<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="一、简介1. 概述ORM（Object-Relational Mapping，对象关系映射） 是一种编程技术，用于在关系型数据库和面向对象编程语言之间建立一座“桥梁”。它的核心思想是将数据库中的**关系数据（表、行、列）与程序中的对象（类、对象、属性）**进行自动化的映射。 简单来说，ORM 框架允许开发者使用操作对象的方式来操作数据库表，而无需手动编写繁琐、重复的 SQL 语句和 JDBC 代码">
<meta property="og:type" content="article">
<meta property="og:title" content="ORM框架">
<meta property="og:url" content="http://example.com/2025/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/ORM%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="一、简介1. 概述ORM（Object-Relational Mapping，对象关系映射） 是一种编程技术，用于在关系型数据库和面向对象编程语言之间建立一座“桥梁”。它的核心思想是将数据库中的**关系数据（表、行、列）与程序中的对象（类、对象、属性）**进行自动化的映射。 简单来说，ORM 框架允许开发者使用操作对象的方式来操作数据库表，而无需手动编写繁琐、重复的 SQL 语句和 JDBC 代码">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-09-24T07:23:30.000Z">
<meta property="article:modified_time" content="2025-10-17T08:08:55.746Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/ORM%E6%A1%86%E6%9E%B6/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/ORM%E6%A1%86%E6%9E%B6/","path":"2025/09/24/数据库与持久化/ORM框架/","title":"ORM框架"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ORM框架 | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%AE%80%E4%BB%8B"><span class="nav-text">一、简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF"><span class="nav-text">2. 核心优势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-ORM-%E7%9A%84%E7%BC%BA%E7%82%B9%E4%B8%8E%E6%8C%91%E6%88%98"><span class="nav-text">3. ORM 的缺点与挑战</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81MyBatis"><span class="nav-text">二、MyBatis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-MyBatis%E7%AE%80%E4%BB%8B%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">1. MyBatis简介与核心思想</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9A%E4%BD%8D"><span class="nav-text">1.1 定义与定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">1.2 核心思想</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-SQL-%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%88%86%E7%A6%BB%EF%BC%8C%E4%B8%93%E6%B3%A8%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91"><span class="nav-text">1.2.1 SQL 与代码分离，专注业务逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E5%BC%80%E5%8F%91%E8%80%85%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8E%A7-SQL%EF%BC%8C%E6%8F%90%E4%BE%9B%E6%9E%81%E8%87%B4%E7%81%B5%E6%B4%BB%E6%80%A7"><span class="nav-text">1.2.2 开发者完全掌控 SQL，提供极致灵活性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E7%AE%80%E5%8C%96-JDBC-%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%BC%98%E9%9B%85%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><span class="nav-text">1.2.3 简化 JDBC 操作，实现优雅的数据访问</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">2. 核心组件与工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-text">2.1 核心组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">2.2 工作流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="nav-text">3. 快速入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="nav-text">3.1 环境准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%88%9B%E5%BB%BAMaven%E9%A1%B9%E7%9B%AE%E5%B9%B6%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96"><span class="nav-text">3.2 创建Maven项目并添加依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="nav-text">3.3 准备数据库和数据表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="nav-text">3.4 创建实体类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E5%88%9B%E5%BB%BAMapper%E6%8E%A5%E5%8F%A3"><span class="nav-text">3.5 创建Mapper接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E5%88%9B%E5%BB%BAMapper-XML%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="nav-text">3.6 创建Mapper XML映射文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-%E5%88%9B%E5%BB%BA-MyBatis-%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-text">3.7 创建 MyBatis 核心配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-text">3.8 编写测试代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-XML%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="nav-text">4. XML映射文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E8%A7%92%E8%89%B2%E4%B8%8E%E7%BB%93%E6%9E%84"><span class="nav-text">4.1 角色与结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-CRUD%E6%93%8D%E4%BD%9C%E6%A0%87%E7%AD%BE"><span class="nav-text">4.2 CRUD操作标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86-vs"><span class="nav-text">4.3 参数处理 (#{} vs ${})</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84"><span class="nav-text">4.4 结果映射 (&lt;resultMap&gt;)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E5%8F%AF%E9%87%8D%E7%94%A8-SQL-%E7%89%87%E6%AE%B5"><span class="nav-text">4.5 可重用 SQL 片段 (&lt;sql&gt;)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%8A%A8%E6%80%81SQL"><span class="nav-text">5. 动态SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8A%A8%E6%80%81-SQL%EF%BC%9F"><span class="nav-text">5.1 为什么需要动态 SQL？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E6%A0%B8%E5%BF%83%E5%8A%A8%E6%80%81-SQL-%E6%A0%87%E7%AD%BE"><span class="nav-text">5.2 核心动态 SQL 标签</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1"><span class="nav-text">5.2.1 &lt;if&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2"><span class="nav-text">5.2.2 &lt;where&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3"><span class="nav-text">5.2.3 &lt;set&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-4"><span class="nav-text">5.2.4 &lt;foreach&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-5"><span class="nav-text">5.2.5 &lt;choose&gt;, &lt;when&gt;, &lt;otherwise&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-6"><span class="nav-text">5.2.6 &lt;trim&gt;</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="nav-text">6. 注解开发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E7%AE%80%E4%BB%8B%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">6.1 简介与适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E5%90%AF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="nav-text">6.2 启用注解开发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E6%A0%B8%E5%BF%83-CRUD-%E6%B3%A8%E8%A7%A3"><span class="nav-text">6.3 核心 CRUD 注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86-Param"><span class="nav-text">6.4 参数处理 (@Param)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-1-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">6.4.1 使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%96%B9%E6%B3%95%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E6%97%B6"><span class="nav-text">1. 方法有多个参数时</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%8F%82%E6%95%B0%E6%98%AF%E9%9B%86%E5%90%88%E6%88%96%E6%95%B0%E7%BB%84%E6%97%B6"><span class="nav-text">2. 参数是集合或数组时</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-2-%E5%8F%AF%E4%BB%A5%E4%B8%8D%E4%BD%BF%E7%94%A8"><span class="nav-text">6.4.2 可以不使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%8D%95%E4%B8%AA%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-text">1. 单个简单类型参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%8D%95%E4%B8%AA-POJO-%E5%AF%B9%E8%B1%A1%E5%8F%82%E6%95%B0"><span class="nav-text">2. 单个 POJO 对象参数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-3-Java-8-%E7%9A%84-parameters-%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9"><span class="nav-text">6.4.3 Java 8 的 -parameters 编译选项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84-Results-Result"><span class="nav-text">6.5 结果映射 (@Results &amp; @Result)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-%E5%8A%A8%E6%80%81-SQL-%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%B1%80%E9%99%90%E4%B8%8E%E6%96%B9%E6%A1%88"><span class="nav-text">6.6 动态 SQL (注解的局限与方案)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-%E6%80%BB%E7%BB%93%EF%BC%9A%E6%B3%A8%E8%A7%A3-vs-XML-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">6.7 总结：注解 vs XML (最佳实践)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-%E5%8E%9F%E7%94%9FMyBatis"><span class="nav-text">7. 适用场景 (原生MyBatis)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-%E6%9E%81%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E8%BF%BD%E6%B1%82%E4%B8%8E%E5%A4%8D%E6%9D%82%E7%9A%84-SQL-%E4%BC%98%E5%8C%96"><span class="nav-text">7.1 极致的性能追求与复杂的 SQL 优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E6%88%96%E5%A4%8D%E6%9D%82%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1"><span class="nav-text">7.2 遗留系统或复杂的数据库设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-%E6%8A%A5%E8%A1%A8%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90"><span class="nav-text">7.3 报表系统与数据分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-%E5%A4%A7%E9%87%8F%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%B9%E6%80%A7"><span class="nav-text">7.4 大量使用存储过程与数据库特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-%E5%AF%B9-SQL-%E6%9C%89%E5%BC%BA%E6%8E%8C%E6%8E%A7%E6%AC%B2%E6%88%96-DBA-%E6%B7%B1%E5%BA%A6%E5%8F%82%E4%B8%8E%E7%9A%84%E9%A1%B9%E7%9B%AE"><span class="nav-text">7.5 对 SQL 有强掌控欲或 DBA 深度参与的项目</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81MyBatis-Plus-%E6%95%88%E7%8E%87%E5%A2%9E%E5%BC%BA"><span class="nav-text">三、MyBatis-Plus (效率增强)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%AE%80%E4%BB%8B%E4%B8%8E%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF"><span class="nav-text">1. 简介与核心优势</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-MyBatis-Plus-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1.1 MyBatis-Plus 是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF"><span class="nav-text">1.2 核心优势</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E6%9E%81%E7%AE%80-CRUD"><span class="nav-text">1.2.1 极简 CRUD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8-Wrapper"><span class="nav-text">1.2.2 强大的条件构造器 (Wrapper)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E5%86%85%E7%BD%AE%E5%AE%9E%E7%94%A8%E6%8F%92%E4%BB%B6%EF%BC%8C%E5%BC%80%E7%AE%B1%E5%8D%B3%E7%94%A8"><span class="nav-text">1.2.3 内置实用插件，开箱即用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8-AutoGenerator"><span class="nav-text">1.2.4 代码生成器 (AutoGenerator)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-5-%E6%97%A0%E4%BE%B5%E5%85%A5%E8%AE%BE%E8%AE%A1%EF%BC%8C%E5%AE%8C%E7%BE%8E%E5%85%BC%E5%AE%B9"><span class="nav-text">1.2.5 无侵入设计，完美兼容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-6-%E5%86%85%E7%BD%AE%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD"><span class="nav-text">1.2.6 内置高级功能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-%E4%B8%8E-Spring-Boot-%E9%9B%86%E6%88%90"><span class="nav-text">2. 快速入门 (与 Spring Boot 集成)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E7%8E%AF%E5%A2%83%E4%B8%8E%E9%A1%B9%E7%9B%AE%E5%87%86%E5%A4%87"><span class="nav-text">2.1 环境与项目准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%B7%BB%E5%8A%A0-MyBatis-Plus-%E4%BE%9D%E8%B5%96"><span class="nav-text">2.2 添加 MyBatis-Plus 依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5"><span class="nav-text">2.3 配置数据库连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BD%93%E7%B1%BB-Entity"><span class="nav-text">2.4 创建实体类 (Entity)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E5%88%9B%E5%BB%BA-Mapper-%E6%8E%A5%E5%8F%A3"><span class="nav-text">2.5 创建 Mapper 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E9%85%8D%E7%BD%AE-Mapper-%E6%89%AB%E6%8F%8F"><span class="nav-text">2.6 配置 Mapper 扫描</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-text">2.7 编写测试代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%80%9A%E7%94%A8-CRUD-BaseMapper-IService"><span class="nav-text">3. 通用 CRUD (BaseMapper &amp; IService)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-BaseMapper-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%B1%82%E7%9A%84%E5%9F%BA%E7%9F%B3"><span class="nav-text">3.1 BaseMapper&lt;T&gt;: 数据访问层的基石</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="nav-text">3.1.1 如何使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%B8%80%E8%A7%88"><span class="nav-text">3.1.2 常用方法一览</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-IService-ServiceImpl-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%B1%82%E7%9A%84%E5%B0%81%E8%A3%85"><span class="nav-text">3.2 IService&lt;T&gt; &amp; ServiceImpl&lt;M, T&gt;: 业务逻辑层的封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="nav-text">3.2.1 如何使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-IService-%E5%A2%9E%E5%BC%BA%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">3.2.2 IService 增强的方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-BaseMapper-vs-IService-%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">3.3 BaseMapper vs IService (总结与最佳实践)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8-Wrapper"><span class="nav-text">4. 条件构造器 (Wrapper)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-QueryWrapper-UpdateWrapper"><span class="nav-text">4.1 QueryWrapper &amp; UpdateWrapper</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-QueryWrapper"><span class="nav-text">4.1.1 QueryWrapper&lt;T&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="nav-text">1. 核心方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">2. 使用示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-UpdateWrapper"><span class="nav-text">4.1.2 UpdateWrapper&lt;T&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95-1"><span class="nav-text">1. 核心方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-1"><span class="nav-text">2. 使用示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-LambdaQueryWrapper-LambdaUpdateWrapper"><span class="nav-text">4.2 LambdaQueryWrapper &amp; LambdaUpdateWrapper</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Lambda-Wrapper%EF%BC%9F"><span class="nav-text">4.2.1 为什么需要 Lambda Wrapper？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">4.2.2 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-LambdaQueryWrapper"><span class="nav-text">4.2.3 LambdaQueryWrapper&lt;T&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-4-LambdaUpdateWrapper"><span class="nav-text">4.2.4 LambdaUpdateWrapper&lt;T&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-5-%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">4.2.5 总结与最佳实践</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-text">4.3 常用查询方法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E6%9F%A5%E8%AF%A2%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1-selectOne"><span class="nav-text">4.3.1 查询单个对象: selectOne()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%E6%9F%A5%E8%AF%A2%E5%AF%B9%E8%B1%A1%E5%88%97%E8%A1%A8-selectList"><span class="nav-text">4.3.2 查询对象列表: selectList()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-%E6%9F%A5%E8%AF%A2%E8%AE%B0%E5%BD%95%E6%80%BB%E6%95%B0-selectCount"><span class="nav-text">4.3.3 查询记录总数: selectCount()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-4-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2-selectPage"><span class="nav-text">4.3.4 分页查询: selectPage()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-5-%E6%A3%80%E6%9F%A5%E5%AD%98%E5%9C%A8%E6%80%A7-exists-MP-3-5-3-%E7%89%88%E6%9C%AC"><span class="nav-text">4.3.5 检查存在性: exists() (MP 3.5.3+ 版本)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%A0%B8%E5%BF%83%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="nav-text">5. 核心插件机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6-PaginationInnerInterceptor"><span class="nav-text">5.1 分页插件 (PaginationInnerInterceptor)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%EF%BC%9F"><span class="nav-text">5.1.1 为什么需要分页插件？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-%E6%8F%92%E4%BB%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="nav-text">5.1.2 插件的核心原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE-Spring-Boot"><span class="nav-text">5.1.3 如何配置 (Spring Boot)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="nav-text">5.1.4 如何使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-5-%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">5.1.5 总结与注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E4%B9%90%E8%A7%82%E9%94%81%E6%8F%92%E4%BB%B6-OptimisticLockerInnerInterceptor"><span class="nav-text">5.2 乐观锁插件 (OptimisticLockerInnerInterceptor)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">5.2.1 乐观锁的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-%E5%A6%82%E4%BD%95%E5%9C%A8-MyBatis-Plus-%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="nav-text">5.2.2 如何在 MyBatis-Plus 中使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">5.2.3 使用示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-4-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">5.2.4 适用场景与注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8-AutoGenerator"><span class="nav-text">6. 代码生成器 (AutoGenerator)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E4%BC%98%E5%8A%BF"><span class="nav-text">6.1 核心功能与优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="nav-text">6.2 如何使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-text">6.3 示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%A6%E8%A7%A3-strategyConfig"><span class="nav-text">6.4 核心配置项详解 (strategyConfig)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">6.5 最佳实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="nav-text">7. 高级特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4"><span class="nav-text">7.1 逻辑删除</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4%EF%BC%9F"><span class="nav-text">7.1.1 什么是逻辑删除？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4%EF%BC%9F"><span class="nav-text">7.1.2 为什么使用逻辑删除？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-3-MyBatis-Plus-%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">7.1.3 MyBatis-Plus 中的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-4-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-text">7.1.4 如何配置和使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-5-%E5%AE%9E%E9%99%85%E6%95%88%E6%9E%9C"><span class="nav-text">7.1.5 实际效果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-6-%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2%E8%A2%AB%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-text">7.1.6 如何查询被逻辑删除的数据？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85-MetaObjectHandler"><span class="nav-text">7.2 自动填充 (MetaObjectHandler)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="nav-text">7.2.1 核心思想与原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-2-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="nav-text">7.2.2 如何使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-3-%E5%AE%9E%E9%99%85%E6%95%88%E6%9E%9C"><span class="nav-text">7.2.3 实际效果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-4-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%93%8D%E4%BD%9C%E4%BA%BA"><span class="nav-text">7.2.4 获取当前操作人</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E4%B8%BB%E9%94%AE%E7%AD%96%E7%95%A5"><span class="nav-text">7.3 主键策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">7.3.1 简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-2-%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="nav-text">7.3.2 配置方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-3-%E6%A0%B8%E5%BF%83%E4%B8%BB%E9%94%AE%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3"><span class="nav-text">7.3.3 核心主键策略详解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-IdType-AUTO-%E6%95%B0%E6%8D%AE%E5%BA%93ID%E8%87%AA%E5%A2%9E"><span class="nav-text">1. IdType.AUTO (数据库ID自增)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-IdType-ASSIGN-ID-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95-%E9%BB%98%E8%AE%A4-%E6%8E%A8%E8%8D%90"><span class="nav-text">2. IdType.ASSIGN_ID (雪花算法, 默认&#x2F;推荐)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-IdType-ASSIGN-UUID-UUID"><span class="nav-text">3. IdType.ASSIGN_UUID (UUID)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-IdType-INPUT-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5"><span class="nav-text">4. IdType.INPUT (用户输入)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-IdType-NONE-%E6%97%A0%E7%8A%B6%E6%80%81"><span class="nav-text">5. IdType.NONE (无状态)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-IdType-SEQUENCE-%E5%BA%8F%E5%88%97"><span class="nav-text">6. IdType.SEQUENCE (序列)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-4-%E5%85%A8%E5%B1%80%E4%B8%BB%E9%94%AE%E7%AD%96%E7%95%A5%E9%85%8D%E7%BD%AE"><span class="nav-text">7.3.4 全局主键策略配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-5-%E7%AD%96%E7%95%A5%E9%80%89%E5%9E%8B%E6%80%BB%E7%BB%93"><span class="nav-text">7.3.5 策略选型总结</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81JPA-Hibernate"><span class="nav-text">四、JPA &amp; Hibernate</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-JPA-%E8%A7%84%E8%8C%83%E4%B8%8E-Hibernate-%E5%AE%9E%E7%8E%B0"><span class="nav-text">1. JPA 规范与 Hibernate 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF-JPA-Java-Persistence-API-%EF%BC%9F"><span class="nav-text">1.1 什么是 JPA (Java Persistence API)？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E4%BB%80%E4%B9%88%E6%98%AF-Hibernate%EF%BC%9F"><span class="nav-text">1.2 什么是 Hibernate？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E4%B8%A4%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A%E8%A7%84%E8%8C%83%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-text">1.3 两者的关系：规范与实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%80%9A%E5%B8%B8%E5%B0%86%E5%AE%83%E4%BB%AC%E4%B8%80%E8%B5%B7%E6%8F%90%E5%8F%8A%EF%BC%9F"><span class="nav-text">1.4 为什么我们通常将它们一起提及？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">2. 核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%AE%9E%E4%BD%93-Entity"><span class="nav-text">2.1 实体 (Entity)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-EntityManagerFactory-%E5%AE%9E%E4%BD%93%E7%AE%A1%E7%90%86%E5%99%A8%E5%B7%A5%E5%8E%82"><span class="nav-text">2.2 EntityManagerFactory (实体管理器工厂)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-EntityManager-%E5%AE%9E%E4%BD%93%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-text">2.3 EntityManager (实体管理器)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87-Persistence-Context"><span class="nav-text">2.4 持久化上下文 (Persistence Context)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E5%AE%9E%E4%BD%93%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-Entity-Lifecycle"><span class="nav-text">2.5 实体生命周期 (Entity Lifecycle)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E4%BA%8B%E5%8A%A1-Transaction"><span class="nav-text">2.6 事务 (Transaction)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-1"><span class="nav-text">3. 快速入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E7%8E%AF%E5%A2%83%E4%B8%8E%E9%A1%B9%E7%9B%AE%E5%87%86%E5%A4%87"><span class="nav-text">3.1 环境与项目准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5"><span class="nav-text">3.2 配置数据库连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BD%93%E7%B1%BB-Entity"><span class="nav-text">3.3 创建实体类 (Entity)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%88%9B%E5%BB%BA-Repository-%E6%8E%A5%E5%8F%A3"><span class="nav-text">3.4 创建 Repository 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-text">3.5 编写测试代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%AE%9E%E4%BD%93%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84"><span class="nav-text">4. 实体关系映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">4.1 基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%A4%9A%E5%AF%B9%E4%B8%80-ManyToOne-%E4%B8%80%E5%AF%B9%E5%A4%9A-OneToMany"><span class="nav-text">4.2 多对一 (ManyToOne) &amp; 一对多 (OneToMany)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E4%B8%80%E5%AF%B9%E4%B8%80-OneToOne"><span class="nav-text">4.3 一对一 (OneToOne)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E5%A4%9A%E5%AF%B9%E5%A4%9A-ManyToMany"><span class="nav-text">4.4 多对多 (ManyToMany)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">4.5 总结与最佳实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-JPQL-Java-Persistence-Query-Language"><span class="nav-text">5. JPQL (Java Persistence Query Language)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E4%BB%80%E4%B9%88%E6%98%AF-JPQL%EF%BC%9F"><span class="nav-text">5.1 什么是 JPQL？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-JPQL-%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF"><span class="nav-text">5.2 JPQL 的核心优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-JPQL-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-text">5.3 JPQL 基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1-SELECT-%E6%9F%A5%E8%AF%A2"><span class="nav-text">5.3.1 SELECT 查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-UPDATE-%E5%92%8C-DELETE-%E6%9F%A5%E8%AF%A2"><span class="nav-text">5.3.2 UPDATE 和 DELETE 查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2-JOIN"><span class="nav-text">5.4 连接查询 (JOIN)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E5%9C%A8-Spring-Data-JPA-%E4%B8%AD%E4%BD%BF%E7%94%A8-JPQL"><span class="nav-text">5.5 在 Spring Data JPA 中使用 JPQL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Spring-Data-JPA"><span class="nav-text">6. Spring Data JPA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E4%BB%80%E4%B9%88%E6%98%AF-Spring-Data-JPA%EF%BC%9F"><span class="nav-text">6.1 什么是 Spring Data JPA？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E4%B8%8E%E4%BC%98%E5%8A%BF"><span class="nav-text">6.2 核心特性与优势</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%BC%BA%E5%A4%A7%E7%9A%84-Repository-%E6%8A%BD%E8%B1%A1-JpaRepository"><span class="nav-text">1. 强大的 Repository 抽象 (JpaRepository)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%96%B9%E6%B3%95%E5%91%BD%E5%90%8D%E6%9F%A5%E8%AF%A2-Query-Methods-Derived-Queries"><span class="nav-text">2. 方法命名查询 (Query Methods &#x2F; Derived Queries)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8-Query-%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9F%A5%E8%AF%A2"><span class="nav-text">3. 使用 @Query 注解自定义查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%8A%A8%E6%80%81%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81-JPA-Criteria-API-QueryDSL"><span class="nav-text">4. 动态查询支持 (JPA Criteria API &amp; QueryDSL)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E7%AE%80%E5%8C%96%E7%9A%84%E5%88%86%E9%A1%B5%E4%B8%8E%E6%8E%92%E5%BA%8F"><span class="nav-text">5. 简化的分页与排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E4%B8%8E-MyBatis-MyBatis-Plus-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-text">6.3 与 MyBatis&#x2F;MyBatis-Plus 的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E6%80%BB%E7%BB%93"><span class="nav-text">6.4 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">7. 适用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JPA-Hibernate-%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF%E5%9C%A8%E4%BA%8E%EF%BC%9A"><span class="nav-text">JPA &amp; Hibernate 的核心优势在于：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%96%B0%E9%A1%B9%E7%9B%AE%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%8E%9F%E5%9E%8B%E5%BC%80%E5%8F%91"><span class="nav-text">1. 新项目与快速原型开发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-CRUD-%E5%AF%86%E9%9B%86%E5%9E%8B%E7%9A%84%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F"><span class="nav-text">2. CRUD 密集型的业务系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E9%9C%80%E8%A6%81%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E6%88%96%E6%9C%AA%E6%9D%A5%E5%8F%AF%E8%83%BD%E6%9B%B4%E6%8D%A2%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%A1%B9%E7%9B%AE"><span class="nav-text">3. 需要支持多种数据库或未来可能更换数据库的项目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-DDD-%E5%AE%9E%E8%B7%B5"><span class="nav-text">4. 领域驱动设计 (DDD) 实践</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%9B%A2%E9%98%9F%E6%88%90%E5%91%98%E5%AF%B9-SQL-%E4%B8%8D%E5%A4%9F%E7%B2%BE%E9%80%9A%E6%88%96%E5%B8%8C%E6%9C%9B%E5%B1%8F%E8%94%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%86%E8%8A%82"><span class="nav-text">5. 团队成员对 SQL 不够精通或希望屏蔽数据库细节</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81ORM-%E8%BF%9B%E9%98%B6%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">五、ORM 进阶与最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-N-1-%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98"><span class="nav-text">1. N+1 查询问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-MyBatis-%E4%B8%8E-MyBatis-Plus-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">1.1 MyBatis 与 MyBatis-Plus 解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E5%9C%A8-MyBatis-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F-N-1-%E9%97%AE%E9%A2%98"><span class="nav-text">1.1.1 在 MyBatis 中如何产生 N+1 问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-MyBatis-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">1.1.2 MyBatis 解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9A%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2-Join-Query"><span class="nav-text">方案一：连接查询 (Join Query)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9A%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD-Nested-Selects-Lazy-Loading"><span class="nav-text">方案二：分步查询 + 延迟加载 (Nested Selects + Lazy Loading)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-MyBatis-Plus-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">1.1.3 MyBatis-Plus 解决方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-JPA-Hibernate-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">1.2 JPA&#x2F;Hibernate 解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E5%9C%A8-JPA-Hibernate-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F-N-1-%E9%97%AE%E9%A2%98"><span class="nav-text">1.2.1 在 JPA&#x2F;Hibernate 中如何产生 N+1 问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-JPA-Hibernate-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">1.2.2 JPA&#x2F;Hibernate 解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9AJPQL-JOIN-FETCH-%E6%9C%80%E5%B8%B8%E7%94%A8%EF%BC%8C%E6%9C%80%E6%8E%A8%E8%8D%90"><span class="nav-text">方案一：JPQL JOIN FETCH (最常用，最推荐)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9A%E5%AE%9E%E4%BD%93%E5%9B%BE-EntityGraph"><span class="nav-text">方案二：实体图 (@EntityGraph)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%B8%89%EF%BC%9A%E6%89%B9%E5%A4%84%E7%90%86%E6%8A%93%E5%8F%96-BatchSize"><span class="nav-text">方案三：批处理抓取 (@BatchSize)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="nav-text">2. 缓存机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-text">2.1 一级缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="nav-text">2.1.1 定义与核心特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-MyBatis-%E4%B8%AD%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-text">2.1.2 MyBatis 中的一级缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-JPA-Hibernate-%E4%B8%AD%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-text">2.1.3 JPA&#x2F;Hibernate 中的一级缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-text">2.1.4 一级缓存的意义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-text">2.2 二级缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="nav-text">2.2.1 定义与核心特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-MyBatis-%E4%B8%AD%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-text">2.2.2 MyBatis 中的二级缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%BC%80%E5%90%AF%E6%AD%A5%E9%AA%A4"><span class="nav-text">1. 开启步骤:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">2. 工作流程:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88"><span class="nav-text">3. 缓存失效:</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-JPA-Hibernate-%E4%B8%AD%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-text">2.2.3 JPA&#x2F;Hibernate 中的二级缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%BC%80%E5%90%AF%E6%AD%A5%E9%AA%A4-1"><span class="nav-text">1. 开启步骤:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Hibernate-%E7%BC%93%E5%AD%98%E5%B9%B6%E5%8F%91%E7%AD%96%E7%95%A5-CacheConcurrencyStrategy"><span class="nav-text">2. Hibernate 缓存并发策略 (CacheConcurrencyStrategy):</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98-Query-Cache"><span class="nav-text">3. 查询缓存 (Query Cache)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E7%BC%93%E5%AD%98%E7%9A%84%E6%84%8F%E4%B9%89%E3%80%81%E9%A3%8E%E9%99%A9%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="nav-text">2.3 缓存的意义、风险与配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E7%BC%93%E5%AD%98%E7%9A%84%E6%84%8F%E4%B9%89-Why-use-cache"><span class="nav-text">2.3.1 缓存的意义 (Why use cache?)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E7%BC%93%E5%AD%98%E7%9A%84%E9%A3%8E%E9%99%A9%E4%B8%8E%E6%8C%91%E6%88%98-Risks-and-Challenges"><span class="nav-text">2.3.2 缓存的风险与挑战 (Risks and Challenges)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98"><span class="nav-text">2.3.3 如何合理配置与使用缓存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-text">3. 事务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-ORM%E6%A1%86%E6%9E%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90"><span class="nav-text">3.1 ORM框架与事务如何集成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E7%9A%84%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3"><span class="nav-text">3.1.1 事务管理的核心职责</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E9%9B%86%E6%88%90%E6%96%B9%E5%BC%8F"><span class="nav-text">3.1.2 集成方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1-Programmatic-Transaction-Management"><span class="nav-text">1. 编程式事务 (Programmatic Transaction Management)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1-Declarative-Transaction-Management-%E4%B8%BB%E6%B5%81%E6%96%B9%E5%BC%8F"><span class="nav-text">2. 声明式事务 (Declarative Transaction Management) - (主流方式)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-%E6%80%BB%E7%BB%93"><span class="nav-text">3.1.3 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">3.2 声明式事务的工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-text">3.2.1 核心组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E8%AF%A6%E7%BB%86%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">3.2.2 详细工作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E4%B8%BA%E4%BB%80%E4%B9%88-Transactional-%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="nav-text">3.2.3 为什么 @Transactional 会失效？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="nav-text">3.3 事务的隔离级别与传播行为</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-Isolation-Level"><span class="nav-text">3.3.1 事务的隔离级别 (Isolation Level)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA-Propagation-Behavior"><span class="nav-text">3.3.2 事务的传播行为 (Propagation Behavior)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-REQUIRED-%E9%BB%98%E8%AE%A4"><span class="nav-text">1. REQUIRED (默认)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-REQUIRES-NEW"><span class="nav-text">2. REQUIRES_NEW</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-ORM%E6%A1%86%E6%9E%B6%E9%80%89%E5%9E%8B"><span class="nav-text">4. ORM框架选型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%A0%B8%E5%BF%83%E5%B7%AE%E5%BC%82%E5%AF%B9%E6%AF%94"><span class="nav-text">4.1 核心差异对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%A6%82%E4%BD%95%E5%81%9A%E5%87%BA%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="nav-text">4.2 如何做出选择？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E9%80%89%E6%8B%A9-MyBatis-MyBatis-Plus-%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="nav-text">4.2.1 选择 MyBatis &#x2F; MyBatis-Plus 的场景：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E9%80%89%E6%8B%A9-JPA-Hibernate-%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="nav-text">4.2.2 选择 JPA &#x2F; Hibernate 的场景：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%9A%E4%B8%80%E7%A7%8D%E5%8A%A1%E5%AE%9E%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-text">4.3 混合使用：一种务实的选择</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/ORM%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="ORM框架 | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ORM框架
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-24 15:23:30" itemprop="dateCreated datePublished" datetime="2025-09-24T15:23:30+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 16:08:55" itemprop="dateModified" datetime="2025-10-17T16:08:55+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">数据库与持久化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><strong>ORM（Object-Relational Mapping，对象关系映射）</strong> 是一种编程技术，用于在<strong>关系型数据库</strong>和<strong>面向对象编程语言</strong>之间建立一座“桥梁”。它的核心思想是将数据库中的**关系数据（表、行、列）<strong>与程序中的</strong>对象（类、对象、属性）**进行自动化的映射。</p>
<p>简单来说，ORM 框架允许开发者<strong>使用操作对象的方式来操作数据库表</strong>，而无需手动编写繁琐、重复的 SQL 语句和 JDBC 代码。</p>
<ul>
<li><strong>O (Object):</strong> 指的是我们编程语言中的对象，例如一个 Java 类 <code>User</code>。</li>
<li><strong>R (Relational):</strong> 指的是关系型数据库，例如 MySQL 中的一张表 <code>users</code>。</li>
<li><strong>M (Mapping):</strong> 指的是 ORM 框架建立的映射规则，它告诉程序：<ul>
<li><code>User</code> 类 对应 <code>users</code> 表。</li>
<li><code>User</code> 类的 <code>id</code> 属性 对应 <code>users</code> 表的 <code>id</code> 字段。</li>
<li><code>User</code> 类的 <code>username</code> 属性 对应 <code>users</code> 表的 <code>username</code> 字段。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-核心优势"><a href="#2-核心优势" class="headerlink" title="2. 核心优势"></a>2. 核心优势</h2><p>在没有 ORM 的时代，我们使用原生 JDBC 来与数据库交互，代码通常是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码：原生 JDBC 查询</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    conn = DriverManager.getConnection(...);</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, username, password FROM users WHERE id = ?&quot;</span>;</span><br><span class="line">    ps = conn.prepareStatement(sql);</span><br><span class="line">    ps.setInt(<span class="number">1</span>, <span class="number">101</span>);</span><br><span class="line">    rs = ps.executeQuery();</span><br><span class="line">    <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        user.setUsername(rs.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        user.setPassword(rs.getString(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">        <span class="comment">// ... 使用 user 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 繁琐的资源关闭</span></span><br><span class="line">    <span class="keyword">if</span> (rs != <span class="literal">null</span>) rs.close();</span><br><span class="line">    <span class="keyword">if</span> (ps != <span class="literal">null</span>) ps.close();</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="literal">null</span>) conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 ORM 框架后，代码变得极其简洁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码：使用 ORM 框架查询</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.findUserById(<span class="number">101</span>);</span><br><span class="line"><span class="comment">// ... 直接使用 user 对象</span></span><br></pre></td></tr></table></figure>

<p><strong>ORM 的主要优势：</strong></p>
<ol>
<li><strong>提高开发效率</strong>：将开发者从繁琐的 SQL 编写、参数设置、结果集映射等重复性劳动中解放出来，专注于业务逻辑。</li>
<li><strong>代码更简洁、可读性更高</strong>：用面向对象的方式操作数据，使得业务逻辑更加清晰。</li>
<li><strong>更好的可维护性</strong>：<ul>
<li><strong>解耦</strong>：将数据访问层与业务逻辑层解耦。</li>
<li><strong>易于修改</strong>：当数据库表结构发生微小变化时（如增加一个字段），通常只需修改映射关系和对象类，而不用深入到每个 SQL 语句中去修改。</li>
</ul>
</li>
<li><strong>数据库无关性</strong>：优秀的 ORM 框架支持多种数据库。当需要更换数据库时（如从 MySQL 切换到 PostgreSQL），通常只需修改配置文件，而无需修改大量的业务代码和 SQL 语句。</li>
<li><strong>内置高级功能</strong>：许多 ORM 框架内置了缓存、懒加载、事务管理等高级功能，简化了复杂应用的开发。</li>
</ol>
<hr>
<h2 id="3-ORM-的缺点与挑战"><a href="#3-ORM-的缺点与挑战" class="headerlink" title="3. ORM 的缺点与挑战"></a>3. ORM 的缺点与挑战</h2><ol>
<li><strong>性能开销</strong>：ORM 框架在对象和 SQL 之间增加了一个抽象层，这会带来一定的性能损失。对于性能要求极高的场景，手写优化的 SQL 可能效率更高。</li>
<li><strong>学习成本</strong>：需要学习 ORM 框架本身的使用方法、API 和配置。</li>
<li><strong>复杂查询的挑战</strong>：对于非常复杂的多表连接、统计报表等查询，使用 ORM 可能变得笨拙，甚至不如直接编写原生 SQL 灵活和高效。</li>
<li><strong>“黑盒”问题</strong>：ORM 可能会隐藏底层的 SQL 执行细节，导致开发者不清楚实际执行了哪些 SQL，可能会产生意料之外的性能问题（如下一节的 <code>N+1</code> 查询问题）。</li>
</ol>
<hr>
<hr>
<h1 id="二、MyBatis"><a href="#二、MyBatis" class="headerlink" title="二、MyBatis"></a>二、MyBatis</h1><h2 id="1-MyBatis简介与核心思想"><a href="#1-MyBatis简介与核心思想" class="headerlink" title="1. MyBatis简介与核心思想"></a>1. MyBatis简介与核心思想</h2><h3 id="1-1-定义与定位"><a href="#1-1-定义与定位" class="headerlink" title="1.1 定义与定位"></a>1.1 定义与定位</h3><p><strong>MyBatis</strong> 是一个优秀的 <strong>持久层框架</strong>，它支持自定义 SQL、存储过程以及高级映射。与传统的全自动 ORM 框架（如 Hibernate）不同，MyBatis 并非完全将开发者与 SQL 隔离开，而是让开发者能够完全掌控 SQL 的编写。因此，它通常被定位为 <strong>“半自动 ORM” (Semi-ORM)</strong> 或 <strong>“SQL 映射器” (SQL Mapper)</strong>。</p>
<p>它的核心任务是：将 <strong>Java 对象 (POJO)</strong> 与 <strong>SQL 语句</strong> 进行映射，从而将繁琐的 JDBC 操作（如创建连接、设置参数、处理结果集、关闭资源等）自动化，让开发者可以更专注于 SQL 本身。</p>
<hr>
<h3 id="1-2-核心思想"><a href="#1-2-核心思想" class="headerlink" title="1.2 核心思想"></a>1.2 核心思想</h3><h4 id="1-2-1-SQL-与代码分离，专注业务逻辑"><a href="#1-2-1-SQL-与代码分离，专注业务逻辑" class="headerlink" title="1.2.1 SQL 与代码分离，专注业务逻辑"></a>1.2.1 SQL 与代码分离，专注业务逻辑</h4><p>这是 MyBatis 最核心的思想。它主张将 SQL 语句从 Java 代码中抽离出来，统一配置在 XML 映射文件中（或使用注解）。</p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>解耦</strong>：业务逻辑（Java 代码）与数据访问逻辑（SQL）分离，使得代码更清晰、更易于维护。</li>
<li><strong>便于管理与优化</strong>：DBA 或 SQL 专家可以独立地审查和优化 SQL，而无需关心 Java 代码的实现细节。</li>
<li><strong>提高可维护性</strong>：当 SQL 逻辑需要调整时，通常只需要修改 XML 文件，而不需要重新编译 Java 代码。</li>
</ul>
<hr>
<h4 id="1-2-2-开发者完全掌控-SQL，提供极致灵活性"><a href="#1-2-2-开发者完全掌控-SQL，提供极致灵活性" class="headerlink" title="1.2.2 开发者完全掌控 SQL，提供极致灵活性"></a>1.2.2 开发者完全掌控 SQL，提供极致灵活性</h4><p>与 Hibernate (后续章节详细讲解) 这类全自动 ORM 框架自动生成 SQL 不同，MyBatis 将 SQL 的编写权完全交还给开发者。</p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>性能优化</strong>：开发者可以根据具体的业务场景编写最高效、最复杂的 SQL，包括多表连接、子查询、调用存储过程、使用数据库特性函数等。这对于性能要求极高的场景至关重要。</li>
<li><strong>应对复杂需求</strong>：对于复杂的报表查询或特定业务逻辑，自动生成的 SQL 往往难以满足需求或效率低下，手动编写 SQL 则能轻松应对。</li>
<li><strong>易于过渡</strong>：对于熟悉 SQL 的开发者来说，学习曲线非常平缓，可以快速上手。</li>
</ul>
<hr>
<h4 id="1-2-3-简化-JDBC-操作，实现优雅的数据访问"><a href="#1-2-3-简化-JDBC-操作，实现优雅的数据访问" class="headerlink" title="1.2.3 简化 JDBC 操作，实现优雅的数据访问"></a>1.2.3 简化 JDBC 操作，实现优雅的数据访问</h4><p>MyBatis 极大地简化了基于 JDBC 的编程模型，封装了所有冗余的“样板代码”。</p>
<p><strong>封装内容</strong>：</p>
<ul>
<li><strong>参数映射</strong>：自动将传入的 Java 对象属性映射到 SQL 语句的参数中（<code>PreparedStatement</code> 的 <code>?</code> 占位符）。</li>
<li><strong>结果集映射</strong>：自动将查询返回的结果集（<code>ResultSet</code>）映射到 Java 对象、List 或 Map 中。</li>
<li><strong>资源管理</strong>：自动处理数据库连接的获取、使用和关闭。</li>
<li><strong>异常处理</strong>：将 JDBC 的 <code>SQLException</code> 转换为更易于处理的非检查性异常。</li>
</ul>
<hr>
<h2 id="2-核心组件与工作流程"><a href="#2-核心组件与工作流程" class="headerlink" title="2. 核心组件与工作流程"></a>2. 核心组件与工作流程</h2><h3 id="2-1-核心组件"><a href="#2-1-核心组件" class="headerlink" title="2.1 核心组件"></a>2.1 核心组件</h3><p>MyBatis 的架构由几个核心组件构成，每个组件都扮演着不可或缺的角色。</p>
<ol>
<li><strong>Configuration (配置)</strong><ul>
<li><strong>描述</strong>：MyBatis 的所有配置信息都保存在一个 <code>Configuration</code> 对象中。它包含了从数据源、事务管理器到类型别名、映射器（Mapper）等所有设置。</li>
<li><strong>来源</strong>：通常由主配置文件 <code>mybatis-config.xml</code> 和各个映射文件 <code>*.xml</code> 解析而来。</li>
</ul>
</li>
<li><strong>SqlSessionFactoryBuilder (构建器)</strong><ul>
<li><strong>描述</strong>：这是一个“一次性”的类，它的唯一作用就是根据配置信息（通常是一个 XML 配置文件的输入流）来构建一个 <code>SqlSessionFactory</code>。一旦创建了 <code>SqlSessionFactory</code>，这个构建器就不再需要了。</li>
<li><strong>生命周期</strong>：方法作用域（用完即可丢弃）。</li>
</ul>
</li>
<li><strong>SqlSessionFactory (会话工厂)</strong><ul>
<li><strong>描述</strong>：这是 MyBatis 的核心入口，类似于一个数据库连接池的工厂。它的主要职责是创建 <code>SqlSession</code> 实例。由于 <code>SqlSessionFactory</code> 的创建过程需要解析 XML 并进行初始化，这是一个昂贵的操作，因此它在应用程序的整个生命周期中通常只存在一个实例（单例模式）。</li>
<li><strong>生命周期</strong>：应用作用域（Application Scope）。</li>
</ul>
</li>
<li><strong>SqlSession (会话)</strong><ul>
<li><strong>描述</strong>：这是应用程序与数据库进行交互的主要接口。你可以通过 <code>SqlSession</code> 实例来执行 SQL 命令、获取 Mapper 代理对象以及管理事务。它封装了底层的 JDBC 连接。</li>
<li><strong>重要特性</strong>：<strong><code>SqlSession</code> 是线程不安全的</strong>，因此绝不能在多个线程之间共享。最佳实践是将其生命周期限制在单个请求或方法作用域内，用完后必须关闭（<code>try-with-resources</code> 是一个很好的选择）。</li>
<li><strong>生命周期</strong>：请求或方法作用域。</li>
</ul>
</li>
<li><strong>Executor (执行器)</strong><ul>
<li><strong>描述</strong>：<code>SqlSession</code> 内部的真正执行者。所有 SQL 的执行（查询、更新、存储过程调用）都是由 <code>Executor</code> 完成的。它负责处理参数映射、SQL 动态解析、执行 SQL，并与缓存机制（一级缓存）紧密交互。</li>
<li><strong>类型</strong>：MyBatis 提供了几种执行器，如 <code>SimpleExecutor</code>（默认）、<code>ReuseExecutor</code>（重用 <code>PreparedStatement</code>）、<code>BatchExecutor</code>（批量执行）。</li>
</ul>
</li>
<li><strong>Mapped Statement (映射语句)</strong><ul>
<li><strong>描述</strong>：一个封装了单条 SQL 语句所有信息的对象，包括 SQL 文本、输入参数类型、输出结果类型等。它是在解析 XML 映射文件或注解时创建的。<code>Configuration</code> 对象中会有一个 Map 存储所有 <code>MappedStatement</code>，其键（key）通常是 <code>namespace + id</code>（例如 <code>com.example.UserMapper.selectById</code>）。</li>
</ul>
</li>
<li><strong>Handler (处理器)</strong><ul>
<li><strong>描述</strong>：MyBatis 底层使用一系列处理器来完成具体的 JDBC 操作。</li>
<li><strong><code>ParameterHandler</code></strong>：负责将用户传入的参数设置到 <code>PreparedStatement</code> 中。</li>
<li><strong><code>ResultSetHandler</code></strong>：负责将 <code>ResultSet</code> 的查询结果集转换成 Java 对象（POJO）。</li>
<li><strong><code>StatementHandler</code></strong>：负责封装和管理底层的 <code>java.sql.Statement</code> 操作，包括创建 <code>Statement</code>、设置参数和执行 SQL。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-2-工作流程"><a href="#2-2-工作流程" class="headerlink" title="2.2 工作流程"></a>2.2 工作流程</h3><p>下面以一次典型的查询调用（<code>userMapper.selectById(1)</code>）为例，串联起上述核心组件的工作流程。</p>
<p><strong>整体流程示例:</strong><code>应用程序 -&gt; SqlSession -&gt; Executor -&gt; StatementHandler -&gt; 数据库</code></p>
<p><strong>详细步骤:</strong></p>
<ol>
<li><strong>加载配置与初始化 (应用启动时)</strong><ul>
<li>应用程序通过 <code>SqlSessionFactoryBuilder</code> 读取 <code>mybatis-config.xml</code> 和所有映射器 XML 文件。</li>
<li><code>Builder</code> 解析这些文件，创建一个包含所有配置信息的 <code>Configuration</code> 对象。</li>
<li>最后，<code>Builder</code> 使用这个 <code>Configuration</code> 对象创建一个唯一的 <code>SqlSessionFactory</code> 实例。</li>
</ul>
</li>
<li><strong>创建 SqlSession (请求开始时)</strong><ul>
<li>当需要进行数据库操作时，应用程序代码从 <code>SqlSessionFactory</code> 中获取一个 <code>SqlSession</code> 实例。</li>
<li><code>SqlSessionFactory</code> 在创建 <code>SqlSession</code> 时，会根据配置为其创建一个 <code>Executor</code>（执行器）。</li>
</ul>
</li>
<li><strong>获取 Mapper 代理对象</strong><ul>
<li>应用程序调用 <code>sqlSession.getMapper(UserMapper.class)</code>。</li>
<li>MyBatis 会使用 JDK 动态代理为 <code>UserMapper</code> 接口生成一个代理实现类。这个代理对象将所有接口方法的调用都转发给 <code>SqlSession</code> 内部的相应方法。</li>
</ul>
</li>
<li><strong>执行 Mapper 方法</strong><ul>
<li>当代码调用 <code>userMapper.selectById(1)</code> 时，实际上是调用了代理对象的方法。</li>
<li>代理对象会通过 <code>SqlSession</code> 找到并执行对应的 SQL。具体来说，它会调用 <code>sqlSession.selectOne(&quot;com.example.UserMapper.selectById&quot;, 1)</code>。</li>
</ul>
</li>
<li><strong>Executor 执行查询</strong><ul>
<li><code>SqlSession</code> 将请求委托给内部的 <code>Executor</code>。</li>
<li><strong>一级缓存检查</strong>：<code>Executor</code> 首先会检查一级缓存（Session 级别的缓存）中是否存在相同的查询结果。如果命中，则直接返回缓存中的数据，不再查询数据库。</li>
<li><strong>创建 Statement</strong>：如果缓存未命中，<code>Executor</code> 会从 <code>Configuration</code> 中获取 ID 为 <code>com.example.UserMapper.selectById</code> 的 <code>MappedStatement</code> 对象。</li>
<li><code>Executor</code> 通过 <code>StatementHandler</code> 来准备 SQL 语句。如果 SQL 是动态的，此时会进行解析和拼接。</li>
</ul>
</li>
<li><strong>参数设置与 SQL 执行</strong><ul>
<li><code>StatementHandler</code> 使用 <code>ParameterHandler</code> 将传入的参数（<code>id=1</code>）安全地设置到 <code>PreparedStatement</code> 的占位符上。</li>
<li><code>StatementHandler</code> 调用 JDBC 的 <code>execute()</code> 或 <code>executeQuery()</code> 方法，向数据库发送 SQL 请求。</li>
</ul>
</li>
<li><strong>结果集映射</strong><ul>
<li>数据库返回 <code>ResultSet</code> 结果集。</li>
<li><code>StatementHandler</code> 使用 <code>ResultSetHandler</code> 来处理这个结果集。</li>
<li><code>ResultSetHandler</code> 根据 <code>MappedStatement</code> 中定义的 <code>&lt;resultMap&gt;</code> 或结果类型，将 <code>ResultSet</code> 中的每一行数据转换成一个 Java 对象（如 <code>User</code> 对象）。</li>
</ul>
</li>
<li><strong>返回结果与缓存</strong><ul>
<li><code>Executor</code> 接收到 <code>ResultSetHandler</code> 返回的 Java 对象列表。</li>
<li><code>Executor</code> 将查询结果存入一级缓存中，以备后续相同的查询使用。</li>
<li>结果最终被返回给调用者（应用程序）。</li>
</ul>
</li>
<li><strong>关闭 SqlSession (请求结束时)</strong><ul>
<li>应用程序在使用完毕后，必须调用 <code>sqlSession.close()</code>。</li>
<li>这个操作会释放 <code>SqlSession</code> 占用的资源，最重要的是将数据库连接归还给连接池，并清空该会话的一级缓存。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-快速入门"><a href="#3-快速入门" class="headerlink" title="3. 快速入门"></a>3. 快速入门</h2><h3 id="3-1-环境准备"><a href="#3-1-环境准备" class="headerlink" title="3.1 环境准备"></a>3.1 环境准备</h3><ul>
<li><strong>JDK</strong>: 1.8 或更高版本</li>
<li><strong>Maven</strong>: 3.6 或更高版本</li>
<li><strong>数据库</strong>: 以 MySQL 为例</li>
</ul>
<hr>
<h3 id="3-2-创建Maven项目并添加依赖"><a href="#3-2-创建Maven项目并添加依赖" class="headerlink" title="3.2 创建Maven项目并添加依赖"></a>3.2 创建Maven项目并添加依赖</h3><p>创建一个标准的 Maven 项目，并在 <code>pom.xml</code> 文件中添加 MyBatis 和 MySQL 驱动的核心依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- MyBatis 核心库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- MySQL 数据库驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 日志（可选，但推荐） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-准备数据库和数据表"><a href="#3-3-准备数据库和数据表" class="headerlink" title="3.3 准备数据库和数据表"></a>3.3 准备数据库和数据表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建 user 表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `username` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `email` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入测试数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `<span class="keyword">user</span>` (`id`, `username`, `password`, `email`) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;password123&#x27;</span>, <span class="string">&#x27;alice@example.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-4-创建实体类"><a href="#3-4-创建实体类" class="headerlink" title="3.4 创建实体类"></a>3.4 创建实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/model/UserPO.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserPO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters 和 Setters</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserPO&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, email=&#x27;&quot;</span> + email + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-5-创建Mapper接口"><a href="#3-5-创建Mapper接口" class="headerlink" title="3.5 创建Mapper接口"></a>3.5 创建Mapper接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/mapper/UserMapper.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.model.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID查询用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    User <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-6-创建Mapper-XML映射文件"><a href="#3-6-创建Mapper-XML映射文件" class="headerlink" title="3.6 创建Mapper XML映射文件"></a>3.6 创建Mapper XML映射文件</h3><p>在 <code>src/main/resources</code> 目录下，创建一个与 Mapper 接口对应的 XML 文件 <code>UserMapper.xml</code>。<strong>注意：目录结构通常要与接口的包结构保持一致。</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/main/resources/com/example/mapper/UserMapper.xml --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- namespace 必须指向 Mapper 接口的全限定名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        select 标签定义一个查询操作</span></span><br><span class="line"><span class="comment">        id: 必须与接口中的方法名一致</span></span><br><span class="line"><span class="comment">        resultType: 查询结果映射的 Java 类型（全限定名或别名）</span></span><br><span class="line"><span class="comment">        parameterType: 传入参数的类型（可选，MyBatis通常能自动推断）</span></span><br><span class="line"><span class="comment">        #&#123;id&#125;: MyBatis 的参数占位符，表示从传入的参数中获取 id 属性/值</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-7-创建-MyBatis-核心配置文件"><a href="#3-7-创建-MyBatis-核心配置文件" class="headerlink" title="3.7 创建 MyBatis 核心配置文件"></a>3.7 创建 MyBatis 核心配置文件</h3><p>在 <code>src/main/resources</code> 目录下创建 <code>mybatis-config.xml</code>，这是 MyBatis 的主配置文件，用于配置数据源、事务管理器和引入映射文件。</p>
<p>在实际开发中这种核心配置文件被SpringBoot的application.yml替代，不再需要这么复杂的xml语句。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/main/resources/mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据库连接环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 事务管理器：使用 JDBC 的提交和回滚设置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 数据源：使用 MyBatis 自带的连接池 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/your_database?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=UTC&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;your_password&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 注册 Mapper XML 文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/example/mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 请将 <code>your_database</code> 和 <code>your_password</code> 替换为您自己的数据库名和密码。</p>
<hr>
<h3 id="3-8-编写测试代码"><a href="#3-8-编写测试代码" class="headerlink" title="3.8 编写测试代码"></a>3.8 编写测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 指定核心配置文件的路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="comment">// 2. 读取配置文件输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="comment">// 3. 创建 SqlSessionFactory（重量级对象，全局唯一）</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 从 SqlSessionFactory 获取 SqlSession（轻量级对象，线程不安全，用完即关）</span></span><br><span class="line">        <span class="comment">// 使用 try-with-resources 语句确保 SqlSession 被自动关闭</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">            <span class="comment">// 5. 获取 Mapper 接口的代理对象</span></span><br><span class="line">            <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 6. 调用 Mapper 方法执行查询</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Querying user with ID 1...&quot;</span>);</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7. 处理并打印结果</span></span><br><span class="line">            <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;User found: &quot;</span> + user);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;User not found.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-XML映射文件"><a href="#4-XML映射文件" class="headerlink" title="4. XML映射文件"></a>4. XML映射文件</h2><p>XML 映射文件是 MyBatis 的核心和灵魂所在。它体现了 MyBatis “SQL 与代码分离”的设计哲学，允许开发者将 SQL 语句集中管理，提供了极大的灵活性和可维护性。</p>
<h3 id="4-1-角色与结构"><a href="#4-1-角色与结构" class="headerlink" title="4.1 角色与结构"></a>4.1 角色与结构</h3><p><strong>角色</strong>：XML 映射文件是 <strong>Mapper 接口</strong> 与 <strong>SQL 语句</strong> 之间的桥梁。它告诉 MyBatis，当调用接口中的某个方法时，应该执行哪条 SQL 语句，以及如何处理参数和结果。</p>
<p><strong>基本结构</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 根元素 &lt;mapper&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 在这里定义各种 SQL 语句映射 --&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>&lt;!DOCTYPE mapper ...&gt;</code></strong>: 这是标准的 DTD (Document Type Definition) 声明，用于验证 XML 文件的结构合法性，并提供 IDE 的代码提示功能。</li>
<li><strong><code>&lt;mapper namespace=&quot;...&quot;&gt;</code></strong>: 根元素。<ul>
<li><strong><code>namespace</code> (命名空间)</strong>: 这是映射文件最重要的属性，它必须被设置为 <strong>对应的 Mapper 接口的全限定名</strong> (例如 <code>com.example.mapper.UserMapper</code>)。它的作用是将这个 XML 文件与指定的 Java 接口绑定起来，MyBatis 通过这个命名空间来定位和执行 SQL。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-2-CRUD操作标签"><a href="#4-2-CRUD操作标签" class="headerlink" title="4.2 CRUD操作标签"></a>4.2 CRUD操作标签</h3><p>MyBatis 为增删改查操作提供了四个基本标签：</p>
<ul>
<li><strong><code>&lt;select&gt;</code></strong>: 用于定义查询语句。</li>
<li><strong><code>&lt;insert&gt;</code></strong>: 用于定义插入语句。</li>
<li><strong><code>&lt;update&gt;</code></strong>: 用于定义更新语句。</li>
<li><strong><code>&lt;delete&gt;</code></strong>: 用于定义删除语句。</li>
</ul>
<p><strong>通用属性</strong>:</p>
<ul>
<li><strong><code>id</code></strong>: 必填。唯一标识符，必须与 Mapper 接口中对应的方法名完全一致。</li>
<li><strong><code>parameterType</code></strong>: 可选。传入参数的 Java 类型全限定名或别名。MyBatis 通常可以自动推断，所以大部分情况下可以省略。</li>
<li><strong><code>timeout</code></strong>: 设置超时时间（秒）。</li>
<li><strong><code>flushCache</code></strong>: 默认为 <code>false</code> (select) 或 <code>true</code> (insert&#x2F;update&#x2F;delete)。设置为 <code>true</code> 时，执行该语句会清空一级和二级缓存。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 查询 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 插入并返回自增主键 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.model.User&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        INSERT INTO user (username, password, email) </span><br><span class="line">        VALUES (#&#123;username&#125;, #&#123;password&#125;, #&#123;email&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 更新 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">        UPDATE user SET username = #&#123;username&#125;, email = #&#123;email&#125; WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 删除 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span>&gt;</span></span><br><span class="line">        DELETE FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>useGeneratedKeys=&quot;true&quot;</code></strong> 和 <strong><code>keyProperty=&quot;id&quot;</code></strong>: 这两个属性配合使用，可以在执行 <code>insert</code> 语句后，将数据库生成的自增主键值回填到传入的 <code>User</code> 对象的 <code>id</code> 属性中。</li>
</ul>
<hr>
<h3 id="4-3-参数处理-vs"><a href="#4-3-参数处理-vs" class="headerlink" title="4.3 参数处理 (#{} vs ${})"></a>4.3 参数处理 (<code>#{}</code> vs <code>${}</code>)</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>#{}</code> (占位符)</th>
<th align="left"><code>${}</code> (拼接符)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>底层实现</strong></td>
<td align="left"><code>PreparedStatement</code></td>
<td align="left"><code>Statement</code></td>
</tr>
<tr>
<td align="left"><strong>工作方式</strong></td>
<td align="left">参数替换，将 <code>#{...}</code> 替换为 <code>?</code>，然后安全地设置值。</td>
<td align="left">字符串直接拼接，将 <code>${...}</code> 的内容原样拼接到 SQL 中。</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left"><strong>安全</strong>，能有效防止 SQL 注入。</td>
<td align="left"><strong>不安全</strong>，存在 SQL 注入风险，必须谨慎使用。</td>
</tr>
<tr>
<td align="left"><strong>类型处理</strong></td>
<td align="left">自动进行数据类型转换（如 String 转 ‘String’）。</td>
<td align="left">不进行任何处理，原样输出。</td>
</tr>
<tr>
<td align="left"><strong>推荐使用</strong></td>
<td align="left"><strong>绝大多数情况下都应该使用。</strong></td>
<td align="left">仅用于无法使用 <code>#{}</code> 的场景。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">传递查询条件、更新值等所有用户输入的数据。</td>
<td align="left">动态指定表名、列名、<code>ORDER BY</code> 子句等非参数值部分。</td>
</tr>
</tbody></table>
<p><strong>示例</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 安全的用法 (推荐)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> #&#123;userId&#125;;</span><br><span class="line"><span class="comment">-- MyBatis 会生成: SELECT * FROM user WHERE id = ?;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 危险的用法 (有 SQL 注入风险)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> $&#123;userId&#125;;</span><br><span class="line"><span class="comment">-- 如果 userId 是 &quot;1 OR 1=1&quot;，SQL 会变成: SELECT * FROM user WHERE id = 1 OR 1=1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- `$&#123;&#125;` 的合理用法</span></span><br><span class="line"><span class="comment">-- 动态排序：orderByColumn 可以是 &quot;username&quot; 或 &quot;email&quot;</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> $&#123;orderByColumn&#125; <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-4-结果映射"><a href="#4-4-结果映射" class="headerlink" title="4.4 结果映射 (&lt;resultMap&gt;)"></a>4.4 结果映射 (<code>&lt;resultMap&gt;</code>)</h3><p>当数据库表的列名与 Java 对象的属性名不一致时，或者需要处理复杂的关联查询（如一对一、一对多）时，<code>resultType</code> 就显得力不从心了。此时，需要使用功能更强大的 <code>&lt;resultMap&gt;</code>。</p>
<p><strong><code>resultType</code> vs <code>&lt;resultMap&gt;</code></strong>:</p>
<ul>
<li><strong><code>resultType</code></strong>: 用于简单的自动映射。它要求 SQL 查询出的列名与 Java 对象的属性名（忽略大小写和下划线）能够匹配。例如，数据库列 <code>user_name</code> 可以自动映射到 Java 属性 <code>userName</code>。</li>
<li><strong><code>&lt;resultMap&gt;</code></strong>: 提供手动的、精细化的映射规则。</li>
</ul>
<p><strong><code>&lt;resultMap&gt;</code> 的使用</strong>:</p>
<ol>
<li><p><strong>定义 <code>&lt;resultMap&gt;</code></strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  id: resultMap 的唯一标识</span></span><br><span class="line"><span class="comment">  type: 映射的目标 Java 类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;id&gt; 用于映射主键，有助于性能提升 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;result&gt; 用于映射普通列 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 <code>&lt;select&gt;</code> 标签中引用 <code>resultMap</code></strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserWithCustomMapping&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT user_id, user_name, user_password, user_email FROM user WHERE user_id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="4-5-可重用-SQL-片段"><a href="#4-5-可重用-SQL-片段" class="headerlink" title="4.5 可重用 SQL 片段 (&lt;sql&gt;)"></a>4.5 可重用 SQL 片段 (<code>&lt;sql&gt;</code>)</h3><p>为了避免重复编写相同的 SQL 代码（如查询的列名列表），可以使用 <code>&lt;sql&gt;</code> 标签定义可重用的 SQL 片段，并通过 <code>&lt;include&gt;</code> 标签引用它。</p>
<p><strong>示例</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 定义可重用的 SQL 片段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;baseColumnList&quot;</span>&gt;</span></span><br><span class="line">    id, username, password, email</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2. 在查询语句中引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT </span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;baseColumnList&quot;</span>/&gt;</span></span><br><span class="line">    FROM user </span><br><span class="line">    WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;baseColumnList&quot;</span>/&gt;</span></span><br><span class="line">    FROM user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-动态SQL"><a href="#5-动态SQL" class="headerlink" title="5. 动态SQL"></a>5. 动态SQL</h2><p><strong>动态 SQL</strong> 是 MyBatis 最强大、最核心的功能之一。它允许你根据不同的条件，在 XML 映射文件中动态地拼接、组合 SQL 语句。这极大地解决了传统 JDBC 中需要通过 Java 代码进行大量 <code>if-else</code> 判断来拼接 SQL 的痛点，使得 SQL 语句的管理更加清晰和高效。</p>
<h3 id="5-1-为什么需要动态-SQL？"><a href="#5-1-为什么需要动态-SQL？" class="headerlink" title="5.1 为什么需要动态 SQL？"></a>5.1 为什么需要动态 SQL？</h3><p>在实际开发中，我们经常遇到“多条件组合查询”的场景。例如，一个用户搜索功能，用户可能只输入了用户名，或者只选择了状态，或者两者都输入了。如果使用静态 SQL，你需要为每一种可能的组合编写一个 SQL 语句，这是不现实的。</p>
<p>动态 SQL 让你只需编写一个 SQL 模板，通过使用特定的标签，MyBatis 会在运行时根据传入的参数动态地生成最终要执行的 SQL。</p>
<hr>
<h3 id="5-2-核心动态-SQL-标签"><a href="#5-2-核心动态-SQL-标签" class="headerlink" title="5.2 核心动态 SQL 标签"></a>5.2 核心动态 SQL 标签</h3><h4 id="5-2-1"><a href="#5-2-1" class="headerlink" title="5.2.1 &lt;if&gt;"></a>5.2.1 <code>&lt;if&gt;</code></h4><p>这是最常用的动态 SQL 标签，用于进行单条件判断。如果 <code>test</code> 表达式的值为 <code>true</code>，则会将 <code>&lt;if&gt;</code> 标签内的 SQL 片段包含进来。</p>
<p><strong>场景</strong>：根据用户名（可选）和邮箱（可选）查询用户。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserByCondition&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.model.User&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    WHERE 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null and username != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        AND username = #&#123;username&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        AND email = #&#123;email&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>test</code> 属性</strong>：接收一个 OGNL (Object-Graph Navigation Language) 表达式。你可以直接访问传入参数对象的属性。</li>
<li><strong><code>WHERE 1=1</code> 的技巧</strong>：这是一个经典的“hack”手法。为了避免当所有 <code>&lt;if&gt;</code> 条件都不满足时 SQL 语法错误，或者当第一个 <code>&lt;if&gt;</code> 满足时需要处理 <code>WHERE</code> 和 <code>AND</code> 的连接问题，<code>WHERE 1=1</code> 可以巧妙地让后续所有条件都以 <code>AND</code> 开头，简化了逻辑。不过，MyBatis 提供了更优雅的解决方案。</li>
</ul>
<hr>
<h4 id="5-2-2"><a href="#5-2-2" class="headerlink" title="5.2.2 &lt;where&gt;"></a>5.2.2 <code>&lt;where&gt;</code></h4><p><code>&lt;where&gt;</code> 标签专门用于解决上述 <code>WHERE 1=1</code> 的问题。它会智能地处理 SQL 拼接：</p>
<ul>
<li>只有当 <code>&lt;where&gt;</code> 标签内有内容输出时，它才会生成 <code>WHERE</code> 关键字。</li>
<li>它会自动<strong>去除</strong>标签内 SQL 语句<strong>开头</strong>的 <code>AND</code> 或 <code>OR</code>。</li>
</ul>
<p><strong>使用 <code>&lt;where&gt;</code> 优化上述示例</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserByCondition&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.model.User&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null and username != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            AND username = #&#123;username&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            AND email = #&#123;email&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段代码更加简洁、优雅，且意图明确。<strong>强烈推荐使用 <code>&lt;where&gt;</code> 替代 <code>WHERE 1=1</code> 的写法。</strong></p>
<hr>
<h4 id="5-2-3"><a href="#5-2-3" class="headerlink" title="5.2.3 &lt;set&gt;"></a>5.2.3 <code>&lt;set&gt;</code></h4><p><code>&lt;set&gt;</code> 标签主要用于 <code>UPDATE</code> 语句中，它解决了动态更新时可能出现的“逗号问题”。</p>
<ul>
<li>只有当 <code>&lt;set&gt;</code> 标签内有内容输出时，它才会生成 <code>SET</code> 关键字。</li>
<li>它会自动<strong>去除</strong>标签内 SQL 语句<strong>结尾</strong>多余的逗号 <code>,</code>。</li>
</ul>
<p><strong>场景</strong>：动态更新用户信息，只更新传入对象中非 <code>null</code> 的字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=&quot;updateUserSelective&quot; parameterType=&quot;com.example.model.User&quot;&gt;</span><br><span class="line">    UPDATE user</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">        &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            username = #&#123;username&#125;,</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            password = #&#123;password&#125;,</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;email != null and email != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            email = #&#123;email&#125;,</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">    WHERE id = #&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>

<p>如果没有 <code>&lt;set&gt;</code>，当最后一个 <code>&lt;if&gt;</code> 条件满足时，SQL 语句会以一个逗号结尾，导致语法错误。<code>&lt;set&gt;</code> 完美地解决了这个问题。</p>
<hr>
<h4 id="5-2-4"><a href="#5-2-4" class="headerlink" title="5.2.4 &lt;foreach&gt;"></a>5.2.4 <code>&lt;foreach&gt;</code></h4><p><code>&lt;foreach&gt;</code> 标签用于对集合（如 <code>List</code>, <code>Set</code>, <code>Array</code>）进行迭代，常用于构建 <code>IN</code> 子句或批量插入。</p>
<p><strong>核心属性</strong>:</p>
<ul>
<li><strong><code>collection</code></strong>: 必填。要迭代的集合参数。当参数是 <code>List</code> 时，默认为 <code>list</code>；当是数组时，默认为 <code>array</code>。也可以通过 <code>@Param</code> 注解指定名称。</li>
<li><strong><code>item</code></strong>: 迭代过程中当前元素的变量名。</li>
<li><strong><code>open</code></strong>: 整个循环内容开始前要拼接的字符串。</li>
<li><strong><code>close</code></strong>: 整个循环内容结束后要拼接的字符串。</li>
<li><strong><code>separator</code></strong>: 每次迭代之间要拼接的分隔符。</li>
</ul>
<p><strong>场景</strong>：根据一组 ID 查询多个用户。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Mapper 接口方法: List&lt;User&gt; selectByIds(@Param(&quot;ids&quot;) List&lt;Integer&gt; ids); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    WHERE id IN</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果传入的 <code>ids</code> 是 <code>[1, 2, 3]</code>，上述代码会生成如下 SQL：<code>SELECT * FROM user WHERE id IN ( ? , ? , ? )</code></p>
<hr>
<h4 id="5-2-5"><a href="#5-2-5" class="headerlink" title="5.2.5 &lt;choose&gt;, &lt;when&gt;, &lt;otherwise&gt;"></a>5.2.5 <code>&lt;choose&gt;</code>, <code>&lt;when&gt;</code>, <code>&lt;otherwise&gt;</code></h4><p>这组标签相当于 Java 中的 <code>switch-case</code> 或 <code>if-else if-else</code> 结构，提供了“多选一”的逻辑。</p>
<p><strong>场景</strong>：根据传入的 <code>searchType</code> 决定按哪个字段搜索。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserBySearchType&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;searchType == &#x27;username&#x27; and username != null&quot;</span>&gt;</span></span><br><span class="line">                username LIKE CONCAT(&#x27;%&#x27;, #&#123;username&#125;, &#x27;%&#x27;)</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;searchType == &#x27;email&#x27; and email != null&quot;</span>&gt;</span></span><br><span class="line">                email = #&#123;email&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                AND status = &#x27;active&#x27;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-2-6"><a href="#5-2-6" class="headerlink" title="5.2.6 &lt;trim&gt;"></a>5.2.6 <code>&lt;trim&gt;</code></h4><p><code>&lt;trim&gt;</code> 是一个更通用的自定义标签，<code>&lt;where&gt;</code> 和 <code>&lt;set&gt;</code> 本质上是 <code>&lt;trim&gt;</code> 的特定配置。它允许你自定义前缀、后缀以及需要覆盖（移除）的前缀和后缀。</p>
<p><strong>属性</strong>:</p>
<ul>
<li><code>prefix</code>: 在标签内容前添加的前缀。</li>
<li><code>suffix</code>: 在标签内容后添加的后缀。</li>
<li><code>prefixOverrides</code>: 需要从标签内容<strong>开头</strong>移除的文本（多个用 <code>|</code> 分隔）。</li>
<li><code>suffixOverrides</code>: 需要从标签内容<strong>结尾</strong>移除的文本（多个用 <code>|</code> 分隔）。</li>
</ul>
<p><strong>使用 <code>&lt;trim&gt;</code> 模拟 <code>&lt;where&gt;</code></strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND |OR &quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... a bunch of if statements ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>使用 <code>&lt;trim&gt;</code> 模拟 <code>&lt;set&gt;</code></strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... a bunch of if statements ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>虽然 <code>&lt;trim&gt;</code> 更强大，但在适用场景下，使用 <code>&lt;where&gt;</code> 和 <code>&lt;set&gt;</code> 会让代码意图更清晰，可读性更好。</p>
<h2 id="6-注解开发"><a href="#6-注解开发" class="headerlink" title="6. 注解开发"></a>6. 注解开发</h2><p>MyBatis 注解开发是一种将 SQL 语句直接写在 Mapper 接口方法上的方式，作为 XML 映射文件的替代方案。它以牺牲“SQL与代码分离”的原则为代价，换取了开发的便捷性，特别适用于简单、固定的 SQL 场景。</p>
<h3 id="6-1-简介与适用场景"><a href="#6-1-简介与适用场景" class="headerlink" title="6.1 简介与适用场景"></a>6.1 简介与适用场景</h3><p><strong>核心思想</strong>：将 SQL 映射的配置信息从 XML 文件中移到 Java 接口的注解上，让接口本身就成为一个完整的映射单元。</p>
<p><strong>适用场景</strong>:</p>
<ul>
<li><strong>简单的 CRUD 操作</strong>：对于那些 SQL 语句非常简短、固定且不会改变的增删改查，使用注解可以减少一个 XML 文件，使项目结构更紧凑。</li>
<li><strong>快速原型开发</strong>：在项目初期或开发小型应用时，注解方式可以快速实现功能。</li>
<li><strong>SQL 语句非常简单</strong>：当 SQL 逻辑不涉及复杂的动态判断或关联时，注解是很好的选择。</li>
</ul>
<p><strong>不适用场景</strong>：</p>
<ul>
<li><strong>复杂的动态 SQL</strong>：虽然注解也支持动态 SQL，但写法非常笨拙，可读性和可维护性远不如 XML。</li>
<li><strong>SQL 需要被 DBA 审查或优化</strong>：当 SQL 需要由专门的数据库管理员进行管理时，XML 的分离特性是巨大优势。</li>
<li><strong>需要处理复杂的结果集映射</strong>：注解方式处理复杂映射（如嵌套查询）比 XML 更加繁琐。</li>
</ul>
<hr>
<h3 id="6-2-启用注解开发"><a href="#6-2-启用注解开发" class="headerlink" title="6.2 启用注解开发"></a>6.2 启用注解开发</h3><p>要让 MyBatis 扫描并识别注解，需要在核心配置文件 <code>mybatis-config.xml</code> 中注册 Mapper <strong>接口类</strong>，而不是 XML 文件资源。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方案一：逐个注册 Mapper 接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 方案二：批量扫描指定包下的所有 Mapper 接口（更常用） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.example.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：MyBatis 允许混合使用 XML 和注解。即使你使用了注解，MyBatis 默认还是会去寻找与接口同名同路径的 XML 文件。这种混合模式提供了极大的灵活性。</p>
<hr>
<h3 id="6-3-核心-CRUD-注解"><a href="#6-3-核心-CRUD-注解" class="headerlink" title="6.3 核心 CRUD 注解"></a>6.3 核心 CRUD 注解</h3><p>MyBatis 提供了一套与 XML 标签对应的注解，用于定义增删改查操作。</p>
<ul>
<li><code>@Select</code>: 对应 <code>&lt;select&gt;</code> 标签，用于查询。</li>
<li><code>@Insert</code>: 对应 <code>&lt;insert&gt;</code> 标签，用于插入。</li>
<li><code>@Update</code>: 对应 <code>&lt;update&gt;</code> 标签，用于更新。</li>
<li><code>@Delete</code>: 对应 <code>&lt;delete&gt;</code> 标签，用于删除。</li>
</ul>
<p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com/example/mapper/UserMapper.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM user WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;INSERT INTO user (username, password, email) VALUES (#&#123;username&#125;, #&#123;password&#125;, #&#123;email&#125;)&quot;)</span></span><br><span class="line">    <span class="comment">// 使用 @Options 注解获取自增主键</span></span><br><span class="line">    <span class="meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;UPDATE user SET username = #&#123;username&#125;, email = #&#123;email&#125; WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateUser</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;DELETE FROM user WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-4-参数处理-Param"><a href="#6-4-参数处理-Param" class="headerlink" title="6.4 参数处理 (@Param)"></a>6.4 参数处理 (<code>@Param</code>)</h3><p><code>@Param</code> 注解的核心作用是<strong>给 Mapper 接口方法中的参数命名</strong>。</p>
<p>当 MyBatis 将 Java 方法的参数传入 XML 文件中的 SQL 语句时，它需要一种方式来关联这两者。</p>
<h4 id="6-4-1-使用场景"><a href="#6-4-1-使用场景" class="headerlink" title="6.4.1 使用场景"></a>6.4.1 使用场景</h4><h5 id="1-方法有多个参数时"><a href="#1-方法有多个参数时" class="headerlink" title="1. 方法有多个参数时"></a>1. 方法有多个参数时</h5><p>如果一个 Mapper 方法有多个参数，比如 <code>(String username, String password)</code>，MyBatis 默认情况下无法区分哪个参数对应 SQL 语句中的哪个占位符。它可能会使用 <code>arg0</code>, <code>arg1</code>… 或者 <code>param1</code>, <code>param2</code>… 这样的默认名称，但这非常不直观且容易出错。</p>
<p>使用 <code>@Param</code> 为每个参数指定一个明确的、有意义的名称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名和密码查询用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    User <span class="title function_">findUserByUsernameAndPassword</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username, </span></span><br><span class="line"><span class="params">                                       <span class="meta">@Param(&quot;password&quot;)</span> String password)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserByUsernameAndPassword&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * </span><br><span class="line">    FROM user </span><br><span class="line">    WHERE username = #&#123;username&#125; AND password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>@Param(&quot;username&quot;)</code> 将 Java 方法的第一个参数 <code>username</code> 命名为 “username”。</li>
<li><code>@Param(&quot;password&quot;)</code> 将 Java 方法的第二个参数 <code>password</code> 命名为 “password”。</li>
<li>在 XML 中，我们就可以通过 <code>#{username}</code> 和 <code>#{password}</code> 来精确地引用这两个参数了。名字必须完全匹配。</li>
</ul>
<hr>
<h5 id="2-参数是集合或数组时"><a href="#2-参数是集合或数组时" class="headerlink" title="2. 参数是集合或数组时"></a>2. 参数是集合或数组时</h5><p>当你的方法参数是 <code>List</code>、<code>Set</code> 或数组，并且需要在 SQL 中进行遍历（例如 <code>IN</code> 查询），强烈推荐使用 <code>@Param</code>。</p>
<p>MyBatis 在处理集合类参数时，会将其包装在一个 <code>Map</code> 对象中。如果你不指定名称，MyBatis 会使用默认的名称，如 <code>list</code>、<code>collection</code> 或 <code>array</code>。虽然可用，但这同样不直观。</p>
<p>使用 <code>@Param</code> 给集合参数一个有意义的名称，让 XML 中的 <code>&lt;foreach&gt;</code> 标签更具可读性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户ID列表查询多个用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userIds 用户ID列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findUsersByIds</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> List&lt;Integer&gt; userIds)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUsersByIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT *</span><br><span class="line">    FROM user</span><br><span class="line">    WHERE id IN</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;userId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>@Param(&quot;ids&quot;)</code> 将 <code>List&lt;Integer&gt; userIds</code> 这个参数命名为 “ids”。</li>
<li>在 <code>&lt;foreach&gt;</code> 标签中，<code>collection</code> 属性的值就直接写成 “ids”，代码意图一目了然。</li>
</ul>
<hr>
<h4 id="6-4-2-可以不使用"><a href="#6-4-2-可以不使用" class="headerlink" title="6.4.2 可以不使用"></a>6.4.2 可以不使用</h4><p><strong>当方法只有一个参数，且不是集合&#x2F;数组时</strong></p>
<p>如果方法只有一个参数，并且它是简单类型（如 <code>Integer</code>, <code>String</code>）或一个 POJO (JavaBean) 对象，那么你可以<strong>不使用</strong> <code>@Param</code>。</p>
<p>**原理：**在这种情况下，MyBatis 能够自动识别，你可以直接在 XML 中使用参数名或者对象的属性名。</p>
<h5 id="1-单个简单类型参数"><a href="#1-单个简单类型参数" class="headerlink" title="1. 单个简单类型参数"></a>1. 单个简单类型参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- #&#123;id&#125; 或 #&#123;_parameter&#125; 或任何你喜欢的名字都可以 --&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>#{}</code> 里的名字可以任意写（虽然推荐写成和参数名一致的 <code>id</code> 以便于理解）。</p>
<hr>
<h5 id="2-单个-POJO-对象参数"><a href="#2-单个-POJO-对象参数" class="headerlink" title="2. 单个 POJO 对象参数"></a>2. 单个 POJO 对象参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--可以直接使用User对象的属性名--&gt;</span></span><br><span class="line">    INSERT INTO user (username, password, email)</span><br><span class="line">    VALUES (#&#123;username&#125;, #&#123;password&#125;, #&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MyBatis 会自动从 <code>user</code> 对象中获取名为 <code>username</code>, <code>password</code> 的属性值。</p>
<p>**但是，即使在这种情况下，使用 <code>@Param</code> 也是一个好习惯，**因为它可以增加代码的明确性和一致性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加上@Param让代码更清晰</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertUser</span><span class="params">(<span class="meta">@Param(&quot;user&quot;)</span> User user)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- XML中也对应地使用user.属性名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    INSERT INTO user (username, password, email)</span><br><span class="line">    VALUES (#&#123;user.username&#125;, #&#123;user.password&#125;, #&#123;user.email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-4-3-Java-8-的-parameters-编译选项"><a href="#6-4-3-Java-8-的-parameters-编译选项" class="headerlink" title="6.4.3 Java 8 的 -parameters 编译选项"></a>6.4.3 Java 8 的 <code>-parameters</code> 编译选项</h4><p>如果你使用的是 Java 8 或更高版本，并且在编译时开启了 <code>-parameters</code> 标志（默认关闭），MyBatis 3.4.1+ 可以通过反射获取到方法的实际参数名（例如 <code>username</code>, <code>password</code>）。</p>
<p>在这种情况下，即使有多个参数，也可以不使用 <code>@Param</code> 注解。</p>
<p><strong>示例 (开启了 <code>-parameters</code> 标志):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无需 @Param</span></span><br><span class="line">User <span class="title function_">findUserByUsernameAndPassword</span><span class="params">(String username, String password)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 可以直接使用参数名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserByUsernameAndPassword&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * </span><br><span class="line">    FROM user </span><br><span class="line">    WHERE username = #&#123;username&#125; AND password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>然而，依赖这个特性有风险：</strong></p>
<ol>
<li><strong>构建环境依赖</strong>：它要求你的项目（以及所有依赖它的项目）都必须在开启 <code>-parameters</code> 标志的情况下编译。如果构建配置发生变化，代码可能会在运行时失败。</li>
<li><strong>可移植性差</strong>：其他开发者或者 CI&#x2F;CD 环境可能没有配置这个标志，导致构建失败。</li>
</ol>
<p>因此，<strong>最佳实践是：不要依赖 <code>-parameters</code> 标志，始终为多个参数显式地使用 <code>@Param</code> 注解。</strong> 这样你的代码会更健壮、更清晰、更不容易出错。</p>
<hr>
<h3 id="6-5-结果映射-Results-Result"><a href="#6-5-结果映射-Results-Result" class="headerlink" title="6.5 结果映射 (@Results &amp; @Result)"></a>6.5 结果映射 (<code>@Results</code> &amp; <code>@Result</code>)</h3><p>当数据库列名与 Java 实体类的属性名不匹配时，可以使用 <code>@Results</code> 和 <code>@Result</code> 注解来进行手动映射，它们的功能等同于 XML 中的 <code>&lt;resultMap&gt;</code>。</p>
<ul>
<li><code>@Results</code>: 包含一组 <code>@Result</code> 映射规则的容器，可以给它指定一个 <code>id</code> 以便复用。</li>
<li><code>@Result</code>: 定义单个列与属性的映射关系。<ul>
<li><code>column</code>: 数据库列名。</li>
<li><code>property</code>: Java 实体类属性名。</li>
<li><code>id = true</code>: 表明这是主键字段。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Results(id = &quot;userResultMap&quot;, value = &#123;</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;id&quot;, column = &quot;user_id&quot;, id = true),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;username&quot;, column = &quot;user_name&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;password&quot;, column = &quot;user_pwd&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;email&quot;, column = &quot;user_email&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT user_id, user_name, user_pwd, user_email FROM user WHERE user_id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">selectUserWithCustomMapping</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复用上面定义的 Results</span></span><br><span class="line">    <span class="meta">@ResultMap(&quot;userResultMap&quot;)</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT user_id, user_name, user_pwd, user_email FROM user&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectAllUsers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-6-动态-SQL-注解的局限与方案"><a href="#6-6-动态-SQL-注解的局限与方案" class="headerlink" title="6.6 动态 SQL (注解的局限与方案)"></a>6.6 动态 SQL (注解的局限与方案)</h3><p>在注解中实现动态 SQL 是其最大的短板，可读性很差。主要有两种方案：</p>
<p><strong>方案一：使用 <code>&lt;script&gt;</code> 标签 (推荐)</strong></p>
<p>你可以在注解的 SQL 字符串中嵌入 <code>&lt;script&gt;</code> 标签，然后在标签内部使用和 XML 中一样的动态 SQL 标签（如 <code>&lt;if&gt;</code>, <code>&lt;where&gt;</code>, <code>&lt;foreach&gt;</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;&lt;script&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;SELECT * FROM user &quot; +</span></span><br><span class="line"><span class="meta">            &quot;&lt;where&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;  &lt;if test=&#x27;username != null and username != \&quot;\&quot;&#x27;&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;    AND username = #&#123;username&#125;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;  &lt;/if&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;  &lt;if test=&#x27;email != null and email != \&quot;\&quot;&#x27;&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;    AND email = #&#123;email&#125;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;  &lt;/if&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;&lt;/where&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;&lt;/script&gt;&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findUserByCondition</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>：SQL 以字符串形式存在，容易出错，IDE 没有语法高亮和检查，可读性差。</p>
<p><strong>方案二：使用 <code>Provider</code> 注解 (高级)</strong></p>
<p>对于极其复杂的动态 SQL，可以使用 <code>@SelectProvider</code>, <code>@InsertProvider</code> 等注解，将构建 SQL 的逻辑委托给一个外部的 Java 类来完成。</p>
<ol>
<li><p><strong>创建一个 SQL Provider 类</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSqlProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findUserByCondition</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 MyBatis 内置的 SQL 构建器，比手动拼接更安全</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;&#123;</span><br><span class="line">            SELECT(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            FROM(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (user.getUsername() != <span class="literal">null</span> &amp;&amp; !user.getUsername().isEmpty()) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;username = #&#123;username&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (user.getEmail() != <span class="literal">null</span> &amp;&amp; !user.getEmail().isEmpty()) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;email = #&#123;email&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 Mapper 接口中引用</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@SelectProvider(type = UserSqlProvider.class, method = &quot;findUserByCondition&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findUserByCondition</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>优点</strong>：可以利用 Java 的全部能力来构建 SQL，逻辑最强大。</p>
<p><strong>缺点</strong>：实现复杂，将数据访问逻辑分散到了另一个类中。</p>
<hr>
<h3 id="6-7-总结：注解-vs-XML-最佳实践"><a href="#6-7-总结：注解-vs-XML-最佳实践" class="headerlink" title="6.7 总结：注解 vs XML (最佳实践)"></a>6.7 总结：注解 vs XML (最佳实践)</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">注解方式</th>
<th align="left">XML 方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>简洁性</strong></td>
<td align="left"><strong>优</strong>，无需额外文件</td>
<td align="left"><strong>良</strong>，需要维护 XML 文件</td>
</tr>
<tr>
<td align="left"><strong>SQL与代码分离</strong></td>
<td align="left"><strong>差</strong>，SQL 与 Java 代码耦合</td>
<td align="left"><strong>优</strong>，完全分离，便于维护</td>
</tr>
<tr>
<td align="left"><strong>动态 SQL 支持</strong></td>
<td align="left"><strong>差</strong>，可读性极低</td>
<td align="left"><strong>优</strong>，语法清晰，功能强大</td>
</tr>
<tr>
<td align="left"><strong>复杂结果映射</strong></td>
<td align="left"><strong>差</strong>，注解写法繁琐</td>
<td align="left"><strong>优</strong>，<code>&lt;resultMap&gt;</code> 结构清晰</td>
</tr>
<tr>
<td align="left"><strong>IDE 支持</strong></td>
<td align="left"><strong>差</strong>，SQL 为字符串，无提示</td>
<td align="left"><strong>优</strong>，有语法高亮和提示</td>
</tr>
</tbody></table>
<p><strong>最佳实践：混合使用</strong></p>
<p>在实际项目中，最理想的策略是<strong>混合使用</strong>两种方式，发挥各自的优势：</p>
<ul>
<li>对于<strong>简单、固定、不常变动</strong>的 CRUD 操作，使用<strong>注解</strong>，以提高开发效率。</li>
<li>对于<strong>复杂查询、动态 SQL、需要 DBA 介入或频繁优化</strong>的 SQL，使用 <strong>XML 文件</strong>，以保证可读性和可维护性。</li>
</ul>
<hr>
<h2 id="7-适用场景-原生MyBatis"><a href="#7-适用场景-原生MyBatis" class="headerlink" title="7. 适用场景 (原生MyBatis)"></a>7. 适用场景 (原生MyBatis)</h2><p>原生MyBatis的核心优势在于它在 <strong>自动化便利性</strong> 和 <strong>SQL 终极控制力</strong> 之间取得了完美的平衡。</p>
<h4 id="7-1-极致的性能追求与复杂的-SQL-优化"><a href="#7-1-极致的性能追求与复杂的-SQL-优化" class="headerlink" title="7.1 极致的性能追求与复杂的 SQL 优化"></a>7.1 极致的性能追求与复杂的 SQL 优化</h4><p>当应用程序的性能瓶颈在于数据库交互，且需要对 SQL 进行精细化、极致的优化时，原生 MyBatis 是不二之选。</p>
<ul>
<li><strong>完全掌控 SQL</strong>：开发者可以手动编写最高效的 SQL，包括使用数据库特有的查询提示（Hints）、强制使用特定索引、编写复杂的子查询或 <code>WITH</code> 公共表表达式（CTE）等。</li>
<li><strong>避免 ORM 开销</strong>：全自动 ORM 框架（如 Hibernate）在生成 SQL 的过程中可能会产生额外的性能开销，或者生成的 SQL 并非最优解。原生 MyBatis 则完全没有这层“中间商”。</li>
<li><strong>场景示例</strong>：高并发的电商系统中的商品查询、金融系统中的实时交易报表、秒杀活动等对数据库响应时间要求极为苛刻的场景。</li>
</ul>
<hr>
<h4 id="7-2-遗留系统或复杂的数据库设计"><a href="#7-2-遗留系统或复杂的数据库设计" class="headerlink" title="7.2 遗留系统或复杂的数据库设计"></a>7.2 遗留系统或复杂的数据库设计</h4><p>在面对设计不规范、年代久远的遗留系统数据库时，原生 MyBatis 的灵活性展现出巨大优势。</p>
<ul>
<li><strong>解耦领域模型与数据模型</strong>：遗留系统的表结构可能非常混乱，与理想的 Java 对象模型相去甚远。全自动 ORM 框架强制的实体映射关系在这种情况下会变得非常痛苦。</li>
<li><strong>强大的 <code>&lt;resultMap&gt;</code></strong>：通过 MyBatis 强大的 <code>&lt;resultMap&gt;</code>，你可以将任何复杂的查询结果（无论表结构多么不合理）灵活地映射到干净的 POJO 或 DTO 对象上，实现数据访问层对业务逻辑层的完美隔离。</li>
<li><strong>场景示例</strong>：对一个没有主外键约束、存在大量冗余字段、命名不规范的老旧系统进行现代化改造或功能扩展。</li>
</ul>
<hr>
<h4 id="7-3-报表系统与数据分析"><a href="#7-3-报表系统与数据分析" class="headerlink" title="7.3 报表系统与数据分析"></a>7.3 报表系统与数据分析</h4><p>报表和数据分析类需求往往涉及极其复杂的 SQL 查询，这些查询是业务的核心。</p>
<ul>
<li><strong>复杂的多表连接与聚合</strong>：报表查询通常需要连接十几个表，并进行大量的 <code>GROUP BY</code>, <code>HAVING</code>, 聚合函数（<code>SUM</code>, <code>AVG</code>, <code>COUNT</code>）和窗口函数等操作。用 Java 代码（如 JPA Criteria API）来构建这类查询既复杂又低效。</li>
<li><strong>SQL 集中管理</strong>：将这些复杂的报表 SQL 集中存放在 XML 文件中，使得 SQL 的维护、审查和调优变得非常方便，业务逻辑代码则保持简洁。</li>
<li><strong>场景示例</strong>：生成财务月度报表、BI 系统的数据看板、多维度的数据统计与分析。</li>
</ul>
<hr>
<h4 id="7-4-大量使用存储过程与数据库特性"><a href="#7-4-大量使用存储过程与数据库特性" class="headerlink" title="7.4 大量使用存储过程与数据库特性"></a>7.4 大量使用存储过程与数据库特性</h4><p>当业务逻辑严重依赖数据库的存储过程、函数或特定高级特性时，MyBatis 提供了最直接、最方便的支持。</p>
<ul>
<li><strong>一流的存储过程支持</strong>：MyBatis 对存储过程的调用支持非常完善，可以轻松处理输入参数、输出参数以及返回的结果集。</li>
<li><strong>利用数据库方言</strong>：可以无缝使用特定数据库的功能，例如 Oracle 的 <code>CONNECT BY</code> 树形查询、PostgreSQL 的 JSONB 函数等，而这些功能是标准化的 JPA 规范无法覆盖的。</li>
<li><strong>场景示例</strong>：与银行、电信等核心系统对接，这些系统通常会通过存储过程暴露接口；利用数据库原生功能进行高性能的地理空间计算或全文检索。</li>
</ul>
<hr>
<h4 id="7-5-对-SQL-有强掌控欲或-DBA-深度参与的项目"><a href="#7-5-对-SQL-有强掌控欲或-DBA-深度参与的项目" class="headerlink" title="7.5 对 SQL 有强掌控欲或 DBA 深度参与的项目"></a>7.5 对 SQL 有强掌控欲或 DBA 深度参与的项目</h4><p>在一些对数据库安全性和稳定性要求极高的团队或项目中，所有上线的 SQL 都需要经过 DBA (数据库管理员) 的严格审核。</p>
<ul>
<li><strong>SQL 透明化</strong>：MyBatis 的 XML 文件将所有 SQL 语句清晰地展示出来，非常便于 DBA 进行审查（Code Review）和性能分析（Explain Plan）。</li>
<li><strong>职责分离</strong>：Java 开发者负责业务逻辑，DBA 负责 SQL 的编写和优化，两者通过 XML 文件协作，职责清晰。全自动 ORM 产生的“黑盒”SQL 在这种模式下是不可接受的。</li>
<li><strong>场景示例</strong>：金融、证券、政府等领域的关键业务系统。</li>
</ul>
<hr>
<hr>
<h1 id="三、MyBatis-Plus-效率增强"><a href="#三、MyBatis-Plus-效率增强" class="headerlink" title="三、MyBatis-Plus (效率增强)"></a>三、MyBatis-Plus (效率增强)</h1><h2 id="1-简介与核心优势"><a href="#1-简介与核心优势" class="headerlink" title="1. 简介与核心优势"></a>1. 简介与核心优势</h2><h3 id="1-1-MyBatis-Plus-是什么？"><a href="#1-1-MyBatis-Plus-是什么？" class="headerlink" title="1.1 MyBatis-Plus 是什么？"></a>1.1 MyBatis-Plus 是什么？</h3><p><strong>MyBatis-Plus (简称 MP)</strong> 是一个为 MyBatis 量身打造的<strong>增强工具</strong>，其设计的初衷和口号是 <strong>“为简化而生”</strong>。它并非要取代 MyBatis，而是在 MyBatis 的基础上进行功能扩展和优化，旨在最大化地简化开发、提高效率。</p>
<p><strong>核心定位</strong>：</p>
<p>MyBatis-Plus 并不改变 MyBatis 的核心，它是一个<strong>无侵入</strong>的增强包。这意味着：</p>
<ul>
<li>依然可以像以前一样使用 MyBatis 的所有原生功能（如编写 XML、动态 SQL 等）。</li>
<li>在此之上，MP 提供了一系列开箱即用的强大功能，让你从大量重复的、简单的 CRUD（增删改查）工作中解放出来。</li>
</ul>
<hr>
<h3 id="1-2-核心优势"><a href="#1-2-核心优势" class="headerlink" title="1.2 核心优势"></a>1.2 核心优势</h3><h4 id="1-2-1-极简-CRUD"><a href="#1-2-1-极简-CRUD" class="headerlink" title="1.2.1 极简 CRUD"></a>1.2.1 极简 CRUD</h4><p>只需要定义一个 Mapper 接口并继承 <code>BaseMapper&lt;T&gt;</code>，即可<strong>无需编写任何 SQL 语句</strong>，自动拥有多达 30+ 种通用的增、删、改、查方法。这覆盖了 80% 以上的单表操作需求，极大地减少了样板代码。</p>
<ul>
<li><strong>示例</strong>：<code>insert()</code>, <code>deleteById()</code>, <code>updateById()</code>, <code>selectById()</code>, <code>selectList()</code>, <code>selectPage()</code> 等。</li>
</ul>
<hr>
<h4 id="1-2-2-强大的条件构造器-Wrapper"><a href="#1-2-2-强大的条件构造器-Wrapper" class="headerlink" title="1.2.2 强大的条件构造器 (Wrapper)"></a>1.2.2 强大的条件构造器 (Wrapper)</h4><p>MP 提供了一套功能强大且易于使用的条件构造器 (<code>Wrapper</code>)，允许9通过<strong>链式调用的 Java 代码</strong>来安全、动态地构建复杂的查询条件。这在绝大多数场景下可以完美替代手写 XML 动态 SQL。</p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>类型安全</strong>：推荐使用 <code>LambdaQueryWrapper</code>，它通过方法引用 (<code>User::getUsername</code>) 来指定字段，避免了手写字符串 “username” 可能带来的拼写错误，并能在编译期进行检查。</li>
<li><strong>代码直观</strong>：查询逻辑直接体现在 Java 代码中，比在 XML 和 Java 代码之间来回切换更加直观。</li>
<li><strong>功能丰富</strong>：支持 <code>like</code>, <code>gt</code>, <code>lt</code>, <code>in</code>, <code>or</code>, <code>groupBy</code>, <code>orderBy</code> 等所有常见 SQL 关键字。</li>
</ul>
<hr>
<h4 id="1-2-3-内置实用插件，开箱即用"><a href="#1-2-3-内置实用插件，开箱即用" class="headerlink" title="1.2.3 内置实用插件，开箱即用"></a>1.2.3 内置实用插件，开箱即用</h4><p>MP 提供了许多在企业级开发中高频使用的功能插件，只需简单配置即可启用，无需自己造轮子。</p>
<ul>
<li><strong>分页插件 (<code>PaginationInnerInterceptor</code>)</strong>: 实现了真正的物理分页，自动识别数据库类型并拼接分页 SQL，使用极其简单。</li>
<li><strong>乐观锁插件 (<code>OptimisticLockerInnerInterceptor</code>)</strong>: 优雅地实现了乐观锁机9制，有效防止并发场景下的数据更新冲突。</li>
<li><strong>防全表更新与删除插件 (<code>BlockAttackInnerInterceptor</code>)</strong>: 防止开发人员误操作，执行没有 <code>WHERE</code> 条件的 <code>UPDATE</code> 或 <code>DELETE</code> 语句，保障数据安全。</li>
</ul>
<hr>
<h4 id="1-2-4-代码生成器-AutoGenerator"><a href="#1-2-4-代码生成器-AutoGenerator" class="headerlink" title="1.2.4 代码生成器 (AutoGenerator)"></a>1.2.4 代码生成器 (AutoGenerator)</h4><p>这是一个极大地提升开发效率的利器。通过简单的配置，MP 的代码生成器可以一键为你生成 <strong>Entity、Mapper、Mapper.xml、Service、ServiceImpl、Controller</strong> 等所有分层的代码，让你专注于业务逻辑的实现。</p>
<hr>
<h4 id="1-2-5-无侵入设计，完美兼容"><a href="#1-2-5-无侵入设计，完美兼容" class="headerlink" title="1.2.5 无侵入设计，完美兼容"></a>1.2.5 无侵入设计，完美兼容</h4><p>MP 始终坚持“只做增强不做改变”的原则。它与原生 MyBatis 完美兼容。对于 MP 无法满足的复杂业务场景（如复杂的报表查询、存储过程调用等），你可以随时切换回 MyBatis 的传统方式，在 XML 文件中编写和优化你的 SQL，两者可以无缝共存。</p>
<hr>
<h4 id="1-2-6-内置高级功能"><a href="#1-2-6-内置高级功能" class="headerlink" title="1.2.6 内置高级功能"></a>1.2.6 内置高级功能</h4><ul>
<li><strong>逻辑删除</strong>: 只需一个注解 (<code>@TableLogic</code>) 和简单配置，即可实现“软删除”。所有查询会自动过滤掉被逻辑删除的数据，而删除操作会自动转为更新操作。</li>
<li><strong>自动填充 (<code>MetaObjectHandler</code>)</strong>: 对于 <code>create_time</code>, <code>update_time</code>, <code>create_by</code> 等公共字段，可以实现插入或更新时的自动填充，无需在业务代码中手动设置。</li>
<li><strong>强大的主键策略</strong>: 内置了雪花算法 (<code>ASSIGN_ID</code>)、UUID、数据库自增等多种主键生成策略，特别适合分布式系统。</li>
</ul>
<hr>
<h2 id="2-快速入门-与-Spring-Boot-集成"><a href="#2-快速入门-与-Spring-Boot-集成" class="headerlink" title="2. 快速入门 (与 Spring Boot 集成)"></a>2. 快速入门 (与 Spring Boot 集成)</h2><p>MyBatis-Plus 与 Spring Boot 的集成就如同鱼和水，官方提供了 <code>mybatis-plus-boot-starter</code>，使得整合过程极其简单快捷。下面将通过一个完整的步骤，演示如何在一个 Spring Boot 项目中快速集成并使用 MyBatis-Plus。</p>
<h3 id="2-1-环境与项目准备"><a href="#2-1-环境与项目准备" class="headerlink" title="2.1 环境与项目准备"></a>2.1 环境与项目准备</h3><ul>
<li><strong>环境</strong>: JDK 1.8+, Maven 3.6+, MySQL 5.7+</li>
<li><strong>项目</strong>: 使用 <a target="_blank" rel="noopener" href="https://start.spring.io/">Spring Initializr</a> 创建一个新的 Spring Boot 项目，并勾选以下依赖：<ul>
<li>Spring Web</li>
<li>MySQL Driver</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-添加-MyBatis-Plus-依赖"><a href="#2-2-添加-MyBatis-Plus-依赖" class="headerlink" title="2.2 添加 MyBatis-Plus 依赖"></a>2.2 添加 MyBatis-Plus 依赖</h3><p>在 <code>pom.xml</code> 文件中，添加 MyBatis-Plus 的启动器依赖。这个启动器已经包含了 MyBatis 核心和 Spring Boot 集成的所有必要组件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 使用一个较新的稳定版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-配置数据库连接"><a href="#2-3-配置数据库连接" class="headerlink" title="2.3 配置数据库连接"></a>2.3 配置数据库连接</h3><p>在 <code>src/main/resources/application.yml</code> (或 <code>application.properties</code>) 文件中，配置数据库的数据源信息。</p>
<p><strong><code>application.yml</code> 格式:</strong></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DataSource Configuration</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    	<span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/your_database?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf8</span></span><br><span class="line">    	<span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    	<span class="attr">password:</span> <span class="string">your_password</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MyBatis-Plus Global Configuration (可选)</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">	<span class="attr">configuration:</span></span><br><span class="line">    	<span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span> <span class="comment"># 日志打印到控制台</span></span><br><span class="line">		<span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span>     <span class="comment">#开启驼峰自动转换</span></span><br><span class="line">    <span class="attr">global-config:</span></span><br><span class="line">    	<span class="attr">db-config:</span></span><br><span class="line">      		<span class="attr">id-type:</span> <span class="string">assign_id</span>    <span class="comment">#设置统一的主键生成策略</span></span><br><span class="line">      		<span class="attr">logic-delete-field:</span> <span class="string">deleted</span>	<span class="comment"># 全局逻辑删除字段名(逻辑删除激活)</span></span><br><span class="line">      		<span class="attr">logic-delete-value:</span> <span class="number">1</span>	<span class="comment"># 全局逻辑删除字段名(逻辑删除激活)</span></span><br><span class="line">      		<span class="attr">logic-not-delete-value:</span> <span class="number">0</span>  <span class="comment"># 逻辑未删除值（默认为 0）</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 请替换 <code>your_database</code> 和 <code>your_password</code> 为你自己的配置。</p>
<hr>
<h3 id="2-4-创建实体类-Entity"><a href="#2-4-创建实体类-Entity" class="headerlink" title="2.4 创建实体类 (Entity)"></a>2.4 创建实体类 (Entity)</h3><p>创建一个与数据库表对应的 Java 实体类。使用 MyBatis-Plus 的注解来标识表名和主键。</p>
<p><strong>数据库表 (user):</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">  `age` <span class="type">INT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">  `email` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>

<p><strong>实体类 <code>User.java</code>:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/entity/User.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.entity;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span> <span class="comment">// 指定该实体类对应的数据库表名为 &quot;user&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span> <span class="comment">// 指定 id 是主键，并且主键策略是数据库自增</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getter/Setter/toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-5-创建-Mapper-接口"><a href="#2-5-创建-Mapper-接口" class="headerlink" title="2.5 创建 Mapper 接口"></a>2.5 创建 Mapper 接口</h3><p>创建一个 Mapper 接口，它需要继承 MyBatis-Plus 提供的 <code>BaseMapper&lt;T&gt;</code> 泛型接口。<strong>你不需要在这个接口里写任何方法定义</strong>，就已经拥有了强大的 CRUD 能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/mapper/UserMapper.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.mapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Mapper 注解也可以在这里加，但推荐在启动类上使用 @MapperScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// BaseMapper 已经提供了丰富的 CRUD 方法</span></span><br><span class="line">    <span class="comment">// 如果有自定义的、复杂的 SQL 查询，可以在这里定义方法，并在 XML 文件中实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-6-配置-Mapper-扫描"><a href="#2-6-配置-Mapper-扫描" class="headerlink" title="2.6 配置 Mapper 扫描"></a>2.6 配置 Mapper 扫描</h3><p>在 Spring Boot 的主启动类上，添加 <code>@MapperScan</code> 注解，告诉 MyBatis-Plus 去哪里查找你的 Mapper 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/MyApplication.java</span></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span> <span class="comment">// 扫描 com.example.mapper 包下的所有 Mapper 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-7-编写测试代码"><a href="#2-7-编写测试代码" class="headerlink" title="2.7 编写测试代码"></a>2.7 编写测试代码</h3><p>现在，你可以在任何被 Spring 管理的组件（如 <code>@Service</code> 或 <code>@RestController</code>）中注入 <code>UserMapper</code> 并直接使用了。</p>
<p>创建一个测试类来验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/test/java/com/example/MyApplicationTests.java</span></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSelectList</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----- selectAll method test ------&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用 BaseMapper 的 selectList 方法，参数为 null 表示查询所有</span></span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// Assert.isTrue(5 == userList.size(), &quot;&quot;); // 断言</span></span><br><span class="line">        userList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----- insert method test ------&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;MP-Tester&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">25</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;mp@baomidou.com&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;Insert result: &quot;</span> + result);</span><br><span class="line">        System.out.println(<span class="string">&quot;Generated ID: &quot;</span> + user.getId()); <span class="comment">// ID 会自动回填</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----- updateById method test ------&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>); <span class="comment">// 假设 ID=1 的用户存在</span></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            user.setAge(<span class="number">30</span>);</span><br><span class="line">            userMapper.updateById(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----- deleteById method test ------&quot;</span>);</span><br><span class="line">        userMapper.deleteById(<span class="number">1L</span>); <span class="comment">// 删除 ID=1 的用户</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-通用-CRUD-BaseMapper-IService"><a href="#3-通用-CRUD-BaseMapper-IService" class="headerlink" title="3. 通用 CRUD (BaseMapper &amp; IService)"></a>3. 通用 CRUD (BaseMapper &amp; IService)</h2><h3 id="3-1-BaseMapper-数据访问层的基石"><a href="#3-1-BaseMapper-数据访问层的基石" class="headerlink" title="3.1 BaseMapper&lt;T&gt;: 数据访问层的基石"></a>3.1 <code>BaseMapper&lt;T&gt;</code>: 数据访问层的基石</h3><p><code>BaseMapper</code> 是一个泛型接口，定义在数据访问层 (DAO&#x2F;Mapper)。<strong>只要你的 Mapper 接口继承了 <code>BaseMapper</code>，就立即拥有了一整套现成的、无需编写 SQL 的 CRUD 方法。</strong></p>
<h4 id="3-1-1-如何使用"><a href="#3-1-1-如何使用" class="headerlink" title="3.1.1 如何使用"></a>3.1.1 如何使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserMapper.java</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只需继承 BaseMapper&lt;User&gt; 即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里是空的！所有通用方法都已继承</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-2-常用方法一览"><a href="#3-1-2-常用方法一览" class="headerlink" title="3.1.2 常用方法一览"></a>3.1.2 常用方法一览</h4><p><code>BaseMapper</code> 提供了非常丰富的方法，以下是一些最常用的：</p>
<p><strong>插入操作 (Insert):</strong></p>
<ul>
<li><code>int insert(T entity)</code>: 插入一条记录。实体中为 <code>null</code> 的字段<strong>会</strong>被插入到数据库（即插入 <code>NULL</code> 值）。</li>
</ul>
<p><strong>删除操作 (Delete):</strong></p>
<ul>
<li><code>int deleteById(Serializable id)</code>: 根据主键 ID 删除一条记录。</li>
<li><code>int deleteBatchIds(Collection&lt;? extends Serializable&gt; idList)</code>: 根据 ID 批量删除。</li>
<li><code>int deleteByMap(Map&lt;String, Object&gt; columnMap)</code>: 根据 <code>Map</code> 中的列名和值删除记录（多个条件是 AND 关系）。</li>
<li><code>int delete(Wrapper&lt;T&gt; queryWrapper)</code>: 根据条件构造器 (<code>Wrapper</code>) 删除记录。</li>
</ul>
<p><strong>更新操作 (Update):</strong></p>
<ul>
<li><code>int updateById(T entity)</code>: 根据主键 ID 更新。实体中为 <code>null</code> 的字段<strong>不会</strong>被更新。</li>
<li><code>int update(T entity, Wrapper&lt;T&gt; updateWrapper)</code>: 根据 <code>Wrapper</code> 条件更新 <code>entity</code> 中<strong>非 <code>null</code></strong> 的字段。</li>
</ul>
<p><strong>查询操作 (Select):</strong></p>
<ul>
<li><code>T selectById(Serializable id)</code>: 根据主鍵 ID 查询一条记录。</li>
<li><code>List&lt;T&gt; selectBatchIds(Collection&lt;? extends Serializable&gt; idList)</code>: 根据 ID 批量查询。</li>
<li><code>T selectOne(Wrapper&lt;T&gt; queryWrapper)</code>: 根据 <code>Wrapper</code> 条件查询一条记录。如果结果超过 1 条会报错。</li>
<li><code>Long selectCount(Wrapper&lt;T&gt; queryWrapper)</code>: 根据 <code>Wrapper</code> 条件查询记录总数。</li>
<li><code>List&lt;T&gt; selectList(Wrapper&lt;T&gt; queryWrapper)</code>: 根据 <code>Wrapper</code> 条件查询所有记录。</li>
<li><code>IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</code>: 根据 <code>Wrapper</code> 条件进行分页查询。</li>
</ul>
<hr>
<h3 id="3-2-IService-ServiceImpl-业务逻辑层的封装"><a href="#3-2-IService-ServiceImpl-业务逻辑层的封装" class="headerlink" title="3.2 IService&lt;T&gt; &amp; ServiceImpl&lt;M, T&gt;: 业务逻辑层的封装"></a>3.2 <code>IService&lt;T&gt;</code> &amp; <code>ServiceImpl&lt;M, T&gt;</code>: 业务逻辑层的封装</h3><p>虽然 <code>BaseMapper</code> 已经很强大，但在实际分层架构中，我们通常不建议在 Controller 或更上层直接调用 Mapper。业务逻辑应该封装在 Service 层。为此，MP 贴心地提供了 <code>IService</code> 和 <code>ServiceImpl</code>。</p>
<p><strong><code>IService</code> 的作用</strong>：</p>
<ol>
<li><strong>分层解耦</strong>：遵循标准的 <code>Controller -&gt; Service -&gt; Mapper</code> 架构，使代码结构更清晰。</li>
<li><strong>功能增强</strong>：在 <code>BaseMapper</code> 的基础上，提供了一些更符合业务语义、功能更强大的方法，特别是批量操作。</li>
<li><strong>事务控制</strong>：Service 层是添加声明式事务 (<code>@Transactional</code>) 的理想位置。</li>
</ol>
<hr>
<h4 id="3-2-1-如何使用"><a href="#3-2-1-如何使用" class="headerlink" title="3.2.1 如何使用"></a>3.2.1 如何使用</h4><ol>
<li><p><strong>创建 <code>IService</code> 接口</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IUserService.java</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 可以在这里定义自定义的业务方法</span></span><br><span class="line">    <span class="comment">// e.g., void registerUser(User user);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建 <code>ServiceImpl</code> 实现类</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserServiceImpl.java</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">    <span class="comment">// ServiceImpl 已经自动注入了 baseMapper (即 UserMapper)，可以直接使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现自定义的业务方法</span></span><br><span class="line">    <span class="comment">// @Transactional</span></span><br><span class="line">    <span class="comment">// public void registerUser(User user) &#123;</span></span><br><span class="line">    <span class="comment">//     // 1. 检查用户名是否存在</span></span><br><span class="line">    <span class="comment">//     // 2. 加密密码</span></span><br><span class="line">    <span class="comment">//     // 3. 调用 baseMapper.insert(user) 或 save(user)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="3-2-2-IService-增强的方法"><a href="#3-2-2-IService-增强的方法" class="headerlink" title="3.2.2 IService 增强的方法"></a>3.2.2 <code>IService</code> 增强的方法</h4><p><code>IService</code> 不仅包含了 <code>BaseMapper</code> 的所有功能（通过 <code>getBaseMapper()</code> 调用），还提供了一些更方便的封装：</p>
<ul>
<li><strong><code>save(T entity)</code></strong>: 保存一条记录（内部调用 <code>insert</code>）。</li>
<li><strong><code>saveBatch(Collection&lt;T&gt; entityList)</code></strong>: 批量插入。</li>
<li><strong><code>saveOrUpdate(T entity)</code></strong>: 根据实体 <code>id</code> 是否存在，智能判断是插入还是更新。</li>
<li><strong><code>saveOrUpdateBatch(Collection&lt;T&gt; entityList)</code></strong>: 批量插入或更新。</li>
<li><strong><code>removeById(Serializable id)</code></strong>: 根据 ID 删除（内部调用 <code>deleteById</code>）。</li>
<li><strong><code>removeByIds(Collection&lt;?&gt; list)</code></strong>: 批量删除。</li>
<li><strong><code>updateById(T entity)</code></strong>: 根据 ID 更新。</li>
<li><strong><code>updateBatchById(Collection&lt;T&gt; entityList)</code></strong>: 批量更新。</li>
<li><strong><code>getById(Serializable id)</code></strong>: 根据 ID 查询（内部调用 <code>selectById</code>）。</li>
<li><strong><code>getOne(Wrapper&lt;T&gt; queryWrapper)</code></strong>: 查询一条记录。</li>
<li><strong><code>list()</code></strong>: 查询全部。</li>
<li><strong><code>page(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</code></strong>: 分页查询。</li>
</ul>
<hr>
<h3 id="3-3-BaseMapper-vs-IService-总结与最佳实践"><a href="#3-3-BaseMapper-vs-IService-总结与最佳实践" class="headerlink" title="3.3 BaseMapper vs IService (总结与最佳实践)"></a>3.3 <code>BaseMapper</code> vs <code>IService</code> (总结与最佳实践)</h3><table>
<thead>
<tr>
<th align="left">特性&#x2F;方面</th>
<th align="left"><code>BaseMapper&lt;T&gt;</code></th>
<th align="left"><code>IService&lt;T&gt;</code> &#x2F; <code>ServiceImpl&lt;M, T&gt;</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>层级定位</strong></td>
<td align="left"><strong>数据访问层 (DAO&#x2F;Mapper)</strong></td>
<td align="left"><strong>业务逻辑层 (Service)</strong></td>
</tr>
<tr>
<td align="left"><strong>主要职责</strong></td>
<td align="left">直接与数据库交互，执行最底层的 SQL 操作。</td>
<td align="left">封装业务逻辑，处理事务，组合 Mapper 方法。</td>
</tr>
<tr>
<td align="left"><strong>方法命名</strong></td>
<td align="left">偏向 SQL 动词，如 <code>insert</code>, <code>selectById</code>。</td>
<td align="left">偏向业务语义，如 <code>save</code>, <code>getById</code>, <code>remove</code>。</td>
</tr>
<tr>
<td align="left"><strong>批量操作</strong></td>
<td align="left">部分支持（如 <code>selectBatchIds</code>），但功能较少。</td>
<td align="left"><strong>提供了更完善的批量操作</strong>，如 <code>saveBatch</code>, <code>updateBatchById</code>。</td>
</tr>
<tr>
<td align="left"><strong>事务管理</strong></td>
<td align="left">不负责事务。</td>
<td align="left"><strong>是添加 <code>@Transactional</code> 的理想位置。</strong></td>
</tr>
<tr>
<td align="left"><strong>使用建议</strong></td>
<td align="left">在 <code>ServiceImpl</code> 内部调用。<strong>不应直接暴露给 Controller。</strong></td>
<td align="left"><strong>应由 Controller 调用</strong>，作为业务入口。</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong>:</p>
<ol>
<li><strong>严格分层</strong>：始终遵循 <code>Controller -&gt; IService -&gt; UserMapper</code> 的调用链路。Controller 注入 <code>IUserService</code>，而<strong>不是</strong> <code>UserMapper</code>。</li>
<li><strong>业务封装</strong>：将复杂的业务逻辑、多个 Mapper 操作的组合、事务控制等都放在 <code>ServiceImpl</code> 中完成。</li>
<li><strong>优先使用 <code>IService</code> 方法</strong>：在 Service 层，优先使用 <code>IService</code> 提供的 <code>save</code>, <code>getById</code>, <code>list</code> 等方法，因为它们更符合业务语义，且可能包含更优的实现（如批量操作）。</li>
<li><strong>自定义 SQL</strong>：对于 MP 通用方法无法满足的复杂查询（如多表连接），在 <code>UserMapper</code> 接口中定义新方法，并在对应的 XML 文件中编写 SQL，然后在 <code>ServiceImpl</code> 中调用这个自定义的 Mapper 方法。</li>
</ol>
<hr>
<h2 id="4-条件构造器-Wrapper"><a href="#4-条件构造器-Wrapper" class="headerlink" title="4. 条件构造器 (Wrapper)"></a>4. 条件构造器 (Wrapper)</h2><h3 id="4-1-QueryWrapper-UpdateWrapper"><a href="#4-1-QueryWrapper-UpdateWrapper" class="headerlink" title="4.1 QueryWrapper &amp; UpdateWrapper"></a>4.1 QueryWrapper &amp; UpdateWrapper</h3><h4 id="4-1-1-QueryWrapper"><a href="#4-1-1-QueryWrapper" class="headerlink" title="4.1.1 QueryWrapper&lt;T&gt;"></a>4.1.1 <code>QueryWrapper&lt;T&gt;</code></h4><p><strong>用途</strong>：主要用于构建 <strong>查询</strong> 条件，即 <code>SELECT</code> 语句的 <code>WHERE</code> 子句、<code>ORDER BY</code> 子句等。</p>
<p>它是 MP 中使用频率最高的条件构造器。</p>
<h5 id="1-核心方法"><a href="#1-核心方法" class="headerlink" title="1. 核心方法"></a>1. 核心方法</h5><p><code>QueryWrapper</code> 提供了丰富的链式方法，几乎涵盖了所有 SQL <code>WHERE</code> 子句的操作。</p>
<p><strong>比较操作:</strong></p>
<ul>
<li><code>eq(column, value)</code>: 等于 <code>=</code> (equal)</li>
<li><code>ne(column, value)</code>: 不等于 <code>&lt;&gt;</code> (not equal)</li>
<li><code>gt(column, value)</code>: 大于 <code>&gt;</code> (greater than)</li>
<li><code>ge(column, value)</code>: 大于等于 <code>&gt;=</code> (greater than or equal)</li>
<li><code>lt(column, value)</code>: 小于 <code>&lt;</code> (less than)</li>
<li><code>le(column, value)</code>: 小于等于 <code>&lt;=</code> (less than or equal)</li>
<li><code>between(column, val1, val2)</code>: <code>BETWEEN ... AND ...</code></li>
<li><code>notBetween(column, val1, val2)</code>: <code>NOT BETWEEN ... AND ...</code></li>
</ul>
<p><strong>模糊查询:</strong></p>
<ul>
<li><code>like(column, value)</code>: <code>LIKE &#39;%值%&#39;</code></li>
<li><code>notLike(column, value)</code>: <code>NOT LIKE &#39;%值%&#39;</code></li>
<li><code>likeLeft(column, value)</code>: <code>LIKE &#39;%值&#39;</code> (左模糊)</li>
<li><code>likeRight(column, value)</code>: <code>LIKE &#39;值%&#39;</code> (右模糊)</li>
</ul>
<p><strong>空值判断:</strong></p>
<ul>
<li><code>isNull(column)</code>: <code>... IS NULL</code></li>
<li><code>isNotNull(column)</code>: <code>... IS NOT NULL</code></li>
</ul>
<p><strong>集合操作:</strong></p>
<ul>
<li><code>in(column, collection)</code>: <code>... IN (...)</code></li>
<li><code>notIn(column, collection)</code>: <code>... NOT IN (...)</code></li>
<li><code>inSql(column, sql)</code>: <code>... IN (子查询)</code></li>
</ul>
<p><strong>逻辑连接:</strong></p>
<ul>
<li><code>or()</code>: 连接 <code>OR</code> 条件。例如 <code>... WHERE name = &#39;Tom&#39; OR age &gt; 25</code></li>
<li><code>and(Consumer&lt;Wrapper&gt; consumer)</code>: 嵌套 <code>AND</code> 条件。例如 <code>... AND (name = &#39;Tom&#39; AND age &gt; 25)</code></li>
<li><code>nested(Consumer&lt;Wrapper&gt; consumer)</code>: 正常嵌套，括号内由 <code>AND</code> 连接。</li>
</ul>
<p><strong>排序与分组:</strong></p>
<ul>
<li><code>orderByAsc(column...)</code>: 升序 <code>ORDER BY ... ASC</code></li>
<li><code>orderByDesc(column...)</code>: 降序 <code>ORDER BY ... DESC</code></li>
<li><code>groupBy(column...)</code>: <code>GROUP BY ...</code></li>
</ul>
<p><strong>结果集筛选:</strong></p>
<ul>
<li><code>select(column...)</code>: 指定要查询的字段。例如 <code>select(&quot;id&quot;, &quot;name&quot;)</code> 会生成 <code>SELECT id, name FROM ...</code></li>
</ul>
<hr>
<h5 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="2. 使用示例"></a>2. 使用示例</h5><p><strong>场景</strong>：查询所有年龄在 20 到 30 岁之间、名字中包含 “a”、并且邮箱不为空的用户，结果按年龄降序排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入 UserMapper</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 QueryWrapper 对象</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 链式调用，构建查询条件</span></span><br><span class="line">    queryWrapper.between(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>, <span class="number">30</span>) <span class="comment">// age BETWEEN 20 AND 30</span></span><br><span class="line">                .like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;a&quot;</span>)       <span class="comment">// AND name LIKE &#x27;%a%&#x27;</span></span><br><span class="line">                .isNotNull(<span class="string">&quot;email&quot;</span>)      <span class="comment">// AND email IS NOT NULL</span></span><br><span class="line">                .orderByDesc(<span class="string">&quot;age&quot;</span>);     <span class="comment">// ORDER BY age DESC</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将 Wrapper 作为参数传入 Mapper 方法</span></span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(queryWrapper);</span><br><span class="line"></span><br><span class="line">    userList.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MP 最终生成的 SQL 语句大致如下：<code>SELECT id, name, age, email FROM user WHERE age BETWEEN ? AND ? AND name LIKE ? AND email IS NOT NULL ORDER BY age DESC</code></p>
<hr>
<h4 id="4-1-2-UpdateWrapper"><a href="#4-1-2-UpdateWrapper" class="headerlink" title="4.1.2 UpdateWrapper&lt;T&gt;"></a>4.1.2 <code>UpdateWrapper&lt;T&gt;</code></h4><p><strong>用途</strong>：功能比 <code>QueryWrapper</code> 更广，它既可以用于构建 <strong>更新</strong> 和 <strong>删除</strong> 时的 <code>WHERE</code> 条件，还可以用于指定 <code>UPDATE</code> 语句的 <code>SET</code> 子句。</p>
<h5 id="1-核心方法-1"><a href="#1-核心方法-1" class="headerlink" title="1. 核心方法"></a>1. 核心方法</h5><p><code>UpdateWrapper</code> 继承了 <code>QueryWrapper</code> 的所有 <code>WHERE</code> 构建方法，并在此基础上增加了用于更新操作的方法。</p>
<p><strong>设置更新字段:</strong></p>
<ul>
<li><strong><code>set(column, value)</code></strong>: 核心方法，用于指定 <code>SET column = value</code>。</li>
<li><code>setSql(sql)</code>: 用于设置复杂的 SQL 表达式，如 <code>setSql(&quot;age = age + 1&quot;)</code>。</li>
</ul>
<hr>
<h5 id="2-使用示例-1"><a href="#2-使用示例-1" class="headerlink" title="2. 使用示例"></a>2. 使用示例</h5><p><strong>示例1: 更新操作</strong></p>
<p><strong>场景</strong>：将所有名字为 “Sandy” 的用户的年龄更新为 22 岁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 UpdateWrapper 对象</span></span><br><span class="line">UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 构建 SET 子句和 WHERE 子句</span></span><br><span class="line">updateWrapper.set(<span class="string">&quot;age&quot;</span>, <span class="number">22</span>)         <span class="comment">// SET age = 22</span></span><br><span class="line">             .eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Sandy&quot;</span>);    <span class="comment">// WHERE name = &#x27;Sandy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 调用 update 方法，第一个参数为 null (因为 set 已经在 wrapper 中定义)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">updatedRows</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">System.out.println(<span class="string">&quot;Updated rows: &quot;</span> + updatedRows);</span><br></pre></td></tr></table></figure>

<p>生成的 SQL 语句大致如下：<code>UPDATE user SET age = ? WHERE name = ?</code></p>
<p><strong>示例2: 删除操作</strong></p>
<p><strong>场景</strong>：删除所有年龄大于 60 岁的用户。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 UpdateWrapper 对象 (也可以用 QueryWrapper，因为只用到 WHERE)</span></span><br><span class="line">UpdateWrapper&lt;User&gt; deleteWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 构建 WHERE 子句</span></span><br><span class="line">deleteWrapper.gt(<span class="string">&quot;age&quot;</span>, <span class="number">60</span>); <span class="comment">// WHERE age &gt; 60</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 调用 delete 方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">deletedRows</span> <span class="operator">=</span> userMapper.delete(deleteWrapper);</span><br><span class="line">System.out.println(<span class="string">&quot;Deleted rows: &quot;</span> + deletedRows);</span><br></pre></td></tr></table></figure>

<p>生成的 SQL 语句大致如下：<code>DELETE FROM user WHERE age &gt; ?</code></p>
<hr>
<h3 id="4-2-LambdaQueryWrapper-LambdaUpdateWrapper"><a href="#4-2-LambdaQueryWrapper-LambdaUpdateWrapper" class="headerlink" title="4.2 LambdaQueryWrapper &amp; LambdaUpdateWrapper"></a>4.2 LambdaQueryWrapper &amp; LambdaUpdateWrapper</h3><h4 id="4-2-1-为什么需要-Lambda-Wrapper？"><a href="#4-2-1-为什么需要-Lambda-Wrapper？" class="headerlink" title="4.2.1 为什么需要 Lambda Wrapper？"></a>4.2.1 为什么需要 Lambda Wrapper？</h4><p>使用 <code>QueryWrapper(&quot;name&quot;, &quot;value&quot;)</code> 这种方式存在几个显著的缺点：</p>
<ol>
<li><strong>无编译期安全检查</strong>：如果字段名 <code>name</code> 拼写错误，例如写成了 <code>namae</code>，编译器不会报错，只有在程序运行时才会抛出异常。</li>
<li><strong>重构困难</strong>：当实体类的属性名或数据库字段名需要修改时，你必须手动在整个项目中搜索并替换这些字符串，非常容易出错和遗漏。</li>
<li><strong>IDE 支持不佳</strong>：IDE 无法对字符串进行有效的代码提示、补全或跳转。</li>
</ol>
<p>Lambda Wrapper 通过<strong>方法引用 (Method Reference)</strong> 的方式完美地解决了以上所有问题。</p>
<hr>
<h4 id="4-2-2-核心思想"><a href="#4-2-2-核心思想" class="headerlink" title="4.2.2 核心思想"></a>4.2.2 核心思想</h4><p>Lambda Wrapper 利用了 Java 8 的方法引用特性，例如 <code>User::getName</code>。MyBatis-Plus 可以在运行时解析这个方法引用，从而安全地、动态地获取到对应的属性名 (<code>name</code>)，并根据驼峰命名或注解规则映射到数据库的列名 (<code>name</code> 或 <code>user_name</code>)。</p>
<p>这样一来，字段的指定就从一个不安全的<strong>字符串</strong>变成了一个与实体类强关联的<strong>方法引用</strong>。</p>
<hr>
<h4 id="4-2-3-LambdaQueryWrapper"><a href="#4-2-3-LambdaQueryWrapper" class="headerlink" title="4.2.3 LambdaQueryWrapper&lt;T&gt;"></a>4.2.3 <code>LambdaQueryWrapper&lt;T&gt;</code></h4><p>它是 <code>QueryWrapper</code> 的 Lambda 版本，使用方式几乎完全相同，只是将列名的字符串参数替换为了方法引用。</p>
<p><strong>对比示例</strong></p>
<p><strong>场景</strong>：查询所有年龄在 20 到 30 岁之间、名字中包含 “a”、并且邮箱不为空的用户，结果按年龄降序排序。</p>
<p><strong>之前 (使用 <code>QueryWrapper</code>)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">queryWrapper.between(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">            .like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">            .isNotNull(<span class="string">&quot;email&quot;</span>)</span><br><span class="line">            .orderByDesc(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">List&lt;User&gt; userList = userMapper.selectList(queryWrapper);</span><br></pre></td></tr></table></figure>

<p><strong>现在 (使用 <code>LambdaQueryWrapper</code>)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 LambdaQueryWrapper 对象</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; lambdaQuery = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用方法引用来指定列，更加安全和直观</span></span><br><span class="line">lambdaQuery.between(User::getAge, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">           .like(User::getName, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">           .isNotNull(User::getEmail)</span><br><span class="line">           .orderByDesc(User::getAge);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行查询</span></span><br><span class="line">List&lt;User&gt; userList = userMapper.selectList(lambdaQuery);</span><br></pre></td></tr></table></figure>

<p><strong>LambdaQueryWrapper 的优势</strong></p>
<ol>
<li><strong>编译期安全</strong>：如果你写的 <code>User::getNamae</code> 是一个不存在的方法，代码将无法通过编译，错误在开发阶段就被发现。</li>
<li><strong>代码可读性与智能提示</strong>：IDE 可以为 <code>User::</code> 提供所有 <code>get</code> 方法的提示，代码意图一目了然。</li>
<li><strong>重构友好</strong>：当你想把 <code>User</code> 类的 <code>name</code> 属性重命名为 <code>username</code> 时，只需使用 IDE 的重构功能（例如 <code>Shift+F6</code>），所有相关的 <code>User::getName</code> 引用都会被自动更新为 <code>User::getUsername</code>，安全可靠。</li>
</ol>
<hr>
<h4 id="4-2-4-LambdaUpdateWrapper"><a href="#4-2-4-LambdaUpdateWrapper" class="headerlink" title="4.2.4 LambdaUpdateWrapper&lt;T&gt;"></a>4.2.4 <code>LambdaUpdateWrapper&lt;T&gt;</code></h4><p>同理，<code>LambdaUpdateWrapper</code> 是 <code>UpdateWrapper</code> 的 Lambda 版本。</p>
<p><strong>对比示例</strong></p>
<p><strong>场景</strong>：将所有名字为 “Sandy” 的用户的年龄更新为 22 岁。</p>
<p><strong>之前 (使用 <code>UpdateWrapper</code>)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">updateWrapper.set(<span class="string">&quot;age&quot;</span>, <span class="number">22</span>)</span><br><span class="line">             .eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Sandy&quot;</span>);</span><br><span class="line">userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br></pre></td></tr></table></figure>

<p><strong>现在 (使用 <code>LambdaUpdateWrapper</code>)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LambdaUpdateWrapper&lt;User&gt; lambdaUpdate = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">lambdaUpdate.set(User::getAge, <span class="number">22</span>)</span><br><span class="line">            .eq(User::getName, <span class="string">&quot;Sandy&quot;</span>);</span><br><span class="line">userMapper.update(<span class="literal">null</span>, lambdaUpdate);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-5-总结与最佳实践"><a href="#4-2-5-总结与最佳实践" class="headerlink" title="4.2.5 总结与最佳实践"></a>4.2.5 总结与最佳实践</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>QueryWrapper</code> (字符串)</th>
<th align="left"><code>LambdaQueryWrapper</code> (Lambda)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>语法</strong></td>
<td align="left"><code>wrapper.eq(&quot;name&quot;, &quot;Tom&quot;)</code></td>
<td align="left"><code>wrapper.eq(User::getName, &quot;Tom&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong>类型安全</strong></td>
<td align="left"><strong>无</strong>，依赖字符串的正确性</td>
<td align="left"><strong>有</strong>，依赖方法引用，编译期检查</td>
</tr>
<tr>
<td align="left"><strong>重构支持</strong></td>
<td align="left"><strong>差</strong>，需要手动修改字符串</td>
<td align="left"><strong>优秀</strong>，IDE 可自动重构</td>
</tr>
<tr>
<td align="left"><strong>IDE支持</strong></td>
<td align="left">弱，无代码提示和跳转</td>
<td align="left">强，提供方法提示、补全和跳转</td>
</tr>
<tr>
<td align="left"><strong>推荐度</strong></td>
<td align="left">不推荐在项目中使用</td>
<td align="left"><strong>强烈推荐，是现代 MP 开发的首选</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="4-3-常用查询方法详解"><a href="#4-3-常用查询方法详解" class="headerlink" title="4.3 常用查询方法详解"></a>4.3 常用查询方法详解</h3><h4 id="4-3-1-查询单个对象-selectOne"><a href="#4-3-1-查询单个对象-selectOne" class="headerlink" title="4.3.1 查询单个对象: selectOne()"></a>4.3.1 查询单个对象: <code>selectOne()</code></h4><ul>
<li><p><strong>方法签名</strong>: <code>T selectOne(Wrapper&lt;T&gt; queryWrapper)</code></p>
</li>
<li><p><strong>功能描述</strong>: 根据 <code>Wrapper</code> 条件查询<strong>一条</strong>记录。</p>
</li>
<li><p><strong>使用场景</strong>: 当你预期查询结果<strong>有且仅有一条</strong>时使用。例如，根据唯一的用户名、邮箱或手机号查询用户信息。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户名为 &quot;admin&quot; 的用户</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.eq(User::getName, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">admin</span> <span class="operator">=</span> userMapper.selectOne(wrapper);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (admin != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Found admin user: &quot;</span> + admin);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Admin user not found.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重要注意事项</strong>:</p>
<ul>
<li>如果查询结果<strong>不存在</strong>，此方法返回 <code>null</code>。</li>
<li>如果查询结果<strong>超过一条</strong>，此方法会抛出 <code>TooManyResultsException</code> 异常。这是为了防止脏数据或不严谨的查询条件导致业务逻辑错误，是一个非常重要的保护机制。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-3-2-查询对象列表-selectList"><a href="#4-3-2-查询对象列表-selectList" class="headerlink" title="4.3.2 查询对象列表: selectList()"></a>4.3.2 查询对象列表: <code>selectList()</code></h4><ul>
<li><p><strong>方法签名</strong>: <code>List&lt;T&gt; selectList(Wrapper&lt;T&gt; queryWrapper)</code></p>
</li>
<li><p><strong>功能描述</strong>: 根据 <code>Wrapper</code> 条件查询<strong>所有</strong>满足条件的记录。这是最常用的查询方法。</p>
</li>
<li><p><strong>使用场景</strong>: 查询满足某个条件的一组数据。例如，查询所有年龄大于 18 岁的用户，或查询某个部门下的所有员工。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有年龄大于 18 岁的用户</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.gt(User::getAge, <span class="number">18</span>);</span><br><span class="line">List&lt;User&gt; adults = userMapper.selectList(wrapper);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Total adult users: &quot;</span> + adults.size());</span><br><span class="line">adults.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重要注意事项</strong>:</p>
<ul>
<li>如果查询结果<strong>不存在</strong>，此方法返回一个<strong>空的 <code>List</code></strong> (<code>Collections.emptyList()</code>)，而<strong>不是 <code>null</code></strong>。这避免了空指针异常，是一个很好的设计。</li>
<li><strong>性能警惕</strong>：当查询的表数据量巨大时，在没有分页的情况下直接调用 <code>selectList</code> 可能会一次性加载大量数据到内存，导致<strong>内存溢出 (OOM)</strong>。务必确保你的查询条件足够精确，或者使用分页查询。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-3-3-查询记录总数-selectCount"><a href="#4-3-3-查询记录总数-selectCount" class="headerlink" title="4.3.3 查询记录总数: selectCount()"></a>4.3.3 查询记录总数: <code>selectCount()</code></h4><ul>
<li><p><strong>方法签名</strong>: <code>Long selectCount(Wrapper&lt;T&gt; queryWrapper)</code></p>
</li>
<li><p><strong>功能描述</strong>: 根据 <code>Wrapper</code> 条件查询满足条件的记录<strong>总数</strong>。</p>
</li>
<li><p><strong>使用场景</strong>: 获取总数以用于分页显示，或进行业务统计。例如，统计网站的注册用户总数，或搜索结果的总条目数。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计邮箱后缀为 @gmail.com 的用户数量</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.likeRight(User::getEmail, <span class="string">&quot;@gmail.com&quot;</span>); <span class="comment">// email LIKE &#x27;@gmail.com%&#x27;</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> userMapper.selectCount(wrapper);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Gmail user count: &quot;</span> + count);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重要注意事项</strong>:</p>
<ul>
<li>该方法底层执行的是 <code>SELECT COUNT(*)</code> SQL 语句，比 <code>userMapper.selectList(wrapper).size()</code> 的方式<strong>高效得多</strong>，因为它只返回一个数字，而不需要传输和映射整个结果集。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-3-4-分页查询-selectPage"><a href="#4-3-4-分页查询-selectPage" class="headerlink" title="4.3.4 分页查询: selectPage()"></a>4.3.4 分页查询: <code>selectPage()</code></h4><ul>
<li><p><strong>方法签名</strong>: <code>IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</code></p>
</li>
<li><p><strong>功能描述</strong>: 根据 <code>Wrapper</code> 条件进行<strong>物理分页</strong>查询。</p>
</li>
<li><p><strong>使用场景</strong>: Web 后台管理系统的表格数据展示、App 的信息流列表加载等需要分页的场景。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询第二页，每页 5 条数据</span></span><br><span class="line"><span class="comment">// 1. 创建 Page 对象，传入当前页码和每页数量</span></span><br><span class="line">Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建 Wrapper (可以为 null，表示查询所有)</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.orderByDesc(User::getId); <span class="comment">// 按 ID 降序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行分页查询，返回 IPage 对象</span></span><br><span class="line">IPage&lt;User&gt; userPage = userMapper.selectPage(page, wrapper);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 从 IPage 对象中获取分页信息</span></span><br><span class="line">System.out.println(<span class="string">&quot;总页数: &quot;</span> + userPage.getPages());</span><br><span class="line">System.out.println(<span class="string">&quot;总记录数: &quot;</span> + userPage.getTotal());</span><br><span class="line">System.out.println(<span class="string">&quot;当前页数据: &quot;</span>);</span><br><span class="line">userPage.getRecords().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重要注意事项</strong>:</p>
<ul>
<li><strong>必须配置分页插件！</strong> 使用此方法前，必须在 Spring Boot 配置中添加 <code>MybatisPlusInterceptor</code> 并注册 <code>PaginationInnerInterceptor</code>。否则，<code>selectPage</code> 方法会退化成 <code>selectList</code>，一次性查询出所有数据，无法实现分页效果，并可能导致内存溢出。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-3-5-检查存在性-exists-MP-3-5-3-版本"><a href="#4-3-5-检查存在性-exists-MP-3-5-3-版本" class="headerlink" title="4.3.5 检查存在性: exists() (MP 3.5.3+ 版本)"></a>4.3.5 检查存在性: <code>exists()</code> (MP 3.5.3+ 版本)</h4><ul>
<li><p><strong>方法签名</strong>: <code>boolean exists(Wrapper&lt;T&gt; queryWrapper)</code></p>
</li>
<li><p><strong>功能描述</strong>: 根据 <code>Wrapper</code> 条件判断是否存在满足条件的记录。</p>
</li>
<li><p><strong>使用场景</strong>: 需要快速判断数据是否存在，而不需要获取具体数据。例如，注册时检查用户名是否已被占用。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否存在名为 &quot;root&quot; 的用户</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.eq(User::getName, <span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isExist</span> <span class="operator">=</span> userMapper.exists(wrapper);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isExist) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Username &#x27;root&#x27; already exists.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重要注意事项</strong>:</p>
<ul>
<li>此方法比 <code>selectCount(wrapper) &gt; 0</code> 的方式<strong>更高效</strong>。因为它底层生成的 SQL 是 <code>SELECT 1 FROM ... LIMIT 1</code>，数据库只要找到第一条匹配的记录就会立即返回，而 <code>COUNT</code> 则需要扫描所有满足条件的记录。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-核心插件机制"><a href="#5-核心插件机制" class="headerlink" title="5. 核心插件机制"></a>5. 核心插件机制</h2><h3 id="5-1-分页插件-PaginationInnerInterceptor"><a href="#5-1-分页插件-PaginationInnerInterceptor" class="headerlink" title="5.1 分页插件 (PaginationInnerInterceptor)"></a>5.1 分页插件 (PaginationInnerInterceptor)</h3><h4 id="5-1-1-为什么需要分页插件？"><a href="#5-1-1-为什么需要分页插件？" class="headerlink" title="5.1.1 为什么需要分页插件？"></a>5.1.1 为什么需要分页插件？</h4><p>如果没有分页插件，实现分页查询会非常痛苦：</p>
<ol>
<li><strong>SQL 方言差异</strong>：不同数据库的分页 SQL 完全不同。MySQL 使用 <code>LIMIT</code>, Oracle 使用 <code>ROWNUM</code>, SQL Server 使用 <code>OFFSET...FETCH...</code>。开发者需要为每种数据库编写不同的分页逻辑。</li>
<li><strong>硬编码与拼接</strong>：开发者需要在代码或 XML 中手动拼接分页参数，容易出错且不安全。</li>
<li><strong>逻辑分页的陷阱</strong>：一种错误的做法是查询出所有数据，然后在 Java 内存中进行分页（逻辑分页）。当数据量巨大时，这会立即导致<strong>内存溢出 (OOM)</strong>。</li>
</ol>
<p>MP 的分页插件通过<strong>拦截并改写 SQL</strong>的方式，实现了<strong>物理分页</strong>，从根本上解决了以上所有问题。</p>
<hr>
<h4 id="5-1-2-插件的核心原理"><a href="#5-1-2-插件的核心原理" class="headerlink" title="5.1.2 插件的核心原理"></a>5.1.2 插件的核心原理</h4><p><code>PaginationInnerInterceptor</code> 是 MyBatis-Plus 拦截器链中的一个内部拦截器。它的工作原理如下：</p>
<ol>
<li><strong>拦截</strong>：当 MP 执行一个 Mapper 方法时，<code>MybatisPlusInterceptor</code> 会拦截这次调用。</li>
<li><strong>判断</strong>：<code>PaginationInnerInterceptor</code> 会检查方法的参数中是否包含 <code>IPage</code> 接口的实现类（通常是 <code>Page</code> 对象）。如果包含，就认为这是一次分页查询。</li>
<li><strong>改写 SQL</strong>: 插件会获取本次查询的原始 SQL 语句，并根据配置的数据库类型 (<code>DbType</code>) 和 <code>Page</code> 对象中的分页参数（当前页 <code>current</code>、每页数量 <code>size</code>），自动在原始 SQL 的末尾追加上对应数据库的分页语句（如 <code>LIMIT ?,?</code>）。</li>
<li><strong>执行查询</strong>: 执行被改写后的分页 SQL，获取当前页的数据。</li>
<li><strong>执行 Count 查询</strong>: 插件会自动生成一条 <code>SELECT COUNT(*)</code> 语句（基于原始 SQL）来查询满足条件的总记录数。</li>
<li><strong>封装返回</strong>: 将查询到的当前页数据列表、总记录数、总页数等信息全部封装到传入的 <code>Page</code> 对象中，并最终返回。</li>
</ol>
<hr>
<h4 id="5-1-3-如何配置-Spring-Boot"><a href="#5-1-3-如何配置-Spring-Boot" class="headerlink" title="5.1.3 如何配置 (Spring Boot)"></a>5.1.3 如何配置 (Spring Boot)</h4><p>自 MP 3.4.0 版本起，官方推荐使用 <code>MybatisPlusInterceptor</code> 来统一管理所有内部拦截器。</p>
<ol>
<li>创建一个配置类（例如 <code>MybatisPlusConfig.java</code>）。</li>
<li>将 <code>MybatisPlusInterceptor</code> 注册为一个 Spring Bean。</li>
<li>向 <code>MybatisPlusInterceptor</code> 中添加 <code>PaginationInnerInterceptor</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/config/MybatisPlusConfig.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加分页插件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 定义 MybatisPlusInterceptor 拦截器</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 添加具体的分页插件 PaginationInnerInterceptor</span></span><br><span class="line">        <span class="comment">//    参数指定了数据库类型，MP 会根据该类型生成对应的分页 SQL</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL)); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置说明</strong>:</p>
<ul>
<li><code>DbType.MYSQL</code>: 明确指定数据库类型为 MySQL。MP 支持所有主流数据库，如 <code>ORACLE</code>, <code>POSTGRE_SQL</code> 等。通常 MP 也能自动识别，但显式指定更稳妥。</li>
<li><strong>必须配置</strong>：如果不配置这个 Bean，所有分页相关的调用 (<code>selectPage</code>) 都不会生效，会退化为查询全表数据。</li>
</ul>
<hr>
<h4 id="5-1-4-如何使用"><a href="#5-1-4-如何使用" class="headerlink" title="5.1.4 如何使用"></a>5.1.4 如何使用</h4><p>配置完成后，在 Service 或 Mapper 中使用分页查询就变得非常简单。</p>
<p><strong>核心步骤</strong>：</p>
<ol>
<li>创建一个 <code>Page&lt;T&gt;</code> 对象，指定<strong>当前页码 (current)</strong> 和 <strong>每页显示条数 (size)</strong>。</li>
<li>（可选）创建一个 <code>Wrapper</code> 来设置查询条件。</li>
<li>调用 <code>mapper.selectPage(page, wrapper)</code> 或 <code>service.page(page, wrapper)</code> 方法。</li>
<li>从返回的 <code>IPage&lt;T&gt;</code> 对象中获取分页结果。</li>
</ol>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IPage&lt;User&gt; <span class="title function_">findUsersByPage</span><span class="params">(<span class="type">int</span> currentPage, <span class="type">int</span> pageSize, Integer minAge)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 Page 对象</span></span><br><span class="line">        <span class="comment">// 参数：当前页，每页大小</span></span><br><span class="line">        Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(currentPage, pageSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建查询条件 Wrapper</span></span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (minAge != <span class="literal">null</span>) &#123;</span><br><span class="line">            wrapper.ge(User::getAge, minAge);</span><br><span class="line">        &#125;</span><br><span class="line">        wrapper.orderByDesc(User::getId); <span class="comment">// 按 ID 降序排序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 执行分页查询。</span></span><br><span class="line">        <span class="comment">// MP 会自动将查询结果和分页信息封装到 page 对象中</span></span><br><span class="line">        <span class="comment">// 注意：selectPage 方法的返回值就是传入的 page 对象，也可以不接收返回值直接使用 page。</span></span><br><span class="line">        IPage&lt;User&gt; userPage = <span class="built_in">this</span>.baseMapper.selectPage(page, wrapper);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 从 IPage 对象中获取分页信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;查询结果--------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总记录数: &quot;</span> + userPage.getTotal());</span><br><span class="line">        System.out.println(<span class="string">&quot;总页数: &quot;</span> + userPage.getPages());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前页码: &quot;</span> + userPage.getCurrent());</span><br><span class="line">        System.out.println(<span class="string">&quot;每页数量: &quot;</span> + userPage.getSize());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前页数据: &quot;</span>);</span><br><span class="line">        userPage.getRecords().forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> userPage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-1-5-总结与注意事项"><a href="#5-1-5-总结与注意事项" class="headerlink" title="5.1.5 总结与注意事项"></a>5.1.5 总结与注意事项</h4><ul>
<li><strong>必须配置</strong>：分页插件不是开箱即用的，必须手动将其配置为 Spring Bean。</li>
<li><strong>物理分页</strong>：插件实现的是物理分页，直接在数据库层面完成数据筛选，性能高，内存占用小。</li>
<li><strong>两次 SQL</strong>：一次 <code>selectPage</code> 调用通常会触发<strong>两次</strong>数据库查询：一次是获取总记录数的 <code>COUNT(*)</code> 查询，另一次是获取当前页数据的分页查询。</li>
<li><strong><code>IPage</code> 返回值</strong>：分页查询的返回结果是一个 <code>IPage</code> 对象（<code>Page</code> 是其实现类），它包含了分页所需的所有信息（数据列表、总数、总页数等），可以直接返回给前端进行渲染。</li>
<li><strong>参数传递</strong>：<code>Page</code> 对象是作为参数传入的，MP 在执行过程中会修改这个对象的内容，而不是创建一个新的对象。</li>
</ul>
<hr>
<h3 id="5-2-乐观锁插件-OptimisticLockerInnerInterceptor"><a href="#5-2-乐观锁插件-OptimisticLockerInnerInterceptor" class="headerlink" title="5.2 乐观锁插件 (OptimisticLockerInnerInterceptor)"></a>5.2 乐观锁插件 (OptimisticLockerInnerInterceptor)</h3><p>在多线程或分布式高并发场景下，数据的一致性至关重要。”更新丢失” (Lost Update) 是一个常见的问题：当多个线程同时读取同一条数据，各自修改后又写回数据库，最后一个写回的操作会覆盖掉之前的所有修改，导致数据丢失。</p>
<p><strong>解决并发更新问题的两种主要方式</strong>：</p>
<ol>
<li><strong>悲观锁 (Pessimistic Locking)</strong>: 认为数据冲突总是会发生。在整个数据处理过程中，将数据锁定，阻止其他线程访问。数据库的行锁、表锁（如 <code>SELECT ... FOR UPDATE</code>）都属于悲观锁。<strong>优点</strong>是数据安全，<strong>缺点</strong>是并发性能差。</li>
<li><strong>乐观锁 (Optimistic Locking)</strong>: 认为数据冲突是小概率事件。在数据处理过程中不加锁，而是在<strong>提交更新时检查数据是否被其他线程修改过</strong>。如果没有，则更新成功；如果已被修改，则更新失败，由调用方决定如何处理（如重试或提示用户）。</li>
</ol>
<p>MyBatis-Plus 提供的 <code>OptimisticLockerInnerInterceptor</code> 就是一个优雅的乐观锁实现方案。</p>
<hr>
<h4 id="5-2-1-乐观锁的实现原理"><a href="#5-2-1-乐观锁的实现原理" class="headerlink" title="5.2.1 乐观锁的实现原理"></a>5.2.1 乐观锁的实现原理</h4><p>MP 的乐观锁插件基于 <strong>版本号 (version)</strong> 机制：</p>
<ol>
<li><p>在数据库表中增加一个整型字段，通常命名为 <code>version</code>，用于记录数据的版本号。</p>
</li>
<li><p><strong>读取数据</strong>：当查询数据时，将 <code>version</code> 字段的值一并读出。</p>
</li>
<li><p><strong>更新数据</strong>：当执行更新操作时，将<strong>当前持有的 <code>version</code> 值作为 <code>WHERE</code> 条件的一部分</strong>。同时，在 <code>SET</code> 子句中将 <code>version</code> 值<strong>加一</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设读取出的 version 是 1</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;New Name&#x27;</span>, version <span class="operator">=</span> <span class="number">2</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> version <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果判断</strong>：</p>
<ul>
<li>如果 <code>WHERE</code> 条件匹配（<code>id=1</code> 且 <code>version=1</code>），说明在你读取数据到提交更新的这段时间内，数据没有被其他线程修改过。更新成功，受影响行数为 1。</li>
<li>如果 <code>WHERE</code> 条件不匹配（受影响行数为 0），说明在你准备更新时，已经有其他线程修改了这条数据，使其 <code>version</code> 值不再是 1。更新失败，表示发生了并发冲突。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-2-2-如何在-MyBatis-Plus-中使用"><a href="#5-2-2-如何在-MyBatis-Plus-中使用" class="headerlink" title="5.2.2 如何在 MyBatis-Plus 中使用"></a>5.2.2 如何在 MyBatis-Plus 中使用</h4><p>使用乐观锁插件非常简单，只需三步：</p>
<p><strong>第 1 步：修改数据库表结构</strong></p>
<p>在需要进行乐观锁控制的表中，添加一个 <code>version</code> 字段（字段名可自定义）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> `<span class="keyword">user</span>` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> `version` <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;版本号&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：初始值建议设为 <code>1</code> 或 <code>0</code>。</p>
<p><strong>第 2 步：修改实体类</strong></p>
<p>在对应的实体类中，添加 <code>version</code> 属性，并使用 <code>@Version</code> 注解标记它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User.java</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.Version;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Version</span> <span class="comment">// 标记这是一个乐观锁版本号字段</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 3 步：配置乐观锁插件</strong></p>
<p>和分页插件一样，将 <code>OptimisticLockerInnerInterceptor</code> 添加到 <code>MybatisPlusInterceptor</code> 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/config/MybatisPlusConfig.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加乐观锁插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加分页插件 (注意插件的添加顺序)</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL)); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：插件的添加顺序可能会影响其行为，通常建议将功能性插件（如乐观锁）放在分页等流程性插件之前。</p>
<hr>
<h4 id="5-2-3-使用示例"><a href="#5-2-3-使用示例" class="headerlink" title="5.2.3 使用示例"></a>5.2.3 使用示例</h4><p>配置完成后，乐观锁插件会自动对<strong>包含 <code>@Version</code> 字段</strong>的实体的<strong>更新操作</strong>生效。你无需在业务代码中做任何特殊处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testOptimisticLocker</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 小王查询商品信息，此时 version=1</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">p1</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小王查询到的版本号: &quot;</span> + p1.getVersion());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 小李也查询该商品信息，此时 version=1</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">p2</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李查询到的版本号: &quot;</span> + p2.getVersion());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 小王将商品价格修改为 90 元，并提交更新</span></span><br><span class="line">    p1.setPrice(<span class="number">90</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> productMapper.updateById(p1);</span><br><span class="line">    System.out.println(<span class="string">&quot;小王更新结果: &quot;</span> + (result1 &gt; <span class="number">0</span> ? <span class="string">&quot;成功&quot;</span> : <span class="string">&quot;失败&quot;</span>));</span><br><span class="line">    <span class="comment">// 此时数据库中 version 变为 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 小李将商品价格修改为 110 元，并提交更新</span></span><br><span class="line">    p2.setPrice(<span class="number">110</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> productMapper.updateById(p2); <span class="comment">// 提交时携带的 version 仍然是 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;小李更新结果: &quot;</span> + (result2 &gt; <span class="number">0</span> ? <span class="string">&quot;成功&quot;</span> : <span class="string">&quot;失败&quot;</span>));</span><br><span class="line">    <span class="comment">// 由于数据库 version 已经是 2，而小李的更新条件是 version=1，所以更新失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 查看最终的商品信息</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">finalProduct</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;最终商品价格: &quot;</span> + finalProduct.getPrice()); <span class="comment">// 应该是 90</span></span><br><span class="line">    System.out.println(<span class="string">&quot;最终版本号: &quot;</span> + finalProduct.getVersion());   <span class="comment">// 应该是 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插件在背后做了什么？</strong></p>
<p>当执行 <code>productMapper.updateById(p2)</code> 时，插件会自动将 SQL 改写为：<code>UPDATE product SET price=110, version=2 WHERE id=1 AND version=1</code></p>
<p>由于数据库中的 <code>version</code> 已经是 2，这个 <code>UPDATE</code> 语句的 <code>WHERE</code> 条件不成立，执行后影响行数为 0，因此 <code>updateById</code> 方法返回 0，表示更新失败。</p>
<hr>
<h4 id="5-2-4-适用场景与注意事项"><a href="#5-2-4-适用场景与注意事项" class="headerlink" title="5.2.4 适用场景与注意事项"></a>5.2.4 适用场景与注意事项</h4><ul>
<li><strong>适用场景</strong>：适用于**“读多写少”**的并发场景。如果写操作非常频繁，冲突会经常发生，导致大量更新失败和重试，反而降低了系统性能。在这种情况下，悲观锁可能更合适。</li>
<li><strong>仅支持特定方法</strong>：乐观锁插件仅对 <code>updateById(T)</code> 和 <code>update(T, Wrapper)</code> 方法生效。对于自定义的 XML 更新语句，插件不会生效，你需要手动在 SQL 中实现版本号的判断和递增。</li>
<li><strong>失败处理</strong>：当更新失败时（返回值为 0 或 false），业务代码需要进行处理，例如：抛出异常提示用户“操作失败，请刷新重试”，或者加入循环进行一定次数的重试。</li>
<li><strong>CAS 思想</strong>：乐观锁的本质是 CAS (Compare-and-Swap) 思想，即“比较并交换”。</li>
</ul>
<hr>
<h2 id="6-代码生成器-AutoGenerator"><a href="#6-代码生成器-AutoGenerator" class="headerlink" title="6. 代码生成器 (AutoGenerator)"></a>6. 代码生成器 (AutoGenerator)</h2><p>在项目开发初期，搭建项目骨架和创建各个分层的基础类（如 Entity, Mapper, Service, Controller）是一项重复性高、技术含量低但又非常耗时的工作。MyBatis-Plus 的代码生成器 (<code>AutoGenerator</code>) 就是为了解决这一痛点而生的，它可以根据数据库表结构，<strong>一键生成</strong>项目所需的基础代码，极大地提升开发效率。</p>
<h3 id="6-1-核心功能与优势"><a href="#6-1-核心功能与优势" class="headerlink" title="6.1 核心功能与优势"></a>6.1 核心功能与优势</h3><ul>
<li><strong>全方位代码生成</strong>: 可以自动生成从数据层到表现层的全套代码，包括：<ul>
<li><strong>Entity</strong> (实体类)</li>
<li><strong>Mapper</strong> (接口)</li>
<li><strong>Mapper.xml</strong> (XML映射文件)</li>
<li><strong>Service</strong> (业务接口)</li>
<li><strong>ServiceImpl</strong> (业务实现类)</li>
<li><strong>Controller</strong> (控制器)</li>
</ul>
</li>
<li><strong>高度可配置</strong>: 提供了丰富的配置选项，允许你自定义生成的代码，包括：<ul>
<li>作者、输出目录、文件覆盖策略。</li>
<li>要生成的表、要排除的表、表&#x2F;字段前缀。</li>
<li>实体类的命名策略（驼峰）、Lombok 支持、主键策略。</li>
<li>自定义模板引擎（默认 Velocity，可选 FreeMarker）。</li>
</ul>
</li>
<li><strong>解放生产力</strong>: 将开发者从繁琐的“CV大法”中解放出来，使其能够更专注于业务逻辑的实现，尤其是在微服务架构或新项目启动阶段，效果显著。</li>
</ul>
<hr>
<h3 id="6-2-如何使用"><a href="#6-2-如何使用" class="headerlink" title="6.2 如何使用"></a>6.2 如何使用</h3><p>使用代码生成器通常需要以下步骤：</p>
<ol>
<li><p><strong>添加依赖</strong>: 在项目中添加代码生成器引擎的依赖。MyBatis-Plus 默认使用 Velocity 模板引擎。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注意：此依赖仅在开发阶段使用，可以放在 &lt;scope&gt;test&lt;/scope&gt; 或不打包到生产环境 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 版本最好与 mybatis-plus-boot-starter 一致 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果使用 Freemarker 引擎 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">    &lt;groupId&gt;org.freemarker&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">    &lt;artifactId&gt;freemarker&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">    &lt;version&gt;2.3.31&lt;/version&gt;</span></span><br><span class="line"><span class="comment">&lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编写生成器主类</strong>: 创建一个独立的 Java main 方法来运行代码生成器。这通常放在 <code>src/test/java</code> 目录下，因为它不属于项目的业务代码。</p>
</li>
<li><p><strong>进行配置</strong>: 代码生成器的配置主要分为几个部分：</p>
<ul>
<li><strong>全局配置 (<code>GlobalConfig</code>)</strong>: 设置作者、输出路径、是否覆盖文件等。</li>
<li><strong>数据源配置 (<code>DataSourceConfig</code>)</strong>: 配置数据库连接信息。</li>
<li><strong>包配置 (<code>PackageConfig</code>)</strong>: 设置各层代码生成的包名。</li>
<li><strong>策略配置 (<code>StrategyConfig</code>)</strong>: <strong>核心配置</strong>，用于设置表映射、命名策略、要生成的表、Lombok 支持等。</li>
<li><strong>模板配置 (<code>TemplateConfig</code>)</strong>: （可选）自定义要生成的模板文件路径。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="6-3-示例代码"><a href="#6-3-示例代码" class="headerlink" title="6.3 示例代码"></a>6.3 示例代码</h3><p>以下是一个完整且带有详细注释的代码生成器示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/test/java/com/example/CodeGenerator.java</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.FastAutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.OutputFile;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine; <span class="comment">// 如果使用Freemarker</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 数据库连接信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dbUrl</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/your_database?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dbUsername</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dbPassword</span> <span class="operator">=</span> <span class="string">&quot;your_password&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取项目路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">projectPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line"></span><br><span class="line">        FastAutoGenerator.create(dbUrl, dbUsername, dbPassword)</span><br><span class="line">            <span class="comment">// 1. 全局配置</span></span><br><span class="line">            .globalConfig(builder -&gt; &#123;</span><br><span class="line">                builder.author(<span class="string">&quot;YourName&quot;</span>) <span class="comment">// 设置作者</span></span><br><span class="line">                       .outputDir(projectPath + <span class="string">&quot;/src/main/java&quot;</span>) <span class="comment">// 指定输出目录</span></span><br><span class="line">                       .commentDate(<span class="string">&quot;yyyy-MM-dd&quot;</span>) <span class="comment">// 注释日期格式</span></span><br><span class="line">                       .disableOpenDir(); <span class="comment">// 禁止生成后打开资源管理器</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 2. 包配置</span></span><br><span class="line">            .packageConfig(builder -&gt; &#123;</span><br><span class="line">                builder.parent(<span class="string">&quot;com.example&quot;</span>) <span class="comment">// 设置父包名</span></span><br><span class="line">                       .moduleName(<span class="string">&quot;system&quot;</span>) <span class="comment">// 设置父包模块名</span></span><br><span class="line">                       .entity(<span class="string">&quot;entity&quot;</span>)</span><br><span class="line">                       .service(<span class="string">&quot;service&quot;</span>)</span><br><span class="line">                       .serviceImpl(<span class="string">&quot;service.impl&quot;</span>)</span><br><span class="line">                       .mapper(<span class="string">&quot;mapper&quot;</span>)</span><br><span class="line">                       .xml(<span class="string">&quot;mapper.xml&quot;</span>)</span><br><span class="line">                       .controller(<span class="string">&quot;controller&quot;</span>)</span><br><span class="line">                       .pathInfo(Collections.singletonMap(OutputFile.xml, projectPath + <span class="string">&quot;/src/main/resources/mapper/system&quot;</span>)); <span class="comment">// 设置 mapperXml 生成路径</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 3. 策略配置</span></span><br><span class="line">            .strategyConfig(builder -&gt; &#123;</span><br><span class="line">                builder.addInclude(<span class="string">&quot;sys_user&quot;</span>, <span class="string">&quot;sys_role&quot;</span>) <span class="comment">// 设置需要生成的表名，可变参数</span></span><br><span class="line">                       .addTablePrefix(<span class="string">&quot;t_&quot;</span>, <span class="string">&quot;sys_&quot;</span>) <span class="comment">// 设置过滤表前缀</span></span><br><span class="line"></span><br><span class="line">                       <span class="comment">// Entity 策略配置</span></span><br><span class="line">                       .entityBuilder()</span><br><span class="line">                       .enableLombok() <span class="comment">// 开启 Lombok</span></span><br><span class="line">                       .enableTableFieldAnnotation() <span class="comment">// 开启生成实体时生成字段注解</span></span><br><span class="line">                       </span><br><span class="line">                       <span class="comment">// Controller 策略配置</span></span><br><span class="line">                       .controllerBuilder()</span><br><span class="line">                       .enableRestStyle() <span class="comment">// 开启生成 @RestController 控制器</span></span><br><span class="line">                       </span><br><span class="line">                       <span class="comment">// Service 策略配置</span></span><br><span class="line">                       .serviceBuilder()</span><br><span class="line">                       .formatServiceFileName(<span class="string">&quot;%sService&quot;</span>) <span class="comment">// Service 文件名格式</span></span><br><span class="line">                       .formatServiceImplFileName(<span class="string">&quot;%sServiceImpl&quot;</span>) <span class="comment">// ServiceImpl 文件名格式</span></span><br><span class="line">                       </span><br><span class="line">                       <span class="comment">// Mapper 策略配置</span></span><br><span class="line">                       .mapperBuilder()</span><br><span class="line">                       .enableBaseResultMap() <span class="comment">// 启用 BaseResultMap 生成</span></span><br><span class="line">                       .enableBaseColumnList(); <span class="comment">// 启用 BaseColumnList</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 4. 模板引擎配置 (可选，MP 默认使用 Velocity)</span></span><br><span class="line">            <span class="comment">// .templateEngine(new FreemarkerTemplateEngine()) </span></span><br><span class="line">            </span><br><span class="line">            .execute(); <span class="comment">// 执行生成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-4-核心配置项详解-strategyConfig"><a href="#6-4-核心配置项详解-strategyConfig" class="headerlink" title="6.4 核心配置项详解 (strategyConfig)"></a>6.4 核心配置项详解 (<code>strategyConfig</code>)</h3><ul>
<li><strong><code>addInclude(&quot;table1&quot;, &quot;table2&quot;)</code></strong>: 指定要为哪些表生成代码。如果不设置，则默认生成所有表。</li>
<li><strong><code>addExclude(&quot;table_to_ignore&quot;)</code></strong>: 指定不为哪些表生成代码。</li>
<li><strong><code>addTablePrefix(&quot;t_&quot;, &quot;c_&quot;)</code></strong>: 在生成实体类名时，会自动移除这些表名前缀。例如，表名 <code>t_user</code> 会生成实体类 <code>User</code>。</li>
<li><strong><code>entityBuilder()</code></strong>: 进入实体类配置。<ul>
<li><strong><code>.enableLombok()</code></strong>: 自动为实体类添加 <code>@Data</code> 等 Lombok 注解。</li>
<li><strong><code>.logicDeleteColumnName(&quot;deleted&quot;)</code></strong>: 指定逻辑删除字段名。</li>
<li><strong><code>.versionColumnName(&quot;version&quot;)</code></strong>: 指定乐观锁版本号字段名。</li>
</ul>
</li>
<li><strong><code>controllerBuilder()</code></strong>: 进入 Controller 配置。<ul>
<li><strong><code>.enableRestStyle()</code></strong>: 生成的 Controller 会自带 <code>@RestController</code> 注解。</li>
</ul>
</li>
<li><strong><code>mapperBuilder()</code></strong>: 进入 Mapper 配置。<ul>
<li><strong><code>.enableBaseResultMap()</code></strong>: 会在生成的 Mapper.xml 文件中自动创建 <code>&lt;resultMap&gt;</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-5-最佳实践"><a href="#6-5-最佳实践" class="headerlink" title="6.5 最佳实践"></a>6.5 最佳实践</h3><ol>
<li><strong>独立模块或测试目录</strong>: 将代码生成器的代码放在项目的 <code>src/test/java</code> 目录下，或者创建一个专门的 <code>generator</code> 模块，避免将其打包到生产环境中。</li>
<li><strong>按需生成</strong>: 在 <code>addInclude</code> 中明确指定需要生成的表，而不是生成所有表，避免产生不必要的代码。</li>
<li><strong>覆盖策略</strong>: 默认情况下，如果文件已存在，生成器不会覆盖。如果需要重新生成，可以在 <code>globalConfig</code> 中配置 <code>.fileOverride()</code>。但请注意，这会覆盖你手动修改过的代码，务必谨慎使用。</li>
<li><strong>多次使用</strong>: 在项目迭代过程中，如果新增了表，只需修改 <code>addInclude</code> 中的表名，然后重新运行生成器即可，非常方便。</li>
</ol>
<hr>
<h2 id="7-高级特性"><a href="#7-高级特性" class="headerlink" title="7. 高级特性"></a>7. 高级特性</h2><h3 id="7-1-逻辑删除"><a href="#7-1-逻辑删除" class="headerlink" title="7.1 逻辑删除"></a>7.1 逻辑删除</h3><h4 id="7-1-1-什么是逻辑删除？"><a href="#7-1-1-什么是逻辑删除？" class="headerlink" title="7.1.1 什么是逻辑删除？"></a>7.1.1 什么是逻辑删除？</h4><p>在业务系统中，删除操作通常分为两种：</p>
<ol>
<li><strong>物理删除 (Physical Delete)</strong>: 直接从数据库中执行 <code>DELETE</code> 语句，将数据行<strong>永久抹除</strong>。这种操作是不可逆的。</li>
<li><strong>逻辑删除 (Logical Delete &#x2F; Soft Delete)</strong>: 并<strong>不真正删除</strong>数据，而是通过一个特定的字段（例如 <code>is_deleted</code>, <code>status</code> 等）来<strong>标记</strong>这条数据的状态为“已删除”。对于应用程序来说，这条数据就如同被删除了一样，在正常的查询中不会再出现。</li>
</ol>
<p>MyBatis-Plus 提供的逻辑删除功能，就是对<strong>逻辑删除</strong>操作的完美封装和自动化。</p>
<hr>
<h4 id="7-1-2-为什么使用逻辑删除？"><a href="#7-1-2-为什么使用逻辑删除？" class="headerlink" title="7.1.2 为什么使用逻辑删除？"></a>7.1.2 为什么使用逻辑删除？</h4><p>使用逻辑删除主要有以下几个核心优势：</p>
<ul>
<li><strong>数据可恢复</strong>: 这是最大的优点。如果发生误删除操作，只需将标记字段的状态改回去，数据就能立刻恢复，避免了从数据库备份中恢复数据的复杂过程。</li>
<li><strong>保留数据完整性</strong>: 在复杂的关联关系中，物理删除一条主记录可能会导致关联的子记录成为“孤儿数据”，或者因为外键约束而删除失败。逻辑删除则可以保留这些关联关系。</li>
<li><strong>便于审计与追溯</strong>: 所有的数据操作历史都被保留在数据库中，便于日后进行数据审计、问题排查和行为分析。</li>
<li><strong>操作安全</strong>: 避免了因 <code>DELETE</code> 语句 <code>WHERE</code> 条件错误而导致灾难性数据丢失的风险。</li>
</ul>
<hr>
<h4 id="7-1-3-MyBatis-Plus-中的实现原理"><a href="#7-1-3-MyBatis-Plus-中的实现原理" class="headerlink" title="7.1.3 MyBatis-Plus 中的实现原理"></a>7.1.3 MyBatis-Plus 中的实现原理</h4><p>MyBatis-Plus 的逻辑删除功能是通过其<strong>拦截器机制</strong>实现的，对开发者完全透明：</p>
<ol>
<li><strong>改写 <code>DELETE</code></strong>: 当你调用 <code>deleteById()</code> 或 <code>removeById()</code> 等删除方法时，MP 拦截器会捕获这个操作，并自动将其<strong>改写</strong>为一个 <code>UPDATE</code> 语句。<ul>
<li><strong>原始意图</strong>: <code>DELETE FROM user WHERE id = ?</code></li>
<li><strong>MP 实际执行</strong>: <code>UPDATE user SET deleted = 1 WHERE id = ? AND deleted = 0</code></li>
</ul>
</li>
<li><strong>过滤 <code>SELECT</code></strong>: 当你调用 <code>selectList()</code>, <code>selectById()</code>, <code>selectPage()</code> 等所有查询方法时，MP 拦截器会自动在 <code>WHERE</code> 子句的末尾<strong>追加</strong>逻辑删除字段的过滤条件。<ul>
<li><strong>原始意图</strong>: <code>SELECT * FROM user WHERE name = &#39;Tom&#39;</code></li>
<li><strong>MP 实际执行</strong>: <code>SELECT * FROM user WHERE name = &#39;Tom&#39; AND deleted = 0</code></li>
</ul>
</li>
<li><strong>过滤 <code>UPDATE</code></strong>: 同样，在执行更新操作时，也会自动追加过滤条件，以确保你不会更新到一条已经被“删除”的数据。</li>
</ol>
<hr>
<h4 id="7-1-4-如何配置和使用"><a href="#7-1-4-如何配置和使用" class="headerlink" title="7.1.4 如何配置和使用"></a>7.1.4 如何配置和使用</h4><p>在 MP 中启用逻辑删除非常简单，只需两到三步：</p>
<p><strong>第 1 步：数据库表</strong></p>
<p>在需要逻辑删除的表中，增加一个用于标记状态的字段，例如 <code>deleted</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> `<span class="keyword">user</span>` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> `deleted` TINYINT(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;逻辑删除标记 0-未删除 1-已删除&#x27;</span>;</span><br><span class="line"><span class="comment">-- 建议为该字段添加索引，以提高查询性能</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_deleted <span class="keyword">ON</span> <span class="keyword">user</span>(deleted);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 必须为该字段设置一个默认值（通常是 <code>0</code> 表示未删除）。</p>
<p><strong>第 2 步：实体类</strong></p>
<p>在对应的实体类中，添加该字段，并使用 <code>@TableLogic</code> 注解标记。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User.java</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableLogic;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他字段</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TableLogic</span> <span class="comment">// 标记为逻辑删除字段</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 3 步：全局配置 (可选，但强烈推荐)</strong></p>
<p>虽然 <code>@TableLogic</code> 注解可以指定删除和未删除的值，但在 <code>application.yml</code> 或 <code>properties</code> 中进行全局配置是更好的实践，可以统一管理。</p>
<p><strong><code>application.yml</code> 示例:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment"># 逻辑删除字段名 (全局)</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">deleted</span> </span><br><span class="line">      <span class="comment"># 逻辑删除值 (默认为 1)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span></span><br><span class="line">      <span class="comment"># 逻辑未删除值 (默认为 0)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>全局配置 vs 注解</strong>: 如果同时进行了全局配置和 <code>@TableLogic</code> 注解配置，<strong>注解的优先级更高</strong>。</li>
</ul>
<hr>
<h4 id="7-1-5-实际效果"><a href="#7-1-5-实际效果" class="headerlink" title="7.1.5 实际效果"></a>7.1.5 实际效果</h4><p>配置完成后，所有操作都会被 MP 自动处理：</p>
<ul>
<li><p><strong>执行删除</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userMapper.deleteById(<span class="number">1L</span>);</span><br></pre></td></tr></table></figure>

<p><strong>实际执行的 SQL</strong>: <code>UPDATE user SET deleted=1 WHERE id=1 AND deleted=0</code></p>
</li>
<li><p><strong>执行查询</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有用户</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><strong>实际执行的 SQL</strong>: <code>SELECT id,name,age,email,deleted FROM user WHERE deleted=0</code></p>
</li>
<li><p><strong>执行更新</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">1L</span>);</span><br><span class="line">user.setAge(<span class="number">30</span>);</span><br><span class="line">userMapper.updateById(user);</span><br></pre></td></tr></table></figure>

<p><strong>实际执行的 SQL</strong>: <code>UPDATE user SET age=30 WHERE id=1 AND deleted=0</code></p>
</li>
</ul>
<hr>
<h4 id="7-1-6-如何查询被逻辑删除的数据？"><a href="#7-1-6-如何查询被逻辑删除的数据？" class="headerlink" title="7.1.6 如何查询被逻辑删除的数据？"></a>7.1.6 如何查询被逻辑删除的数据？</h4><p>一个常见的需求是，管理员需要一个“回收站”功能来查看并恢复被删除的数据。由于 MP 的查询会自动过滤掉已删除数据，你需要<strong>手写 SQL</strong> 来绕过这个机制。</p>
<p>在 <code>UserMapper</code> 接口中定义一个自定义方法，并在对应的 XML 文件中编写 SQL：</p>
<p><strong><code>UserMapper.java</code></strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectDeletedUsers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>UserMapper.xml</code></strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDeletedUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.entity.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE deleted = 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过这种方式，你可以精确控制何时需要忽略逻辑删除的过滤规则。</p>
<hr>
<h3 id="7-2-自动填充-MetaObjectHandler"><a href="#7-2-自动填充-MetaObjectHandler" class="headerlink" title="7.2 自动填充 (MetaObjectHandler)"></a>7.2 自动填充 (MetaObjectHandler)</h3><p>在大多数业务系统中，许多数据表都包含一些公共字段，如 <code>create_time</code>（创建时间）、<code>update_time</code>（更新时间）、<code>create_by</code>（创建人）、<code>update_by</code>（更新人）等。这些字段的值通常具有固定的填充规则，例如在插入数据时自动设置创建时间和更新时间，在更新数据时自动设置更新时间。</p>
<p>如果在每个 Service 的 <code>save</code> 和 <code>update</code> 方法中都手动设置这些值，不仅会导致大量重复代码，还容易遗漏。</p>
<p>MyBatis-Plus 的<strong>自动填充</strong>功能 (<code>MetaObjectHandler</code>) 就是为了优雅地解决这个问题而设计的。</p>
<hr>
<h4 id="7-2-1-核心思想与原理"><a href="#7-2-1-核心思想与原理" class="headerlink" title="7.2.1 核心思想与原理"></a>7.2.1 核心思想与原理</h4><p><code>MetaObjectHandler</code> 是一个公共字段填充处理器。它的核心思想是利用 AOP（面向切面编程）的理念，在 MP 执行<strong>插入 (<code>insert</code>)</strong> 和 <strong>更新 (<code>update</code>)</strong> 操作时，通过拦截器机制自动对指定字段进行填充。</p>
<p>开发者只需定义一个实现了 <code>MetaObjectHandler</code> 接口的 Bean，并实现其中的 <code>insertFill</code> 和 <code>updateFill</code> 方法，MP 就会在相应的 SQL 执行前调用这些方法，完成对实体对象（<code>metaObject</code>）属性的赋值。</p>
<hr>
<h4 id="7-2-2-如何使用"><a href="#7-2-2-如何使用" class="headerlink" title="7.2.2 如何使用"></a>7.2.2 如何使用</h4><p>实现自动填充功能主要需要三步：</p>
<p><strong>第 1 步：在实体类中标记需要填充的字段</strong></p>
<p>在实体类的属性上，使用 <code>@TableField</code> 注解并指定 <code>fill</code> 策略。</p>
<ul>
<li><code>FieldFill.INSERT</code>: 只在<strong>插入</strong>时填充。</li>
<li><code>FieldFill.UPDATE</code>: 只在<strong>更新</strong>时填充。</li>
<li><code>FieldFill.INSERT_UPDATE</code>: 在<strong>插入和更新</strong>时都填充。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User.java</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span> <span class="comment">// 插入时填充</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span> <span class="comment">// 插入和更新时都填充</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> String createBy;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> String updateBy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 2 步：创建 <code>MetaObjectHandler</code> 实现类</strong></p>
<p>创建一个类，实现 <code>MetaObjectHandler</code> 接口，并重写 <code>insertFill</code> 和 <code>updateFill</code> 方法。在这个类中定义具体的字段填充逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/handler/MyMetaObjectHandler.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.MetaObject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// **重要**：必须将处理器注入到 Spring 容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入操作时的填充策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject 元数据对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start insert fill ....&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 参1: 实体类的属性名, 不是数据库的字段名</span></span><br><span class="line">        <span class="comment">// 参2: 要填充的值</span></span><br><span class="line">        <span class="comment">// 参3: 元数据对象</span></span><br><span class="line">        <span class="built_in">this</span>.strictInsertFill(metaObject, <span class="string">&quot;createTime&quot;</span>, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">        <span class="built_in">this</span>.strictInsertFill(metaObject, <span class="string">&quot;updateTime&quot;</span>, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 示例：填充创建人（需要从当前会话或安全上下文中获取）</span></span><br><span class="line">        <span class="comment">// String currentUsername = getCurrentUsername(); // 假设有方法可以获取当前用户名</span></span><br><span class="line">        <span class="comment">// this.strictInsertFill(metaObject, &quot;createBy&quot;, String.class, currentUsername);</span></span><br><span class="line">        <span class="comment">// this.strictInsertFill(metaObject, &quot;updateBy&quot;, String.class, currentUsername);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新操作时的填充策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject 元数据对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start update fill ....&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.strictUpdateFill(metaObject, <span class="string">&quot;updateTime&quot;</span>, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// String currentUsername = getCurrentUsername();</span></span><br><span class="line">        <span class="comment">// this.strictUpdateFill(metaObject, &quot;updateBy&quot;, String.class, currentUsername);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>strict...Fill</code> vs <code>setFieldValByName</code></strong>:</p>
<ul>
<li><code>setFieldValByName(fieldName, fieldVal, metaObject)</code>: 无论属性值是否已存在，都会强制覆盖。</li>
<li><code>strictInsertFill(metaObject, fieldName, fieldType, fieldVal)</code>: 更严谨的版本。它会先判断实体中该属性是否已有值，<strong>只有在值为 <code>null</code> 时才进行填充</strong>。这允许你在业务代码中手动设置一个特定的创建时间，而不会被自动填充覆盖。<code>strictUpdateFill</code> 同理。<strong>官方推荐使用 <code>strict</code> 版本。</strong></li>
</ul>
<p><strong>第 3 步：将 Handler 注册为 Spring Bean</strong></p>
<p>只需在 <code>MyMetaObjectHandler</code> 类上添加 <code>@Component</code> 或 <code>@Configuration</code> 注解，确保它被 Spring IoC 容器管理即可。MyBatis-Plus 的 starter 会自动检测并装配它。</p>
<hr>
<h4 id="7-2-3-实际效果"><a href="#7-2-3-实际效果" class="headerlink" title="7.2.3 实际效果"></a>7.2.3 实际效果</h4><p>配置完成后，当你执行插入或更新操作时，不再需要手动设置这些公共字段。</p>
<p><strong>插入操作</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setName(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">userService.save(user); <span class="comment">// 或者 userMapper.insert(user)</span></span><br></pre></td></tr></table></figure>

<p><strong>实际执行的 SQL 会包含自动填充的字段</strong>:</p>
<p><code>INSERT INTO user ( name, create_time, update_time ) VALUES ( &#39;Jack&#39;, &#39;2023-10-27 10:00:00&#39;, &#39;2023-10-27 10:00:00&#39; )</code></p>
<p><strong>更新操作</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(<span class="number">1L</span>);</span><br><span class="line">user.setName(<span class="string">&quot;Jack-updated&quot;</span>);</span><br><span class="line">userService.updateById(user);</span><br></pre></td></tr></table></figure>

<p><strong>实际执行的 SQL 会自动更新 <code>update_time</code> 字段</strong>:</p>
<p><code>UPDATE user SET name=&#39;Jack-updated&#39;, update_time=&#39;2023-10-27 10:05:00&#39; WHERE id=1</code></p>
<hr>
<h4 id="7-2-4-获取当前操作人"><a href="#7-2-4-获取当前操作人" class="headerlink" title="7.2.4 获取当前操作人"></a>7.2.4 获取当前操作人</h4><p>在 <code>MetaObjectHandler</code> 中填充 <code>createBy</code> 和 <code>updateBy</code> 字段是一个常见的需求。这通常需要从当前的用户会话中获取登录信息。一种常见的实现方式是：</p>
<ol>
<li>使用 <strong>Spring Security</strong> 或其他安全框架，用户信息保存在 <code>SecurityContextHolder</code> 中。</li>
<li>使用 <strong><code>ThreadLocal</code></strong>。在请求进入 Controller 或经过某个 Filter&#x2F;Interceptor 时，将当前用户信息存入 <code>ThreadLocal</code>，在 <code>MetaObjectHandler</code> 中从中读取，请求结束后再清除。</li>
</ol>
<hr>
<h3 id="7-3-主键策略"><a href="#7-3-主键策略" class="headerlink" title="7.3 主键策略"></a>7.3 主键策略</h3><h4 id="7-3-1-简介"><a href="#7-3-1-简介" class="headerlink" title="7.3.1 简介"></a>7.3.1 简介</h4><p>主键 (Primary Key, PK) 是数据库中每条记录的唯一标识。如何生成和管理主键，在不同的系统架构下有不同的最佳实践。在单体应用中，数据库的自增 ID (Auto Increment) 简单高效；但在分布式、微服务架构下，依赖单个数据库的自增 ID 会带来扩展性问题和主键冲突的风险。</p>
<p>MyBatis-Plus (MP) 深刻理解这一挑战，内置了多种主键生成策略，并通过简单的配置即可应用，使得主键管理变得异常轻松。</p>
<hr>
<h4 id="7-3-2-配置方式"><a href="#7-3-2-配置方式" class="headerlink" title="7.3.2 配置方式"></a>7.3.2 配置方式</h4><p>MP 主要通过在实体类的主键字段上使用 <code>@TableId</code> 注解来配置主键策略。其核心属性是 <code>type</code>，它接收一个 <code>IdType</code> 枚举值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@TableId</span> 注解用于标识主键字段</span></span><br><span class="line"><span class="comment">     * type 属性用于指定主键生成策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableId(type = IdType.ASSIGN_ID)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... other fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7-3-3-核心主键策略详解"><a href="#7-3-3-核心主键策略详解" class="headerlink" title="7.3.3 核心主键策略详解"></a>7.3.3 核心主键策略详解</h4><p><code>IdType</code> 枚举定义了以下几种常用的主键策略：</p>
<h5 id="1-IdType-AUTO-数据库ID自增"><a href="#1-IdType-AUTO-数据库ID自增" class="headerlink" title="1. IdType.AUTO (数据库ID自增)"></a>1. <code>IdType.AUTO</code> (数据库ID自增)</h5><ul>
<li><strong>描述</strong>: 依赖数据库自身的 ID 自增机制来生成主键。例如 MySQL 的 <code>AUTO_INCREMENT</code>。</li>
<li><strong>如何工作</strong>: 当插入数据时，MP 不会为主键赋值，而是由数据库生成后，再通过 JDBC 将生成的主键值回填到实体对象中。</li>
<li><strong>适用场景</strong>: 单体应用、数据量不大、没有分库分表需求的简单项目。这是最传统、最简单的方式。</li>
<li><strong>配置</strong>: <code>@TableId(type = IdType.AUTO)</code></li>
</ul>
<h5 id="2-IdType-ASSIGN-ID-雪花算法-默认-推荐"><a href="#2-IdType-ASSIGN-ID-雪花算法-默认-推荐" class="headerlink" title="2. IdType.ASSIGN_ID (雪花算法, 默认&#x2F;推荐)"></a>2. <code>IdType.ASSIGN_ID</code> (雪花算法, 默认&#x2F;推荐)</h5><ul>
<li><strong>描述</strong>: MP 默认的主键策略。它使用<strong>雪花算法 (Snowflake)</strong> 在应用程序层面生成一个全局唯一的、趋势递增的 64 位长整型 ID。</li>
<li><strong>雪花算法简介</strong>: 该算法生成的 ID 由 <code>时间戳 + 数据中心ID + 机器ID + 序列号</code> 组合而成，保证了在分布式系统中的全局唯一性和高性能。</li>
<li><strong>优点</strong>:<ul>
<li><strong>全局唯一</strong>: 在分布式环境下，不同机器生成的 ID 不会冲突。</li>
<li><strong>高性能</strong>: ID 在本地生成，不依赖数据库，性能极高。</li>
<li><strong>趋势递增</strong>: ID 整体上随时间增长，有利于数据库索引的性能。</li>
<li><strong>数值类型</strong>: 作为数值型主键，查询效率高于字符串类型。</li>
</ul>
</li>
<li><strong>适用场景</strong>: <strong>微服务、分布式系统、高并发应用</strong>。这是 MP 在分布式场景下的<strong>首选推荐</strong>策略。</li>
<li><strong>配置</strong>: <code>@TableId(type = IdType.ASSIGN_ID)</code> 或不写 <code>type</code> 属性（因为它是默认值）。</li>
</ul>
<h5 id="3-IdType-ASSIGN-UUID-UUID"><a href="#3-IdType-ASSIGN-UUID-UUID" class="headerlink" title="3. IdType.ASSIGN_UUID (UUID)"></a>3. <code>IdType.ASSIGN_UUID</code> (UUID)</h5><ul>
<li><strong>描述</strong>: 使用 UUID (Universally Unique Identifier) 算法生成一个全局唯一的字符串 ID。</li>
<li><strong>如何工作</strong>: 生成一个类似 <code>550e8400-e29b-41d4-a716-446655440000</code> 的 32 位十六进制字符串作为主键。</li>
<li><strong>优点</strong>:<ul>
<li><strong>全局唯一</strong>: 绝对的全局唯一，不依赖任何中心节点。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>字符串类型</strong>: 占用存储空间大，查询性能低于数值型主键。</li>
<li><strong>无序性</strong>: UUID 是无序的，作为主键会导致数据库索引频繁重建，插入性能下降。</li>
<li><strong>可读性差</strong>。</li>
</ul>
</li>
<li><strong>适用场景</strong>: 当主键需要对外暴露，且不希望其具有规律性（如订单号、支付流水号的场景，但通常这些是业务ID而非主键），或者对主键的唯一性要求极高而不在乎性能时。</li>
<li><strong>配置</strong>: <code>@TableId(type = IdType.ASSIGN_UUID)</code></li>
</ul>
<h5 id="4-IdType-INPUT-用户输入"><a href="#4-IdType-INPUT-用户输入" class="headerlink" title="4. IdType.INPUT (用户输入)"></a>4. <code>IdType.INPUT</code> (用户输入)</h5><ul>
<li><strong>描述</strong>: 表示主键由用户或业务代码<strong>手动设置</strong>。MP 不会为其生成任何值。</li>
<li><strong>如何工作</strong>: 在执行 <code>insert</code> 操作之前，你必须手动为实体的主键字段赋一个值。</li>
<li><strong>适用场景</strong>: 当主键本身具有业务含义时，例如使用用户的学号、身份证号、或自定义的编码作为主键。</li>
<li><strong>配置</strong>: <code>@TableId(type = IdType.INPUT)</code></li>
</ul>
<h5 id="5-IdType-NONE-无状态"><a href="#5-IdType-NONE-无状态" class="headerlink" title="5. IdType.NONE (无状态)"></a>5. <code>IdType.NONE</code> (无状态)</h5><ul>
<li><strong>描述</strong>: 表示未设置主键类型，MP 会遵循全局配置。如果全局也未配置，则等同于 <code>INPUT</code>。</li>
</ul>
<h5 id="6-IdType-SEQUENCE-序列"><a href="#6-IdType-SEQUENCE-序列" class="headerlink" title="6. IdType.SEQUENCE (序列)"></a>6. <code>IdType.SEQUENCE</code> (序列)</h5><ul>
<li><strong>描述</strong>: 使用数据库的序列（Sequence）来生成主键。这是 Oracle、PostgreSQL 等数据库推荐的主键生成方式。需要配合 <code>@KeySequence</code> 注解使用。</li>
</ul>
<hr>
<h4 id="7-3-4-全局主键策略配置"><a href="#7-3-4-全局主键策略配置" class="headerlink" title="7.3.4 全局主键策略配置"></a>7.3.4 全局主键策略配置</h4><p>除了在每个实体类上单独配置，你还可以在 <code>application.yml</code> 中配置一个全局的主键生成策略。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment"># 设置全局的主键生成策略为数据库自增</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure>

<p><strong>优先级</strong>: 实体类上的 <code>@TableId</code> 注解配置的优先级 <strong>高于</strong> 全局配置。</p>
<hr>
<h4 id="7-3-5-策略选型总结"><a href="#7-3-5-策略选型总结" class="headerlink" title="7.3.5 策略选型总结"></a>7.3.5 策略选型总结</h4><table>
<thead>
<tr>
<th align="left">策略 (<code>IdType</code>)</th>
<th align="left">描述</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>AUTO</code></td>
<td align="left">数据库自增</td>
<td align="left">简单、连续、易于理解</td>
<td align="left">仅限单数据库，不适用于分布式</td>
<td align="left">单体应用，简单项目</td>
</tr>
<tr>
<td align="left"><strong><code>ASSIGN_ID</code></strong></td>
<td align="left"><strong>雪花算法</strong></td>
<td align="left"><strong>全局唯一、高性能、趋势递增</strong></td>
<td align="left">依赖时间，时钟回拨可能导致问题</td>
<td align="left"><strong>微服务、分布式系统、高并发（强烈推荐）</strong></td>
</tr>
<tr>
<td align="left"><code>ASSIGN_UUID</code></td>
<td align="left">UUID字符串</td>
<td align="left">全局唯一，无中心依赖</td>
<td align="left">字符串性能差、无序、占用空间大</td>
<td align="left">对唯一性要求极高，不关心性能的场景</td>
</tr>
<tr>
<td align="left"><code>INPUT</code></td>
<td align="left">手动输入</td>
<td align="left">灵活，主键可具业务含义</td>
<td align="left">需要手动管理，易出错</td>
<td align="left">主键有明确业务意义（如身份证号）</td>
</tr>
<tr>
<td align="left"><code>SEQUENCE</code></td>
<td align="left">数据库序列</td>
<td align="left">高性能、数据库原生支持</td>
<td align="left">特定数据库（Oracle等）</td>
<td align="left">使用支持序列的数据库时</td>
</tr>
</tbody></table>
<hr>
<hr>
<h1 id="四、JPA-Hibernate"><a href="#四、JPA-Hibernate" class="headerlink" title="四、JPA &amp; Hibernate"></a>四、JPA &amp; Hibernate</h1><h2 id="1-JPA-规范与-Hibernate-实现"><a href="#1-JPA-规范与-Hibernate-实现" class="headerlink" title="1. JPA 规范与 Hibernate 实现"></a>1. JPA 规范与 Hibernate 实现</h2><h3 id="1-1-什么是-JPA-Java-Persistence-API-？"><a href="#1-1-什么是-JPA-Java-Persistence-API-？" class="headerlink" title="1.1 什么是 JPA (Java Persistence API)？"></a>1.1 什么是 JPA (Java Persistence API)？</h3><p><strong>JPA 本质上是一套 Java EE (现为 Jakarta EE) 的技术规范</strong>，由 JSR (Java Specification Request) 定义。它并非一个可以直接使用的框架或工具，而是一系列 <strong>API 接口、注解和查询语言 (JPQL)</strong> 的集合。</p>
<p><strong>JPA 的核心目标是</strong>：为 Java 开发者提供一个<strong>标准化的、与具体 ORM 框架无关</strong>的持久化编程模型。</p>
<p>它主要定义了以下几个方面的内容：</p>
<ol>
<li><strong>ORM 映射元数据 (Mapping Metadata)</strong>:<ul>
<li>通过注解（如 <code>@Entity</code>, <code>@Table</code>, <code>@Id</code>, <code>@Column</code>, <code>@OneToMany</code> 等）或 XML 配置，来定义 Java 对象 (POJO) 与数据库表之间的映射关系。</li>
</ul>
</li>
<li><strong>实体操作 API</strong>:<ul>
<li>定义了一套用于操作实体的标准接口，其中最核心的是 <code>EntityManager</code>。它提供了 <code>persist()</code> (保存), <code>merge()</code> (更新), <code>remove()</code> (删除), <code>find()</code> (查询) 等方法。</li>
</ul>
</li>
<li><strong>查询语言 (JPQL)</strong>:<ul>
<li>定义了一种面向对象的、与具体数据库方言无关的查询语言——Java Persistence Query Language (JPQL)。JPQL 的语法与 SQL 类似，但操作的是<strong>实体对象和属性</strong>，而不是数据库的表和列。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-2-什么是-Hibernate？"><a href="#1-2-什么是-Hibernate？" class="headerlink" title="1.2 什么是 Hibernate？"></a>1.2 什么是 Hibernate？</h3><p><strong>Hibernate 是一个功能强大、开源、成熟的 ORM (对象关系映射) 框架</strong>。它是一个<strong>具体的产品</strong>，负责将开发者定义好的对象模型持久化到数据库中。</p>
<p>Hibernate 诞生于 JPA 之前，凭借其强大的功能和灵活性迅速成为 Java 持久化领域的领导者。正因为 Hibernate 的成功，JPA 规范在制定时大量借鉴了 Hibernate 的设计思想。</p>
<p>Hibernate 不仅完整地实现了 JPA 规范定义的所有功能，还提供了许多<strong>超越 JPA 规范的、自身特有的高级功能</strong>，例如：</p>
<ul>
<li>更丰富的查询方式（如 QBC - Query by Criteria API）。</li>
<li>更强大的二级缓存策略和集成方案。</li>
<li>更细粒度的性能调优选项。</li>
<li>特有的 HQL (Hibernate Query Language)，它是 JPQL 的超集。</li>
</ul>
<hr>
<h3 id="1-3-两者的关系：规范与实现"><a href="#1-3-两者的关系：规范与实现" class="headerlink" title="1.3 两者的关系：规范与实现"></a>1.3 两者的关系：规范与实现</h3><p><strong>JPA 是“标准”，Hibernate 是“实现”</strong>。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">JPA (Java Persistence API)</th>
<th align="left">Hibernate</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>本质</strong></td>
<td align="left">一套<strong>技术规范、接口标准</strong></td>
<td align="left">一个<strong>具体的 ORM 框架、JPA 规范的实现</strong></td>
</tr>
<tr>
<td align="left"><strong>提供内容</strong></td>
<td align="left">API 接口 (<code>EntityManager</code>), 注解 (<code>@Entity</code>), JPQL</td>
<td align="left">JPA 规范所有功能的具体实现，以及额外的增强功能</td>
</tr>
<tr>
<td align="left"><strong>可移植性</strong></td>
<td align="left"><strong>高</strong>。应用程序面向 JPA 编程，理论上可以无缝切换 ORM 实现。</td>
<td align="left"><strong>低</strong>。如果代码中使用了 Hibernate 特有的 API，将无法轻松切换到其他框架。</td>
</tr>
<tr>
<td align="left"><strong>依赖关系</strong></td>
<td align="left">Hibernate 依赖并实现了 JPA 规范。</td>
<td align="left">JPA 是一种标准，不依赖任何具体实现。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-4-为什么我们通常将它们一起提及？"><a href="#1-4-为什么我们通常将它们一起提及？" class="headerlink" title="1.4 为什么我们通常将它们一起提及？"></a>1.4 为什么我们通常将它们一起提及？</h3><ol>
<li><strong>Hibernate 是事实上的标准实现</strong>: 尽管存在其他 JPA 实现，但 Hibernate 是最流行、最强大、社区最活跃的一个，绝大多数使用 JPA 的项目底层都默认选择了 Hibernate。</li>
<li><strong>Spring Data JPA 的推动</strong>: Spring 生态中的 <code>Spring Data JPA</code> 模块极大地简化了 JPA 的使用。它默认的底层实现就是 Hibernate。这使得“Spring Boot + Spring Data JPA + Hibernate”成为现代 Java Web 开发的黄金组合。</li>
</ol>
<p><strong>最佳实践</strong>:</p>
<p>在开发中，我们应该<strong>面向 JPA 规范编程</strong>。这意味着：</p>
<ul>
<li>使用 JPA 定义的注解 (<code>@Entity</code>, <code>@Id</code> 等)。</li>
<li>通过依赖注入获取和使用 JPA 的核心接口 <code>EntityManager</code>。</li>
<li>编写 JPQL 而不是特定于 Hibernate 的 HQL。</li>
</ul>
<hr>
<h2 id="2-核心概念"><a href="#2-核心概念" class="headerlink" title="2. 核心概念"></a>2. 核心概念</h2><h3 id="2-1-实体-Entity"><a href="#2-1-实体-Entity" class="headerlink" title="2.1 实体 (Entity)"></a>2.1 实体 (Entity)</h3><p><strong>实体是 JPA 的核心。</strong> 它是一个普通的 Java 对象 (POJO)，通过注解或 XML 配置，与数据库中的一张表进行了映射。</p>
<ul>
<li><strong>定义</strong>: 一个被 JPA 管理的、持久化的领域对象。</li>
<li><strong>核心要求</strong>:<ol>
<li>必须使用 <code>@Entity</code> 注解进行标记。</li>
<li>必须有一个无参的构造函数 (<code>public</code> 或 <code>protected</code>)。</li>
<li>必须有一个主键，使用 <code>@Id</code> 注解进行标记。</li>
</ol>
</li>
<li><strong>特点</strong>: 实体<strong>不是</strong>一个简单的 DTO (Data Transfer Object)。它是有状态的，其生命周期由持久化上下文（Persistence Context）管理。对托管状态下实体对象的任何修改，都可能被自动同步到数据库。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span> <span class="comment">// 标记这是一个实体类</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_user&quot;)</span> <span class="comment">// 映射到数据库的 t_user 表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="comment">// 标记这是主键</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span> <span class="comment">// 主键生成策略</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_name&quot;, length = 50)</span> <span class="comment">// 映射到 user_name 列</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age; <span class="comment">// 如果属性名和列名相同，可以省略 @Column</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123; <span class="comment">// 必须有无参构造</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... Getters and Setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-EntityManagerFactory-实体管理器工厂"><a href="#2-2-EntityManagerFactory-实体管理器工厂" class="headerlink" title="2.2 EntityManagerFactory (实体管理器工厂)"></a>2.2 EntityManagerFactory (实体管理器工厂)</h3><ul>
<li><strong>定义</strong>: 用于创建 <code>EntityManager</code> 实例的工厂对象。</li>
<li><strong>类比</strong>: 类似于 MyBatis 中的 <code>SqlSessionFactory</code> 或数据库的连接池。</li>
<li><strong>特点</strong>:<ul>
<li><strong>重量级对象</strong>: 创建 <code>EntityManagerFactory</code> 的过程非常耗时，因为它需要解析所有持久化配置信息、建立与数据库的连接池等。</li>
<li><strong>线程安全</strong>: 它的设计是线程安全的。</li>
<li><strong>生命周期</strong>: 在整个应用程序中，通常<strong>只创建一个</strong> <code>EntityManagerFactory</code> 实例（单例模式）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-EntityManager-实体管理器"><a href="#2-3-EntityManager-实体管理器" class="headerlink" title="2.3 EntityManager (实体管理器)"></a>2.3 EntityManager (实体管理器)</h3><ul>
<li><strong>定义</strong>: <strong>与持久化上下文交互的主要 API</strong>。所有对实体的操作（增删改查）都是通过 <code>EntityManager</code> 来完成的。</li>
<li><strong>类比</strong>: 类似于 MyBatis 中的 <code>SqlSession</code> 或一个数据库连接。</li>
<li><strong>核心方法</strong>:<ul>
<li><code>persist(Object entity)</code>: 将一个新建的实体纳入管理，使其持久化（对应 <code>INSERT</code>）。</li>
<li><code>merge(T entity)</code>: 将一个游离态的实体重新合并到上下文中，或更新一个托管态的实体（对应 <code>UPDATE</code>）。</li>
<li><code>remove(Object entity)</code>: 将一个实体标记为删除状态（对应 <code>DELETE</code>）。</li>
<li><code>find(Class&lt;T&gt; entityClass, Object primaryKey)</code>: 根据主键查找实体（对应 <code>SELECT</code>）。</li>
<li><code>createQuery(String jpql)</code>: 创建 JPQL 查询对象。</li>
</ul>
</li>
<li><strong>特点</strong>:<ul>
<li><strong>轻量级对象</strong>: 创建和销毁的开销很小。</li>
<li><strong>线程不安全</strong>: <strong>绝对不能在多个线程之间共享</strong> <code>EntityManager</code> 实例。</li>
<li><strong>生命周期</strong>: 通常与一个事务或一个请求绑定，即“一请求一 <code>EntityManager</code>，一事务一 <code>EntityManager</code>”。用完后必须关闭。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-4-持久化上下文-Persistence-Context"><a href="#2-4-持久化上下文-Persistence-Context" class="headerlink" title="2.4 持久化上下文 (Persistence Context)"></a>2.4 持久化上下文 (Persistence Context)</h3><p><strong>这是 JPA&#x2F;Hibernate 最核心、最关键的概念，是理解其“魔法”的关键。</strong></p>
<ul>
<li><strong>定义</strong>: 一个<strong>实体实例的集合</strong>，可以理解为一个<strong>一级缓存</strong>或一个“工作单元”。<code>EntityManager</code> 管理的所有实体都存放在这个上下文中。</li>
<li><strong>特点</strong>:<ol>
<li><strong>身份管理 (Identity Management)</strong>: 在同一个持久化上下文中，对于同一个主键，<code>find()</code> 方法永远返回<strong>同一个 Java 对象实例</strong>。这保证了数据的一致性。</li>
<li><strong>事务回写 (Transactional Write-Behind)</strong>: 当你调用 <code>persist()</code> 或 <code>merge()</code> 时，Hibernate <strong>不会</strong>立即执行 SQL。它会将这些操作缓存起来，直到事务提交或上下文被刷新 (<code>flush</code>) 时，才会将这些变更批量同步到数据库。</li>
<li><strong>自动脏检查 (Automatic Dirty Checking)</strong>: 这是 JPA&#x2F;Hibernate 最神奇的特性。当事务提交时，持久化上下文会<strong>自动检测</strong>其中所有<strong>托管态 (Managed)</strong> 实体的属性是否发生了变化（与加载时的快照进行对比）。如果发生变化，Hibernate 会<strong>自动生成</strong>一条 <code>UPDATE</code> 语句并执行，<strong>无需你手动调用任何 <code>update</code> 方法</strong>。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-5-实体生命周期-Entity-Lifecycle"><a href="#2-5-实体生命周期-Entity-Lifecycle" class="headerlink" title="2.5 实体生命周期 (Entity Lifecycle)"></a>2.5 实体生命周期 (Entity Lifecycle)</h3><p>一个实体对象在其生命周期中会经历四种状态，<code>EntityManager</code> 的方法就是用来驱动实体在这些状态之间转换的。</p>
<ol>
<li><strong>新建态 (New &#x2F; Transient)</strong><ul>
<li><strong>描述</strong>: 一个刚刚 <code>new</code> 出来的 POJO 对象，它还没有主键，也<strong>没有</strong>被任何持久化上下文所管理。</li>
<li><strong>特点</strong>: 数据库中没有与之对应的记录。</li>
</ul>
</li>
<li><strong>托管态 (Managed &#x2F; Persistent)</strong><ul>
<li><strong>描述</strong>: 实体<strong>正在</strong>被一个持久化上下文所管理。</li>
<li><strong>来源</strong>:<ul>
<li>通过 <code>em.find()</code> 或 JPQL 查询从数据库加载而来。</li>
<li>通过 <code>em.persist()</code> 将一个新建态实体转入。</li>
<li>通过 <code>em.merge()</code> 将一个游离态实体转入。</li>
</ul>
</li>
<li><strong>特点</strong>: <strong>所有对该实体属性的修改都会被自动脏检查机制监视，并在事务提交时同步到数据库。</strong></li>
</ul>
</li>
<li><strong>游离态 (Detached)</strong><ul>
<li><strong>描述</strong>: 实体曾经被持久化上下文管理，但该上下文<strong>已经关闭</strong> (<code>em.close()</code>)，或者实体被<strong>明确地</strong>从上下文中分离 (<code>em.detach()</code>)。</li>
<li><strong>特点</strong>: 实体仍然拥有主键，但它已不再受 JPA 管理。对它的任何修改都<strong>不会</strong>被自动同步到数据库。</li>
</ul>
</li>
<li><strong>删除态 (Removed)</strong><ul>
<li><strong>描述</strong>: 实体正在被持久化上下文管理，但已被标记为删除状态（通过 <code>em.remove()</code>）。</li>
<li><strong>特点</strong>: 在事务提交时，数据库中与该实体对应的记录将被删除。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-6-事务-Transaction"><a href="#2-6-事务-Transaction" class="headerlink" title="2.6 事务 (Transaction)"></a>2.6 事务 (Transaction)</h3><ul>
<li><strong>定义</strong>: 一个原子性的工作单元。JPA 规定，所有对数据的修改操作（<code>persist</code>, <code>merge</code>, <code>remove</code>）都<strong>必须</strong>在一个活动的事务中进行。</li>
<li><strong>关联</strong>: 事务的生命周期通常与 <code>EntityManager</code> 和持久化上下文的生命周期绑定。当事务提交时，持久化上下文会将所有变更刷新 (<code>flush</code>) 到数据库。如果事务回滚，所有变更都会被丢弃。</li>
</ul>
<hr>
<h2 id="3-快速入门-1"><a href="#3-快速入门-1" class="headerlink" title="3. 快速入门"></a>3. 快速入门</h2><p>在现代 Java 开发中，直接使用原生的 JPA API (<code>EntityManager</code>) 相对繁琐。Spring Boot 集成了 <strong>Spring Data JPA</strong>，它在 JPA 规范之上提供了一个更高层次的抽象，极大地简化了数据访问层的开发。本快速入门将基于这一黄金组合。</p>
<h3 id="3-1-环境与项目准备"><a href="#3-1-环境与项目准备" class="headerlink" title="3.1 环境与项目准备"></a>3.1 环境与项目准备</h3><ul>
<li><strong>环境</strong>: JDK 1.8+, Maven 3.6+, MySQL 5.7+</li>
<li><strong>项目</strong>: 使用 <a target="_blank" rel="noopener" href="https://start.spring.io/">Spring Initializr</a> 创建一个新的 Spring Boot 项目，并勾选以下依赖：<ul>
<li><strong>Spring Web</strong>: 用于创建 Web 应用。</li>
<li><strong>Spring Data JPA</strong>: JPA 的核心依赖。</li>
<li><strong>MySQL Driver</strong>: 数据库驱动。</li>
<li><strong>Lombok</strong>: (可选，但推荐) 简化实体类代码。</li>
</ul>
</li>
</ul>
<p><strong>生成的 <code>pom.xml</code> 核心依赖</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: <code>spring-boot-starter-data-jpa</code> 会自动传递依赖引入 <strong>Hibernate</strong> 作为默认的 JPA 实现。</p>
<hr>
<h3 id="3-2-配置数据库连接"><a href="#3-2-配置数据库连接" class="headerlink" title="3.2 配置数据库连接"></a>3.2 配置数据库连接</h3><p>在 <code>src/main/resources/application.properties</code> (或 <code>application.yml</code>) 文件中，配置数据库信息和 JPA&#x2F;Hibernate 的相关属性。</p>
<p><strong><code>application.properties</code> 格式:</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DataSource Configuration</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/your_database?useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">your_password</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># JPA / Hibernate Configuration</span></span><br><span class="line"><span class="comment"># (可选) 让 Hibernate 自动根据实体类创建或更新数据库表结构。</span></span><br><span class="line"><span class="comment"># create: 每次启动都删除并重建。</span></span><br><span class="line"><span class="comment"># create-drop: 启动时创建，关闭时删除。</span></span><br><span class="line"><span class="comment"># update: 检查差异并更新（不删除列）。</span></span><br><span class="line"><span class="comment"># validate: 验证实体与表的匹配性。</span></span><br><span class="line"><span class="comment"># none: (生产环境推荐) 不做任何操作。</span></span><br><span class="line"><span class="attr">spring.jpa.hibernate.ddl-auto</span>=<span class="string">update</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># (可选) 在控制台显示 Hibernate 执行的 SQL 语句，方便调试。</span></span><br><span class="line"><span class="attr">spring.jpa.show-sql</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># (可选) 对显示的 SQL 进行格式化。</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.format_sql</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 请替换 <code>your_database</code> 和 <code>your_password</code>。<code>ddl-auto=update</code> 仅适用于开发和测试环境，生产环境应使用 <code>validate</code> 或 <code>none</code>，并由专业的数据库迁移工具（如 Flyway, Liquibase）管理表结构。</p>
<hr>
<h3 id="3-3-创建实体类-Entity"><a href="#3-3-创建实体类-Entity" class="headerlink" title="3.3 创建实体类 (Entity)"></a>3.3 创建实体类 (Entity)</h3><p>创建一个与数据库表对应的 Java 实体类，并使用 JPA 注解进行映射。</p>
<p><strong>数据库表 (user):</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">INT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `email` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>实体类 <code>User.java</code>:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/entity/User.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.persistence.*; <span class="comment">// Spring Boot 3.x 使用 jakarta.persistence</span></span><br><span class="line"><span class="comment">// import javax.persistence.*; // Spring Boot 2.x 使用 javax.persistence</span></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span> <span class="comment">// 标记这是一个 JPA 实体</span></span><br><span class="line"><span class="meta">@Table(name = &quot;user&quot;)</span> <span class="comment">// 映射到数据库的 &quot;user&quot; 表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="comment">// 标记主键</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span> <span class="comment">// 主键生成策略：数据库自增</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;name&quot;, length = 50)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(name = &quot;age&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;email&quot;, unique = true)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-4-创建-Repository-接口"><a href="#3-4-创建-Repository-接口" class="headerlink" title="3.4 创建 Repository 接口"></a>3.4 创建 Repository 接口</h3><p>这是 Spring Data JPA 的魔力所在。你只需要创建一个接口，并继承 <code>JpaRepository</code>，就能<strong>立即拥有一整套完整的 CRUD 方法，无需任何实现</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/repository/UserRepository.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span> <span class="comment">// 标记这是一个 Spring 管理的 Repository Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// JpaRepository&lt;实体类型, 主键类型&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring Data JPA 的另一大魔法：方法命名查询 (Query Methods)</span></span><br><span class="line">    <span class="comment">// 你只需按照约定的规则定义方法名，Spring Data JPA 就会自动为你生成 JPQL 查询。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据名字查询用户</span></span><br><span class="line"><span class="comment">     * Spring Data JPA 会自动生成: SELECT u FROM User u WHERE u.name = ?1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    User <span class="title function_">findByName</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据名字模糊查询并按年龄降序排序</span></span><br><span class="line"><span class="comment">     * 会生成: SELECT u FROM User u WHERE u.name LIKE ?1 ORDER BY u.age DESC</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByNameContainingOrderByAgeDesc</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-5-编写测试代码"><a href="#3-5-编写测试代码" class="headerlink" title="3.5 编写测试代码"></a>3.5 编写测试代码</h3><p>现在，你可以编写一个测试类，注入 <code>UserRepository</code>，并直接调用其内置或自定义的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/test/java/com/example/MyApplicationTests.java</span></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.repository.UserRepository;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;JPA Tester&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">28</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;jpa@example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">savedUser</span> <span class="operator">=</span> userRepository.save(user); <span class="comment">// save 方法兼具插入和更新功能</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Saved user: &quot;</span> + savedUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testFindById</span><span class="params">()</span> &#123;</span><br><span class="line">        Optional&lt;User&gt; userOptional = userRepository.findById(<span class="number">1L</span>); <span class="comment">// findById 返回 Optional</span></span><br><span class="line">        userOptional.ifPresent(user -&gt; System.out.println(<span class="string">&quot;Found user: &quot;</span> + user));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testFindAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; users = userRepository.findAll();</span><br><span class="line">        users.forEach(System.out.println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">        userRepository.findById(<span class="number">1L</span>).ifPresent(user -&gt; &#123;</span><br><span class="line">            user.setAge(<span class="number">30</span>);</span><br><span class="line">            userRepository.save(user); <span class="comment">// ID 存在时，save 方法执行更新</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Updated user: &quot;</span> + user);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> &#123;</span><br><span class="line">        userRepository.deleteById(<span class="number">1L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;User with ID 1 deleted.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testCustomQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepository.findByName(<span class="string">&quot;JPA Tester&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Found by custom query: &quot;</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-实体关系映射"><a href="#4-实体关系映射" class="headerlink" title="4. 实体关系映射"></a>4. 实体关系映射</h2><p>在真实的业务场景中，数据库的表之间往往存在着各种关联关系，如一个用户有多个订单，一个订单属于一个用户。JPA 提供了一套丰富的注解，用于在实体类 (Entity) 之间精确地描述这些关系。正确地进行关系映射是 ORM 框架的核心价值所在。</p>
<p>数据库中的关系主要有四种：<strong>一对一 (OneToOne)</strong>, <strong>一对多 (OneToMany)</strong>, <strong>多对一 (ManyToOne)</strong>, 和 <strong>多对多 (ManyToMany)</strong>。</p>
<h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><ul>
<li><strong>关系拥有方 (Owning Side)</strong>: 负责维护关联关系的一方。通常是<strong>包含外键</strong>的那一方。在拥有方的实体中，会通过 <code>@JoinColumn</code> 注解来指定外键列。</li>
<li><strong>关系被拥有方 (Inverse Side)</strong>: 不负责维护关联关系的一方。在被拥有方的注解中，通常需要使用 <code>mappedBy</code> 属性来指明这段关系是由对方的哪个属性来维护的。</li>
<li><strong>级联操作 (Cascade)</strong>: 当对主实体进行操作（如 <code>persist</code>, <code>remove</code>, <code>merge</code>）时，是否要将该操作<strong>级联</strong>到其关联的实体上。通过 <code>@...To...</code> 注解的 <code>cascade</code> 属性来配置。</li>
<li><strong>抓取策略 (Fetch)</strong>: 当加载一个实体时，是否要<strong>立即</strong>加载其关联的实体（<strong>饥饿加载 Eager Fetch</strong>），还是在<strong>第一次访问</strong>关联实体时才去加载（<strong>懒加载 Lazy Fetch</strong>）。通过 <code>@...To...</code> 注解的 <code>fetch</code> 属性来配置。</li>
</ul>
<hr>
<h3 id="4-2-多对一-ManyToOne-一对多-OneToMany"><a href="#4-2-多对一-ManyToOne-一对多-OneToMany" class="headerlink" title="4.2 多对一 (ManyToOne) &amp; 一对多 (OneToMany)"></a>4.2 多对一 (ManyToOne) &amp; 一对多 (OneToMany)</h3><p>这是最常见的一种关系。例如：<strong>多个订单 (<code>Order</code>) 属于一个客户 (<code>Customer</code>)</strong>。</p>
<ul>
<li><strong><code>@ManyToOne</code></strong>: 放在“多”的一方（<code>Order</code>），表示多个订单对应一个客户。</li>
<li><strong><code>@OneToMany</code></strong>: 放在“一”的一方（<code>Customer</code>），表示一个客户拥有一个订单列表。</li>
</ul>
<p><strong>数据库表结构</strong>: <code>t_order</code> 表中会有一个 <code>customer_id</code> 外键列，指向 <code>t_customer</code> 表的主键。</p>
<p><strong>实体类定义</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户实体 (&quot;一&quot;的一方)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_customer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@OneToMany</span>: 声明一对多关系</span></span><br><span class="line"><span class="comment">     * mappedBy = &quot;customer&quot;: </span></span><br><span class="line"><span class="comment">     *      - 指明这个关联关系由 Order 实体的 &quot;customer&quot; 属性来维护。</span></span><br><span class="line"><span class="comment">     *      - 这意味着 Customer 是关系的【被拥有方】，它不包含外键。</span></span><br><span class="line"><span class="comment">     *      - &quot;customer&quot; 必须是 Order 类中 <span class="doctag">@ManyToOne</span> 注解的那个字段名。</span></span><br><span class="line"><span class="comment">     * cascade = CascadeType.ALL: </span></span><br><span class="line"><span class="comment">     *      - 级联所有操作。保存客户时会自动保存其名下的新订单，删除客户时会自动删除其所有订单。</span></span><br><span class="line"><span class="comment">     * fetch = FetchType.LAZY:</span></span><br><span class="line"><span class="comment">     *      - 懒加载。查询客户时，默认不加载其订单列表，只有在首次调用 getOrders() 时才会去查询数据库。</span></span><br><span class="line"><span class="comment">     *      - 【最佳实践】所有集合类型的关联（OneToMany, ManyToMany）都应配置为懒加载，避免性能问题。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = &quot;customer&quot;, cascade = CascadeType.ALL, fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订单实体 (&quot;多&quot;的一方)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String orderNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@ManyToOne</span>: 声明多对一关系</span></span><br><span class="line"><span class="comment">     * fetch = FetchType.EAGER:</span></span><br><span class="line"><span class="comment">     *      - 饥饿加载。查询订单时，会立即通过 LEFT JOIN 将其关联的客户信息一并查询出来。</span></span><br><span class="line"><span class="comment">     *      - 【默认策略】...ToOne 关系的默认抓取策略是 EAGER。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@JoinColumn</span>(name = &quot;customer_id&quot;):</span></span><br><span class="line"><span class="comment">     *      - 指定外键列。这表明 Order 是关系的【拥有方】。</span></span><br><span class="line"><span class="comment">     *      - name = &quot;customer_id&quot; 指的是 t_order 表中的外键列名。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.EAGER)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-一对一-OneToOne"><a href="#4-3-一对一-OneToOne" class="headerlink" title="4.3 一对一 (OneToOne)"></a>4.3 一对一 (OneToOne)</h3><p>例如：一个<strong>用户 (<code>User</code>)</strong> 对应一个<strong>用户详情 (<code>UserProfile</code>)</strong>。</p>
<p>一对一关系可以通过共享主键或唯一外键来实现。这里以外键为例。</p>
<p><strong>数据库表结构</strong>: <code>t_user_profile</code> 表中有一个 <code>user_id</code> 外键列，且该列具有唯一约束 (<code>UNIQUE</code>)。</p>
<p><strong>实体类定义</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户实体</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mappedBy = &quot;user&quot;: 表示关系由 UserProfile 的 &quot;user&quot; 属性维护。</span></span><br><span class="line"><span class="comment">     * cascade = CascadeType.ALL: 级联操作。</span></span><br><span class="line"><span class="comment">     * optional = false: 表示 UserProfile 对于 User 来说是必须存在的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OneToOne(mappedBy = &quot;user&quot;, cascade = CascadeType.ALL, fetch = FetchType.LAZY, optional = false)</span></span><br><span class="line">    <span class="keyword">private</span> UserProfile userProfile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户详情实体</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_user_profile&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProfile</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@JoinColumn</span>: 指定外键，使其成为关系拥有方。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OneToOne(fetch = FetchType.EAGER)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;user_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-4-多对多-ManyToMany"><a href="#4-4-多对多-ManyToMany" class="headerlink" title="4.4 多对多 (ManyToMany)"></a>4.4 多对多 (ManyToMany)</h3><p>例如：一个<strong>学生 (<code>Student</code>)</strong> 可以选择多门<strong>课程 (<code>Course</code>)</strong>，一门课程也可以被多个学生选择。</p>
<p>多对多关系在数据库中必须通过一个**中间表（连接表）**来实现。</p>
<p><strong>数据库表结构</strong>: 除了 <code>t_student</code> 和 <code>t_course</code> 表，还需要一个 <code>t_student_course</code> 中间表，它至少包含 <code>student_id</code> 和 <code>course_id</code> 两个外键。</p>
<p><strong>实体类定义</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_student&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@ManyToMany</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@JoinTable</span>: 配置中间表信息</span></span><br><span class="line"><span class="comment">     *      - name: 中间表的名称</span></span><br><span class="line"><span class="comment">     *      - joinColumns: 定义中间表中与【本实体】关联的外键。</span></span><br><span class="line"><span class="comment">     *          - <span class="doctag">@JoinColumn</span>(name = &quot;student_id&quot;): 中间表中名为 &quot;student_id&quot; 的列。</span></span><br><span class="line"><span class="comment">     *      - inverseJoinColumns: 定义中间表中与【对方实体】关联的外键。</span></span><br><span class="line"><span class="comment">     *          - <span class="doctag">@JoinColumn</span>(name = &quot;course_id&quot;): 中间表中名为 &quot;course_id&quot; 的列。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ManyToMany(fetch = FetchType.LAZY, cascade = CascadeType.PERSIST)</span></span><br><span class="line">    <span class="meta">@JoinTable(name = &quot;t_student_course&quot;,</span></span><br><span class="line"><span class="meta">               joinColumns = @JoinColumn(name = &quot;student_id&quot;),</span></span><br><span class="line"><span class="meta">               inverseJoinColumns = @JoinColumn(name = &quot;course_id&quot;))</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Course&gt; courses = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_course&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Course</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mappedBy = &quot;courses&quot;: </span></span><br><span class="line"><span class="comment">     *      - 表示这是一个双向关系，且由 Student 实体的 &quot;courses&quot; 属性维护。</span></span><br><span class="line"><span class="comment">     *      - 通常在多对多关系中，我们会选择一方作为拥有方（配置<span class="doctag">@JoinTable</span>），另一方作为被拥有方（配置mappedBy）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ManyToMany(mappedBy = &quot;courses&quot;, fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-5-总结与最佳实践"><a href="#4-5-总结与最佳实践" class="headerlink" title="4.5 总结与最佳实践"></a>4.5 总结与最佳实践</h3><ul>
<li><strong><code>@...ToOne</code> 默认是 EAGER，<code>@...ToMany</code> 默认是 LAZY</strong>。</li>
<li><strong>最佳实践</strong>: 为了避免 N+1 查询问题和不必要的性能开销，<strong>强烈建议将所有关联关系都显式地设置为 <code>fetch = FetchType.LAZY</code></strong>，然后在需要时通过 JPQL 的 <code>JOIN FETCH</code> 或 <code>@EntityGraph</code> 来主动抓取数据。</li>
<li><strong>双向关系</strong>: 在设置双向关系时，<strong>必须</strong>在其中一方使用 <code>mappedBy</code> 来指定关系维护方，否则 Hibernate 会认为这是两个独立的关系，可能会创建出两张中间表或两个外键列。</li>
<li><strong>集合类型</strong>: 对于 <code>@OneToMany</code> 和 <code>@ManyToMany</code>，推荐使用 <code>Set</code> 集合类型，因为 <code>Set</code> 不允许重复元素，更符合关系模型的语义，并且在某些场景下比 <code>List</code> 性能更好。</li>
</ul>
<hr>
<h2 id="5-JPQL-Java-Persistence-Query-Language"><a href="#5-JPQL-Java-Persistence-Query-Language" class="headerlink" title="5. JPQL (Java Persistence Query Language)"></a>5. JPQL (Java Persistence Query Language)</h2><h3 id="5-1-什么是-JPQL？"><a href="#5-1-什么是-JPQL？" class="headerlink" title="5.1 什么是 JPQL？"></a>5.1 什么是 JPQL？</h3><p><strong>JPQL (Java Persistence Query Language)</strong> 是 JPA 规范中定义的一种<strong>面向对象的查询语言</strong>。它在语法上与 SQL 非常相似，但有一个根本性的区别：</p>
<ul>
<li><strong>SQL</strong> 操作的是数据库的<strong>表 (table)</strong> 和<strong>列 (column)</strong>。</li>
<li><strong>JPQL</strong> 操作的是 JPA 的<strong>实体 (Entity)</strong> 和<strong>属性 (property)</strong>。</li>
</ul>
<p>这种面向对象的特性使得 JPQL 具有<strong>平台无关性</strong>。你编写的 JPQL 查询语句可以被任何 JPA 实现（如 Hibernate, EclipseLink）正确地解析，并由底层框架转换为对应数据库方言的 SQL 语句来执行。</p>
<hr>
<h3 id="5-2-JPQL-的核心优势"><a href="#5-2-JPQL-的核心优势" class="headerlink" title="5.2 JPQL 的核心优势"></a>5.2 JPQL 的核心优势</h3><ol>
<li><strong>面向对象</strong>: 查询逻辑直接与你的领域模型（实体类）绑定，而不是与底层数据库结构耦合，代码更直观，可读性更高。</li>
<li><strong>数据库无关</strong>: 无需关心不同数据库的 SQL 语法差异（如分页、函数等）。JPA 提供商会自动处理这些转换。</li>
<li><strong>类型安全</strong>: 与拼接原生 SQL 相比，JPQL 查询通常与参数绑定结合使用，可以有效防止 SQL 注入。</li>
<li><strong>支持复杂查询</strong>: 支持连接查询 (JOIN)、聚合函数、分组、子查询等所有高级查询功能。</li>
</ol>
<hr>
<h3 id="5-3-JPQL-基础语法"><a href="#5-3-JPQL-基础语法" class="headerlink" title="5.3 JPQL 基础语法"></a>5.3 JPQL 基础语法</h3><p>JPQL 的语法结构与 SQL 几乎一致，主要包括 <code>SELECT</code>, <code>UPDATE</code>, <code>DELETE</code> 语句。</p>
<h4 id="5-3-1-SELECT-查询"><a href="#5-3-1-SELECT-查询" class="headerlink" title="5.3.1 SELECT 查询"></a>5.3.1 <code>SELECT</code> 查询</h4><p>这是最常用的查询类型。</p>
<p><strong>基本结构</strong>:<br><code>SELECT ... FROM EntityName [alias] WHERE ... GROUP BY ... HAVING ... ORDER BY ...</code></p>
<p><strong>示例 1: 简单查询</strong><br>查询所有年龄大于 18 岁的用户。</p>
<ul>
<li><strong>JPQL</strong>: <code>SELECT u FROM User u WHERE u.age &gt; 18</code></li>
<li><strong>注意</strong>:<ul>
<li><code>FROM User u</code>: <code>User</code> 是<strong>实体类的名称</strong>，不是表名。<code>u</code> 是别名。</li>
<li><code>u.age</code>: 引用的是 <code>User</code> 实体的 <code>age</code> <strong>属性</strong>，不是数据库的 <code>age</code> 列。</li>
</ul>
</li>
</ul>
<p><strong>示例 2: 投影查询 (查询部分属性)</strong><br>只查询用户的姓名和邮箱。</p>
<ul>
<li><strong>JPQL</strong>: <code>SELECT u.name, u.email FROM User u</code></li>
<li><strong>返回类型</strong>: 默认返回 <code>List&lt;Object[]&gt;</code>，每个 <code>Object[]</code> 包含 <code>name</code> 和 <code>email</code>。</li>
<li><strong>构造器表达式 (推荐)</strong>: 为了获得类型安全的 <code>List&lt;UserDTO&gt;</code>，可以使用构造器表达式。<ul>
<li><strong>JPQL</strong>: <code>SELECT new com.example.dto.UserDTO(u.name, u.email) FROM User u</code></li>
<li>这要求 <code>UserDTO</code> 有一个匹配的构造函数 <code>public UserDTO(String name, String email)</code>。</li>
</ul>
</li>
</ul>
<p><strong>示例 3: 参数绑定</strong><br>使用<strong>命名参数 (<code>:paramName</code>)</strong> 或 <strong>位置参数 (<code>?index</code>)</strong> 来传递查询条件，防止 SQL 注入。<strong>命名参数是首选</strong>，因为它更具可读性。</p>
<ul>
<li><strong>JPQL (命名参数)</strong>: <code>SELECT u FROM User u WHERE u.name = :name AND u.age &gt; :minAge</code></li>
<li><strong>JPQL (位置参数)</strong>: <code>SELECT u FROM User u WHERE u.name = ?1 AND u.age &gt; ?2</code></li>
</ul>
<hr>
<h4 id="5-3-2-UPDATE-和-DELETE-查询"><a href="#5-3-2-UPDATE-和-DELETE-查询" class="headerlink" title="5.3.2 UPDATE 和 DELETE 查询"></a>5.3.2 <code>UPDATE</code> 和 <code>DELETE</code> 查询</h4><p>JPQL 也支持批量更新和删除操作。</p>
<ul>
<li><strong><code>UPDATE</code></strong>: <code>UPDATE User u SET u.age = u.age + 1 WHERE u.status = &#39;inactive&#39;</code></li>
<li><strong><code>DELETE</code></strong>: <code>DELETE FROM User u WHERE u.lastLoginTime &lt; :someDate</code></li>
</ul>
<p><strong>重要注意事项</strong>:</p>
<ul>
<li>批量 <code>UPDATE</code> 和 <code>DELETE</code> 操作会<strong>直接在数据库层面执行</strong>，它们会<strong>绕过持久化上下文 (一级缓存)</strong>。</li>
<li>这意味着，如果持久化上下文中存在已被这些批量操作修改或删除的实体，这些实体<strong>不会</strong>自动更新，可能会导致<strong>数据不一致</strong>。</li>
<li>因此，在执行批量操作后，通常建议<strong>清空持久化上下文</strong> (<code>entityManager.clear()</code>)，以强制后续查询从数据库重新加载最新数据。</li>
</ul>
<hr>
<h3 id="5-4-连接查询-JOIN"><a href="#5-4-连接查询-JOIN" class="headerlink" title="5.4 连接查询 (JOIN)"></a>5.4 连接查询 (JOIN)</h3><p>JPQL 的连接查询是其强大功能的核心，它允许你根据实体之间的关联关系进行导航查询。</p>
<p>假设有 <code>Customer</code> (一) 和 <code>Order</code> (多) 两个实体。</p>
<ul>
<li><strong><code>INNER JOIN</code></strong>: <code>SELECT c FROM Customer c JOIN c.orders o WHERE o.amount &gt; 100</code><ul>
<li>查询所有拥有订单金额大于 100 的客户。</li>
<li><code>c.orders</code> 是 <code>Customer</code> 实体中定义的关联属性。</li>
</ul>
</li>
<li><strong><code>LEFT JOIN</code></strong>: <code>SELECT c, o FROM Customer c LEFT JOIN c.orders o</code><ul>
<li>查询所有客户及其订单，即使客户没有任何订单也会被查询出来。</li>
</ul>
</li>
<li><strong><code>JOIN FETCH</code> (性能优化的关键)</strong>: 这是 JPQL 中一个极其重要的特性，用于解决 <strong>N+1 查询问题</strong>。<ul>
<li><strong>普通 JOIN</strong>: <code>SELECT c FROM Customer c JOIN c.orders</code> 只会查询出 <code>Customer</code>，当你访问 <code>c.getOrders()</code> 时，仍然会为每个 <code>Customer</code> 发起一次新的 SQL 去查询其 <code>Order</code>（如果关联是懒加载）。</li>
<li><strong><code>JOIN FETCH</code></strong>: <code>SELECT c FROM Customer c LEFT JOIN FETCH c.orders</code></li>
<li><code>FETCH</code> 关键字告诉 JPA 提供商，在执行查询时，不仅要加载主实体 (<code>Customer</code>)，还要<strong>立即、一次性地</strong>将其关联的集合 (<code>orders</code>) 也查询出来并填充好。</li>
<li>这会将多次查询合并为一次 <code>LEFT JOIN</code> SQL，极大地提升了性能。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-5-在-Spring-Data-JPA-中使用-JPQL"><a href="#5-5-在-Spring-Data-JPA-中使用-JPQL" class="headerlink" title="5.5 在 Spring Data JPA 中使用 JPQL"></a>5.5 在 Spring Data JPA 中使用 JPQL</h3><p>Spring Data JPA 提供了多种使用 JPQL 的方式，最常用的是通过 <code>@Query</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 JPQL 进行查询，并使用命名参数</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT u FROM User u WHERE u.email = :email&quot;)</span></span><br><span class="line">    Optional&lt;User&gt; <span class="title function_">findByEmailAddress</span><span class="params">(<span class="meta">@Param(&quot;email&quot;)</span> String email)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用构造器表达式返回 DTO</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT new com.example.dto.UserSummary(u.id, u.name) FROM User u WHERE u.age &gt; :minAge&quot;)</span></span><br><span class="line">    List&lt;UserSummary&gt; <span class="title function_">findUserSummariesByAge</span><span class="params">(<span class="meta">@Param(&quot;minAge&quot;)</span> <span class="type">int</span> age)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 JOIN FETCH 解决 N+1 问题</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT DISTINCT c FROM Customer c LEFT JOIN FETCH c.orders&quot;)</span></span><br><span class="line">    List&lt;Customer&gt; <span class="title function_">findAllCustomersWithOrders</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @Modifying 注解来执行更新或删除操作</span></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// 更新/删除操作需要事务</span></span><br><span class="line">    <span class="meta">@Query(&quot;UPDATE User u SET u.status = :newStatus WHERE u.id = :id&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateUserStatus</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id, <span class="meta">@Param(&quot;newStatus&quot;)</span> String newStatus)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>:</p>
<ul>
<li><code>@Query</code>: 将 JPQL 语句直接写在接口方法上。</li>
<li><code>@Param</code>: 用于将方法参数与 JPQL 中的命名参数进行绑定。</li>
<li><code>@Modifying</code>: <strong>必须</strong>用于标记执行 <code>UPDATE</code> 或 <code>DELETE</code> 操作的方法。</li>
<li><code>@Transactional</code>: 修改数据的操作通常需要事务支持。</li>
</ul>
<hr>
<h2 id="6-Spring-Data-JPA"><a href="#6-Spring-Data-JPA" class="headerlink" title="6. Spring Data JPA"></a>6. Spring Data JPA</h2><h3 id="6-1-什么是-Spring-Data-JPA？"><a href="#6-1-什么是-Spring-Data-JPA？" class="headerlink" title="6.1 什么是 Spring Data JPA？"></a>6.1 什么是 Spring Data JPA？</h3><p><strong>Spring Data JPA</strong> 是 Spring Data 项目下的一个核心子模块。它并非一个新的 ORM 框架，也不是 JPA 的替代品，而是<strong>在 JPA 规范之上构建的一个更高层次的抽象层</strong>。</p>
<p><strong>核心目标</strong>：<strong>极大地简化和标准化数据访问层 (DAO&#x2F;Repository) 的开发</strong>。</p>
<p>Spring Data JPA 通过提供强大的 <code>Repository</code> 抽象和一系列约定，使得开发者可以从繁琐的、样板化的数据访问代码中解放出来，甚至在很多情况下，<strong>无需编写任何实现代码</strong>就能完成复杂的数据库操作。</p>
<p>它底层的持久化工作仍然委托给 JPA 提供商（默认为 Hibernate）来完成。可以理解为：<br><code>你的代码 -&gt; Spring Data JPA -&gt; JPA API (Hibernate) -&gt; JDBC -&gt; 数据库</code></p>
<hr>
<h3 id="6-2-核心特性与优势"><a href="#6-2-核心特性与优势" class="headerlink" title="6.2 核心特性与优势"></a>6.2 核心特性与优势</h3><h4 id="1-强大的-Repository-抽象-JpaRepository"><a href="#1-强大的-Repository-抽象-JpaRepository" class="headerlink" title="1. 强大的 Repository 抽象 (JpaRepository)"></a><strong>1. 强大的 Repository 抽象 (<code>JpaRepository</code>)</strong></h4><p>这是 Spring Data JPA 的基石。你只需要创建一个接口并继承 <code>JpaRepository&lt;T, ID&gt;</code>，就能<strong>立即免费获得</strong>一整套开箱即用的、功能完善的 CRUD 和分页排序方法。</p>
<ul>
<li><code>save(S entity)</code>: 保存或更新实体。</li>
<li><code>findById(ID id)</code>: 根据主键查询。</li>
<li><code>findAll()</code>: 查询所有。</li>
<li><code>deleteById(ID id)</code>: 根据主键删除。</li>
<li><code>count()</code>: 统计总数。</li>
<li><code>findAll(Sort sort)</code>: 排序查询。</li>
<li><code>findAll(Pageable pageable)</code>: 分页查询。</li>
<li>… 等等</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只需要定义接口，无需任何实现类！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-方法命名查询-Query-Methods-Derived-Queries"><a href="#2-方法命名查询-Query-Methods-Derived-Queries" class="headerlink" title="2. 方法命名查询 (Query Methods &#x2F; Derived Queries)"></a><strong>2. 方法命名查询 (Query Methods &#x2F; Derived Queries)</strong></h4><p>这是 Spring Data JPA 最“神奇”的特性。你只需<strong>按照一套约定的命名规则来定义接口方法</strong>，Spring Data JPA 就会在运行时自动解析方法名，并为你生成相应的 JPQL 查询。</p>
<ul>
<li><strong>关键字</strong>: <code>FindBy</code>, <code>CountBy</code>, <code>ExistsBy</code>, <code>DeleteBy</code></li>
<li><strong>属性表达式</strong>: <code>And</code>, <code>Or</code>, <code>Between</code>, <code>LessThan</code>, <code>GreaterThan</code>, <code>Like</code>, <code>Containing</code>, <code>IsNull</code>, <code>In</code></li>
<li><strong>排序与限制</strong>: <code>OrderBy...Asc/Desc</code>, <code>Top</code>, <code>First</code></li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// 根据 name 查询</span></span><br><span class="line">    <span class="comment">// JPQL: select u from User u where u.name = ?1</span></span><br><span class="line">    User <span class="title function_">findByName</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 name 和 age 查询</span></span><br><span class="line">    <span class="comment">// JPQL: select u from User u where u.name = ?1 and u.age = ?2</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByNameAndAge</span><span class="params">(String name, <span class="type">int</span> age)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据 age 大于某个值并按 name 降序排序，只取前10条</span></span><br><span class="line">    <span class="comment">// JPQL: select u from User u where u.age &gt; ?1 order by u.name desc limit 10</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findTop10ByAgeGreaterThanOrderByNameDesc</span><span class="params">(<span class="type">int</span> age)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否存在某个 email 的用户</span></span><br><span class="line">    <span class="comment">// JPQL: select case when count(u) &gt; 0 then true else false end from User u where u.email = ?1</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">existsByEmail</span><span class="params">(String email)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-使用-Query-注解自定义查询"><a href="#3-使用-Query-注解自定义查询" class="headerlink" title="3. 使用 @Query 注解自定义查询"></a><strong>3. 使用 <code>@Query</code> 注解自定义查询</strong></h4><p>对于方法命名无法表达的复杂查询逻辑（例如多表连接、子查询、DTO 投影等），可以使用 <code>@Query</code> 注解，直接在接口方法上编写 <strong>JPQL</strong> 或 <strong>原生 SQL</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 JPQL</span></span><br><span class="line">    <span class="meta">@Query(&quot;select u from User u where u.name like %:name%&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findUsersByNameLike</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用原生 SQL (nativeQuery = true)</span></span><br><span class="line">    <span class="meta">@Query(value = &quot;SELECT * FROM user WHERE email = ?1&quot;, nativeQuery = true)</span></span><br><span class="line">    User <span class="title function_">findByEmailWithNativeSQL</span><span class="params">(String email)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 @Modifying 执行更新操作</span></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Query(&quot;update User u set u.age = u.age + 1 where u.id = :id&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">incrementAge</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-动态查询支持-JPA-Criteria-API-QueryDSL"><a href="#4-动态查询支持-JPA-Criteria-API-QueryDSL" class="headerlink" title="4. 动态查询支持 (JPA Criteria API &amp; QueryDSL)"></a><strong>4. 动态查询支持 (JPA Criteria API &amp; QueryDSL)</strong></h4><p>对于需要根据运行时条件动态构建查询的场景（例如复杂的多条件搜索），Spring Data JPA 提供了两种强大的集成方案：</p>
<ul>
<li><strong>JPA Specification (规范)</strong>: 提供了一套类型安全的 API，允许你通过组合 <code>Predicate</code> 对象来构建动态的 <code>WHERE</code> 子句。</li>
<li><strong>QueryDSL</strong>: 一个更强大、更流畅的第三方类型安全查询库，与 Spring Data JPA 无缝集成。</li>
</ul>
<h4 id="5-简化的分页与排序"><a href="#5-简化的分页与排序" class="headerlink" title="5. 简化的分页与排序"></a><strong>5. 简化的分页与排序</strong></h4><p>分页和排序被抽象为 <code>Pageable</code> 和 <code>Sort</code> 接口，使用起来极其简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Controller</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;User&gt; <span class="title function_">getUsersByPage</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(defaultValue = &quot;0&quot;)</span> <span class="type">int</span> page,</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(defaultValue = &quot;10&quot;)</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(defaultValue = &quot;id,desc&quot;)</span> String[] sort)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Spring MVC 会自动将请求参数转换为 Pageable 对象</span></span><br><span class="line">    <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> PageRequest.of(page, size, Sort.by(sort));</span><br><span class="line">    <span class="keyword">return</span> userRepository.findAll(pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-3-与-MyBatis-MyBatis-Plus-的对比"><a href="#6-3-与-MyBatis-MyBatis-Plus-的对比" class="headerlink" title="6.3 与 MyBatis&#x2F;MyBatis-Plus 的对比"></a>6.3 与 MyBatis&#x2F;MyBatis-Plus 的对比</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Spring Data JPA (Hibernate)</th>
<th align="left">MyBatis-Plus</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>抽象层次</strong></td>
<td align="left"><strong>高</strong>，完全面向对象，屏蔽 SQL</td>
<td align="left"><strong>中</strong>，半自动，SQL 仍是核心</td>
</tr>
<tr>
<td align="left"><strong>开发效率</strong></td>
<td align="left"><strong>极高</strong>，方法命名和 JpaRepository 极大减少代码</td>
<td align="left"><strong>高</strong>，通用 CRUD 和 Wrapper 也很高效</td>
</tr>
<tr>
<td align="left"><strong>SQL 控制力</strong></td>
<td align="left"><strong>间接</strong>，通过 JPQL 或原生 SQL 控制，不直接</td>
<td align="left"><strong>直接且完全</strong>，可以精细优化每一条 SQL</td>
</tr>
<tr>
<td align="left"><strong>数据库移植性</strong></td>
<td align="left"><strong>非常强</strong>，面向 JPA 规范，更换数据库成本低</td>
<td align="left"><strong>较强</strong>，但复杂 SQL 可能依赖方言</td>
</tr>
<tr>
<td align="left"><strong>学习曲线</strong></td>
<td align="left">较陡峭，需理解实体生命周期、持久化上下文等核心概念</td>
<td align="left">较平缓，对熟悉 SQL 的开发者非常友好</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">简单 CRUD 性能优异，但复杂查询可能因自动生成 SQL 而非最优</td>
<td align="left">开发者可手动编写最优 SQL，性能潜力更高</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">快速开发、标准 CRUD 密集的业务系统、需要数据库无关性的项目</td>
<td align="left">复杂报表、性能要求极致、DBA 深度参与的项目</td>
</tr>
</tbody></table>
<hr>
<h3 id="6-4-总结"><a href="#6-4-总结" class="headerlink" title="6.4 总结"></a>6.4 总结</h3><p>Spring Data JPA 是一个生产力工具，它站在 JPA 这一巨人的肩膀上，通过“<strong>约定优于配置</strong>”的理念，为开发者提供了一套极其优雅和高效的数据访问解决方案。它使得 Repository 层的代码量锐减，让开发者能够更专注于业务逻辑的实现。对于大多数标准的业务系统而言，Spring Data JPA + Hibernate 是一个非常强大且高效的选择。</p>
<hr>
<h2 id="7-适用场景"><a href="#7-适用场景" class="headerlink" title="7. 适用场景"></a>7. 适用场景</h2><p>JPA (以 Hibernate 为代表实现) 和 MyBatis 是 Java 持久化领域的两大主流框架，它们各自有明确的设计哲学和优势，因此适用于不同的项目场景。选择哪一个框架，通常取决于项目的业务复杂度、团队技能、对性能的要求以及对开发效率的权衡。</p>
<h3 id="JPA-Hibernate-的核心优势在于："><a href="#JPA-Hibernate-的核心优势在于：" class="headerlink" title="JPA &amp; Hibernate 的核心优势在于："></a>JPA &amp; Hibernate 的核心优势在于：</h3><ul>
<li><strong>高度的领域模型驱动</strong>: 完全面向对象，让开发者更专注于业务模型而非数据库细节。</li>
<li><strong>开发效率极高</strong>: Spring Data JPA 进一步将开发效率推向极致。</li>
<li><strong>数据库无关性</strong>: 优秀的跨数据库移植能力。</li>
<li><strong>强大的生态</strong>: 与 Spring 生态无缝集成，拥有丰富的社区支持和解决方案。</li>
</ul>
<p>基于以上优势，JPA &amp; Hibernate 特别适用于以下场景：</p>
<h4 id="1-新项目与快速原型开发"><a href="#1-新项目与快速原型开发" class="headerlink" title="1. 新项目与快速原型开发"></a>1. 新项目与快速原型开发</h4><p>对于从零开始的新项目，特别是初创公司或需要快速验证市场想法 (MVP) 的产品，JPA 是绝佳选择。</p>
<ul>
<li><strong>敏捷开发</strong>: <code>JpaRepository</code> 和方法命名查询可以让你在几分钟内就搭建好一套功能完整的 CRUD API，无需编写任何 SQL 或 XML。</li>
<li><strong>关注业务</strong>: 开发者可以将全部精力投入到业务领域模型的设计上，<code>ddl-auto</code> 功能还能自动根据实体类生成或更新数据库表，极大地加快了开发迭代速度。</li>
</ul>
<h4 id="2-CRUD-密集型的业务系统"><a href="#2-CRUD-密集型的业务系统" class="headerlink" title="2. CRUD 密集型的业务系统"></a>2. CRUD 密集型的业务系统</h4><p>大多数企业级应用，如 OA、CRM、ERP、电商后台管理系统等，其核心功能都围绕着大量的增删改查操作。</p>
<ul>
<li><strong>标准化与规范化</strong>: JPA 对这类操作提供了最优雅、最简洁的解决方案。整个数据访问层代码非常统一、干净。</li>
<li><strong>维护性高</strong>: 面向对象的查询（如方法命名查询、JPQL）比散落在各处的 SQL 语句更容易理解和维护。当业务需求变更导致实体属性增减时，重构也更加方便。</li>
</ul>
<h4 id="3-需要支持多种数据库或未来可能更换数据库的项目"><a href="#3-需要支持多种数据库或未来可能更换数据库的项目" class="headerlink" title="3. 需要支持多种数据库或未来可能更换数据库的项目"></a>3. 需要支持多种数据库或未来可能更换数据库的项目</h4><p>如果项目需要同时支持多种数据库（如 MySQL 和 Oracle），或者预见到未来有更换数据库的可能性，JPA 的数据库无关性是其杀手级特性。</p>
<ul>
<li><strong>无缝切换</strong>: 只要代码是面向 JPA 规范编写的（使用 JPQL 而非原生 SQL），理论上只需更改配置文件中的数据库方言 (<code>dialect</code>) 和驱动，就能平滑迁移到新的数据库平台，无需修改任何业务代码。</li>
<li><strong>场景示例</strong>: 需要部署到不同客户环境下的商业软件产品，这些客户可能使用不同的数据库。</li>
</ul>
<h4 id="4-领域驱动设计-DDD-实践"><a href="#4-领域驱动设计-DDD-实践" class="headerlink" title="4. 领域驱动设计 (DDD) 实践"></a>4. 领域驱动设计 (DDD) 实践</h4><p>JPA&#x2F;Hibernate 的设计哲学与领域驱动设计 (DDD) 的思想高度契合。</p>
<ul>
<li><strong>富领域模型</strong>: JPA 的实体 (Entity) 不仅仅是数据的载体，它们可以包含业务逻辑，成为真正的“富领域对象”。实体的生命周期、关联关系、懒加载等特性，都为实现复杂的领域模型提供了强大的技术支撑。</li>
<li><strong>聚合根 (Aggregate Root)</strong>: <code>JpaRepository</code> 的设计天然地鼓励开发者为每个聚合根创建一个 Repository，这与 DDD 的实践不谋而合。级联操作 (<code>cascade</code>) 也方便地实现了对聚合内部实体的一致性管理。</li>
</ul>
<h4 id="5-团队成员对-SQL-不够精通或希望屏蔽数据库细节"><a href="#5-团队成员对-SQL-不够精通或希望屏蔽数据库细节" class="headerlink" title="5. 团队成员对 SQL 不够精通或希望屏蔽数据库细节"></a>5. 团队成员对 SQL 不够精通或希望屏蔽数据库细节</h4><p>对于一个团队，如果大部分成员是 Java 开发背景，对复杂的 SQL 优化经验不足，或者希望将团队的关注点保持在 Java 业务逻辑层面，JPA 是一个很好的选择。</p>
<ul>
<li><strong>降低心智负担</strong>: 开发者无需过多关心底层 SQL 的实现细节，JPA&#x2F;Hibernate 会在大多数情况下生成正确且性能良好的 SQL。</li>
<li><strong>统一技术栈</strong>: 整个团队可以使用统一的、面向对象的方式进行数据访问，减少了因个人 SQL 水平差异带来的代码质量波动。</li>
</ul>
<hr>
<hr>
<h1 id="五、ORM-进阶与最佳实践"><a href="#五、ORM-进阶与最佳实践" class="headerlink" title="五、ORM 进阶与最佳实践"></a>五、ORM 进阶与最佳实践</h1><h2 id="1-N-1-查询问题"><a href="#1-N-1-查询问题" class="headerlink" title="1. N+1 查询问题"></a>1. N+1 查询问题</h2><h3 id="1-1-MyBatis-与-MyBatis-Plus-解决方案"><a href="#1-1-MyBatis-与-MyBatis-Plus-解决方案" class="headerlink" title="1.1 MyBatis 与 MyBatis-Plus 解决方案"></a>1.1 MyBatis 与 MyBatis-Plus 解决方案</h3><h4 id="1-1-1-在-MyBatis-中如何产生-N-1-问题"><a href="#1-1-1-在-MyBatis-中如何产生-N-1-问题" class="headerlink" title="1.1.1 在 MyBatis 中如何产生 N+1 问题"></a>1.1.1 在 MyBatis 中如何产生 N+1 问题</h4><p>N+1 问题通常在使用嵌套结果映射 (<code>&lt;association&gt;</code> 或 <code>&lt;collection&gt;</code>) 并通过<strong>分步查询 (Nested Selects)</strong> 时产生。</p>
<p><strong>问题示例 <code>CustomerMapper.xml</code></strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 查询所有客户 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAllCustomers&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;CustomerWithOrdersMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM t_customer</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2. 根据客户ID查询其订单 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findOrdersByCustomerId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.Order&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM t_order WHERE customer_id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  这个 ResultMap 会导致 N+1 问题。</span></span><br><span class="line"><span class="comment">  它首先执行 findAllCustomers (1次查询)，</span></span><br><span class="line"><span class="comment">  然后在映射 orders 集合时，会为每个 customer 对象调用一次 findOrdersByCustomerId (N次查询)。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;CustomerWithOrdersMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.Customer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- collection 标签的 select 属性触发了分步查询 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.example.Order&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">select</span>=<span class="string">&quot;findOrdersByCustomerId&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-1-2-MyBatis-解决方案"><a href="#1-1-2-MyBatis-解决方案" class="headerlink" title="1.1.2 MyBatis 解决方案"></a>1.1.2 MyBatis 解决方案</h4><p>MyBatis 提供了两种核心方案来解决 N+1 问题。</p>
<h5 id="方案一：连接查询-Join-Query"><a href="#方案一：连接查询-Join-Query" class="headerlink" title="方案一：连接查询 (Join Query)"></a>方案一：连接查询 (Join Query)</h5><p><strong>核心思想</strong>：通过在一次 SQL 查询中使用 <code>JOIN</code>，将主实体和关联的子实体数据一次性全部查询出来。</p>
<p><strong>实现方式</strong>：修改 <code>ResultMap</code>，使其能够处理 <code>JOIN</code> 后的扁平化结果集。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAllCustomersWithOrders&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;CustomerWithOrdersJoinMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT </span><br><span class="line">        c.id as customer_id, </span><br><span class="line">        c.name as customer_name,</span><br><span class="line">        o.id as order_id,</span><br><span class="line">        o.order_number</span><br><span class="line">    FROM </span><br><span class="line">        t_customer c</span><br><span class="line">    LEFT JOIN </span><br><span class="line">        t_order o ON c.id = o.customer_id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;CustomerWithOrdersJoinMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.Customer&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 映射 Customer 的主键和属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;customer_name&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 映射关联的 Order 集合 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ofType 指定集合中元素的类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.example.Order&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 映射 Order 的主键和属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;orderNumber&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_number&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MyBatis 会智能地将返回的多行结果（其中客户信息是重复的）聚合成一个 <code>Customer</code> 对象列表，每个 <code>Customer</code> 对象包含其对应的 <code>Order</code> 列表。</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>一次数据库交互</strong>：性能最高，网络开销最小。</li>
<li>逻辑简单直观。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>数据冗余</strong>：如果一个客户有10个订单，那么这个客户的信息会在结果集中重复10次，增加了数据传输量。</li>
<li><strong>复杂分页问题</strong>：当对主实体（如 <code>Customer</code>）进行分页时，由于 <code>JOIN</code> 导致结果集膨胀，直接在 SQL 中使用 <code>LIMIT</code> 会导致分页结果不准确。这通常会导致“内存分页”，即查询出所有数据后再在内存中进行分页，有内存溢出的风险。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="方案二：分步查询-延迟加载-Nested-Selects-Lazy-Loading"><a href="#方案二：分步查询-延迟加载-Nested-Selects-Lazy-Loading" class="headerlink" title="方案二：分步查询 + 延迟加载 (Nested Selects + Lazy Loading)"></a>方案二：分步查询 + 延迟加载 (Nested Selects + Lazy Loading)</h5><p><strong>核心思想</strong>：仍然执行两次查询，但 MyBatis 会<strong>智能地将 N 次子查询合并为一次</strong>。这被称为**“N+1 优化”**。</p>
<p><strong>实现方式</strong>：</p>
<ol>
<li><p><strong>开启延迟加载</strong>：在 <code>mybatis-config.xml</code> 或 Spring Boot 的 <code>application.yml</code> 中开启延迟加载。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yml</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">lazy-loading-enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># aggressive-lazy-loading: false (默认为false，按需加载)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用分步查询的 <code>ResultMap</code></strong> (与问题示例中的 <code>ResultMap</code> 相同)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;CustomerWithOrdersMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.Customer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.example.Order&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">select</span>=<span class="string">&quot;findOrdersByCustomerId&quot;</span> <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>工作原理</strong>：</p>
<ol>
<li>MyBatis 首先执行 <code>findAllCustomers</code>，返回 <code>Customer</code> 列表。但由于开启了延迟加载，<code>orders</code> 属性此时是一个代理对象，并未填充数据。</li>
<li>当你<strong>第一次</strong>访问某个 <code>customer.getOrders()</code> 时，MyBatis 不会立即执行查询。</li>
<li>它会<strong>收集</strong>所有已加载的 <code>Customer</code> 列表中的主键 (<code>id</code>)。</li>
<li>然后，它会执行<strong>一次</strong> <code>findOrdersByCustomerId</code> 查询，并使用 <code>IN</code> 子句将所有收集到的 <code>id</code> 传入。<br><code>SELECT * FROM t_order WHERE customer_id IN (1, 2, 3, ...)</code></li>
<li>最后，将查询到的所有 <code>Order</code> 分配给对应的 <code>Customer</code> 对象。</li>
</ol>
<p>这样，总的查询次数从 <strong>1+N</strong> 变成了 <strong>1+1</strong>，极大地提升了性能。</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>SQL 语句清晰</strong>，解耦度高。</li>
<li><strong>完美支持分页</strong>：对主实体分页时，不会有任何问题。</li>
<li><strong>按需加载</strong>：如果从不访问 <code>orders</code> 属性，那么第二次查询永远不会被触发。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>需要执行两次数据库查询。</li>
<li>需要额外配置。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-3-MyBatis-Plus-解决方案"><a href="#1-1-3-MyBatis-Plus-解决方案" class="headerlink" title="1.1.3 MyBatis-Plus 解决方案"></a>1.1.3 MyBatis-Plus 解决方案</h4><p>MyBatis-Plus (MP) 底层就是 MyBatis，因此上述两种解决方案<strong>完全适用</strong>。但由于 MP 鼓励使用 Wrapper 进行单表操作，对于多表关联查询，通常的做法是回归 MyBatis 的本质。</p>
<ol>
<li><p><strong>对于连接查询 (方案一)</strong>:</p>
<ul>
<li>MP 的 <code>BaseMapper</code> 不直接支持多表 <code>JOIN</code> 查询。</li>
<li><strong>标准做法</strong>：在 <code>Mapper</code> 接口中自定义一个方法，然后在对应的 XML 文件中编写 <code>JOIN</code> 查询的 SQL 和 <code>ResultMap</code>，这与原生 MyBatis 的方案一<strong>完全一致</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CustomerMapper.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Customer&gt; &#123;</span><br><span class="line">    <span class="comment">// 自定义方法，并使用 IPage 支持分页</span></span><br><span class="line">    IPage&lt;Customer&gt; <span class="title function_">selectCustomerWithOrders</span><span class="params">(IPage&lt;Customer&gt; page)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>CustomerMapper.xml</code> 中实现上述 <code>selectCustomerWithOrders</code> 方法和对应的 <code>ResultMap</code>。</p>
</li>
<li><p><strong>对于分步查询 (方案二)</strong>:</p>
<ul>
<li>同样，需要在 XML 文件中定义好分步查询的 <code>ResultMap</code>。</li>
<li>然后，你可以定义一个自定义的 Mapper 方法来使用这个 <code>ResultMap</code>，或者通过 Wrapper 查询时<strong>动态指定</strong>要使用的 <code>ResultMap</code> (需要额外封装，不常用)。</li>
<li>最直接的方式还是<strong>自定义 Mapper 方法 + XML</strong>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-2-JPA-Hibernate-解决方案"><a href="#1-2-JPA-Hibernate-解决方案" class="headerlink" title="1.2 JPA&#x2F;Hibernate 解决方案"></a>1.2 JPA&#x2F;Hibernate 解决方案</h3><p>在 JPA&#x2F;Hibernate 中，N+1 问题通常由于<strong>不恰当的抓取策略 (Fetch Strategy)</strong> 和 <strong>不合理的查询方式</strong> 导致。Hibernate 作为其实现，提供了多种高效的解决方案来应对这一问题。</p>
<h4 id="1-2-1-在-JPA-Hibernate-中如何产生-N-1-问题"><a href="#1-2-1-在-JPA-Hibernate-中如何产生-N-1-问题" class="headerlink" title="1.2.1 在 JPA&#x2F;Hibernate 中如何产生 N+1 问题"></a>1.2.1 在 JPA&#x2F;Hibernate 中如何产生 N+1 问题</h4><p>N+1 问题主要发生在加载一个实体及其关联集合时。</p>
<p><strong>典型场景</strong>：查询所有客户 (<code>Customer</code>) 及其各自的订单 (<code>Order</code>) 列表。</p>
<p><strong>实体定义</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = &quot;customer&quot;, fetch = FetchType.LAZY)</span> <span class="comment">// LAZY 是默认且推荐的</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.EAGER)</span> <span class="comment">// EAGER 是 ...ToOne 的默认策略</span></span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 第1次查询: 执行查询获取所有客户</span></span><br><span class="line">List&lt;Customer&gt; customers = customerRepository.findAll(); </span><br><span class="line"><span class="comment">// SQL: SELECT * FROM t_customer;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 循环遍历客户，并访问其订单集合</span></span><br><span class="line"><span class="keyword">for</span> (Customer customer : customers) &#123;</span><br><span class="line">    <span class="comment">// 当首次访问 customer.getOrders() 时，由于是懒加载(LAZY)...</span></span><br><span class="line">    <span class="comment">// Hibernate 会为【每个】customer 发起一次新的查询来获取其订单</span></span><br><span class="line">    <span class="comment">// 这将触发 N 次查询！</span></span><br><span class="line">    Set&lt;Order&gt; orders = customer.getOrders(); </span><br><span class="line">    <span class="comment">// SQL: SELECT * FROM t_order WHERE customer_id = ? (此句会执行 N 次)</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Customer: &quot;</span> + customer.getName() + <span class="string">&quot;, Orders count: &quot;</span> + orders.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：即使关联是 <code>EAGER</code>（饥饿加载），如果查询方式不当（如使用 <code>findAll()</code>），Hibernate 默认也可能采用分步查询的方式，从而同样引发 N+1 问题。</p>
<hr>
<h4 id="1-2-2-JPA-Hibernate-解决方案"><a href="#1-2-2-JPA-Hibernate-解决方案" class="headerlink" title="1.2.2 JPA&#x2F;Hibernate 解决方案"></a>1.2.2 JPA&#x2F;Hibernate 解决方案</h4><p>JPA&#x2F;Hibernate 提供了多种解决方案，核心思想都是通过<strong>一次查询</strong>将所需的主实体和关联实体都加载到持久化上下文中。</p>
<h5 id="方案一：JPQL-JOIN-FETCH-最常用，最推荐"><a href="#方案一：JPQL-JOIN-FETCH-最常用，最推荐" class="headerlink" title="方案一：JPQL JOIN FETCH (最常用，最推荐)"></a><strong>方案一：JPQL <code>JOIN FETCH</code> (最常用，最推荐)</strong></h5><p><strong>核心思想</strong>：在 JPQL 查询语句中使用 <code>JOIN FETCH</code> 关键字，明确告诉 Hibernate，在执行查询时，不仅要获取主实体，还要<strong>立即、一次性地</strong>将其指定的关联实体（或集合）的数据<strong>一并抓取</strong>出来。</p>
<p><strong>实现方式</strong>: 在 <code>Repository</code> 接口中自定义一个使用 <code>JOIN FETCH</code> 的查询方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Customer, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT DISTINCT c FROM Customer c LEFT JOIN FETCH c.orders&quot;)</span></span><br><span class="line">    List&lt;Customer&gt; <span class="title function_">findAllWithOrders</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作原理</strong>:<br>Hibernate 会将上述 JPQL 转换为一条<strong>包含 <code>LEFT JOIN</code> 的 SQL 语句</strong>：<br><code>SELECT ... FROM t_customer c LEFT JOIN t_order o ON c.id = o.customer_id;</code></p>
<p>它会一次性将所有客户及其所有订单都查询出来，并在内存中智能地组装成 <code>Customer</code> 和 <code>Order</code> 对象。整个过程只有<strong>一次数据库交互</strong>。</p>
<ul>
<li><strong><code>DISTINCT</code> 关键字</strong>：由于 <code>LEFT JOIN</code> 会导致主实体（<code>Customer</code>）因其关联的多个子实体（<code>Order</code>）而重复出现，使用 <code>DISTINCT</code> 可以确保返回的 <code>List&lt;Customer&gt;</code> 中不包含重复的 <code>Customer</code> 对象实例。</li>
<li><strong>优点</strong>:<ul>
<li><strong>性能极高</strong>：将 N+1 次查询合并为 1 次。</li>
<li><strong>代码清晰</strong>：查询意图明确地体现在 JPQL 中。</li>
<li><strong>通用性强</strong>：是解决 N+1 问题的标准和首选方案。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>分页问题</strong>：当对包含 <code>JOIN FETCH</code> 的集合关联进行分页时，Hibernate 会发出警告，因为它无法在数据库层面进行准确的分页。它会<strong>将所有数据加载到内存中再进行分页</strong>，这在数据量大时可能导致内存溢出 (OOM)。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="方案二：实体图-EntityGraph"><a href="#方案二：实体图-EntityGraph" class="headerlink" title="方案二：实体图 (@EntityGraph)"></a><strong>方案二：实体图 (<code>@EntityGraph</code>)</strong></h5><p><strong>核心思想</strong>：<code>@EntityGraph</code> 是 JPA 2.1 引入的一个更强大、更灵活的特性。它允许你<strong>动态地、声明式地</strong>定义一个“抓取计划”，指定在执行某个查询时需要<strong>饥饿加载</strong>哪些关联属性，而无需修改 JPQL 语句。</p>
<p><strong>实现方式</strong>:</p>
<ol>
<li>在实体类上使用 <code>@NamedEntityGraph</code> 定义一个可复用的实体图。</li>
<li>在 <code>Repository</code> 方法上使用 <code>@EntityGraph</code> 注解来应用这个图。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Customer.java</span></span><br><span class="line"><span class="meta">@NamedEntityGraph(</span></span><br><span class="line"><span class="meta">    name = &quot;customer-with-orders-graph&quot;,</span></span><br><span class="line"><span class="meta">    attributeNodes = &#123;</span></span><br><span class="line"><span class="meta">        @NamedAttributeNode(&quot;orders&quot;) // 指定要一同抓取的属性名</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CustomerRepository.java</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Customer, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在执行 findAll() 时，应用名为 &quot;customer-with-orders-graph&quot; 的实体图</span></span><br><span class="line">    <span class="meta">@EntityGraph(value = &quot;customer-with-orders-graph&quot;, type = EntityGraphType.FETCH)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    List&lt;Customer&gt; <span class="title function_">findAll</span><span class="params">()</span>; <span class="comment">// 可以覆盖 JpaRepository 的原生方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以直接在注解中定义 ad-hoc 实体图</span></span><br><span class="line">    <span class="meta">@EntityGraph(attributePaths = &#123;&quot;orders&quot;&#125;)</span></span><br><span class="line">    List&lt;Customer&gt; <span class="title function_">getAllCustomersWithTheirOrders</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作原理</strong>: 与 <code>JOIN FETCH</code> 类似，Hibernate 看到 <code>@EntityGraph</code> 注解后，会自动生成 <code>LEFT JOIN</code> SQL 来一次性加载关联数据。</p>
<ul>
<li><strong><code>type</code> 属性</strong>:<ul>
<li><code>EntityGraphType.FETCH</code>: 实体图中指定的属性会被饥饿加载，未指定的则遵循其默认的抓取策略。<strong>这是我们想要的模式</strong>。</li>
<li><code>EntityGraphType.LOAD</code>: 实体图中指定的属性会被饥饿加载，未指定的则会被强制设置为懒加载。</li>
</ul>
</li>
<li><strong>优点</strong>:<ul>
<li><strong>代码解耦</strong>：将抓取策略与 JPQL 查询本身分离，使得查询语句更简洁。</li>
<li><strong>可复用性</strong>：通过 <code>@NamedEntityGraph</code> 定义的图可以在多个查询中复用。</li>
<li><strong>解决了 <code>JOIN FETCH</code> 的分页问题</strong>：当 <code>@EntityGraph</code> 与分页查询（返回 <code>Page&lt;T&gt;</code>）结合使用时，Hibernate 会智能地执行<strong>两次 SQL</strong>：一次是获取主实体 ID 的分页查询，另一次是根据这些 ID 使用 <code>IN</code> 子句加载关联实体。从而避免了内存分页。这是它相对于 <code>JOIN FETCH</code> 的一大优势。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="方案三：批处理抓取-BatchSize"><a href="#方案三：批处理抓取-BatchSize" class="headerlink" title="方案三：批处理抓取 (@BatchSize)"></a><strong>方案三：批处理抓取 (<code>@BatchSize</code>)</strong></h5><p><strong>核心思想</strong>：这是一种对懒加载的优化。它不会将 N+1 次查询合并为 1 次，而是将其合并为 <strong>1 + (N &#x2F; batch_size)</strong> 次。</p>
<p><strong>实现方式</strong>: 在关联集合的注解上添加 <code>@BatchSize</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = &quot;customer&quot;, fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@BatchSize(size = 10)</span> <span class="comment">// 设置批处理大小</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作原理</strong>:</p>
<ol>
<li>执行 <code>findAll()</code> 查询，获取 N 个 <code>Customer</code> (1次查询)。</li>
<li>当第一次访问某个 <code>customer.getOrders()</code> 时，Hibernate 不会只查询这一个客户的订单。</li>
<li>它会一次性地<strong>预加载接下来 <code>size</code> (这里是10) 个</strong> <code>Customer</code> 代理对象的 <code>orders</code> 集合。</li>
<li>它会生成一条带有 <code>IN</code> 子句的 SQL，一次性查询 10 个客户的订单：<br><code>SELECT * FROM t_order WHERE customer_id IN (?, ?, ..., ?)</code> (10个参数)</li>
<li>如果 N 是 35，那么总查询次数将是 1 + (10) + (10) + (10) + (5) &#x3D; 1 + 4 &#x3D; 5 次，而不是 1 + 35 &#x3D; 36 次。</li>
</ol>
<ul>
<li><strong>优点</strong>:<ul>
<li><strong>配置简单</strong>：只需一个注解即可。</li>
<li><strong>懒加载优化</strong>：对懒加载场景的性能提升非常有效，且不会像 <code>JOIN FETCH</code> 那样一次性加载所有数据。</li>
<li><strong>对分页友好</strong>。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li>仍然需要多次数据库交互，不如 <code>JOIN FETCH</code> 和 <code>@EntityGraph</code> 直接。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-缓存机制"><a href="#2-缓存机制" class="headerlink" title="2. 缓存机制"></a>2. 缓存机制</h2><h3 id="2-1-一级缓存"><a href="#2-1-一级缓存" class="headerlink" title="2.1 一级缓存"></a>2.1 一级缓存</h3><h4 id="2-1-1-定义与核心特性"><a href="#2-1-1-定义与核心特性" class="headerlink" title="2.1.1 定义与核心特性"></a>2.1.1 定义与核心特性</h4><p><strong>一级缓存 (First-Level Cache)</strong> 是 ORM 框架中内置的、与<strong>会话 (Session)</strong> 或 <strong>持久化上下文 (Persistence Context)</strong> 绑定的缓存机制。它是一个无法被关闭或配置的<strong>强制性</strong>特性，是 ORM 框架实现其核心功能的基础。</p>
<p><strong>核心特性</strong>:</p>
<ol>
<li><strong>会话级别 (Session-Level)</strong>:<ul>
<li>一级缓存的生命周期与 <code>SqlSession</code> (MyBatis) 或 <code>EntityManager</code>&#x2F;<code>Session</code> (JPA&#x2F;Hibernate) 的生命周期<strong>完全绑定</strong>。</li>
<li>当会话被创建时，一级缓存随之开启。</li>
<li>当会话被关闭 (<code>close()</code>) 时，一级缓存随之被销毁，其中的所有数据都会被清空。<br>.</li>
</ul>
</li>
<li><strong>线程不共享</strong>:<ul>
<li>由于 <code>SqlSession</code> 和 <code>EntityManager</code> 都是<strong>线程不安全</strong>的，因此一级缓存也是<strong>线程隔离</strong>的。</li>
<li>每个线程（通常对应一个业务请求）都有自己独立的会话和一级缓存，不同线程之间的一级缓存互不影响、互不可见。</li>
</ul>
</li>
<li><strong>身份映射 (Identity Map)</strong>:<ul>
<li>这是ORM框架实现<strong>对象一致性</strong>的关键。</li>
<li>在一级缓存内部，通常是一个 <code>Map&lt;Key, Object&gt;</code> 结构，其中 <code>Key</code> 由实体的<strong>类名</strong>和<strong>主键</strong>组合而成，<code>Value</code> 则是从数据库加载的<strong>实体对象实例</strong>。</li>
<li>这个机制保证了在<strong>同一个会话</strong>中，对于<strong>同一个主键</strong>的<strong>同一个实体类</strong>，无论查询多少次，返回的永远是<strong>同一个 Java 对象实例</strong> (<code>objectA == objectB</code> 为 <code>true</code>)。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-1-2-MyBatis-中的一级缓存"><a href="#2-1-2-MyBatis-中的一级缓存" class="headerlink" title="2.1.2 MyBatis 中的一级缓存"></a>2.1.2 MyBatis 中的一级缓存</h4><p>MyBatis 的一级缓存是默认开启的，且由 <code>SqlSession</code> 直接管理。</p>
<p><strong>工作流程</strong>:</p>
<ol>
<li>当一个 <code>SqlSession</code> 开启后，MyBatis 会为其创建一个 <code>Executor</code>（执行器），<code>Executor</code> 内部持有一个 <code>PerpetualCache</code> 实例，这就是一级缓存。</li>
<li>当通过 <code>SqlSession</code> 执行一次<strong>查询</strong>操作时：<br>a. MyBatis 会根据查询语句、参数、分页信息等生成一个唯一的 <code>CacheKey</code>。<br>b. 首先使用这个 <code>CacheKey</code> 在一级缓存中查找结果。<br>c. <strong>如果命中</strong>，则直接从缓存中返回结果，<strong>不再查询数据库</strong>。<br>d. <strong>如果未命中</strong>，则执行数据库查询，获取结果。<br>e. 将查询到的结果存入一级缓存中（以 <code>CacheKey</code> 为键）。<br>f. 将结果返回给调用者。</li>
</ol>
<p><strong>缓存失效的场景</strong>:</p>
<p>MyBatis 的一级缓存设计得非常“智能”，会在可能导致数据不一致的情况下自动失效：</p>
<ol>
<li><strong>执行 CUD 操作</strong>:<ul>
<li>当在同一个 <code>SqlSession</code> 中执行了 <code>insert</code>, <code>update</code>, <code>delete</code> 操作时，MyBatis 会认为数据库中的数据可能已经发生了变化，为了防止脏读，它会<strong>清空 (clear)</strong> 该 <code>SqlSession</code> 的整个一级缓存。</li>
</ul>
</li>
<li><strong>手动清空缓存</strong>:<ul>
<li>可以调用 <code>sqlSession.clearCache()</code> 方法来手动清空一级缓存。</li>
</ul>
</li>
<li><strong>关闭 <code>SqlSession</code></strong>:<ul>
<li><code>sqlSession.close()</code> 会销毁会话，一级缓存自然也随之销毁。</li>
</ul>
</li>
<li><strong>XML 中设置 <code>flushCache=&quot;true&quot;</code></strong>:<ul>
<li>在 <code>&lt;select&gt;</code>, <code>&lt;insert&gt;</code>, <code>&lt;update&gt;</code>, <code>&lt;delete&gt;</code> 标签上设置 <code>flushCache=&quot;true&quot;</code>，会在执行该语句后强制清空一级缓存。默认情况下，<code>select</code> 为 <code>false</code>，CUD 操作为 <code>true</code>。</li>
</ul>
</li>
</ol>
<p><strong>示例代码 (MyBatis)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次查询，会从数据库加载</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;User 1: &quot;</span> + user1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次查询相同的用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;User 2: &quot;</span> + user2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于一级缓存的存在，第二次查询不会执行 SQL</span></span><br><span class="line">    <span class="comment">// 并且 user1 和 user2 是同一个 Java 对象实例</span></span><br><span class="line">    System.out.println(<span class="string">&quot;user1 == user2 ? &quot;</span> + (user1 == user2)); <span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一次更新操作</span></span><br><span class="line">    user1.setAge(<span class="number">30</span>);</span><br><span class="line">    userMapper.updateUser(user1);</span><br><span class="line">    session.commit(); <span class="comment">// CUD 操作会清空一级缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三次查询</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;User 3: &quot;</span> + user3);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于缓存已被清空，这次查询会重新从数据库加载</span></span><br><span class="line">    <span class="comment">// 因此 user1 和 user3 是不同的 Java 对象实例</span></span><br><span class="line">    System.out.println(<span class="string">&quot;user1 == user3 ? &quot;</span> + (user1 == user3)); <span class="comment">// 输出 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-3-JPA-Hibernate-中的一级缓存"><a href="#2-1-3-JPA-Hibernate-中的一级缓存" class="headerlink" title="2.1.3 JPA&#x2F;Hibernate 中的一级缓存"></a>2.1.3 JPA&#x2F;Hibernate 中的一级缓存</h4><p>JPA&#x2F;Hibernate 的一级缓存就是其核心概念——<strong>持久化上下文 (Persistence Context)</strong>。</p>
<p><strong>工作流程与 MyBatis 类似但更强大</strong>:</p>
<ol>
<li><strong>缓存命中</strong>: 当调用 <code>entityManager.find(User.class, 1L)</code> 时，Hibernate 会首先在持久化上下文中根据 <code>User</code> 类和主键 <code>1L</code> 查找实体。如果找到，直接返回，不访问数据库。</li>
<li><strong>自动脏检查 (Dirty Checking)</strong>: Hibernate 一级缓存的强大之处在于它不仅仅是简单的读缓存。它会保存实体加载时的<strong>快照 (Snapshot)</strong>。在事务提交时，Hibernate 会将当前托管态实体的状态与快照进行对比，如果发现不一致（即“脏”了），就会<strong>自动生成 <code>UPDATE</code> 语句</strong>并同步到数据库。</li>
<li><strong>事务回写 (Transactional Write-Behind)</strong>: 对实体的 <code>persist</code>, <code>merge</code>, <code>remove</code> 操作并不会立即执行 SQL，而是将这些操作缓存在持久化上下文中。直到事务提交或上下文被 <code>flush</code> 时，Hibernate 才会将这些操作以最优化的顺序（例如，先 <code>INSERT</code>，再 <code>UPDATE</code>）一次性发送到数据库。</li>
</ol>
<p><strong>缓存失效的场景</strong>:</p>
<ol>
<li><strong>关闭 <code>EntityManager</code></strong>: <code>entityManager.close()</code> 会销毁持久化上下文。</li>
<li><strong>事务提交或回滚</strong>: 在 Spring 环境下，一个事务结束后，与之关联的 <code>EntityManager</code> 通常也会被关闭。</li>
<li><strong>手动清除</strong>:<ul>
<li><code>entityManager.clear()</code>: <strong>分离 (detach)</strong> 持久化上下文中<strong>所有</strong>的实体。</li>
<li><code>entityManager.detach(entity)</code>: 分离<strong>指定</strong>的实体。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-1-4-一级缓存的意义"><a href="#2-1-4-一级缓存的意义" class="headerlink" title="2.1.4 一级缓存的意义"></a>2.1.4 一级缓存的意义</h4><ul>
<li><strong>保证会话内的数据一致性</strong>: 通过身份映射机制，确保对同一数据的操作都作用于同一个 Java 对象实例，避免了数据冲突和混乱。</li>
<li><strong>减少数据库交互</strong>: 在同一个事务或请求中，对于重复的读取操作，可以显著减少对数据库的访问次数，提升性能。</li>
<li><strong>ORM 核心功能的基础</strong>: 是实现自动脏检查、事务回写等高级特性的基础。没有一级缓存，Hibernate 的许多“魔法”将不复存在。</li>
</ul>
<hr>
<h3 id="2-2-二级缓存"><a href="#2-2-二级缓存" class="headerlink" title="2.2 二级缓存"></a>2.2 二级缓存</h3><h4 id="2-2-1-定义与核心特性"><a href="#2-2-1-定义与核心特性" class="headerlink" title="2.2.1 定义与核心特性"></a>2.2.1 定义与核心特性</h4><p><strong>二级缓存 (Second-Level Cache)</strong> 是一种<strong>跨会话 (Session) &#x2F; 跨事务</strong>的全局缓存机制。与一级缓存不同，二级缓存是可选的、可配置的，并且需要显式地开启和配置。</p>
<p><strong>核心特性</strong>:</p>
<ol>
<li><strong>应用级别 (Application-Level)</strong>:<ul>
<li>二级缓存的生命周期与<strong>应用程序</strong>或 <code>SessionFactory</code> (MyBatis 的 <code>SqlSessionFactory</code> &#x2F; Hibernate 的 <code>SessionFactory</code>) 的生命周期绑定。</li>
<li>只要应用程序在运行，二级缓存就存在，并且可以被应用程序中<strong>所有</strong>的会话&#x2F;线程共享。</li>
</ul>
</li>
<li><strong>线程共享</strong>:<ul>
<li>二级缓存是<strong>线程安全</strong>的。多个用户、多个请求、多个线程都可以访问和共享同一份缓存数据。</li>
</ul>
</li>
<li><strong>数据共享而非对象共享</strong>:<ul>
<li>这是二级缓存与一级缓存的一个关键区别。为了保证线程安全和避免数据被意外修改，从二级缓存中读取数据时，ORM 框架返回的通常是<strong>原始缓存对象的序列化副本 (Serialized Copy)</strong>，而不是缓存中对象的直接引用。</li>
<li>这意味着，不同会话从二级缓存中获取的同一个主键的实体，会是<strong>不同的 Java 对象实例</strong> (<code>objectA == objectB</code> 为 <code>false</code>)，尽管它们的数据内容是相同的。</li>
</ul>
</li>
<li><strong>可插拔 (Pluggable)</strong>:<ul>
<li>ORM 框架本身通常只提供二级缓存的<strong>接口规范</strong>，而具体的缓存实现则由第三方的缓存框架来提供，例如 <strong>EhCache</strong>, <strong>Redis</strong>, <strong>Caffeine</strong> 等。这使得开发者可以根据项目需求选择最合适的缓存产品。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-2-2-MyBatis-中的二级缓存"><a href="#2-2-2-MyBatis-中的二级缓存" class="headerlink" title="2.2.2 MyBatis 中的二级缓存"></a>2.2.2 MyBatis 中的二级缓存</h4><p>MyBatis 的二级缓存是基于 <strong><code>namespace</code> (即 Mapper 接口)</strong> 的。每个 <code>Mapper.xml</code> 文件可以拥有自己独立的二级缓存实例。</p>
<h5 id="1-开启步骤"><a href="#1-开启步骤" class="headerlink" title="1. 开启步骤:"></a>1. 开启步骤:</h5><ol>
<li><p><strong>全局开启</strong>: 在 <code>mybatis-config.xml</code> 或 <code>application.yml</code> 中全局开启二级缓存。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yml</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">cache-enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Mapper 级别开启</strong>: 在需要开启二级缓存的 <code>Mapper.xml</code> 文件中，添加 <code>&lt;cache/&gt;</code> 标签。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- UserMapper.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启该 namespace 的二级缓存 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- ... select, insert, etc. ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实体类实现 <code>Serializable</code> 接口</strong>: 由于二级缓存可能涉及序列化（例如存入 Redis 或跨 JVM 共享），所有需要被缓存的实体类都必须实现 <code>java.io.Serializable</code> 接口。</p>
</li>
<li><p><strong>语句级别控制</strong>: 在单个 <code>&lt;select&gt;</code> 标签上，可以通过 <code>useCache=&quot;true&quot;</code> (默认) 或 <code>useCache=&quot;false&quot;</code> 来控制该查询是否使用二级缓存。</p>
</li>
</ol>
<h5 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2. 工作流程:"></a>2. 工作流程:</h5><ol>
<li>当一个会话 <code>session1</code> 执行查询时，如果一级缓存未命中，它会查询数据库。</li>
<li>查询结果返回后，不仅会存入 <code>session1</code> 的一级缓存，还会被<strong>提交 (commit)</strong> 到 <code>UserMapper</code> 的二级缓存中。<strong>注意：只有当会话被 <code>close()</code> 或 <code>commit()</code> 时，一级缓存中的数据才会被刷新到二级缓存。</strong></li>
<li>之后，另一个会话 <code>session2</code> 执行<strong>完全相同</strong>的查询（<code>CacheKey</code> 相同）。</li>
<li><code>session2</code> 首先检查自己的一级缓存，未命中。</li>
<li>然后，它会去 <code>UserMapper</code> 的二级缓存中查找。</li>
<li><strong>如果命中</strong>，它会从二级缓存中获取数据（的副本），存入自己的一级缓存，然后返回给调用者。<strong>整个过程 <code>session2</code> 没有访问数据库。</strong></li>
</ol>
<h5 id="3-缓存失效"><a href="#3-缓存失效" class="headerlink" title="3. 缓存失效:"></a>3. 缓存失效:</h5><p>当任何一个会话在 <code>UserMapper</code> 的 <code>namespace</code> 下执行了 <code>insert</code>, <code>update</code>, <code>delete</code> 操作并<strong>提交</strong>后，该 <code>namespace</code> 下的<strong>所有二级缓存数据都会被清空 (flush)</strong>。这种“一刀切”的策略保证了数据的最终一致性，但也可能降低缓存的命中率。</p>
<hr>
<h4 id="2-2-3-JPA-Hibernate-中的二级缓存"><a href="#2-2-3-JPA-Hibernate-中的二级缓存" class="headerlink" title="2.2.3 JPA&#x2F;Hibernate 中的二级缓存"></a>2.2.3 JPA&#x2F;Hibernate 中的二级缓存</h4><p>Hibernate 的二级缓存设计得更为精细和强大，它提供了<strong>实体级别</strong>的缓存，并支持更复杂的缓存策略。</p>
<h5 id="1-开启步骤-1"><a href="#1-开启步骤-1" class="headerlink" title="1. 开启步骤:"></a>1. 开启步骤:</h5><ol>
<li><p><strong>添加依赖</strong>: 在 <code>pom.xml</code> 中添加 Hibernate 对特定缓存产品的集成依赖，例如 <code>hibernate-jcache</code> (用于集成 JCache 标准的缓存，如 EhCache 3, Caffeine) 或 <code>hibernate-ehcache</code> (用于 EhCache 2)。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.orm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-jcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hibernate.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>全局开启</strong>: 在 <code>application.properties</code> &#x2F; <code>yml</code> 中开启二级缓存并指定缓存工厂。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启二级缓存</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.cache.use_second_level_cache</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># (可选) 开启查询缓存，用于缓存 JPQL 查询结果</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.cache.use_query_cache</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 指定 JCache (EhCache 3) 作为缓存提供商</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.cache.region.factory_class</span>=<span class="string">org.hibernate.cache.jcache.JCacheRegionFactory</span></span><br><span class="line"><span class="comment"># 指定 EhCache 的配置文件路径</span></span><br><span class="line"><span class="attr">spring.jpa.properties.javax.persistence.sharedCache.mode</span>=<span class="string">ENABLE_SELECTIVE</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.javax.cache.provider</span>=<span class="string">org.ehcache.jsr107.EhcacheCachingProvider</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.javax.cache.uri</span>=<span class="string">classpath:ehcache.xml</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实体级别开启</strong>: 在需要缓存的实体类上，使用 <code>@Cacheable</code> 和 <code>@Cache</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Cacheable</span> <span class="comment">// 标记该实体可以被缓存</span></span><br><span class="line"><span class="meta">@org</span>.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE) <span class="comment">// 指定并发访问策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="2-Hibernate-缓存并发策略-CacheConcurrencyStrategy"><a href="#2-Hibernate-缓存并发策略-CacheConcurrencyStrategy" class="headerlink" title="2. Hibernate 缓存并发策略 (CacheConcurrencyStrategy):"></a>2. Hibernate 缓存并发策略 (<code>CacheConcurrencyStrategy</code>):</h5><p>这是 Hibernate 二级缓存的核心配置，决定了如何处理并发访问和保证数据一致性。</p>
<ul>
<li><strong><code>READ_ONLY</code></strong>: 只读缓存。适用于<strong>绝对不会被修改</strong>的数据（如字典表）。性能最高。</li>
<li><strong><code>NONSTRICT_READ_WRITE</code></strong>: 非严格读写。不保证缓存与数据库的强一致性，可能会有短暂的脏读。适用于对数据一致性要求不高的场景。</li>
<li><strong><code>READ_WRITE</code></strong>: 读写缓存。通过类似“版本戳”的机制保证缓存与数据库的<strong>强一致性</strong>（可重复读级别）。这是<strong>最常用</strong>的策略。</li>
<li><strong><code>TRANSACTIONAL</code></strong>: 事务缓存。将缓存的更新操作纳入 JTA 事务管理，提供最高级别的隔离。</li>
</ul>
<h5 id="3-查询缓存-Query-Cache"><a href="#3-查询缓存-Query-Cache" class="headerlink" title="3. 查询缓存 (Query Cache)"></a>3. 查询缓存 (Query Cache)</h5><p>Hibernate 的二级缓存默认只缓存<strong>通过主键 (<code>find</code>&#x2F;<code>get</code>) 加载的实体</strong>。对于 JPQL 或 Criteria 查询返回的<strong>实体列表</strong>，默认是<strong>不缓存</strong>的。</p>
<p>要缓存查询结果，必须：</p>
<ol>
<li><p>全局开启查询缓存 (<code>use_query_cache=true</code>)。</p>
</li>
<li><p>在执行查询时，显式地设置该查询为可缓存的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生 Hibernate API</span></span><br><span class="line">query.setCacheable(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spring Data JPA (通过 @QueryHint)</span></span><br><span class="line"><span class="meta">@QueryHints(&#123;@QueryHint(name = &quot;org.hibernate.cacheable&quot;, value = &quot;true&quot;)&#125;)</span></span><br><span class="line"><span class="meta">@Query(&quot;from User u where u.age &gt; ?1&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsersByAge</span><span class="params">(<span class="type">int</span> age)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>查询缓存缓存的是<strong>查询结果集的主键列表 (ID list)</strong>，而不是实体本身。当执行查询时，Hibernate 会先从查询缓存中找到对应的主键列表，然后再去二级实体缓存中根据这些主-键获取实体数据。</p>
<hr>
<h3 id="2-3-缓存的意义、风险与配置"><a href="#2-3-缓存的意义、风险与配置" class="headerlink" title="2.3 缓存的意义、风险与配置"></a>2.3 缓存的意义、风险与配置</h3><h4 id="2-3-1-缓存的意义-Why-use-cache"><a href="#2-3-1-缓存的意义-Why-use-cache" class="headerlink" title="2.3.1 缓存的意义 (Why use cache?)"></a>2.3.1 缓存的意义 (Why use cache?)</h4><p>在应用中使用一级和二级缓存，主要出于以下几个核心目的：</p>
<ol>
<li><strong>提升性能 (Performance Improvement)</strong><ul>
<li><strong>减少数据库 I&#x2F;O</strong>: 这是最直接的意义。数据库访问通常是应用程序中最慢、资源消耗最大的操作之一，涉及网络延迟、磁盘 I&#x2F;O、SQL 解析与执行等。缓存将频繁读取的数据存储在内存中（内存的访问速度比磁盘快几个数量级），从而极大地减少了对数据库的直接访问。</li>
<li><strong>降低数据库负载</strong>: 当大量并发请求访问相同的数据时，缓存可以直接响应大部分请求，显著降低数据库服务器的压力，使其能够更从容地处理写操作和复杂的查询，从而提高整个系统的吞吐量。</li>
</ul>
</li>
<li><strong>保证数据一致性 (Data Consistency)</strong><ul>
<li>这主要体现在<strong>一级缓存</strong>中。通过其<strong>身份映射 (Identity Map)</strong> 机制，确保在同一个事务或会话中，对同一条数据的所有操作都作用于同一个 Java 对象实例。这避免了在业务逻辑处理过程中因持有不同对象副本而导致的数据状态不一致问题。</li>
</ul>
</li>
<li><strong>ORM 框架功能的基础 (Foundation for ORM Features)</strong><ul>
<li>对于像 Hibernate 这样的全自动 ORM 框架，<strong>一级缓存（持久化上下文）</strong> 是其实现<strong>自动脏检查 (Dirty Checking)</strong> 和 <strong>事务回写 (Transactional Write-Behind)</strong> 等“魔法”功能的基石。没有一级缓存，这些自动化特性将无法实现。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-3-2-缓存的风险与挑战-Risks-and-Challenges"><a href="#2-3-2-缓存的风险与挑战-Risks-and-Challenges" class="headerlink" title="2.3.2 缓存的风险与挑战 (Risks and Challenges)"></a>2.3.2 缓存的风险与挑战 (Risks and Challenges)</h4><p>引入缓存并非银弹，它在带来性能提升的同时，也引入了新的复杂性和风险：</p>
<ol>
<li><strong>数据不一致性 (Data Inconsistency)</strong><ul>
<li><strong>核心挑战</strong>: 缓存的本质是数据的副本。如何保证缓存中的数据与数据库中的主数据保持同步，是缓存系统面临的最大挑战。</li>
<li><strong>产生原因</strong>:<ul>
<li><strong>缓存更新延迟</strong>: 当数据库数据被修改后，如果缓存未能及时更新或失效，就会导致应用程序读到过期的“脏数据”。</li>
<li><strong>多节点问题</strong>: 在分布式系统中，如果多个应用实例各自拥有本地缓存（如 EhCache），当一个节点更新了数据库，其他节点的缓存可能仍然是旧的。</li>
<li><strong>绕过 ORM</strong>: 如果有其他服务或手动执行的 SQL 直接修改了数据库，ORM 框架的缓存机制将对此毫不知情，导致缓存数据过时。</li>
</ul>
</li>
</ul>
</li>
<li><strong>内存消耗 (Memory Consumption)</strong><ul>
<li>缓存是空间换时间的策略。将大量数据加载到内存中会占用宝贵的 JVM 堆空间。如果缓存的数据量过大，或者没有合适的<strong>淘汰策略 (Eviction Policy)</strong>，可能会导致频繁的 Full GC，甚至<strong>内存溢出 (OOM)</strong>。</li>
</ul>
</li>
<li><strong>增加了系统复杂性 (Increased Complexity)</strong><ul>
<li><strong>配置与维护</strong>: 需要仔细配置缓存的容量、过期时间、淘汰策略、并发策略等。</li>
<li><strong>问题排查</strong>: 当出现问题时，排查是源于业务逻辑、数据库还是缓存本身，会变得更加困难。开发者需要理解缓存的工作原理和失效机制。</li>
</ul>
</li>
<li><strong>缓存穿透、击穿和雪崩 (Advanced Cache Problems)</strong><ul>
<li><strong>穿透 (Penetration)</strong>: 查询一个<strong>绝对不存在</strong>的数据。由于缓存中没有，请求会一直穿透到数据库，如果被恶意利用，可能导致数据库崩溃。</li>
<li><strong>击穿 (Breakdown)</strong>: 一个<strong>热点数据</strong>的缓存刚好失效，在此时刻，大量并发请求同时涌入，直接打到数据库上，导致其压力瞬增。</li>
<li><strong>雪崩 (Avalanche)</strong>: 大量缓存数据在<strong>同一时刻</strong>集体失效（例如，设置了相同的过期时间），导致所有请求瞬间全部转向数据库，造成数据库宕机。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-3-3-如何合理配置与使用缓存"><a href="#2-3-3-如何合理配置与使用缓存" class="headerlink" title="2.3.3 如何合理配置与使用缓存"></a>2.3.3 如何合理配置与使用缓存</h4><p>为了最大化缓存的收益并规避其风险，应遵循以下原则：</p>
<ol>
<li><strong>明确缓存适用场景</strong>:<ul>
<li><strong>读多写少</strong>: 缓存最适用于那些<strong>读取频率远高于写入频率</strong>的数据。如果数据频繁变动，维护缓存的成本（不断地使其失效和重新加载）可能会超过其带来的收益。</li>
<li><strong>热点数据</strong>: 优先缓存那些被频繁访问的热点数据。</li>
<li><strong>对一致性要求不高的非核心数据</strong>: 对于一些可以容忍短暂数据不一致的场景（如新闻、商品分类），缓存是绝佳选择。对于金融交易等要求强一致性的核心数据，使用缓存必须极其谨慎。</li>
</ul>
</li>
<li><strong>选择合适的缓存粒度</strong>:<ul>
<li><strong>一级缓存</strong>: 默认开启，无需配置。主要用于保障事务内的数据一致性和性能。</li>
<li><strong>二级缓存</strong>: 按需开启。优先为那些<strong>稳定、不常变化的基础数据</strong>开启二级缓存，例如：<ul>
<li><strong>字典表</strong> (国家、省份、状态码等)</li>
<li><strong>权限配置</strong> (角色、权限资源等)</li>
<li><strong>商品分类</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>精细化配置</strong>:<ul>
<li><strong>设置合理的容量 (<code>max-entries</code>)</strong>: 根据可用内存和数据量估算缓存大小，避免 OOM。</li>
<li><strong>设置淘汰策略 (Eviction Policy)</strong>: 当缓存满时，如何淘汰旧数据。常用策略有：<ul>
<li><code>LRU</code> (Least Recently Used): 淘汰最久未被使用的数据。</li>
<li><code>LFU</code> (Least Frequently Used): 淘汰最不常用的数据。</li>
<li><code>FIFO</code> (First In First Out): 先进先出。</li>
</ul>
</li>
<li><strong>设置过期时间 (<code>TTL/TTI</code>)</strong>:<ul>
<li><code>TTL</code> (Time To Live): 数据存活时间。从放入缓存开始计时，到期自动失效。</li>
<li><code>TTI</code> (Time To Idle): 数据空闲时间。每次访问都会重置计时器，如果数据在指定时间内一直未被访问，则失效。</li>
</ul>
</li>
<li><strong>选择正确的并发策略 (Hibernate)</strong>: 根据数据的更新特性选择 <code>READ_ONLY</code>, <code>READ_WRITE</code> 等策略，在性能和一致性之间找到平衡。</li>
</ul>
</li>
<li><strong>分布式缓存方案</strong>:<ul>
<li>在分布式或微服务架构中，应优先考虑使用<strong>集中式&#x2F;分布式缓存</strong>，如 <strong>Redis</strong>, <strong>Memcached</strong>。</li>
<li>这可以保证所有服务实例共享同一份缓存数据，从根本上解决多节点间的缓存不一致问题。</li>
<li>ORM 框架（如 Hibernate）可以通过相应的集成包（如 <code>hibernate-redis</code>）与这些分布式缓存系统无缝集成。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>: 缓存是一把双刃剑。合理地使用和配置可以极大地提升系统性能和可伸缩性，但错误或盲目地使用则会引入数据不一致等严重问题。在决定使用二级缓存之前，务必进行充分的分析和评估。</p>
<hr>
<h2 id="3-事务管理"><a href="#3-事务管理" class="headerlink" title="3. 事务管理"></a>3. 事务管理</h2><h3 id="3-1-ORM框架与事务如何集成"><a href="#3-1-ORM框架与事务如何集成" class="headerlink" title="3.1 ORM框架与事务如何集成"></a>3.1 ORM框架与事务如何集成</h3><p>事务管理是企业级应用中保证数据一致性的核心机制。ORM 框架作为数据持久化层，其所有写操作（增、删、改）都必须在事务的边界内进行。因此，ORM 框架与事务管理的集成是天作之合，也是框架设计的关键部分。</p>
<h4 id="3-1-1-事务管理的核心职责"><a href="#3-1-1-事务管理的核心职责" class="headerlink" title="3.1.1 事务管理的核心职责"></a>3.1.1 事务管理的核心职责</h4><p>无论何种技术实现，事务管理器都需要负责以下核心职责：</p>
<ol>
<li><strong>开启事务 (Begin)</strong>: 标记一个新事务的开始。</li>
<li><strong>提交事务 (Commit)</strong>: 如果事务中的所有操作都成功执行，则将这些变更永久保存到数据库。</li>
<li><strong>回滚事务 (Rollback)</strong>: 如果事务中任何一个操作失败，或者业务逻辑要求中止，则撤销该事务中已执行的所有操作，使数据库恢复到事务开始前的状态。</li>
</ol>
<hr>
<h4 id="3-1-2-集成方式"><a href="#3-1-2-集成方式" class="headerlink" title="3.1.2 集成方式"></a>3.1.2 集成方式</h4><p>ORM 框架与事务的集成主要有两种方式：<strong>编程式事务</strong>和<strong>声明式事务</strong>。在现代开发中，特别是与 Spring 框架结合使用时，<strong>声明式事务是绝对的主流和最佳实践</strong>。</p>
<h5 id="1-编程式事务-Programmatic-Transaction-Management"><a href="#1-编程式事务-Programmatic-Transaction-Management" class="headerlink" title="1. 编程式事务 (Programmatic Transaction Management)"></a>1. 编程式事务 (Programmatic Transaction Management)</h5><p><strong>定义</strong>: 在业务代码中，通过<strong>手动调用</strong>事务管理 API 来精确控制事务的边界（开始、提交、回滚）。</p>
<p><strong>集成原理</strong>:ORM 框架提供获取和控制事务的底层 API。开发者需要显式地在代码中进行管理。</p>
<p><strong>MyBatis 中的编程式事务</strong>:</p>
<p>MyBatis 的事务管理是建立在 JDBC 事务之上的。<code>SqlSession</code> 默认是<strong>不自动提交</strong>事务的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession(); <span class="comment">// 默认 openSession(false)</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">    <span class="comment">// ... 执行多个数据库操作</span></span><br><span class="line">    userMapper.updateUser(user1);</span><br><span class="line">    accountMapper.decreaseBalance(account1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有操作成功，手动提交事务</span></span><br><span class="line">    session.commit(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 发生异常，手动回滚事务</span></span><br><span class="line">    session.rollback();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 必须关闭 session</span></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>: 控制粒度最细，可以非常灵活地在代码的任何位置开启或结束事务。</li>
<li><strong>缺点</strong>:<ul>
<li><strong>代码侵入性强</strong>: 事务管理逻辑与业务逻辑紧密耦合在一起，污染了业务代码。</li>
<li><strong>重复性高</strong>: 每个需要事务的方法都必须编写类似的 <code>try-catch-finally</code> 样板代码，容易出错和遗漏。</li>
<li><strong>维护困难</strong>: 随着业务逻辑变复杂，事务边界的管理会变得非常混乱。</li>
</ul>
</li>
</ul>
<p><strong>JPA&#x2F;Hibernate 中的编程式事务</strong>:</p>
<p>JPA 提供了 <code>EntityTransaction</code> API 来管理事务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EntityManager</span> <span class="variable">em</span> <span class="operator">=</span> emf.createEntityManager();</span><br><span class="line"><span class="type">EntityTransaction</span> <span class="variable">transaction</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取并开启事务</span></span><br><span class="line">    transaction = em.getTransaction();</span><br><span class="line">    transaction.begin();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 执行实体操作</span></span><br><span class="line">    em.persist(newUser);</span><br><span class="line">    em.merge(existingAccount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    transaction.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 回滚事务</span></span><br><span class="line">    <span class="keyword">if</span> (transaction != <span class="literal">null</span> &amp;&amp; transaction.isActive()) &#123;</span><br><span class="line">        transaction.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    em.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其优缺点与 MyBatis 编程式事务完全相同。</p>
<hr>
<h5 id="2-声明式事务-Declarative-Transaction-Management-主流方式"><a href="#2-声明式事务-Declarative-Transaction-Management-主流方式" class="headerlink" title="2. 声明式事务 (Declarative Transaction Management) - (主流方式)"></a>2. 声明式事务 (Declarative Transaction Management) - (主流方式)</h5><p><strong>定义</strong>: 通过<strong>注解 (<code>@Transactional</code>)</strong> 或 XML 配置的方式来“声明”一个方法的事务属性，而无需在方法内部编写任何事务管理代码。事务管理的横切逻辑由框架（通常是 Spring AOP）自动织入。</p>
<p><strong>集成原理</strong>:</p>
<p>这是 Spring 框架与 ORM 框架集成的核心。Spring 提供了统一的事务管理抽象 (<code>PlatformTransactionManager</code>)，并为不同的持久化技术提供了具体的实现类。</p>
<ul>
<li>对于 <strong>JDBC&#x2F;MyBatis</strong>，使用 <code>DataSourceTransactionManager</code>。</li>
<li>对于 <strong>JPA&#x2F;Hibernate</strong>，使用 <code>JpaTransactionManager</code>。</li>
</ul>
<p><strong>工作流程 (以 Spring + JPA 为例)</strong>:</p>
<ol>
<li><p><strong>配置 <code>TransactionManager</code></strong>: 在 Spring 配置中，声明一个 <code>JpaTransactionManager</code> Bean，并将其与 <code>EntityManagerFactory</code> 关联起来。Spring Boot 会自动完成这个配置。</p>
</li>
<li><p><strong>开启事务支持</strong>: 使用 <code>@EnableTransactionManagement</code> 注解开启声明式事务功能。Spring Boot 也是自动开启的。</p>
</li>
<li><p><strong>声明事务边界</strong>: 在需要事务管理的方法或类上添加 <code>@Transactional</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransferServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">TransferService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountRepository accountRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// 声明此方法需要事务管理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Long fromId, Long toId, BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 业务逻辑 ...</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">fromAccount</span> <span class="operator">=</span> accountRepository.findById(fromId).orElseThrow();</span><br><span class="line">        <span class="type">Account</span> <span class="variable">toAccount</span> <span class="operator">=</span> accountRepository.findById(toId).orElseThrow();</span><br><span class="line">        </span><br><span class="line">        fromAccount.setBalance(fromAccount.getBalance().subtract(amount));</span><br><span class="line">        toAccount.setBalance(toAccount.getBalance().add(amount));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 无需手动 commit/rollback</span></span><br><span class="line">        <span class="comment">// Spring 会在方法成功执行后自动提交事务</span></span><br><span class="line">        <span class="comment">// 如果方法抛出运行时异常，Spring 会自动回滚事务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>AOP 动态代理</strong>:</p>
<ul>
<li>当 Spring 容器启动时，它会扫描到 <code>@Transactional</code> 注解。</li>
<li>Spring 会为 <code>TransferServiceImpl</code> 创建一个<strong>动态代理对象</strong>。</li>
<li>当外部代码调用 <code>transferService.transfer(...)</code> 时，实际上调用的是这个代理对象的方法。</li>
</ul>
</li>
<li><p><strong>事务拦截器</strong>:</p>
<ul>
<li>代理对象的方法在执行<strong>前</strong>，会触发一个事务拦截器（Transaction Interceptor）。</li>
<li>拦截器会从 <code>JpaTransactionManager</code> 中获取一个事务，并<strong>开启事务</strong>（底层是调用 <code>em.getTransaction().begin()</code>）。</li>
<li>同时，它会将 <code>EntityManager</code> 和事务信息绑定到当前线程的 <code>ThreadLocal</code> 中，以确保后续的数据库操作都在同一个事务和会z话中进行。</li>
</ul>
</li>
<li><p><strong>执行业务逻辑</strong>: 代理对象接着调用<strong>原始 <code>TransferServiceImpl</code> 对象</strong>的 <code>transfer</code> 方法。方法中的所有数据库操作都会使用从 <code>ThreadLocal</code> 中获取的 <code>EntityManager</code>。</p>
</li>
<li><p><strong>提交&#x2F;回滚</strong>:</p>
<ul>
<li>如果 <code>transfer</code> 方法<strong>正常执行完毕</strong>，事务拦截器会在方法返回后<strong>提交事务</strong> (<code>transaction.commit()</code>)。</li>
<li>如果 <code>transfer</code> 方法<strong>抛出运行时异常</strong>（<code>RuntimeException</code> 或 <code>Error</code>），事务拦截器会捕获异常，并<strong>回滚事务</strong> (<code>transaction.rollback()</code>)，然后将异常继续向外抛出。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-1-3-总结"><a href="#3-1-3-总结" class="headerlink" title="3.1.3 总结"></a>3.1.3 总结</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">编程式事务</th>
<th align="left">声明式事务</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>实现方式</strong></td>
<td align="left">手动调用 API</td>
<td align="left">注解 (<code>@Transactional</code>) &#x2F; XML 配置</td>
</tr>
<tr>
<td align="left"><strong>代码侵入性</strong></td>
<td align="left"><strong>高</strong>，业务与事务逻辑耦合</td>
<td align="left"><strong>极低</strong>，业务代码干净</td>
</tr>
<tr>
<td align="left"><strong>维护性</strong></td>
<td align="left"><strong>差</strong>，样板代码多，易出错</td>
<td align="left"><strong>优秀</strong>，逻辑清晰，易于管理</td>
</tr>
<tr>
<td align="left"><strong>框架</strong></td>
<td align="left">ORM 框架原生支持</td>
<td align="left"><strong>Spring AOP</strong></td>
</tr>
<tr>
<td align="left"><strong>推荐度</strong></td>
<td align="left">仅在极少数需要精细控制的场景使用</td>
<td align="left"><strong>99% 的场景下的最佳实践</strong></td>
</tr>
</tbody></table>
<p><strong>结论</strong>: 在现代 Spring 应用中，ORM 框架与事务的集成几乎总是通过 <strong>Spring 的声明式事务管理</strong> 来实现的。这种方式将事务控制的复杂性完全交给了框架，让开发者可以专注于业务逻辑本身，是 AOP 思想的最佳体现之一。</p>
<hr>
<h3 id="3-2-声明式事务的工作原理"><a href="#3-2-声明式事务的工作原理" class="headerlink" title="3.2 声明式事务的工作原理"></a>3.2 声明式事务的工作原理</h3><p>Spring 的声明式事务是其最核心、最强大的功能之一，也是 AOP (Aspect-Oriented Programming, 面向切面编程) 思想的经典应用。理解其工作原理，有助于我们正确地使用 <code>@Transactional</code> 注解并避免常见的“事务失效”问题。</p>
<p>其核心可以概括为：<strong>基于 AOP 的动态代理和事务拦截器</strong>。</p>
<h4 id="3-2-1-核心组件"><a href="#3-2-1-核心组件" class="headerlink" title="3.2.1 核心组件"></a>3.2.1 核心组件</h4><ol>
<li><strong><code>@Transactional</code> 注解</strong>:<ul>
<li>一个元数据标记，用于告诉 Spring 哪些类或方法需要被事务管理。它本身不包含任何逻辑，只是一个“声明”。</li>
</ul>
</li>
<li><strong><code>PlatformTransactionManager</code> (平台事务管理器)</strong>:<ul>
<li>Spring 事务管理的<strong>统一接口</strong>，定义了 <code>getTransaction</code>, <code>commit</code>, <code>rollback</code> 等核心方法。</li>
<li>Spring 为不同的持久化技术提供了具体的实现，例如：<ul>
<li><code>DataSourceTransactionManager</code>: 用于 JDBC, MyBatis。</li>
<li><code>JpaTransactionManager</code>: 用于 JPA&#x2F;Hibernate。</li>
</ul>
</li>
<li>它的职责是实际执行事务的开启、提交和回滚操作。</li>
</ul>
</li>
<li><strong>AOP 代理 (AOP Proxy)</strong>:<ul>
<li>Spring AOP 的核心。当 Spring 容器扫描到一个类被 <code>@Transactional</code> 注解标记时，它<strong>不会</strong>直接将这个类的原始实例（目标对象 Target Object）放入容器。</li>
<li>相反，它会为这个目标对象创建一个<strong>动态代理对象 (Proxy)</strong>，并将这个代理对象作为 Bean 放入容器。</li>
<li>这个代理对象“包裹”了原始对象，并持有对它的引用。</li>
</ul>
</li>
<li><strong>事务拦截器 (Transaction Interceptor)</strong>:<ul>
<li>一个实现了 AOP <code>Advice</code> (通知) 的组件，通常是 <code>TransactionInterceptor</code> 类。</li>
<li>这个拦截器包含了事务管理的<strong>横切逻辑</strong>（即在业务方法执行前后需要做的事务操作）。</li>
<li>Spring 会通过<strong>切点 (Pointcut)</strong> 将这个拦截器与被 <code>@Transactional</code> 注解的方法绑定起来。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-2-2-详细工作流程"><a href="#3-2-2-详细工作流程" class="headerlink" title="3.2.2 详细工作流程"></a>3.2.2 详细工作流程</h4><p>下面以一个典型的服务调用 <code>someService.doBusinessLogic()</code> 为例，分解声明式事务的完整工作流程：</p>
<p><strong>步骤 1: 外部调用</strong></p>
<ul>
<li>当应用程序的其他部分（如 Controller）注入并调用 <code>SomeService</code> 的 <code>doBusinessLogic()</code> 方法时，它实际获取并调用的是 <strong>Spring 创建的 <code>SomeService</code> 的代理对象</strong>，而不是原始的 <code>SomeService</code> 实例。</li>
</ul>
<p><strong>步骤 2: 代理拦截</strong></p>
<ul>
<li>对代理对象的 <code>doBusinessLogic()</code> 方法的调用被 <strong>AOP 代理</strong>所拦截。</li>
</ul>
<p><strong>步骤 3: 事务拦截器介入</strong></p>
<ul>
<li>代理对象在调用原始业务方法<strong>之前</strong>，首先会调用<strong>事务拦截器</strong> (<code>TransactionInterceptor</code>) 的 <code>invoke</code> 方法。</li>
</ul>
<p><strong>步骤 4: 开启事务</strong></p>
<ul>
<li>事务拦截器检查 <code>doBusinessLogic()</code> 方法上的 <code>@Transactional</code> 注解的属性（如隔离级别、传播行为、只读等）。</li>
<li>它向 <code>PlatformTransactionManager</code> (例如 <code>JpaTransactionManager</code>) 请求一个新事务。</li>
<li><code>PlatformTransactionManager</code> 会：<br>a. 从数据源获取一个数据库连接 (<code>Connection</code>)。<br>b. <strong>禁用</strong>该连接的自动提交 (<code>connection.setAutoCommit(false)</code>)。<br>c. (对于 JPA) 创建一个 <code>EntityManager</code>，并开始一个事务 (<code>em.getTransaction().begin()</code>)。<br>d. 将数据库连接&#x2F;<code>EntityManager</code> 等事务资源<strong>绑定到当前线程的 <code>ThreadLocal</code></strong> 中。这是为了确保后续在该线程中的所有数据库操作都使用同一个连接&#x2F;<code>EntityManager</code>，从而处于同一个事务中。</li>
</ul>
<p><strong>步骤 5: 执行业务逻辑</strong></p>
<ul>
<li>事务拦截器调用<strong>原始 <code>SomeService</code> 实例 (Target Object)</strong> 的 <code>doBusinessLogic()</code> 方法。</li>
<li>在该方法内部，所有对 <code>Repository</code> 或 <code>Mapper</code> 的调用，都会从 <code>ThreadLocal</code> 中获取已经被事务管理的数据库连接或 <code>EntityManager</code>，并执行相应的 SQL 操作。这些操作的结果暂时停留在数据库的事务日志或 ORM 的一级缓存中，并未永久提交。</li>
</ul>
<p><strong>步骤 6: 事务提交或回滚</strong></p>
<ul>
<li>业务方法 <code>doBusinessLogic()</code> 执行完毕后，控制权返回给事务拦截器。</li>
<li><strong>情况 A: 方法正常返回 (没有抛出异常)</strong><ul>
<li>拦截器会通知 <code>PlatformTransactionManager</code> <strong>提交 (commit)</strong> 事务。</li>
<li><code>PlatformTransactionManager</code> 会调用 <code>connection.commit()</code> 或 <code>em.getTransaction().commit()</code>，将事务中的所有变更永久写入数据库。</li>
</ul>
</li>
<li><strong>情况 B: 方法抛出异常</strong><ul>
<li>拦截器会捕获这个异常。</li>
<li>默认情况下，如果异常是 <code>RuntimeException</code> 或 <code>Error</code>，拦截器会通知 <code>PlatformTransactionManager</code> <strong>回滚 (rollback)</strong> 事务。</li>
<li><code>PlatformTransactionManager</code> 会调用 <code>connection.rollback()</code> 或 <code>em.getTransaction().rollback()</code>，撤销事务中的所有变更。</li>
<li>如果异常是<strong>受检异常 (Checked Exception)</strong>，默认情况下事务<strong>不会</strong>回滚（可以通过 <code>@Transactional(rollbackFor = ...)</code> 来改变这个行为）。</li>
<li>回滚或提交后，拦截器会将捕获的异常继续向外抛出。</li>
</ul>
</li>
</ul>
<p><strong>步骤 7: 清理资源</strong></p>
<ul>
<li>无论事务是提交还是回滚，事务拦截器最终都会在 <code>finally</code> 块中执行清理操作。</li>
<li><code>PlatformTransactionManager</code> 会<strong>释放</strong>数据库连接（将其归还给连接池），并从 <code>ThreadLocal</code> 中<strong>解绑</strong>所有事务资源。</li>
</ul>
<hr>
<h4 id="3-2-3-为什么-Transactional-会失效？"><a href="#3-2-3-为什么-Transactional-会失效？" class="headerlink" title="3.2.3 为什么 @Transactional 会失效？"></a>3.2.3 为什么 <code>@Transactional</code> 会失效？</h4><p>理解了上述原理，就很容易明白为什么在某些情况下 <code>@Transactional</code> 会失效：</p>
<ul>
<li><strong>方法不是 <code>public</code> 的</strong>: Spring AOP 默认只能代理 <code>public</code> 方法。</li>
<li><strong>方法是 <code>final</code> 或 <code>static</code> 的</strong>: 代理是基于子类继承 (CGLIB) 或接口实现 (JDK Proxy) 的，<code>final</code> 和 <code>static</code> 方法无法被覆盖，因此无法被代理。</li>
<li><strong>同一个类中的方法调用 (this 调用)</strong>:<ul>
<li><code>public void methodA() { this.methodB(); }</code></li>
<li>如果外部调用 <code>methodA()</code> (无 <code>@Transactional</code> 注解)，而 <code>methodB()</code> 有 <code>@Transactional</code> 注解，<code>methodB</code> 的事务<strong>不会生效</strong>。</li>
<li><strong>原因</strong>: 调用 <code>this.methodB()</code> 是直接调用<strong>原始对象 (Target Object)</strong> 的方法，<strong>绕过了代理对象 (Proxy)</strong>。事务拦截器根本没有机会介入。</li>
</ul>
</li>
<li><strong>异常被 <code>catch</code> 掉了</strong>: 如果业务方法内部 <code>try-catch</code> 了一个 <code>RuntimeException</code> 并且没有重新抛出，事务拦截器就感知不到异常的发生，因此会<strong>正常提交事务</strong>。</li>
</ul>
<hr>
<h3 id="3-3-事务的隔离级别与传播行为"><a href="#3-3-事务的隔离级别与传播行为" class="headerlink" title="3.3 事务的隔离级别与传播行为"></a>3.3 事务的隔离级别与传播行为</h3><p>在使用 Spring 的 <code>@Transactional</code> 注解时，除了默认行为，我们还可以通过配置其 <code>isolation</code> (隔离级别) 和 <code>propagation</code> (传播行为) 属性，来精细化地控制事务的行为，以应对复杂的业务场景。</p>
<h4 id="3-3-1-事务的隔离级别-Isolation-Level"><a href="#3-3-1-事务的隔离级别-Isolation-Level" class="headerlink" title="3.3.1 事务的隔离级别 (Isolation Level)"></a>3.3.1 事务的隔离级别 (Isolation Level)</h4><p><strong>定义</strong>: 隔离级别定义了一个事务在执行过程中，其所做的修改对<strong>其他并发事务</strong>的可见程度。它旨在解决多事务并发执行时可能出现的<strong>脏读、不可重复读、幻读</strong>等问题。</p>
<p>隔离级别本质上是在<strong>数据一致性</strong>和<strong>并发性能</strong>之间做出的权衡。级别越高，数据一致性越好，但并发性能通常越差，因为需要更强的锁机制。</p>
<p><strong>并发问题简介</strong>:</p>
<ul>
<li><strong>脏读 (Dirty Read)</strong>: 一个事务读取到了另一个<strong>未提交</strong>事务修改的数据。</li>
<li><strong>不可重复读 (Non-Repeatable Read)</strong>: 在同一个事务内，两次读取<strong>同一行</strong>数据，得到的结果不同。这是因为在两次读取之间，有另一个事务<strong>提交了</strong>对这行数据的修改。</li>
<li><strong>幻读 (Phantom Read)</strong>: 在同一个事务内，两次执行<strong>相同的范围查询</strong>，第二次查询返回了第一次查询中<strong>不存在的新行</strong>。这是因为在两次查询之间，有另一个事务<strong>插入了</strong>符合该范围条件的新数据。</li>
</ul>
<p><strong>Spring 定义的隔离级别 (<code>Isolation</code> 枚举)</strong>:</p>
<table>
<thead>
<tr>
<th align="left">隔离级别 (<code>@Transactional(isolation = ...</code>)</th>
<th align="left">脏读</th>
<th align="left">不可重复读</th>
<th align="left">幻读</th>
<th align="left">数据库默认 (常见)</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>READ_UNCOMMITTED</code></td>
<td align="left"><strong>可能</strong></td>
<td align="left"><strong>可能</strong></td>
<td align="left"><strong>可能</strong></td>
<td align="left">-</td>
<td align="left"><strong>读未提交</strong>。级别最低，允许读取未提交的数据，性能最好但数据一致性最差。几乎不使用。</td>
</tr>
<tr>
<td align="left"><code>READ_COMMITTED</code></td>
<td align="left">不会</td>
<td align="left"><strong>可能</strong></td>
<td align="left"><strong>可能</strong></td>
<td align="left">Oracle, SQL Server</td>
<td align="left"><strong>读已提交</strong>。一个事务只能读取到其他已提交事务的修改。解决了脏读。这是大多数数据库的默认级别。</td>
</tr>
<tr>
<td align="left"><code>REPEATABLE_READ</code></td>
<td align="left">不会</td>
<td align="left">不会</td>
<td align="left"><strong>可能</strong></td>
<td align="left"><strong>MySQL (InnoDB)</strong></td>
<td align="left"><strong>可重复读</strong>。保证在同一事务中多次读取同一行数据的结果是一致的。解决了不可重复读。MySQL InnoDB 通过 Next-Key Lock 机制在一定程度上解决了幻读。</td>
</tr>
<tr>
<td align="left"><code>SERIALIZABLE</code></td>
<td align="left">不会</td>
<td align="left">不会</td>
<td align="left">不会</td>
<td align="left">-</td>
<td align="left"><strong>串行化</strong>。级别最高，强制事务串行执行，完全避免了所有并发问题。性能最差，通常不使用。</td>
</tr>
<tr>
<td align="left"><code>DEFAULT</code></td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left"><strong>使用数据库的默认隔离级别</strong>。这是 <code>@Transactional</code> 的<strong>默认值</strong>。</td>
</tr>
</tbody></table>
<p><strong>如何选择</strong>:</p>
<ul>
<li>绝大多数情况下，使用<strong>数据库的默认隔离级别 (<code>DEFAULT</code>)</strong> 就足够了。</li>
<li>如果业务上对数据一致性有特殊要求（例如，在一次交易中需要多次读取账户余额并确保其不变），可以考虑提升隔离级别到 <code>REPEATABLE_READ</code>。</li>
</ul>
<hr>
<h4 id="3-3-2-事务的传播行为-Propagation-Behavior"><a href="#3-3-2-事务的传播行为-Propagation-Behavior" class="headerlink" title="3.3.2 事务的传播行为 (Propagation Behavior)"></a>3.3.2 事务的传播行为 (Propagation Behavior)</h4><p><strong>定义</strong>: 传播行为定义了当一个<strong>已存在事务</strong>的方法调用另一个需要事务的方法时，事务应该如何<strong>传播或交互</strong>。它解决了<strong>事务嵌套</strong>的问题。</p>
<p>例如，<code>ServiceA.methodA()</code> 调用 <code>ServiceB.methodB()</code>，两者都标记了 <code>@Transactional</code>，<code>methodB</code> 是加入 <code>methodA</code> 的事务，还是开启一个新事务？这就是传播行为要解决的问题。</p>
<p><strong>Spring 定义的传播行为 (<code>Propagation</code> 枚举)</strong>:</p>
<table>
<thead>
<tr>
<th align="left">传播行为 (<code>@Transactional(propagation = ...</code>)</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>REQUIRED</code></strong> (默认值)</td>
<td align="left"><strong>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</strong> 这是最常用、最符合逻辑的行为。</td>
</tr>
<tr>
<td align="left"><code>SUPPORTS</code></td>
<td align="left">如果当前存在事务，则加入该事务；如果当前没有事务，则以<strong>非事务</strong>的方式执行。</td>
</tr>
<tr>
<td align="left"><code>MANDATORY</code></td>
<td align="left"><strong>强制要求</strong>当前必须存在一个事务，否则抛出异常。</td>
</tr>
<tr>
<td align="left"><strong><code>REQUIRES_NEW</code></strong></td>
<td align="left"><strong>总是创建一个新的事务。</strong> 如果当前已存在事务，则将<strong>当前事务挂起</strong>，执行完新事务后再恢复。两个事务是完全独立的，外部事务的回滚不影响内部事务的提交，反之亦然。</td>
</tr>
<tr>
<td align="left"><code>NOT_SUPPORTED</code></td>
<td align="left">以<strong>非事务</strong>的方式执行操作。如果当前存在事务，则将该事务挂起。</td>
</tr>
<tr>
<td align="left"><code>NEVER</code></td>
<td align="left">以<strong>非事务</strong>的方式执行，并且<strong>强制要求</strong>当前不能存在事务，否则抛出异常。</td>
</tr>
<tr>
<td align="left"><code>NESTED</code></td>
<td align="left"><strong>嵌套事务</strong>。如果当前存在事务，则在当前事务中创建一个保存点 (Savepoint)，形成一个嵌套事务。嵌套事务可以独立于外部事务进行回滚。如果当前没有事务，则行为等同于 <code>REQUIRED</code>。 (注意：并非所有数据库都支持保存点)</td>
</tr>
</tbody></table>
<p><strong>最常用的两种传播行为</strong>:</p>
<h5 id="1-REQUIRED-默认"><a href="#1-REQUIRED-默认" class="headerlink" title="1. REQUIRED (默认)"></a>1. <code>REQUIRED</code> (默认)</h5><ul>
<li><strong>场景</strong>: 绝大多数业务场景。例如，一个“下单”服务 <code>placeOrder()</code> 调用“扣减库存”服务 <code>deductStock()</code> 和“更新订单状态”服务 <code>updateStatus()</code>。这三个操作逻辑上属于<strong>同一个原子工作单元</strong>，必须同成败。<code>deductStock</code> 和 <code>updateStatus</code> 都应该加入到 <code>placeOrder</code> 的事务中。</li>
<li><strong>结果</strong>: 整个调用链在同一个事务中，任何一步失败，所有操作都会一起回滚。</li>
</ul>
<h5 id="2-REQUIRES-NEW"><a href="#2-REQUIRES-NEW" class="headerlink" title="2. REQUIRES_NEW"></a>2. <code>REQUIRES_NEW</code></h5><ul>
<li><p><strong>场景</strong>: 当你希望某个操作的事务独立于外部调用者的事务时。</p>
</li>
<li><p><strong>典型例子</strong>: 记录操作日志。假设有一个业务方法 <code>doBusiness()</code>，无论 <code>doBusiness()</code> 最终是成功提交还是失败回滚，我们都<strong>希望</strong>将本次操作的日志 (<code>logService.record(...)</code>) <strong>成功地保存到数据库</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogService logService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBusiness</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ... 核心业务逻辑，可能会失败 ...</span></span><br><span class="line">            <span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;业务失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论业务成功与否，都尝试记录日志</span></span><br><span class="line">            logService.record(<span class="string">&quot;执行了一次业务操作&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 将日志信息保存到数据库 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>工作流程</strong>:</p>
<ol>
<li><code>doBusiness</code> 开启事务 <code>TX1</code>。</li>
<li>调用 <code>logService.record</code> 时，<code>REQUIRES_NEW</code> 会使 <code>TX1</code> <strong>挂起</strong>。</li>
<li><code>logService.record</code> 开启一个<strong>全新的、独立的事务 <code>TX2</code></strong>。</li>
<li><code>record</code> 方法执行完毕，<code>TX2</code> <strong>独立提交</strong>，日志成功写入数据库。</li>
<li>控制权返回，<code>TX1</code> <strong>恢复</strong>。</li>
<li><code>doBusiness</code> 方法中抛出异常，<code>TX1</code> <strong>回滚</strong>。</li>
</ol>
</li>
<li><p><strong>最终结果</strong>: 核心业务操作被回滚，但操作日志成功保留。</p>
</li>
</ul>
<hr>
<h2 id="4-ORM框架选型"><a href="#4-ORM框架选型" class="headerlink" title="4. ORM框架选型"></a>4. ORM框架选型</h2><p>在 Java 持久化领域，MyBatis (及其增强版 MyBatis-Plus) 和 JPA (以 Hibernate 为代表实现) 是两大主流选择。它们没有绝对的优劣之分，而是各自在设计哲学、适用场景和开发体验上有所侧重。进行技术选型时，需要综合考虑项目需求、团队技能、性能要求和未来发展等多个维度。</p>
<h3 id="4-1-核心差异对比"><a href="#4-1-核心差异对比" class="headerlink" title="4.1 核心差异对比"></a>4.1 核心差异对比</h3><p>这是一张总结两大框架核心差异的对比表，可以作为选型的快速参考：</p>
<table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left">MyBatis &#x2F; MyBatis-Plus</th>
<th align="left">JPA &#x2F; Hibernate</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>设计哲学</strong></td>
<td align="left"><strong>SQL中心 (SQL-centric)</strong></td>
<td align="left"><strong>对象中心 (Object-centric)</strong></td>
</tr>
<tr>
<td align="left"><strong>抽象层次</strong></td>
<td align="left"><strong>半自动 ORM (Semi-ORM)</strong></td>
<td align="left"><strong>全自动 ORM (Full-ORM)</strong></td>
</tr>
<tr>
<td align="left"><strong>SQL 控制力</strong></td>
<td align="left"><strong>完全控制</strong>，开发者手写和优化所有 SQL。</td>
<td align="left"><strong>间接控制</strong>，框架自动生成 SQL，也可通过 JPQL 或原生 SQL 干预。</td>
</tr>
<tr>
<td align="left"><strong>开发效率</strong></td>
<td align="left">- <strong>原生MyBatis</strong>: 中等，需编写 XML 和接口。 <br>- <strong>MyBatis-Plus</strong>: <strong>很高</strong>，通用 CRUD 无需 SQL。</td>
<td align="left"><strong>极高</strong>，Spring Data JPA 的 <code>Repository</code> 和方法命名查询极大减少代码量。</td>
</tr>
<tr>
<td align="left"><strong>学习曲线</strong></td>
<td align="left"><strong>平缓</strong>，对熟悉 SQL 的开发者非常友好。</td>
<td align="left"><strong>较陡峭</strong>，需深入理解实体生命周期、持久化上下文、抓取策略等核心概念。</td>
</tr>
<tr>
<td align="left"><strong>数据库移植性</strong></td>
<td align="left"><strong>较好</strong>，但复杂 SQL 可能依赖数据库方言，移植时需要修改。</td>
<td align="left"><strong>非常好</strong>，只要面向 JPA 规范编程，更换数据库的成本极低。</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left"><strong>潜力更高</strong>，开发者可以直接编写最优化的 SQL。</td>
<td align="left"><strong>通常良好</strong>，但自动生成的 SQL 可能非最优，复杂场景下需要手动调优。</td>
</tr>
<tr>
<td align="left"><strong>复杂查询支持</strong></td>
<td align="left"><strong>非常强大</strong>，特别适合复杂的报表和多表连接查询。</td>
<td align="left"><strong>良好</strong>，但构建复杂 JPQL 相对繁琐，有时不如手写 SQL 直观。</td>
</tr>
<tr>
<td align="left"><strong>生态集成</strong></td>
<td align="left">与 Spring 集成良好，MyBatis-Plus 社区活跃。</td>
<td align="left"><strong>与 Spring 生态无缝集成</strong>，是 Spring Data 的核心部分，生态极为成熟。</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-2-如何做出选择？"><a href="#4-2-如何做出选择？" class="headerlink" title="4.2 如何做出选择？"></a>4.2 如何做出选择？</h3><h4 id="4-2-1-选择-MyBatis-MyBatis-Plus-的场景："><a href="#4-2-1-选择-MyBatis-MyBatis-Plus-的场景：" class="headerlink" title="4.2.1 选择 MyBatis &#x2F; MyBatis-Plus 的场景："></a>4.2.1 选择 MyBatis &#x2F; MyBatis-Plus 的场景：</h4><ol>
<li><strong>SQL 优化是首要任务</strong>:<ul>
<li>当项目对数据库性能有极致要求，需要对每一条 SQL 进行精细化审查和优化（如使用索引提示、复杂子查询等）时，MyBatis 提供了无与伦比的控制力。</li>
<li><strong>适用项目</strong>: 高并发的互联网应用（如秒杀、实时推荐）、金融交易系统。</li>
</ul>
</li>
<li><strong>报表系统和数据分析平台</strong>:<ul>
<li>这类项目通常涉及大量复杂、动态、多表 <code>JOIN</code> 的聚合查询。用手写 SQL 来表达这些逻辑远比用 JPQL 或 Criteria API 更直接、更高效。</li>
<li>将这些复杂的 SQL 集中管理在 XML 中，也便于 DBA 介入和维护。</li>
</ul>
</li>
<li><strong>遗留系统或数据库设计不规范</strong>:<ul>
<li>当需要对接一个设计不佳或无法修改的遗留数据库时，MyBatis 强大的 <code>&lt;resultMap&gt;</code> 可以将任何奇特的查询结果灵活地映射到 Java 对象上。而 JPA 强制的实体映射关系在这种情况下可能会处处受限。</li>
</ul>
</li>
<li><strong>团队成员精通 SQL</strong>:<ul>
<li>如果团队成员（包括 DBA）对 SQL 有着深厚的功底，并乐于通过 SQL 解决问题，MyBatis 的学习曲线会非常平缓，能快速发挥团队的优势。</li>
</ul>
</li>
<li><strong>希望保持简单和轻量级</strong>:<ul>
<li>原生 MyBatis 本身非常轻量，其工作模式也相对透明。对于不希望引入过多“魔法”和复杂概念的项目，MyBatis 是一个可靠的选择。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-2-2-选择-JPA-Hibernate-的场景："><a href="#4-2-2-选择-JPA-Hibernate-的场景：" class="headerlink" title="4.2.2 选择 JPA &#x2F; Hibernate 的场景："></a>4.2.2 选择 JPA &#x2F; Hibernate 的场景：</h4><ol>
<li><strong>快速开发和原型验证</strong>:<ul>
<li>对于新项目，特别是需要快速迭代的业务系统，Spring Data JPA 的开发效率是无与伦比的。它可以让你在极短的时间内搭建起功能完备的数据访问层。</li>
<li><strong>适用项目</strong>: 创业公司的 MVP 产品、企业内部管理系统。</li>
</ul>
</li>
<li><strong>CRUD 密集的标准业务系统</strong>:<ul>
<li>对于大多数以表单和列表为核心的 CRUD 应用（如 OA, CRM, ERP），JPA 提供了最优雅的解决方案。代码简洁、规范，维护性好。</li>
</ul>
</li>
<li><strong>追求数据库无关性和高可移植性</strong>:<ul>
<li>如果项目计划支持多种数据库，或者未来可能需要从一个数据库迁移到另一个，JPA 是不二之选。它能最大程度地保护你的业务代码不受底层数据库变化的影响。</li>
<li><strong>适用项目</strong>: 需要私有化部署的商业软件产品。</li>
</ul>
</li>
<li><strong>践行领域驱动设计 (DDD)</strong>:<ul>
<li>JPA 的面向对象设计与 DDD 的思想天然契合。实体、值对象、聚合根等 DDD 概念都能在 JPA 中找到很好的技术映射，有助于构建健壮的领域模型。</li>
</ul>
</li>
<li><strong>希望全面拥抱 Spring 生态</strong>:<ul>
<li>Spring Data JPA 是 Spring 生态中的“一等公民”，与 Spring Boot、Spring Security 等其他模块的集成最为紧密和成熟。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-3-混合使用：一种务实的选择"><a href="#4-3-混合使用：一种务实的选择" class="headerlink" title="4.3 混合使用：一种务实的选择"></a>4.3 混合使用：一种务实的选择</h3><p>在复杂的项目中，<strong>没有必要将自己局限于单一的框架</strong>。Spring Boot 允许你在同一个项目中同时集成 MyBatis-Plus 和 Spring Data JPA。</p>
<p><strong>混合使用策略</strong>:</p>
<ul>
<li><strong>JPA 作为主力</strong>: 使用 Spring Data JPA 处理项目中 <strong>80% 的标准化 CRUD 和简单的业务查询</strong>，以享受其带来的高开发效率。</li>
<li><strong>MyBatis 作为补充</strong>: 对于那 <strong>20% 的、极其复杂的报表查询或需要极致性能优化的场景</strong>，单独创建 MyBatis 的 Mapper 接口和 XML 文件，手写最优的 SQL 来解决。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/09/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/JDBC/" rel="prev" title="JDBC">
                  <i class="fa fa-angle-left"></i> JDBC
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/09/29/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringFramework/" rel="next" title="Spring全家桶-SpringFramework">
                  Spring全家桶-SpringFramework <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
