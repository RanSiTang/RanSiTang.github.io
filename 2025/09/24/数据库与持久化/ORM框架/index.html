<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="一、简介1. 核心概念与本质1.1 什么是ORM？ORM (Object-Relational Mapping，对象关系映射) 是一种在关系型数据库和面向对象编程语言之间建立桥梁的技术规范。它充当了应用程序与数据库之间的中间件，负责数据的自动持久化与还原。  O (Object): 也就是 Java POJO（领域模型），关注业务逻辑。 R (Relational): 关系型数据库（Schema）">
<meta property="og:type" content="article">
<meta property="og:title" content="ORM框架">
<meta property="og:url" content="http://example.com/2025/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/ORM%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="一、简介1. 核心概念与本质1.1 什么是ORM？ORM (Object-Relational Mapping，对象关系映射) 是一种在关系型数据库和面向对象编程语言之间建立桥梁的技术规范。它充当了应用程序与数据库之间的中间件，负责数据的自动持久化与还原。  O (Object): 也就是 Java POJO（领域模型），关注业务逻辑。 R (Relational): 关系型数据库（Schema）">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-09-24T07:23:30.000Z">
<meta property="article:modified_time" content="2025-12-12T12:33:03.543Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/ORM%E6%A1%86%E6%9E%B6/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/ORM%E6%A1%86%E6%9E%B6/","path":"2025/09/24/数据库与持久化/ORM框架/","title":"ORM框架"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ORM框架 | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%AE%80%E4%BB%8B"><span class="nav-text">一、简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%9C%AC%E8%B4%A8"><span class="nav-text">1. 核心概念与本质</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AFORM%EF%BC%9F"><span class="nav-text">1.1 什么是ORM？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%A7%A3%E5%86%B3%E7%9A%84%E6%A0%B8%E5%BF%83%E9%80%9A%E7%82%B9"><span class="nav-text">1.2 解决的核心通点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B"><span class="nav-text">2. 技术演进</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8E%9F%E7%94%9F-JDBC-%E7%9A%84%E7%97%9B%E7%82%B9"><span class="nav-text">2.1 原生 JDBC 的痛点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-ORM-%E7%9A%84%E8%A7%A3%E6%94%BE"><span class="nav-text">2.2 ORM 的解放</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Java-ORM-%E7%94%9F%E6%80%81%E7%9A%84%E4%B8%A4%E5%A4%A7%E6%B5%81%E6%B4%BE"><span class="nav-text">3. Java ORM 生态的两大流派</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%85%A8%E8%87%AA%E5%8A%A8-ORM-Full-Automation"><span class="nav-text">3.1 全自动 ORM (Full Automation)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%8D%8A%E8%87%AA%E5%8A%A8-ORM-SQL-Mapper"><span class="nav-text">3.2 半自动 ORM &#x2F; SQL Mapper</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%B5%81%E6%B4%BE%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="nav-text">3.3 流派对比表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-ORM-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E8%BE%A9%E8%AF%81%E5%88%86%E6%9E%90"><span class="nav-text">4. ORM 的优缺点辩证分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF"><span class="nav-text">4.1 核心优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%BD%9C%E5%9C%A8%E5%8A%A3%E5%8A%BF"><span class="nav-text">4.2 潜在劣势</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%80%BB%E7%BB%93%E4%B8%8E%E9%80%89%E5%9E%8B%E5%BB%BA%E8%AE%AE"><span class="nav-text">5. 总结与选型建议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81MyBatis"><span class="nav-text">二、MyBatis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-MyBatis%E7%AE%80%E4%BB%8B%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">1. MyBatis简介与核心思想</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9A%E4%BD%8D"><span class="nav-text">1.1 定义与定位</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E4%BB%80%E4%B9%88%E6%98%AFMyBatis%EF%BC%9F"><span class="nav-text">1.1.1 什么是MyBatis？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E6%98%AF%E2%80%9C%E5%8D%8A%E8%87%AA%E5%8A%A8%E2%80%9D%E7%9A%84%EF%BC%9F"><span class="nav-text">1.1.2 为什么它是“半自动”的？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6"><span class="nav-text">1.2 核心设计哲学</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E2%80%9CSQL-%E4%BC%98%E5%85%88%E2%80%9D-SQL-Centric"><span class="nav-text">1.2.1 “SQL 优先” (SQL-Centric)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E6%8E%A5%E5%8F%A3%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB-Interface-Binding"><span class="nav-text">1.2.2 接口绑定与动静分离 (Interface Binding)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E5%BC%BA%E5%A4%A7%E7%9A%84%E2%80%9C%E5%8A%A8%E6%80%81-SQL%E2%80%9D-Dynamic-SQL"><span class="nav-text">1.2.3 强大的“动态 SQL” (Dynamic SQL)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4-%E5%BC%BA%E5%A4%A7%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84-ResultMap"><span class="nav-text">1.2.4 强大的结果映射 (ResultMap)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">2. 核心架构与执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82%E8%A7%A3%E6%9E%90"><span class="nav-text">2.1 架构分层解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E6%8E%A5%E5%8F%A3%E5%B1%82"><span class="nav-text">2.1.1 接口层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E6%A0%B8%E5%BF%83%E5%A4%84%E7%90%86%E5%B1%82"><span class="nav-text">2.1.2 核心处理层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-%E5%9F%BA%E7%A1%80%E6%94%AF%E6%92%91%E5%B1%82"><span class="nav-text">2.1.3 基础支撑层</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%85%A8%E9%93%BE%E8%B7%AF%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">2.2 全链路执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="nav-text">2.2.1 初始化阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E4%BB%A3%E7%90%86%E9%98%B6%E6%AE%B5"><span class="nav-text">2.2.2 代理阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5"><span class="nav-text">2.2.3 数据处理阶段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-Standalone-%E6%A8%A1%E5%BC%8F"><span class="nav-text">3. 快速入门 (Standalone 模式)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BE%9D%E8%B5%96%E5%87%86%E5%A4%87"><span class="nav-text">3.1 环境与依赖准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E8%A7%84%E8%8C%83%E7%9A%84%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-text">3.2 规范的工程目录结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%86%E5%A4%87"><span class="nav-text">3.3 数据库准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E7%BC%96%E5%86%99%E6%8C%81%E4%B9%85%E5%B1%82%E4%BB%A3%E7%A0%81"><span class="nav-text">3.4 编写持久层代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-%E5%AE%9E%E4%BD%93%E7%B1%BB-User-java"><span class="nav-text">3.4.1 实体类 (User.java)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-Mapper-%E6%8E%A5%E5%8F%A3-UserMapper-java"><span class="nav-text">3.4.2 Mapper 接口 (UserMapper.java)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-Mapper-XML-%E6%98%A0%E5%B0%84-UserMapper-xml"><span class="nav-text">3.4.3 Mapper XML 映射 (UserMapper.xml)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E5%85%A8%E5%B1%80%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE-mybatis-config-xml"><span class="nav-text">3.5 全局核心配置 (mybatis-config.xml)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E5%90%AF%E5%8A%A8%E4%B8%8E%E9%AA%8C%E8%AF%81-Main-java"><span class="nav-text">3.6 启动与验证 (Main.java)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-XML%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="nav-text">4. XML映射文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%BB%91%E5%AE%9A"><span class="nav-text">4.1 核心结构与接口绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-CRUD-%E6%A0%87%E7%AD%BE%E4%B8%8E%E4%B8%BB%E9%94%AE%E5%9B%9E%E5%A1%AB"><span class="nav-text">4.2 CRUD 标签与主键回填</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E5%9F%BA%E7%A1%80-CRUD-%E7%A4%BA%E4%BE%8B"><span class="nav-text">4.2.1 基础 CRUD 示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E4%B8%BB%E9%94%AE%E5%9B%9E%E5%A1%AB"><span class="nav-text">4.2.2 主键回填</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF-A%EF%BC%9A%E6%94%AF%E6%8C%81%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL"><span class="nav-text">场景 A：支持自增主键的数据库 (MySQL)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF-B%EF%BC%9A%E4%B8%8D%E6%94%AF%E6%8C%81%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93-Oracle"><span class="nav-text">场景 B：不支持自增主键的数据库 (Oracle)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86-vs"><span class="nav-text">4.3 参数处理 (#{} vs ${})</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84"><span class="nav-text">4.4 结果映射 (&lt;resultMap&gt;)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-%E5%9F%BA%E7%A1%80%E6%98%A0%E5%B0%84-%E5%AD%97%E6%AE%B5%E5%90%8D%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="nav-text">4.4.1 基础映射 (字段名不一致)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-%E9%AB%98%E7%BA%A7%E6%98%A0%E5%B0%84%EF%BC%9A%E7%BA%A7%E8%81%94%E6%9F%A5%E8%AF%A2"><span class="nav-text">4.4.2 高级映射：级联查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E5%8F%AF%E9%87%8D%E7%94%A8-SQL-%E7%89%87%E6%AE%B5"><span class="nav-text">4.5 可重用 SQL 片段 (&lt;sql&gt;)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%8A%A8%E6%80%81SQL"><span class="nav-text">5. 动态SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E6%A0%87%E7%AD%BE"><span class="nav-text">5.1 条件判断标签</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1"><span class="nav-text">5.1.1 &lt;if&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2"><span class="nav-text">5.1.2 &lt;where&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3"><span class="nav-text">5.1.3 &lt;set&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E5%A4%8D%E6%9D%82%E9%80%BB%E8%BE%91%E6%A0%87%E7%AD%BE"><span class="nav-text">5.2 复杂逻辑标签</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1"><span class="nav-text">5.2.1 &lt;choose&gt;, &lt;when&gt;, &lt;otherwise&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2"><span class="nav-text">5.2.2  &lt;trim&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E9%9B%86%E5%90%88%E8%BF%AD%E4%BB%A3%E6%A0%87%E7%AD%BE"><span class="nav-text">5.3 集合迭代标签</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1-%E2%80%94%E2%80%94-%E6%9E%84%E5%BB%BA-IN-%E6%9F%A5%E8%AF%A2"><span class="nav-text">5.3.1 &lt;foreach&gt; —— 构建 IN 查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-%E2%80%94%E2%80%94-MySQL-%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5"><span class="nav-text">5.3.2 &lt;foreach&gt; —— MySQL 批量插入</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E8%BE%85%E5%8A%A9%E6%A0%87%E7%AD%BE"><span class="nav-text">5.4 辅助标签</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-1-%E2%80%94%E2%80%94-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A0%E5%85%B3%E7%9A%84%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2"><span class="nav-text">5.4.1 &lt;bind&gt; —— 数据库无关的模糊查询</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="nav-text">6. 注解开发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E7%AE%80%E4%BB%8B%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">6.1 简介与适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E5%90%AF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="nav-text">6.2 启用注解开发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E6%A0%B8%E5%BF%83-CRUD-%E6%B3%A8%E8%A7%A3"><span class="nav-text">6.3 核心 CRUD 注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86-Param"><span class="nav-text">6.4 参数处理 (@Param)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-1-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">6.4.1 使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%A4%9A%E5%8F%82%E6%95%B0-%E5%BF%85%E7%94%A8"><span class="nav-text">1. 多参数 (必用)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E9%9B%86%E5%90%88%E5%8F%82%E6%95%B0-%E6%8E%A8%E8%8D%90"><span class="nav-text">2. 集合参数 (推荐)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84-Results-Result"><span class="nav-text">6.5 结果映射 (@Results &amp; @Result)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-1-%E5%9F%BA%E7%A1%80%E6%98%A0%E5%B0%84"><span class="nav-text">6.5.1 基础映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-2-%E7%BA%A7%E8%81%94%E6%9F%A5%E8%AF%A2%EF%BC%88-One-Many%EF%BC%89"><span class="nav-text">6.5.2 级联查询（@One &amp; @Many）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-%E5%8A%A8%E6%80%81-SQL-%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%B1%80%E9%99%90%E4%B8%8E%E6%96%B9%E6%A1%88"><span class="nav-text">6.6 动态 SQL (注解的局限与方案)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-%E6%80%BB%E7%BB%93%EF%BC%9A%E6%B3%A8%E8%A7%A3-vs-XML-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">6.7 总结：注解 vs XML (最佳实践)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-%E5%8E%9F%E7%94%9FMyBatis"><span class="nav-text">7. 适用场景 (原生MyBatis)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E6%9E%81%E8%87%B4%E6%80%A7%E8%83%BD%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91-High-Concurrency"><span class="nav-text">7.1 极致性能与高并发 (High Concurrency)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E5%A4%8D%E6%9D%82%E6%8A%A5%E8%A1%A8%E4%B8%8E-OLAP-%E5%88%86%E6%9E%90-Complex-Reporting"><span class="nav-text">7.2 复杂报表与 OLAP 分析 (Complex Reporting)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E6%94%B9%E9%80%A0-Legacy-Systems"><span class="nav-text">7.3 遗留系统改造 (Legacy Systems)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-%E6%B7%B1%E5%BA%A6%E4%BE%9D%E8%B5%96%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%B9%E6%80%A7-DB-Specifics"><span class="nav-text">7.4 深度依赖数据库特性 (DB Specifics)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-%E4%B8%A5%E6%A0%BC%E7%9A%84-DBA-%E5%AE%A1%E6%A0%B8-Governance"><span class="nav-text">7.5 严格的 DBA 审核 (Governance)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81MyBatis-Plus-%E6%95%88%E7%8E%87%E5%A2%9E%E5%BC%BA"><span class="nav-text">三、MyBatis-Plus (效率增强)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%BD%8D%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6"><span class="nav-text">1. 核心定位与设计哲学</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-MyBatis-Plus-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1.1 MyBatis-Plus 是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-MP%EF%BC%9F"><span class="nav-text">1.2 为什么选择 MP？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%85%AD%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF%E8%AF%A6%E8%A7%A3"><span class="nav-text">1.3 六大核心优势详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-%E6%9E%81%E7%AE%80-CRUD"><span class="nav-text">1.3.1 极简 CRUD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8-Wrapper"><span class="nav-text">1.3.2 强大的条件构造器 (Wrapper)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3-%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%8F%92%E4%BB%B6"><span class="nav-text">1.3.3 企业级插件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-4-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8-AutoGenerator"><span class="nav-text">1.3.4 代码生成器 (AutoGenerator)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-5-%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4"><span class="nav-text">1.3.5 逻辑删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-6-%E8%87%AA%E5%8A%A8%E5%8C%96%E7%89%B9%E6%80%A7"><span class="nav-text">1.3.6 自动化特性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-%E4%B8%8E-Spring-Boot-%E9%9B%86%E6%88%90"><span class="nav-text">2. 快速入门 (与 Spring Boot 集成)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BE%9D%E8%B5%96"><span class="nav-text">2.1 环境与依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%B8%8E%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="nav-text">2.2 数据库表与实体类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Mapper%E6%8E%A5%E5%8F%A3"><span class="nav-text">2.3 Mapper接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-text">2.4 配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-text">2.5 单元测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%80%9A%E7%94%A8-CRUD-BaseMapper-IService"><span class="nav-text">3. 通用 CRUD (BaseMapper &amp; IService)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-BaseMapper-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%B1%82%E7%9A%84%E5%9F%BA%E7%9F%B3"><span class="nav-text">3.1 BaseMapper&lt;T&gt;: 数据访问层的基石</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="nav-text">3.1.1 如何使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%B8%80%E8%A7%88"><span class="nav-text">3.1.2 常用方法一览</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-IService-ServiceImpl-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%B1%82%E7%9A%84%E5%B0%81%E8%A3%85"><span class="nav-text">3.2 IService&lt;T&gt; &amp; ServiceImpl&lt;M, T&gt;: 业务逻辑层的封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="nav-text">3.2.1 如何使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-IService-%E5%A2%9E%E5%BC%BA%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">3.2.2 IService 增强的方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-BaseMapper-vs-IService-%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">3.3 BaseMapper vs IService (总结与最佳实践)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8-Wrapper"><span class="nav-text">4. 条件构造器 (Wrapper)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-QueryWrapper-UpdateWrapper"><span class="nav-text">4.1 QueryWrapper &amp; UpdateWrapper</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-QueryWrapper"><span class="nav-text">4.1.1 QueryWrapper&lt;T&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="nav-text">1. 核心方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">2. 使用示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-UpdateWrapper"><span class="nav-text">4.1.2 UpdateWrapper&lt;T&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95-1"><span class="nav-text">1. 核心方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-1"><span class="nav-text">2. 使用示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-LambdaQueryWrapper-LambdaUpdateWrapper"><span class="nav-text">4.2 LambdaQueryWrapper &amp; LambdaUpdateWrapper</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Lambda-Wrapper%EF%BC%9F"><span class="nav-text">4.2.1 为什么需要 Lambda Wrapper？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">4.2.2 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-LambdaQueryWrapper"><span class="nav-text">4.2.3 LambdaQueryWrapper&lt;T&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-4-LambdaUpdateWrapper"><span class="nav-text">4.2.4 LambdaUpdateWrapper&lt;T&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-5-%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">4.2.5 总结与最佳实践</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-text">4.3 常用查询方法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E6%9F%A5%E8%AF%A2%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1-selectOne"><span class="nav-text">4.3.1 查询单个对象: selectOne()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%E6%9F%A5%E8%AF%A2%E5%AF%B9%E8%B1%A1%E5%88%97%E8%A1%A8-selectList"><span class="nav-text">4.3.2 查询对象列表: selectList()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-%E6%9F%A5%E8%AF%A2%E8%AE%B0%E5%BD%95%E6%80%BB%E6%95%B0-selectCount"><span class="nav-text">4.3.3 查询记录总数: selectCount()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-4-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2-selectPage"><span class="nav-text">4.3.4 分页查询: selectPage()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-5-%E6%A3%80%E6%9F%A5%E5%AD%98%E5%9C%A8%E6%80%A7-exists-MP-3-5-3-%E7%89%88%E6%9C%AC"><span class="nav-text">4.3.5 检查存在性: exists() (MP 3.5.3+ 版本)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%A0%B8%E5%BF%83%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="nav-text">5. 核心插件机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6-PaginationInnerInterceptor"><span class="nav-text">5.1 分页插件 (PaginationInnerInterceptor)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%EF%BC%9F"><span class="nav-text">5.1.1 为什么需要分页插件？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-%E6%8F%92%E4%BB%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="nav-text">5.1.2 插件的核心原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE-Spring-Boot"><span class="nav-text">5.1.3 如何配置 (Spring Boot)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="nav-text">5.1.4 如何使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-5-%E6%80%BB%E7%BB%93%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">5.1.5 总结与注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E4%B9%90%E8%A7%82%E9%94%81%E6%8F%92%E4%BB%B6-OptimisticLockerInnerInterceptor"><span class="nav-text">5.2 乐观锁插件 (OptimisticLockerInnerInterceptor)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">5.2.1 乐观锁的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-%E5%A6%82%E4%BD%95%E5%9C%A8-MyBatis-Plus-%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="nav-text">5.2.2 如何在 MyBatis-Plus 中使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">5.2.3 使用示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-4-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">5.2.4 适用场景与注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8-AutoGenerator"><span class="nav-text">6. 代码生成器 (AutoGenerator)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E4%BC%98%E5%8A%BF"><span class="nav-text">6.1 核心功能与优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="nav-text">6.2 环境准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-text">6.3 示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3"><span class="nav-text">6.4 核心配置详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-1-GlobalConfig-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE"><span class="nav-text">6.4.1 GlobalConfig (全局配置)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-2-PackageConfig-%E5%8C%85%E9%85%8D%E7%BD%AE"><span class="nav-text">6.4.2 PackageConfig (包配置)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-3-StrategyConfig-%E7%AD%96%E7%95%A5%E9%85%8D%E7%BD%AE"><span class="nav-text">6.4.3 StrategyConfig (策略配置)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%80%9A%E7%94%A8%E7%AD%96%E7%95%A5"><span class="nav-text">1. 通用策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Entity-%E7%AD%96%E7%95%A5-entityBuilder"><span class="nav-text">2. Entity 策略 (entityBuilder)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Controller-%E7%AD%96%E7%95%A5-controllerBuilder"><span class="nav-text">3. Controller 策略 (controllerBuilder)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-Service-%E7%AD%96%E7%95%A5-serviceBuilder"><span class="nav-text">4. Service 策略 (serviceBuilder)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-%E8%BF%9B%E9%98%B6%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">6.5 进阶技巧与最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-1-%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%94%9F%E6%88%90"><span class="nav-text">6.5.1 交互式生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF"><span class="nav-text">6.5.2 自定义模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-3-%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97"><span class="nav-text">6.5.3 避坑指南</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="nav-text">7. 高级特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4"><span class="nav-text">7.1 逻辑删除</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4%EF%BC%9F"><span class="nav-text">7.1.1 什么是逻辑删除？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4%EF%BC%9F"><span class="nav-text">7.1.2 为什么使用逻辑删除？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-3-MyBatis-Plus-%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">7.1.3 MyBatis-Plus 中的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-4-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-text">7.1.4 如何配置和使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-5-%E5%AE%9E%E9%99%85%E6%95%88%E6%9E%9C"><span class="nav-text">7.1.5 实际效果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-6-%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2%E8%A2%AB%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-text">7.1.6 如何查询被逻辑删除的数据？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85-MetaObjectHandler"><span class="nav-text">7.2 自动填充 (MetaObjectHandler)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="nav-text">7.2.1 核心思想与原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-2-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="nav-text">7.2.2 如何使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-3-%E5%AE%9E%E9%99%85%E6%95%88%E6%9E%9C"><span class="nav-text">7.2.3 实际效果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-4-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%93%8D%E4%BD%9C%E4%BA%BA"><span class="nav-text">7.2.4 获取当前操作人</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E4%B8%BB%E9%94%AE%E7%AD%96%E7%95%A5"><span class="nav-text">7.3 主键策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">7.3.1 简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-2-%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="nav-text">7.3.2 配置方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-3-%E6%A0%B8%E5%BF%83%E4%B8%BB%E9%94%AE%E7%AD%96%E7%95%A5%E8%AF%A6%E8%A7%A3"><span class="nav-text">7.3.3 核心主键策略详解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-IdType-AUTO-%E6%95%B0%E6%8D%AE%E5%BA%93ID%E8%87%AA%E5%A2%9E"><span class="nav-text">1. IdType.AUTO (数据库ID自增)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-IdType-ASSIGN-ID-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95-%E9%BB%98%E8%AE%A4-%E6%8E%A8%E8%8D%90"><span class="nav-text">2. IdType.ASSIGN_ID (雪花算法, 默认&#x2F;推荐)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-IdType-ASSIGN-UUID-UUID"><span class="nav-text">3. IdType.ASSIGN_UUID (UUID)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-IdType-INPUT-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5"><span class="nav-text">4. IdType.INPUT (用户输入)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-IdType-NONE-%E6%97%A0%E7%8A%B6%E6%80%81"><span class="nav-text">5. IdType.NONE (无状态)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-IdType-SEQUENCE-%E5%BA%8F%E5%88%97"><span class="nav-text">6. IdType.SEQUENCE (序列)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-4-%E5%85%A8%E5%B1%80%E4%B8%BB%E9%94%AE%E7%AD%96%E7%95%A5%E9%85%8D%E7%BD%AE"><span class="nav-text">7.3.4 全局主键策略配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-5-%E7%AD%96%E7%95%A5%E9%80%89%E5%9E%8B%E6%80%BB%E7%BB%93"><span class="nav-text">7.3.5 策略选型总结</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81JPA-Hibernate"><span class="nav-text">四、JPA &amp; Hibernate</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%9E%B6%E6%9E%84%E5%AE%9A%E4%BD%8D"><span class="nav-text">1. 核心概念与架构定位</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-JPA-Jakarta-Persistence-API"><span class="nav-text">1.1 JPA (Jakarta Persistence API)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Hibernate"><span class="nav-text">1.2 Hibernate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E6%B7%B1%E5%BA%A6%E5%AF%B9%E6%AF%94"><span class="nav-text">1.3 深度对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">2. 核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%AE%9E%E4%BD%93-Entity"><span class="nav-text">2.1 实体 (Entity)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-EntityManagerFactory-%E5%AE%9E%E4%BD%93%E7%AE%A1%E7%90%86%E5%99%A8%E5%B7%A5%E5%8E%82"><span class="nav-text">2.2 EntityManagerFactory (实体管理器工厂)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-EntityManager-%E5%AE%9E%E4%BD%93%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-text">2.3 EntityManager (实体管理器)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87-Persistence-Context"><span class="nav-text">2.4 持久化上下文 (Persistence Context)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E5%AE%9E%E4%BD%93%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-Entity-Lifecycle"><span class="nav-text">2.5 实体生命周期 (Entity Lifecycle)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E4%BA%8B%E5%8A%A1-Transaction"><span class="nav-text">2.6 事务 (Transaction)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Spring-Data-JPA-%E5%BF%AB%E9%80%9F%E5%AE%9E%E6%88%98"><span class="nav-text">3. Spring Data JPA 快速实战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BE%9D%E8%B5%96"><span class="nav-text">3.1 环境与依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="nav-text">3.2 工程化配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BD%93%E7%B1%BB-Entity"><span class="nav-text">3.3 创建实体类 (Entity)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%88%9B%E5%BB%BA-Repository-%E6%8E%A5%E5%8F%A3"><span class="nav-text">3.4 创建 Repository 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-text">3.5 单元测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%AE%9E%E4%BD%93%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84"><span class="nav-text">4. 实体关系映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">4.1 基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%A4%9A%E5%AF%B9%E4%B8%80-ManyToOne-%E4%B8%80%E5%AF%B9%E5%A4%9A-OneToMany"><span class="nav-text">4.2 多对一 (ManyToOne) &amp; 一对多 (OneToMany)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E4%B8%80%E5%AF%B9%E4%B8%80-OneToOne"><span class="nav-text">4.3 一对一 (OneToOne)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9C%BA%E6%99%AF"><span class="nav-text">4.3.1 概念与场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%A4%96%E9%94%AE%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="nav-text">4.3.2 代码实现（外键方式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-%E6%A0%B8%E5%BF%83%E9%99%B7%E9%98%B1%EF%BC%9A%E6%87%92%E5%8A%A0%E8%BD%BD%E5%A4%B1%E6%95%88"><span class="nav-text">4.3.3 核心陷阱：懒加载失效</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-4-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">4.3.4 解决方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E5%A4%9A%E5%AF%B9%E5%A4%9A-ManyToMany"><span class="nav-text">4.4 多对多 (ManyToMany)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9C%BA%E6%99%AF"><span class="nav-text">4.4.1 概念与场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-%E6%A0%87%E5%87%86%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BD%BF%E7%94%A8-ManyToMany%EF%BC%89"><span class="nav-text">4.4.2 标准实现（使用@ManyToMany）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-%E5%B7%A5%E7%A8%8B%E9%99%B7%E9%98%B1%EF%BC%9A%E9%9A%90%E5%BD%A2%E7%9A%84%E4%B8%AD%E9%97%B4%E8%A1%A8"><span class="nav-text">4.4.3 工程陷阱：隐形的中间表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-4-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E6%8B%86%E5%88%86%E4%B8%BA%E4%B8%A4%E4%B8%AA-OneToMany"><span class="nav-text">4.4.4 解决方案：拆分为两个 OneToMany</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C-Cascade-%E5%86%B3%E7%AD%96%E6%8C%87%E5%8D%97"><span class="nav-text">4.5 级联操作 (Cascade) 决策指南</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">4.6 总结与最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-1-%E6%8A%93%E5%8F%96%E7%AD%96%E7%95%A5%EF%BC%9A%E5%85%A8%E5%B1%80%E6%87%92%E5%8A%A0%E8%BD%BD-Global-Lazy-Loading"><span class="nav-text">4.6.1 抓取策略：全局懒加载 (Global Lazy Loading)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-2-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%98%E5%85%88%E7%94%A8-Set-%E8%80%8C%E9%9D%9E-List%EF%BC%9F"><span class="nav-text">4.6.2 集合类型选择：为什么优先用 Set 而非 List？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-3-%E5%8F%8C%E5%90%91%E5%85%B3%E7%B3%BB%E7%9A%84%E7%BB%B4%E6%8A%A4-Ownership-Consistency"><span class="nav-text">4.6.3 双向关系的维护 (Ownership &amp; Consistency)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-4-%E7%BA%A7%E8%81%94-Cascade-%E7%9A%84%E7%BA%A2%E7%BA%BF"><span class="nav-text">4.6.4 级联 (Cascade) 的红线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-5-%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E5%9C%A8-toString-equals-hashCode-%E4%B8%AD%E5%BC%95%E7%94%A8%E5%85%B3%E8%81%94%E5%AD%97%E6%AE%B5"><span class="nav-text">4.6.5 永远不要在 toString() &#x2F; equals() &#x2F; hashCode() 中引用关联字段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-JPQL-Java-Persistence-Query-Language"><span class="nav-text">5. JPQL (Java Persistence Query Language)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E4%BB%80%E4%B9%88%E6%98%AF-JPQL%EF%BC%9F"><span class="nav-text">5.1 什么是 JPQL？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">5.2 核心优势与底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%B9%E8%A8%80%E6%97%A0%E5%85%B3%E6%80%A7-Dialect-Agnostic"><span class="nav-text">5.2.1 数据库方言无关性 (Dialect Agnostic)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-%E6%9E%81%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-text">5.2.2 极致的性能优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3-%E7%BA%AF%E7%B2%B9%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-Object-Oriented"><span class="nav-text">5.2.3 纯粹的面向对象 (Object-Oriented)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-4-%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2%E8%83%BD%E5%8A%9B"><span class="nav-text">5.2.4 安全性与复杂查询能力</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-JPQL-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-text">5.3 JPQL 基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1-SELECT-%E6%9F%A5%E8%AF%A2"><span class="nav-text">5.3.1 SELECT 查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-UPDATE-%E5%92%8C-DELETE-%E6%9F%A5%E8%AF%A2"><span class="nav-text">5.3.2 UPDATE 和 DELETE 查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2-JOIN"><span class="nav-text">5.4 连接查询 (JOIN)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E5%9C%A8-Spring-Data-JPA-%E4%B8%AD%E4%BD%BF%E7%94%A8-JPQL"><span class="nav-text">5.5 在 Spring Data JPA 中使用 JPQL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Spring-Data-JPA"><span class="nav-text">6. Spring Data JPA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E4%BB%80%E4%B9%88%E6%98%AF-Spring-Data-JPA%EF%BC%9F"><span class="nav-text">6.1 什么是 Spring Data JPA？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E4%B8%8E%E4%BC%98%E5%8A%BF"><span class="nav-text">6.2 核心特性与优势</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1-%E5%BC%BA%E5%A4%A7%E7%9A%84-Repository-%E6%8A%BD%E8%B1%A1-JpaRepository"><span class="nav-text">6.2.1 强大的 Repository 抽象 (JpaRepository)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2-%E6%96%B9%E6%B3%95%E5%91%BD%E5%90%8D%E6%9F%A5%E8%AF%A2-Query-Methods-Derived-Queries"><span class="nav-text">6.2.2 方法命名查询 (Query Methods &#x2F; Derived Queries)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-3-%E4%BD%BF%E7%94%A8-Query-%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9F%A5%E8%AF%A2"><span class="nav-text">6.2.3 使用 @Query 注解自定义查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-4-%E5%8A%A8%E6%80%81%E6%9F%A5%E8%AF%A2%E6%94%AF%E6%8C%81-JPA-Criteria-API-QueryDSL"><span class="nav-text">6.2.4 动态查询支持 (JPA Criteria API &amp; QueryDSL)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-5-%E7%AE%80%E5%8C%96%E7%9A%84%E5%88%86%E9%A1%B5%E4%B8%8E%E6%8E%92%E5%BA%8F"><span class="nav-text">6.2.5 简化的分页与排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E4%B8%8E-MyBatis-MyBatis-Plus-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-text">6.3 与 MyBatis&#x2F;MyBatis-Plus 的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E6%80%BB%E7%BB%93"><span class="nav-text">6.4 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">7. 适用场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81ORM-%E8%BF%9B%E9%98%B6%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">五、ORM 进阶与最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-N-1-%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98"><span class="nav-text">1. N+1 查询问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-MyBatis-%E4%B8%8E-MyBatis-Plus-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">1.1 MyBatis 与 MyBatis-Plus 解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E5%9C%A8-MyBatis-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F-N-1-%E9%97%AE%E9%A2%98"><span class="nav-text">1.1.1 在 MyBatis 中如何产生 N+1 问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-MyBatis-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">1.1.2 MyBatis 解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9A%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2-Join-Query"><span class="nav-text">方案一：连接查询 (Join Query)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9A%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD-Nested-Selects-Lazy-Loading"><span class="nav-text">方案二：分步查询 + 延迟加载 (Nested Selects + Lazy Loading)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-MyBatis-Plus-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">1.1.3 MyBatis-Plus 解决方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-JPA-Hibernate-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">1.2 JPA&#x2F;Hibernate 解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E5%9C%A8-JPA-Hibernate-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F-N-1-%E9%97%AE%E9%A2%98"><span class="nav-text">1.2.1 在 JPA&#x2F;Hibernate 中如何产生 N+1 问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-JPA-Hibernate-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">1.2.2 JPA&#x2F;Hibernate 解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9AJPQL-JOIN-FETCH-%E6%9C%80%E5%B8%B8%E7%94%A8%EF%BC%8C%E6%9C%80%E6%8E%A8%E8%8D%90"><span class="nav-text">方案一：JPQL JOIN FETCH (最常用，最推荐)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9A%E5%AE%9E%E4%BD%93%E5%9B%BE-EntityGraph"><span class="nav-text">方案二：实体图 (@EntityGraph)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%B8%89%EF%BC%9A%E6%89%B9%E5%A4%84%E7%90%86%E6%8A%93%E5%8F%96-BatchSize"><span class="nav-text">方案三：批处理抓取 (@BatchSize)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="nav-text">2. 缓存机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-text">2.1 一级缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="nav-text">2.1.1 定义与核心特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-MyBatis-%E4%B8%AD%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-text">2.1.2 MyBatis 中的一级缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-JPA-Hibernate-%E4%B8%AD%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-text">2.1.3 JPA&#x2F;Hibernate 中的一级缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-text">2.1.4 一级缓存的意义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-text">2.2 二级缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="nav-text">2.2.1 定义与核心特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-MyBatis-%E4%B8%AD%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-text">2.2.2 MyBatis 中的二级缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%BC%80%E5%90%AF%E6%AD%A5%E9%AA%A4"><span class="nav-text">1. 开启步骤:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">2. 工作流程:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88"><span class="nav-text">3. 缓存失效:</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-JPA-Hibernate-%E4%B8%AD%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-text">2.2.3 JPA&#x2F;Hibernate 中的二级缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%BC%80%E5%90%AF%E6%AD%A5%E9%AA%A4-1"><span class="nav-text">1. 开启步骤:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Hibernate-%E7%BC%93%E5%AD%98%E5%B9%B6%E5%8F%91%E7%AD%96%E7%95%A5-CacheConcurrencyStrategy"><span class="nav-text">2. Hibernate 缓存并发策略 (CacheConcurrencyStrategy):</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98-Query-Cache"><span class="nav-text">3. 查询缓存 (Query Cache)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E7%BC%93%E5%AD%98%E7%9A%84%E6%84%8F%E4%B9%89%E3%80%81%E9%A3%8E%E9%99%A9%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="nav-text">2.3 缓存的意义、风险与配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E7%BC%93%E5%AD%98%E7%9A%84%E6%84%8F%E4%B9%89-Why-use-cache"><span class="nav-text">2.3.1 缓存的意义 (Why use cache?)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E7%BC%93%E5%AD%98%E7%9A%84%E9%A3%8E%E9%99%A9%E4%B8%8E%E6%8C%91%E6%88%98-Risks-and-Challenges"><span class="nav-text">2.3.2 缓存的风险与挑战 (Risks and Challenges)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98"><span class="nav-text">2.3.3 如何合理配置与使用缓存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-text">3. 事务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-ORM%E6%A1%86%E6%9E%B6%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90"><span class="nav-text">3.1 ORM框架与事务如何集成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E7%9A%84%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3"><span class="nav-text">3.1.1 事务管理的核心职责</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E9%9B%86%E6%88%90%E6%96%B9%E5%BC%8F"><span class="nav-text">3.1.2 集成方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1-Programmatic-Transaction-Management"><span class="nav-text">1. 编程式事务 (Programmatic Transaction Management)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1-Declarative-Transaction-Management-%E4%B8%BB%E6%B5%81%E6%96%B9%E5%BC%8F"><span class="nav-text">2. 声明式事务 (Declarative Transaction Management) - (主流方式)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-%E6%80%BB%E7%BB%93"><span class="nav-text">3.1.3 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">3.2 声明式事务的工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-text">3.2.1 核心组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E8%AF%A6%E7%BB%86%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">3.2.2 详细工作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E4%B8%BA%E4%BB%80%E4%B9%88-Transactional-%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="nav-text">3.2.3 为什么 @Transactional 会失效？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="nav-text">3.3 事务的隔离级别与传播行为</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-Isolation-Level"><span class="nav-text">3.3.1 事务的隔离级别 (Isolation Level)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA-Propagation-Behavior"><span class="nav-text">3.3.2 事务的传播行为 (Propagation Behavior)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-REQUIRED-%E9%BB%98%E8%AE%A4"><span class="nav-text">1. REQUIRED (默认)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-REQUIRES-NEW"><span class="nav-text">2. REQUIRES_NEW</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/ORM%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="ORM框架 | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ORM框架
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-24 15:23:30" itemprop="dateCreated datePublished" datetime="2025-09-24T15:23:30+08:00">2025-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-12 20:33:03" itemprop="dateModified" datetime="2025-12-12T20:33:03+08:00">2025-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">数据库与持久化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-核心概念与本质"><a href="#1-核心概念与本质" class="headerlink" title="1. 核心概念与本质"></a>1. 核心概念与本质</h2><h3 id="1-1-什么是ORM？"><a href="#1-1-什么是ORM？" class="headerlink" title="1.1 什么是ORM？"></a>1.1 什么是ORM？</h3><p><strong>ORM (Object-Relational Mapping，对象关系映射)</strong> 是一种在<strong>关系型数据库</strong>和<strong>面向对象编程语言</strong>之间建立桥梁的技术规范。它充当了应用程序与数据库之间的<strong>中间件</strong>，负责数据的自动持久化与还原。</p>
<ul>
<li><strong>O (Object)</strong>: 也就是 Java POJO（领域模型），关注业务逻辑。</li>
<li><strong>R (Relational)</strong>: 关系型数据库（Schema），关注数据存储与一致性。</li>
<li><strong>M (Mapping)</strong>: 映射元数据，定义了“类⇋表”、“属性⇋列”的转换规则。</li>
</ul>
<hr>
<h3 id="1-2-解决的核心通点"><a href="#1-2-解决的核心通点" class="headerlink" title="1.2 解决的核心通点"></a>1.2 解决的核心通点</h3><p>ORM 的诞生是为了解决 <strong>对象模型</strong> 与 <strong>关系模型</strong> 之间的 <strong>Object-Relational Impedance Mismatch（阻抗不匹配）</strong>，主要体现在以下四个维度：</p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">面向对象 (Java)</th>
<th align="left">关系数据库 (SQL)</th>
<th align="left">ORM 的解决方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>粒度</strong></td>
<td align="left">类设计细腻，有组合关系（如 User 类包含 Address 类）</td>
<td align="left">表结构扁平，列数有限</td>
<td align="left">将多个类映射到一张表，或拆分映射</td>
</tr>
<tr>
<td align="left"><strong>继承</strong></td>
<td align="left">天然支持类继承、多态</td>
<td align="left">无继承概念</td>
<td align="left">提供单表继承、连接表继承等策略</td>
</tr>
<tr>
<td align="left"><strong>标识</strong></td>
<td align="left">内存地址 (<code>==</code>) 或 <code>equals</code></td>
<td align="left">主键 (Primary Key)</td>
<td align="left">统一管理主键生成策略</td>
</tr>
<tr>
<td align="left"><strong>关联</strong></td>
<td align="left">对象引用 (Object Reference)</td>
<td align="left">外键 (Foreign Key)</td>
<td align="left">自动处理外键关联与级联操作</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-技术演进"><a href="#2-技术演进" class="headerlink" title="2. 技术演进"></a>2. 技术演进</h2><h3 id="2-1-原生-JDBC-的痛点"><a href="#2-1-原生-JDBC-的痛点" class="headerlink" title="2.1 原生 JDBC 的痛点"></a>2.1 原生 JDBC 的痛点</h3><p>在没有 ORM 之前，数据持久化层（DAO）充满了大量的<strong>样板代码（Boilerplate Code）</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统 JDBC 的痛点示例</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, username, pwd FROM t_user WHERE id = ?&quot;</span>;</span><br><span class="line">    <span class="comment">// ... 省略 Connection 获取 ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line">        <span class="comment">// 痛点1: 索引设参，类型不安全且易错位</span></span><br><span class="line">        ps.setLong(<span class="number">1</span>, id); </span><br><span class="line">        rs = ps.executeQuery();</span><br><span class="line">        <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            <span class="comment">// 痛点2: 硬编码映射，列名修改需改代码，无驼峰转换</span></span><br><span class="line">            u.setId(rs.getLong(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">            u.setUsername(rs.getString(<span class="string">&quot;username&quot;</span>)); </span><br><span class="line">            <span class="keyword">return</span> u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">// 痛点3: 强制捕获受检异常，污染业务代码</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 痛点4: 必须手动关闭资源，极易导致内存/连接泄漏</span></span><br><span class="line">        DBUtils.close(rs, ps, conn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-ORM-的解放"><a href="#2-2-ORM-的解放" class="headerlink" title="2.2 ORM 的解放"></a>2.2 ORM 的解放</h3><p>使用 ORM 框架后，DAO 层回归业务本质。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ORM 方式 (以 MyBatis-Plus 为例)</span></span><br><span class="line"><span class="comment">// 仅需一行代码，框架自动处理：连接获取 -&gt; SQL生成 -&gt; 参数设置 -&gt; 结果映射 -&gt; 连接释放</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">101L</span>);</span><br></pre></td></tr></table></figure>

<p><strong>核心价值：</strong></p>
<ol>
<li><strong>消灭硬编码</strong>：解耦 SQL 与 Java 代码。</li>
<li><strong>自动映射</strong>：自动处理结果集 (<code>ResultSet</code>) 到 Java Bean 的属性填充（如自动驼峰转换）。</li>
<li><strong>资源托管</strong>：框架自动管理连接池的借出与归还，杜绝资源泄漏。</li>
</ol>
<hr>
<h2 id="3-Java-ORM-生态的两大流派"><a href="#3-Java-ORM-生态的两大流派" class="headerlink" title="3. Java ORM 生态的两大流派"></a>3. Java ORM 生态的两大流派</h2><p>在 Java 领域，根据对 SQL 的封装程度，主要分为两大流派。</p>
<h3 id="3-1-全自动-ORM-Full-Automation"><a href="#3-1-全自动-ORM-Full-Automation" class="headerlink" title="3.1 全自动 ORM (Full Automation)"></a>3.1 全自动 ORM (Full Automation)</h3><ul>
<li><strong>代表框架</strong>：<strong>Hibernate</strong>, <strong>Spring Data JPA</strong> (基于 JPA 规范)</li>
<li><strong>核心理念</strong>：将数据库视为对象的存储库。开发者操作对象（<code>save</code>, <code>delete</code>），框架自动生成 SQL。</li>
<li><strong>特点</strong>：<ul>
<li><strong>深度封装</strong>：引入了一级&#x2F;二级缓存、脏检查（Dirty Checking）、懒加载（Lazy Loading）等高级特性。</li>
<li><strong>移植性强</strong>：基于 HQL&#x2F;JPQL 抽象查询语言，切换数据库只需修改方言（Dialect）配置。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<strong>OA、ERP、CRM 等企业级应用</strong>。这些系统业务逻辑复杂，表关联多，但并发量和数据规模相对可控，且对开发速度要求高。</li>
</ul>
<hr>
<h3 id="3-2-半自动-ORM-SQL-Mapper"><a href="#3-2-半自动-ORM-SQL-Mapper" class="headerlink" title="3.2 半自动 ORM &#x2F; SQL Mapper"></a>3.2 半自动 ORM &#x2F; SQL Mapper</h3><ul>
<li><strong>代表框架</strong>：<strong>MyBatis</strong>, <strong>MyBatis-Plus</strong></li>
<li><strong>核心理念</strong>：SQL 仍然是核心，框架仅负责<strong>参数输入</strong>和<strong>结果映射</strong>的自动化。</li>
<li><strong>特点</strong>：<ul>
<li><strong>SQL 可控性</strong>：开发者手写 SQL，能够进行极致的性能调优（如索引优化、复杂 Join）。</li>
<li><strong>学习成本低</strong>：没有复杂的生命周期管理，所见即所得。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<strong>互联网、电商、金融高并发系统</strong>。这些系统对 SQL 执行效率要求极高，通常禁止三表以上关联，且数据库架构可能经常变动。</li>
</ul>
<hr>
<h3 id="3-3-流派对比表"><a href="#3-3-流派对比表" class="headerlink" title="3.3 流派对比表"></a>3.3 流派对比表</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Hibernate &#x2F; JPA (全自动)</th>
<th align="left">MyBatis (半自动)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SQL 编写</strong></td>
<td align="left">框架自动生成 (HQL)</td>
<td align="left">开发者手写 &#x2F; XML &#x2F; 注解</td>
</tr>
<tr>
<td align="left"><strong>上手难度</strong></td>
<td align="left">陡峭 (需理解实体状态、缓存机制)</td>
<td align="left">简单 (懂 SQL 即可)</td>
</tr>
<tr>
<td align="left"><strong>性能优化</strong></td>
<td align="left">较难 (需精通框架底层)</td>
<td align="left">容易 (直接优化 SQL)</td>
</tr>
<tr>
<td align="left"><strong>移植性</strong></td>
<td align="left">极好 (Dialect 屏蔽差异)</td>
<td align="left">较差 (SQL 依赖特定 DB 语法)</td>
</tr>
<tr>
<td align="left"><strong>复杂查询</strong></td>
<td align="left">较繁琐 (且生成的 SQL 往往非最优)</td>
<td align="left">灵活强大</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-ORM-的优缺点辩证分析"><a href="#4-ORM-的优缺点辩证分析" class="headerlink" title="4. ORM 的优缺点辩证分析"></a>4. ORM 的优缺点辩证分析</h2><h3 id="4-1-核心优势"><a href="#4-1-核心优势" class="headerlink" title="4.1 核心优势"></a>4.1 核心优势</h3><ul>
<li><strong>研发效能提升</strong>：聚焦业务逻辑，CRUD 操作全自动化，代码量减少 70% 以上。</li>
<li><strong>架构解耦</strong>：数据访问层（DAO）与业务逻辑层完全分离，数据库表结构微调对业务代码影响较小。</li>
<li><strong>高级特性</strong>：原生支持事务传播、连接池管理、预编译防注入、缓存机制等。</li>
</ul>
<hr>
<h3 id="4-2-潜在劣势"><a href="#4-2-潜在劣势" class="headerlink" title="4.2 潜在劣势"></a>4.2 潜在劣势</h3><ul>
<li><strong>性能黑盒与开销</strong>：<ul>
<li><strong>反射与动态代理</strong>：映射过程有一定 CPU 开销（通常可忽略）。</li>
<li><strong>N+1 问题</strong>：这是 ORM 最经典的性能陷阱（例：查询 10 个用户，遍历时又发出了 10 条查询部门的 SQL），需通过 <code>Join Fetch</code> 或批量查询解决。</li>
</ul>
</li>
<li><strong>复杂查询的局限</strong>：在处理复杂的统计报表、多维分析时，面向对象的查询语法（JPQL&#x2F;HQL）往往显得笨重且效率低下，不如原生 SQL 直接。</li>
<li><strong>抽象泄漏</strong>：开发者若不懂底层 SQL 原理，完全依赖框架，一旦遇到慢查询很难排查。</li>
</ul>
<hr>
<h2 id="5-总结与选型建议"><a href="#5-总结与选型建议" class="headerlink" title="5. 总结与选型建议"></a>5. 总结与选型建议</h2><blockquote>
<p><strong>没有最好的框架，只有最适合业务场景的框架。</strong></p>
</blockquote>
<ol>
<li><strong>初创公司&#x2F;快速原型开发</strong>：首选 <strong>Spring Data JPA</strong>。开发速度快，修改需求响应灵活。</li>
<li><strong>大型互联网&#x2F;高并发系统</strong>：首选 <strong>MyBatis &#x2F; MyBatis-Plus</strong>。SQL 必须完全掌控在 DBA 或开发者手中，杜绝不可控的慢 SQL 拖垮数据库。</li>
<li><strong>混合模式</strong>：在很多现代项目中，也会采用 <strong>Spring Data JPA (处理简单增删改)</strong> + <strong>MyBatis (处理复杂报表查询)</strong> 的组合模式。</li>
</ol>
<hr>
<hr>
<h1 id="二、MyBatis"><a href="#二、MyBatis" class="headerlink" title="二、MyBatis"></a>二、MyBatis</h1><h2 id="1-MyBatis简介与核心思想"><a href="#1-MyBatis简介与核心思想" class="headerlink" title="1. MyBatis简介与核心思想"></a>1. MyBatis简介与核心思想</h2><h3 id="1-1-定义与定位"><a href="#1-1-定义与定位" class="headerlink" title="1.1 定义与定位"></a>1.1 定义与定位</h3><h4 id="1-1-1-什么是MyBatis？"><a href="#1-1-1-什么是MyBatis？" class="headerlink" title="1.1.1 什么是MyBatis？"></a>1.1.1 什么是MyBatis？</h4><p><strong>MyBatis</strong> 是一款优秀的持久层框架，前身是 Apache iBatis。它本质上是一个 <strong>“SQL 映射器” (SQL Mapper)</strong>，属于 <strong>半自动 ORM (Semi-ORM)</strong> 框架。</p>
<p>它在 Java 对象和关系型数据库之间建立了一个<strong>可配置</strong>的通道，既保留了 JDBC 的灵活性，又屏蔽了其繁琐的样板代码（连接管理、结果集解析等）。</p>
<hr>
<h4 id="1-1-2-为什么它是“半自动”的？"><a href="#1-1-2-为什么它是“半自动”的？" class="headerlink" title="1.1.2 为什么它是“半自动”的？"></a>1.1.2 为什么它是“半自动”的？</h4><p>与 Hibernate&#x2F;JPA 的“全自动”相比，MyBatis 的核心权衡（Trade-off）在于：</p>
<ul>
<li><strong>不屏蔽 SQL</strong>：它不自动生成 SQL，而是让开发者直接编写 SQL。</li>
<li><strong>只做映射</strong>：它专注于负责将 SQL 执行前的数据（入参）和执行后的数据（结果集）映射到 Java 对象。</li>
</ul>
<hr>
<h3 id="1-2-核心设计哲学"><a href="#1-2-核心设计哲学" class="headerlink" title="1.2 核心设计哲学"></a>1.2 核心设计哲学</h3><h4 id="1-2-1-“SQL-优先”-SQL-Centric"><a href="#1-2-1-“SQL-优先”-SQL-Centric" class="headerlink" title="1.2.1 “SQL 优先” (SQL-Centric)"></a>1.2.1 “SQL 优先” (SQL-Centric)</h4><p>MyBatis 认为 SQL 是开发者的核心资产，而不是一种应当被屏蔽的底层细节。</p>
<ul>
<li><strong>痛点解决</strong>：在处理亿级数据、分库分表、复杂报表统计时，全自动 ORM 生成的 SQL 往往不够高效且难以优化。</li>
<li><strong>设计目的</strong>：赋予开发者对 SQL 的 <strong>100% 控制权</strong>。开发者可以自由使用数据库的特定功能（如 MySQL 的 <code>FORCE INDEX</code>、Oracle 的窗口函数）或编写复杂的连接查询（Join）。</li>
<li><strong>适用场景</strong>：<strong>互联网高并发系统</strong>、<strong>复杂业务报表</strong>、<strong>对 DB 性能极其敏感的场景</strong>。</li>
</ul>
<hr>
<h4 id="1-2-2-接口绑定与动静分离-Interface-Binding"><a href="#1-2-2-接口绑定与动静分离-Interface-Binding" class="headerlink" title="1.2.2 接口绑定与动静分离 (Interface Binding)"></a>1.2.2 接口绑定与动静分离 (Interface Binding)</h4><p>MyBatis 实现了 Java 代码与 SQL 语句的彻底解耦，并通过 <strong>动态代理</strong> 将二者绑定。</p>
<ul>
<li><strong>分离架构</strong>：<ul>
<li><strong>Mapper 接口 (Java)</strong>：定义业务行为（<code>What to do</code>）。</li>
<li><strong>Mapper XML (Config)</strong>：定义具体实现逻辑（<code>How to do</code>）。</li>
</ul>
</li>
<li><strong>底层机制</strong>：MyBatis 启动时，会扫描接口和 XML，利用 <strong>JDK 动态代理</strong> 为接口生成代理对象。开发者调用接口方法时，代理对象会自动定位并执行 XML 中对应的 SQL。</li>
<li><strong>优势</strong>：<ul>
<li><strong>代码纯净</strong>：Java 业务代码中无任何 SQL 字符串干扰。</li>
<li><strong>维护便利</strong>：SQL 集中在 XML 中管理，便于 DBA 审查和优化，甚至支持不重启服务热加载 SQL。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-3-强大的“动态-SQL”-Dynamic-SQL"><a href="#1-2-3-强大的“动态-SQL”-Dynamic-SQL" class="headerlink" title="1.2.3 强大的“动态 SQL” (Dynamic SQL)"></a>1.2.3 强大的“动态 SQL” (Dynamic SQL)</h4><p>这是 MyBatis 最强大的特性之一。它解决了很多传统 JDBC 中需要通过大量 <code>if-else</code> 和字符串拼接来构建查询条件的痛点。</p>
<ul>
<li><strong>原理</strong>：基于 OGNL 表达式，提供了一套类似 XML 标签的逻辑语法。</li>
<li><strong>常用标签</strong>：<ul>
<li><code>&lt;if&gt;</code> &#x2F; <code>&lt;choose&gt;</code>: 条件判断。</li>
<li><code>&lt;where&gt;</code> &#x2F; <code>&lt;set&gt;</code>: 智能处理 SQL 语法（自动去除多余的 <code>AND</code> 或逗号）。</li>
<li><code>&lt;foreach&gt;</code>: 处理 <code>IN</code> 查询或批量插入。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-4-强大的结果映射-ResultMap"><a href="#1-2-4-强大的结果映射-ResultMap" class="headerlink" title="1.2.4 强大的结果映射 (ResultMap)"></a>1.2.4 强大的结果映射 (ResultMap)</h4><p>虽然 SQL 是手写的，但 MyBatis 极其擅长处理 <strong>ResultSet</strong> 到 <strong>Java Object</strong> 的复杂映射，解决了“对象与关系的不匹配”问题。</p>
<ul>
<li><strong>ResultType (自动映射)</strong>：适用于字段名与属性名一致（或通过配置开启驼峰转换）的简单场景。</li>
<li><strong>ResultMap (手动精确映射)</strong>：MyBatis 的核心武器，解决复杂场景：<ol>
<li><strong>字段名不一致</strong>：数据库列叫 <code>u_name</code>，Java 属性叫 <code>username</code>。</li>
<li><strong>级联查询 (Association)</strong>：处理 <strong>一对一</strong> 关系（如：查询订单时同时查出所属用户）。</li>
<li><strong>集合查询 (Collection)</strong>：处理 <strong>一对多</strong> 关系（如：查询用户时同时查出他名下的所有订单）。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="2-核心架构与执行流程"><a href="#2-核心架构与执行流程" class="headerlink" title="2. 核心架构与执行流程"></a>2. 核心架构与执行流程</h2><h3 id="2-1-架构分层解析"><a href="#2-1-架构分层解析" class="headerlink" title="2.1 架构分层解析"></a>2.1 架构分层解析</h3><p>MyBatis 的核心组件可以分为三个层次：<strong>接口层</strong>、<strong>核心处理层</strong>、<strong>基础支撑层</strong>。</p>
<h4 id="2-1-1-接口层"><a href="#2-1-1-接口层" class="headerlink" title="2.1.1 接口层"></a>2.1.1 接口层</h4><p>这一层直接面向开发者，负责接收调用请求。</p>
<ul>
<li><strong>SqlSession (会话)</strong><ul>
<li><strong>定位</strong>：与数据库交互的<strong>顶层标准接口</strong>。</li>
<li><strong>关键特性</strong>：<ul>
<li><strong>非线程安全 (Thread Unsafe)</strong>：内部持有 JDBC <code>Connection</code>，绝不能跨线程共享或设为静态变量（必须<strong>Thread Confinement</strong>）。</li>
<li><strong>生命周期</strong>：<strong>Request 级</strong>。用完必须关闭（<code>try-with-resources</code>），否则导致连接泄漏。</li>
</ul>
</li>
<li><strong>职责</strong>：提供 CRUD API（如 <code>selectOne</code>）及事务控制。</li>
</ul>
</li>
<li><strong>Mapper接口 (Interface)</strong><ul>
<li><strong>定位</strong>：业务代码调用的入口。</li>
<li><strong>原理</strong>：通过 <strong>JDK 动态代理</strong> (<code>MapperProxy</code>) 将接口方法调用拦截并转发给 <code>SqlSession</code>。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-2-核心处理层"><a href="#2-1-2-核心处理层" class="headerlink" title="2.1.2 核心处理层"></a>2.1.2 核心处理层</h4><p>这一层负责 SQL 的解析、执行计划生成、缓存管理和插件调度。</p>
<ul>
<li><strong>Configuration (全局配置)</strong><ul>
<li><strong>定位</strong>：MyBatis 的<strong>上帝对象</strong>（单例）。</li>
<li><strong>内容</strong>：存储了 <code>mybatis-config.xml</code> 的所有设置、所有解析好的 SQL (<code>MappedStatement</code>)、类型别名等。</li>
<li><strong>生命周期</strong>：与应用生命周期一致。</li>
</ul>
</li>
<li><strong>SqlSessionFactory (工厂)</strong><ul>
<li><strong>模式</strong>：<strong>工厂模式</strong>。</li>
<li><strong>职责</strong>：负责生产 <code>SqlSession</code>。通常一个数据库对应一个全局单例工厂。</li>
</ul>
</li>
<li><strong>Executor (执行器)</strong><ul>
<li><strong>定位</strong>：<strong>核心调度器</strong>。<code>SqlSession</code> 只是门面，<code>Executor</code> 才是真正干活的。</li>
<li><strong>职责</strong>：<ul>
<li><strong>缓存管理</strong>：负责查询一级缓存（BaseExecutor）和二级缓存（CachingExecutor）。</li>
<li><strong>事务控制</strong>：Commit &#x2F; Rollback。</li>
</ul>
</li>
<li><strong>三种实现</strong>：<ul>
<li><code>SimpleExecutor</code>（默认）：每条 SQL 新建一个 Statement。</li>
<li><code>ReuseExecutor</code>：复用 Statement（连接池级别的复用）。</li>
<li><code>BatchExecutor</code>：批量执行（用于高性能数据导入）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>MappedStatement (SQL 元数据)</strong><ul>
<li><strong>定位</strong>：XML 中 <code>&lt;select&gt;</code>&#x2F;<code>&lt;update&gt;</code> 标签的内存封装。包含 SQL 源码、参数映射、结果映射配置。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-3-基础支撑层"><a href="#2-1-3-基础支撑层" class="headerlink" title="2.1.3 基础支撑层"></a>2.1.3 基础支撑层</h4><p>这一层负责最底层的 JDBC 交互，也是 <strong>MyBatis 插件 (Plugin)</strong> 能够拦截的 <strong>四大核心对象</strong>。</p>
<table>
<thead>
<tr>
<th align="left">组件名</th>
<th align="left">职责描述</th>
<th align="left">插件拦截场景示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>StatementHandler</strong></td>
<td align="left"><strong>JDBC 的直接操作者</strong>。负责创建 <code>Statement</code> (PreparedStatement) 并设置超时时间等。</td>
<td align="left"><strong>分页插件 (PageHelper)</strong>：在此拦截，修改 SQL 增加 <code>LIMIT</code>。</td>
</tr>
<tr>
<td align="left"><strong>ParameterHandler</strong></td>
<td align="left"><strong>参数设置器</strong>。负责将 Java 对象转换为 SQL 参数（处理 <code>?</code> 占位符）。</td>
<td align="left"><strong>加密插件</strong>：在此拦截，将参数加密后传入数据库。</td>
</tr>
<tr>
<td align="left"><strong>ResultSetHandler</strong></td>
<td align="left"><strong>结果集映射器</strong>。负责将 <code>ResultSet</code> 转换为 Java 对象。这是 MyBatis 最复杂的部分。</td>
<td align="left"><strong>脱敏插件</strong>：在此拦截，将查出的手机号中间四位变星号。</td>
</tr>
<tr>
<td align="left"><strong>TypeHandler</strong></td>
<td align="left"><strong>类型转换器</strong>。Java 类型 ↔↔ JDBC 类型（如 <code>String</code> ↔↔ <code>VARCHAR</code>）。</td>
<td align="left">处理枚举转换、JSON 字段存取。</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-2-全链路执行流程"><a href="#2-2-全链路执行流程" class="headerlink" title="2.2 全链路执行流程"></a>2.2 全链路执行流程</h3><h4 id="2-2-1-初始化阶段"><a href="#2-2-1-初始化阶段" class="headerlink" title="2.2.1 初始化阶段"></a>2.2.1 初始化阶段</h4><blockquote>
<p><em>系统启动时执行，耗时较长，只执行一次。</em></p>
</blockquote>
<ol>
<li><strong>加载配置</strong>：读取 <code>mybatis-config.xml</code> 和 Mapper XML。</li>
<li><strong>解析注册</strong>：<code>SqlSessionFactoryBuilder</code> 解析配置，将 XML 中的 SQL 解析为 <code>MappedStatement</code> 对象，注册到 <code>Configuration</code> 中。</li>
<li><strong>构建工厂</strong>：生成全局唯一的 <code>SqlSessionFactory</code>。</li>
</ol>
<hr>
<h4 id="2-2-2-代理阶段"><a href="#2-2-2-代理阶段" class="headerlink" title="2.2.2 代理阶段"></a>2.2.2 代理阶段</h4><blockquote>
<p><em>每次业务请求时执行。</em></p>
</blockquote>
<ol>
<li><strong>获取会话</strong>：<code>factory.openSession()</code> 创建 <code>SqlSession</code>（同时也初始化了 <code>Executor</code>）。</li>
<li><strong>获取代理</strong>：<code>session.getMapper(UserMapper.class)</code> 返回 JDK 动态代理对象 <code>MapperProxy</code>。</li>
<li><strong>方法拦截</strong>：调用 <code>userMapper.getById(1)</code> 时，<code>MapperProxy</code> 拦截调用，并根据方法签名找到对应的 <code>MappedStatement</code>。</li>
</ol>
<hr>
<h4 id="2-2-3-数据处理阶段"><a href="#2-2-3-数据处理阶段" class="headerlink" title="2.2.3 数据处理阶段"></a>2.2.3 数据处理阶段</h4><blockquote>
<p><em>核心链路，涉及数据库交互。</em></p>
</blockquote>
<ol>
<li><strong>执行器介入 (Executor)</strong>：<ul>
<li>查询 <strong>二级缓存</strong> (Global Cache)。</li>
<li>查询 <strong>一级缓存</strong> (Local Cache&#x2F;Session Cache)。</li>
<li>若未命中，决定直连数据库。</li>
</ul>
</li>
<li><strong>语句准备 (StatementHandler)</strong>：<ul>
<li><code>Executor</code> 创建 <code>StatementHandler</code>。</li>
<li><strong>关键点</strong>：此时 <strong>插件链 (InterceptorChain)</strong> 介入，插件有机会修改 SQL（如分页）。</li>
<li>获取 JDBC 连接 (<code>Connection</code>)，创建 <code>PreparedStatement</code>。</li>
</ul>
</li>
<li><strong>参数填充 (ParameterHandler)</strong>：<ul>
<li>调用 <code>ParameterHandler</code>。</li>
<li>利用 <code>TypeHandler</code> 将 Java 参数（如 <code>int 1</code>）填充到 SQL 的占位符 <code>?</code> 中。</li>
</ul>
</li>
<li><strong>执行 SQL (JDBC Driver)</strong>：<ul>
<li>调用底层 JDBC <code>ps.execute()</code> 发送 SQL 给数据库。</li>
</ul>
</li>
<li><strong>结果映射 (ResultSetHandler)</strong>：<ul>
<li>数据库返回 <code>ResultSet</code>。</li>
<li><code>ResultSetHandler</code> 遍历结果集，根据 <code>ResultMap</code> 的定义，利用 <code>TypeHandler</code> 将数据逐行转换为 Java POJO。</li>
</ul>
</li>
<li><strong>资源释放</strong>：<ul>
<li>结果返回给业务层。</li>
<li>关闭 <code>SqlSession</code>（归还连接给连接池）。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-快速入门-Standalone-模式"><a href="#3-快速入门-Standalone-模式" class="headerlink" title="3. 快速入门 (Standalone 模式)"></a>3. 快速入门 (Standalone 模式)</h2><blockquote>
<p><strong>前言</strong>：虽然在实际工作中我们几乎总是结合 Spring Boot 使用，但通过<strong>原生方式</strong>构建 MyBatis 应用，是理解其 <code>SessionFactory</code> <em>-&gt;</em> <code>Session</code> <em>-&gt;</em> <code>Executor</code> 生命周期的最佳途径。</p>
</blockquote>
<h3 id="3-1-环境与依赖准备"><a href="#3-1-环境与依赖准备" class="headerlink" title="3.1 环境与依赖准备"></a>3.1 环境与依赖准备</h3><p>创建一个标准的 Maven 项目。为了更贴近现代开发习惯，除了核心包，我们引入 Lombok 和 日志框架。</p>
<p><strong>pom.xml 核心依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- MyBatis 核心库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- MySQL 驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Lombok (减少样板代码) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Logback (查看 SQL 日志，调试必备) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-2-规范的工程目录结构"><a href="#3-2-规范的工程目录结构" class="headerlink" title="3.2 规范的工程目录结构"></a>3.2 规范的工程目录结构</h3><p>MyBatis 对配置文件的路径敏感，建议遵循 Maven 标准结构：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/main</span><br><span class="line">├── java</span><br><span class="line">│   └── com.example</span><br><span class="line">│       ├── model      // 存放 POJO (User.java)</span><br><span class="line">│       └── mapper     // 存放接口 (UserMapper.java)</span><br><span class="line">└── resources</span><br><span class="line">    ├── mybatis-config.xml        // 全局核心配置</span><br><span class="line">    └── com/example/mapper        // 存放 XML 映射文件</span><br><span class="line">        └── UserMapper.xml        // (路径建议与接口包名保持一致)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-数据库准备"><a href="#3-3-数据库准备" class="headerlink" title="3.3 数据库准备"></a>3.3 数据库准备</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `t_user` (</span><br><span class="line">  `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `username` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `email` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入测试数据</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> `t_user` (`username`, `password`, `email`) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>, <span class="string">&#x27;alice@code.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-4-编写持久层代码"><a href="#3-4-编写持久层代码" class="headerlink" title="3.4 编写持久层代码"></a>3.4 编写持久层代码</h3><h4 id="3-4-1-实体类-User-java"><a href="#3-4-1-实体类-User-java" class="headerlink" title="3.4.1 实体类 (User.java)"></a>3.4.1 实体类 (User.java)</h4><p>使用 Lombok <code>@Data</code> 简化 Getter&#x2F;Setter&#x2F;ToString。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-4-2-Mapper-接口-UserMapper-java"><a href="#3-4-2-Mapper-接口-UserMapper-java" class="headerlink" title="3.4.2 Mapper 接口 (UserMapper.java)"></a>3.4.2 Mapper 接口 (UserMapper.java)</h4><p>遵循<strong>接口绑定</strong>原则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.model.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">// 根据 ID 查询用户</span></span><br><span class="line">    User <span class="title function_">selectById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-4-3-Mapper-XML-映射-UserMapper-xml"><a href="#3-4-3-Mapper-XML-映射-UserMapper-xml" class="headerlink" title="3.4.3 Mapper XML 映射 (UserMapper.xml)"></a>3.4.3 Mapper XML 映射 (UserMapper.xml)</h4><p><strong>关键规范</strong>：</p>
<ol>
<li><code>namespace</code> 必须匹配接口的全限定名。</li>
<li><code>id</code> 必须匹配接口的方法名。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">       resultType: 直接指定实体类。</span></span><br><span class="line"><span class="comment">       注意：MyBatis 会自动将表列名映射到类属性（需开启驼峰配置）</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT id, username, password, email </span><br><span class="line">        FROM t_user </span><br><span class="line">        WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-5-全局核心配置-mybatis-config-xml"><a href="#3-5-全局核心配置-mybatis-config-xml" class="headerlink" title="3.5 全局核心配置 (mybatis-config.xml)"></a>3.5 全局核心配置 (mybatis-config.xml)</h3><p>这是 MyBatis 的“大脑”配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1. 全局设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开启驼峰命名转换 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 打印 SQL 日志到控制台 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 环境配置 (支持多环境切换: dev/prod) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;dev&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;dev&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 事务管理器: JDBC (手动 commit/rollback) --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 数据源: POOLED (使用内置连接池) --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/demo_db?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3. 注册 Mapper XML --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/example/mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-6-启动与验证-Main-java"><a href="#3-6-启动与验证-Main-java" class="headerlink" title="3.6 启动与验证 (Main.java)"></a>3.6 启动与验证 (Main.java)</h3><p>模拟完整的执行生命周期。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 读取配置文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 构建 SqlSessionFactory (重量级，单例模式，通常应用启动时构建一次)</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 打开 SqlSession (轻量级，非线程安全，用完即关)</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 获取接口代理对象 (JDK 动态代理)</span></span><br><span class="line">            <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 执行业务逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;--- 开始查询 ---&quot;</span>);</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.selectById(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;查询结果: &quot;</span> + user);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 注意：如果是增删改操作，必须手动提交事务</span></span><br><span class="line">            <span class="comment">// session.commit();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-XML映射文件"><a href="#4-XML映射文件" class="headerlink" title="4. XML映射文件"></a>4. XML映射文件</h2><p>Mapper XML 是 MyBatis 的核心，它定义了 Java 方法与底层 SQL 之间的<strong>契约</strong>。它是 MyBatis 区别于其他 ORM 框架（如 JPA）的最大特色，提供了对 SQL 的极致控制力。</p>
<h3 id="4-1-核心结构与接口绑定"><a href="#4-1-核心结构与接口绑定" class="headerlink" title="4.1 核心结构与接口绑定"></a>4.1 核心结构与接口绑定</h3><p>XML 映射文件通过 <code>namespace</code> 属性实现与 Java 接口的绑定。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 核心：namespace 必须与 Java 接口的全限定名完全一致 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SQL 映射定义 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>绑定机制的四大原则：</strong></p>
<ol>
<li>XML 的 <code>namespace</code> &#x3D; 接口的 <strong>全限定名</strong>。</li>
<li>SQL 标签的 <code>id</code> &#x3D; 接口的 <strong>方法名</strong>。</li>
<li>SQL 标签的 <code>parameterType</code> ≈ 接口的 <strong>参数类型</strong>。</li>
<li>SQL 标签的 <code>resultType/resultMap</code> &#x3D; 接口的 <strong>返回值类型</strong>。</li>
</ol>
<hr>
<h3 id="4-2-CRUD-标签与主键回填"><a href="#4-2-CRUD-标签与主键回填" class="headerlink" title="4.2 CRUD 标签与主键回填"></a>4.2 CRUD 标签与主键回填</h3><h4 id="4-2-1-基础-CRUD-示例"><a href="#4-2-1-基础-CRUD-示例" class="headerlink" title="4.2.1 基础 CRUD 示例"></a>4.2.1 基础 CRUD 示例</h4><p>MyBatis 为增删改查操作提供了四个基本标签：</p>
<ul>
<li><strong><code>&lt;select&gt;</code></strong>: 用于定义查询语句。</li>
<li><strong><code>&lt;insert&gt;</code></strong>: 用于定义插入语句。</li>
<li><strong><code>&lt;update&gt;</code></strong>: 用于定义更新语句。</li>
<li><strong><code>&lt;delete&gt;</code></strong>: 用于定义删除语句。</li>
</ul>
<p><strong>通用属性</strong>:</p>
<ul>
<li><strong><code>id</code></strong>: 必填。唯一标识符，必须与 Mapper 接口中对应的方法名完全一致。</li>
<li><strong><code>parameterType</code></strong>: 可选。传入参数的 Java 类型全限定名或别名。MyBatis 通常可以自动推断，所以大部分情况下可以省略。</li>
<li><strong><code>timeout</code></strong>: 设置超时时间（秒）。</li>
<li><strong><code>flushCache</code></strong>: 默认为 <code>false</code> (select) 或 <code>true</code> (insert&#x2F;update&#x2F;delete)。设置为 <code>true</code> 时，执行该语句会清空一级和二级缓存。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 查询 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 插入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">        INSERT INTO user (username, password, email) </span><br><span class="line">        VALUES (#&#123;username&#125;, #&#123;password&#125;, #&#123;email&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 更新 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">        UPDATE user SET username = #&#123;username&#125;, email = #&#123;email&#125; WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 删除 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span>&gt;</span></span><br><span class="line">        DELETE FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-2-主键回填"><a href="#4-2-2-主键回填" class="headerlink" title="4.2.2 主键回填"></a>4.2.2 主键回填</h4><p>这是实际开发中的高频需求：插入数据后，立即获取数据库生成的 ID（如用于后续关联表的插入）。</p>
<h5 id="场景-A：支持自增主键的数据库-MySQL"><a href="#场景-A：支持自增主键的数据库-MySQL" class="headerlink" title="场景 A：支持自增主键的数据库 (MySQL)"></a>场景 A：支持自增主键的数据库 (MySQL)</h5><p>使用 <code>useGeneratedKeys</code> 和 <code>keyProperty</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    useGeneratedKeys=&quot;true&quot;: 开启主键回填</span></span><br><span class="line"><span class="comment">    keyProperty=&quot;id&quot;: 将数据库生成的主键值赋值给 Java 对象的 id 属性</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    INSERT INTO t_user (username, password) </span><br><span class="line">    VALUES (#&#123;username&#125;, #&#123;password&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>执行后：<code>user.getId()</code> 将不再是 null。</em></p>
<h5 id="场景-B：不支持自增主键的数据库-Oracle"><a href="#场景-B：不支持自增主键的数据库-Oracle" class="headerlink" title="场景 B：不支持自增主键的数据库 (Oracle)"></a>场景 B：不支持自增主键的数据库 (Oracle)</h5><p>使用 <code>&lt;selectKey&gt;</code> 子标签配合序列 (Sequence)。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 运行顺序：BEFORE，先查序列，设给 id，再执行 insert --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span>&gt;</span></span><br><span class="line">        SELECT SEQ_USER_ID.nextval FROM dual</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    INSERT INTO t_user (id, username) VALUES (#&#123;id&#125;, #&#123;username&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-参数处理-vs"><a href="#4-3-参数处理-vs" class="headerlink" title="4.3 参数处理 (#{} vs ${})"></a>4.3 参数处理 (<code>#{}</code> vs <code>${}</code>)</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>#{}</code> (占位符)</th>
<th align="left"><code>${}</code> (拼接符)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>底层实现</strong></td>
<td align="left"><code>PreparedStatement</code></td>
<td align="left"><code>Statement</code></td>
</tr>
<tr>
<td align="left"><strong>工作方式</strong></td>
<td align="left">参数替换，将 <code>#{...}</code> 替换为 <code>?</code>，然后安全地设置值。</td>
<td align="left">字符串直接拼接，将 <code>${...}</code> 的内容原样拼接到 SQL 中。</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left"><strong>安全</strong>，能有效防止 SQL 注入。</td>
<td align="left"><strong>不安全</strong>，存在 SQL 注入风险，必须谨慎使用。</td>
</tr>
<tr>
<td align="left"><strong>类型处理</strong></td>
<td align="left">自动进行数据类型转换（如 String 转 ‘String’）。</td>
<td align="left">不进行任何处理，原样输出。</td>
</tr>
<tr>
<td align="left"><strong>推荐使用</strong></td>
<td align="left"><strong>绝大多数情况下都应该使用。</strong></td>
<td align="left">仅用于无法使用 <code>#{}</code> 的场景。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">传递查询条件、更新值等所有用户输入的数据。</td>
<td align="left">动态指定表名、列名、<code>ORDER BY</code> 子句等非参数值部分。</td>
</tr>
</tbody></table>
<p><strong>示例</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 安全的用法 (推荐)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> #&#123;userId&#125;;</span><br><span class="line"><span class="comment">-- MyBatis 会生成: SELECT * FROM user WHERE id = ?;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 危险的用法 (有 SQL 注入风险)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> $&#123;userId&#125;;</span><br><span class="line"><span class="comment">-- 如果 userId 是 &quot;1 OR 1=1&quot;，SQL 会变成: SELECT * FROM user WHERE id = 1 OR 1=1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- `$&#123;&#125;` 的合理用法</span></span><br><span class="line"><span class="comment">-- 动态排序：orderByColumn 可以是 &quot;username&quot; 或 &quot;email&quot;</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> $&#123;orderByColumn&#125; <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-4-结果映射"><a href="#4-4-结果映射" class="headerlink" title="4.4 结果映射 (&lt;resultMap&gt;)"></a>4.4 结果映射 (<code>&lt;resultMap&gt;</code>)</h3><p>当数据库表的列名与 Java 对象的属性名不一致时，或者需要处理复杂的关联查询（如一对一、一对多）时，<code>resultType</code> 就显得力不从心了。此时，需要使用功能更强大的 <code>&lt;resultMap&gt;</code>。</p>
<p><strong><code>resultType</code> vs <code>&lt;resultMap&gt;</code></strong>:</p>
<ul>
<li><strong><code>resultType</code></strong>: 用于简单的自动映射。它要求 SQL 查询出的列名与 Java 对象的属性名（忽略大小写和下划线）能够匹配。例如，数据库列 <code>user_name</code> 可以自动映射到 Java 属性 <code>userName</code>。</li>
<li><strong><code>&lt;resultMap&gt;</code></strong>: 提供手动的、精细化的映射规则。</li>
</ul>
<h4 id="4-4-1-基础映射-字段名不一致"><a href="#4-4-1-基础映射-字段名不一致" class="headerlink" title="4.4.1 基础映射 (字段名不一致)"></a>4.4.1 基础映射 (字段名不一致)</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id: 主键映射，这对 MyBatis 缓存和去重非常重要 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- result: 普通字段映射 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;u_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;u_pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-4-2-高级映射：级联查询"><a href="#4-4-2-高级映射：级联查询" class="headerlink" title="4.4.2 高级映射：级联查询"></a>4.4.2 高级映射：级联查询</h4><p>这是 MyBatis 处理多表 JOIN 的核心武器。</p>
<p>假设场景：一个 <strong>用户(User)</strong> 拥有一个 <strong>钱包(Wallet)</strong>，且有多个 <strong>订单(Order)</strong>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserDetailMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1. 一对一映射 (Has-One): 用户 -&gt; 钱包 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- property: User 类中的 wallet 属性 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- javaType: wallet 属性的类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;wallet&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Wallet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;wallet_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;balance&quot;</span> <span class="attr">property</span>=<span class="string">&quot;balance&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 一对多映射 (Has-Many): 用户 -&gt; 订单列表 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- property: User 类中的 orders 属性 (List&lt;Order&gt;) --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ofType: List 中元素的类型 (Order) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Order&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;order_no&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderNo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">property</span>=<span class="string">&quot;amount&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 对应的联表查询 SQL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserDetail&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserDetailMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT </span><br><span class="line">        u.id, u.username,</span><br><span class="line">        w.id as wallet_id, w.balance,</span><br><span class="line">        o.id as order_id, o.order_no, o.amount</span><br><span class="line">    FROM t_user u</span><br><span class="line">    LEFT JOIN t_wallet w ON u.id = w.user_id</span><br><span class="line">    LEFT JOIN t_order o ON u.id = o.user_id</span><br><span class="line">    WHERE u.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-5-可重用-SQL-片段"><a href="#4-5-可重用-SQL-片段" class="headerlink" title="4.5 可重用 SQL 片段 (&lt;sql&gt;)"></a>4.5 可重用 SQL 片段 (<code>&lt;sql&gt;</code>)</h3><p>遵循 <strong>DRY (Don’t Repeat Yourself)</strong> 原则，将高频出现的列名或条件抽取出来。</p>
<p><strong>示例</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义片段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span>&gt;</span></span><br><span class="line">    id, username, email, create_time, update_time</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 引用片段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    SELECT </span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span>/&gt;</span></span><br><span class="line">    FROM t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-动态SQL"><a href="#5-动态SQL" class="headerlink" title="5. 动态SQL"></a>5. 动态SQL</h2><p>动态 SQL 是 MyBatis 的灵魂。它基于 OGNL 表达式，解决了传统 JDBC 需要在 Java 代码中手写 <code>StringBuilder</code> 拼接 SQL 的痛点。</p>
<blockquote>
<p><strong>核心价值</strong>：一套 SQL 模板 × 不同的入参 &#x3D; 千变万化的执行 SQL。</p>
</blockquote>
<h3 id="5-1-条件判断标签"><a href="#5-1-条件判断标签" class="headerlink" title="5.1 条件判断标签"></a>5.1 条件判断标签</h3><h4 id="5-1-1"><a href="#5-1-1" class="headerlink" title="5.1.1 &lt;if&gt;"></a>5.1.1 <code>&lt;if&gt;</code></h4><p>这是最常用的动态 SQL 标签，用于进行单条件判断。如果 <code>test</code> 表达式的值为 <code>true</code>，则会将 <code>&lt;if&gt;</code> 标签内的 SQL 片段包含进来。</p>
<p><strong>场景</strong>：根据用户名（可选）和邮箱（可选）查询用户。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserByCondition&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.model.User&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    WHERE 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null and username != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        AND username = #&#123;username&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">        AND email = #&#123;email&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>test</code> 属性</strong>：接收一个 OGNL (Object-Graph Navigation Language) 表达式。你可以直接访问传入参数对象的属性。</li>
<li><strong><code>WHERE 1=1</code> 的技巧</strong>：这是一个经典的“hack”手法。为了避免当所有 <code>&lt;if&gt;</code> 条件都不满足时 SQL 语法错误，或者当第一个 <code>&lt;if&gt;</code> 满足时需要处理 <code>WHERE</code> 和 <code>AND</code> 的连接问题，<code>WHERE 1=1</code> 可以巧妙地让后续所有条件都以 <code>AND</code> 开头，简化了逻辑。不过，MyBatis 提供了更优雅的解决方案。</li>
</ul>
<blockquote>
<p><strong>避坑指南 (OGNL 陷阱)</strong>：</p>
<p>在判断数字类型（如<code>status</code>）时，不要使用 <code>status != &#39;&#39;</code>。</p>
<p>因为在 MyBatis 的 OGNL 规则中，<code>0</code> 有时会被解析为空字符串，导致 <code>status=0</code> 的条件被忽略！</p>
<p><strong>正确写法</strong>：<code>&lt;if test=&quot;status != null&quot;&gt;</code></p>
</blockquote>
<hr>
<h4 id="5-1-2"><a href="#5-1-2" class="headerlink" title="5.1.2 &lt;where&gt;"></a>5.1.2 <code>&lt;where&gt;</code></h4><p><code>&lt;where&gt;</code> 标签专门用于解决上述 <code>WHERE 1=1</code> 的问题。它会智能地处理 SQL 拼接：</p>
<ul>
<li><strong>智能行为 1</strong>：如果标签内部没有生成任何 SQL，则不会输出 <code>WHERE</code> 关键字。</li>
<li><strong>智能行为 2</strong>：如果标签内部生成的 SQL 以 <code>AND</code> 或 <code>OR</code> 开头，它会自动剔除。</li>
</ul>
<p><strong>使用 <code>&lt;where&gt;</code> 优化上述示例</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserByCondition&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.model.User&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.model.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 即使 username 为空，email 这里的 AND 也会被自动剔除 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null and username != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            AND username = #&#123;username&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            AND email = #&#123;email&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-1-3"><a href="#5-1-3" class="headerlink" title="5.1.3 &lt;set&gt;"></a>5.1.3 <code>&lt;set&gt;</code></h4><p><code>&lt;set&gt;</code> 标签主要用于 <code>UPDATE</code> 语句中，它解决了动态更新时可能出现的“逗号问题”。</p>
<ul>
<li><strong>智能行为 1</strong>：如果标签内部没有生成任何 SQL，则不会输出 <code>set</code> 关键字。</li>
<li><strong>智能行为 2</strong>：自动剔除生成的 SQL 语句末尾多余的 <code>,</code>。</li>
</ul>
<p><strong>场景</strong>：动态更新用户信息，只更新传入对象中非 <code>null</code> 的字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">update</span> id<span class="operator">=</span>&quot;updateUserSelective&quot; parameterType<span class="operator">=</span>&quot;com.example.model.User&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">UPDATE</span> <span class="keyword">user</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="keyword">set</span><span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;username != null and username != &#x27;&#x27;&quot;<span class="operator">&gt;</span></span><br><span class="line">            username <span class="operator">=</span> #&#123;username&#125;,</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;password != null and password != &#x27;&#x27;&quot;<span class="operator">&gt;</span></span><br><span class="line">            password <span class="operator">=</span> #&#123;password&#125;,</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;email != null and email != &#x27;&#x27;&quot;<span class="operator">&gt;</span></span><br><span class="line">            email <span class="operator">=</span> #&#123;email&#125;,</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">set</span><span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">WHERE</span> id <span class="operator">=</span> #&#123;id&#125;</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">update</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果没有 <code>&lt;set&gt;</code>，当最后一个 <code>&lt;if&gt;</code> 条件满足时，SQL 语句会以一个逗号结尾，导致语法错误。<code>&lt;set&gt;</code> 完美地解决了这个问题。</p>
<hr>
<h3 id="5-2-复杂逻辑标签"><a href="#5-2-复杂逻辑标签" class="headerlink" title="5.2 复杂逻辑标签"></a>5.2 复杂逻辑标签</h3><h4 id="5-2-1"><a href="#5-2-1" class="headerlink" title="5.2.1 &lt;choose&gt;, &lt;when&gt;, &lt;otherwise&gt;"></a>5.2.1 <code>&lt;choose&gt;</code>, <code>&lt;when&gt;</code>, <code>&lt;otherwise&gt;</code></h4><p>不同于 <code>&lt;if&gt;</code> 的多选多，这组标签只执行第一个匹配的条件。</p>
<p><strong>场景</strong>：搜索优先级 —— ID &gt; 用户名 &gt; 默认查全部。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserRelaxed&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM t_user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span>&gt;</span></span><br><span class="line">                AND id = #&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">                AND username = #&#123;username&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                AND status = &#x27;ACTIVE&#x27;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-2-2"><a href="#5-2-2" class="headerlink" title="5.2.2  &lt;trim&gt;"></a>5.2.2  <code>&lt;trim&gt;</code></h4><p><code>&lt;trim&gt;</code> 是一个更通用的自定义标签，<code>&lt;where&gt;</code> 和 <code>&lt;set&gt;</code> 本质上是 <code>&lt;trim&gt;</code> 的特定配置。它允许你自定义前缀、后缀以及需要覆盖（移除）的前缀和后缀。</p>
<p><strong>属性</strong>:</p>
<ul>
<li><code>prefix</code>: 在标签内容前添加的前缀。</li>
<li><code>suffix</code>: 在标签内容后添加的后缀。</li>
<li><code>prefixOverrides</code>: 需要从标签内容<strong>开头</strong>移除的文本（多个用 <code>|</code> 分隔）。</li>
<li><code>suffixOverrides</code>: 需要从标签内容<strong>结尾</strong>移除的文本（多个用 <code>|</code> 分隔）。</li>
</ul>
<p><strong>使用 <code>&lt;trim&gt;</code> 模拟 <code>&lt;where&gt;</code></strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;WHERE&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;AND |OR &quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... a bunch of if statements ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>使用 <code>&lt;trim&gt;</code> 模拟 <code>&lt;set&gt;</code></strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;SET&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... a bunch of if statements ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>虽然 <code>&lt;trim&gt;</code> 更强大，但在适用场景下，使用 <code>&lt;where&gt;</code> 和 <code>&lt;set&gt;</code> 会让代码意图更清晰，可读性更好。</p>
<hr>
<h3 id="5-3-集合迭代标签"><a href="#5-3-集合迭代标签" class="headerlink" title="5.3 集合迭代标签"></a>5.3 集合迭代标签</h3><h4 id="5-3-1-——-构建-IN-查询"><a href="#5-3-1-——-构建-IN-查询" class="headerlink" title="5.3.1 &lt;foreach&gt; —— 构建 IN 查询"></a>5.3.1 <code>&lt;foreach&gt;</code> —— 构建 IN 查询</h4><p><code>&lt;foreach&gt;</code> 标签用于对集合（如 <code>List</code>, <code>Set</code>, <code>Array</code>）进行迭代，常用于构建 <code>IN</code> 子句或批量插入。</p>
<p><strong>核心属性</strong>:</p>
<ul>
<li><strong><code>collection</code></strong>: 必填。要迭代的集合参数。当参数是 <code>List</code> 时，默认为 <code>list</code>；当是数组时，默认为 <code>array</code>。也可以通过 <code>@Param</code> 注解指定名称。</li>
<li><strong><code>item</code></strong>: 迭代过程中当前元素的变量名。</li>
<li><strong><code>open</code></strong>: 整个循环内容开始前要拼接的字符串。</li>
<li><strong><code>close</code></strong>: 整个循环内容结束后要拼接的字符串。</li>
<li><strong><code>separator</code></strong>: 每次迭代之间要拼接的分隔符。</li>
</ul>
<p>这是最常见的用法。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;User&gt; selectByIds(@Param(&quot;ids&quot;) List&lt;Integer&gt; ids); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM t_user WHERE id IN</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-3-2-——-MySQL-批量插入"><a href="#5-3-2-——-MySQL-批量插入" class="headerlink" title="5.3.2 &lt;foreach&gt; —— MySQL 批量插入"></a>5.3.2 <code>&lt;foreach&gt;</code> —— MySQL 批量插入</h4><p>这是提升数据导入性能的关键手段（比循环调用 insert 快 10 倍以上）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- void batchInsert(@Param(&quot;users&quot;) List&lt;User&gt; users); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;batchInsert&quot;</span>&gt;</span></span><br><span class="line">    INSERT INTO t_user (username, password, email)</span><br><span class="line">    VALUES</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;users&quot;</span> <span class="attr">item</span>=<span class="string">&quot;u&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        (#&#123;u.username&#125;, #&#123;u.password&#125;, #&#123;u.email&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>生成 SQL</em>：<code>INSERT INTO t_user (...) VALUES (&#39;Alice&#39;,...), (&#39;Bob&#39;,...), (&#39;Charlie&#39;,...)</code></p>
<hr>
<h3 id="5-4-辅助标签"><a href="#5-4-辅助标签" class="headerlink" title="5.4 辅助标签"></a>5.4 辅助标签</h3><h4 id="5-4-1-——-数据库无关的模糊查询"><a href="#5-4-1-——-数据库无关的模糊查询" class="headerlink" title="5.4.1 &lt;bind&gt; —— 数据库无关的模糊查询"></a>5.4.1 <code>&lt;bind&gt;</code> —— 数据库无关的模糊查询</h4><p>为了防止 SQL 注入，同时避免使用 MySQL 特有的 <code>concat</code> 函数（为了兼容性），可以使用 <code>&lt;bind&gt;</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlogsLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 创建一个变量 pattern，值为 &quot;%&quot; + title + &quot;%&quot; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;pattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;%&#x27; + title + &#x27;%&#x27;&quot;</span> /&gt;</span></span><br><span class="line">  </span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE title LIKE #&#123;pattern&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-注解开发"><a href="#6-注解开发" class="headerlink" title="6. 注解开发"></a>6. 注解开发</h2><p>注解开发是 XML 的轻量级替代方案。它将 SQL 直接写在 Java 接口的方法上，实现了“零配置”开发。</p>
<p><strong>核心权衡 (Trade-off)</strong>：</p>
<ul>
<li><strong>XML</strong>：配置繁琐，但 SQL 与代码解耦，适合复杂 SQL 和 DBA 调优。</li>
<li><strong>注解</strong>：开发极快，但 SQL 与代码耦合（硬编码），仅适合简单 SQL。</li>
</ul>
<h3 id="6-1-简介与适用场景"><a href="#6-1-简介与适用场景" class="headerlink" title="6.1 简介与适用场景"></a>6.1 简介与适用场景</h3><p><strong>核心思想</strong>：将 SQL 映射的配置信息从 XML 文件中移到 Java 接口的注解上，让接口本身就成为一个完整的映射单元。</p>
<p><strong>适用场景</strong>:</p>
<ul>
<li><strong>简单的 CRUD 操作</strong>：对于那些 SQL 语句非常简短、固定且不会改变的增删改查，使用注解可以减少一个 XML 文件，使项目结构更紧凑。</li>
<li><strong>快速原型开发</strong>：在项目初期或开发小型应用时，注解方式可以快速实现功能。</li>
<li><strong>SQL 语句非常简单</strong>：当 SQL 逻辑不涉及复杂的动态判断或关联时，注解是很好的选择。</li>
</ul>
<p><strong>不适用场景</strong>：</p>
<ul>
<li><strong>复杂的动态 SQL</strong>：虽然注解也支持动态 SQL，但写法非常笨拙，可读性和可维护性远不如 XML。</li>
<li><strong>SQL 需要被 DBA 审查或优化</strong>：当 SQL 需要由专门的数据库管理员进行管理时，XML 的分离特性是巨大优势。</li>
<li><strong>需要处理复杂的结果集映射</strong>：注解方式处理复杂映射（如嵌套查询）比 XML 更加繁琐。</li>
</ul>
<hr>
<h3 id="6-2-启用注解开发"><a href="#6-2-启用注解开发" class="headerlink" title="6.2 启用注解开发"></a>6.2 启用注解开发</h3><p>要让 MyBatis 扫描并识别注解，需要在核心配置文件 <code>mybatis-config.xml</code> 中注册 Mapper <strong>接口类</strong>，而不是 XML 文件资源。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方案一：逐个注册 Mapper 接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 方案二：批量扫描指定包下的所有 Mapper 接口（更常用） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.example.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：MyBatis 允许混合使用 XML 和注解。即使用了注解，MyBatis 默认还是会去寻找与接口同名同路径的 XML 文件。这种混合模式提供了极大的灵活性。</p>
<hr>
<h3 id="6-3-核心-CRUD-注解"><a href="#6-3-核心-CRUD-注解" class="headerlink" title="6.3 核心 CRUD 注解"></a>6.3 核心 CRUD 注解</h3><p>MyBatis 提供了一套与 XML 标签对应的注解，用于定义增删改查操作。</p>
<ul>
<li><code>@Select</code>: 对应 <code>&lt;select&gt;</code> 标签，用于查询。</li>
<li><code>@Insert</code>: 对应 <code>&lt;insert&gt;</code> 标签，用于插入。</li>
<li><code>@Update</code>: 对应 <code>&lt;update&gt;</code> 标签，用于更新。</li>
<li><code>@Delete</code>: 对应 <code>&lt;delete&gt;</code> 标签，用于删除。</li>
</ul>
<p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com/example/mapper/UserMapper.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 查询</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM t_user WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">selectById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 插入 (并回填主键)</span></span><br><span class="line">    <span class="meta">@Insert(&quot;INSERT INTO t_user(username, password) VALUES(#&#123;username&#125;, #&#123;password&#125;)&quot;)</span></span><br><span class="line">    <span class="comment">// 使用 @Options 注解获取自增主键</span></span><br><span class="line">    <span class="meta">@Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 更新</span></span><br><span class="line">    <span class="meta">@Update(&quot;UPDATE t_user SET email = #&#123;email&#125; WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 删除</span></span><br><span class="line">    <span class="meta">@Delete(&quot;DELETE FROM t_user WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-4-参数处理-Param"><a href="#6-4-参数处理-Param" class="headerlink" title="6.4 参数处理 (@Param)"></a>6.4 参数处理 (<code>@Param</code>)</h3><p><code>@Param</code> 的作用是给参数起一个<strong>在 SQL 中使用的别名</strong>。</p>
<p><strong>核心法则</strong>：<strong>为了代码的健壮性和可读性，除了“单参数且为 POJO”的情况外，建议一律加上 <code>@Param</code>。</strong></p>
<h4 id="6-4-1-使用场景"><a href="#6-4-1-使用场景" class="headerlink" title="6.4.1 使用场景"></a>6.4.1 使用场景</h4><h5 id="1-多参数-必用"><a href="#1-多参数-必用" class="headerlink" title="1. 多参数 (必用)"></a>1. 多参数 (必用)</h5><p>MyBatis 无法自动识别参数名（除非开启 <code>-parameters</code> 编译选项，但不推荐依赖环境）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名和密码查询用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    User <span class="title function_">findUserByUsernameAndPassword</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username, </span></span><br><span class="line"><span class="params">                                       <span class="meta">@Param(&quot;password&quot;)</span> String password)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserByUsernameAndPassword&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * </span><br><span class="line">    FROM user </span><br><span class="line">    WHERE username = #&#123;username&#125; AND password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-集合参数-推荐"><a href="#2-集合参数-推荐" class="headerlink" title="2. 集合参数 (推荐)"></a>2. 集合参数 (推荐)</h5><p>为了让 <code>IN</code> 查询的 SQL 更易读。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户ID列表查询多个用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userIds 用户ID列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findUsersByIds</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> List&lt;Integer&gt; userIds)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUsersByIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT *</span><br><span class="line">    FROM user</span><br><span class="line">    WHERE id IN</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;userId&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;userId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-5-结果映射-Results-Result"><a href="#6-5-结果映射-Results-Result" class="headerlink" title="6.5 结果映射 (@Results &amp; @Result)"></a>6.5 结果映射 (<code>@Results</code> &amp; <code>@Result</code>)</h3><h4 id="6-5-1-基础映射"><a href="#6-5-1-基础映射" class="headerlink" title="6.5.1 基础映射"></a>6.5.1 基础映射</h4><p>当数据库列名与 Java 实体类的属性名不匹配时，可以使用 <code>@Results</code> 和 <code>@Result</code> 注解来进行手动映射，它们的功能等同于 XML 中的 <code>&lt;resultMap&gt;</code>。</p>
<ul>
<li><code>@Results</code>: 包含一组 <code>@Result</code> 映射规则的容器，可以给它指定一个 <code>id</code> 以便复用。</li>
<li><code>@Result</code>: 定义单个列与属性的映射关系。<ul>
<li><code>column</code>: 数据库列名。</li>
<li><code>property</code>: Java 实体类属性名。</li>
<li><code>id = true</code>: 表明这是主键字段。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Results(id = &quot;userResultMap&quot;, value = &#123;</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;id&quot;, column = &quot;user_id&quot;, id = true),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;username&quot;, column = &quot;user_name&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;password&quot;, column = &quot;user_pwd&quot;),</span></span><br><span class="line"><span class="meta">        @Result(property = &quot;email&quot;, column = &quot;user_email&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT user_id, user_name, user_pwd, user_email FROM user WHERE user_id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">selectUserWithCustomMapping</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复用上面定义的 Results</span></span><br><span class="line">    <span class="meta">@ResultMap(&quot;userResultMap&quot;)</span></span><br><span class="line">    <span class="meta">@Select(&quot;SELECT user_id, user_name, user_pwd, user_email FROM user&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectAllUsers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-5-2-级联查询（-One-Many）"><a href="#6-5-2-级联查询（-One-Many）" class="headerlink" title="6.5.2 级联查询（@One &amp; @Many）"></a>6.5.2 级联查询（<code>@One</code> &amp; <code>@Many</code>）</h4><p>这是注解开发中最复杂的部分，对应 XML 的 <code>association</code> 和 <code>collection</code>。</p>
<ul>
<li><strong>@One</strong>: 一对一 (立即加载&#x2F;懒加载)</li>
<li><strong>@Many</strong>: 一对多</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT * FROM t_user WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Results(&#123;</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;id&quot;, property = &quot;id&quot;, id = true),</span></span><br><span class="line"><span class="meta">    @Result(column = &quot;username&quot;, property = &quot;username&quot;),</span></span><br><span class="line"><span class="meta">    // 一对多：通过 id 列，去调用 OrderMapper 的 findByUserId 方法</span></span><br><span class="line"><span class="meta">    @Result(</span></span><br><span class="line"><span class="meta">        column = &quot;id&quot;, </span></span><br><span class="line"><span class="meta">        property = &quot;orders&quot;,</span></span><br><span class="line"><span class="meta">        many = @Many(</span></span><br><span class="line"><span class="meta">            select = &quot;com.example.mapper.OrderMapper.findByUserId&quot;,</span></span><br><span class="line"><span class="meta">            fetchType = FetchType.LAZY // 开启懒加载</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">User <span class="title function_">findUserWithOrders</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-6-动态-SQL-注解的局限与方案"><a href="#6-6-动态-SQL-注解的局限与方案" class="headerlink" title="6.6 动态 SQL (注解的局限与方案)"></a>6.6 动态 SQL (注解的局限与方案)</h3><p>注解本身不支持 <code>if/else</code> 标签，处理动态 SQL 非常痛苦。MyBatis 提供了两种方案：</p>
<p><strong>方案一：使用 <code>&lt;script&gt;</code> 标签 (推荐)</strong></p>
<p>你可以在注解的 SQL 字符串中嵌入 <code>&lt;script&gt;</code> 标签，然后在标签内部使用和 XML 中一样的动态 SQL 标签（如 <code>&lt;if&gt;</code>, <code>&lt;where&gt;</code>, <code>&lt;foreach&gt;</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;&lt;script&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;SELECT * FROM user &quot; +</span></span><br><span class="line"><span class="meta">            &quot;&lt;where&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;  &lt;if test=&#x27;username != null and username != \&quot;\&quot;&#x27;&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;    AND username = #&#123;username&#125;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;  &lt;/if&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;  &lt;if test=&#x27;email != null and email != \&quot;\&quot;&#x27;&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;    AND email = #&#123;email&#125;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;  &lt;/if&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;&lt;/where&gt;&quot; +</span></span><br><span class="line"><span class="meta">            &quot;&lt;/script&gt;&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findUserByCondition</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>：SQL 以字符串形式存在，容易出错，IDE 没有语法高亮和检查，可读性差。</p>
<p><strong>方案二：使用 <code>Provider</code> 注解 (高级)</strong></p>
<p>对于极其复杂的动态 SQL，可以使用 <code>@SelectProvider</code>, <code>@InsertProvider</code> 等注解，将构建 SQL 的逻辑委托给一个外部的 Java 类来完成。</p>
<ol>
<li><p><strong>创建一个 SQL Provider 类</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSqlProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findUserByCondition</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 MyBatis 内置的 SQL 构建器，比手动拼接更安全</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;&#123;</span><br><span class="line">            SELECT(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            FROM(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (user.getUsername() != <span class="literal">null</span> &amp;&amp; !user.getUsername().isEmpty()) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;username = #&#123;username&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (user.getEmail() != <span class="literal">null</span> &amp;&amp; !user.getEmail().isEmpty()) &#123;</span><br><span class="line">                WHERE(<span class="string">&quot;email = #&#123;email&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 Mapper 接口中引用</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@SelectProvider(type = UserSqlProvider.class, method = &quot;findUserByCondition&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findUserByCondition</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>优点</strong>：可以利用 Java 的全部能力来构建 SQL，逻辑最强大。</p>
<p><strong>缺点</strong>：实现复杂，将数据访问逻辑分散到了另一个类中。</p>
<hr>
<h3 id="6-7-总结：注解-vs-XML-最佳实践"><a href="#6-7-总结：注解-vs-XML-最佳实践" class="headerlink" title="6.7 总结：注解 vs XML (最佳实践)"></a>6.7 总结：注解 vs XML (最佳实践)</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">注解方式</th>
<th align="left">XML 方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>简洁性</strong></td>
<td align="left"><strong>优</strong>，无需额外文件</td>
<td align="left"><strong>良</strong>，需要维护 XML 文件</td>
</tr>
<tr>
<td align="left"><strong>SQL与代码分离</strong></td>
<td align="left"><strong>差</strong>，SQL 与 Java 代码耦合</td>
<td align="left"><strong>优</strong>，完全分离，便于维护</td>
</tr>
<tr>
<td align="left"><strong>动态 SQL 支持</strong></td>
<td align="left"><strong>差</strong>，可读性极低</td>
<td align="left"><strong>优</strong>，语法清晰，功能强大</td>
</tr>
<tr>
<td align="left"><strong>复杂结果映射</strong></td>
<td align="left"><strong>差</strong>，注解写法繁琐</td>
<td align="left"><strong>优</strong>，<code>&lt;resultMap&gt;</code> 结构清晰</td>
</tr>
<tr>
<td align="left"><strong>IDE 支持</strong></td>
<td align="left"><strong>差</strong>，SQL 为字符串，无提示</td>
<td align="left"><strong>优</strong>，有语法高亮和提示</td>
</tr>
</tbody></table>
<p><strong>最佳实践：混合使用</strong></p>
<p>在实际项目中，最理想的策略是<strong>混合使用</strong>两种方式，发挥各自的优势：</p>
<ul>
<li>对于<strong>简单、固定、不常变动</strong>的 CRUD 操作，使用<strong>注解</strong>，以提高开发效率。</li>
<li>对于<strong>复杂查询、动态 SQL、需要 DBA 介入或频繁优化</strong>的 SQL，使用 <strong>XML 文件</strong>，以保证可读性和可维护性。</li>
</ul>
<hr>
<h2 id="7-适用场景-原生MyBatis"><a href="#7-适用场景-原生MyBatis" class="headerlink" title="7. 适用场景 (原生MyBatis)"></a>7. 适用场景 (原生MyBatis)</h2><p>原生 MyBatis 的核心优势在于对 <strong>SQL 的绝对掌控力</strong> 和 <strong>复杂映射的灵活性</strong>。</p>
<h3 id="7-1-极致性能与高并发-High-Concurrency"><a href="#7-1-极致性能与高并发-High-Concurrency" class="headerlink" title="7.1 极致性能与高并发 (High Concurrency)"></a>7.1 极致性能与高并发 (High Concurrency)</h3><ul>
<li><strong>痛点</strong>：全自动 ORM 生成的 SQL 往往不是最优解，难以利用索引覆盖、SQL Hint 等数据库特性。</li>
<li><strong>MyBatis 优势</strong>：允许开发者手写 <strong>“体雕式” SQL</strong>，精确控制执行计划。</li>
<li><strong>典型场景</strong>：<strong>电商秒杀、实时交易系统、亿级数据查询</strong>。</li>
</ul>
<hr>
<h3 id="7-2-复杂报表与-OLAP-分析-Complex-Reporting"><a href="#7-2-复杂报表与-OLAP-分析-Complex-Reporting" class="headerlink" title="7.2 复杂报表与 OLAP 分析 (Complex Reporting)"></a>7.2 复杂报表与 OLAP 分析 (Complex Reporting)</h3><ul>
<li><strong>痛点</strong>：涉及 5 张表以上的关联、复杂的聚合函数 (<code>SUM</code>, <code>AVG</code>)、窗口函数 (<code>OVER</code>) 或 CTE (<code>WITH</code>)。</li>
<li><strong>MyBatis 优势</strong>：XML 天然适合管理这种长达数十行的复杂 SQL，且逻辑清晰。</li>
<li><strong>典型场景</strong>：<strong>财务报表、BI 数据看板、多维数据统计</strong>。</li>
</ul>
<hr>
<h3 id="7-3-遗留系统改造-Legacy-Systems"><a href="#7-3-遗留系统改造-Legacy-Systems" class="headerlink" title="7.3 遗留系统改造 (Legacy Systems)"></a>7.3 遗留系统改造 (Legacy Systems)</h3><ul>
<li><strong>痛点</strong>：老旧数据库设计不规范（无外键、字段冗余、命名混乱），与现代 Java 对象模型完全脱节。</li>
<li><strong>MyBatis 优势</strong>：通过强大的 <code>&lt;resultMap&gt;</code>，可以将任何“脏乱差”的表结构灵活映射为干净的 Java 对象。</li>
<li><strong>典型场景</strong>：<strong>老旧 ERP 系统重构、对接第三方不规范数据库</strong>。</li>
</ul>
<hr>
<h3 id="7-4-深度依赖数据库特性-DB-Specifics"><a href="#7-4-深度依赖数据库特性-DB-Specifics" class="headerlink" title="7.4 深度依赖数据库特性 (DB Specifics)"></a>7.4 深度依赖数据库特性 (DB Specifics)</h3><ul>
<li><strong>痛点</strong>：业务逻辑大量依赖存储过程、函数，或特定数据库的专有功能（如 PostGIS 地理信息、Oracle 树形查询）。</li>
<li><strong>MyBatis 优势</strong>：原生支持存储过程调用，且不屏蔽数据库方言。</li>
<li><strong>典型场景</strong>：<strong>银行核心系统（重度存储过程）、GIS 地理信息系统</strong>。</li>
</ul>
<hr>
<h3 id="7-5-严格的-DBA-审核-Governance"><a href="#7-5-严格的-DBA-审核-Governance" class="headerlink" title="7.5 严格的 DBA 审核 (Governance)"></a>7.5 严格的 DBA 审核 (Governance)</h3><ul>
<li><strong>痛点</strong>：金融&#x2F;政务类项目要求所有上线的 SQL 必须经过 DBA 逐条人工审核。</li>
<li><strong>MyBatis 优势</strong>：SQL 集中在 XML 中，<strong>透明可见（White-box）</strong>，方便 DBA 进行 Review 和索引优化。</li>
<li><strong>典型场景</strong>：<strong>金融证券、政务系统、对数据安全极其敏感的项目</strong>。</li>
</ul>
<hr>
<hr>
<h1 id="三、MyBatis-Plus-效率增强"><a href="#三、MyBatis-Plus-效率增强" class="headerlink" title="三、MyBatis-Plus (效率增强)"></a>三、MyBatis-Plus (效率增强)</h1><h2 id="1-核心定位与设计哲学"><a href="#1-核心定位与设计哲学" class="headerlink" title="1. 核心定位与设计哲学"></a>1. 核心定位与设计哲学</h2><h3 id="1-1-MyBatis-Plus-是什么？"><a href="#1-1-MyBatis-Plus-是什么？" class="headerlink" title="1.1 MyBatis-Plus 是什么？"></a>1.1 MyBatis-Plus 是什么？</h3><p><strong>MyBatis-Plus (MP)</strong> 是基于 MyBatis 的<strong>无侵入式增强工具</strong>。</p>
<ul>
<li><strong>定位</strong>：如果把 MyBatis 比作“发动机”，MP 就是一套“涡轮增压套件”。</li>
<li><strong>原则</strong>：<strong>只做增强不做改变</strong>。引入 MP 后，原有的 MyBatis 架构、XML 配置、Mapper 写法完全不需要修改，两者可以完美共存。</li>
</ul>
<hr>
<h3 id="1-2-为什么选择-MP？"><a href="#1-2-为什么选择-MP？" class="headerlink" title="1.2 为什么选择 MP？"></a>1.2 为什么选择 MP？</h3><p>它解决了原生 MyBatis 的最大痛点：<strong>简单的 CRUD 也要写大量重复的 SQL 和 XML</strong>。</p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">原生 MyBatis</th>
<th align="left">MyBatis-Plus</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>单表 CRUD</strong></td>
<td align="left">需手写 SQL 或生成大量 XML</td>
<td align="left"><strong>0 SQL，0 XML</strong>，继承接口即可</td>
</tr>
<tr>
<td align="left"><strong>查询条件</strong></td>
<td align="left">需手写 <code>Wrapper</code> 或 XML 动态 SQL</td>
<td align="left"><strong>Java 链式调用</strong>，像写代码一样写 SQL</td>
</tr>
<tr>
<td align="left"><strong>分页</strong></td>
<td align="left">需依赖第三方插件 (PageHelper)</td>
<td align="left"><strong>内置</strong>物理分页插件，全自动处理</td>
</tr>
<tr>
<td align="left"><strong>代码生成</strong></td>
<td align="left">需要配置复杂的 Generator</td>
<td align="left"><strong>一键生成</strong> Controller-Service-Mapper-Entity</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-3-六大核心优势详解"><a href="#1-3-六大核心优势详解" class="headerlink" title="1.3 六大核心优势详解"></a>1.3 六大核心优势详解</h3><h4 id="1-3-1-极简-CRUD"><a href="#1-3-1-极简-CRUD" class="headerlink" title="1.3.1 极简 CRUD"></a>1.3.1 极简 CRUD</h4><p>只需让 Mapper 接口继承 <code>BaseMapper&lt;T&gt;</code>，即可直接拥有 17 个标准 CRUD 方法。</p>
<p><strong>代码对比：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生方式：需在 XML 中写 &lt;insert&gt; 标签</span></span><br><span class="line">userMapper.insertUser(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// MP 方式：继承 BaseMapper 后直接调用</span></span><br><span class="line">userMapper.insert(user); <span class="comment">// 自动生成 SQL: INSERT INTO ...</span></span><br><span class="line">userMapper.deleteById(<span class="number">1</span>); <span class="comment">// 自动生成 SQL: DELETE FROM ... WHERE id = 1</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-3-2-强大的条件构造器-Wrapper"><a href="#1-3-2-强大的条件构造器-Wrapper" class="headerlink" title="1.3.2 强大的条件构造器 (Wrapper)"></a>1.3.2 强大的条件构造器 (Wrapper)</h4><p>MP 提供了一套类似 JPA Criteria 的查询构建器，但更符合国人习惯。尤其是 <strong>LambdaQueryWrapper</strong>，彻底解决了“硬编码字段名”的问题。</p>
<ul>
<li><strong>类型安全</strong>：使用 <code>User::getName</code> 代替字符串 <code>&quot;name&quot;</code>，字段名改了编译直接报错。</li>
<li><strong>链式优雅</strong>：逻辑清晰，如读文章般顺畅。</li>
</ul>
<p><strong>实战示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求：查询名字包含 &quot;Jack&quot;，且年龄大于 20，或者邮箱不为空的用户</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.like(User::getName, <span class="string">&quot;Jack&quot;</span>)</span><br><span class="line">       .gt(User::getAge, <span class="number">20</span>)</span><br><span class="line">       .or()</span><br><span class="line">       .isNotNull(User::getEmail);</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-3-3-企业级插件"><a href="#1-3-3-企业级插件" class="headerlink" title="1.3.3 企业级插件"></a>1.3.3 企业级插件</h4><p>MP 内置了一系列“开箱即用”的拦截器插件，无需重复造轮子。</p>
<ul>
<li><strong>分页插件</strong>：自动识别数据库方言，生成 <code>LIMIT / OFFSET</code> 语句。</li>
<li><strong>乐观锁插件</strong>：自动处理 <code>@Version</code> 字段，解决并发更新问题。</li>
<li><strong>防全表更新插件</strong>：禁止执行不带 <code>WHERE</code> 条件的 <code>UPDATE/DELETE</code>，防止删库跑路。</li>
</ul>
<hr>
<h4 id="1-3-4-代码生成器-AutoGenerator"><a href="#1-3-4-代码生成器-AutoGenerator" class="headerlink" title="1.3.4 代码生成器 (AutoGenerator)"></a>1.3.4 代码生成器 (AutoGenerator)</h4><p>一键生成 Controller, Service, Mapper, Entity, XML 代码，甚至可以根据模板生成前端代码，让开发专注于业务逻辑。</p>
<hr>
<h4 id="1-3-5-逻辑删除"><a href="#1-3-5-逻辑删除" class="headerlink" title="1.3.5 逻辑删除"></a>1.3.5 逻辑删除</h4><p>只需一个 <code>@TableLogic</code> 注解，物理删除自动变逻辑删除。</p>
<ul>
<li><strong>删除时</strong>：<code>UPDATE table SET deleted=1 WHERE id=1</code></li>
<li><strong>查询时</strong>：自动追加 <code>AND deleted=0</code>，业务代码完全无感知。</li>
</ul>
<hr>
<h4 id="1-3-6-自动化特性"><a href="#1-3-6-自动化特性" class="headerlink" title="1.3.6 自动化特性"></a>1.3.6 自动化特性</h4><ul>
<li><strong>主键策略</strong>：内置分布式唯一 ID 生成器（<strong>雪花算法</strong> <code>ASSIGN_ID</code>），解决分库分表主键冲突问题。</li>
<li><strong>自动填充</strong>：通过实现 <code>MetaObjectHandler</code>，自动处理 <code>create_time</code>, <code>update_time</code> 等审计字段，无需业务层手动 set。</li>
<li><strong>AR 模式 (ActiveRecord)</strong>：支持实体类直接操作数据库（如 <code>user.insert()</code>），适合简单脚本开发。</li>
</ul>
<hr>
<h2 id="2-快速入门-与-Spring-Boot-集成"><a href="#2-快速入门-与-Spring-Boot-集成" class="headerlink" title="2. 快速入门 (与 Spring Boot 集成)"></a>2. 快速入门 (与 Spring Boot 集成)</h2><p>MyBatis-Plus 与 Spring Boot 的整合是“开箱即用”的典范。只需引入 <code>starter</code>，几乎不需要任何配置即可开始 CRUD。</p>
<h3 id="2-1-环境与依赖"><a href="#2-1-环境与依赖" class="headerlink" title="2.1 环境与依赖"></a>2.1 环境与依赖</h3><p><strong>核心依赖</strong>：<code>mybatis-plus-boot-starter</code>。它已经包含了 <code>mybatis</code> 和 <code>mybatis-spring</code>，<strong>千万不要重复引入原生 MyBatis 依赖</strong>，否则可能导致版本冲突。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- MyBatis-Plus 启动器 (包含了 MyBatis 核心) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- MySQL 驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Lombok (极大简化实体类) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-数据库表与实体类"><a href="#2-2-数据库表与实体类" class="headerlink" title="2.2 数据库表与实体类"></a>2.2 数据库表与实体类</h3><p><strong>表结构 (t_user)</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `t_user` (</span><br><span class="line">  `id` <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>, <span class="comment">-- 注意：若是雪花算法，必须是 BIGINT</span></span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `email` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `is_deleted` TINYINT <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;逻辑删除标识&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>实体类 (User.java)</strong>：</p>
<p>使用注解建立映射关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span> <span class="comment">// Lombok: 自动生成 Getter/Setter/ToString</span></span><br><span class="line"><span class="meta">@TableName(&quot;t_user&quot;)</span> <span class="comment">// 指定数据库表名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@TableId</span>: 主键注解</span></span><br><span class="line"><span class="comment">     * type = IdType.ASSIGN_ID: (默认) 雪花算法，生成 19 位分布式唯一 ID</span></span><br><span class="line"><span class="comment">     * type = IdType.AUTO: 数据库自增 (需数据库表设置 auto_increment)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableId(type = IdType.ASSIGN_ID)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// @TableLogic: 逻辑删除注解 (查询时自动带上 is_deleted=0)</span></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer isDeleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-Mapper接口"><a href="#2-3-Mapper接口" class="headerlink" title="2.3 Mapper接口"></a>2.3 Mapper接口</h3><p>这是 MP 的魔法所在。<strong>无需编写 XML，无需实现类</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承 BaseMapper&lt;T&gt;，泛型指定实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 此处已自动拥有 insert, delete, update, select 等 17 个方法</span></span><br><span class="line">    <span class="comment">// 依然可以在此定义自定义方法，并在 XML 中实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>启动类扫描</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.mapper&quot;)</span> <span class="comment">// 必须加！扫描 Mapper 接口位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-4-配置文件"><a href="#2-4-配置文件" class="headerlink" title="2.4 配置文件"></a>2.4 配置文件</h3><p>配置数据源、日志以及 MP 的全局策略。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/demo_db?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">password</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment"># 开启 SQL 日志输出到控制台 (调试神器)</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">    <span class="comment"># 开启驼峰命名自动转换 (user_name -&gt; userName)</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment"># 全局主键策略: 雪花算法</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">assign_id</span></span><br><span class="line">      <span class="comment"># 全局逻辑删除配置</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">isDeleted</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-5-单元测试"><a href="#2-5-单元测试" class="headerlink" title="2.5 单元测试"></a>2.5 单元测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SampleTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testCrud</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println((<span class="string">&quot;----- 1. 插入测试 -----&quot;</span>));</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;jack@mp.com&quot;</span>);</span><br><span class="line">        <span class="comment">// 自动生成 ID (雪花算法)</span></span><br><span class="line">        userMapper.insert(user); </span><br><span class="line"></span><br><span class="line">        System.out.println((<span class="string">&quot;----- 2. 查询测试 -----&quot;</span>));</span><br><span class="line">        <span class="comment">// selectList(null) 查询所有</span></span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        userList.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println((<span class="string">&quot;----- 3. 逻辑删除测试 -----&quot;</span>));</span><br><span class="line">        <span class="comment">// 实际上执行的是 UPDATE t_user SET is_deleted=1 WHERE id=?</span></span><br><span class="line">        userMapper.deleteById(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-通用-CRUD-BaseMapper-IService"><a href="#3-通用-CRUD-BaseMapper-IService" class="headerlink" title="3. 通用 CRUD (BaseMapper &amp; IService)"></a>3. 通用 CRUD (BaseMapper &amp; IService)</h2><h3 id="3-1-BaseMapper-数据访问层的基石"><a href="#3-1-BaseMapper-数据访问层的基石" class="headerlink" title="3.1 BaseMapper&lt;T&gt;: 数据访问层的基石"></a>3.1 <code>BaseMapper&lt;T&gt;</code>: 数据访问层的基石</h3><p><code>BaseMapper</code> 是一个泛型接口，定义在数据访问层 (DAO&#x2F;Mapper)。<strong>只要你的 Mapper 接口继承了 <code>BaseMapper</code>，就立即拥有了一整套现成的、无需编写 SQL 的 CRUD 方法。</strong></p>
<h4 id="3-1-1-如何使用"><a href="#3-1-1-如何使用" class="headerlink" title="3.1.1 如何使用"></a>3.1.1 如何使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserMapper.java</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只需继承 BaseMapper&lt;User&gt; 即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里是空的！所有通用方法都已继承</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-2-常用方法一览"><a href="#3-1-2-常用方法一览" class="headerlink" title="3.1.2 常用方法一览"></a>3.1.2 常用方法一览</h4><p><code>BaseMapper</code> 提供了非常丰富的方法，以下是一些最常用的：</p>
<p><strong>插入操作 (Insert):</strong></p>
<ul>
<li><code>int insert(T entity)</code>: 插入一条记录。实体中为 <code>null</code> 的字段<strong>会</strong>被插入到数据库（即插入 <code>NULL</code> 值）。</li>
</ul>
<p><strong>删除操作 (Delete):</strong></p>
<ul>
<li><code>int deleteById(Serializable id)</code>: 根据主键 ID 删除一条记录。</li>
<li><code>int deleteBatchIds(Collection&lt;? extends Serializable&gt; idList)</code>: 根据 ID 批量删除。</li>
<li><code>int deleteByMap(Map&lt;String, Object&gt; columnMap)</code>: 根据 <code>Map</code> 中的列名和值删除记录（多个条件是 AND 关系）。</li>
<li><code>int delete(Wrapper&lt;T&gt; queryWrapper)</code>: 根据条件构造器 (<code>Wrapper</code>) 删除记录。</li>
</ul>
<p><strong>更新操作 (Update):</strong></p>
<ul>
<li><code>int updateById(T entity)</code>: 根据主键 ID 更新。实体中为 <code>null</code> 的字段<strong>不会</strong>被更新。</li>
<li><code>int update(T entity, Wrapper&lt;T&gt; updateWrapper)</code>: 根据 <code>Wrapper</code> 条件更新 <code>entity</code> 中<strong>非 <code>null</code></strong> 的字段。</li>
</ul>
<p><strong>查询操作 (Select):</strong></p>
<ul>
<li><code>T selectById(Serializable id)</code>: 根据主鍵 ID 查询一条记录。</li>
<li><code>List&lt;T&gt; selectBatchIds(Collection&lt;? extends Serializable&gt; idList)</code>: 根据 ID 批量查询。</li>
<li><code>T selectOne(Wrapper&lt;T&gt; queryWrapper)</code>: 根据 <code>Wrapper</code> 条件查询一条记录。如果结果超过 1 条会报错。</li>
<li><code>Long selectCount(Wrapper&lt;T&gt; queryWrapper)</code>: 根据 <code>Wrapper</code> 条件查询记录总数。</li>
<li><code>List&lt;T&gt; selectList(Wrapper&lt;T&gt; queryWrapper)</code>: 根据 <code>Wrapper</code> 条件查询所有记录。</li>
<li><code>IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</code>: 根据 <code>Wrapper</code> 条件进行分页查询。</li>
</ul>
<hr>
<h3 id="3-2-IService-ServiceImpl-业务逻辑层的封装"><a href="#3-2-IService-ServiceImpl-业务逻辑层的封装" class="headerlink" title="3.2 IService&lt;T&gt; &amp; ServiceImpl&lt;M, T&gt;: 业务逻辑层的封装"></a>3.2 <code>IService&lt;T&gt;</code> &amp; <code>ServiceImpl&lt;M, T&gt;</code>: 业务逻辑层的封装</h3><p>虽然 <code>BaseMapper</code> 已经很强大，但在实际分层架构中，我们通常不建议在 Controller 或更上层直接调用 Mapper。业务逻辑应该封装在 Service 层。为此，MP 贴心地提供了 <code>IService</code> 和 <code>ServiceImpl</code>。</p>
<p><strong><code>IService</code> 的作用</strong>：</p>
<ol>
<li><strong>分层解耦</strong>：遵循标准的 <code>Controller -&gt; Service -&gt; Mapper</code> 架构，使代码结构更清晰。</li>
<li><strong>避免循环依赖</strong>: 在复杂的业务中，Service 互相调用比 Mapper 互相调用更易管理。</li>
<li><strong>功能增强</strong>：在 <code>BaseMapper</code> 的基础上，提供了一些更符合业务语义、功能更强大的方法，特别是批量操作。</li>
<li><strong>事务控制</strong>：Service 层是添加声明式事务 (<code>@Transactional</code>) 的理想位置。</li>
</ol>
<hr>
<h4 id="3-2-1-如何使用"><a href="#3-2-1-如何使用" class="headerlink" title="3.2.1 如何使用"></a>3.2.1 如何使用</h4><ol>
<li><p><strong>创建 <code>IService</code> 接口</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IUserService.java</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.IService;</span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 可以在这里定义自定义的业务方法</span></span><br><span class="line">    <span class="comment">// e.g., void registerUser(User user);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建 <code>ServiceImpl</code> 实现类</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserServiceImpl.java</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">    <span class="comment">// ServiceImpl 已经自动注入了 baseMapper (即 UserMapper)，可以直接使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现自定义的业务方法</span></span><br><span class="line">    <span class="comment">// @Transactional</span></span><br><span class="line">    <span class="comment">// public void registerUser(User user) &#123;</span></span><br><span class="line">    <span class="comment">//     // 1. 检查用户名是否存在</span></span><br><span class="line">    <span class="comment">//     // 2. 加密密码</span></span><br><span class="line">    <span class="comment">//     // 3. 调用 baseMapper.insert(user) 或 save(user)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="3-2-2-IService-增强的方法"><a href="#3-2-2-IService-增强的方法" class="headerlink" title="3.2.2 IService 增强的方法"></a>3.2.2 <code>IService</code> 增强的方法</h4><p><code>IService</code> 不仅包含了 <code>BaseMapper</code> 的所有功能（通过 <code>getBaseMapper()</code> 调用），还提供了一些更方便的封装：</p>
<ul>
<li><strong><code>save(T entity)</code></strong>: 保存一条记录（内部调用 <code>insert</code>）。</li>
<li><strong><code>saveBatch(Collection&lt;T&gt; entityList)</code></strong>: 批量插入，默认是循环调用 insert。需配置 <code>rewriteBatchedStatements=true</code> 才能开启 JDBC 级批量优化。</li>
<li><strong><code>saveOrUpdate(T entity)</code></strong>: <strong>有性能损耗</strong>：先查询主键是否存在，再决定 insert 还是 update。高并发慎用。</li>
<li><strong><code>saveOrUpdateBatch(Collection&lt;T&gt; entityList)</code></strong>: 批量插入或更新。</li>
<li><strong><code>removeById(Serializable id)</code></strong>: 根据 ID 删除（内部调用 <code>deleteById</code>）。</li>
<li><strong><code>removeByIds(Collection&lt;?&gt; list)</code></strong>: 批量删除。</li>
<li><strong><code>updateById(T entity)</code></strong>: 根据 ID 更新。</li>
<li><strong><code>updateBatchById(Collection&lt;T&gt; entityList)</code></strong>: 批量更新。</li>
<li><strong><code>getById(Serializable id)</code></strong>: 根据 ID 查询（内部调用 <code>selectById</code>）。</li>
<li><strong><code>getOne(Wrapper&lt;T&gt; queryWrapper)</code></strong>: 查询一条记录。</li>
<li><strong><code>list()</code></strong>: 查询全部。</li>
<li><strong><code>page(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</code></strong>: 分页查询。</li>
</ul>
<hr>
<h3 id="3-3-BaseMapper-vs-IService-总结与最佳实践"><a href="#3-3-BaseMapper-vs-IService-总结与最佳实践" class="headerlink" title="3.3 BaseMapper vs IService (总结与最佳实践)"></a>3.3 <code>BaseMapper</code> vs <code>IService</code> (总结与最佳实践)</h3><table>
<thead>
<tr>
<th align="left">特性&#x2F;方面</th>
<th align="left"><code>BaseMapper&lt;T&gt;</code></th>
<th align="left"><code>IService&lt;T&gt;</code> &#x2F; <code>ServiceImpl&lt;M, T&gt;</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>层级定位</strong></td>
<td align="left"><strong>数据访问层 (DAO&#x2F;Mapper)</strong></td>
<td align="left"><strong>业务逻辑层 (Service)</strong></td>
</tr>
<tr>
<td align="left"><strong>主要职责</strong></td>
<td align="left">直接与数据库交互，执行最底层的 SQL 操作。</td>
<td align="left">封装业务逻辑，处理事务，组合 Mapper 方法。</td>
</tr>
<tr>
<td align="left"><strong>方法命名</strong></td>
<td align="left">偏向 SQL 动词，如 <code>insert</code>, <code>selectById</code>。</td>
<td align="left">偏向业务语义，如 <code>save</code>, <code>getById</code>, <code>remove</code>。</td>
</tr>
<tr>
<td align="left"><strong>批量操作</strong></td>
<td align="left">部分支持（如 <code>selectBatchIds</code>），但功能较少。</td>
<td align="left"><strong>提供了更完善的批量操作</strong>，如 <code>saveBatch</code>, <code>updateBatchById</code>。</td>
</tr>
<tr>
<td align="left"><strong>事务管理</strong></td>
<td align="left">不负责事务。</td>
<td align="left"><strong>是添加 <code>@Transactional</code> 的理想位置。</strong></td>
</tr>
<tr>
<td align="left"><strong>使用建议</strong></td>
<td align="left">在 <code>ServiceImpl</code> 内部调用。<strong>不应直接暴露给 Controller。</strong></td>
<td align="left"><strong>应由 Controller 调用</strong>，作为业务入口。</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong>:</p>
<ol>
<li><strong>严格分层</strong>：始终遵循 <code>Controller -&gt; IService -&gt; UserMapper</code> 的调用链路。Controller 注入 <code>IUserService</code>，而<strong>不是</strong> <code>UserMapper</code>。</li>
<li><strong>业务封装</strong>：将复杂的业务逻辑、多个 Mapper 操作的组合、事务控制等都放在 <code>ServiceImpl</code> 中完成。</li>
<li><strong>优先使用 <code>IService</code> 方法</strong>：在 Service 层，优先使用 <code>IService</code> 提供的 <code>save</code>, <code>getById</code>, <code>list</code> 等方法，因为它们更符合业务语义，且可能包含更优的实现（如批量操作）。</li>
<li><strong>自定义 SQL</strong>：对于 MP 通用方法无法满足的复杂查询（如多表连接），在 <code>UserMapper</code> 接口中定义新方法，并在对应的 XML 文件中编写 SQL，然后在 <code>ServiceImpl</code> 中调用这个自定义的 Mapper 方法。</li>
<li><strong>批量操作性能优化</strong>:<ul>
<li><code>saveBatch</code> 默认并非 JDBC 批量插入。</li>
<li><strong>优化方案</strong>: JDBC URL 必须添加 <code>&amp;rewriteBatchedStatements=true</code>，这样 MySQL 驱动才会将多条 <code>INSERT</code> 语句重写为 <code>INSERT INTO table VALUES (...), (...), (...)</code> 的形式，性能大幅提升。</li>
</ul>
</li>
<li><strong><code>saveOrUpdate</code> 慎用</strong>：在分布式高并发场景下，可能出现“查询时不存在，插入时主键冲突”的异常。对于明确知道是新增还是修改的场景，请显式调用 <code>save</code> 或 <code>update</code>。</li>
</ol>
<hr>
<h2 id="4-条件构造器-Wrapper"><a href="#4-条件构造器-Wrapper" class="headerlink" title="4. 条件构造器 (Wrapper)"></a>4. 条件构造器 (Wrapper)</h2><h3 id="4-1-QueryWrapper-UpdateWrapper"><a href="#4-1-QueryWrapper-UpdateWrapper" class="headerlink" title="4.1 QueryWrapper &amp; UpdateWrapper"></a>4.1 QueryWrapper &amp; UpdateWrapper</h3><h4 id="4-1-1-QueryWrapper"><a href="#4-1-1-QueryWrapper" class="headerlink" title="4.1.1 QueryWrapper&lt;T&gt;"></a>4.1.1 <code>QueryWrapper&lt;T&gt;</code></h4><p><strong>用途</strong>：主要用于构建 <strong>查询</strong> 条件，即 <code>SELECT</code> 语句的 <code>WHERE</code> 子句、<code>ORDER BY</code> 子句等。</p>
<h5 id="1-核心方法"><a href="#1-核心方法" class="headerlink" title="1. 核心方法"></a>1. 核心方法</h5><p><strong>比较操作:</strong></p>
<ul>
<li><code>eq(column, value)</code>: 等于 <code>=</code> (equal)</li>
<li><code>ne(column, value)</code>: 不等于 <code>&lt;&gt;</code> (not equal)</li>
<li><code>gt(column, value)</code>: 大于 <code>&gt;</code> (greater than)</li>
<li><code>ge(column, value)</code>: 大于等于 <code>&gt;=</code> (greater than or equal)</li>
<li><code>lt(column, value)</code>: 小于 <code>&lt;</code> (less than)</li>
<li><code>le(column, value)</code>: 小于等于 <code>&lt;=</code> (less than or equal)</li>
<li><code>between(column, val1, val2)</code>: <code>BETWEEN ... AND ...</code></li>
<li><code>notBetween(column, val1, val2)</code>: <code>NOT BETWEEN ... AND ...</code></li>
</ul>
<p><strong>模糊查询:</strong></p>
<ul>
<li><code>like(column, value)</code>: <code>LIKE &#39;%值%&#39;</code></li>
<li><code>notLike(column, value)</code>: <code>NOT LIKE &#39;%值%&#39;</code></li>
<li><code>likeLeft(column, value)</code>: <code>LIKE &#39;%值&#39;</code> (左模糊)</li>
<li><code>likeRight(column, value)</code>: <code>LIKE &#39;值%&#39;</code> (右模糊)</li>
</ul>
<p><strong>空值判断:</strong></p>
<ul>
<li><code>isNull(column)</code>: <code>... IS NULL</code></li>
<li><code>isNotNull(column)</code>: <code>... IS NOT NULL</code></li>
</ul>
<p><strong>集合操作:</strong></p>
<ul>
<li><code>in(column, collection)</code>: <code>... IN (...)</code></li>
<li><code>notIn(column, collection)</code>: <code>... NOT IN (...)</code></li>
<li><code>inSql(column, sql)</code>: <code>... IN (子查询)</code></li>
</ul>
<p><strong>逻辑连接:</strong></p>
<ul>
<li><code>or()</code>: 连接 <code>OR</code> 条件。例如 <code>... WHERE name = &#39;Tom&#39; OR age &gt; 25</code></li>
<li><code>and(Consumer&lt;Wrapper&gt; consumer)</code>: 嵌套 <code>AND</code> 条件。例如 <code>... AND (name = &#39;Tom&#39; AND age &gt; 25)</code></li>
<li><code>nested(Consumer&lt;Wrapper&gt; consumer)</code>: 正常嵌套，括号内由 <code>AND</code> 连接。</li>
</ul>
<p><strong>排序与分组:</strong></p>
<ul>
<li><code>orderByAsc(column...)</code>: 升序 <code>ORDER BY ... ASC</code></li>
<li><code>orderByDesc(column...)</code>: 降序 <code>ORDER BY ... DESC</code></li>
<li><code>groupBy(column...)</code>: <code>GROUP BY ...</code></li>
</ul>
<p><strong>结果集筛选:</strong></p>
<ul>
<li><code>select(column...)</code>: 指定要查询的字段。例如 <code>select(&quot;id&quot;, &quot;name&quot;)</code> 会生成 <code>SELECT id, name FROM ...</code></li>
</ul>
<hr>
<h5 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="2. 使用示例"></a>2. 使用示例</h5><p><strong>场景</strong>：查询所有年龄在 20 到 30 岁之间、名字中包含 “a”、并且邮箱不为空的用户，结果按年龄降序排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入 UserMapper</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 QueryWrapper 对象</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 链式调用，构建查询条件</span></span><br><span class="line">    queryWrapper.between(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>, <span class="number">30</span>) <span class="comment">// age BETWEEN 20 AND 30</span></span><br><span class="line">                .like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;a&quot;</span>)       <span class="comment">// AND name LIKE &#x27;%a%&#x27;</span></span><br><span class="line">                .isNotNull(<span class="string">&quot;email&quot;</span>)      <span class="comment">// AND email IS NOT NULL</span></span><br><span class="line">                .orderByDesc(<span class="string">&quot;age&quot;</span>);     <span class="comment">// ORDER BY age DESC</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将 Wrapper 作为参数传入 Mapper 方法</span></span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(queryWrapper);</span><br><span class="line"></span><br><span class="line">    userList.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MP 最终生成的 SQL 语句大致如下：<code>SELECT id, name, age, email FROM user WHERE age BETWEEN ? AND ? AND name LIKE ? AND email IS NOT NULL ORDER BY age DESC</code></p>
<hr>
<h4 id="4-1-2-UpdateWrapper"><a href="#4-1-2-UpdateWrapper" class="headerlink" title="4.1.2 UpdateWrapper&lt;T&gt;"></a>4.1.2 <code>UpdateWrapper&lt;T&gt;</code></h4><p><strong>用途</strong>：功能比 <code>QueryWrapper</code> 更广，它既可以用于构建 <strong>更新</strong> 和 <strong>删除</strong> 时的 <code>WHERE</code> 条件，还可以用于指定 <code>UPDATE</code> 语句的 <code>SET</code> 子句。</p>
<h5 id="1-核心方法-1"><a href="#1-核心方法-1" class="headerlink" title="1. 核心方法"></a>1. 核心方法</h5><p><code>UpdateWrapper</code> 继承了 <code>QueryWrapper</code> 的所有 <code>WHERE</code> 构建方法，并在此基础上增加了用于更新操作的方法。</p>
<p><strong>设置更新字段:</strong></p>
<ul>
<li><strong><code>set(column, value)</code></strong>: 核心方法，用于指定 <code>SET column = value</code>。</li>
<li><code>setSql(sql)</code>: 用于设置复杂的 SQL 表达式，如 <code>setSql(&quot;age = age + 1&quot;)</code>。</li>
</ul>
<hr>
<h5 id="2-使用示例-1"><a href="#2-使用示例-1" class="headerlink" title="2. 使用示例"></a>2. 使用示例</h5><p><strong>示例1: 更新操作</strong></p>
<p><strong>场景</strong>：将所有名字为 “Sandy” 的用户的年龄更新为 22 岁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 UpdateWrapper 对象</span></span><br><span class="line">UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 构建 SET 子句和 WHERE 子句</span></span><br><span class="line">updateWrapper.set(<span class="string">&quot;age&quot;</span>, <span class="number">22</span>)         <span class="comment">// SET age = 22</span></span><br><span class="line">             .eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Sandy&quot;</span>);    <span class="comment">// WHERE name = &#x27;Sandy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 调用 update 方法，第一个参数为 null (因为 set 已经在 wrapper 中定义)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">updatedRows</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">System.out.println(<span class="string">&quot;Updated rows: &quot;</span> + updatedRows);</span><br></pre></td></tr></table></figure>

<p>生成的 SQL 语句大致如下：<code>UPDATE user SET age = ? WHERE name = ?</code></p>
<p><strong>示例2: 删除操作</strong></p>
<p><strong>场景</strong>：删除所有年龄大于 60 岁的用户。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 UpdateWrapper 对象 (也可以用 QueryWrapper，因为只用到 WHERE)</span></span><br><span class="line">UpdateWrapper&lt;User&gt; deleteWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 构建 WHERE 子句</span></span><br><span class="line">deleteWrapper.gt(<span class="string">&quot;age&quot;</span>, <span class="number">60</span>); <span class="comment">// WHERE age &gt; 60</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 调用 delete 方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">deletedRows</span> <span class="operator">=</span> userMapper.delete(deleteWrapper);</span><br><span class="line">System.out.println(<span class="string">&quot;Deleted rows: &quot;</span> + deletedRows);</span><br></pre></td></tr></table></figure>

<p>生成的 SQL 语句大致如下：<code>DELETE FROM user WHERE age &gt; ?</code></p>
<hr>
<h3 id="4-2-LambdaQueryWrapper-LambdaUpdateWrapper"><a href="#4-2-LambdaQueryWrapper-LambdaUpdateWrapper" class="headerlink" title="4.2 LambdaQueryWrapper &amp; LambdaUpdateWrapper"></a>4.2 LambdaQueryWrapper &amp; LambdaUpdateWrapper</h3><h4 id="4-2-1-为什么需要-Lambda-Wrapper？"><a href="#4-2-1-为什么需要-Lambda-Wrapper？" class="headerlink" title="4.2.1 为什么需要 Lambda Wrapper？"></a>4.2.1 为什么需要 Lambda Wrapper？</h4><p>使用 <code>QueryWrapper(&quot;name&quot;, &quot;value&quot;)</code> 这种方式存在几个显著的缺点：</p>
<ol>
<li><strong>无编译期安全检查</strong>：如果字段名 <code>name</code> 拼写错误，例如写成了 <code>namae</code>，编译器不会报错，只有在程序运行时才会抛出异常。</li>
<li><strong>重构困难</strong>：当实体类的属性名或数据库字段名需要修改时，你必须手动在整个项目中搜索并替换这些字符串，非常容易出错和遗漏。</li>
<li><strong>IDE 支持不佳</strong>：IDE 无法对字符串进行有效的代码提示、补全或跳转。</li>
</ol>
<p>Lambda Wrapper 通过<strong>方法引用 (Method Reference)</strong> 的方式完美地解决了以上所有问题。</p>
<hr>
<h4 id="4-2-2-核心思想"><a href="#4-2-2-核心思想" class="headerlink" title="4.2.2 核心思想"></a>4.2.2 核心思想</h4><p>Lambda Wrapper 利用了 Java 8 的方法引用特性，例如 <code>User::getName</code>。MyBatis-Plus 可以在运行时解析这个方法引用，从而安全地、动态地获取到对应的属性名 (<code>name</code>)，并根据驼峰命名或注解规则映射到数据库的列名 (<code>name</code> 或 <code>user_name</code>)。</p>
<p>这样一来，字段的指定就从一个不安全的<strong>字符串</strong>变成了一个与实体类强关联的<strong>方法引用</strong>。</p>
<hr>
<h4 id="4-2-3-LambdaQueryWrapper"><a href="#4-2-3-LambdaQueryWrapper" class="headerlink" title="4.2.3 LambdaQueryWrapper&lt;T&gt;"></a>4.2.3 <code>LambdaQueryWrapper&lt;T&gt;</code></h4><p>它是 <code>QueryWrapper</code> 的 Lambda 版本，使用方式几乎完全相同，只是将列名的字符串参数替换为了方法引用。</p>
<p><strong>对比示例</strong></p>
<p><strong>场景</strong>：查询所有年龄在 20 到 30 岁之间、名字中包含 “a”、并且邮箱不为空的用户，结果按年龄降序排序。</p>
<p><strong>之前 (使用 <code>QueryWrapper</code>)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">queryWrapper.between(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">            .like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">            .isNotNull(<span class="string">&quot;email&quot;</span>)</span><br><span class="line">            .orderByDesc(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">List&lt;User&gt; userList = userMapper.selectList(queryWrapper);</span><br></pre></td></tr></table></figure>

<p><strong>现在 (使用 <code>LambdaQueryWrapper</code>)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 LambdaQueryWrapper 对象</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; lambdaQuery = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用方法引用来指定列，更加安全和直观</span></span><br><span class="line">lambdaQuery.between(User::getAge, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">           .like(User::getName, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">           .isNotNull(User::getEmail)</span><br><span class="line">           .orderByDesc(User::getAge);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行查询</span></span><br><span class="line">List&lt;User&gt; userList = userMapper.selectList(lambdaQuery);</span><br></pre></td></tr></table></figure>

<p><strong>LambdaQueryWrapper 的优势</strong></p>
<ol>
<li><strong>编译期安全</strong>：如果你写的 <code>User::getNamae</code> 是一个不存在的方法，代码将无法通过编译，错误在开发阶段就被发现。</li>
<li><strong>代码可读性与智能提示</strong>：IDE 可以为 <code>User::</code> 提供所有 <code>get</code> 方法的提示，代码意图一目了然。</li>
<li><strong>重构友好</strong>：当你想把 <code>User</code> 类的 <code>name</code> 属性重命名为 <code>username</code> 时，只需使用 IDE 的重构功能（例如 <code>Shift+F6</code>），所有相关的 <code>User::getName</code> 引用都会被自动更新为 <code>User::getUsername</code>，安全可靠。</li>
</ol>
<hr>
<h4 id="4-2-4-LambdaUpdateWrapper"><a href="#4-2-4-LambdaUpdateWrapper" class="headerlink" title="4.2.4 LambdaUpdateWrapper&lt;T&gt;"></a>4.2.4 <code>LambdaUpdateWrapper&lt;T&gt;</code></h4><p>同理，<code>LambdaUpdateWrapper</code> 是 <code>UpdateWrapper</code> 的 Lambda 版本。</p>
<p><strong>对比示例</strong></p>
<p><strong>场景</strong>：将所有名字为 “Sandy” 的用户的年龄更新为 22 岁。</p>
<p><strong>之前 (使用 <code>UpdateWrapper</code>)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">updateWrapper.set(<span class="string">&quot;age&quot;</span>, <span class="number">22</span>)</span><br><span class="line">             .eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Sandy&quot;</span>);</span><br><span class="line">userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br></pre></td></tr></table></figure>

<p><strong>现在 (使用 <code>LambdaUpdateWrapper</code>)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LambdaUpdateWrapper&lt;User&gt; lambdaUpdate = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">lambdaUpdate.set(User::getAge, <span class="number">22</span>)</span><br><span class="line">            .eq(User::getName, <span class="string">&quot;Sandy&quot;</span>);</span><br><span class="line">userMapper.update(<span class="literal">null</span>, lambdaUpdate);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-5-总结与最佳实践"><a href="#4-2-5-总结与最佳实践" class="headerlink" title="4.2.5 总结与最佳实践"></a>4.2.5 总结与最佳实践</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>QueryWrapper</code> (字符串)</th>
<th align="left"><code>LambdaQueryWrapper</code> (Lambda)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>语法</strong></td>
<td align="left"><code>wrapper.eq(&quot;name&quot;, &quot;Tom&quot;)</code></td>
<td align="left"><code>wrapper.eq(User::getName, &quot;Tom&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong>类型安全</strong></td>
<td align="left"><strong>无</strong>，依赖字符串的正确性</td>
<td align="left"><strong>有</strong>，依赖方法引用，编译期检查</td>
</tr>
<tr>
<td align="left"><strong>重构支持</strong></td>
<td align="left"><strong>差</strong>，需要手动修改字符串</td>
<td align="left"><strong>优秀</strong>，IDE 可自动重构</td>
</tr>
<tr>
<td align="left"><strong>IDE支持</strong></td>
<td align="left">弱，无代码提示和跳转</td>
<td align="left">强，提供方法提示、补全和跳转</td>
</tr>
<tr>
<td align="left"><strong>推荐度</strong></td>
<td align="left">不推荐在项目中使用</td>
<td align="left"><strong>强烈推荐，是现代 MP 开发的首选</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="4-3-常用查询方法详解"><a href="#4-3-常用查询方法详解" class="headerlink" title="4.3 常用查询方法详解"></a>4.3 常用查询方法详解</h3><h4 id="4-3-1-查询单个对象-selectOne"><a href="#4-3-1-查询单个对象-selectOne" class="headerlink" title="4.3.1 查询单个对象: selectOne()"></a>4.3.1 查询单个对象: <code>selectOne()</code></h4><ul>
<li><p><strong>方法签名</strong>: <code>T selectOne(Wrapper&lt;T&gt; queryWrapper)</code></p>
</li>
<li><p><strong>功能描述</strong>: 根据 <code>Wrapper</code> 条件查询<strong>一条</strong>记录。</p>
</li>
<li><p><strong>使用场景</strong>: 当你预期查询结果<strong>有且仅有一条</strong>时使用。例如，根据唯一的用户名、邮箱或手机号查询用户信息。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户名为 &quot;admin&quot; 的用户</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.eq(User::getName, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">admin</span> <span class="operator">=</span> userMapper.selectOne(wrapper);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (admin != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Found admin user: &quot;</span> + admin);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Admin user not found.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重要注意事项</strong>:</p>
<ul>
<li>如果查询结果<strong>不存在</strong>，此方法返回 <code>null</code>。</li>
<li>如果查询结果<strong>超过一条</strong>，此方法会抛出 <code>TooManyResultsException</code> 异常。这是为了防止脏数据或不严谨的查询条件导致业务逻辑错误，是一个非常重要的保护机制。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-3-2-查询对象列表-selectList"><a href="#4-3-2-查询对象列表-selectList" class="headerlink" title="4.3.2 查询对象列表: selectList()"></a>4.3.2 查询对象列表: <code>selectList()</code></h4><ul>
<li><p><strong>方法签名</strong>: <code>List&lt;T&gt; selectList(Wrapper&lt;T&gt; queryWrapper)</code></p>
</li>
<li><p><strong>功能描述</strong>: 根据 <code>Wrapper</code> 条件查询<strong>所有</strong>满足条件的记录。这是最常用的查询方法。</p>
</li>
<li><p><strong>使用场景</strong>: 查询满足某个条件的一组数据。例如，查询所有年龄大于 18 岁的用户，或查询某个部门下的所有员工。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有年龄大于 18 岁的用户</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.gt(User::getAge, <span class="number">18</span>);</span><br><span class="line">List&lt;User&gt; adults = userMapper.selectList(wrapper);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Total adult users: &quot;</span> + adults.size());</span><br><span class="line">adults.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重要注意事项</strong>:</p>
<ul>
<li>如果查询结果<strong>不存在</strong>，此方法返回一个<strong>空的 <code>List</code></strong> (<code>Collections.emptyList()</code>)，而<strong>不是 <code>null</code></strong>。这避免了空指针异常，是一个很好的设计。</li>
<li><strong>性能警惕</strong>：当查询的表数据量巨大时，在没有分页的情况下直接调用 <code>selectList</code> 可能会一次性加载大量数据到内存，导致<strong>内存溢出 (OOM)</strong>。务必确保你的查询条件足够精确，或者使用分页查询。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-3-3-查询记录总数-selectCount"><a href="#4-3-3-查询记录总数-selectCount" class="headerlink" title="4.3.3 查询记录总数: selectCount()"></a>4.3.3 查询记录总数: <code>selectCount()</code></h4><ul>
<li><p><strong>方法签名</strong>: <code>Long selectCount(Wrapper&lt;T&gt; queryWrapper)</code></p>
</li>
<li><p><strong>功能描述</strong>: 根据 <code>Wrapper</code> 条件查询满足条件的记录<strong>总数</strong>。</p>
</li>
<li><p><strong>使用场景</strong>: 获取总数以用于分页显示，或进行业务统计。例如，统计网站的注册用户总数，或搜索结果的总条目数。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计邮箱后缀为 @gmail.com 的用户数量</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.likeRight(User::getEmail, <span class="string">&quot;@gmail.com&quot;</span>); <span class="comment">// email LIKE &#x27;@gmail.com%&#x27;</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> userMapper.selectCount(wrapper);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Gmail user count: &quot;</span> + count);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重要注意事项</strong>:</p>
<ul>
<li>该方法底层执行的是 <code>SELECT COUNT(*)</code> SQL 语句，比 <code>userMapper.selectList(wrapper).size()</code> 的方式<strong>高效得多</strong>，因为它只返回一个数字，而不需要传输和映射整个结果集。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-3-4-分页查询-selectPage"><a href="#4-3-4-分页查询-selectPage" class="headerlink" title="4.3.4 分页查询: selectPage()"></a>4.3.4 分页查询: <code>selectPage()</code></h4><ul>
<li><p><strong>方法签名</strong>: <code>IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</code></p>
</li>
<li><p><strong>功能描述</strong>: 根据 <code>Wrapper</code> 条件进行<strong>物理分页</strong>查询。</p>
</li>
<li><p><strong>使用场景</strong>: Web 后台管理系统的表格数据展示、App 的信息流列表加载等需要分页的场景。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询第二页，每页 5 条数据</span></span><br><span class="line"><span class="comment">// 1. 创建 Page 对象，传入当前页码和每页数量</span></span><br><span class="line">Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建 Wrapper (可以为 null，表示查询所有)</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.orderByDesc(User::getId); <span class="comment">// 按 ID 降序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行分页查询，返回 IPage 对象</span></span><br><span class="line">IPage&lt;User&gt; userPage = userMapper.selectPage(page, wrapper);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 从 IPage 对象中获取分页信息</span></span><br><span class="line">System.out.println(<span class="string">&quot;总页数: &quot;</span> + userPage.getPages());</span><br><span class="line">System.out.println(<span class="string">&quot;总记录数: &quot;</span> + userPage.getTotal());</span><br><span class="line">System.out.println(<span class="string">&quot;当前页数据: &quot;</span>);</span><br><span class="line">userPage.getRecords().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重要注意事项</strong>:</p>
<ul>
<li><strong>必须配置分页插件！</strong> 使用此方法前，必须在 Spring Boot 配置中添加 <code>MybatisPlusInterceptor</code> 并注册 <code>PaginationInnerInterceptor</code>。否则，<code>selectPage</code> 方法会退化成 <code>selectList</code>，一次性查询出所有数据，无法实现分页效果，并可能导致内存溢出。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-3-5-检查存在性-exists-MP-3-5-3-版本"><a href="#4-3-5-检查存在性-exists-MP-3-5-3-版本" class="headerlink" title="4.3.5 检查存在性: exists() (MP 3.5.3+ 版本)"></a>4.3.5 检查存在性: <code>exists()</code> (MP 3.5.3+ 版本)</h4><ul>
<li><p><strong>方法签名</strong>: <code>boolean exists(Wrapper&lt;T&gt; queryWrapper)</code></p>
</li>
<li><p><strong>功能描述</strong>: 根据 <code>Wrapper</code> 条件判断是否存在满足条件的记录。</p>
</li>
<li><p><strong>使用场景</strong>: 需要快速判断数据是否存在，而不需要获取具体数据。例如，注册时检查用户名是否已被占用。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否存在名为 &quot;root&quot; 的用户</span></span><br><span class="line">LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.eq(User::getName, <span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isExist</span> <span class="operator">=</span> userMapper.exists(wrapper);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isExist) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Username &#x27;root&#x27; already exists.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重要注意事项</strong>:</p>
<ul>
<li>此方法比 <code>selectCount(wrapper) &gt; 0</code> 的方式<strong>更高效</strong>。因为它底层生成的 SQL 是 <code>SELECT 1 FROM ... LIMIT 1</code>，数据库只要找到第一条匹配的记录就会立即返回，而 <code>COUNT</code> 则需要扫描所有满足条件的记录。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-核心插件机制"><a href="#5-核心插件机制" class="headerlink" title="5. 核心插件机制"></a>5. 核心插件机制</h2><h3 id="5-1-分页插件-PaginationInnerInterceptor"><a href="#5-1-分页插件-PaginationInnerInterceptor" class="headerlink" title="5.1 分页插件 (PaginationInnerInterceptor)"></a>5.1 分页插件 (PaginationInnerInterceptor)</h3><h4 id="5-1-1-为什么需要分页插件？"><a href="#5-1-1-为什么需要分页插件？" class="headerlink" title="5.1.1 为什么需要分页插件？"></a>5.1.1 为什么需要分页插件？</h4><p>如果没有分页插件，实现分页查询会非常痛苦：</p>
<ol>
<li><strong>SQL 方言差异</strong>：不同数据库的分页 SQL 完全不同。MySQL 使用 <code>LIMIT</code>, Oracle 使用 <code>ROWNUM</code>, SQL Server 使用 <code>OFFSET...FETCH...</code>。开发者需要为每种数据库编写不同的分页逻辑。</li>
<li><strong>硬编码与拼接</strong>：开发者需要在代码或 XML 中手动拼接分页参数，容易出错且不安全。</li>
<li><strong>逻辑分页的陷阱</strong>：一种错误的做法是查询出所有数据，然后在 Java 内存中进行分页（逻辑分页）。当数据量巨大时，这会立即导致<strong>内存溢出 (OOM)</strong>。</li>
</ol>
<p>MP 的分页插件通过<strong>拦截并改写 SQL</strong>的方式，实现了<strong>物理分页</strong>，从根本上解决了以上所有问题。</p>
<hr>
<h4 id="5-1-2-插件的核心原理"><a href="#5-1-2-插件的核心原理" class="headerlink" title="5.1.2 插件的核心原理"></a>5.1.2 插件的核心原理</h4><p><code>PaginationInnerInterceptor</code> 是 MyBatis-Plus 拦截器链中的一个内部拦截器。它的工作原理如下：</p>
<ol>
<li><strong>拦截</strong>：当 MP 执行一个 Mapper 方法时，<code>MybatisPlusInterceptor</code> 会拦截这次调用。</li>
<li><strong>判断</strong>：<code>PaginationInnerInterceptor</code> 会检查方法的参数中是否包含 <code>IPage</code> 接口的实现类（通常是 <code>Page</code> 对象）。如果包含，就认为这是一次分页查询。</li>
<li><strong>改写 SQL</strong>: 插件会获取本次查询的原始 SQL 语句，并根据配置的数据库类型 (<code>DbType</code>) 和 <code>Page</code> 对象中的分页参数（当前页 <code>current</code>、每页数量 <code>size</code>），自动在原始 SQL 的末尾追加上对应数据库的分页语句（如 <code>LIMIT ?,?</code>）。</li>
<li><strong>执行查询</strong>: 执行被改写后的分页 SQL，获取当前页的数据。</li>
<li><strong>执行 Count 查询</strong>: 插件会自动生成一条 <code>SELECT COUNT(*)</code> 语句（基于原始 SQL）来查询满足条件的总记录数。</li>
<li><strong>封装返回</strong>: 将查询到的当前页数据列表、总记录数、总页数等信息全部封装到传入的 <code>Page</code> 对象中，并最终返回。</li>
</ol>
<hr>
<h4 id="5-1-3-如何配置-Spring-Boot"><a href="#5-1-3-如何配置-Spring-Boot" class="headerlink" title="5.1.3 如何配置 (Spring Boot)"></a>5.1.3 如何配置 (Spring Boot)</h4><p>自 MP 3.4.0 版本起，官方推荐使用 <code>MybatisPlusInterceptor</code> 来统一管理所有内部拦截器。</p>
<ol>
<li>创建一个配置类（例如 <code>MybatisPlusConfig.java</code>）。</li>
<li>将 <code>MybatisPlusInterceptor</code> 注册为一个 Spring Bean。</li>
<li>向 <code>MybatisPlusInterceptor</code> 中添加 <code>PaginationInnerInterceptor</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/config/MybatisPlusConfig.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加分页插件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 定义 MybatisPlusInterceptor 拦截器</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 添加具体的分页插件 PaginationInnerInterceptor</span></span><br><span class="line">        <span class="comment">//    参数指定了数据库类型，MP 会根据该类型生成对应的分页 SQL</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL)); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置说明</strong>:</p>
<ul>
<li><code>DbType.MYSQL</code>: 明确指定数据库类型为 MySQL。MP 支持所有主流数据库，如 <code>ORACLE</code>, <code>POSTGRE_SQL</code> 等。通常 MP 也能自动识别，但显式指定更稳妥。</li>
<li><strong>必须配置</strong>：如果不配置这个 Bean，所有分页相关的调用 (<code>selectPage</code>) 都不会生效，会退化为查询全表数据。</li>
</ul>
<hr>
<h4 id="5-1-4-如何使用"><a href="#5-1-4-如何使用" class="headerlink" title="5.1.4 如何使用"></a>5.1.4 如何使用</h4><p>配置完成后，在 Service 或 Mapper 中使用分页查询就变得非常简单。</p>
<p><strong>核心步骤</strong>：</p>
<ol>
<li>创建一个 <code>Page&lt;T&gt;</code> 对象，指定<strong>当前页码 (current)</strong> 和 <strong>每页显示条数 (size)</strong>。</li>
<li>（可选）创建一个 <code>Wrapper</code> 来设置查询条件。</li>
<li>调用 <code>mapper.selectPage(page, wrapper)</code> 或 <code>service.page(page, wrapper)</code> 方法。</li>
<li>从返回的 <code>IPage&lt;T&gt;</code> 对象中获取分页结果。</li>
</ol>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IPage&lt;User&gt; <span class="title function_">findUsersByPage</span><span class="params">(<span class="type">int</span> currentPage, <span class="type">int</span> pageSize, Integer minAge)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 Page 对象</span></span><br><span class="line">        <span class="comment">// 参数：当前页，每页大小</span></span><br><span class="line">        Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(currentPage, pageSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建查询条件 Wrapper</span></span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (minAge != <span class="literal">null</span>) &#123;</span><br><span class="line">            wrapper.ge(User::getAge, minAge);</span><br><span class="line">        &#125;</span><br><span class="line">        wrapper.orderByDesc(User::getId); <span class="comment">// 按 ID 降序排序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 执行分页查询。</span></span><br><span class="line">        <span class="comment">// MP 会自动将查询结果和分页信息封装到 page 对象中</span></span><br><span class="line">        <span class="comment">// 注意：selectPage 方法的返回值就是传入的 page 对象，也可以不接收返回值直接使用 page。</span></span><br><span class="line">        IPage&lt;User&gt; userPage = <span class="built_in">this</span>.baseMapper.selectPage(page, wrapper);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 从 IPage 对象中获取分页信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;查询结果--------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总记录数: &quot;</span> + userPage.getTotal());</span><br><span class="line">        System.out.println(<span class="string">&quot;总页数: &quot;</span> + userPage.getPages());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前页码: &quot;</span> + userPage.getCurrent());</span><br><span class="line">        System.out.println(<span class="string">&quot;每页数量: &quot;</span> + userPage.getSize());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前页数据: &quot;</span>);</span><br><span class="line">        userPage.getRecords().forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> userPage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-1-5-总结与注意事项"><a href="#5-1-5-总结与注意事项" class="headerlink" title="5.1.5 总结与注意事项"></a>5.1.5 总结与注意事项</h4><ul>
<li><strong>必须配置</strong>：分页插件不是开箱即用的，必须手动将其配置为 Spring Bean。</li>
<li><strong>物理分页</strong>：插件实现的是物理分页，直接在数据库层面完成数据筛选，性能高，内存占用小。</li>
<li><strong>两次 SQL</strong>：一次 <code>selectPage</code> 调用通常会触发<strong>两次</strong>数据库查询：一次是获取总记录数的 <code>COUNT(*)</code> 查询，另一次是获取当前页数据的分页查询。</li>
<li><strong><code>IPage</code> 返回值</strong>：分页查询的返回结果是一个 <code>IPage</code> 对象（<code>Page</code> 是其实现类），它包含了分页所需的所有信息（数据列表、总数、总页数等），可以直接返回给前端进行渲染。</li>
<li><strong>参数传递</strong>：<code>Page</code> 对象是作为参数传入的，MP 在执行过程中会修改这个对象的内容，而不是创建一个新的对象。</li>
</ul>
<hr>
<h3 id="5-2-乐观锁插件-OptimisticLockerInnerInterceptor"><a href="#5-2-乐观锁插件-OptimisticLockerInnerInterceptor" class="headerlink" title="5.2 乐观锁插件 (OptimisticLockerInnerInterceptor)"></a>5.2 乐观锁插件 (OptimisticLockerInnerInterceptor)</h3><p>在多线程或分布式高并发场景下，数据的一致性至关重要。”更新丢失” (Lost Update) 是一个常见的问题：当多个线程同时读取同一条数据，各自修改后又写回数据库，最后一个写回的操作会覆盖掉之前的所有修改，导致数据丢失。</p>
<p><strong>解决并发更新问题的两种主要方式</strong>：</p>
<ol>
<li><strong>悲观锁 (Pessimistic Locking)</strong>: 认为数据冲突总是会发生。在整个数据处理过程中，将数据锁定，阻止其他线程访问。数据库的行锁、表锁（如 <code>SELECT ... FOR UPDATE</code>）都属于悲观锁。<strong>优点</strong>是数据安全，<strong>缺点</strong>是并发性能差。</li>
<li><strong>乐观锁 (Optimistic Locking)</strong>: 认为数据冲突是小概率事件。在数据处理过程中不加锁，而是在<strong>提交更新时检查数据是否被其他线程修改过</strong>。如果没有，则更新成功；如果已被修改，则更新失败，由调用方决定如何处理（如重试或提示用户）。</li>
</ol>
<p>MyBatis-Plus 提供的 <code>OptimisticLockerInnerInterceptor</code> 就是一个优雅的乐观锁实现方案。</p>
<hr>
<h4 id="5-2-1-乐观锁的实现原理"><a href="#5-2-1-乐观锁的实现原理" class="headerlink" title="5.2.1 乐观锁的实现原理"></a>5.2.1 乐观锁的实现原理</h4><p>MP 的乐观锁插件基于 <strong>版本号 (version)</strong> 机制：</p>
<ol>
<li><p>在数据库表中增加一个整型字段，通常命名为 <code>version</code>，用于记录数据的版本号。</p>
</li>
<li><p><strong>读取数据</strong>：当查询数据时，将 <code>version</code> 字段的值一并读出。</p>
</li>
<li><p><strong>更新数据</strong>：当执行更新操作时，将<strong>当前持有的 <code>version</code> 值作为 <code>WHERE</code> 条件的一部分</strong>。同时，在 <code>SET</code> 子句中将 <code>version</code> 值<strong>加一</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设读取出的 version 是 1</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;New Name&#x27;</span>, version <span class="operator">=</span> <span class="number">2</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> version <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结果判断</strong>：</p>
<ul>
<li>如果 <code>WHERE</code> 条件匹配（<code>id=1</code> 且 <code>version=1</code>），说明在你读取数据到提交更新的这段时间内，数据没有被其他线程修改过。更新成功，受影响行数为 1。</li>
<li>如果 <code>WHERE</code> 条件不匹配（受影响行数为 0），说明在你准备更新时，已经有其他线程修改了这条数据，使其 <code>version</code> 值不再是 1。更新失败，表示发生了并发冲突。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-2-2-如何在-MyBatis-Plus-中使用"><a href="#5-2-2-如何在-MyBatis-Plus-中使用" class="headerlink" title="5.2.2 如何在 MyBatis-Plus 中使用"></a>5.2.2 如何在 MyBatis-Plus 中使用</h4><p>使用乐观锁插件非常简单，只需三步：</p>
<p><strong>第 1 步：修改数据库表结构</strong></p>
<p>在需要进行乐观锁控制的表中，添加一个 <code>version</code> 字段（字段名可自定义）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> `<span class="keyword">user</span>` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> `version` <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;版本号&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：初始值建议设为 <code>1</code> 或 <code>0</code>。</p>
<p><strong>第 2 步：修改实体类</strong></p>
<p>在对应的实体类中，添加 <code>version</code> 属性，并使用 <code>@Version</code> 注解标记它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User.java</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.Version;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Version</span> <span class="comment">// 标记这是一个乐观锁版本号字段</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 3 步：配置乐观锁插件</strong></p>
<p>和分页插件一样，将 <code>OptimisticLockerInnerInterceptor</code> 添加到 <code>MybatisPlusInterceptor</code> 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/config/MybatisPlusConfig.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加乐观锁插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加分页插件 (注意插件的添加顺序)</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL)); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：插件的添加顺序可能会影响其行为，通常建议将功能性插件（如乐观锁）放在分页等流程性插件之前。</p>
<hr>
<h4 id="5-2-3-使用示例"><a href="#5-2-3-使用示例" class="headerlink" title="5.2.3 使用示例"></a>5.2.3 使用示例</h4><p>配置完成后，乐观锁插件会自动对<strong>包含 <code>@Version</code> 字段</strong>的实体的<strong>更新操作</strong>生效。你无需在业务代码中做任何特殊处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testOptimisticLocker</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 小王查询商品信息，此时 version=1</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">p1</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小王查询到的版本号: &quot;</span> + p1.getVersion());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 小李也查询该商品信息，此时 version=1</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">p2</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李查询到的版本号: &quot;</span> + p2.getVersion());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 小王将商品价格修改为 90 元，并提交更新</span></span><br><span class="line">    p1.setPrice(<span class="number">90</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> productMapper.updateById(p1);</span><br><span class="line">    System.out.println(<span class="string">&quot;小王更新结果: &quot;</span> + (result1 &gt; <span class="number">0</span> ? <span class="string">&quot;成功&quot;</span> : <span class="string">&quot;失败&quot;</span>));</span><br><span class="line">    <span class="comment">// 此时数据库中 version 变为 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 小李将商品价格修改为 110 元，并提交更新</span></span><br><span class="line">    p2.setPrice(<span class="number">110</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> productMapper.updateById(p2); <span class="comment">// 提交时携带的 version 仍然是 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;小李更新结果: &quot;</span> + (result2 &gt; <span class="number">0</span> ? <span class="string">&quot;成功&quot;</span> : <span class="string">&quot;失败&quot;</span>));</span><br><span class="line">    <span class="comment">// 由于数据库 version 已经是 2，而小李的更新条件是 version=1，所以更新失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 查看最终的商品信息</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">finalProduct</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;最终商品价格: &quot;</span> + finalProduct.getPrice()); <span class="comment">// 应该是 90</span></span><br><span class="line">    System.out.println(<span class="string">&quot;最终版本号: &quot;</span> + finalProduct.getVersion());   <span class="comment">// 应该是 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插件在背后做了什么？</strong></p>
<p>当执行 <code>productMapper.updateById(p2)</code> 时，插件会自动将 SQL 改写为：<code>UPDATE product SET price=110, version=2 WHERE id=1 AND version=1</code></p>
<p>由于数据库中的 <code>version</code> 已经是 2，这个 <code>UPDATE</code> 语句的 <code>WHERE</code> 条件不成立，执行后影响行数为 0，因此 <code>updateById</code> 方法返回 0，表示更新失败。</p>
<hr>
<h4 id="5-2-4-适用场景与注意事项"><a href="#5-2-4-适用场景与注意事项" class="headerlink" title="5.2.4 适用场景与注意事项"></a>5.2.4 适用场景与注意事项</h4><ul>
<li><strong>适用场景</strong>：适用于**“读多写少”**的并发场景。如果写操作非常频繁，冲突会经常发生，导致大量更新失败和重试，反而降低了系统性能。在这种情况下，悲观锁可能更合适。</li>
<li><strong>仅支持特定方法</strong>：乐观锁插件仅对 <code>updateById(T)</code> 和 <code>update(T, Wrapper)</code> 方法生效。对于自定义的 XML 更新语句，插件不会生效，你需要手动在 SQL 中实现版本号的判断和递增。</li>
<li><strong>失败处理</strong>：当更新失败时（返回值为 0 或 false），业务代码需要进行处理，例如：抛出异常提示用户“操作失败，请刷新重试”，或者加入循环进行一定次数的重试。</li>
<li><strong>CAS 思想</strong>：乐观锁的本质是 CAS (Compare-and-Swap) 思想，即“比较并交换”。</li>
</ul>
<hr>
<h2 id="6-代码生成器-AutoGenerator"><a href="#6-代码生成器-AutoGenerator" class="headerlink" title="6. 代码生成器 (AutoGenerator)"></a>6. 代码生成器 (AutoGenerator)</h2><h3 id="6-1-核心功能与优势"><a href="#6-1-核心功能与优势" class="headerlink" title="6.1 核心功能与优势"></a>6.1 核心功能与优势</h3><p><strong>代码生成器 (AutoGenerator)</strong> 是 MyBatis-Plus 的“杀手级”功能。它能根据数据库表结构，自动生成标准的 <strong>Entity、Mapper、Mapper XML、Service、ServiceImpl、Controller</strong> 代码。</p>
<p><strong>核心价值</strong>：</p>
<ul>
<li><strong>解放双手</strong>：彻底告别重复的 CRUD 样板代码编写。</li>
<li><strong>规范统一</strong>：强制统一团队的代码风格（如命名规范、Lombok 使用、API 响应格式）。</li>
<li><strong>快速启动</strong>：新建项目时，能在几秒钟内搭建好完整的业务骨架。</li>
</ul>
<p><strong>版本说明</strong>：</p>
<ul>
<li><strong>旧版 (&lt;&#x3D; 3.5.0)</strong>: 使用 <code>AutoGenerator</code> 类，配置繁琐。</li>
<li><strong>新版 (&gt;&#x3D; 3.5.1)</strong>: 使用 <strong><code>FastAutoGenerator</code></strong>，采用 Builder 模式和 Lambda 表达式，配置极其优雅。<strong>本笔记基于新版讲解。</strong></li>
</ul>
<hr>
<h3 id="6-2-环境准备"><a href="#6-2-环境准备" class="headerlink" title="6.2 环境准备"></a>6.2 环境准备</h3><p>代码生成器是一个独立的模块，通常只需要在<strong>开发环境</strong>中使用（比如写在一个 <code>test</code> 目录下或者一个单独的 <code>Main</code> 方法中），不需要打包到生产环境。</p>
<p>除了 MP 的核心包，还需要引入 <code>mybatis-plus-generator</code> 和一个模板引擎（推荐 <strong>Velocity</strong>）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注意：此依赖仅在开发阶段使用，可以放在 &lt;scope&gt;test&lt;/scope&gt; 或不打包到生产环境 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 版本最好与 mybatis-plus-boot-starter 一致 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果使用 Freemarker 引擎 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">    &lt;groupId&gt;org.freemarker&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">    &lt;artifactId&gt;freemarker&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">    &lt;version&gt;2.3.31&lt;/version&gt;</span></span><br><span class="line"><span class="comment">&lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>编写生成器主类</strong>: 创建一个独立的 Java main 方法来运行代码生成器。这通常放在 <code>src/test/java</code> 目录下，因为它不属于项目的业务代码。</p>
</li>
<li><p><strong>进行配置</strong>: 代码生成器的配置主要分为几个部分：</p>
<ul>
<li><strong>全局配置 (<code>GlobalConfig</code>)</strong>: 设置作者、输出路径、是否覆盖文件等。</li>
<li><strong>数据源配置 (<code>DataSourceConfig</code>)</strong>: 配置数据库连接信息。</li>
<li><strong>包配置 (<code>PackageConfig</code>)</strong>: 设置各层代码生成的包名。</li>
<li><strong>策略配置 (<code>StrategyConfig</code>)</strong>: <strong>核心配置</strong>，用于设置表映射、命名策略、要生成的表、Lombok 支持等。</li>
<li><strong>模板配置 (<code>TemplateConfig</code>)</strong>: （可选）自定义要生成的模板文件路径。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="6-3-示例代码"><a href="#6-3-示例代码" class="headerlink" title="6.3 示例代码"></a>6.3 示例代码</h3><p>新版生成器采用了<strong>交互式</strong>或<strong>硬编码</strong>两种方式。为了方便版本控制和复用，推荐使用<strong>硬编码配置</strong>的方式。</p>
<p>新建一个 Java 类（如 <code>CodeGenerator.java</code>），在 <code>main</code> 方法中运行以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.generator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.FastAutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.OutputFile;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 数据库配置</span></span><br><span class="line">        FastAutoGenerator.create(<span class="string">&quot;jdbc:mysql://localhost:3306/demo_db&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 2. 全局配置</span></span><br><span class="line">                .globalConfig(builder -&gt; &#123;</span><br><span class="line">                    builder.author(<span class="string">&quot;JavaEngineer&quot;</span>) <span class="comment">// 设置作者</span></span><br><span class="line">                            .outputDir(System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;/src/main/java&quot;</span>) <span class="comment">// 指定输出目录</span></span><br><span class="line">                            .commentDate(<span class="string">&quot;yyyy-MM-dd&quot;</span>) <span class="comment">// 注释日期格式</span></span><br><span class="line">                            .disableOpenDir(); <span class="comment">// 禁止生成后自动打开目录</span></span><br><span class="line">                &#125;)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 3. 包配置</span></span><br><span class="line">                .packageConfig(builder -&gt; &#123;</span><br><span class="line">                    builder.parent(<span class="string">&quot;com.example&quot;</span>) <span class="comment">// 父包名</span></span><br><span class="line">                            .moduleName(<span class="string">&quot;user&quot;</span>)   <span class="comment">// 父包模块名 (最终包名: com.example.user)</span></span><br><span class="line">                            .entity(<span class="string">&quot;model.entity&quot;</span>) <span class="comment">// Entity 包名</span></span><br><span class="line">                            .service(<span class="string">&quot;service&quot;</span>)     <span class="comment">// Service 包名</span></span><br><span class="line">                            .mapper(<span class="string">&quot;mapper&quot;</span>)       <span class="comment">// Mapper 包名</span></span><br><span class="line">                            <span class="comment">// 将 XML 文件输出到 resources 目录下</span></span><br><span class="line">                            .pathInfo(Collections.singletonMap(OutputFile.xml, System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;/src/main/resources/mapper&quot;</span>));</span><br><span class="line">                &#125;)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 4. 策略配置 (核心)</span></span><br><span class="line">                .strategyConfig(builder -&gt; &#123;</span><br><span class="line">                    builder.addInclude(<span class="string">&quot;t_user&quot;</span>, <span class="string">&quot;t_order&quot;</span>) <span class="comment">// 设置需要生成的表名</span></span><br><span class="line">                            .addTablePrefix(<span class="string">&quot;t_&quot;</span>, <span class="string">&quot;c_&quot;</span>); <span class="comment">// 设置过滤表前缀 (生成类名时去掉 t_)</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 4.1 Entity 策略</span></span><br><span class="line">                    builder.entityBuilder()</span><br><span class="line">                            .enableLombok() <span class="comment">// 开启 Lombok</span></span><br><span class="line">                            .enableTableFieldAnnotation() <span class="comment">// 开启字段注解</span></span><br><span class="line">                            .logicDeleteColumnName(<span class="string">&quot;is_deleted&quot;</span>); <span class="comment">// 逻辑删除字段</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 4.2 Controller 策略</span></span><br><span class="line">                    builder.controllerBuilder()</span><br><span class="line">                            .enableRestStyle(); <span class="comment">// 开启 @RestController</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 4.3 Service 策略</span></span><br><span class="line">                    builder.serviceBuilder()</span><br><span class="line">                            .formatServiceFileName(<span class="string">&quot;I%sService&quot;</span>) <span class="comment">// 格式化 Service 接口名 (IUserService)</span></span><br><span class="line">                            .formatServiceImplFileName(<span class="string">&quot;%sServiceImpl&quot;</span>); <span class="comment">// 实现类名</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 4.4 Mapper 策略</span></span><br><span class="line">                    builder.mapperBuilder()</span><br><span class="line">                            .enableMapperAnnotation(); <span class="comment">// 开启 @Mapper 注解</span></span><br><span class="line">                &#125;)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 5. 模板引擎 (默认为 Velocity，如果依赖引入了 Freemarker 需在此指定)</span></span><br><span class="line">                <span class="comment">// .templateEngine(new FreemarkerTemplateEngine()) </span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 6. 执行</span></span><br><span class="line">                .execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-4-核心配置详解"><a href="#6-4-核心配置详解" class="headerlink" title="6.4 核心配置详解"></a>6.4 核心配置详解</h3><h4 id="6-4-1-GlobalConfig-全局配置"><a href="#6-4-1-GlobalConfig-全局配置" class="headerlink" title="6.4.1 GlobalConfig (全局配置)"></a>6.4.1 GlobalConfig (全局配置)</h4><p>控制代码生成的整体环境和输出。</p>
<ul>
<li><strong><code>outputDir</code></strong>: <strong>最重要</strong>。建议使用 <code>System.getProperty(&quot;user.dir&quot;) + &quot;/src/main/java&quot;</code> 动态获取当前项目路径，避免硬编码绝对路径导致团队协作报错。</li>
<li><strong><code>author</code></strong>: 生成代码 <code>@author</code> 注释中的名字。</li>
<li><strong><code>fileOverride</code></strong>: <strong>慎用</strong>。是否覆盖已有的文件。通常建议关闭，以免覆盖手写的自定义业务逻辑。</li>
</ul>
<hr>
<h4 id="6-4-2-PackageConfig-包配置"><a href="#6-4-2-PackageConfig-包配置" class="headerlink" title="6.4.2 PackageConfig (包配置)"></a>6.4.2 PackageConfig (包配置)</h4><p>定义生成的类的包结构。</p>
<ul>
<li><strong><code>parent</code></strong>: 父包名，如 <code>com.baidu.tieba</code>。</li>
<li><strong><code>moduleName</code></strong>: 模块名，如 <code>user</code>。最终会生成在 <code>com.baidu.tieba.user</code> 下。</li>
<li><strong><code>pathInfo</code></strong>: 用于特殊指定某些文件（主要是 XML）的生成路径。如果不配置，XML 默认会生成在 <code>src/main/java/.../mapper/xml</code> 下，这通常不符合 Maven 项目的标准结构，建议重定向到 <code>src/main/resources/mapper</code>。</li>
</ul>
<hr>
<h4 id="6-4-3-StrategyConfig-策略配置"><a href="#6-4-3-StrategyConfig-策略配置" class="headerlink" title="6.4.3 StrategyConfig (策略配置)"></a>6.4.3 StrategyConfig (策略配置)</h4><p>控制数据库表到 Java 类的映射规则。</p>
<h5 id="1-通用策略"><a href="#1-通用策略" class="headerlink" title="1. 通用策略"></a>1. 通用策略</h5><ul>
<li><strong><code>addInclude(&quot;table1&quot;, &quot;table2&quot;)</code></strong>: 指定需要生成的表。支持正则。</li>
<li><strong><code>addTablePrefix(&quot;t_&quot;)</code></strong>: 这是一个很棒的功能。数据库表通常叫 <code>t_user</code>，但实体类我们希望叫 <code>User</code>，配置这个可以自动去除前缀。</li>
</ul>
<h5 id="2-Entity-策略-entityBuilder"><a href="#2-Entity-策略-entityBuilder" class="headerlink" title="2. Entity 策略 (entityBuilder)"></a>2. Entity 策略 (<code>entityBuilder</code>)</h5><ul>
<li><strong><code>enableLombok()</code></strong>: 自动添加 <code>@Data</code>, <code>@EqualsAndHashCode</code> 等注解。</li>
<li><strong><code>idType(IdType.ASSIGN_ID)</code></strong>: 指定主键生成策略。</li>
<li><strong><code>enableTableFieldAnnotation()</code></strong>: 给每个字段添加 <code>@TableField</code> 注解。</li>
<li><strong><code>logicDeleteColumnName(&quot;deleted&quot;)</code></strong>: 自动识别逻辑删除字段并添加 <code>@TableLogic</code>。</li>
<li><strong><code>versionColumnName(&quot;version&quot;)</code></strong>: 自动识别乐观锁字段并添加 <code>@Version</code>。</li>
</ul>
<h5 id="3-Controller-策略-controllerBuilder"><a href="#3-Controller-策略-controllerBuilder" class="headerlink" title="3. Controller 策略 (controllerBuilder)"></a>3. Controller 策略 (<code>controllerBuilder</code>)</h5><ul>
<li><strong><code>enableRestStyle()</code></strong>: 生成 <code>@RestController</code> 而不是 <code>@Controller</code>。</li>
<li><strong><code>enableHyphenStyle()</code></strong>: 开启驼峰转连字符。例如 <code>UserController</code> 的 mapping 会变成 <code>/user-controller</code> 而不是 <code>/userController</code>。</li>
</ul>
<h5 id="4-Service-策略-serviceBuilder"><a href="#4-Service-策略-serviceBuilder" class="headerlink" title="4. Service 策略 (serviceBuilder)"></a>4. Service 策略 (<code>serviceBuilder</code>)</h5><ul>
<li><strong><code>formatServiceFileName(&quot;I%sService&quot;)</code></strong>: MyBatis-Plus 默认生成的 Service 接口叫 <code>IUserService</code>，如果不习惯 <code>I</code> 开头，可以在这里修改格式为 <code>%sService</code>。</li>
</ul>
<hr>
<h3 id="6-5-进阶技巧与最佳实践"><a href="#6-5-进阶技巧与最佳实践" class="headerlink" title="6.5 进阶技巧与最佳实践"></a>6.5 进阶技巧与最佳实践</h3><h4 id="6-5-1-交互式生成"><a href="#6-5-1-交互式生成" class="headerlink" title="6.5.1 交互式生成"></a>6.5.1 交互式生成</h4><p>如果你不想每次改代码里的表名，可以使用 MP 提供的 <code>Scanner</code> 从控制台读取输入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 strategyConfig 中使用</span></span><br><span class="line">.strategyConfig(builder -&gt; &#123;</span><br><span class="line">    builder.addInclude(getTables(<span class="string">&quot;请输入表名，多个英文逗号分隔：&quot;</span>));</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getTables</span><span class="params">(String tip)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(tip);</span><br><span class="line">    <span class="keyword">if</span> (scanner.hasNext()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ipt</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(ipt)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.asList(ipt.split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-5-2-自定义模板"><a href="#6-5-2-自定义模板" class="headerlink" title="6.5.2 自定义模板"></a>6.5.2 自定义模板</h4><p>如果 MP 默认生成的代码风格（如注释格式、Controller 的返回值包装）不符合公司规范，你可以：</p>
<ol>
<li><p>找到 <code>mybatis-plus-generator</code> jar 包中的 <code>.vm</code> (Velocity) 文件。</p>
</li>
<li><p>复制到项目的 <code>src/main/resources/templates</code> 目录下。</p>
</li>
<li><p>修改模板内容。</p>
</li>
<li><p>在代码生成器中指定自定义模板路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.templateConfig(builder -&gt; &#123;</span><br><span class="line">    builder.entity(<span class="string">&quot;/templates/my-entity.java&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="6-5-3-避坑指南"><a href="#6-5-3-避坑指南" class="headerlink" title="6.5.3 避坑指南"></a>6.5.3 避坑指南</h4><ol>
<li><strong>不要提交生成器代码</strong>：通常建议将 <code>CodeGenerator</code> 类放在 <code>src/test/java</code> 下，或者在 <code>.gitignore</code> 中忽略，防止生产环境误执行。</li>
<li><strong>XML 路径陷阱</strong>：务必使用 <code>pathInfo</code> 将 XML 映射文件重定向到 <code>resources</code> 目录，否则 Maven 打包时默认不会包含 <code>src/main/java</code> 下的 XML 文件，导致 <code>BindingException</code>。</li>
<li><strong>覆盖风险</strong>：如果是二次开发（表中加了字段），重新生成代码时，默认策略通常是<strong>不覆盖</strong>。如果强制开启覆盖，<strong>务必备份</strong>你自己手写的自定义 Service 方法，否则会被生成器无情抹除。<ul>
<li><em>建议</em>：Entity 和 Mapper XML 可以覆盖（通常不写逻辑），但 Service 和 Controller 尽量手动维护增量更新。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="7-高级特性"><a href="#7-高级特性" class="headerlink" title="7. 高级特性"></a>7. 高级特性</h2><h3 id="7-1-逻辑删除"><a href="#7-1-逻辑删除" class="headerlink" title="7.1 逻辑删除"></a>7.1 逻辑删除</h3><h4 id="7-1-1-什么是逻辑删除？"><a href="#7-1-1-什么是逻辑删除？" class="headerlink" title="7.1.1 什么是逻辑删除？"></a>7.1.1 什么是逻辑删除？</h4><p>在业务系统中，删除操作通常分为两种：</p>
<ol>
<li><strong>物理删除 (Physical Delete)</strong>: 直接从数据库中执行 <code>DELETE</code> 语句，将数据行<strong>永久抹除</strong>。这种操作是不可逆的。</li>
<li><strong>逻辑删除 (Logical Delete &#x2F; Soft Delete)</strong>: 并<strong>不真正删除</strong>数据，而是通过一个特定的字段（例如 <code>is_deleted</code>, <code>status</code> 等）来<strong>标记</strong>这条数据的状态为“已删除”。对于应用程序来说，这条数据就如同被删除了一样，在正常的查询中不会再出现。</li>
</ol>
<p>MyBatis-Plus 提供的逻辑删除功能，就是对<strong>逻辑删除</strong>操作的完美封装和自动化。</p>
<hr>
<h4 id="7-1-2-为什么使用逻辑删除？"><a href="#7-1-2-为什么使用逻辑删除？" class="headerlink" title="7.1.2 为什么使用逻辑删除？"></a>7.1.2 为什么使用逻辑删除？</h4><p>使用逻辑删除主要有以下几个核心优势：</p>
<ul>
<li><strong>数据可恢复</strong>: 这是最大的优点。如果发生误删除操作，只需将标记字段的状态改回去，数据就能立刻恢复，避免了从数据库备份中恢复数据的复杂过程。</li>
<li><strong>保留数据完整性</strong>: 在复杂的关联关系中，物理删除一条主记录可能会导致关联的子记录成为“孤儿数据”，或者因为外键约束而删除失败。逻辑删除则可以保留这些关联关系。</li>
<li><strong>便于审计与追溯</strong>: 所有的数据操作历史都被保留在数据库中，便于日后进行数据审计、问题排查和行为分析。</li>
<li><strong>操作安全</strong>: 避免了因 <code>DELETE</code> 语句 <code>WHERE</code> 条件错误而导致灾难性数据丢失的风险。</li>
</ul>
<hr>
<h4 id="7-1-3-MyBatis-Plus-中的实现原理"><a href="#7-1-3-MyBatis-Plus-中的实现原理" class="headerlink" title="7.1.3 MyBatis-Plus 中的实现原理"></a>7.1.3 MyBatis-Plus 中的实现原理</h4><p>MyBatis-Plus 的逻辑删除功能是通过其<strong>拦截器机制</strong>实现的，对开发者完全透明：</p>
<ol>
<li><strong>改写 <code>DELETE</code></strong>: 当你调用 <code>deleteById()</code> 或 <code>removeById()</code> 等删除方法时，MP 拦截器会捕获这个操作，并自动将其<strong>改写</strong>为一个 <code>UPDATE</code> 语句。<ul>
<li><strong>原始意图</strong>: <code>DELETE FROM user WHERE id = ?</code></li>
<li><strong>MP 实际执行</strong>: <code>UPDATE user SET deleted = 1 WHERE id = ? AND deleted = 0</code></li>
</ul>
</li>
<li><strong>过滤 <code>SELECT</code></strong>: 当你调用 <code>selectList()</code>, <code>selectById()</code>, <code>selectPage()</code> 等所有查询方法时，MP 拦截器会自动在 <code>WHERE</code> 子句的末尾<strong>追加</strong>逻辑删除字段的过滤条件。<ul>
<li><strong>原始意图</strong>: <code>SELECT * FROM user WHERE name = &#39;Tom&#39;</code></li>
<li><strong>MP 实际执行</strong>: <code>SELECT * FROM user WHERE name = &#39;Tom&#39; AND deleted = 0</code></li>
</ul>
</li>
<li><strong>过滤 <code>UPDATE</code></strong>: 同样，在执行更新操作时，也会自动追加过滤条件，以确保你不会更新到一条已经被“删除”的数据。</li>
</ol>
<hr>
<h4 id="7-1-4-如何配置和使用"><a href="#7-1-4-如何配置和使用" class="headerlink" title="7.1.4 如何配置和使用"></a>7.1.4 如何配置和使用</h4><p>在 MP 中启用逻辑删除非常简单，只需两到三步：</p>
<p><strong>第 1 步：数据库表</strong></p>
<p>在需要逻辑删除的表中，增加一个用于标记状态的字段，例如 <code>deleted</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> `<span class="keyword">user</span>` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> `deleted` TINYINT(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;逻辑删除标记 0-未删除 1-已删除&#x27;</span>;</span><br><span class="line"><span class="comment">-- 建议为该字段添加索引，以提高查询性能</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_deleted <span class="keyword">ON</span> <span class="keyword">user</span>(deleted);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 必须为该字段设置一个默认值（通常是 <code>0</code> 表示未删除）。</p>
<p><strong>第 2 步：实体类</strong></p>
<p>在对应的实体类中，添加该字段，并使用 <code>@TableLogic</code> 注解标记。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User.java</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableLogic;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他字段</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TableLogic</span> <span class="comment">// 标记为逻辑删除字段</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 3 步：全局配置 (可选，但强烈推荐)</strong></p>
<p>虽然 <code>@TableLogic</code> 注解可以指定删除和未删除的值，但在 <code>application.yml</code> 或 <code>properties</code> 中进行全局配置是更好的实践，可以统一管理。</p>
<p><strong><code>application.yml</code> 示例:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment"># 逻辑删除字段名 (全局)</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">deleted</span> </span><br><span class="line">      <span class="comment"># 逻辑删除值 (默认为 1)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span></span><br><span class="line">      <span class="comment"># 逻辑未删除值 (默认为 0)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>全局配置 vs 注解</strong>: 如果同时进行了全局配置和 <code>@TableLogic</code> 注解配置，<strong>注解的优先级更高</strong>。</li>
</ul>
<hr>
<h4 id="7-1-5-实际效果"><a href="#7-1-5-实际效果" class="headerlink" title="7.1.5 实际效果"></a>7.1.5 实际效果</h4><p>配置完成后，所有操作都会被 MP 自动处理：</p>
<ul>
<li><p><strong>执行删除</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userMapper.deleteById(<span class="number">1L</span>);</span><br></pre></td></tr></table></figure>

<p><strong>实际执行的 SQL</strong>: <code>UPDATE user SET deleted=1 WHERE id=1 AND deleted=0</code></p>
</li>
<li><p><strong>执行查询</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有用户</span></span><br><span class="line">List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><strong>实际执行的 SQL</strong>: <code>SELECT id,name,age,email,deleted FROM user WHERE deleted=0</code></p>
</li>
<li><p><strong>执行更新</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">1L</span>);</span><br><span class="line">user.setAge(<span class="number">30</span>);</span><br><span class="line">userMapper.updateById(user);</span><br></pre></td></tr></table></figure>

<p><strong>实际执行的 SQL</strong>: <code>UPDATE user SET age=30 WHERE id=1 AND deleted=0</code></p>
</li>
</ul>
<hr>
<h4 id="7-1-6-如何查询被逻辑删除的数据？"><a href="#7-1-6-如何查询被逻辑删除的数据？" class="headerlink" title="7.1.6 如何查询被逻辑删除的数据？"></a>7.1.6 如何查询被逻辑删除的数据？</h4><p>一个常见的需求是，管理员需要一个“回收站”功能来查看并恢复被删除的数据。由于 MP 的查询会自动过滤掉已删除数据，你需要<strong>手写 SQL</strong> 来绕过这个机制。</p>
<p>在 <code>UserMapper</code> 接口中定义一个自定义方法，并在对应的 XML 文件中编写 SQL：</p>
<p><strong><code>UserMapper.java</code></strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectDeletedUsers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>UserMapper.xml</code></strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDeletedUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.entity.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE deleted = 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过这种方式，你可以精确控制何时需要忽略逻辑删除的过滤规则。</p>
<hr>
<h3 id="7-2-自动填充-MetaObjectHandler"><a href="#7-2-自动填充-MetaObjectHandler" class="headerlink" title="7.2 自动填充 (MetaObjectHandler)"></a>7.2 自动填充 (MetaObjectHandler)</h3><p>在大多数业务系统中，许多数据表都包含一些公共字段，如 <code>create_time</code>（创建时间）、<code>update_time</code>（更新时间）、<code>create_by</code>（创建人）、<code>update_by</code>（更新人）等。这些字段的值通常具有固定的填充规则，例如在插入数据时自动设置创建时间和更新时间，在更新数据时自动设置更新时间。</p>
<p>如果在每个 Service 的 <code>save</code> 和 <code>update</code> 方法中都手动设置这些值，不仅会导致大量重复代码，还容易遗漏。</p>
<p>MyBatis-Plus 的<strong>自动填充</strong>功能 (<code>MetaObjectHandler</code>) 就是为了优雅地解决这个问题而设计的。</p>
<hr>
<h4 id="7-2-1-核心思想与原理"><a href="#7-2-1-核心思想与原理" class="headerlink" title="7.2.1 核心思想与原理"></a>7.2.1 核心思想与原理</h4><p><code>MetaObjectHandler</code> 是一个公共字段填充处理器。它的核心思想是利用 AOP（面向切面编程）的理念，在 MP 执行<strong>插入 (<code>insert</code>)</strong> 和 <strong>更新 (<code>update</code>)</strong> 操作时，通过拦截器机制自动对指定字段进行填充。</p>
<p>开发者只需定义一个实现了 <code>MetaObjectHandler</code> 接口的 Bean，并实现其中的 <code>insertFill</code> 和 <code>updateFill</code> 方法，MP 就会在相应的 SQL 执行前调用这些方法，完成对实体对象（<code>metaObject</code>）属性的赋值。</p>
<hr>
<h4 id="7-2-2-如何使用"><a href="#7-2-2-如何使用" class="headerlink" title="7.2.2 如何使用"></a>7.2.2 如何使用</h4><p>实现自动填充功能主要需要三步：</p>
<p><strong>第 1 步：在实体类中标记需要填充的字段</strong></p>
<p>在实体类的属性上，使用 <code>@TableField</code> 注解并指定 <code>fill</code> 策略。</p>
<ul>
<li><code>FieldFill.INSERT</code>: 只在<strong>插入</strong>时填充。</li>
<li><code>FieldFill.UPDATE</code>: 只在<strong>更新</strong>时填充。</li>
<li><code>FieldFill.INSERT_UPDATE</code>: 在<strong>插入和更新</strong>时都填充。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User.java</span></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span> <span class="comment">// 插入时填充</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span> <span class="comment">// 插入和更新时都填充</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> String createBy;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> String updateBy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 2 步：创建 <code>MetaObjectHandler</code> 实现类</strong></p>
<p>创建一个类，实现 <code>MetaObjectHandler</code> 接口，并重写 <code>insertFill</code> 和 <code>updateFill</code> 方法。在这个类中定义具体的字段填充逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/handler/MyMetaObjectHandler.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.MetaObject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// **重要**：必须将处理器注入到 Spring 容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入操作时的填充策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject 元数据对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start insert fill ....&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 参1: 实体类的属性名, 不是数据库的字段名</span></span><br><span class="line">        <span class="comment">// 参2: 要填充的值</span></span><br><span class="line">        <span class="comment">// 参3: 元数据对象</span></span><br><span class="line">        <span class="built_in">this</span>.strictInsertFill(metaObject, <span class="string">&quot;createTime&quot;</span>, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">        <span class="built_in">this</span>.strictInsertFill(metaObject, <span class="string">&quot;updateTime&quot;</span>, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 示例：填充创建人（需要从当前会话或安全上下文中获取）</span></span><br><span class="line">        <span class="comment">// String currentUsername = getCurrentUsername(); // 假设有方法可以获取当前用户名</span></span><br><span class="line">        <span class="comment">// this.strictInsertFill(metaObject, &quot;createBy&quot;, String.class, currentUsername);</span></span><br><span class="line">        <span class="comment">// this.strictInsertFill(metaObject, &quot;updateBy&quot;, String.class, currentUsername);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新操作时的填充策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject 元数据对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start update fill ....&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.strictUpdateFill(metaObject, <span class="string">&quot;updateTime&quot;</span>, LocalDateTime.class, LocalDateTime.now());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// String currentUsername = getCurrentUsername();</span></span><br><span class="line">        <span class="comment">// this.strictUpdateFill(metaObject, &quot;updateBy&quot;, String.class, currentUsername);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>strict...Fill</code> vs <code>setFieldValByName</code></strong>:</p>
<ul>
<li><code>setFieldValByName(fieldName, fieldVal, metaObject)</code>: 无论属性值是否已存在，都会强制覆盖。</li>
<li><code>strictInsertFill(metaObject, fieldName, fieldType, fieldVal)</code>: 更严谨的版本。它会先判断实体中该属性是否已有值，<strong>只有在值为 <code>null</code> 时才进行填充</strong>。这允许你在业务代码中手动设置一个特定的创建时间，而不会被自动填充覆盖。<code>strictUpdateFill</code> 同理。<strong>官方推荐使用 <code>strict</code> 版本。</strong></li>
</ul>
<p><strong>第 3 步：将 Handler 注册为 Spring Bean</strong></p>
<p>只需在 <code>MyMetaObjectHandler</code> 类上添加 <code>@Component</code> 或 <code>@Configuration</code> 注解，确保它被 Spring IoC 容器管理即可。MyBatis-Plus 的 starter 会自动检测并装配它。</p>
<hr>
<h4 id="7-2-3-实际效果"><a href="#7-2-3-实际效果" class="headerlink" title="7.2.3 实际效果"></a>7.2.3 实际效果</h4><p>配置完成后，当你执行插入或更新操作时，不再需要手动设置这些公共字段。</p>
<p><strong>插入操作</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setName(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">userService.save(user); <span class="comment">// 或者 userMapper.insert(user)</span></span><br></pre></td></tr></table></figure>

<p><strong>实际执行的 SQL 会包含自动填充的字段</strong>:</p>
<p><code>INSERT INTO user ( name, create_time, update_time ) VALUES ( &#39;Jack&#39;, &#39;2023-10-27 10:00:00&#39;, &#39;2023-10-27 10:00:00&#39; )</code></p>
<p><strong>更新操作</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(<span class="number">1L</span>);</span><br><span class="line">user.setName(<span class="string">&quot;Jack-updated&quot;</span>);</span><br><span class="line">userService.updateById(user);</span><br></pre></td></tr></table></figure>

<p><strong>实际执行的 SQL 会自动更新 <code>update_time</code> 字段</strong>:</p>
<p><code>UPDATE user SET name=&#39;Jack-updated&#39;, update_time=&#39;2023-10-27 10:05:00&#39; WHERE id=1</code></p>
<hr>
<h4 id="7-2-4-获取当前操作人"><a href="#7-2-4-获取当前操作人" class="headerlink" title="7.2.4 获取当前操作人"></a>7.2.4 获取当前操作人</h4><p>在 <code>MetaObjectHandler</code> 中填充 <code>createBy</code> 和 <code>updateBy</code> 字段是一个常见的需求。这通常需要从当前的用户会话中获取登录信息。一种常见的实现方式是：</p>
<ol>
<li>使用 <strong>Spring Security</strong> 或其他安全框架，用户信息保存在 <code>SecurityContextHolder</code> 中。</li>
<li>使用 <strong><code>ThreadLocal</code></strong>。在请求进入 Controller 或经过某个 Filter&#x2F;Interceptor 时，将当前用户信息存入 <code>ThreadLocal</code>，在 <code>MetaObjectHandler</code> 中从中读取，请求结束后再清除。</li>
</ol>
<hr>
<h3 id="7-3-主键策略"><a href="#7-3-主键策略" class="headerlink" title="7.3 主键策略"></a>7.3 主键策略</h3><h4 id="7-3-1-简介"><a href="#7-3-1-简介" class="headerlink" title="7.3.1 简介"></a>7.3.1 简介</h4><p>主键 (Primary Key, PK) 是数据库中每条记录的唯一标识。如何生成和管理主键，在不同的系统架构下有不同的最佳实践。在单体应用中，数据库的自增 ID (Auto Increment) 简单高效；但在分布式、微服务架构下，依赖单个数据库的自增 ID 会带来扩展性问题和主键冲突的风险。</p>
<p>MyBatis-Plus (MP) 深刻理解这一挑战，内置了多种主键生成策略，并通过简单的配置即可应用，使得主键管理变得异常轻松。</p>
<hr>
<h4 id="7-3-2-配置方式"><a href="#7-3-2-配置方式" class="headerlink" title="7.3.2 配置方式"></a>7.3.2 配置方式</h4><p>MP 主要通过在实体类的主键字段上使用 <code>@TableId</code> 注解来配置主键策略。其核心属性是 <code>type</code>，它接收一个 <code>IdType</code> 枚举值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@TableId</span> 注解用于标识主键字段</span></span><br><span class="line"><span class="comment">     * type 属性用于指定主键生成策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableId(type = IdType.ASSIGN_ID)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... other fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7-3-3-核心主键策略详解"><a href="#7-3-3-核心主键策略详解" class="headerlink" title="7.3.3 核心主键策略详解"></a>7.3.3 核心主键策略详解</h4><p><code>IdType</code> 枚举定义了以下几种常用的主键策略：</p>
<h5 id="1-IdType-AUTO-数据库ID自增"><a href="#1-IdType-AUTO-数据库ID自增" class="headerlink" title="1. IdType.AUTO (数据库ID自增)"></a>1. <code>IdType.AUTO</code> (数据库ID自增)</h5><ul>
<li><strong>描述</strong>: 依赖数据库自身的 ID 自增机制来生成主键。例如 MySQL 的 <code>AUTO_INCREMENT</code>。</li>
<li><strong>如何工作</strong>: 当插入数据时，MP 不会为主键赋值，而是由数据库生成后，再通过 JDBC 将生成的主键值回填到实体对象中。</li>
<li><strong>适用场景</strong>: 单体应用、数据量不大、没有分库分表需求的简单项目。这是最传统、最简单的方式。</li>
<li><strong>配置</strong>: <code>@TableId(type = IdType.AUTO)</code></li>
</ul>
<h5 id="2-IdType-ASSIGN-ID-雪花算法-默认-推荐"><a href="#2-IdType-ASSIGN-ID-雪花算法-默认-推荐" class="headerlink" title="2. IdType.ASSIGN_ID (雪花算法, 默认&#x2F;推荐)"></a>2. <code>IdType.ASSIGN_ID</code> (雪花算法, 默认&#x2F;推荐)</h5><ul>
<li><strong>描述</strong>: MP 默认的主键策略。它使用<strong>雪花算法 (Snowflake)</strong> 在应用程序层面生成一个全局唯一的、趋势递增的 64 位长整型 ID。</li>
<li><strong>雪花算法简介</strong>: 该算法生成的 ID 由 <code>时间戳 + 数据中心ID + 机器ID + 序列号</code> 组合而成，保证了在分布式系统中的全局唯一性和高性能。</li>
<li><strong>优点</strong>:<ul>
<li><strong>全局唯一</strong>: 在分布式环境下，不同机器生成的 ID 不会冲突。</li>
<li><strong>高性能</strong>: ID 在本地生成，不依赖数据库，性能极高。</li>
<li><strong>趋势递增</strong>: ID 整体上随时间增长，有利于数据库索引的性能。</li>
<li><strong>数值类型</strong>: 作为数值型主键，查询效率高于字符串类型。</li>
</ul>
</li>
<li><strong>适用场景</strong>: <strong>微服务、分布式系统、高并发应用</strong>。这是 MP 在分布式场景下的<strong>首选推荐</strong>策略。</li>
<li><strong>配置</strong>: <code>@TableId(type = IdType.ASSIGN_ID)</code> 或不写 <code>type</code> 属性（因为它是默认值）。</li>
</ul>
<h5 id="3-IdType-ASSIGN-UUID-UUID"><a href="#3-IdType-ASSIGN-UUID-UUID" class="headerlink" title="3. IdType.ASSIGN_UUID (UUID)"></a>3. <code>IdType.ASSIGN_UUID</code> (UUID)</h5><ul>
<li><strong>描述</strong>: 使用 UUID (Universally Unique Identifier) 算法生成一个全局唯一的字符串 ID。</li>
<li><strong>如何工作</strong>: 生成一个类似 <code>550e8400-e29b-41d4-a716-446655440000</code> 的 32 位十六进制字符串作为主键。</li>
<li><strong>优点</strong>:<ul>
<li><strong>全局唯一</strong>: 绝对的全局唯一，不依赖任何中心节点。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>字符串类型</strong>: 占用存储空间大，查询性能低于数值型主键。</li>
<li><strong>无序性</strong>: UUID 是无序的，作为主键会导致数据库索引频繁重建，插入性能下降。</li>
<li><strong>可读性差</strong>。</li>
</ul>
</li>
<li><strong>适用场景</strong>: 当主键需要对外暴露，且不希望其具有规律性（如订单号、支付流水号的场景，但通常这些是业务ID而非主键），或者对主键的唯一性要求极高而不在乎性能时。</li>
<li><strong>配置</strong>: <code>@TableId(type = IdType.ASSIGN_UUID)</code></li>
</ul>
<h5 id="4-IdType-INPUT-用户输入"><a href="#4-IdType-INPUT-用户输入" class="headerlink" title="4. IdType.INPUT (用户输入)"></a>4. <code>IdType.INPUT</code> (用户输入)</h5><ul>
<li><strong>描述</strong>: 表示主键由用户或业务代码<strong>手动设置</strong>。MP 不会为其生成任何值。</li>
<li><strong>如何工作</strong>: 在执行 <code>insert</code> 操作之前，你必须手动为实体的主键字段赋一个值。</li>
<li><strong>适用场景</strong>: 当主键本身具有业务含义时，例如使用用户的学号、身份证号、或自定义的编码作为主键。</li>
<li><strong>配置</strong>: <code>@TableId(type = IdType.INPUT)</code></li>
</ul>
<h5 id="5-IdType-NONE-无状态"><a href="#5-IdType-NONE-无状态" class="headerlink" title="5. IdType.NONE (无状态)"></a>5. <code>IdType.NONE</code> (无状态)</h5><ul>
<li><strong>描述</strong>: 表示未设置主键类型，MP 会遵循全局配置。如果全局也未配置，则等同于 <code>INPUT</code>。</li>
</ul>
<h5 id="6-IdType-SEQUENCE-序列"><a href="#6-IdType-SEQUENCE-序列" class="headerlink" title="6. IdType.SEQUENCE (序列)"></a>6. <code>IdType.SEQUENCE</code> (序列)</h5><ul>
<li><strong>描述</strong>: 使用数据库的序列（Sequence）来生成主键。这是 Oracle、PostgreSQL 等数据库推荐的主键生成方式。需要配合 <code>@KeySequence</code> 注解使用。</li>
</ul>
<hr>
<h4 id="7-3-4-全局主键策略配置"><a href="#7-3-4-全局主键策略配置" class="headerlink" title="7.3.4 全局主键策略配置"></a>7.3.4 全局主键策略配置</h4><p>除了在每个实体类上单独配置，你还可以在 <code>application.yml</code> 中配置一个全局的主键生成策略。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment"># 设置全局的主键生成策略为数据库自增</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure>

<p><strong>优先级</strong>: 实体类上的 <code>@TableId</code> 注解配置的优先级 <strong>高于</strong> 全局配置。</p>
<hr>
<h4 id="7-3-5-策略选型总结"><a href="#7-3-5-策略选型总结" class="headerlink" title="7.3.5 策略选型总结"></a>7.3.5 策略选型总结</h4><table>
<thead>
<tr>
<th align="left">策略 (<code>IdType</code>)</th>
<th align="left">描述</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>AUTO</code></td>
<td align="left">数据库自增</td>
<td align="left">简单、连续、易于理解</td>
<td align="left">仅限单数据库，不适用于分布式</td>
<td align="left">单体应用，简单项目</td>
</tr>
<tr>
<td align="left"><strong><code>ASSIGN_ID</code></strong></td>
<td align="left"><strong>雪花算法</strong></td>
<td align="left"><strong>全局唯一、高性能、趋势递增</strong></td>
<td align="left">依赖时间，时钟回拨可能导致问题</td>
<td align="left"><strong>微服务、分布式系统、高并发（强烈推荐）</strong></td>
</tr>
<tr>
<td align="left"><code>ASSIGN_UUID</code></td>
<td align="left">UUID字符串</td>
<td align="left">全局唯一，无中心依赖</td>
<td align="left">字符串性能差、无序、占用空间大</td>
<td align="left">对唯一性要求极高，不关心性能的场景</td>
</tr>
<tr>
<td align="left"><code>INPUT</code></td>
<td align="left">手动输入</td>
<td align="left">灵活，主键可具业务含义</td>
<td align="left">需要手动管理，易出错</td>
<td align="left">主键有明确业务意义（如身份证号）</td>
</tr>
<tr>
<td align="left"><code>SEQUENCE</code></td>
<td align="left">数据库序列</td>
<td align="left">高性能、数据库原生支持</td>
<td align="left">特定数据库（Oracle等）</td>
<td align="left">使用支持序列的数据库时</td>
</tr>
</tbody></table>
<hr>
<hr>
<h1 id="四、JPA-Hibernate"><a href="#四、JPA-Hibernate" class="headerlink" title="四、JPA &amp; Hibernate"></a>四、JPA &amp; Hibernate</h1><h2 id="1-核心概念与架构定位"><a href="#1-核心概念与架构定位" class="headerlink" title="1. 核心概念与架构定位"></a>1. 核心概念与架构定位</h2><h3 id="1-1-JPA-Jakarta-Persistence-API"><a href="#1-1-JPA-Jakarta-Persistence-API" class="headerlink" title="1.1 JPA (Jakarta Persistence API)"></a>1.1 JPA (Jakarta Persistence API)</h3><p><strong>JPA</strong> 是 Java EE (现 Jakarta EE) 体系中定义的<strong>标准 ORM 规范</strong> (JSR-338)，旨在解决对象范式与关系数据库范式之间的<strong>阻抗不匹配 (Impedance Mismatch)</strong> 问题。</p>
<ul>
<li><strong>本质</strong>：JPA 是一套<strong>接口 (Interfaces)</strong>、<strong>注解 (Annotations)</strong> 和<strong>语义规范</strong>，它本身<strong>不提供</strong>具体的持久化实现（即它不能直接连接数据库）。</li>
<li><strong>核心组件</strong>：<ol>
<li><strong>ORM 映射元数据</strong>：通过 <code>@Entity</code>, <code>@Table</code>, <code>@Column</code>, <code>@OneToMany</code> 等注解描述对象与关系表的映射。</li>
<li><strong>EntityManager API</strong>：操作实体的核心接口，定义了 <code>persist</code>, <code>merge</code>, <code>remove</code>, <code>find</code> 等标准动作。</li>
<li><strong>JPQL (Java Persistence Query Language)</strong>：一种<strong>面向对象</strong>的查询语言，解析时会被翻译成特定数据库的 SQL。</li>
<li><strong>Entity Lifecycle (实体生命周期)</strong>：定义了实体在 <code>New</code>, <code>Managed</code>, <code>Detached</code>, <code>Removed</code> 四种状态间的流转规则。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="1-2-Hibernate"><a href="#1-2-Hibernate" class="headerlink" title="1.2 Hibernate"></a>1.2 Hibernate</h3><p><strong>Hibernate</strong> 是一个成熟、开源的 <strong>ORM 框架</strong>，也是 JPA 规范的<strong>事实标准实现 (Reference Implementation)</strong>。</p>
<ul>
<li><strong>定位</strong>：Hibernate 位于 JPA 接口之下，JDBC 之上。它负责解析 JPA 注解，生成 SQL 语句，并通过 JDBC 驱动与数据库交互。</li>
<li><strong>特性</strong>：<ul>
<li><strong>全功能实现</strong>：完整实现了 JPA 规范。</li>
<li><strong>超集功能</strong>：提供了 JPA 规范之外的高级特性，如特定的 ID 生成策略、二级缓存的具体实现、HQL (Hibernate Query Language) 等。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-深度对比"><a href="#1-3-深度对比" class="headerlink" title="1.3 深度对比"></a>1.3 深度对比</h3><table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">JPA (规范)</th>
<th align="left">Hibernate (框架&#x2F;实现)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>角色</strong></td>
<td align="left"><strong>接口标准 (Interface)</strong></td>
<td align="left"><strong>服务提供商 (Provider)</strong></td>
</tr>
<tr>
<td align="left"><strong>核心对象</strong></td>
<td align="left"><code>EntityManagerFactory</code>, <code>EntityManager</code></td>
<td align="left"><code>SessionFactory</code>, <code>Session</code></td>
</tr>
<tr>
<td align="left"><strong>查询语言</strong></td>
<td align="left"><strong>JPQL</strong> (Java Persistence QL)</td>
<td align="left"><strong>HQL</strong> (Hibernate QL, JPQL 的超集)</td>
</tr>
<tr>
<td align="left"><strong>可移植性</strong></td>
<td align="left"><strong>高</strong>。面向 JPA 编程可轻松切换底层实现（如切换到 EclipseLink）。</td>
<td align="left"><strong>低</strong>。若使用 Hibernate 特有 API，将绑定在该框架上。</td>
</tr>
<tr>
<td align="left"><strong>依赖关系</strong></td>
<td align="left">不依赖具体实现，只依赖 <code>jakarta.persistence</code> 包。</td>
<td align="left">依赖 JDBC，并作为 JPA 的 SPI (Service Provider Interface) 存在。</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-核心概念"><a href="#2-核心概念" class="headerlink" title="2. 核心概念"></a>2. 核心概念</h2><h3 id="2-1-实体-Entity"><a href="#2-1-实体-Entity" class="headerlink" title="2.1 实体 (Entity)"></a>2.1 实体 (Entity)</h3><p><strong>实体是 JPA 的核心</strong>。它不仅仅是 POJO，更是持久化上下文管理的核心单元。</p>
<ul>
<li><strong>定义</strong>: 一个轻量级的、持久化的领域对象，通常代表数据库表中的一行记录。</li>
<li><strong>核心规范 (Best Practices)</strong>:<ol>
<li><strong>注解标记</strong>: 必须使用 <code>@Entity</code> 标记类，<code>@Id</code> 标记主键。</li>
<li><strong>构造函数</strong>: 必须包含一个无参构造函数（<code>public</code> 或 <code>protected</code>），供 JPA 反射实例化使用。</li>
<li><strong>非 Final</strong>: 实体类及其方法最好不要定义为 <code>final</code>。<ul>
<li><em>原理</em>: Hibernate 经常使用 CGLIB 生成实体的<strong>动态代理 (Proxy)</strong> 来实现延迟加载。如果类是 <code>final</code> 的，无法生成子类代理，会导致延迟加载失效。</li>
</ul>
</li>
<li><strong>序列化</strong>: 建议实现 <code>Serializable</code> 接口。<ul>
<li><em>场景</em>: 当实体需要在网络传输（如 RPC）、存储到二级缓存（Redis）或在集群间复制时，必须支持序列化。</li>
</ul>
</li>
</ol>
</li>
<li><strong>Entity vs DTO</strong>:<ul>
<li><strong>Entity</strong>: 有状态（Managed&#x2F;Detached），与数据库强绑定，生命周期受 EM 管理。</li>
<li><strong>DTO</strong>: 无状态，仅用于数据传输，纯粹的 Java Bean。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span> <span class="comment">// 标记这是一个实体类</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_user&quot;)</span> <span class="comment">// 映射到数据库的 t_user 表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="comment">// 标记这是主键</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span> <span class="comment">// 主键生成策略</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_name&quot;, length = 50)</span> <span class="comment">// 映射到 user_name 列</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age; <span class="comment">// 如果属性名和列名相同，可以省略 @Column</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123; <span class="comment">// 必须有无参构造</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... Getters and Setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-EntityManagerFactory-实体管理器工厂"><a href="#2-2-EntityManagerFactory-实体管理器工厂" class="headerlink" title="2.2 EntityManagerFactory (实体管理器工厂)"></a>2.2 EntityManagerFactory (实体管理器工厂)</h3><ul>
<li><strong>定义</strong>: 根据配置信息（<code>persistence.xml</code> 或 Spring Boot 配置）创建的重量级工厂对象。</li>
<li><strong>架构地位</strong>: 对应 Hibernate 的 <code>SessionFactory</code>。</li>
<li><strong>核心特征</strong>:<ul>
<li><strong>重量级 &amp; 不可变</strong>: 初始化时需要读取元数据、构建数据库连接池、预编译 SQL 等，资源消耗极大。</li>
<li><strong>线程安全</strong>: 设计为多线程共享，内部维护了二级缓存（Second-level Cache）。</li>
<li><strong>单例模式</strong>: 在一个应用（或一个数据库源）中，通常<strong>全局唯一</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-EntityManager-实体管理器"><a href="#2-3-EntityManager-实体管理器" class="headerlink" title="2.3 EntityManager (实体管理器)"></a>2.3 EntityManager (实体管理器)</h3><ul>
<li><strong>定义</strong>: 应用程序与持久化上下文交互的<strong>主要运行时接口</strong>。</li>
<li><strong>架构地位</strong>: 对应 Hibernate 的 <code>Session</code>。</li>
<li><strong>关键特性</strong>:<ul>
<li><strong>轻量级</strong>: 创建销毁成本低。</li>
<li><strong>非线程安全</strong>: <strong>绝对禁止</strong>在多线程间共享同一个 <code>EntityManager</code> 实例（如将其设为 Servlet 的静态变量）。</li>
</ul>
</li>
<li><strong>Spring 环境下的特殊性 (重要)</strong>:<ul>
<li>在 Spring Service 中，我们经常看到 <code>@PersistenceContext EntityManager em;</code> 注入到单例 Bean 中。</li>
<li><strong>为什么不报错？</strong> Spring 注入的不是真实的 <code>EntityManager</code>，而是一个 <strong>Shared EntityManager Proxy (共享代理)</strong>。</li>
<li><strong>原理</strong>: 这个代理会根据当前的线程（ThreadLocal），自动路由到当前事务绑定的那个真实的 <code>EntityManager</code> 实例。因此，代码看起来是共享的，实际运行时是<strong>线程隔离</strong>的。</li>
</ul>
</li>
<li><strong>核心 API 扩展</strong>:<ul>
<li><code>flush()</code>: <strong>强制</strong>将上下文中的变更同步到数据库（执行 SQL），但不提交事务。</li>
<li><code>refresh(entity)</code>: 丢弃当前实体的修改，重新从数据库加载最新状态（用于覆盖脏数据）。</li>
<li><code>getReference(class, id)</code>: <strong>延迟加载</strong>的核心。只返回一个代理对象（只有 ID 有值），直到真正调用 getter 时才查库。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-4-持久化上下文-Persistence-Context"><a href="#2-4-持久化上下文-Persistence-Context" class="headerlink" title="2.4 持久化上下文 (Persistence Context)"></a>2.4 持久化上下文 (Persistence Context)</h3><p><strong>这是 JPA 的“一级缓存”和“逻辑数据库”。</strong></p>
<ul>
<li><strong>本质</strong>: <code>EntityManager</code> 内部维护的一组<strong>实体实例的集合</strong>。</li>
<li><strong>三大核心机制</strong>:<ol>
<li><strong>Identity Map (唯一标识映射)</strong>:<ul>
<li>在同一下文中，多次查询 ID&#x3D;1 的 User，返回的永远是<strong>同一个内存地址</strong>的对象。</li>
<li><em>作用</em>: 避免重复查询，解决循环引用问题，保证事务内数据一致性。</li>
</ul>
</li>
<li><strong>Write-Behind (事务写后&#x2F;延迟写入)</strong>:<ul>
<li>调用 <code>persist/merge</code> 时，JPA 仅把对象放入上下文，<strong>不立即执行 SQL</strong>。</li>
<li><em>触发 SQL 的时机</em>:<ol>
<li>事务提交 (<code>commit</code>) 时。</li>
<li>显式调用 <code>flush()</code> 时。</li>
<li>执行 JPQL 查询前 (为了保证查询结果包含最新的内存变更，通常会自动 flush)。</li>
</ol>
</li>
</ul>
</li>
<li><strong>Dirty Checking (自动脏检查)</strong>:<ul>
<li><strong>原理</strong>: 实体加载时，Context 会保存一份<strong>快照 (Snapshot)</strong>。</li>
<li><strong>流程</strong>: <code>flush</code> 时，对比当前实体与快照。若有差异，自动生成并执行 <code>UPDATE</code> 语句。</li>
<li><em>优势</em>: 开发者无需手写 <code>update</code> 语句，面向对象操作即可。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-5-实体生命周期-Entity-Lifecycle"><a href="#2-5-实体生命周期-Entity-Lifecycle" class="headerlink" title="2.5 实体生命周期 (Entity Lifecycle)"></a>2.5 实体生命周期 (Entity Lifecycle)</h3><p>一个实体对象在其生命周期中会经历四种状态，<code>EntityManager</code> 的方法就是用来驱动实体在这些状态之间转换的。</p>
<ol>
<li><strong>新建态 (New &#x2F; Transient)</strong><ul>
<li><strong>描述</strong>: 一个刚刚 <code>new</code> 出来的 POJO 对象，它还没有主键，也<strong>没有</strong>被任何持久化上下文所管理。</li>
<li><strong>特点</strong>: 数据库中没有与之对应的记录。</li>
</ul>
</li>
<li><strong>托管态 (Managed &#x2F; Persistent)</strong><ul>
<li><strong>描述</strong>: 实体<strong>正在</strong>被一个持久化上下文所管理。</li>
<li><strong>来源</strong>:<ul>
<li>通过 <code>em.find()</code> 或 JPQL 查询从数据库加载而来。</li>
<li>通过 <code>em.persist()</code> 将一个新建态实体转入。</li>
<li>通过 <code>em.merge()</code> 将一个游离态实体转入。</li>
</ul>
</li>
<li><strong>特点</strong>: <strong>所有对该实体属性的修改都会被自动脏检查机制监视，并在事务提交时同步到数据库。</strong></li>
</ul>
</li>
<li><strong>游离态 (Detached)</strong><ul>
<li><strong>描述</strong>: 实体曾经被持久化上下文管理，但该上下文<strong>已经关闭</strong> (<code>em.close()</code>)，或者实体被<strong>明确地</strong>从上下文中分离 (<code>em.detach()</code>)。</li>
<li><strong>特点</strong>: 实体仍然拥有主键，但它已不再受 JPA 管理。对它的任何修改都<strong>不会</strong>被自动同步到数据库。</li>
</ul>
</li>
<li><strong>删除态 (Removed)</strong><ul>
<li><strong>描述</strong>: 实体正在被持久化上下文管理，但已被标记为删除状态（通过 <code>em.remove()</code>）。</li>
<li><strong>特点</strong>: 在事务提交时，数据库中与该实体对应的记录将被删除。</li>
</ul>
</li>
</ol>
<pre><code class="highlight mermaid">graph TD
    A[New 新建态] --&gt;|persist| B(Managed 托管态)
    B --&gt;|remove| D[Removed 删除态]
    B --&gt;|Transaction Commit / close / detach| C[Detached 游离态]
    
    C --&gt;|merge| B
    C --&gt;|无操作| Garbage[垃圾回收]
    
    D --&gt;|persist| B
    D --&gt;|flush / Commit| DB[数据库记录被删除]
    
    DB_Record[数据库记录] --&gt;|find / query| B</code></pre>

<ul>
<li><strong>Merge 的陷阱</strong>: <code>T managedEntity = em.merge(detachedEntity);</code><ul>
<li><code>merge</code> 方法<strong>不会</strong>把传入的 <code>detachedEntity</code> 变成托管态。</li>
<li>它会创建一个<strong>新的</strong>对象（或查找已有的），把数据的属性复制过去，然后返回这个<strong>新的托管对象</strong>。</li>
<li><strong>错误写法</strong>: <code>em.merge(user); user.setName(&quot;new&quot;);</code> (user 还是游离态，修改无效)</li>
<li><strong>正确写法</strong>: <code>User managedUser = em.merge(user); managedUser.setName(&quot;new&quot;);</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-6-事务-Transaction"><a href="#2-6-事务-Transaction" class="headerlink" title="2.6 事务 (Transaction)"></a>2.6 事务 (Transaction)</h3><ul>
<li><strong>JPA 的事务模型</strong>:<ul>
<li>JPA 自身不实现复杂的事务逻辑，它依赖于底层的事务管理器（如 JDBC 事务或 JTA 分布式事务）。</li>
</ul>
</li>
<li><strong>原子性约束</strong>: 所有的 <code>persist</code>, <code>merge</code>, <code>remove</code> 操作必须在事务内执行，否则会抛出 <code>TransactionRequiredException</code>。</li>
<li><strong>读写分离</strong>: 虽然 <code>find</code> (查询) 可以在非事务环境下运行（Nontransactional Read），但为了保证隔离级别和一级缓存的一致性，建议所有数据库操作都在事务内完成。</li>
<li><strong>Spring 整合</strong>: 在实际开发中，我们几乎不手动处理 <code>em.getTransaction().begin/commit</code>，而是全权委托给 Spring 的 <code>@Transactional</code> 注解。</li>
</ul>
<hr>
<h2 id="3-Spring-Data-JPA-快速实战"><a href="#3-Spring-Data-JPA-快速实战" class="headerlink" title="3. Spring Data JPA 快速实战"></a>3. Spring Data JPA 快速实战</h2><p>在现代 Spring Boot 开发中，我们极少直接操作原生的 <code>EntityManager</code>。<strong>Spring Data JPA</strong> 在 JPA 规范之上构建了一层抽象（Repository Pattern），通过<strong>动态代理</strong>技术，极大地减少了样板代码。</p>
<h3 id="3-1-环境与依赖"><a href="#3-1-环境与依赖" class="headerlink" title="3.1 环境与依赖"></a>3.1 环境与依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- JPA 核心 starter: 包含 Spring Data JPA, Hibernate, Jakarta Persistence API, HikariCP --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- Web 模块 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 数据库驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- Lombok: 简化代码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: <code>spring-boot-starter-data-jpa</code> 会自动传递依赖引入 <strong>Hibernate</strong> 作为默认的 JPA 实现。</p>
<hr>
<h3 id="3-2-工程化配置"><a href="#3-2-工程化配置" class="headerlink" title="3.2 工程化配置"></a>3.2 工程化配置</h3><p>除了基础连接，我们需要关注连接池配置和 DDL 策略。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">datasource</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">url</span>: <span class="string">jdbc:mysql://localhost:3306/demo_db?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line">    <span class="attr">username</span>: <span class="string">root</span></span><br><span class="line">    <span class="attr">password</span>: <span class="string">your_password</span></span><br><span class="line">    <span class="attr">driver-class-name</span>: <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment">    # HikariCP 连接池配置 (生产环境至关重要)</span></span><br><span class="line">    <span class="attr">hikari</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">minimum-idle</span>: <span class="string">5</span></span><br><span class="line">      <span class="attr">maximum-pool-size</span>: <span class="string">20</span></span><br><span class="line">      <span class="attr">idle-timeout</span>: <span class="string">30000</span></span><br><span class="line">      <span class="attr">max-lifetime</span>: <span class="string">1800000</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">jpa</span>:<span class="string"></span></span><br><span class="line"><span class="comment">    # 自动根据实体更新表结构</span></span><br><span class="line"><span class="comment">    # 开发环境: update (更新表结构), create (每次启动重建), create-drop (关闭时删除)</span></span><br><span class="line"><span class="comment">    # 生产环境: validate (仅校验), none (关闭，推荐配合 Flyway/Liquibase 管理)</span></span><br><span class="line">    <span class="attr">hibernate</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">ddl-auto</span>: <span class="string">update</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    # 控制台日志配置</span></span><br><span class="line">    <span class="attr">show-sql</span>: <span class="string">true</span></span><br><span class="line">    <span class="attr">properties</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">hibernate</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">format_sql</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">        # 命名策略: 将驼峰命名(firstName)自动映射为下划线(first_name)</span></span><br><span class="line">        <span class="attr">physical_naming_strategy</span>: <span class="string">org.hibernate.boot.model.naming.CamelCaseToUnderscoresNamingStrategy</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    # Open-Session-In-View 模式</span></span><br><span class="line"><span class="comment">    # true (默认): 允许在 Controller 层懒加载。优点是方便，缺点是连接占用时间长，且容易产生 N+1 问题。</span></span><br><span class="line"><span class="comment">    # false (推荐): 强制在 Service 层完成事务和数据加载。</span></span><br><span class="line">    <span class="attr">open-in-view</span>: <span class="string">false </span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-创建实体类-Entity"><a href="#3-3-创建实体类-Entity" class="headerlink" title="3.3 创建实体类 (Entity)"></a>3.3 创建实体类 (Entity)</h3><p><strong>常见的错误做法</strong>：在 Entity 上直接使用 Lombok 的 <code>@Data</code>。</p>
<p><strong>原因</strong>：<code>@Data</code> 会生成 <code>equals()</code> 和 <code>hashCode()</code> 方法，它们默认包含所有字段。如果实体间存在双向关联（如 User &lt;-&gt; Order），计算 HashCode 会触发无限递归调用，导致 <code>StackOverflowError</code>。即使没有递归，访问关联字段也会触发意外的<strong>懒加载</strong>，影响性能。</p>
<p><strong>最佳实践</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.persistence.*;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_user&quot;)</span> <span class="comment">// 建议显式指定表名，避免数据库关键字冲突</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(length = 50, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(unique = true)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在这里重写 equals 和 hashCode</span></span><br><span class="line">    <span class="comment">// 建议仅使用 id 进行比较，或者直接使用 Object 默认的内存地址比较</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;</span><br><span class="line">        <span class="keyword">return</span> id != <span class="literal">null</span> &amp;&amp; id.equals(user.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 固定返回一个常量是 Hibernate 官方推荐的做法，确保对象在持久化前后 HashCode 不变</span></span><br><span class="line">        <span class="keyword">return</span> getClass().hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-4-创建-Repository-接口"><a href="#3-4-创建-Repository-接口" class="headerlink" title="3.4 创建 Repository 接口"></a>3.4 创建 Repository 接口</h3><p>继承 <code>JpaRepository</code> 即可获得标准 CRUD 能力。Spring Data JPA 利用<strong>动态代理</strong>在运行时生成接口的实现类（通常是 <code>SimpleJpaRepository</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 方法名解析查询 (Query Creation) ---</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// SQL: select * from t_user where username = ?</span></span><br><span class="line">    Optional&lt;User&gt; <span class="title function_">findByUsername</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SQL: select * from t_user where email like ?</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByEmailContaining</span><span class="params">(String email)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SQL: select * from t_user where age &gt; ? order by age desc</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByAgeGreaterThanOrderByAgeDesc</span><span class="params">(Integer age)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --- 复杂查询建议使用 @Query (后续章节详解) ---</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-5-单元测试"><a href="#3-5-单元测试" class="headerlink" title="3.5 单元测试"></a>3.5 单元测试</h3><p>使用 <code>Assertions</code> 进行验证，模拟真实的业务逻辑校验。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.repository.UserRepository;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCrudLifecycle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Create (Save)</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(<span class="string">&quot;DevExpert&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">25</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;dev@example.com&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// save() 原理: </span></span><br><span class="line">        <span class="comment">// 检查 ID 是否为空。</span></span><br><span class="line">        <span class="comment">// 若为空 -&gt; EntityManager.persist() -&gt; Insert</span></span><br><span class="line">        <span class="comment">// 若不为空 -&gt; EntityManager.merge() -&gt; Select (check exist) + Update</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">savedUser</span> <span class="operator">=</span> userRepository.save(user);</span><br><span class="line">        </span><br><span class="line">        Assertions.assertNotNull(savedUser.getId(), <span class="string">&quot;ID should be generated&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Read</span></span><br><span class="line">        Optional&lt;User&gt; fetchUser = userRepository.findById(savedUser.getId());</span><br><span class="line">        Assertions.assertTrue(fetchUser.isPresent());</span><br><span class="line">        Assertions.assertEquals(<span class="string">&quot;DevExpert&quot;</span>, fetchUser.get().getUsername());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Update</span></span><br><span class="line">        savedUser.setAge(<span class="number">30</span>);</span><br><span class="line">        userRepository.save(savedUser); <span class="comment">// 再次 save 即为 update</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. Delete</span></span><br><span class="line">        userRepository.deleteById(savedUser.getId());</span><br><span class="line">        Assertions.assertFalse(userRepository.findById(savedUser.getId()).isPresent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-实体关系映射"><a href="#4-实体关系映射" class="headerlink" title="4. 实体关系映射"></a>4. 实体关系映射</h2><p>在真实的业务场景中，数据库的表之间往往存在着各种关联关系，如一个用户有多个订单，一个订单属于一个用户。JPA 提供了一套丰富的注解，用于在实体类 (Entity) 之间精确地描述这些关系。正确地进行关系映射是 ORM 框架的核心价值所在。</p>
<p>数据库中的关系主要有四种：<strong>一对一 (OneToOne)</strong>, <strong>一对多 (OneToMany)</strong>, <strong>多对一 (ManyToOne)</strong>, 和 <strong>多对多 (ManyToMany)</strong>。</p>
<h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><p>关系映射是 JPA 最强大也最容易导致<strong>性能崩塌</strong>的地方。核心在于理解<strong>所有权（Ownership）</strong>、<strong>抓取策略（Fetch Strategy）以及级联行为（Cascading）</strong>。</p>
<ul>
<li><strong>关系拥有方 (Owning Side)</strong>:<ul>
<li><strong>定义</strong>: 数据库中<strong>持有外键</strong>的那一方。</li>
<li><strong>职责</strong>: 只有修改拥有方的关联属性，数据库的外键值才会改变。</li>
<li><strong>标志</strong>: 必须使用 <code>@JoinColumn</code> 或 <code>@JoinTable</code>。</li>
</ul>
</li>
<li><strong>关系被拥有方 (Inverse Side)</strong>:<ul>
<li><strong>定义</strong>: 仅仅是拥有方的镜像。</li>
<li><strong>职责</strong>: 方便查询，修改它的属性<strong>不会</strong>影响数据库外键。</li>
<li><strong>标志</strong>: 必须使用 <code>mappedBy</code>。</li>
</ul>
</li>
<li><strong>同步方法 (Helper Methods)</strong>:<ul>
<li><strong>痛点</strong>: 设置了双向关联后，如果在内存中只设置了一方（如 <code>order.setCustomer(c)</code>），另一方的集合（<code>c.getOrders()</code>）里并不会自动包含该订单。这会导致同一事务中的逻辑错误。</li>
<li><strong>解法</strong>: 在实体类中封装 <code>add/remove</code> 方法，同时维护两端关系。</li>
</ul>
</li>
<li><strong>级联操作 (Cascade)</strong>: 当对主实体进行操作（如 <code>persist</code>, <code>remove</code>, <code>merge</code>）时，是否要将该操作<strong>级联</strong>到其关联的实体上。通过 <code>@...To...</code> 注解的 <code>cascade</code> 属性来配置。</li>
<li><strong>抓取策略 (Fetch)</strong>: 当加载一个实体时，是否要<strong>立即</strong>加载其关联的实体（<strong>饥饿加载 Eager Fetch</strong>），还是在<strong>第一次访问</strong>关联实体时才去加载（<strong>懒加载 Lazy Fetch</strong>）。通过 <code>@...To...</code> 注解的 <code>fetch</code> 属性来配置。</li>
</ul>
<hr>
<h3 id="4-2-多对一-ManyToOne-一对多-OneToMany"><a href="#4-2-多对一-ManyToOne-一对多-OneToMany" class="headerlink" title="4.2 多对一 (ManyToOne) &amp; 一对多 (OneToMany)"></a>4.2 多对一 (ManyToOne) &amp; 一对多 (OneToMany)</h3><p>这是最常见的一种关系。例如：<strong>多个订单 (<code>Order</code>) 属于一个客户 (<code>Customer</code>)</strong>。</p>
<ul>
<li><strong><code>@ManyToOne</code></strong>: 放在“多”的一方（<code>Order</code>），表示多个订单对应一个客户。</li>
<li><strong><code>@OneToMany</code></strong>: 放在“一”的一方（<code>Customer</code>），表示一个客户拥有一个订单列表。</li>
</ul>
<p><strong>数据库表结构</strong>: <code>t_order</code> 表中会有一个 <code>customer_id</code> 外键列，指向 <code>t_customer</code> 表的主键。</p>
<p><strong>实体类定义</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户实体 (&quot;一&quot;的一方)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_customer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@OneToMany</span>: 声明一对多关系</span></span><br><span class="line"><span class="comment">     * mappedBy = &quot;customer&quot;: </span></span><br><span class="line"><span class="comment">     *      - 指明这个关联关系由 Order 实体的 &quot;customer&quot; 属性来维护。</span></span><br><span class="line"><span class="comment">     *      - 这意味着 Customer 是关系的【被拥有方】，它不包含外键。</span></span><br><span class="line"><span class="comment">     *      - &quot;customer&quot; 必须是 Order 类中 <span class="doctag">@ManyToOne</span> 注解的那个字段名。</span></span><br><span class="line"><span class="comment">     * cascade = CascadeType.ALL: </span></span><br><span class="line"><span class="comment">     *      - 级联所有操作。保存客户时会自动保存其名下的新订单，删除客户时会自动删除其所有订单。</span></span><br><span class="line"><span class="comment">     * fetch = FetchType.LAZY:</span></span><br><span class="line"><span class="comment">     *      - 懒加载。查询客户时，默认不加载其订单列表，只有在首次调用 getOrders() 时才会去查询数据库。</span></span><br><span class="line"><span class="comment">     *      - 【最佳实践】所有集合类型的关联（OneToMany, ManyToMany）都应配置为懒加载，避免性能问题。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = &quot;customer&quot;, cascade = CascadeType.ALL, fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订单实体 (&quot;多&quot;的一方)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String orderNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@ManyToOne</span>: 声明多对一关系</span></span><br><span class="line"><span class="comment">     * fetch = FetchType.EAGER:</span></span><br><span class="line"><span class="comment">     *      - 饥饿加载。查询订单时，会立即通过 LEFT JOIN 将其关联的客户信息一并查询出来。</span></span><br><span class="line"><span class="comment">     *      - 【默认策略】...ToOne 关系的默认抓取策略是 EAGER。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@JoinColumn</span>(name = &quot;customer_id&quot;):</span></span><br><span class="line"><span class="comment">     *      - 指定外键列。这表明 Order 是关系的【拥有方】。</span></span><br><span class="line"><span class="comment">     *      - name = &quot;customer_id&quot; 指的是 t_order 表中的外键列名。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.EAGER)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;customer_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-一对一-OneToOne"><a href="#4-3-一对一-OneToOne" class="headerlink" title="4.3 一对一 (OneToOne)"></a>4.3 一对一 (OneToOne)</h3><h4 id="4-3-1-概念与场景"><a href="#4-3-1-概念与场景" class="headerlink" title="4.3.1 概念与场景"></a>4.3.1 概念与场景</h4><p>一对一关系在业务中非常常见，例如：一个<strong>用户 (<code>User</code>)</strong> 对应一个<strong>用户详情 (<code>UserProfile</code>)</strong>。</p>
<p>在数据库层面，通常通过以下两种方式实现：</p>
<ol>
<li><strong>唯一外键</strong>: 在从表（如 <code>t_user_profile</code>）中添加 <code>user_id</code> 外键，并设置唯一约束 (<code>UNIQUE</code>)。</li>
<li><strong>共享主键</strong>: 两个表共享同一个主键值（既是主键也是外键）。</li>
</ol>
<hr>
<h4 id="4-3-2-代码实现（外键方式）"><a href="#4-3-2-代码实现（外键方式）" class="headerlink" title="4.3.2 代码实现（外键方式）"></a>4.3.2 代码实现（外键方式）</h4><p>以下展示标准的<strong>双向一对一</strong>配置。</p>
<ul>
<li><strong>Owning Side (维护方&#x2F;从表)</strong>: <code>UserProfile</code>，持有外键。</li>
<li><strong>Inverse Side (被维护方&#x2F;主表)</strong>: <code>User</code>，不持有外键，通过 <code>mappedBy</code> 映射。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- 主表 (被维护方) ---</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. mappedBy = &quot;user&quot;: 放弃外键维护权，指向 UserProfile 中的 user 属性。</span></span><br><span class="line"><span class="comment">     * 2. cascade = CascadeType.ALL: 级联保存/删除。</span></span><br><span class="line"><span class="comment">     * 3. fetch = FetchType.LAZY: 意图是懒加载 (但在 OneToOne 中往往失效，见下文分析)。</span></span><br><span class="line"><span class="comment">     * 4. optional = false: 业务语义，表示 User 必须有 Profile。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OneToOne(mappedBy = &quot;user&quot;, cascade = CascadeType.ALL, fetch = FetchType.LAZY, optional = false)</span></span><br><span class="line">    <span class="keyword">private</span> UserProfile userProfile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 从表 (维护方) ---</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_user_profile&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProfile</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@JoinColumn</span>: 指定外键列名 (user_id)，并确立为关系的拥有方。</span></span><br><span class="line"><span class="comment">     * 对于拥有方(持有外键的一方)，懒加载通常是有效的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OneToOne(fetch = FetchType.LAZY)</span> </span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;user_id&quot;, unique = true)</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-3-核心陷阱：懒加载失效"><a href="#4-3-3-核心陷阱：懒加载失效" class="headerlink" title="4.3.3 核心陷阱：懒加载失效"></a>4.3.3 核心陷阱：懒加载失效</h4><p><code>OneToOne</code> 看起来简单，但在 <strong>不持有外键的一方 (Inverse Side &#x2F; User端)</strong> 存在一个著名的性能陷阱。</p>
<ul>
<li><strong>问题现象</strong>:<br>即使在 <code>User</code> 端定义了 <code>@OneToOne(fetch = LAZY, mappedBy = &quot;user&quot;)</code>，当你查询 <code>User</code> 列表时，Hibernate <strong>依然会立即</strong>为每个 User 发起查询去获取 <code>UserProfile</code>（即变成了 EAGER），导致严重的 N+1 问题。</li>
<li><strong>根本原因</strong>:<ul>
<li><strong>代理机制的限制</strong>: Hibernate 实现懒加载通常通过创建一个“代理对象”赋给属性。</li>
<li><strong>信息的缺失</strong>: <code>User</code> 表中没有外键列。加载 <code>User</code> 时，Hibernate 不知道这个用户到底<strong>有没有</strong>对应的 <code>UserProfile</code>。<ul>
<li>如果有，应该放一个代理对象。</li>
<li>如果没有，属性应该是 <code>null</code>。</li>
</ul>
</li>
<li><strong>结果</strong>: 为了确定是赋 <code>null</code> 还是赋代理对象，Hibernate 被迫立即查询 <code>t_user_profile</code> 表，从而导致懒加载失效。</li>
</ul>
</li>
<li>对比: 在持有外键的一方（<code>UserProfile</code>），因为 <code>user_id</code> 列就在表中，Hibernate 也就是看一眼字段值：如果是 null，属性就设为 null；如果有值，就创建代理。所以维护方的懒加载是有效的。</li>
</ul>
<hr>
<h4 id="4-3-4-解决方案"><a href="#4-3-4-解决方案" class="headerlink" title="4.3.4 解决方案"></a>4.3.4 解决方案</h4><p>针对主表（User端）懒加载失效的问题，有以下几种解决思路：</p>
<ol>
<li><strong>共享主键 (@MapsId) 【推荐】</strong>:<ul>
<li>让 <code>UserProfile</code> 的 ID 直接映射 <code>User</code> 的 ID。</li>
<li><strong>优点</strong>: 节省一个外键列，且因为主键一致，Hibernate 更好处理关系，虽不能完全解决所有场景的懒加载，但通常是 1:1 的最佳实践。</li>
</ul>
</li>
<li><strong>字节码增强 (Bytecode Enhancement)</strong>:<ul>
<li>在编译期修改字节码。</li>
<li><strong>缺点</strong>: 配置复杂，构建链繁琐，一般不推荐。</li>
</ul>
</li>
<li><strong>强制必填 (optional &#x3D; false) + 妥协</strong>:<ul>
<li>如果在 <code>User</code> 端设置 <code>@OneToOne(optional = false)</code>，你是告诉 Hibernate：“放心，Profile 一定存在”。</li>
<li>在某些 Hibernate 版本配合字节码增强时，这能起作用，但在纯 JPA 运行环境下，往往还是会退化为 EAGER。</li>
<li><strong>妥协方案</strong>: 如果无法使用 <code>@MapsId</code>，通常建议接受 EAGER，或者将设计改为 <code>OneToMany</code> (List size 限制为 1)，因为 <code>OneToMany</code> 的懒加载是绝对可靠的。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-4-多对多-ManyToMany"><a href="#4-4-多对多-ManyToMany" class="headerlink" title="4.4 多对多 (ManyToMany)"></a>4.4 多对多 (ManyToMany)</h3><h4 id="4-4-1-概念与场景"><a href="#4-4-1-概念与场景" class="headerlink" title="4.4.1 概念与场景"></a>4.4.1 概念与场景</h4><p>例如：一个<strong>学生 (<code>Student</code>)</strong> 可以选择多门<strong>课程 (<code>Course</code>)</strong>，一门课程也可以被多个学生选择。</p>
<p>在关系型数据库中，两张表无法直接建立多对多关系，必须引入一个<strong>中间表（连接表&#x2F;Junction Table）</strong>。</p>
<ul>
<li><strong>表结构</strong>: <code>t_student</code> (主表), <code>t_course</code> (主表), <code>t_student_course</code> (中间表)。</li>
<li><strong>中间表内容</strong>: 至少包含 <code>student_id</code> 和 <code>course_id</code> 两个外键作为联合主键。</li>
</ul>
<hr>
<h4 id="4-4-2-标准实现（使用-ManyToMany）"><a href="#4-4-2-标准实现（使用-ManyToMany）" class="headerlink" title="4.4.2 标准实现（使用@ManyToMany）"></a>4.4.2 标准实现（使用<code>@ManyToMany</code>）</h4><p>在简单的业务场景（中间表不需要存储额外数据）下，可以使用标准的 <code>@ManyToMany</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- 拥有方 (Student) ---</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_student&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@ManyToMany</span></span></span><br><span class="line"><span class="comment">     * 1. 集合类型推荐使用 Set 而非 List，以避免 Hibernate 删除/插入时的低效操作。</span></span><br><span class="line"><span class="comment">     * 2. <span class="doctag">@JoinTable</span>: 定义中间表细节。</span></span><br><span class="line"><span class="comment">     *    - name: 中间表表名 &quot;t_student_course&quot;。</span></span><br><span class="line"><span class="comment">     *    - joinColumns: 当前实体(Student)在中间表的外键列名 &quot;student_id&quot;。</span></span><br><span class="line"><span class="comment">     *    - inverseJoinColumns: 对方实体(Course)在中间表的外键列名 &quot;course_id&quot;。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ManyToMany(fetch = FetchType.LAZY, cascade = CascadeType.PERSIST)</span></span><br><span class="line">    <span class="meta">@JoinTable(name = &quot;t_student_course&quot;,</span></span><br><span class="line"><span class="meta">               joinColumns = @JoinColumn(name = &quot;student_id&quot;),</span></span><br><span class="line"><span class="meta">               inverseJoinColumns = @JoinColumn(name = &quot;course_id&quot;))</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Course&gt; courses = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 被拥有方 (Course) ---</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_course&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Course</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mappedBy = &quot;courses&quot;: </span></span><br><span class="line"><span class="comment">     * 表示关系的维护权在 Student.courses 属性上。</span></span><br><span class="line"><span class="comment">     * 这里的 students 集合是只读的，对它的 add/remove 不会影响数据库，必须操作 Student 端。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ManyToMany(mappedBy = &quot;courses&quot;, fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-4-3-工程陷阱：隐形的中间表"><a href="#4-4-3-工程陷阱：隐形的中间表" class="headerlink" title="4.4.3 工程陷阱：隐形的中间表"></a>4.4.3 工程陷阱：隐形的中间表</h4><p>虽然 <code>@ManyToMany</code> 很方便，但在真实的复杂业务系统中，它有一个致命的<strong>痛点</strong>：</p>
<ul>
<li><strong>场景升级</strong>: 业务方突然提出，学生选课时，需要记录**“考试成绩”<strong>和</strong>“选课时间”**。</li>
<li><strong>问题</strong>: 标准的 <code>@ManyToMany</code> 将中间表隐藏在了注解配置中（<code>@JoinTable</code>）。你<strong>无法</strong>在这个隐形的中间表里添加 <code>score</code> 或 <code>create_time</code> 字段，也无法直接创建一个 Java 对象来表示这行关联数据。</li>
<li><strong>局限</strong>: 它仅适用于“纯粹”的关联，即中间表除了两个 ID 之外没有任何业务含义。</li>
</ul>
<hr>
<h4 id="4-4-4-解决方案：拆分为两个-OneToMany"><a href="#4-4-4-解决方案：拆分为两个-OneToMany" class="headerlink" title="4.4.4 解决方案：拆分为两个 OneToMany"></a>4.4.4 解决方案：拆分为两个 OneToMany</h4><p>为了解决上述扩展性问题，工程上的标准做法是<strong>手动将多对多拆解</strong>。</p>
<ol>
<li><strong>显式创建中间实体</strong>: 创建一个名为 <code>StudentCourse</code> (或 <code>Enrollment</code>) 的实体类。</li>
<li><strong>添加属性</strong>: 在这个实体中除了包含两个对象引用外，还可以随意添加 <code>score</code>、<code>grade</code> 等业务字段。</li>
<li><strong>重构关系</strong>:<ul>
<li><code>Student</code> 对 <code>StudentCourse</code> 是 <strong>OneToMany</strong>。</li>
<li><code>Course</code> 对 <code>StudentCourse</code> 是 <strong>OneToMany</strong>。</li>
</ul>
</li>
</ol>
<p><strong>实体结构示意</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中间实体</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;t_student_course&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentCourse</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>...</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这种设计既规避了 ManyToMany 的黑盒，又能灵活扩展业务字段</span></span><br><span class="line">    <span class="keyword">private</span> Double score; </span><br><span class="line">    <span class="keyword">private</span> LocalDateTime enrollmentDate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;student_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Student student;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;course_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Course course;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student 类变为</span></span><br><span class="line"><span class="comment">// @OneToMany(mappedBy = &quot;student&quot;)</span></span><br><span class="line"><span class="comment">// private Set&lt;StudentCourse&gt; enrollments;</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>:</p>
<ul>
<li><strong>简单关联</strong>（仅需记录A和B有关）：用 <code>@ManyToMany</code>。</li>
<li><strong>业务关联</strong>（需记录A和B何时有关、关系强弱、附加属性）：<strong>强烈建议</strong>拆分为中间实体 + 双向 <code>@OneToMany</code>。</li>
</ul>
<hr>
<h3 id="4-5-级联操作-Cascade-决策指南"><a href="#4-5-级联操作-Cascade-决策指南" class="headerlink" title="4.5 级联操作 (Cascade) 决策指南"></a>4.5 级联操作 (Cascade) 决策指南</h3><table>
<thead>
<tr>
<th align="left">CascadeType</th>
<th align="left">含义</th>
<th align="left">建议</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>PERSIST</strong></td>
<td align="left">保存 A 时自动保存 B</td>
<td align="left"><strong>常用</strong>。如注册用户时自动保存详情。</td>
</tr>
<tr>
<td align="left"><strong>MERGE</strong></td>
<td align="left">更新 A 时自动更新 B</td>
<td align="left"><strong>慎用</strong>。容易意外覆盖 B 的数据。</td>
</tr>
<tr>
<td align="left"><strong>REMOVE</strong></td>
<td align="left">删除 A 时自动删除 B</td>
<td align="left"><strong>极度危险</strong>。通常在数据库层面做逻辑删除，或手动检查删除。</td>
</tr>
<tr>
<td align="left"><strong>ALL</strong></td>
<td align="left">包含以上所有</td>
<td align="left">仅在父子关系极强（如聚合根与值对象）时使用。</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-6-总结与最佳实践"><a href="#4-6-总结与最佳实践" class="headerlink" title="4.6 总结与最佳实践"></a>4.6 总结与最佳实践</h3><h4 id="4-6-1-抓取策略：全局懒加载-Global-Lazy-Loading"><a href="#4-6-1-抓取策略：全局懒加载-Global-Lazy-Loading" class="headerlink" title="4.6.1 抓取策略：全局懒加载 (Global Lazy Loading)"></a>4.6.1 抓取策略：全局懒加载 (Global Lazy Loading)</h4><ul>
<li><strong>铁律</strong>: <strong>所有关联关系（包括 <code>@ManyToOne</code>, <code>@OneToOne</code>）必须显式设置为 <code>fetch = FetchType.LAZY</code></strong>。</li>
<li><strong>原因</strong>:<ul>
<li>默认的 <code>EAGER</code> 策略不可控。在复杂业务中，加载一个 <code>Order</code> 可能会级联查出 <code>User</code>，再查出 <code>User</code> 的 <code>Department</code>，导致 SQL 爆炸。</li>
<li><strong>按需加载</strong>: 只有在明确需要关联数据时，才使用手段去加载。</li>
</ul>
</li>
<li><strong>配合方案</strong>: 既然全开了 LAZY，如何避免 <code>LazyInitializationException</code> 和 <code>N+1</code>？<ul>
<li><strong>简单场景</strong>: 使用 <code>@BatchSize(size = 20)</code> 进行批量抓取（最简单的优化）。</li>
<li><strong>复杂场景</strong>: 使用 JPQL 的 <code>JOIN FETCH</code> 或 Spring Data 的 <code>@EntityGraph</code> 在查询时一次性带出数据。</li>
</ul>
</li>
</ul>
<h4 id="4-6-2-集合类型选择：为什么优先用-Set-而非-List？"><a href="#4-6-2-集合类型选择：为什么优先用-Set-而非-List？" class="headerlink" title="4.6.2 集合类型选择：为什么优先用 Set 而非 List？"></a>4.6.2 集合类型选择：为什么优先用 <code>Set</code> 而非 <code>List</code>？</h4><p>这是 Hibernate 内部机制决定的，非常关键：</p>
<ul>
<li><strong>List (Bag语义)</strong>:<ul>
<li><strong>低效删除</strong>: 如果 <code>User</code> 有一个 <code>List&lt;Order&gt;</code>，当你从 List 中移除一个 Order 时，Hibernate 往往会<strong>删除该用户的所有 Order，然后再把剩下的插回去</strong>（因为它不知道哪个是哪个，List 允许重复）。</li>
<li><strong>笛卡尔积限制</strong>: 如果一个实体同时 <code>EAGER/JOIN FETCH</code> 两个 <code>List</code> 类型的关联属性，Hibernate 会抛出 <code>MultipleBagFetchException</code>，因为它无法处理多重集合产生的笛卡尔积。</li>
</ul>
</li>
<li><strong>Set</strong>:<ul>
<li><strong>高效操作</strong>: <code>Set</code> 保证元素唯一性（基于 <code>equals/hashCode</code>），Hibernate 可以精确定位并删除特定的记录。</li>
<li><strong>允许多重抓取</strong>: Hibernate 允许同时 Fetch 多个 <code>Set</code> 集合（尽管这可能导致巨大的内存消耗，需慎用，但不会报错）。</li>
</ul>
</li>
<li><strong>结论</strong>: <strong>默认使用 <code>Set</code></strong>。如果必须要用 <code>List</code>（例如需要维护插入顺序），请配合 <code>@OrderColumn</code> 使用，或者接受性能损耗。</li>
</ul>
<h4 id="4-6-3-双向关系的维护-Ownership-Consistency"><a href="#4-6-3-双向关系的维护-Ownership-Consistency" class="headerlink" title="4.6.3 双向关系的维护 (Ownership &amp; Consistency)"></a>4.6.3 双向关系的维护 (Ownership &amp; Consistency)</h4><ul>
<li><p><strong>数据库层面</strong>: 只有<strong>拥有方 (Owner Side, 带 <code>@JoinColumn</code>)</strong> 的变化才会触发 SQL 更新外键。修改被拥有方（<code>mappedBy</code>）的集合仅仅是修改了 Java 内存对象。</p>
</li>
<li><p><strong>内存层面</strong>: 必须保证<strong>双边一致性</strong>。</p>
<ul>
<li><strong>错误</strong>: <code>order.setCustomer(user);</code> (user 的 orders 集合里此时还没有这个 order)。</li>
<li><strong>正确</strong>: 使用<strong>辅助方法 (Helper Method)</strong>，在一个原子操作中同时更新两端。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Customer 类中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.orders.add(order);</span><br><span class="line">    order.setCustomer(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-6-4-级联-Cascade-的红线"><a href="#4-6-4-级联-Cascade-的红线" class="headerlink" title="4.6.4 级联 (Cascade) 的红线"></a>4.6.4 级联 (Cascade) 的红线</h4><ul>
<li><strong>慎用 <code>CascadeType.REMOVE</code></strong>: 在微服务或分层架构中，物理删除通常被<strong>逻辑删除</strong>（如 <code>is_deleted = 1</code>）取代。</li>
<li><strong>风险</strong>: 级联删除是递归的。删了一个 <code>Department</code>，可能把关联的 1000 个 <code>Employee</code> 全删了，这在生产环境是灾难。建议在业务逻辑层手动控制删除。</li>
</ul>
<h4 id="4-6-5-永远不要在-toString-equals-hashCode-中引用关联字段"><a href="#4-6-5-永远不要在-toString-equals-hashCode-中引用关联字段" class="headerlink" title="4.6.5 永远不要在 toString() &#x2F; equals() &#x2F; hashCode() 中引用关联字段"></a>4.6.5 永远不要在 <code>toString()</code> &#x2F; <code>equals()</code> &#x2F; <code>hashCode()</code> 中引用关联字段</h4><ul>
<li><strong>死循环风险</strong>: 双向关联中，若 <code>User.toString()</code> 打印 <code>Order</code>，且 <code>Order.toString()</code> 打印 <code>User</code>，会立即导致 <code>StackOverflowError</code>。</li>
<li><strong>性能隐患</strong>: 调用 <code>hashCode()</code> 可能会意外触发 LAZY 加载，发送不必要的 SQL。</li>
<li><strong>建议</strong>: 使用 Lombok 时，务必加上 <code>@ToString.Exclude</code> 和 <code>@EqualsAndHashCode.Exclude</code> 排除掉所有关联属性。</li>
</ul>
<hr>
<h2 id="5-JPQL-Java-Persistence-Query-Language"><a href="#5-JPQL-Java-Persistence-Query-Language" class="headerlink" title="5. JPQL (Java Persistence Query Language)"></a>5. JPQL (Java Persistence Query Language)</h2><h3 id="5-1-什么是-JPQL？"><a href="#5-1-什么是-JPQL？" class="headerlink" title="5.1 什么是 JPQL？"></a>5.1 什么是 JPQL？</h3><p><strong>JPQL</strong> 是 JPA 的灵魂。它不是 SQL 的简单封装，而是一种<strong>基于领域模型 (Domain Model)</strong> 的查询语言。</p>
<ul>
<li><strong>思维转变</strong>:<ul>
<li><strong>SQL</strong>: 操作的是数据库的<strong>表 (table)</strong> 和<strong>列 (column)</strong>，例如：”查 <code>t_user</code> 表，找 <code>age</code> 列大于 18 的行。”</li>
<li><strong>JPQL</strong>: 操作的是 JPA 的<strong>实体 (Entity)</strong> 和<strong>属性 (property)</strong>，例如：”在 <code>User</code> 实体集合中，筛选 <code>age</code> 属性大于 18 的对象。”</li>
</ul>
</li>
<li><strong>多态查询</strong>: 如果 <code>User</code> 有子类 <code>Admin</code> 和 <code>Guest</code>，<code>SELECT u FROM User u</code> 会自动利用 SQL 的 JOIN 或 UNION 策略查出所有子类的实例。这是原生 SQL 难以做到的。</li>
</ul>
<hr>
<h3 id="5-2-核心优势与底层原理"><a href="#5-2-核心优势与底层原理" class="headerlink" title="5.2 核心优势与底层原理"></a>5.2 核心优势与底层原理</h3><h4 id="5-2-1-数据库方言无关性-Dialect-Agnostic"><a href="#5-2-1-数据库方言无关性-Dialect-Agnostic" class="headerlink" title="5.2.1 数据库方言无关性 (Dialect Agnostic)"></a>5.2.1 数据库方言无关性 (Dialect Agnostic)</h4><p>这是 JPQL 最核心的特性。你无需关心底层数据库是 MySQL、Oracle 还是 PostgreSQL，只需编写标准的 JPQL 语句。</p>
<ul>
<li><strong>底层原理</strong>：Hibernate 内部维护了一套完整的 <code>Dialect</code>（方言）体系。JPQL 首先被解析为抽象语法树 (AST)，然后方言解析器根据配置的数据库类型（如 <code>MySQL8Dialect</code>），将 AST 翻译成特定的原生 SQL。<ul>
<li><em>Case</em>: JPQL 中的 <code>SUBSTRING(u.name, 1, 2)</code>。</li>
<li><em>MySQL 环境</em>: 自动翻译为 <code>SUBSTRING(name, 1, 2)</code>。</li>
<li><em>Oracle 环境</em>: 自动翻译为 <code>SUBSTR(name, 1, 2)</code>。</li>
<li><em>其他</em>: 自动处理分页语法（<code>LIMIT</code> vs <code>ROWNUM</code>）等差异。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-2-2-极致的性能优化"><a href="#5-2-2-极致的性能优化" class="headerlink" title="5.2.2 极致的性能优化"></a>5.2.2 极致的性能优化</h4><p>在只读场景或列表展示中，查询整个实体（Entity）往往是一种资源浪费。JPQL 提供了“构造器表达式”来解决这一痛点。</p>
<ul>
<li><strong>痛点</strong>：<code>SELECT u FROM User u</code> 会将所有字段查出，并将对象置于 <strong>Managed（托管）</strong> 状态，伴随着脏检查（Dirty Checking）和一级缓存的内存开销。</li>
<li><strong>解法</strong>：使用 <code>SELECT new com.example.dto.UserSimpleDto(u.id, u.name) FROM User u</code>。</li>
<li><strong>优势</strong>：<ol>
<li><strong>按需获取</strong>：只查询必要的列，减少网络传输和数据库IO。</li>
<li><strong>无托管开销</strong>：返回的是普通 Java POJO，不经过 Persistence Context，没有生命周期管理开销，<strong>查询性能极高</strong>。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="5-2-3-纯粹的面向对象-Object-Oriented"><a href="#5-2-3-纯粹的面向对象-Object-Oriented" class="headerlink" title="5.2.3 纯粹的面向对象 (Object-Oriented)"></a>5.2.3 纯粹的面向对象 (Object-Oriented)</h4><p>JPQL 的操作对象是<strong>实体类（Entity）和属性</strong>，而不是数据库的表（Table）和列（Column）。</p>
<ul>
<li><strong>优势</strong>：<ul>
<li><strong>解耦</strong>：查询逻辑与底层数据库结构解耦。即使数据库表名或字段名发生变更，只要实体类的 <code>@Table</code> 或 <code>@Column</code> 映射同步更新，业务层的 JPQL 代码无需修改。</li>
<li><strong>可读性</strong>：代码语义直接反映领域模型，更符合 Java 开发者的思维习惯。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-2-4-安全性与复杂查询能力"><a href="#5-2-4-安全性与复杂查询能力" class="headerlink" title="5.2.4 安全性与复杂查询能力"></a>5.2.4 安全性与复杂查询能力</h4><ul>
<li><strong>类型安全与防注入</strong>：与拼接原生 SQL 字符串不同，JPQL 强制推荐使用<strong>参数绑定</strong>（Parameter Binding）。这不仅能有效防止 SQL 注入攻击，还能让数据库复用执行计划，提升效率。</li>
<li><strong>全功能支持</strong>：JPQL 并非简单的查询工具，它完整支持 SQL 的高级特性，包括：<ul>
<li>连接查询（<code>JOIN</code>, <code>LEFT JOIN</code>, <code>FETCH JOIN</code>）</li>
<li>聚合函数（<code>COUNT</code>, <code>SUM</code>, <code>AVG</code>）</li>
<li>分组与排序（<code>GROUP BY</code>, <code>ORDER BY</code>）</li>
<li>子查询（Subqueries）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-3-JPQL-基础语法"><a href="#5-3-JPQL-基础语法" class="headerlink" title="5.3 JPQL 基础语法"></a>5.3 JPQL 基础语法</h3><p>JPQL 的语法结构与 SQL 几乎一致，主要包括 <code>SELECT</code>, <code>UPDATE</code>, <code>DELETE</code> 语句。</p>
<h4 id="5-3-1-SELECT-查询"><a href="#5-3-1-SELECT-查询" class="headerlink" title="5.3.1 SELECT 查询"></a>5.3.1 <code>SELECT</code> 查询</h4><p>这是最常用的查询类型。</p>
<p><strong>基本结构</strong>: <code>SELECT ... FROM EntityName [alias] WHERE ... GROUP BY ... HAVING ... ORDER BY ...</code></p>
<p><strong>示例 1: 简单查询</strong></p>
<p>查询所有年龄大于 18 岁的用户。</p>
<ul>
<li><strong>JPQL</strong>: <code>SELECT u FROM User u WHERE u.age &gt; 18</code></li>
<li><strong>注意</strong>:<ul>
<li><code>FROM User u</code>: <code>User</code> 是<strong>实体类的名称</strong>，不是表名。<code>u</code> 是别名。</li>
<li><code>u.age</code>: 引用的是 <code>User</code> 实体的 <code>age</code> <strong>属性</strong>，不是数据库的 <code>age</code> 列。</li>
</ul>
</li>
</ul>
<p><strong>示例 2: 投影查询 (查询部分属性)</strong></p>
<p>只查询用户的姓名和邮箱。</p>
<ul>
<li><strong>JPQL</strong>: <code>SELECT u.name, u.email FROM User u</code></li>
<li><strong>返回类型</strong>: 默认返回 <code>List&lt;Object[]&gt;</code>，每个 <code>Object[]</code> 包含 <code>name</code> 和 <code>email</code>。</li>
<li><strong>构造器表达式 (推荐)</strong>: 为了获得类型安全的 <code>List&lt;UserDTO&gt;</code>，可以使用构造器表达式。<ul>
<li><strong>JPQL</strong>: <code>SELECT new com.example.dto.UserDTO(u.name, u.email) FROM User u</code></li>
<li>这要求 <code>UserDTO</code> 有一个匹配的构造函数 <code>public UserDTO(String name, String email)</code>。</li>
</ul>
</li>
</ul>
<p><strong>示例 3: 参数绑定</strong></p>
<p>使用<strong>命名参数 (<code>:paramName</code>)</strong> 或 <strong>位置参数 (<code>?index</code>)</strong> 来传递查询条件，防止 SQL 注入。<strong>命名参数是首选</strong>，因为它更具可读性。</p>
<ul>
<li><strong>JPQL (命名参数)</strong>: <code>SELECT u FROM User u WHERE u.name = :name AND u.age &gt; :minAge</code></li>
<li><strong>JPQL (位置参数)</strong>: <code>SELECT u FROM User u WHERE u.name = ?1 AND u.age &gt; ?2</code></li>
</ul>
<hr>
<h4 id="5-3-2-UPDATE-和-DELETE-查询"><a href="#5-3-2-UPDATE-和-DELETE-查询" class="headerlink" title="5.3.2 UPDATE 和 DELETE 查询"></a>5.3.2 <code>UPDATE</code> 和 <code>DELETE</code> 查询</h4><p>JPQL 也支持批量更新和删除操作。</p>
<ul>
<li><strong><code>UPDATE</code></strong>: <code>UPDATE User u SET u.age = u.age + 1 WHERE u.status = &#39;inactive&#39;</code></li>
<li><strong><code>DELETE</code></strong>: <code>DELETE FROM User u WHERE u.lastLoginTime &lt; :someDate</code></li>
</ul>
<p><strong>重要注意事项</strong>:</p>
<ul>
<li>批量 <code>UPDATE</code> 和 <code>DELETE</code> 操作会<strong>直接在数据库层面执行</strong>，它们会<strong>绕过持久化上下文 (一级缓存)</strong>。</li>
<li>这意味着，如果持久化上下文中存在已被这些批量操作修改或删除的实体，这些实体<strong>不会</strong>自动更新，可能会导致<strong>数据不一致</strong>。</li>
<li>因此，在执行批量操作后，通常建议<strong>清空持久化上下文</strong> (<code>entityManager.clear()</code>)，以强制后续查询从数据库重新加载最新数据。</li>
</ul>
<hr>
<h3 id="5-4-连接查询-JOIN"><a href="#5-4-连接查询-JOIN" class="headerlink" title="5.4 连接查询 (JOIN)"></a>5.4 连接查询 (JOIN)</h3><p>JPQL 的连接查询是其强大功能的核心，它允许你根据实体之间的关联关系进行导航查询。</p>
<p>假设有 <code>Customer</code> (一) 和 <code>Order</code> (多) 两个实体。</p>
<ul>
<li><strong><code>INNER JOIN</code></strong>: <code>SELECT c FROM Customer c JOIN c.orders o WHERE o.amount &gt; 100</code><ul>
<li>查询所有拥有订单金额大于 100 的客户。</li>
<li><code>c.orders</code> 是 <code>Customer</code> 实体中定义的关联属性。</li>
</ul>
</li>
<li><strong><code>LEFT JOIN</code></strong>: <code>SELECT c, o FROM Customer c LEFT JOIN c.orders o</code><ul>
<li>查询所有客户及其订单，即使客户没有任何订单也会被查询出来。</li>
</ul>
</li>
<li><strong><code>JOIN FETCH</code> (性能优化的关键)</strong>: 这是 JPQL 中一个极其重要的特性，用于解决 <strong>N+1 查询问题</strong>。<ul>
<li><strong>普通 JOIN</strong>: <code>SELECT c FROM Customer c JOIN c.orders</code> 只会查询出 <code>Customer</code>，当你访问 <code>c.getOrders()</code> 时，仍然会为每个 <code>Customer</code> 发起一次新的 SQL 去查询其 <code>Order</code>（如果关联是懒加载）。</li>
<li><strong><code>JOIN FETCH</code></strong>: <code>SELECT c FROM Customer c LEFT JOIN FETCH c.orders</code></li>
<li><code>FETCH</code> 关键字告诉 JPA 提供商，在执行查询时，不仅要加载主实体 (<code>Customer</code>)，还要<strong>立即、一次性地</strong>将其关联的集合 (<code>orders</code>) 也查询出来并填充好。</li>
<li>这会将多次查询合并为一次 <code>LEFT JOIN</code> SQL，极大地提升了性能。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-5-在-Spring-Data-JPA-中使用-JPQL"><a href="#5-5-在-Spring-Data-JPA-中使用-JPQL" class="headerlink" title="5.5 在 Spring Data JPA 中使用 JPQL"></a>5.5 在 Spring Data JPA 中使用 JPQL</h3><p>Spring Data JPA 提供了多种使用 JPQL 的方式，最常用的是通过 <code>@Query</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 JPQL 进行查询，并使用命名参数</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT u FROM User u WHERE u.email = :email&quot;)</span></span><br><span class="line">    Optional&lt;User&gt; <span class="title function_">findByEmailAddress</span><span class="params">(<span class="meta">@Param(&quot;email&quot;)</span> String email)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用构造器表达式返回 DTO</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT new com.example.dto.UserSummary(u.id, u.name) FROM User u WHERE u.age &gt; :minAge&quot;)</span></span><br><span class="line">    List&lt;UserSummary&gt; <span class="title function_">findUserSummariesByAge</span><span class="params">(<span class="meta">@Param(&quot;minAge&quot;)</span> <span class="type">int</span> age)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 JOIN FETCH 解决 N+1 问题</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT DISTINCT c FROM Customer c LEFT JOIN FETCH c.orders&quot;)</span></span><br><span class="line">    List&lt;Customer&gt; <span class="title function_">findAllCustomersWithOrders</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @Modifying 注解来执行更新或删除操作</span></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// 更新/删除操作需要事务</span></span><br><span class="line">    <span class="meta">@Query(&quot;UPDATE User u SET u.status = :newStatus WHERE u.id = :id&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateUserStatus</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id, <span class="meta">@Param(&quot;newStatus&quot;)</span> String newStatus)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>:</p>
<ul>
<li><code>@Query</code>: 将 JPQL 语句直接写在接口方法上。</li>
<li><code>@Param</code>: 用于将方法参数与 JPQL 中的命名参数进行绑定。</li>
<li><code>@Modifying</code>: <strong>必须</strong>用于标记执行 <code>UPDATE</code> 或 <code>DELETE</code> 操作的方法。</li>
<li><code>@Transactional</code>: 修改数据的操作通常需要事务支持。</li>
</ul>
<hr>
<h2 id="6-Spring-Data-JPA"><a href="#6-Spring-Data-JPA" class="headerlink" title="6. Spring Data JPA"></a>6. Spring Data JPA</h2><h3 id="6-1-什么是-Spring-Data-JPA？"><a href="#6-1-什么是-Spring-Data-JPA？" class="headerlink" title="6.1 什么是 Spring Data JPA？"></a>6.1 什么是 Spring Data JPA？</h3><p><strong>Spring Data JPA</strong> 是 Spring Data 项目下的一个核心子模块。它并非一个新的 ORM 框架，也不是 JPA 的替代品，而是<strong>在 JPA 规范之上构建的一个更高层次的抽象层</strong>。</p>
<p><strong>核心目标</strong>：<strong>极大地简化和标准化数据访问层 (DAO&#x2F;Repository) 的开发</strong>。</p>
<p>Spring Data JPA 通过提供强大的 <code>Repository</code> 抽象和一系列约定，使得开发者可以从繁琐的、样板化的数据访问代码中解放出来，甚至在很多情况下，<strong>无需编写任何实现代码</strong>就能完成复杂的数据库操作。它底层的持久化工作仍然委托给 JPA 提供商（默认为 Hibernate）来完成。可以理解为：<code>你的代码 -&gt; Spring Data JPA -&gt; JPA API (Hibernate) -&gt; JDBC -&gt; 数据库</code></p>
<hr>
<h3 id="6-2-核心特性与优势"><a href="#6-2-核心特性与优势" class="headerlink" title="6.2 核心特性与优势"></a>6.2 核心特性与优势</h3><h4 id="6-2-1-强大的-Repository-抽象-JpaRepository"><a href="#6-2-1-强大的-Repository-抽象-JpaRepository" class="headerlink" title="6.2.1 强大的 Repository 抽象 (JpaRepository)"></a>6.2.1 强大的 Repository 抽象 (<code>JpaRepository</code>)</h4><p>这是 Spring Data JPA 的基石。只需要创建一个接口并继承 <code>JpaRepository&lt;T, ID&gt;</code>，就能<strong>立即获得</strong>一整套开箱即用的、功能完善的 CRUD 和分页排序方法。</p>
<ul>
<li><code>save(S entity)</code>: 保存或更新实体。</li>
<li><code>findById(ID id)</code>: 根据主键查询。</li>
<li><code>findAll()</code>: 查询所有。</li>
<li><code>deleteById(ID id)</code>: 根据主键删除。</li>
<li><code>count()</code>: 统计总数。</li>
<li><code>findAll(Sort sort)</code>: 排序查询。</li>
<li><code>findAll(Pageable pageable)</code>: 分页查询。</li>
<li>… 等等</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只需要定义接口，无需任何实现类！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-2-2-方法命名查询-Query-Methods-Derived-Queries"><a href="#6-2-2-方法命名查询-Query-Methods-Derived-Queries" class="headerlink" title="6.2.2 方法命名查询 (Query Methods &#x2F; Derived Queries)"></a>6.2.2 方法命名查询 (Query Methods &#x2F; Derived Queries)</h4><p>这是 Spring Data JPA 最“神奇”的特性。只需<strong>按照一套约定的命名规则来定义接口方法</strong>，Spring Data JPA 就会在运行时自动解析方法名，并为你生成相应的 JPQL 查询。</p>
<ul>
<li><strong>关键字</strong>: <code>FindBy</code>, <code>CountBy</code>, <code>ExistsBy</code>, <code>DeleteBy</code></li>
<li><strong>属性表达式</strong>: <code>And</code>, <code>Or</code>, <code>Between</code>, <code>LessThan</code>, <code>GreaterThan</code>, <code>Like</code>, <code>Containing</code>, <code>IsNull</code>, <code>In</code></li>
<li><strong>排序与限制</strong>: <code>OrderBy...Asc/Desc</code>, <code>Top</code>, <code>First</code></li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// 根据 name 查询</span></span><br><span class="line">    <span class="comment">// JPQL: select u from User u where u.name = ?1</span></span><br><span class="line">    User <span class="title function_">findByName</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 name 和 age 查询</span></span><br><span class="line">    <span class="comment">// JPQL: select u from User u where u.name = ?1 and u.age = ?2</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByNameAndAge</span><span class="params">(String name, <span class="type">int</span> age)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据 age 大于某个值并按 name 降序排序，只取前10条</span></span><br><span class="line">    <span class="comment">// JPQL: select u from User u where u.age &gt; ?1 order by u.name desc limit 10</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findTop10ByAgeGreaterThanOrderByNameDesc</span><span class="params">(<span class="type">int</span> age)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否存在某个 email 的用户</span></span><br><span class="line">    <span class="comment">// JPQL: select case when count(u) &gt; 0 then true else false end from User u where u.email = ?1</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">existsByEmail</span><span class="params">(String email)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-2-3-使用-Query-注解自定义查询"><a href="#6-2-3-使用-Query-注解自定义查询" class="headerlink" title="6.2.3 使用 @Query 注解自定义查询"></a>6.2.3 使用 <code>@Query</code> 注解自定义查询</h4><p>对于方法命名无法表达的复杂查询逻辑（例如多表连接、子查询、DTO 投影等），可以使用 <code>@Query</code> 注解，直接在接口方法上编写 <strong>JPQL</strong> 或 <strong>原生 SQL</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 JPQL</span></span><br><span class="line">    <span class="meta">@Query(&quot;select u from User u where u.name like %:name%&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findUsersByNameLike</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用原生 SQL (nativeQuery = true)</span></span><br><span class="line">    <span class="meta">@Query(value = &quot;SELECT * FROM user WHERE email = ?1&quot;, nativeQuery = true)</span></span><br><span class="line">    User <span class="title function_">findByEmailWithNativeSQL</span><span class="params">(String email)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 @Modifying 执行更新操作</span></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Query(&quot;update User u set u.age = u.age + 1 where u.id = :id&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">incrementAge</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-2-4-动态查询支持-JPA-Criteria-API-QueryDSL"><a href="#6-2-4-动态查询支持-JPA-Criteria-API-QueryDSL" class="headerlink" title="6.2.4 动态查询支持 (JPA Criteria API &amp; QueryDSL)"></a>6.2.4 动态查询支持 (JPA Criteria API &amp; QueryDSL)</h4><p>对于需要根据运行时条件动态构建查询的场景（例如复杂的多条件搜索），Spring Data JPA 提供了两种强大的集成方案：</p>
<ul>
<li><strong>JPA Specification (规范)</strong>: 提供了一套类型安全的 API，允许你通过组合 <code>Predicate</code> 对象来构建动态的 <code>WHERE</code> 子句。</li>
<li><strong>QueryDSL</strong>: 一个更强大、更流畅的第三方类型安全查询库，与 Spring Data JPA 无缝集成。</li>
</ul>
<hr>
<h4 id="6-2-5-简化的分页与排序"><a href="#6-2-5-简化的分页与排序" class="headerlink" title="6.2.5 简化的分页与排序"></a>6.2.5 简化的分页与排序</h4><p>分页和排序被抽象为 <code>Pageable</code> 和 <code>Sort</code> 接口，使用起来极其简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Controller</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;User&gt; <span class="title function_">getUsersByPage</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(defaultValue = &quot;0&quot;)</span> <span class="type">int</span> page,</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(defaultValue = &quot;10&quot;)</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestParam(defaultValue = &quot;id,desc&quot;)</span> String[] sort)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Spring MVC 会自动将请求参数转换为 Pageable 对象</span></span><br><span class="line">    <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> PageRequest.of(page, size, Sort.by(sort));</span><br><span class="line">    <span class="keyword">return</span> userRepository.findAll(pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-3-与-MyBatis-MyBatis-Plus-的对比"><a href="#6-3-与-MyBatis-MyBatis-Plus-的对比" class="headerlink" title="6.3 与 MyBatis&#x2F;MyBatis-Plus 的对比"></a>6.3 与 MyBatis&#x2F;MyBatis-Plus 的对比</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Spring Data JPA (Hibernate)</th>
<th align="left">MyBatis-Plus</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>抽象层次</strong></td>
<td align="left"><strong>高</strong>，完全面向对象，屏蔽 SQL</td>
<td align="left"><strong>中</strong>，半自动，SQL 仍是核心</td>
</tr>
<tr>
<td align="left"><strong>开发效率</strong></td>
<td align="left"><strong>极高</strong>，方法命名和 JpaRepository 极大减少代码</td>
<td align="left"><strong>高</strong>，通用 CRUD 和 Wrapper 也很高效</td>
</tr>
<tr>
<td align="left"><strong>SQL 控制力</strong></td>
<td align="left"><strong>间接</strong>，通过 JPQL 或原生 SQL 控制，不直接</td>
<td align="left"><strong>直接且完全</strong>，可以精细优化每一条 SQL</td>
</tr>
<tr>
<td align="left"><strong>数据库移植性</strong></td>
<td align="left"><strong>非常强</strong>，面向 JPA 规范，更换数据库成本低</td>
<td align="left"><strong>较强</strong>，但复杂 SQL 可能依赖方言</td>
</tr>
<tr>
<td align="left"><strong>学习曲线</strong></td>
<td align="left">较陡峭，需理解实体生命周期、持久化上下文等核心概念</td>
<td align="left">较平缓，对熟悉 SQL 的开发者非常友好</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">简单 CRUD 性能优异，但复杂查询可能因自动生成 SQL 而非最优</td>
<td align="left">开发者可手动编写最优 SQL，性能潜力更高</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">快速开发、标准 CRUD 密集的业务系统、需要数据库无关性的项目</td>
<td align="left">复杂报表、性能要求极致、DBA 深度参与的项目</td>
</tr>
</tbody></table>
<hr>
<h3 id="6-4-总结"><a href="#6-4-总结" class="headerlink" title="6.4 总结"></a>6.4 总结</h3><p>Spring Data JPA 是一个生产力工具，它站在 JPA 这一巨人的肩膀上，通过“<strong>约定优于配置</strong>”的理念，为开发者提供了一套极其优雅和高效的数据访问解决方案。它使得 Repository 层的代码量锐减，让开发者能够更专注于业务逻辑的实现。对于大多数标准的业务系统而言，Spring Data JPA + Hibernate 是一个非常强大且高效的选择。</p>
<hr>
<h2 id="7-适用场景"><a href="#7-适用场景" class="headerlink" title="7. 适用场景"></a>7. 适用场景</h2><p>JPA (Hibernate) 与 MyBatis 是两种截然不同的思想。JPA 追求<strong>开发效率</strong>与<strong>对象模型完整性</strong>，MyBatis 追求<strong>SQL 控制力</strong>与<strong>极致性能调优</strong>。</p>
<ul>
<li><strong>快速原型与 MVP 开发 (Time-to-Market)</strong><ul>
<li><strong>场景</strong>: 初创项目、内部工具、即刻需要上线的业务。</li>
<li><strong>优势</strong>: 配合 Spring Data JPA 几乎零代码实现 CRUD，<code>ddl-auto</code> 自动建表，开发速度极快。</li>
</ul>
</li>
<li><strong>领域驱动设计 (DDD) 实践</strong><ul>
<li><strong>场景</strong>: 业务逻辑极其复杂，核心在于“状态流转”而非“报表统计”的系统。</li>
<li><strong>优势</strong>: 天然支持富领域模型 (Rich Domain Model)，通过实体关联、生命周期和级联操作，完美映射聚合根 (Aggregate Root) 概念。</li>
</ul>
</li>
<li><strong>标准化企业级应用 (OA&#x2F;ERP&#x2F;CRM)</strong><ul>
<li><strong>场景</strong>: 表数量多、CRUD 操作密集、但复杂联表查询相对较少的后台系统。</li>
<li><strong>优势</strong>: 极大减少 SQL 样板代码，代码结构统一，维护成本低。</li>
</ul>
</li>
<li><strong>多数据库支持 (异构数据库)</strong><ul>
<li><strong>场景</strong>: 商业化产品（需部署到客户不同的数据库环境）或云原生应用。</li>
<li><strong>优势</strong>: 利用 Dialect 屏蔽数据库差异，一套 Java 代码适配 MySQL, Oracle, PostgreSQL 等，无缝迁移。</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h1 id="五、ORM-进阶与最佳实践"><a href="#五、ORM-进阶与最佳实践" class="headerlink" title="五、ORM 进阶与最佳实践"></a>五、ORM 进阶与最佳实践</h1><h2 id="1-N-1-查询问题"><a href="#1-N-1-查询问题" class="headerlink" title="1. N+1 查询问题"></a>1. N+1 查询问题</h2><h3 id="1-1-MyBatis-与-MyBatis-Plus-解决方案"><a href="#1-1-MyBatis-与-MyBatis-Plus-解决方案" class="headerlink" title="1.1 MyBatis 与 MyBatis-Plus 解决方案"></a>1.1 MyBatis 与 MyBatis-Plus 解决方案</h3><h4 id="1-1-1-在-MyBatis-中如何产生-N-1-问题"><a href="#1-1-1-在-MyBatis-中如何产生-N-1-问题" class="headerlink" title="1.1.1 在 MyBatis 中如何产生 N+1 问题"></a>1.1.1 在 MyBatis 中如何产生 N+1 问题</h4><p>N+1 问题通常在使用嵌套结果映射 (<code>&lt;association&gt;</code> 或 <code>&lt;collection&gt;</code>) 并通过<strong>分步查询 (Nested Selects)</strong> 时产生。</p>
<p><strong>问题示例 <code>CustomerMapper.xml</code></strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 查询所有客户 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAllCustomers&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;CustomerWithOrdersMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM t_customer</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2. 根据客户ID查询其订单 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findOrdersByCustomerId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.Order&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM t_order WHERE customer_id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  这个 ResultMap 会导致 N+1 问题。</span></span><br><span class="line"><span class="comment">  它首先执行 findAllCustomers (1次查询)，</span></span><br><span class="line"><span class="comment">  然后在映射 orders 集合时，会为每个 customer 对象调用一次 findOrdersByCustomerId (N次查询)。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;CustomerWithOrdersMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.Customer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- collection 标签的 select 属性触发了分步查询 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.example.Order&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">select</span>=<span class="string">&quot;findOrdersByCustomerId&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-1-2-MyBatis-解决方案"><a href="#1-1-2-MyBatis-解决方案" class="headerlink" title="1.1.2 MyBatis 解决方案"></a>1.1.2 MyBatis 解决方案</h4><p>MyBatis 提供了两种核心方案来解决 N+1 问题。</p>
<h5 id="方案一：连接查询-Join-Query"><a href="#方案一：连接查询-Join-Query" class="headerlink" title="方案一：连接查询 (Join Query)"></a>方案一：连接查询 (Join Query)</h5><p><strong>核心思想</strong>：通过在一次 SQL 查询中使用 <code>JOIN</code>，将主实体和关联的子实体数据一次性全部查询出来。</p>
<p><strong>实现方式</strong>：修改 <code>ResultMap</code>，使其能够处理 <code>JOIN</code> 后的扁平化结果集。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAllCustomersWithOrders&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;CustomerWithOrdersJoinMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT </span><br><span class="line">        c.id as customer_id, </span><br><span class="line">        c.name as customer_name,</span><br><span class="line">        o.id as order_id,</span><br><span class="line">        o.order_number</span><br><span class="line">    FROM </span><br><span class="line">        t_customer c</span><br><span class="line">    LEFT JOIN </span><br><span class="line">        t_order o ON c.id = o.customer_id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;CustomerWithOrdersJoinMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.Customer&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 映射 Customer 的主键和属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;customer_name&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 映射关联的 Order 集合 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ofType 指定集合中元素的类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.example.Order&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 映射 Order 的主键和属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;orderNumber&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_number&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MyBatis 会智能地将返回的多行结果（其中客户信息是重复的）聚合成一个 <code>Customer</code> 对象列表，每个 <code>Customer</code> 对象包含其对应的 <code>Order</code> 列表。</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>一次数据库交互</strong>：性能最高，网络开销最小。</li>
<li>逻辑简单直观。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>数据冗余</strong>：如果一个客户有10个订单，那么这个客户的信息会在结果集中重复10次，增加了数据传输量。</li>
<li><strong>复杂分页问题</strong>：当对主实体（如 <code>Customer</code>）进行分页时，由于 <code>JOIN</code> 导致结果集膨胀，直接在 SQL 中使用 <code>LIMIT</code> 会导致分页结果不准确。这通常会导致“内存分页”，即查询出所有数据后再在内存中进行分页，有内存溢出的风险。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="方案二：分步查询-延迟加载-Nested-Selects-Lazy-Loading"><a href="#方案二：分步查询-延迟加载-Nested-Selects-Lazy-Loading" class="headerlink" title="方案二：分步查询 + 延迟加载 (Nested Selects + Lazy Loading)"></a>方案二：分步查询 + 延迟加载 (Nested Selects + Lazy Loading)</h5><p><strong>核心思想</strong>：仍然执行两次查询，但 MyBatis 会<strong>智能地将 N 次子查询合并为一次</strong>。这被称为**“N+1 优化”**。</p>
<p><strong>实现方式</strong>：</p>
<ol>
<li><p><strong>开启延迟加载</strong>：在 <code>mybatis-config.xml</code> 或 Spring Boot 的 <code>application.yml</code> 中开启延迟加载。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yml</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">lazy-loading-enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># aggressive-lazy-loading: false (默认为false，按需加载)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用分步查询的 <code>ResultMap</code></strong> (与问题示例中的 <code>ResultMap</code> 相同)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;CustomerWithOrdersMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.example.Customer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.example.Order&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">select</span>=<span class="string">&quot;findOrdersByCustomerId&quot;</span> <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>工作原理</strong>：</p>
<ol>
<li>MyBatis 首先执行 <code>findAllCustomers</code>，返回 <code>Customer</code> 列表。但由于开启了延迟加载，<code>orders</code> 属性此时是一个代理对象，并未填充数据。</li>
<li>当你<strong>第一次</strong>访问某个 <code>customer.getOrders()</code> 时，MyBatis 不会立即执行查询。</li>
<li>它会<strong>收集</strong>所有已加载的 <code>Customer</code> 列表中的主键 (<code>id</code>)。</li>
<li>然后，它会执行<strong>一次</strong> <code>findOrdersByCustomerId</code> 查询，并使用 <code>IN</code> 子句将所有收集到的 <code>id</code> 传入。<br><code>SELECT * FROM t_order WHERE customer_id IN (1, 2, 3, ...)</code></li>
<li>最后，将查询到的所有 <code>Order</code> 分配给对应的 <code>Customer</code> 对象。</li>
</ol>
<p>这样，总的查询次数从 <strong>1+N</strong> 变成了 <strong>1+1</strong>，极大地提升了性能。</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>SQL 语句清晰</strong>，解耦度高。</li>
<li><strong>完美支持分页</strong>：对主实体分页时，不会有任何问题。</li>
<li><strong>按需加载</strong>：如果从不访问 <code>orders</code> 属性，那么第二次查询永远不会被触发。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>需要执行两次数据库查询。</li>
<li>需要额外配置。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-3-MyBatis-Plus-解决方案"><a href="#1-1-3-MyBatis-Plus-解决方案" class="headerlink" title="1.1.3 MyBatis-Plus 解决方案"></a>1.1.3 MyBatis-Plus 解决方案</h4><p>MyBatis-Plus (MP) 底层就是 MyBatis，因此上述两种解决方案<strong>完全适用</strong>。但由于 MP 鼓励使用 Wrapper 进行单表操作，对于多表关联查询，通常的做法是回归 MyBatis 的本质。</p>
<ol>
<li><p><strong>对于连接查询 (方案一)</strong>:</p>
<ul>
<li>MP 的 <code>BaseMapper</code> 不直接支持多表 <code>JOIN</code> 查询。</li>
<li><strong>标准做法</strong>：在 <code>Mapper</code> 接口中自定义一个方法，然后在对应的 XML 文件中编写 <code>JOIN</code> 查询的 SQL 和 <code>ResultMap</code>，这与原生 MyBatis 的方案一<strong>完全一致</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CustomerMapper.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Customer&gt; &#123;</span><br><span class="line">    <span class="comment">// 自定义方法，并使用 IPage 支持分页</span></span><br><span class="line">    IPage&lt;Customer&gt; <span class="title function_">selectCustomerWithOrders</span><span class="params">(IPage&lt;Customer&gt; page)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>CustomerMapper.xml</code> 中实现上述 <code>selectCustomerWithOrders</code> 方法和对应的 <code>ResultMap</code>。</p>
</li>
<li><p><strong>对于分步查询 (方案二)</strong>:</p>
<ul>
<li>同样，需要在 XML 文件中定义好分步查询的 <code>ResultMap</code>。</li>
<li>然后，你可以定义一个自定义的 Mapper 方法来使用这个 <code>ResultMap</code>，或者通过 Wrapper 查询时<strong>动态指定</strong>要使用的 <code>ResultMap</code> (需要额外封装，不常用)。</li>
<li>最直接的方式还是<strong>自定义 Mapper 方法 + XML</strong>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-2-JPA-Hibernate-解决方案"><a href="#1-2-JPA-Hibernate-解决方案" class="headerlink" title="1.2 JPA&#x2F;Hibernate 解决方案"></a>1.2 JPA&#x2F;Hibernate 解决方案</h3><p>在 JPA&#x2F;Hibernate 中，N+1 问题通常由于<strong>不恰当的抓取策略 (Fetch Strategy)</strong> 和 <strong>不合理的查询方式</strong> 导致。Hibernate 作为其实现，提供了多种高效的解决方案来应对这一问题。</p>
<h4 id="1-2-1-在-JPA-Hibernate-中如何产生-N-1-问题"><a href="#1-2-1-在-JPA-Hibernate-中如何产生-N-1-问题" class="headerlink" title="1.2.1 在 JPA&#x2F;Hibernate 中如何产生 N+1 问题"></a>1.2.1 在 JPA&#x2F;Hibernate 中如何产生 N+1 问题</h4><p>N+1 问题主要发生在加载一个实体及其关联集合时。</p>
<p><strong>典型场景</strong>：查询所有客户 (<code>Customer</code>) 及其各自的订单 (<code>Order</code>) 列表。</p>
<p><strong>实体定义</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = &quot;customer&quot;, fetch = FetchType.LAZY)</span> <span class="comment">// LAZY 是默认且推荐的</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.EAGER)</span> <span class="comment">// EAGER 是 ...ToOne 的默认策略</span></span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 第1次查询: 执行查询获取所有客户</span></span><br><span class="line">List&lt;Customer&gt; customers = customerRepository.findAll(); </span><br><span class="line"><span class="comment">// SQL: SELECT * FROM t_customer;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 循环遍历客户，并访问其订单集合</span></span><br><span class="line"><span class="keyword">for</span> (Customer customer : customers) &#123;</span><br><span class="line">    <span class="comment">// 当首次访问 customer.getOrders() 时，由于是懒加载(LAZY)...</span></span><br><span class="line">    <span class="comment">// Hibernate 会为【每个】customer 发起一次新的查询来获取其订单</span></span><br><span class="line">    <span class="comment">// 这将触发 N 次查询！</span></span><br><span class="line">    Set&lt;Order&gt; orders = customer.getOrders(); </span><br><span class="line">    <span class="comment">// SQL: SELECT * FROM t_order WHERE customer_id = ? (此句会执行 N 次)</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Customer: &quot;</span> + customer.getName() + <span class="string">&quot;, Orders count: &quot;</span> + orders.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：即使关联是 <code>EAGER</code>（饥饿加载），如果查询方式不当（如使用 <code>findAll()</code>），Hibernate 默认也可能采用分步查询的方式，从而同样引发 N+1 问题。</p>
<hr>
<h4 id="1-2-2-JPA-Hibernate-解决方案"><a href="#1-2-2-JPA-Hibernate-解决方案" class="headerlink" title="1.2.2 JPA&#x2F;Hibernate 解决方案"></a>1.2.2 JPA&#x2F;Hibernate 解决方案</h4><p>JPA&#x2F;Hibernate 提供了多种解决方案，核心思想都是通过<strong>一次查询</strong>将所需的主实体和关联实体都加载到持久化上下文中。</p>
<h5 id="方案一：JPQL-JOIN-FETCH-最常用，最推荐"><a href="#方案一：JPQL-JOIN-FETCH-最常用，最推荐" class="headerlink" title="方案一：JPQL JOIN FETCH (最常用，最推荐)"></a><strong>方案一：JPQL <code>JOIN FETCH</code> (最常用，最推荐)</strong></h5><p><strong>核心思想</strong>：在 JPQL 查询语句中使用 <code>JOIN FETCH</code> 关键字，明确告诉 Hibernate，在执行查询时，不仅要获取主实体，还要<strong>立即、一次性地</strong>将其指定的关联实体（或集合）的数据<strong>一并抓取</strong>出来。</p>
<p><strong>实现方式</strong>: 在 <code>Repository</code> 接口中自定义一个使用 <code>JOIN FETCH</code> 的查询方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Customer, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT DISTINCT c FROM Customer c LEFT JOIN FETCH c.orders&quot;)</span></span><br><span class="line">    List&lt;Customer&gt; <span class="title function_">findAllWithOrders</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作原理</strong>:<br>Hibernate 会将上述 JPQL 转换为一条<strong>包含 <code>LEFT JOIN</code> 的 SQL 语句</strong>：<br><code>SELECT ... FROM t_customer c LEFT JOIN t_order o ON c.id = o.customer_id;</code></p>
<p>它会一次性将所有客户及其所有订单都查询出来，并在内存中智能地组装成 <code>Customer</code> 和 <code>Order</code> 对象。整个过程只有<strong>一次数据库交互</strong>。</p>
<ul>
<li><strong><code>DISTINCT</code> 关键字</strong>：由于 <code>LEFT JOIN</code> 会导致主实体（<code>Customer</code>）因其关联的多个子实体（<code>Order</code>）而重复出现，使用 <code>DISTINCT</code> 可以确保返回的 <code>List&lt;Customer&gt;</code> 中不包含重复的 <code>Customer</code> 对象实例。</li>
<li><strong>优点</strong>:<ul>
<li><strong>性能极高</strong>：将 N+1 次查询合并为 1 次。</li>
<li><strong>代码清晰</strong>：查询意图明确地体现在 JPQL 中。</li>
<li><strong>通用性强</strong>：是解决 N+1 问题的标准和首选方案。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>分页问题</strong>：当对包含 <code>JOIN FETCH</code> 的集合关联进行分页时，Hibernate 会发出警告，因为它无法在数据库层面进行准确的分页。它会<strong>将所有数据加载到内存中再进行分页</strong>，这在数据量大时可能导致内存溢出 (OOM)。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="方案二：实体图-EntityGraph"><a href="#方案二：实体图-EntityGraph" class="headerlink" title="方案二：实体图 (@EntityGraph)"></a><strong>方案二：实体图 (<code>@EntityGraph</code>)</strong></h5><p><strong>核心思想</strong>：<code>@EntityGraph</code> 是 JPA 2.1 引入的一个更强大、更灵活的特性。它允许你<strong>动态地、声明式地</strong>定义一个“抓取计划”，指定在执行某个查询时需要<strong>饥饿加载</strong>哪些关联属性，而无需修改 JPQL 语句。</p>
<p><strong>实现方式</strong>:</p>
<ol>
<li>在实体类上使用 <code>@NamedEntityGraph</code> 定义一个可复用的实体图。</li>
<li>在 <code>Repository</code> 方法上使用 <code>@EntityGraph</code> 注解来应用这个图。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Customer.java</span></span><br><span class="line"><span class="meta">@NamedEntityGraph(</span></span><br><span class="line"><span class="meta">    name = &quot;customer-with-orders-graph&quot;,</span></span><br><span class="line"><span class="meta">    attributeNodes = &#123;</span></span><br><span class="line"><span class="meta">        @NamedAttributeNode(&quot;orders&quot;) // 指定要一同抓取的属性名</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CustomerRepository.java</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Customer, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在执行 findAll() 时，应用名为 &quot;customer-with-orders-graph&quot; 的实体图</span></span><br><span class="line">    <span class="meta">@EntityGraph(value = &quot;customer-with-orders-graph&quot;, type = EntityGraphType.FETCH)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    List&lt;Customer&gt; <span class="title function_">findAll</span><span class="params">()</span>; <span class="comment">// 可以覆盖 JpaRepository 的原生方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以直接在注解中定义 ad-hoc 实体图</span></span><br><span class="line">    <span class="meta">@EntityGraph(attributePaths = &#123;&quot;orders&quot;&#125;)</span></span><br><span class="line">    List&lt;Customer&gt; <span class="title function_">getAllCustomersWithTheirOrders</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作原理</strong>: 与 <code>JOIN FETCH</code> 类似，Hibernate 看到 <code>@EntityGraph</code> 注解后，会自动生成 <code>LEFT JOIN</code> SQL 来一次性加载关联数据。</p>
<ul>
<li><strong><code>type</code> 属性</strong>:<ul>
<li><code>EntityGraphType.FETCH</code>: 实体图中指定的属性会被饥饿加载，未指定的则遵循其默认的抓取策略。<strong>这是我们想要的模式</strong>。</li>
<li><code>EntityGraphType.LOAD</code>: 实体图中指定的属性会被饥饿加载，未指定的则会被强制设置为懒加载。</li>
</ul>
</li>
<li><strong>优点</strong>:<ul>
<li><strong>代码解耦</strong>：将抓取策略与 JPQL 查询本身分离，使得查询语句更简洁。</li>
<li><strong>可复用性</strong>：通过 <code>@NamedEntityGraph</code> 定义的图可以在多个查询中复用。</li>
<li><strong>解决了 <code>JOIN FETCH</code> 的分页问题</strong>：当 <code>@EntityGraph</code> 与分页查询（返回 <code>Page&lt;T&gt;</code>）结合使用时，Hibernate 会智能地执行<strong>两次 SQL</strong>：一次是获取主实体 ID 的分页查询，另一次是根据这些 ID 使用 <code>IN</code> 子句加载关联实体。从而避免了内存分页。这是它相对于 <code>JOIN FETCH</code> 的一大优势。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="方案三：批处理抓取-BatchSize"><a href="#方案三：批处理抓取-BatchSize" class="headerlink" title="方案三：批处理抓取 (@BatchSize)"></a><strong>方案三：批处理抓取 (<code>@BatchSize</code>)</strong></h5><p><strong>核心思想</strong>：这是一种对懒加载的优化。它不会将 N+1 次查询合并为 1 次，而是将其合并为 <strong>1 + (N &#x2F; batch_size)</strong> 次。</p>
<p><strong>实现方式</strong>: 在关联集合的注解上添加 <code>@BatchSize</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = &quot;customer&quot;, fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@BatchSize(size = 10)</span> <span class="comment">// 设置批处理大小</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作原理</strong>:</p>
<ol>
<li>执行 <code>findAll()</code> 查询，获取 N 个 <code>Customer</code> (1次查询)。</li>
<li>当第一次访问某个 <code>customer.getOrders()</code> 时，Hibernate 不会只查询这一个客户的订单。</li>
<li>它会一次性地<strong>预加载接下来 <code>size</code> (这里是10) 个</strong> <code>Customer</code> 代理对象的 <code>orders</code> 集合。</li>
<li>它会生成一条带有 <code>IN</code> 子句的 SQL，一次性查询 10 个客户的订单：<br><code>SELECT * FROM t_order WHERE customer_id IN (?, ?, ..., ?)</code> (10个参数)</li>
<li>如果 N 是 35，那么总查询次数将是 1 + (10) + (10) + (10) + (5) &#x3D; 1 + 4 &#x3D; 5 次，而不是 1 + 35 &#x3D; 36 次。</li>
</ol>
<ul>
<li><strong>优点</strong>:<ul>
<li><strong>配置简单</strong>：只需一个注解即可。</li>
<li><strong>懒加载优化</strong>：对懒加载场景的性能提升非常有效，且不会像 <code>JOIN FETCH</code> 那样一次性加载所有数据。</li>
<li><strong>对分页友好</strong>。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li>仍然需要多次数据库交互，不如 <code>JOIN FETCH</code> 和 <code>@EntityGraph</code> 直接。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-缓存机制"><a href="#2-缓存机制" class="headerlink" title="2. 缓存机制"></a>2. 缓存机制</h2><h3 id="2-1-一级缓存"><a href="#2-1-一级缓存" class="headerlink" title="2.1 一级缓存"></a>2.1 一级缓存</h3><h4 id="2-1-1-定义与核心特性"><a href="#2-1-1-定义与核心特性" class="headerlink" title="2.1.1 定义与核心特性"></a>2.1.1 定义与核心特性</h4><p><strong>一级缓存 (First-Level Cache)</strong> 是 ORM 框架中内置的、与<strong>会话 (Session)</strong> 或 <strong>持久化上下文 (Persistence Context)</strong> 绑定的缓存机制。它是一个无法被关闭或配置的<strong>强制性</strong>特性，是 ORM 框架实现其核心功能的基础。</p>
<p><strong>核心特性</strong>:</p>
<ol>
<li><strong>会话级别 (Session-Level)</strong>:<ul>
<li>一级缓存的生命周期与 <code>SqlSession</code> (MyBatis) 或 <code>EntityManager</code>&#x2F;<code>Session</code> (JPA&#x2F;Hibernate) 的生命周期<strong>完全绑定</strong>。</li>
<li>当会话被创建时，一级缓存随之开启。</li>
<li>当会话被关闭 (<code>close()</code>) 时，一级缓存随之被销毁，其中的所有数据都会被清空。<br>.</li>
</ul>
</li>
<li><strong>线程不共享</strong>:<ul>
<li>由于 <code>SqlSession</code> 和 <code>EntityManager</code> 都是<strong>线程不安全</strong>的，因此一级缓存也是<strong>线程隔离</strong>的。</li>
<li>每个线程（通常对应一个业务请求）都有自己独立的会话和一级缓存，不同线程之间的一级缓存互不影响、互不可见。</li>
</ul>
</li>
<li><strong>身份映射 (Identity Map)</strong>:<ul>
<li>这是ORM框架实现<strong>对象一致性</strong>的关键。</li>
<li>在一级缓存内部，通常是一个 <code>Map&lt;Key, Object&gt;</code> 结构，其中 <code>Key</code> 由实体的<strong>类名</strong>和<strong>主键</strong>组合而成，<code>Value</code> 则是从数据库加载的<strong>实体对象实例</strong>。</li>
<li>这个机制保证了在<strong>同一个会话</strong>中，对于<strong>同一个主键</strong>的<strong>同一个实体类</strong>，无论查询多少次，返回的永远是<strong>同一个 Java 对象实例</strong> (<code>objectA == objectB</code> 为 <code>true</code>)。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-1-2-MyBatis-中的一级缓存"><a href="#2-1-2-MyBatis-中的一级缓存" class="headerlink" title="2.1.2 MyBatis 中的一级缓存"></a>2.1.2 MyBatis 中的一级缓存</h4><p>MyBatis 的一级缓存是默认开启的，且由 <code>SqlSession</code> 直接管理。</p>
<p><strong>工作流程</strong>:</p>
<ol>
<li>当一个 <code>SqlSession</code> 开启后，MyBatis 会为其创建一个 <code>Executor</code>（执行器），<code>Executor</code> 内部持有一个 <code>PerpetualCache</code> 实例，这就是一级缓存。</li>
<li>当通过 <code>SqlSession</code> 执行一次<strong>查询</strong>操作时：<br>a. MyBatis 会根据查询语句、参数、分页信息等生成一个唯一的 <code>CacheKey</code>。<br>b. 首先使用这个 <code>CacheKey</code> 在一级缓存中查找结果。<br>c. <strong>如果命中</strong>，则直接从缓存中返回结果，<strong>不再查询数据库</strong>。<br>d. <strong>如果未命中</strong>，则执行数据库查询，获取结果。<br>e. 将查询到的结果存入一级缓存中（以 <code>CacheKey</code> 为键）。<br>f. 将结果返回给调用者。</li>
</ol>
<p><strong>缓存失效的场景</strong>:</p>
<p>MyBatis 的一级缓存设计得非常“智能”，会在可能导致数据不一致的情况下自动失效：</p>
<ol>
<li><strong>执行 CUD 操作</strong>:<ul>
<li>当在同一个 <code>SqlSession</code> 中执行了 <code>insert</code>, <code>update</code>, <code>delete</code> 操作时，MyBatis 会认为数据库中的数据可能已经发生了变化，为了防止脏读，它会<strong>清空 (clear)</strong> 该 <code>SqlSession</code> 的整个一级缓存。</li>
</ul>
</li>
<li><strong>手动清空缓存</strong>:<ul>
<li>可以调用 <code>sqlSession.clearCache()</code> 方法来手动清空一级缓存。</li>
</ul>
</li>
<li><strong>关闭 <code>SqlSession</code></strong>:<ul>
<li><code>sqlSession.close()</code> 会销毁会话，一级缓存自然也随之销毁。</li>
</ul>
</li>
<li><strong>XML 中设置 <code>flushCache=&quot;true&quot;</code></strong>:<ul>
<li>在 <code>&lt;select&gt;</code>, <code>&lt;insert&gt;</code>, <code>&lt;update&gt;</code>, <code>&lt;delete&gt;</code> 标签上设置 <code>flushCache=&quot;true&quot;</code>，会在执行该语句后强制清空一级缓存。默认情况下，<code>select</code> 为 <code>false</code>，CUD 操作为 <code>true</code>。</li>
</ul>
</li>
</ol>
<p><strong>示例代码 (MyBatis)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次查询，会从数据库加载</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;User 1: &quot;</span> + user1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二次查询相同的用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;User 2: &quot;</span> + user2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于一级缓存的存在，第二次查询不会执行 SQL</span></span><br><span class="line">    <span class="comment">// 并且 user1 和 user2 是同一个 Java 对象实例</span></span><br><span class="line">    System.out.println(<span class="string">&quot;user1 == user2 ? &quot;</span> + (user1 == user2)); <span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一次更新操作</span></span><br><span class="line">    user1.setAge(<span class="number">30</span>);</span><br><span class="line">    userMapper.updateUser(user1);</span><br><span class="line">    session.commit(); <span class="comment">// CUD 操作会清空一级缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三次查询</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;User 3: &quot;</span> + user3);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由于缓存已被清空，这次查询会重新从数据库加载</span></span><br><span class="line">    <span class="comment">// 因此 user1 和 user3 是不同的 Java 对象实例</span></span><br><span class="line">    System.out.println(<span class="string">&quot;user1 == user3 ? &quot;</span> + (user1 == user3)); <span class="comment">// 输出 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-3-JPA-Hibernate-中的一级缓存"><a href="#2-1-3-JPA-Hibernate-中的一级缓存" class="headerlink" title="2.1.3 JPA&#x2F;Hibernate 中的一级缓存"></a>2.1.3 JPA&#x2F;Hibernate 中的一级缓存</h4><p>JPA&#x2F;Hibernate 的一级缓存就是其核心概念——<strong>持久化上下文 (Persistence Context)</strong>。</p>
<p><strong>工作流程与 MyBatis 类似但更强大</strong>:</p>
<ol>
<li><strong>缓存命中</strong>: 当调用 <code>entityManager.find(User.class, 1L)</code> 时，Hibernate 会首先在持久化上下文中根据 <code>User</code> 类和主键 <code>1L</code> 查找实体。如果找到，直接返回，不访问数据库。</li>
<li><strong>自动脏检查 (Dirty Checking)</strong>: Hibernate 一级缓存的强大之处在于它不仅仅是简单的读缓存。它会保存实体加载时的<strong>快照 (Snapshot)</strong>。在事务提交时，Hibernate 会将当前托管态实体的状态与快照进行对比，如果发现不一致（即“脏”了），就会<strong>自动生成 <code>UPDATE</code> 语句</strong>并同步到数据库。</li>
<li><strong>事务回写 (Transactional Write-Behind)</strong>: 对实体的 <code>persist</code>, <code>merge</code>, <code>remove</code> 操作并不会立即执行 SQL，而是将这些操作缓存在持久化上下文中。直到事务提交或上下文被 <code>flush</code> 时，Hibernate 才会将这些操作以最优化的顺序（例如，先 <code>INSERT</code>，再 <code>UPDATE</code>）一次性发送到数据库。</li>
</ol>
<p><strong>缓存失效的场景</strong>:</p>
<ol>
<li><strong>关闭 <code>EntityManager</code></strong>: <code>entityManager.close()</code> 会销毁持久化上下文。</li>
<li><strong>事务提交或回滚</strong>: 在 Spring 环境下，一个事务结束后，与之关联的 <code>EntityManager</code> 通常也会被关闭。</li>
<li><strong>手动清除</strong>:<ul>
<li><code>entityManager.clear()</code>: <strong>分离 (detach)</strong> 持久化上下文中<strong>所有</strong>的实体。</li>
<li><code>entityManager.detach(entity)</code>: 分离<strong>指定</strong>的实体。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-1-4-一级缓存的意义"><a href="#2-1-4-一级缓存的意义" class="headerlink" title="2.1.4 一级缓存的意义"></a>2.1.4 一级缓存的意义</h4><ul>
<li><strong>保证会话内的数据一致性</strong>: 通过身份映射机制，确保对同一数据的操作都作用于同一个 Java 对象实例，避免了数据冲突和混乱。</li>
<li><strong>减少数据库交互</strong>: 在同一个事务或请求中，对于重复的读取操作，可以显著减少对数据库的访问次数，提升性能。</li>
<li><strong>ORM 核心功能的基础</strong>: 是实现自动脏检查、事务回写等高级特性的基础。没有一级缓存，Hibernate 的许多“魔法”将不复存在。</li>
</ul>
<hr>
<h3 id="2-2-二级缓存"><a href="#2-2-二级缓存" class="headerlink" title="2.2 二级缓存"></a>2.2 二级缓存</h3><h4 id="2-2-1-定义与核心特性"><a href="#2-2-1-定义与核心特性" class="headerlink" title="2.2.1 定义与核心特性"></a>2.2.1 定义与核心特性</h4><p><strong>二级缓存 (Second-Level Cache)</strong> 是一种<strong>跨会话 (Session) &#x2F; 跨事务</strong>的全局缓存机制。与一级缓存不同，二级缓存是可选的、可配置的，并且需要显式地开启和配置。</p>
<p><strong>核心特性</strong>:</p>
<ol>
<li><strong>应用级别 (Application-Level)</strong>:<ul>
<li>二级缓存的生命周期与<strong>应用程序</strong>或 <code>SessionFactory</code> (MyBatis 的 <code>SqlSessionFactory</code> &#x2F; Hibernate 的 <code>SessionFactory</code>) 的生命周期绑定。</li>
<li>只要应用程序在运行，二级缓存就存在，并且可以被应用程序中<strong>所有</strong>的会话&#x2F;线程共享。</li>
</ul>
</li>
<li><strong>线程共享</strong>:<ul>
<li>二级缓存是<strong>线程安全</strong>的。多个用户、多个请求、多个线程都可以访问和共享同一份缓存数据。</li>
</ul>
</li>
<li><strong>数据共享而非对象共享</strong>:<ul>
<li>这是二级缓存与一级缓存的一个关键区别。为了保证线程安全和避免数据被意外修改，从二级缓存中读取数据时，ORM 框架返回的通常是<strong>原始缓存对象的序列化副本 (Serialized Copy)</strong>，而不是缓存中对象的直接引用。</li>
<li>这意味着，不同会话从二级缓存中获取的同一个主键的实体，会是<strong>不同的 Java 对象实例</strong> (<code>objectA == objectB</code> 为 <code>false</code>)，尽管它们的数据内容是相同的。</li>
</ul>
</li>
<li><strong>可插拔 (Pluggable)</strong>:<ul>
<li>ORM 框架本身通常只提供二级缓存的<strong>接口规范</strong>，而具体的缓存实现则由第三方的缓存框架来提供，例如 <strong>EhCache</strong>, <strong>Redis</strong>, <strong>Caffeine</strong> 等。这使得开发者可以根据项目需求选择最合适的缓存产品。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-2-2-MyBatis-中的二级缓存"><a href="#2-2-2-MyBatis-中的二级缓存" class="headerlink" title="2.2.2 MyBatis 中的二级缓存"></a>2.2.2 MyBatis 中的二级缓存</h4><p>MyBatis 的二级缓存是基于 <strong><code>namespace</code> (即 Mapper 接口)</strong> 的。每个 <code>Mapper.xml</code> 文件可以拥有自己独立的二级缓存实例。</p>
<h5 id="1-开启步骤"><a href="#1-开启步骤" class="headerlink" title="1. 开启步骤:"></a>1. 开启步骤:</h5><ol>
<li><p><strong>全局开启</strong>: 在 <code>mybatis-config.xml</code> 或 <code>application.yml</code> 中全局开启二级缓存。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yml</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">cache-enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Mapper 级别开启</strong>: 在需要开启二级缓存的 <code>Mapper.xml</code> 文件中，添加 <code>&lt;cache/&gt;</code> 标签。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- UserMapper.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启该 namespace 的二级缓存 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- ... select, insert, etc. ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实体类实现 <code>Serializable</code> 接口</strong>: 由于二级缓存可能涉及序列化（例如存入 Redis 或跨 JVM 共享），所有需要被缓存的实体类都必须实现 <code>java.io.Serializable</code> 接口。</p>
</li>
<li><p><strong>语句级别控制</strong>: 在单个 <code>&lt;select&gt;</code> 标签上，可以通过 <code>useCache=&quot;true&quot;</code> (默认) 或 <code>useCache=&quot;false&quot;</code> 来控制该查询是否使用二级缓存。</p>
</li>
</ol>
<h5 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2. 工作流程:"></a>2. 工作流程:</h5><ol>
<li>当一个会话 <code>session1</code> 执行查询时，如果一级缓存未命中，它会查询数据库。</li>
<li>查询结果返回后，不仅会存入 <code>session1</code> 的一级缓存，还会被<strong>提交 (commit)</strong> 到 <code>UserMapper</code> 的二级缓存中。<strong>注意：只有当会话被 <code>close()</code> 或 <code>commit()</code> 时，一级缓存中的数据才会被刷新到二级缓存。</strong></li>
<li>之后，另一个会话 <code>session2</code> 执行<strong>完全相同</strong>的查询（<code>CacheKey</code> 相同）。</li>
<li><code>session2</code> 首先检查自己的一级缓存，未命中。</li>
<li>然后，它会去 <code>UserMapper</code> 的二级缓存中查找。</li>
<li><strong>如果命中</strong>，它会从二级缓存中获取数据（的副本），存入自己的一级缓存，然后返回给调用者。<strong>整个过程 <code>session2</code> 没有访问数据库。</strong></li>
</ol>
<h5 id="3-缓存失效"><a href="#3-缓存失效" class="headerlink" title="3. 缓存失效:"></a>3. 缓存失效:</h5><p>当任何一个会话在 <code>UserMapper</code> 的 <code>namespace</code> 下执行了 <code>insert</code>, <code>update</code>, <code>delete</code> 操作并<strong>提交</strong>后，该 <code>namespace</code> 下的<strong>所有二级缓存数据都会被清空 (flush)</strong>。这种“一刀切”的策略保证了数据的最终一致性，但也可能降低缓存的命中率。</p>
<hr>
<h4 id="2-2-3-JPA-Hibernate-中的二级缓存"><a href="#2-2-3-JPA-Hibernate-中的二级缓存" class="headerlink" title="2.2.3 JPA&#x2F;Hibernate 中的二级缓存"></a>2.2.3 JPA&#x2F;Hibernate 中的二级缓存</h4><p>Hibernate 的二级缓存设计得更为精细和强大，它提供了<strong>实体级别</strong>的缓存，并支持更复杂的缓存策略。</p>
<h5 id="1-开启步骤-1"><a href="#1-开启步骤-1" class="headerlink" title="1. 开启步骤:"></a>1. 开启步骤:</h5><ol>
<li><p><strong>添加依赖</strong>: 在 <code>pom.xml</code> 中添加 Hibernate 对特定缓存产品的集成依赖，例如 <code>hibernate-jcache</code> (用于集成 JCache 标准的缓存，如 EhCache 3, Caffeine) 或 <code>hibernate-ehcache</code> (用于 EhCache 2)。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.orm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-jcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hibernate.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>全局开启</strong>: 在 <code>application.properties</code> &#x2F; <code>yml</code> 中开启二级缓存并指定缓存工厂。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启二级缓存</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.cache.use_second_level_cache</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># (可选) 开启查询缓存，用于缓存 JPQL 查询结果</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.cache.use_query_cache</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 指定 JCache (EhCache 3) 作为缓存提供商</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.cache.region.factory_class</span>=<span class="string">org.hibernate.cache.jcache.JCacheRegionFactory</span></span><br><span class="line"><span class="comment"># 指定 EhCache 的配置文件路径</span></span><br><span class="line"><span class="attr">spring.jpa.properties.javax.persistence.sharedCache.mode</span>=<span class="string">ENABLE_SELECTIVE</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.javax.cache.provider</span>=<span class="string">org.ehcache.jsr107.EhcacheCachingProvider</span></span><br><span class="line"><span class="attr">spring.jpa.properties.hibernate.javax.cache.uri</span>=<span class="string">classpath:ehcache.xml</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实体级别开启</strong>: 在需要缓存的实体类上，使用 <code>@Cacheable</code> 和 <code>@Cache</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Cacheable</span> <span class="comment">// 标记该实体可以被缓存</span></span><br><span class="line"><span class="meta">@org</span>.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE) <span class="comment">// 指定并发访问策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="2-Hibernate-缓存并发策略-CacheConcurrencyStrategy"><a href="#2-Hibernate-缓存并发策略-CacheConcurrencyStrategy" class="headerlink" title="2. Hibernate 缓存并发策略 (CacheConcurrencyStrategy):"></a>2. Hibernate 缓存并发策略 (<code>CacheConcurrencyStrategy</code>):</h5><p>这是 Hibernate 二级缓存的核心配置，决定了如何处理并发访问和保证数据一致性。</p>
<ul>
<li><strong><code>READ_ONLY</code></strong>: 只读缓存。适用于<strong>绝对不会被修改</strong>的数据（如字典表）。性能最高。</li>
<li><strong><code>NONSTRICT_READ_WRITE</code></strong>: 非严格读写。不保证缓存与数据库的强一致性，可能会有短暂的脏读。适用于对数据一致性要求不高的场景。</li>
<li><strong><code>READ_WRITE</code></strong>: 读写缓存。通过类似“版本戳”的机制保证缓存与数据库的<strong>强一致性</strong>（可重复读级别）。这是<strong>最常用</strong>的策略。</li>
<li><strong><code>TRANSACTIONAL</code></strong>: 事务缓存。将缓存的更新操作纳入 JTA 事务管理，提供最高级别的隔离。</li>
</ul>
<h5 id="3-查询缓存-Query-Cache"><a href="#3-查询缓存-Query-Cache" class="headerlink" title="3. 查询缓存 (Query Cache)"></a>3. 查询缓存 (Query Cache)</h5><p>Hibernate 的二级缓存默认只缓存<strong>通过主键 (<code>find</code>&#x2F;<code>get</code>) 加载的实体</strong>。对于 JPQL 或 Criteria 查询返回的<strong>实体列表</strong>，默认是<strong>不缓存</strong>的。</p>
<p>要缓存查询结果，必须：</p>
<ol>
<li><p>全局开启查询缓存 (<code>use_query_cache=true</code>)。</p>
</li>
<li><p>在执行查询时，显式地设置该查询为可缓存的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生 Hibernate API</span></span><br><span class="line">query.setCacheable(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spring Data JPA (通过 @QueryHint)</span></span><br><span class="line"><span class="meta">@QueryHints(&#123;@QueryHint(name = &quot;org.hibernate.cacheable&quot;, value = &quot;true&quot;)&#125;)</span></span><br><span class="line"><span class="meta">@Query(&quot;from User u where u.age &gt; ?1&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">findUsersByAge</span><span class="params">(<span class="type">int</span> age)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>查询缓存缓存的是<strong>查询结果集的主键列表 (ID list)</strong>，而不是实体本身。当执行查询时，Hibernate 会先从查询缓存中找到对应的主键列表，然后再去二级实体缓存中根据这些主-键获取实体数据。</p>
<hr>
<h3 id="2-3-缓存的意义、风险与配置"><a href="#2-3-缓存的意义、风险与配置" class="headerlink" title="2.3 缓存的意义、风险与配置"></a>2.3 缓存的意义、风险与配置</h3><h4 id="2-3-1-缓存的意义-Why-use-cache"><a href="#2-3-1-缓存的意义-Why-use-cache" class="headerlink" title="2.3.1 缓存的意义 (Why use cache?)"></a>2.3.1 缓存的意义 (Why use cache?)</h4><p>在应用中使用一级和二级缓存，主要出于以下几个核心目的：</p>
<ol>
<li><strong>提升性能 (Performance Improvement)</strong><ul>
<li><strong>减少数据库 I&#x2F;O</strong>: 这是最直接的意义。数据库访问通常是应用程序中最慢、资源消耗最大的操作之一，涉及网络延迟、磁盘 I&#x2F;O、SQL 解析与执行等。缓存将频繁读取的数据存储在内存中（内存的访问速度比磁盘快几个数量级），从而极大地减少了对数据库的直接访问。</li>
<li><strong>降低数据库负载</strong>: 当大量并发请求访问相同的数据时，缓存可以直接响应大部分请求，显著降低数据库服务器的压力，使其能够更从容地处理写操作和复杂的查询，从而提高整个系统的吞吐量。</li>
</ul>
</li>
<li><strong>保证数据一致性 (Data Consistency)</strong><ul>
<li>这主要体现在<strong>一级缓存</strong>中。通过其<strong>身份映射 (Identity Map)</strong> 机制，确保在同一个事务或会话中，对同一条数据的所有操作都作用于同一个 Java 对象实例。这避免了在业务逻辑处理过程中因持有不同对象副本而导致的数据状态不一致问题。</li>
</ul>
</li>
<li><strong>ORM 框架功能的基础 (Foundation for ORM Features)</strong><ul>
<li>对于像 Hibernate 这样的全自动 ORM 框架，<strong>一级缓存（持久化上下文）</strong> 是其实现<strong>自动脏检查 (Dirty Checking)</strong> 和 <strong>事务回写 (Transactional Write-Behind)</strong> 等“魔法”功能的基石。没有一级缓存，这些自动化特性将无法实现。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-3-2-缓存的风险与挑战-Risks-and-Challenges"><a href="#2-3-2-缓存的风险与挑战-Risks-and-Challenges" class="headerlink" title="2.3.2 缓存的风险与挑战 (Risks and Challenges)"></a>2.3.2 缓存的风险与挑战 (Risks and Challenges)</h4><p>引入缓存并非银弹，它在带来性能提升的同时，也引入了新的复杂性和风险：</p>
<ol>
<li><strong>数据不一致性 (Data Inconsistency)</strong><ul>
<li><strong>核心挑战</strong>: 缓存的本质是数据的副本。如何保证缓存中的数据与数据库中的主数据保持同步，是缓存系统面临的最大挑战。</li>
<li><strong>产生原因</strong>:<ul>
<li><strong>缓存更新延迟</strong>: 当数据库数据被修改后，如果缓存未能及时更新或失效，就会导致应用程序读到过期的“脏数据”。</li>
<li><strong>多节点问题</strong>: 在分布式系统中，如果多个应用实例各自拥有本地缓存（如 EhCache），当一个节点更新了数据库，其他节点的缓存可能仍然是旧的。</li>
<li><strong>绕过 ORM</strong>: 如果有其他服务或手动执行的 SQL 直接修改了数据库，ORM 框架的缓存机制将对此毫不知情，导致缓存数据过时。</li>
</ul>
</li>
</ul>
</li>
<li><strong>内存消耗 (Memory Consumption)</strong><ul>
<li>缓存是空间换时间的策略。将大量数据加载到内存中会占用宝贵的 JVM 堆空间。如果缓存的数据量过大，或者没有合适的<strong>淘汰策略 (Eviction Policy)</strong>，可能会导致频繁的 Full GC，甚至<strong>内存溢出 (OOM)</strong>。</li>
</ul>
</li>
<li><strong>增加了系统复杂性 (Increased Complexity)</strong><ul>
<li><strong>配置与维护</strong>: 需要仔细配置缓存的容量、过期时间、淘汰策略、并发策略等。</li>
<li><strong>问题排查</strong>: 当出现问题时，排查是源于业务逻辑、数据库还是缓存本身，会变得更加困难。开发者需要理解缓存的工作原理和失效机制。</li>
</ul>
</li>
<li><strong>缓存穿透、击穿和雪崩 (Advanced Cache Problems)</strong><ul>
<li><strong>穿透 (Penetration)</strong>: 查询一个<strong>绝对不存在</strong>的数据。由于缓存中没有，请求会一直穿透到数据库，如果被恶意利用，可能导致数据库崩溃。</li>
<li><strong>击穿 (Breakdown)</strong>: 一个<strong>热点数据</strong>的缓存刚好失效，在此时刻，大量并发请求同时涌入，直接打到数据库上，导致其压力瞬增。</li>
<li><strong>雪崩 (Avalanche)</strong>: 大量缓存数据在<strong>同一时刻</strong>集体失效（例如，设置了相同的过期时间），导致所有请求瞬间全部转向数据库，造成数据库宕机。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-3-3-如何合理配置与使用缓存"><a href="#2-3-3-如何合理配置与使用缓存" class="headerlink" title="2.3.3 如何合理配置与使用缓存"></a>2.3.3 如何合理配置与使用缓存</h4><p>为了最大化缓存的收益并规避其风险，应遵循以下原则：</p>
<ol>
<li><strong>明确缓存适用场景</strong>:<ul>
<li><strong>读多写少</strong>: 缓存最适用于那些<strong>读取频率远高于写入频率</strong>的数据。如果数据频繁变动，维护缓存的成本（不断地使其失效和重新加载）可能会超过其带来的收益。</li>
<li><strong>热点数据</strong>: 优先缓存那些被频繁访问的热点数据。</li>
<li><strong>对一致性要求不高的非核心数据</strong>: 对于一些可以容忍短暂数据不一致的场景（如新闻、商品分类），缓存是绝佳选择。对于金融交易等要求强一致性的核心数据，使用缓存必须极其谨慎。</li>
</ul>
</li>
<li><strong>选择合适的缓存粒度</strong>:<ul>
<li><strong>一级缓存</strong>: 默认开启，无需配置。主要用于保障事务内的数据一致性和性能。</li>
<li><strong>二级缓存</strong>: 按需开启。优先为那些<strong>稳定、不常变化的基础数据</strong>开启二级缓存，例如：<ul>
<li><strong>字典表</strong> (国家、省份、状态码等)</li>
<li><strong>权限配置</strong> (角色、权限资源等)</li>
<li><strong>商品分类</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>精细化配置</strong>:<ul>
<li><strong>设置合理的容量 (<code>max-entries</code>)</strong>: 根据可用内存和数据量估算缓存大小，避免 OOM。</li>
<li><strong>设置淘汰策略 (Eviction Policy)</strong>: 当缓存满时，如何淘汰旧数据。常用策略有：<ul>
<li><code>LRU</code> (Least Recently Used): 淘汰最久未被使用的数据。</li>
<li><code>LFU</code> (Least Frequently Used): 淘汰最不常用的数据。</li>
<li><code>FIFO</code> (First In First Out): 先进先出。</li>
</ul>
</li>
<li><strong>设置过期时间 (<code>TTL/TTI</code>)</strong>:<ul>
<li><code>TTL</code> (Time To Live): 数据存活时间。从放入缓存开始计时，到期自动失效。</li>
<li><code>TTI</code> (Time To Idle): 数据空闲时间。每次访问都会重置计时器，如果数据在指定时间内一直未被访问，则失效。</li>
</ul>
</li>
<li><strong>选择正确的并发策略 (Hibernate)</strong>: 根据数据的更新特性选择 <code>READ_ONLY</code>, <code>READ_WRITE</code> 等策略，在性能和一致性之间找到平衡。</li>
</ul>
</li>
<li><strong>分布式缓存方案</strong>:<ul>
<li>在分布式或微服务架构中，应优先考虑使用<strong>集中式&#x2F;分布式缓存</strong>，如 <strong>Redis</strong>, <strong>Memcached</strong>。</li>
<li>这可以保证所有服务实例共享同一份缓存数据，从根本上解决多节点间的缓存不一致问题。</li>
<li>ORM 框架（如 Hibernate）可以通过相应的集成包（如 <code>hibernate-redis</code>）与这些分布式缓存系统无缝集成。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>: 缓存是一把双刃剑。合理地使用和配置可以极大地提升系统性能和可伸缩性，但错误或盲目地使用则会引入数据不一致等严重问题。在决定使用二级缓存之前，务必进行充分的分析和评估。</p>
<hr>
<h2 id="3-事务管理"><a href="#3-事务管理" class="headerlink" title="3. 事务管理"></a>3. 事务管理</h2><h3 id="3-1-ORM框架与事务如何集成"><a href="#3-1-ORM框架与事务如何集成" class="headerlink" title="3.1 ORM框架与事务如何集成"></a>3.1 ORM框架与事务如何集成</h3><p>事务管理是企业级应用中保证数据一致性的核心机制。ORM 框架作为数据持久化层，其所有写操作（增、删、改）都必须在事务的边界内进行。因此，ORM 框架与事务管理的集成是天作之合，也是框架设计的关键部分。</p>
<h4 id="3-1-1-事务管理的核心职责"><a href="#3-1-1-事务管理的核心职责" class="headerlink" title="3.1.1 事务管理的核心职责"></a>3.1.1 事务管理的核心职责</h4><p>无论何种技术实现，事务管理器都需要负责以下核心职责：</p>
<ol>
<li><strong>开启事务 (Begin)</strong>: 标记一个新事务的开始。</li>
<li><strong>提交事务 (Commit)</strong>: 如果事务中的所有操作都成功执行，则将这些变更永久保存到数据库。</li>
<li><strong>回滚事务 (Rollback)</strong>: 如果事务中任何一个操作失败，或者业务逻辑要求中止，则撤销该事务中已执行的所有操作，使数据库恢复到事务开始前的状态。</li>
</ol>
<hr>
<h4 id="3-1-2-集成方式"><a href="#3-1-2-集成方式" class="headerlink" title="3.1.2 集成方式"></a>3.1.2 集成方式</h4><p>ORM 框架与事务的集成主要有两种方式：<strong>编程式事务</strong>和<strong>声明式事务</strong>。在现代开发中，特别是与 Spring 框架结合使用时，<strong>声明式事务是绝对的主流和最佳实践</strong>。</p>
<h5 id="1-编程式事务-Programmatic-Transaction-Management"><a href="#1-编程式事务-Programmatic-Transaction-Management" class="headerlink" title="1. 编程式事务 (Programmatic Transaction Management)"></a>1. 编程式事务 (Programmatic Transaction Management)</h5><p><strong>定义</strong>: 在业务代码中，通过<strong>手动调用</strong>事务管理 API 来精确控制事务的边界（开始、提交、回滚）。</p>
<p><strong>集成原理</strong>:ORM 框架提供获取和控制事务的底层 API。开发者需要显式地在代码中进行管理。</p>
<p><strong>MyBatis 中的编程式事务</strong>:</p>
<p>MyBatis 的事务管理是建立在 JDBC 事务之上的。<code>SqlSession</code> 默认是<strong>不自动提交</strong>事务的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession(); <span class="comment">// 默认 openSession(false)</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> session.getMapper(UserMapper.class);</span><br><span class="line">    <span class="comment">// ... 执行多个数据库操作</span></span><br><span class="line">    userMapper.updateUser(user1);</span><br><span class="line">    accountMapper.decreaseBalance(account1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有操作成功，手动提交事务</span></span><br><span class="line">    session.commit(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 发生异常，手动回滚事务</span></span><br><span class="line">    session.rollback();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 必须关闭 session</span></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>: 控制粒度最细，可以非常灵活地在代码的任何位置开启或结束事务。</li>
<li><strong>缺点</strong>:<ul>
<li><strong>代码侵入性强</strong>: 事务管理逻辑与业务逻辑紧密耦合在一起，污染了业务代码。</li>
<li><strong>重复性高</strong>: 每个需要事务的方法都必须编写类似的 <code>try-catch-finally</code> 样板代码，容易出错和遗漏。</li>
<li><strong>维护困难</strong>: 随着业务逻辑变复杂，事务边界的管理会变得非常混乱。</li>
</ul>
</li>
</ul>
<p><strong>JPA&#x2F;Hibernate 中的编程式事务</strong>:</p>
<p>JPA 提供了 <code>EntityTransaction</code> API 来管理事务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EntityManager</span> <span class="variable">em</span> <span class="operator">=</span> emf.createEntityManager();</span><br><span class="line"><span class="type">EntityTransaction</span> <span class="variable">transaction</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取并开启事务</span></span><br><span class="line">    transaction = em.getTransaction();</span><br><span class="line">    transaction.begin();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 执行实体操作</span></span><br><span class="line">    em.persist(newUser);</span><br><span class="line">    em.merge(existingAccount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    transaction.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 回滚事务</span></span><br><span class="line">    <span class="keyword">if</span> (transaction != <span class="literal">null</span> &amp;&amp; transaction.isActive()) &#123;</span><br><span class="line">        transaction.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    em.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其优缺点与 MyBatis 编程式事务完全相同。</p>
<hr>
<h5 id="2-声明式事务-Declarative-Transaction-Management-主流方式"><a href="#2-声明式事务-Declarative-Transaction-Management-主流方式" class="headerlink" title="2. 声明式事务 (Declarative Transaction Management) - (主流方式)"></a>2. 声明式事务 (Declarative Transaction Management) - (主流方式)</h5><p><strong>定义</strong>: 通过<strong>注解 (<code>@Transactional</code>)</strong> 或 XML 配置的方式来“声明”一个方法的事务属性，而无需在方法内部编写任何事务管理代码。事务管理的横切逻辑由框架（通常是 Spring AOP）自动织入。</p>
<p><strong>集成原理</strong>:</p>
<p>这是 Spring 框架与 ORM 框架集成的核心。Spring 提供了统一的事务管理抽象 (<code>PlatformTransactionManager</code>)，并为不同的持久化技术提供了具体的实现类。</p>
<ul>
<li>对于 <strong>JDBC&#x2F;MyBatis</strong>，使用 <code>DataSourceTransactionManager</code>。</li>
<li>对于 <strong>JPA&#x2F;Hibernate</strong>，使用 <code>JpaTransactionManager</code>。</li>
</ul>
<p><strong>工作流程 (以 Spring + JPA 为例)</strong>:</p>
<ol>
<li><p><strong>配置 <code>TransactionManager</code></strong>: 在 Spring 配置中，声明一个 <code>JpaTransactionManager</code> Bean，并将其与 <code>EntityManagerFactory</code> 关联起来。Spring Boot 会自动完成这个配置。</p>
</li>
<li><p><strong>开启事务支持</strong>: 使用 <code>@EnableTransactionManagement</code> 注解开启声明式事务功能。Spring Boot 也是自动开启的。</p>
</li>
<li><p><strong>声明事务边界</strong>: 在需要事务管理的方法或类上添加 <code>@Transactional</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransferServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">TransferService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountRepository accountRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// 声明此方法需要事务管理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Long fromId, Long toId, BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 业务逻辑 ...</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">fromAccount</span> <span class="operator">=</span> accountRepository.findById(fromId).orElseThrow();</span><br><span class="line">        <span class="type">Account</span> <span class="variable">toAccount</span> <span class="operator">=</span> accountRepository.findById(toId).orElseThrow();</span><br><span class="line">        </span><br><span class="line">        fromAccount.setBalance(fromAccount.getBalance().subtract(amount));</span><br><span class="line">        toAccount.setBalance(toAccount.getBalance().add(amount));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 无需手动 commit/rollback</span></span><br><span class="line">        <span class="comment">// Spring 会在方法成功执行后自动提交事务</span></span><br><span class="line">        <span class="comment">// 如果方法抛出运行时异常，Spring 会自动回滚事务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>AOP 动态代理</strong>:</p>
<ul>
<li>当 Spring 容器启动时，它会扫描到 <code>@Transactional</code> 注解。</li>
<li>Spring 会为 <code>TransferServiceImpl</code> 创建一个<strong>动态代理对象</strong>。</li>
<li>当外部代码调用 <code>transferService.transfer(...)</code> 时，实际上调用的是这个代理对象的方法。</li>
</ul>
</li>
<li><p><strong>事务拦截器</strong>:</p>
<ul>
<li>代理对象的方法在执行<strong>前</strong>，会触发一个事务拦截器（Transaction Interceptor）。</li>
<li>拦截器会从 <code>JpaTransactionManager</code> 中获取一个事务，并<strong>开启事务</strong>（底层是调用 <code>em.getTransaction().begin()</code>）。</li>
<li>同时，它会将 <code>EntityManager</code> 和事务信息绑定到当前线程的 <code>ThreadLocal</code> 中，以确保后续的数据库操作都在同一个事务和会z话中进行。</li>
</ul>
</li>
<li><p><strong>执行业务逻辑</strong>: 代理对象接着调用<strong>原始 <code>TransferServiceImpl</code> 对象</strong>的 <code>transfer</code> 方法。方法中的所有数据库操作都会使用从 <code>ThreadLocal</code> 中获取的 <code>EntityManager</code>。</p>
</li>
<li><p><strong>提交&#x2F;回滚</strong>:</p>
<ul>
<li>如果 <code>transfer</code> 方法<strong>正常执行完毕</strong>，事务拦截器会在方法返回后<strong>提交事务</strong> (<code>transaction.commit()</code>)。</li>
<li>如果 <code>transfer</code> 方法<strong>抛出运行时异常</strong>（<code>RuntimeException</code> 或 <code>Error</code>），事务拦截器会捕获异常，并<strong>回滚事务</strong> (<code>transaction.rollback()</code>)，然后将异常继续向外抛出。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-1-3-总结"><a href="#3-1-3-总结" class="headerlink" title="3.1.3 总结"></a>3.1.3 总结</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">编程式事务</th>
<th align="left">声明式事务</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>实现方式</strong></td>
<td align="left">手动调用 API</td>
<td align="left">注解 (<code>@Transactional</code>) &#x2F; XML 配置</td>
</tr>
<tr>
<td align="left"><strong>代码侵入性</strong></td>
<td align="left"><strong>高</strong>，业务与事务逻辑耦合</td>
<td align="left"><strong>极低</strong>，业务代码干净</td>
</tr>
<tr>
<td align="left"><strong>维护性</strong></td>
<td align="left"><strong>差</strong>，样板代码多，易出错</td>
<td align="left"><strong>优秀</strong>，逻辑清晰，易于管理</td>
</tr>
<tr>
<td align="left"><strong>框架</strong></td>
<td align="left">ORM 框架原生支持</td>
<td align="left"><strong>Spring AOP</strong></td>
</tr>
<tr>
<td align="left"><strong>推荐度</strong></td>
<td align="left">仅在极少数需要精细控制的场景使用</td>
<td align="left"><strong>99% 的场景下的最佳实践</strong></td>
</tr>
</tbody></table>
<p><strong>结论</strong>: 在现代 Spring 应用中，ORM 框架与事务的集成几乎总是通过 <strong>Spring 的声明式事务管理</strong> 来实现的。这种方式将事务控制的复杂性完全交给了框架，让开发者可以专注于业务逻辑本身，是 AOP 思想的最佳体现之一。</p>
<hr>
<h3 id="3-2-声明式事务的工作原理"><a href="#3-2-声明式事务的工作原理" class="headerlink" title="3.2 声明式事务的工作原理"></a>3.2 声明式事务的工作原理</h3><p>Spring 的声明式事务是其最核心、最强大的功能之一，也是 AOP (Aspect-Oriented Programming, 面向切面编程) 思想的经典应用。理解其工作原理，有助于我们正确地使用 <code>@Transactional</code> 注解并避免常见的“事务失效”问题。</p>
<p>其核心可以概括为：<strong>基于 AOP 的动态代理和事务拦截器</strong>。</p>
<h4 id="3-2-1-核心组件"><a href="#3-2-1-核心组件" class="headerlink" title="3.2.1 核心组件"></a>3.2.1 核心组件</h4><ol>
<li><strong><code>@Transactional</code> 注解</strong>:<ul>
<li>一个元数据标记，用于告诉 Spring 哪些类或方法需要被事务管理。它本身不包含任何逻辑，只是一个“声明”。</li>
</ul>
</li>
<li><strong><code>PlatformTransactionManager</code> (平台事务管理器)</strong>:<ul>
<li>Spring 事务管理的<strong>统一接口</strong>，定义了 <code>getTransaction</code>, <code>commit</code>, <code>rollback</code> 等核心方法。</li>
<li>Spring 为不同的持久化技术提供了具体的实现，例如：<ul>
<li><code>DataSourceTransactionManager</code>: 用于 JDBC, MyBatis。</li>
<li><code>JpaTransactionManager</code>: 用于 JPA&#x2F;Hibernate。</li>
</ul>
</li>
<li>它的职责是实际执行事务的开启、提交和回滚操作。</li>
</ul>
</li>
<li><strong>AOP 代理 (AOP Proxy)</strong>:<ul>
<li>Spring AOP 的核心。当 Spring 容器扫描到一个类被 <code>@Transactional</code> 注解标记时，它<strong>不会</strong>直接将这个类的原始实例（目标对象 Target Object）放入容器。</li>
<li>相反，它会为这个目标对象创建一个<strong>动态代理对象 (Proxy)</strong>，并将这个代理对象作为 Bean 放入容器。</li>
<li>这个代理对象“包裹”了原始对象，并持有对它的引用。</li>
</ul>
</li>
<li><strong>事务拦截器 (Transaction Interceptor)</strong>:<ul>
<li>一个实现了 AOP <code>Advice</code> (通知) 的组件，通常是 <code>TransactionInterceptor</code> 类。</li>
<li>这个拦截器包含了事务管理的<strong>横切逻辑</strong>（即在业务方法执行前后需要做的事务操作）。</li>
<li>Spring 会通过<strong>切点 (Pointcut)</strong> 将这个拦截器与被 <code>@Transactional</code> 注解的方法绑定起来。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-2-2-详细工作流程"><a href="#3-2-2-详细工作流程" class="headerlink" title="3.2.2 详细工作流程"></a>3.2.2 详细工作流程</h4><p>下面以一个典型的服务调用 <code>someService.doBusinessLogic()</code> 为例，分解声明式事务的完整工作流程：</p>
<p><strong>步骤 1: 外部调用</strong></p>
<ul>
<li>当应用程序的其他部分（如 Controller）注入并调用 <code>SomeService</code> 的 <code>doBusinessLogic()</code> 方法时，它实际获取并调用的是 <strong>Spring 创建的 <code>SomeService</code> 的代理对象</strong>，而不是原始的 <code>SomeService</code> 实例。</li>
</ul>
<p><strong>步骤 2: 代理拦截</strong></p>
<ul>
<li>对代理对象的 <code>doBusinessLogic()</code> 方法的调用被 <strong>AOP 代理</strong>所拦截。</li>
</ul>
<p><strong>步骤 3: 事务拦截器介入</strong></p>
<ul>
<li>代理对象在调用原始业务方法<strong>之前</strong>，首先会调用<strong>事务拦截器</strong> (<code>TransactionInterceptor</code>) 的 <code>invoke</code> 方法。</li>
</ul>
<p><strong>步骤 4: 开启事务</strong></p>
<ul>
<li>事务拦截器检查 <code>doBusinessLogic()</code> 方法上的 <code>@Transactional</code> 注解的属性（如隔离级别、传播行为、只读等）。</li>
<li>它向 <code>PlatformTransactionManager</code> (例如 <code>JpaTransactionManager</code>) 请求一个新事务。</li>
<li><code>PlatformTransactionManager</code> 会：<br>a. 从数据源获取一个数据库连接 (<code>Connection</code>)。<br>b. <strong>禁用</strong>该连接的自动提交 (<code>connection.setAutoCommit(false)</code>)。<br>c. (对于 JPA) 创建一个 <code>EntityManager</code>，并开始一个事务 (<code>em.getTransaction().begin()</code>)。<br>d. 将数据库连接&#x2F;<code>EntityManager</code> 等事务资源<strong>绑定到当前线程的 <code>ThreadLocal</code></strong> 中。这是为了确保后续在该线程中的所有数据库操作都使用同一个连接&#x2F;<code>EntityManager</code>，从而处于同一个事务中。</li>
</ul>
<p><strong>步骤 5: 执行业务逻辑</strong></p>
<ul>
<li>事务拦截器调用<strong>原始 <code>SomeService</code> 实例 (Target Object)</strong> 的 <code>doBusinessLogic()</code> 方法。</li>
<li>在该方法内部，所有对 <code>Repository</code> 或 <code>Mapper</code> 的调用，都会从 <code>ThreadLocal</code> 中获取已经被事务管理的数据库连接或 <code>EntityManager</code>，并执行相应的 SQL 操作。这些操作的结果暂时停留在数据库的事务日志或 ORM 的一级缓存中，并未永久提交。</li>
</ul>
<p><strong>步骤 6: 事务提交或回滚</strong></p>
<ul>
<li>业务方法 <code>doBusinessLogic()</code> 执行完毕后，控制权返回给事务拦截器。</li>
<li><strong>情况 A: 方法正常返回 (没有抛出异常)</strong><ul>
<li>拦截器会通知 <code>PlatformTransactionManager</code> <strong>提交 (commit)</strong> 事务。</li>
<li><code>PlatformTransactionManager</code> 会调用 <code>connection.commit()</code> 或 <code>em.getTransaction().commit()</code>，将事务中的所有变更永久写入数据库。</li>
</ul>
</li>
<li><strong>情况 B: 方法抛出异常</strong><ul>
<li>拦截器会捕获这个异常。</li>
<li>默认情况下，如果异常是 <code>RuntimeException</code> 或 <code>Error</code>，拦截器会通知 <code>PlatformTransactionManager</code> <strong>回滚 (rollback)</strong> 事务。</li>
<li><code>PlatformTransactionManager</code> 会调用 <code>connection.rollback()</code> 或 <code>em.getTransaction().rollback()</code>，撤销事务中的所有变更。</li>
<li>如果异常是<strong>受检异常 (Checked Exception)</strong>，默认情况下事务<strong>不会</strong>回滚（可以通过 <code>@Transactional(rollbackFor = ...)</code> 来改变这个行为）。</li>
<li>回滚或提交后，拦截器会将捕获的异常继续向外抛出。</li>
</ul>
</li>
</ul>
<p><strong>步骤 7: 清理资源</strong></p>
<ul>
<li>无论事务是提交还是回滚，事务拦截器最终都会在 <code>finally</code> 块中执行清理操作。</li>
<li><code>PlatformTransactionManager</code> 会<strong>释放</strong>数据库连接（将其归还给连接池），并从 <code>ThreadLocal</code> 中<strong>解绑</strong>所有事务资源。</li>
</ul>
<hr>
<h4 id="3-2-3-为什么-Transactional-会失效？"><a href="#3-2-3-为什么-Transactional-会失效？" class="headerlink" title="3.2.3 为什么 @Transactional 会失效？"></a>3.2.3 为什么 <code>@Transactional</code> 会失效？</h4><p>理解了上述原理，就很容易明白为什么在某些情况下 <code>@Transactional</code> 会失效：</p>
<ul>
<li><strong>方法不是 <code>public</code> 的</strong>: Spring AOP 默认只能代理 <code>public</code> 方法。</li>
<li><strong>方法是 <code>final</code> 或 <code>static</code> 的</strong>: 代理是基于子类继承 (CGLIB) 或接口实现 (JDK Proxy) 的，<code>final</code> 和 <code>static</code> 方法无法被覆盖，因此无法被代理。</li>
<li><strong>同一个类中的方法调用 (this 调用)</strong>:<ul>
<li><code>public void methodA() { this.methodB(); }</code></li>
<li>如果外部调用 <code>methodA()</code> (无 <code>@Transactional</code> 注解)，而 <code>methodB()</code> 有 <code>@Transactional</code> 注解，<code>methodB</code> 的事务<strong>不会生效</strong>。</li>
<li><strong>原因</strong>: 调用 <code>this.methodB()</code> 是直接调用<strong>原始对象 (Target Object)</strong> 的方法，<strong>绕过了代理对象 (Proxy)</strong>。事务拦截器根本没有机会介入。</li>
</ul>
</li>
<li><strong>异常被 <code>catch</code> 掉了</strong>: 如果业务方法内部 <code>try-catch</code> 了一个 <code>RuntimeException</code> 并且没有重新抛出，事务拦截器就感知不到异常的发生，因此会<strong>正常提交事务</strong>。</li>
</ul>
<hr>
<h3 id="3-3-事务的隔离级别与传播行为"><a href="#3-3-事务的隔离级别与传播行为" class="headerlink" title="3.3 事务的隔离级别与传播行为"></a>3.3 事务的隔离级别与传播行为</h3><p>在使用 Spring 的 <code>@Transactional</code> 注解时，除了默认行为，我们还可以通过配置其 <code>isolation</code> (隔离级别) 和 <code>propagation</code> (传播行为) 属性，来精细化地控制事务的行为，以应对复杂的业务场景。</p>
<h4 id="3-3-1-事务的隔离级别-Isolation-Level"><a href="#3-3-1-事务的隔离级别-Isolation-Level" class="headerlink" title="3.3.1 事务的隔离级别 (Isolation Level)"></a>3.3.1 事务的隔离级别 (Isolation Level)</h4><p><strong>定义</strong>: 隔离级别定义了一个事务在执行过程中，其所做的修改对<strong>其他并发事务</strong>的可见程度。它旨在解决多事务并发执行时可能出现的<strong>脏读、不可重复读、幻读</strong>等问题。</p>
<p>隔离级别本质上是在<strong>数据一致性</strong>和<strong>并发性能</strong>之间做出的权衡。级别越高，数据一致性越好，但并发性能通常越差，因为需要更强的锁机制。</p>
<p><strong>并发问题简介</strong>:</p>
<ul>
<li><strong>脏读 (Dirty Read)</strong>: 一个事务读取到了另一个<strong>未提交</strong>事务修改的数据。</li>
<li><strong>不可重复读 (Non-Repeatable Read)</strong>: 在同一个事务内，两次读取<strong>同一行</strong>数据，得到的结果不同。这是因为在两次读取之间，有另一个事务<strong>提交了</strong>对这行数据的修改。</li>
<li><strong>幻读 (Phantom Read)</strong>: 在同一个事务内，两次执行<strong>相同的范围查询</strong>，第二次查询返回了第一次查询中<strong>不存在的新行</strong>。这是因为在两次查询之间，有另一个事务<strong>插入了</strong>符合该范围条件的新数据。</li>
</ul>
<p><strong>Spring 定义的隔离级别 (<code>Isolation</code> 枚举)</strong>:</p>
<table>
<thead>
<tr>
<th align="left">隔离级别 (<code>@Transactional(isolation = ...</code>)</th>
<th align="left">脏读</th>
<th align="left">不可重复读</th>
<th align="left">幻读</th>
<th align="left">数据库默认 (常见)</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>READ_UNCOMMITTED</code></td>
<td align="left"><strong>可能</strong></td>
<td align="left"><strong>可能</strong></td>
<td align="left"><strong>可能</strong></td>
<td align="left">-</td>
<td align="left"><strong>读未提交</strong>。级别最低，允许读取未提交的数据，性能最好但数据一致性最差。几乎不使用。</td>
</tr>
<tr>
<td align="left"><code>READ_COMMITTED</code></td>
<td align="left">不会</td>
<td align="left"><strong>可能</strong></td>
<td align="left"><strong>可能</strong></td>
<td align="left">Oracle, SQL Server</td>
<td align="left"><strong>读已提交</strong>。一个事务只能读取到其他已提交事务的修改。解决了脏读。这是大多数数据库的默认级别。</td>
</tr>
<tr>
<td align="left"><code>REPEATABLE_READ</code></td>
<td align="left">不会</td>
<td align="left">不会</td>
<td align="left"><strong>可能</strong></td>
<td align="left"><strong>MySQL (InnoDB)</strong></td>
<td align="left"><strong>可重复读</strong>。保证在同一事务中多次读取同一行数据的结果是一致的。解决了不可重复读。MySQL InnoDB 通过 Next-Key Lock 机制在一定程度上解决了幻读。</td>
</tr>
<tr>
<td align="left"><code>SERIALIZABLE</code></td>
<td align="left">不会</td>
<td align="left">不会</td>
<td align="left">不会</td>
<td align="left">-</td>
<td align="left"><strong>串行化</strong>。级别最高，强制事务串行执行，完全避免了所有并发问题。性能最差，通常不使用。</td>
</tr>
<tr>
<td align="left"><code>DEFAULT</code></td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left"><strong>使用数据库的默认隔离级别</strong>。这是 <code>@Transactional</code> 的<strong>默认值</strong>。</td>
</tr>
</tbody></table>
<p><strong>如何选择</strong>:</p>
<ul>
<li>绝大多数情况下，使用<strong>数据库的默认隔离级别 (<code>DEFAULT</code>)</strong> 就足够了。</li>
<li>如果业务上对数据一致性有特殊要求（例如，在一次交易中需要多次读取账户余额并确保其不变），可以考虑提升隔离级别到 <code>REPEATABLE_READ</code>。</li>
</ul>
<hr>
<h4 id="3-3-2-事务的传播行为-Propagation-Behavior"><a href="#3-3-2-事务的传播行为-Propagation-Behavior" class="headerlink" title="3.3.2 事务的传播行为 (Propagation Behavior)"></a>3.3.2 事务的传播行为 (Propagation Behavior)</h4><p><strong>定义</strong>: 传播行为定义了当一个<strong>已存在事务</strong>的方法调用另一个需要事务的方法时，事务应该如何<strong>传播或交互</strong>。它解决了<strong>事务嵌套</strong>的问题。</p>
<p>例如，<code>ServiceA.methodA()</code> 调用 <code>ServiceB.methodB()</code>，两者都标记了 <code>@Transactional</code>，<code>methodB</code> 是加入 <code>methodA</code> 的事务，还是开启一个新事务？这就是传播行为要解决的问题。</p>
<p><strong>Spring 定义的传播行为 (<code>Propagation</code> 枚举)</strong>:</p>
<table>
<thead>
<tr>
<th align="left">传播行为 (<code>@Transactional(propagation = ...</code>)</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>REQUIRED</code></strong> (默认值)</td>
<td align="left"><strong>如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</strong> 这是最常用、最符合逻辑的行为。</td>
</tr>
<tr>
<td align="left"><code>SUPPORTS</code></td>
<td align="left">如果当前存在事务，则加入该事务；如果当前没有事务，则以<strong>非事务</strong>的方式执行。</td>
</tr>
<tr>
<td align="left"><code>MANDATORY</code></td>
<td align="left"><strong>强制要求</strong>当前必须存在一个事务，否则抛出异常。</td>
</tr>
<tr>
<td align="left"><strong><code>REQUIRES_NEW</code></strong></td>
<td align="left"><strong>总是创建一个新的事务。</strong> 如果当前已存在事务，则将<strong>当前事务挂起</strong>，执行完新事务后再恢复。两个事务是完全独立的，外部事务的回滚不影响内部事务的提交，反之亦然。</td>
</tr>
<tr>
<td align="left"><code>NOT_SUPPORTED</code></td>
<td align="left">以<strong>非事务</strong>的方式执行操作。如果当前存在事务，则将该事务挂起。</td>
</tr>
<tr>
<td align="left"><code>NEVER</code></td>
<td align="left">以<strong>非事务</strong>的方式执行，并且<strong>强制要求</strong>当前不能存在事务，否则抛出异常。</td>
</tr>
<tr>
<td align="left"><code>NESTED</code></td>
<td align="left"><strong>嵌套事务</strong>。如果当前存在事务，则在当前事务中创建一个保存点 (Savepoint)，形成一个嵌套事务。嵌套事务可以独立于外部事务进行回滚。如果当前没有事务，则行为等同于 <code>REQUIRED</code>。 (注意：并非所有数据库都支持保存点)</td>
</tr>
</tbody></table>
<p><strong>最常用的两种传播行为</strong>:</p>
<h5 id="1-REQUIRED-默认"><a href="#1-REQUIRED-默认" class="headerlink" title="1. REQUIRED (默认)"></a>1. <code>REQUIRED</code> (默认)</h5><ul>
<li><strong>场景</strong>: 绝大多数业务场景。例如，一个“下单”服务 <code>placeOrder()</code> 调用“扣减库存”服务 <code>deductStock()</code> 和“更新订单状态”服务 <code>updateStatus()</code>。这三个操作逻辑上属于<strong>同一个原子工作单元</strong>，必须同成败。<code>deductStock</code> 和 <code>updateStatus</code> 都应该加入到 <code>placeOrder</code> 的事务中。</li>
<li><strong>结果</strong>: 整个调用链在同一个事务中，任何一步失败，所有操作都会一起回滚。</li>
</ul>
<h5 id="2-REQUIRES-NEW"><a href="#2-REQUIRES-NEW" class="headerlink" title="2. REQUIRES_NEW"></a>2. <code>REQUIRES_NEW</code></h5><ul>
<li><p><strong>场景</strong>: 当你希望某个操作的事务独立于外部调用者的事务时。</p>
</li>
<li><p><strong>典型例子</strong>: 记录操作日志。假设有一个业务方法 <code>doBusiness()</code>，无论 <code>doBusiness()</code> 最终是成功提交还是失败回滚，我们都<strong>希望</strong>将本次操作的日志 (<code>logService.record(...)</code>) <strong>成功地保存到数据库</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogService logService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBusiness</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ... 核心业务逻辑，可能会失败 ...</span></span><br><span class="line">            <span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;业务失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论业务成功与否，都尝试记录日志</span></span><br><span class="line">            logService.record(<span class="string">&quot;执行了一次业务操作&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">record</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 将日志信息保存到数据库 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>工作流程</strong>:</p>
<ol>
<li><code>doBusiness</code> 开启事务 <code>TX1</code>。</li>
<li>调用 <code>logService.record</code> 时，<code>REQUIRES_NEW</code> 会使 <code>TX1</code> <strong>挂起</strong>。</li>
<li><code>logService.record</code> 开启一个<strong>全新的、独立的事务 <code>TX2</code></strong>。</li>
<li><code>record</code> 方法执行完毕，<code>TX2</code> <strong>独立提交</strong>，日志成功写入数据库。</li>
<li>控制权返回，<code>TX1</code> <strong>恢复</strong>。</li>
<li><code>doBusiness</code> 方法中抛出异常，<code>TX1</code> <strong>回滚</strong>。</li>
</ol>
</li>
<li><p><strong>最终结果</strong>: 核心业务操作被回滚，但操作日志成功保留。</p>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/09/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/JDBC/" rel="prev" title="JDBC">
                  <i class="fa fa-angle-left"></i> JDBC
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/09/29/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringFramework/" rel="next" title="Spring全家桶-SpringFramework">
                  Spring全家桶-SpringFramework <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
