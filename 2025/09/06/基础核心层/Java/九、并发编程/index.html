<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="九、并发编程并发编程是硬件发展与软件需求共同驱动的技术演进。随着摩尔定律在物理极限（功耗与散热）下失效，多核处理器成为主流，开发者必须编写并发代码才能充分利用硬件性能。同时，I&#x2F;O密集型应用（如网络服务）和用户体验优化（如避免界面卡顿）也推动了并发的广泛应用。 并发能显著提升资源利用率、程序吞吐量和响应性，并使某些多任务问题的建模更自然。然而，它也带来了高昂的复杂度：包括资源竞争（如竞态">
<meta property="og:type" content="article">
<meta property="og:title" content="九、并发编程">
<meta property="og:url" content="http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%B9%9D%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="九、并发编程并发编程是硬件发展与软件需求共同驱动的技术演进。随着摩尔定律在物理极限（功耗与散热）下失效，多核处理器成为主流，开发者必须编写并发代码才能充分利用硬件性能。同时，I&#x2F;O密集型应用（如网络服务）和用户体验优化（如避免界面卡顿）也推动了并发的广泛应用。 并发能显著提升资源利用率、程序吞吐量和响应性，并使某些多任务问题的建模更自然。然而，它也带来了高昂的复杂度：包括资源竞争（如竞态">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-09-06T10:40:00.000Z">
<meta property="article:modified_time" content="2025-10-17T03:08:38.209Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%B9%9D%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%B9%9D%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","path":"2025/09/06/基础核心层/Java/九、并发编程/","title":"九、并发编程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>九、并发编程 | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">九、并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%9F%B3-%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">1. 并发编程的基石 - 线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 线程与进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">1.1.1 进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">1.1.2 线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-%E5%AF%B9%E6%AF%94"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">1.1.3 对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 线程的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-NEW-%E6%96%B0%E5%BB%BA"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">1.2.1 NEW (新建)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-RUNNABLE-%E5%8F%AF%E8%BF%90%E8%A1%8C"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">1.2.2 RUNNABLE (可运行)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-BLOCKED-%E9%98%BB%E5%A1%9E"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">1.2.3 BLOCKED (阻塞)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4-WAITING-%E6%97%A0%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">1.2.4 WAITING (无限期等待)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-5-TIMED-WAITING-%E9%99%90%E6%97%B6%E7%AD%89%E5%BE%85"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">1.2.5 TIMED_WAITING (限时等待)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-6-TERMINATED-%E7%BB%88%E6%AD%A2"><span class="nav-number">1.1.2.6.</span> <span class="nav-text">1.2.6 TERMINATED (终止)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-7-%E6%A0%B8%E5%BF%83%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2%E8%AF%A6%E8%A7%A3%E4%B8%8E%E8%BE%A8%E6%9E%90"><span class="nav-number">1.1.2.7.</span> <span class="nav-text">1.2.7 核心状态切换详解与辨析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%BA%8E%E5%90%AF%E5%8A%A8"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 线程的创建于启动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">1.3.1 继承Thread类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">1.3.2 实现Runnable接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3-%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3-%E9%85%8D%E5%90%88-FutureTask"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">1.3.3 实现Callable接口 (配合 FutureTask)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-4-start-%E4%B8%8E-run-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">1.3.4 start() 与 run() 的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E7%BA%BF%E7%A8%8B%E6%A0%B8%E5%BF%83API"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.4 线程核心API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-%E5%90%AF%E5%8A%A8%E4%B8%8E%E6%89%A7%E8%A1%8C"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">1.4.1 启动与执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-2-%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">1.4.2 控制线程执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-3-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6-%E6%8E%A8%E8%8D%90%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">1.4.3 线程中断机制 (推荐的线程终止方式)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-4-%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E4%BF%A1%E6%81%AF"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">1.4.4 获取线程信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-5-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.1.4.5.</span> <span class="nav-text">1.4.5 守护线程与优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-6-%E5%B7%B2%E5%BA%9F%E5%BC%83%E7%9A%84%E5%8D%B1%E9%99%A9%E6%96%B9%E6%B3%95-%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%EF%BC%81"><span class="nav-number">1.1.4.6.</span> <span class="nav-text">1.4.6 已废弃的危险方法 (不要使用！)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-7-%E6%80%BB%E7%BB%93%E8%A1%A8%E6%A0%BC"><span class="nav-number">1.1.4.7.</span> <span class="nav-text">1.4.7 总结表格</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.5.</span> <span class="nav-text">1.5 守护线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">1.5.1 概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-2-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">1.5.2 守护线程与用户线程的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-3-%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">1.5.3 创建与使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-4-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">1.5.4 注意事项与最佳实践</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%9F%B3"><span class="nav-number">1.2.</span> <span class="nav-text">2. 并发编程的理论基石</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 Java内存模型(JMM)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">2.1.1 概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-JMM%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">2.1.2 JMM的抽象模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-JMM%E5%9B%B4%E7%BB%95%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%89%E4%B8%AA%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">2.1.3 JMM围绕并发处理的三个核心特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%8E%9F%E5%AD%90%E6%80%A7-Atomicity"><span class="nav-number">1.2.1.3.1.</span> <span class="nav-text">1. 原子性 (Atomicity)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%8F%AF%E8%A7%81%E6%80%A7-Visibility"><span class="nav-number">1.2.1.3.2.</span> <span class="nav-text">2. 可见性 (Visibility)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9C%89%E5%BA%8F%E6%80%A7-Ordering"><span class="nav-number">1.2.1.3.3.</span> <span class="nav-text">3. 有序性 (Ordering)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-Happens-Before-%E5%8E%9F%E5%88%99"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">2.1.4 Happens-Before 原则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 关键字与底层实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-synchronized%EF%BC%9A%E9%87%8D%E9%87%8F%E7%BA%A7%E7%9A%84%E5%86%85%E7%BD%AE%E9%94%81"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">2.2.1 synchronized：重量级的内置锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8"><span class="nav-number">1.2.2.1.1.</span> <span class="nav-text">1. 核心作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">1.2.2.1.2.</span> <span class="nav-text">2. 使用方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9AMonitor-%E4%B8%8E%E9%94%81%E5%8D%87%E7%BA%A7"><span class="nav-number">1.2.2.1.3.</span> <span class="nav-text">3. 底层实现原理：Monitor 与锁升级</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-volatile%EF%BC%9A%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">2.2.2 volatile：轻量级的同步机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8-1"><span class="nav-number">1.2.2.2.1.</span> <span class="nav-text">1. 核心作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="nav-number">1.2.2.2.2.</span> <span class="nav-text">2. 底层实现原理：内存屏障</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E5%AF%B9%E6%AF%94"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">2.2.3 对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%94%81%E7%9A%84%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E4%B8%8E-J-U-C"><span class="nav-number">1.3.</span> <span class="nav-text">3. 锁的深入剖析与 J.U.C</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E6%A6%82%E5%BF%B5"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 锁的分类与概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E4%B9%90%E8%A7%82%E9%94%81-Optimistic-Lock-vs-%E6%82%B2%E8%A7%82%E9%94%81-Pessimistic-Lock"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">3.1.1 乐观锁 (Optimistic Lock) vs. 悲观锁 (Pessimistic Lock)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%82%B2%E8%A7%82%E9%94%81-Pessimistic-Lock"><span class="nav-number">1.3.1.1.1.</span> <span class="nav-text">1. 悲观锁 (Pessimistic Lock)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%B9%90%E8%A7%82%E9%94%81-Optimistic-Lock"><span class="nav-number">1.3.1.1.2.</span> <span class="nav-text">2. 乐观锁 (Optimistic Lock)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.3.1.1.3.</span> <span class="nav-text">3. 代码示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.1.1.4.</span> <span class="nav-text">4. 总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E5%85%AC%E5%B9%B3%E9%94%81-Fair-Lock-vs-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81-Unfair-Lock"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">3.1.2 公平锁 (Fair Lock) vs. 非公平锁 (Unfair Lock)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%85%AC%E5%B9%B3%E9%94%81-Fair-Lock"><span class="nav-number">1.3.1.2.1.</span> <span class="nav-text">1. 公平锁 (Fair Lock)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81-Unfair-Lock"><span class="nav-number">1.3.1.2.2.</span> <span class="nav-text">2. 非公平锁 (Unfair Lock)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">1.3.1.2.3.</span> <span class="nav-text">3. 代码示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%80%BB%E7%BB%93-1"><span class="nav-number">1.3.1.2.4.</span> <span class="nav-text">4. 总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-%E7%8B%AC%E5%8D%A0%E9%94%81-Exclusive-Lock-vs-%E5%85%B1%E4%BA%AB%E9%94%81-Shared-Lock"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">3.1.3 独占锁 (Exclusive Lock) vs. 共享锁 (Shared Lock)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%8B%AC%E5%8D%A0%E9%94%81-Exclusive-Lock"><span class="nav-number">1.3.1.3.1.</span> <span class="nav-text">1. 独占锁 (Exclusive Lock)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%85%B1%E4%BA%AB%E9%94%81-Shared-Lock"><span class="nav-number">1.3.1.3.2.</span> <span class="nav-text">2. 共享锁 (Shared Lock)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">1.3.1.3.3.</span> <span class="nav-text">3. 代码示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%80%BB%E7%BB%93-2"><span class="nav-number">1.3.1.3.4.</span> <span class="nav-text">4. 总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-Reentrant-Lock-vs-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-Non-Reentrant-Lock"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">3.1.4 可重入锁 (Reentrant Lock) vs. 不可重入锁 (Non-Reentrant Lock)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-Reentrant-Lock"><span class="nav-number">1.3.1.4.1.</span> <span class="nav-text">1. 可重入锁 (Reentrant Lock)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">1.3.1.4.2.</span> <span class="nav-text">2. 不可重入锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-3"><span class="nav-number">1.3.1.4.3.</span> <span class="nav-text">3. 代码示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%80%BB%E7%BB%93-3"><span class="nav-number">1.3.1.4.4.</span> <span class="nav-text">4. 总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-5-%E8%87%AA%E6%97%8B%E9%94%81-Spin-Lock"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">3.1.5 自旋锁 (Spin Lock)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.3.1.5.1.</span> <span class="nav-text">代码示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-5-%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.1.6.</span> <span class="nav-text">3.1.5 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-JUC-Lock%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 JUC-Lock接口与实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-Lock-%E6%8E%A5%E5%8F%A3%E6%A0%B8%E5%BF%83-API"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">3.2.1 Lock 接口核心 API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-ReentrantLock-%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">3.2.2 ReentrantLock (重入锁)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-ReentrantReadWriteLock-%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">3.2.3 ReentrantReadWriteLock (读写锁)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-StampedLock-Java-8"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">3.2.4 StampedLock (Java 8+)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-JUC-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8E%9F%E5%AD%90%E5%9F%BA%E7%9F%B3%EF%BC%9ACAS-%E4%B8%8E-AQS"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3 JUC - 并发编程的原子基石：CAS 与 AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-CAS-CompareAndSwap-%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">3.3.1 CAS (CompareAndSwap) - 比较并交换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-number">1.3.3.1.1.</span> <span class="nav-text">1. 核心思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Java%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.3.1.2.</span> <span class="nav-text">2. Java中的实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-CAS%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.3.3.1.3.</span> <span class="nav-text">3. CAS的三大问题及解决方案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-AQS-AbstractQueuedSynchronizer-%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">3.3.2 AQS (AbstractQueuedSynchronizer) - 抽象队列同步器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-AQS%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.3.3.2.1.</span> <span class="nav-text">1. AQS核心设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-AQS-%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.3.2.2.</span> <span class="nav-text">2. AQS 的两种模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-AQS-%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.3.2.3.</span> <span class="nav-text">3. AQS 的模板方法模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AReentrantLock-lock-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.3.2.4.</span> <span class="nav-text">4. 源码分析：ReentrantLock.lock() 的工作流程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-JUC-%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">1.4.</span> <span class="nav-text">4. JUC 核心工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 原子操作类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">4.1.1 概述与原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">4.1.2 原子类的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">1.4.1.2.1.</span> <span class="nav-text">1. 基本类型原子类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">1.4.1.2.2.</span> <span class="nav-text">2. 引用类型原子类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">1.4.1.2.3.</span> <span class="nav-text">3. 数组类型原子类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%99%A8"><span class="nav-number">1.4.1.2.4.</span> <span class="nav-text">4. 字段更新器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E7%B4%AF%E5%8A%A0%E5%99%A8-Adder-Accumulator-Java-8"><span class="nav-number">1.4.1.2.5.</span> <span class="nav-text">5. 累加器 (Adder&#x2F;Accumulator - Java 8+)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2 并发容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-ConcurrentHashMap"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">4.2.1 ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E6%BC%94%E8%BF%9B"><span class="nav-number">1.4.2.1.1.</span> <span class="nav-text">1 核心思想演进</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%80%BB%E7%BB%93"><span class="nav-number">1.4.2.1.2.</span> <span class="nav-text">2. 总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-CopyOnWriteArrayList-CopyOnWriteArraySet"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">4.2.2 CopyOnWriteArrayList &#x2F; CopyOnWriteArraySet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-BlockingQueue-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">4.2.3 BlockingQueue - 阻塞队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.2.3.1.</span> <span class="nav-text">1. 核心方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%B8%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">1.4.2.3.2.</span> <span class="nav-text">2. 主要实现类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-4-ConcurrentLinkedQueue"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">4.2.4 ConcurrentLinkedQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-5-ConcurrentSkipListMap-ConcurrentSkipListSet"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">4.2.5 ConcurrentSkipListMap &#x2F; ConcurrentSkipListSet</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.3 线程同步工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-CountDownLatch-%E5%80%92%E8%AE%A1%E6%97%B6%E9%97%A8%E9%97%A9"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">4.3.1 CountDownLatch - 倒计时门闩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-CyclicBarrier-%E5%BE%AA%E7%8E%AF%E5%B1%8F%E9%9A%9C"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">4.3.2 CyclicBarrier - 循环屏障</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-Semaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">4.3.3 Semaphore - 信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-4-Exchanger-%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E5%99%A8"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">4.3.4 Exchanger - 数据交换器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.4.4.</span> <span class="nav-text">4.4 线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">4.4.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BD%93%E7%B3%BB-Executor-%E6%A1%86%E6%9E%B6"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">4.4.2 线程池的核心体系 - Executor 框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-ThreadPoolExecutor-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">4.4.3 ThreadPoolExecutor 的核心参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-4-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">4.4.4 线程池的工作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-5-Executors-%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%B8%8E%E6%BD%9C%E5%9C%A8%E9%A3%8E%E9%99%A9"><span class="nav-number">1.4.4.5.</span> <span class="nav-text">4.4.5 Executors 工具类与潜在风险</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-6-%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.4.4.6.</span> <span class="nav-text">4.4.6 关闭线程池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-ThreadLocal"><span class="nav-number">1.4.5.</span> <span class="nav-text">4.5 ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-1-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">4.5.1. 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-2-%E6%A0%B8%E5%BF%83API"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">4.5.2 核心API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-3-ThreadLocal-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.5.3.</span> <span class="nav-text">4.5.3 ThreadLocal 的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-4-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.5.4.</span> <span class="nav-text">4.5.4 内存泄漏问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-6-InheritableThreadLocal"><span class="nav-number">1.4.5.5.</span> <span class="nav-text">4.5.6 InheritableThreadLocal</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%80%BB%E7%BB%93"><span class="nav-number">1.5.</span> <span class="nav-text">5. 实践与总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E6%AD%BB%E9%94%81"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.1 死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">5.1.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">5.1.2 死锁的四个必要条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">5.1.3 示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E6%AD%BB%E9%94%81"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">5.1.4 如何排查死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-5-%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%E5%92%8C%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">5.1.5 如何预防和避免死锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.2 线程安全的设计方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-%E9%81%BF%E5%85%8D%E5%85%B1%E4%BA%AB-Avoid-Sharing-%E4%BB%8E%E6%A0%B9%E6%BA%90%E4%B8%8A%E6%9D%9C%E7%BB%9D%E9%97%AE%E9%A2%98"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">5.2.1 避免共享 (Avoid Sharing) - 从根源上杜绝问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%88%E5%B0%81%E9%97%AD-Stack-Confinement"><span class="nav-number">1.5.2.1.1.</span> <span class="nav-text">1. 栈封闭 (Stack Confinement)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD-Thread-Confinement"><span class="nav-number">1.5.2.1.2.</span> <span class="nav-text">2. 线程封闭 (Thread Confinement)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-%E4%B8%8D%E5%8F%AF%E5%8F%98-Immutability-%E8%AE%A9%E5%85%B1%E4%BA%AB%E5%8F%98%E5%BE%97%E5%AE%89%E5%85%A8"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">5.2.2 不可变 (Immutability) - 让共享变得安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3-%E5%AE%89%E5%85%A8%E5%85%B1%E4%BA%AB-Safe-Sharing-%E7%B2%BE%E7%BB%86%E5%8C%96%E7%AE%A1%E7%90%86%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">5.2.3 安全共享 (Safe Sharing) - 精细化管理并发访问</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%90%8C%E6%AD%A5-Synchronization"><span class="nav-number">1.5.2.3.1.</span> <span class="nav-text">1. 同步 (Synchronization)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">1.5.2.3.2.</span> <span class="nav-text">2. 使用线程安全的容器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F-Atomic-Variables"><span class="nav-number">1.5.2.3.3.</span> <span class="nav-text">3. 使用原子变量 (Atomic Variables)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-4-%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">5.2.4 原子性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%8F%91%E7%94%9F%E5%8E%9F%E5%AD%90%E6%80%A7%E9%94%99%E8%AF%AF%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">1.5.2.4.1.</span> <span class="nav-text">1. 发生原子性错误的代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8-synchronized-%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%94%99%E8%AF%AF"><span class="nav-number">1.5.2.4.2.</span> <span class="nav-text">2. 使用 synchronized 解决原子性错误</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8-AtomicInteger-%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%94%99%E8%AF%AF"><span class="nav-number">1.5.2.4.3.</span> <span class="nav-text">3. 使用 AtomicInteger 解决原子性错误</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-5-%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">1.5.2.5.</span> <span class="nav-text">5.2.5 可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%8F%91%E7%94%9F%E5%8F%AF%E8%A7%81%E6%80%A7%E9%94%99%E8%AF%AF%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">1.5.2.5.1.</span> <span class="nav-text">1. 发生可见性错误的代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8-volatile-%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E9%94%99%E8%AF%AF"><span class="nav-number">1.5.2.5.2.</span> <span class="nav-text">2. 使用 volatile 解决可见性错误</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-6-%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="nav-number">1.5.2.6.</span> <span class="nav-text">5.2.6 有序性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%8F%91%E7%94%9F%E6%9C%89%E5%BA%8F%E6%80%A7%E9%94%99%E8%AF%AF%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">1.5.2.6.1.</span> <span class="nav-text">1. 发生有序性错误的代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8-volatile-%E8%A7%A3%E5%86%B3%E6%9C%89%E5%BA%8F%E6%80%A7%E9%94%99%E8%AF%AF"><span class="nav-number">1.5.2.6.2.</span> <span class="nav-text">2. 使用 volatile 解决有序性错误</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%B9%9D%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="九、并发编程 | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          九、并发编程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-06 18:40:00" itemprop="dateCreated datePublished" datetime="2025-09-06T18:40:00+08:00">2025-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 11:08:38" itemprop="dateModified" datetime="2025-10-17T11:08:38+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/" itemprop="url" rel="index"><span itemprop="name">基础核心层</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="九、并发编程"><a href="#九、并发编程" class="headerlink" title="九、并发编程"></a>九、并发编程</h1><p>并发编程是硬件发展与软件需求共同驱动的技术演进。随着摩尔定律在物理极限（功耗与散热）下失效，多核处理器成为主流，开发者必须编写并发代码才能充分利用硬件性能。同时，I&#x2F;O密集型应用（如网络服务）和用户体验优化（如避免界面卡顿）也推动了并发的广泛应用。</p>
<p>并发能显著提升资源利用率、程序吞吐量和响应性，并使某些多任务问题的建模更自然。然而，它也带来了高昂的复杂度：包括资源竞争（如竞态条件、死锁）、上下文切换开销，以及难以调试和测试的非确定性行为。</p>
<p>因此，并发虽已成为开发现代高性能、高响应应用的必备能力，但也要求开发者谨慎处理其复杂性，并借助语言和框架提供的高级抽象（如协程、Actor模型等）降低实现难度。</p>
<h2 id="1-并发编程的基石-线程"><a href="#1-并发编程的基石-线程" class="headerlink" title="1. 并发编程的基石 - 线程"></a>1. 并发编程的基石 - 线程</h2><h3 id="1-1-线程与进程"><a href="#1-1-线程与进程" class="headerlink" title="1.1 线程与进程"></a>1.1 线程与进程</h3><h4 id="1-1-1-进程"><a href="#1-1-1-进程" class="headerlink" title="1.1.1 进程"></a>1.1.1 进程</h4><p><strong>进程（Process）是操作系统进行资源分配和调度的基本单位。</strong></p>
<p>可以把一个进程看作是一个正在运行的应用程序的实例。当你双击打开一个程序（例如 Chrome 浏览器、Word 文档），操作系统就会为其创建一个进程。</p>
<p><strong>核心特征：</strong></p>
<ol>
<li><strong>资源容器</strong>：操作系统会为每个进程分配一套独立的资源，这包括：<ul>
<li><strong>独立的内存地址空间</strong>：每个进程都有自己的虚拟内存，一个进程无法直接访问另一个进程的内存。这提供了极好的隔离性和安全性。</li>
<li><strong>文件句柄</strong>：打开的文件、网络连接等。</li>
<li><strong>系统资源</strong>：如CPU时间片、硬件设备等。</li>
</ul>
</li>
<li><strong>独立性</strong>：进程之间是相互独立的。一个进程的崩溃通常不会影响到其他进程的正常运行（除非存在进程间通信的依赖）。</li>
<li><strong>重量级</strong>：创建、销毁和切换进程的开销（Context Switch）很大。因为操作系统需要分配和回收上述所有独立资源，并保存和恢复大量的状态信息。</li>
</ol>
<hr>
<h4 id="1-1-2-线程"><a href="#1-1-2-线程" class="headerlink" title="1.1.2 线程"></a>1.1.2 线程</h4><p><strong>线程（Thread）是CPU调度的基本单位，它被包含在进程之中，是进程中实际执行任务的实体。</strong></p>
<p>一个进程可以包含一个或多个线程。一个进程至少有一个主线程（Main Thread），负责程序的启动和执行。开发者可以在这个主线程的基础上创建更多的子线程来执行并发任务。</p>
<p><strong>核心特征：</strong></p>
<ol>
<li><strong>执行单元</strong>：线程是真正“干活”的单位，它拥有执行程序代码所需的最少资源，包括：<ul>
<li><strong>程序计数器（PC）</strong>：记录下一条要执行的指令地址。</li>
<li><strong>虚拟机栈（Stack）</strong>：存储局部变量、方法参数和调用信息。每个线程都有自己独立的栈。</li>
<li><strong>本地方法栈</strong>：为Native方法服务。</li>
</ul>
</li>
<li><strong>资源共享</strong>：同一进程内的所有线程共享该进程的绝大部分资源，包括：<ul>
<li><strong>堆内存（Heap）</strong>：所有对象实例都存放在这里。</li>
<li><strong>方法区（Method Area）</strong>：存储类信息、静态变量、常量等。</li>
<li><strong>文件句柄、网络连接等</strong>。</li>
</ul>
</li>
<li><strong>轻量级</strong>：与进程相比，线程的创建、销毁和切换开销要小得多。因为它们共享了大部分资源，切换时只需保存和恢复少量线程私有的状态（如程序计数器和栈）。</li>
</ol>
<hr>
<h4 id="1-1-3-对比"><a href="#1-1-3-对比" class="headerlink" title="1.1.3 对比"></a>1.1.3 对比</h4><table>
<thead>
<tr>
<th>对比维度</th>
<th>进程 (Process)</th>
<th>线程 (Thread)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>基本单位</strong></td>
<td>操作系统<strong>资源分配</strong>的基本单位。</td>
<td>CPU<strong>调度</strong>的基本单位，是程序执行的最小单位。</td>
</tr>
<tr>
<td><strong>资源拥有</strong></td>
<td>拥有独立的内存地址空间和系统资源，是资源的“容器”。</td>
<td>自身基本不拥有资源，与同进程的其他线程共享资源。</td>
</tr>
<tr>
<td><strong>开销</strong></td>
<td>创建、销毁、切换的开销<strong>大</strong>，是“重量级”的。</td>
<td>创建、销毁、切换的开销<strong>小</strong>，是“轻量级”的。</td>
</tr>
<tr>
<td><strong>通信方式</strong></td>
<td>进程间通信（IPC）复杂，需要借助管道、消息队列、共享内存等机制。</td>
<td>线程间通信简单，可以直接读写共享变量（如堆内存中的对象）。</td>
</tr>
<tr>
<td><strong>隔离性&#x2F;健壮性</strong></td>
<td>进程间相互隔离，一个进程崩溃不影响其他进程。</td>
<td>一个线程的崩溃（如未捕获的异常）会导致整个进程退出。</td>
</tr>
<tr>
<td><strong>地址空间</strong></td>
<td>每个进程都有独立的地址空间。</td>
<td>同一进程的所有线程共享同一地址空间。</td>
</tr>
<tr>
<td><strong>关系</strong></td>
<td>进程是线程的容器，一个进程至少包含一个线程。</td>
<td>线程是进程的一部分，是进程中执行任务的路径。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-2-线程的生命周期"><a href="#1-2-线程的生命周期" class="headerlink" title="1.2 线程的生命周期"></a>1.2 线程的生命周期</h3><pre><code class="highlight mermaid">graph TD
    %% 1. 定义所有节点及其形状
    New(&quot;新建状态&quot;)
    Runnable&#123;&quot;可运行状态&quot;&#125;
    Running[&quot;运行中&quot;]
    Blocked(&quot;阻塞状态&quot;)
    Waiting(&quot;等待状态&quot;)
    TimedWaiting(&quot;计时等待状态&quot;)
    Terminated(&quot;终止状态&quot;)

    %% 2. 定义状态转换的箭头和标签
    New -- &quot;调用start方法&quot; --&gt; Runnable
    Runnable -- &quot;等待CPU调度&quot; --&gt; Running
    Running -- &quot;yield或时间片用完&quot; --&gt; Runnable
    
    Runnable -- &quot;等待同步锁&quot; --&gt; Blocked
    Blocked -- &quot;获取到同步锁&quot; --&gt; Runnable
    
    Running -- &quot;调用wait/join方法&quot; --&gt; Waiting
    Waiting -- &quot;notify/notifyAll&lt;br/&gt;或join的线程终止&quot; --&gt; Runnable
    
    Running -- &quot;调用sleep/wait&lt;br/&gt;带有超时参数的方法&quot; --&gt; TimedWaiting
    TimedWaiting -- &quot;超时时间到&lt;br/&gt;或被notify/notifyAll&quot; --&gt; Runnable
    
    Running -- &quot;执行完成或异常退出&quot; --&gt; Terminated

    %% 3. 定义并应用样式以匹配原图颜色
    classDef newStyle fill:#e0f2fe,stroke:#3b82f6,stroke-width:2px,color:black
    classDef runnableStyle fill:#dcfce7,stroke:#22c55e,stroke-width:2px,color:black
    classDef runningStyle fill:#bbf7d0,stroke:#16a34a,stroke-width:2px,color:black
    classDef blockedStyle fill:#fef3c7,stroke:#f59e0b,stroke-width:2px,color:black
    classDef waitingStyle fill:#ffedd5,stroke:#f97316,stroke-width:2px,color:black
    classDef timedWaitingStyle fill:#fef9c3,stroke:#eab308,stroke-width:2px,color:black
    classDef terminatedStyle fill:#fee2e2,stroke:#ef4444,stroke-width:2px,color:black

    class New newStyle
    class Runnable runnableStyle
    class Running runningStyle
    class Blocked blockedStyle
    class Waiting waitingStyle
    class TimedWaiting timedWaitingStyle
    class Terminated terminatedStyle</code></pre>

<h4 id="1-2-1-NEW-新建"><a href="#1-2-1-NEW-新建" class="headerlink" title="1.2.1 NEW (新建)"></a>1.2.1 <code>NEW</code> (新建)</h4><ul>
<li><p><strong>定义</strong>：当一个<code>Thread</code>对象被创建，但<code>start()</code>方法还<strong>没有被调用</strong>时，该线程就处于<code>NEW</code>状态。</p>
</li>
<li><p><strong>特征</strong>：这时的线程仅仅是一个普通的Java对象，操作系统内核中还没有为其创建对应的线程实体。它只占用了JVM中的一些内存，没有消耗任何CPU资源。</p>
</li>
<li><p><strong>状态切换</strong>：</p>
<ul>
<li><code>NEW</code> -&gt; <code>RUNNABLE</code>: 当线程对象的<code>start()</code>方法被调用时。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ... some task</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 此时, thread.getState() 的结果是 NEW</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-2-2-RUNNABLE-可运行"><a href="#1-2-2-RUNNABLE-可运行" class="headerlink" title="1.2.2 RUNNABLE (可运行)"></a>1.2.2 <code>RUNNABLE</code> (可运行)</h4><ul>
<li><strong>定义</strong>：这是一个复合状态，它包含了操作系统线程状态中的 <strong>Ready（就绪）</strong> 和 <strong>Running（运行中）</strong>。<ul>
<li><strong>就绪 (Ready)</strong>：线程已经准备好运行，获取了除CPU时间片之外的所有资源，正在等待操作系统的线程调度器分配CPU时间。</li>
<li><strong>运行中 (Running)</strong>：线程已经获得了CPU时间片，正在执行<code>run()</code>方法中的代码。</li>
</ul>
</li>
<li><strong>特征</strong>：处于<code>RUNNABLE</code>状态的线程可能正在运行，也可能在等待CPU。Java虚拟机（JVM）层面不区分这两种情况，统一视为<code>RUNNABLE</code>。</li>
<li><strong>状态切换</strong>：<ul>
<li><code>NEW</code> -&gt; <code>RUNNABLE</code>: 调用<code>start()</code>方法。</li>
<li><code>RUNNABLE</code> -&gt; <code>BLOCKED</code>: 线程试图进入一个<code>synchronized</code>同步块，但该锁被其他线程持有。</li>
<li><code>RUNNABLE</code> -&gt; <code>WAITING</code>: 线程调用了<code>Object.wait()</code>, <code>Thread.join()</code>, 或 <code>LockSupport.park()</code>。</li>
<li><code>RUNNABLE</code> -&gt; <code>TIMED_WAITING</code>: 线程调用了<code>Thread.sleep(long)</code>, <code>Object.wait(long)</code>, <code>Thread.join(long)</code>, <code>LockSupport.parkNanos()</code> 或 <code>LockSupport.parkUntil()</code>。</li>
<li><code>RUNNABLE</code> -&gt; <code>TERMINATED</code>: 线程的<code>run()</code>方法执行完毕，或者因未捕获的异常而退出。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-3-BLOCKED-阻塞"><a href="#1-2-3-BLOCKED-阻塞" class="headerlink" title="1.2.3 BLOCKED (阻塞)"></a>1.2.3 <code>BLOCKED</code> (阻塞)</h4><ul>
<li><p><strong>定义</strong>：线程正在等待获取一个<strong>监视器锁 (Monitor Lock)</strong>。这<strong>专指</strong>线程在进入<code>synchronized</code>修饰的方法或代码块时，因为锁被其他线程占用而导致的等待状态。</p>
</li>
<li><p><strong>特征</strong>：处于<code>BLOCKED</code>状态的线程会暂停执行，直到它获得了它所等待的锁。</p>
</li>
<li><p><strong>状态切换</strong>：</p>
<ul>
<li><code>RUNNABLE</code> -&gt; <code>BLOCKED</code>: 线程请求<code>synchronized</code>锁失败。</li>
<li><code>BLOCKED</code> -&gt; <code>RUNNABLE</code>: 持有锁的线程释放了该锁，并且线程调度器选择了这个线程来获取锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// 线程A</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="comment">// 线程A持有锁，长时间运行</span></span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 线程B在这里会进入 BLOCKED 状态，直到线程A释放锁</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-2-4-WAITING-无限期等待"><a href="#1-2-4-WAITING-无限期等待" class="headerlink" title="1.2.4 WAITING (无限期等待)"></a>1.2.4 <code>WAITING</code> (无限期等待)</h4><ul>
<li><strong>定义</strong>：线程正在无限期地等待另一个线程执行一个特定的动作。线程不会自己醒来，必须被其他线程显式地唤醒。</li>
<li><strong>特征</strong>：处于此状态的线程不消耗CPU时间，并会释放它之前可能持有的锁（特指因调用<code>Object.wait()</code>而进入此状态的情况）。</li>
<li><strong>导致此状态的操作</strong>：<ol>
<li>调用<code>Object.wait()</code> (无参)</li>
<li>调用<code>Thread.join()</code> (无参)</li>
<li>调用<code>LockSupport.park()</code></li>
</ol>
</li>
<li><strong>状态切换</strong>：<ul>
<li><code>RUNNABLE</code> -&gt; <code>WAITING</code>: 调用上述任一方法。</li>
<li><code>WAITING</code> -&gt; <code>RUNNABLE</code>:<ul>
<li>对于<code>Object.wait()</code>: 其他线程调用了该锁对象的<code>notify()</code>或<code>notifyAll()</code>。</li>
<li>对于<code>Thread.join()</code>: 目标线程执行完毕。</li>
<li>对于<code>LockSupport.park()</code>: 其他线程调用了<code>LockSupport.unpark(thread)</code>。</li>
<li><strong>任何时候</strong>，其他线程调用了该线程的<code>interrupt()</code>方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-5-TIMED-WAITING-限时等待"><a href="#1-2-5-TIMED-WAITING-限时等待" class="headerlink" title="1.2.5 TIMED_WAITING (限时等待)"></a>1.2.5 <code>TIMED_WAITING</code> (限时等待)</h4><ul>
<li><strong>定义</strong>：与<code>WAITING</code>类似，但它有等待时间的上限。线程会在指定时间后自动被唤醒，无需其他线程显式唤醒。</li>
<li><strong>特征</strong>：同样不消耗CPU时间，并且在因<code>Object.wait(long)</code>进入此状态时会释放锁。</li>
<li><strong>导致此状态的操作</strong>：<ol>
<li><code>Thread.sleep(long)</code></li>
<li><code>Object.wait(long)</code></li>
<li><code>Thread.join(long)</code></li>
<li><code>LockSupport.parkNanos(long)</code></li>
<li><code>LockSupport.parkUntil(long)</code></li>
</ol>
</li>
<li><strong>状态切换</strong>：<ul>
<li><code>RUNNABLE</code> -&gt; <code>TIMED_WAITING</code>: 调用上述任一方法。</li>
<li><code>TIMED_WAITING</code> -&gt; <code>RUNNABLE</code>:<ul>
<li>等待时间结束。</li>
<li>在等待时间内，被其他线程通过<code>notify()</code>, <code>notifyAll()</code>, <code>unpark()</code>唤醒，或目标线程执行完毕(<code>join</code>)。</li>
<li><strong>任何时候</strong>，其他线程调用了该线程的<code>interrupt()</code>方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-6-TERMINATED-终止"><a href="#1-2-6-TERMINATED-终止" class="headerlink" title="1.2.6 TERMINATED (终止)"></a>1.2.6 <code>TERMINATED</code> (终止)</h4><ul>
<li><strong>定义</strong>：线程的<code>run()</code>方法已经正常执行完毕，或者因为一个未被捕获的异常而提前结束。</li>
<li><strong>特征</strong>：线程的生命周期结束，它所占用的资源被回收。一个处于<code>TERMINATED</code>状态的线程无法再次通过<code>start()</code>方法启动，否则会抛出<code>IllegalThreadStateException</code>。</li>
<li><strong>状态切换</strong>：<ul>
<li><code>RUNNABLE</code> -&gt; <code>TERMINATED</code>: <code>run()</code>方法执行完成或抛出未捕获异常。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-7-核心状态切换详解与辨析"><a href="#1-2-7-核心状态切换详解与辨析" class="headerlink" title="1.2.7 核心状态切换详解与辨析"></a>1.2.7 核心状态切换详解与辨析</h4><p><strong><code>BLOCKED</code> vs. <code>WAITING</code> &#x2F; <code>TIMED_WAITING</code> 的关键区别</strong></p>
<p>这是最容易混淆的地方，也是面试高频点。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>BLOCKED</code> (阻塞)</th>
<th><code>WAITING</code> &#x2F; <code>TIMED_WAITING</code> (等待)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>触发原因</strong></td>
<td><strong>被动</strong>：因争抢<code>synchronized</code>锁失败而进入。</td>
<td><strong>主动</strong>：由代码<strong>主动调用</strong><code>wait()</code>, <code>join()</code>, <code>park()</code>等方法进入。</td>
</tr>
<tr>
<td><strong>锁的持有</strong></td>
<td>线程<strong>不持有</strong>它正在等待的那个<code>synchronized</code>锁。</td>
<td>如果是因为<code>Object.wait()</code>进入等待，它会<strong>释放</strong>已经持有的<code>synchronized</code>锁。如果是<code>park()</code>则不涉及锁。</td>
</tr>
<tr>
<td><strong>唤醒方式</strong></td>
<td><strong>被动</strong>：当持有锁的线程释放锁后，由JVM唤醒并参与竞争。</td>
<td><strong>主动</strong>：必须由其他线程调用<code>notify()</code>, <code>notifyAll()</code>, <code>unpark()</code>或<code>interrupt()</code>来显式唤醒（或超时）。</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td><code>synchronized</code>同步机制。</td>
<td>线程间协作&#x2F;通信，如生产者-消费者模式 (<code>wait/notify</code>)，或等待异步任务完成 (<code>join</code>)。</td>
</tr>
</tbody></table>
<p><strong><code>sleep()</code> vs. <code>wait()</code> 的经典对比</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>Thread.sleep(long millis)</code></th>
<th><code>Object.wait(long timeout)</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>所属类</strong></td>
<td><code>Thread</code></td>
<td><code>Object</code></td>
</tr>
<tr>
<td><strong>是否释放锁</strong></td>
<td><strong>不释放</strong>。如果<code>sleep()</code>在<code>synchronized</code>块中调用，它会一直持有锁，其他线程无法进入。</td>
<td><strong>释放</strong>。线程会释放对象的监视器锁，允许其他线程获取该锁。</td>
</tr>
<tr>
<td><strong>使用前提</strong></td>
<td>无需在同步块中使用。</td>
<td><strong>必须</strong>在<code>synchronized</code>方法或代码块中使用，因为它操作的是锁对象的等待队列。</td>
</tr>
<tr>
<td><strong>唤醒条件</strong></td>
<td>时间到期或被<code>interrupt()</code>。</td>
<td>时间到期、被<code>notify()</code>&#x2F;<code>notifyAll()</code>或被<code>interrupt()</code>。</td>
</tr>
<tr>
<td><strong>目的</strong></td>
<td>让线程暂停执行，通常用于模拟耗时操作或降低CPU使用率。</td>
<td>线程间通信与协作。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-3-线程的创建于启动"><a href="#1-3-线程的创建于启动" class="headerlink" title="1.3 线程的创建于启动"></a>1.3 线程的创建于启动</h3><h4 id="1-3-1-继承Thread类"><a href="#1-3-1-继承Thread类" class="headerlink" title="1.3.1 继承Thread类"></a>1.3.1 继承<code>Thread</code>类</h4><p>这是最直观的方式，通过创建一个继承自<code>java.lang.Thread</code>的子类来定义一个线程。</p>
<p><strong>核心步骤：</strong></p>
<ol>
<li>定义一个类，继承<code>Thread</code>类。</li>
<li>重写<code>run()</code>方法，这个方法就是线程需要执行的任务逻辑。</li>
<li>创建该子类的实例。</li>
<li>调用实例的<code>start()</code>方法来启动线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的任务代码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + getName() + <span class="string">&quot;正在运行&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyThread t1=<span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        MyThread t2=<span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">		</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        </span><br><span class="line">     	<span class="comment">// 注意：是调用 start() 方法，而不是 run() 方法！</span></span><br><span class="line">        <span class="comment">// 调用 start() 会启动一个新的线程，并由JVM调用该线程的 run() 方法。</span></span><br><span class="line">        <span class="comment">// 直接调用 run() 只是在主线程中执行一个普通方法。</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">...</span><br><span class="line">线程线程<span class="number">2</span>正在运行<span class="number">24</span></span><br><span class="line">线程线程<span class="number">1</span>正在运行<span class="number">4</span></span><br><span class="line">线程线程<span class="number">2</span>正在运行<span class="number">27</span></span><br><span class="line">线程线程<span class="number">1</span>正在运行<span class="number">6</span></span><br><span class="line">线程线程<span class="number">1</span>正在运行<span class="number">7</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：实现简单，代码直观。可以直接在<code>run()</code>方法中使用<code>this</code>来获取当前线程对象。</li>
<li><strong>缺点</strong>：<ol>
<li><strong>单继承局限性</strong>：Java是单继承的，如果你的类已经继承了另一个类，就无法再继承<code>Thread</code>类了。</li>
<li><strong>紧耦合</strong>：任务（<code>run</code>方法中的逻辑）与线程（<code>Thread</code>对象）高度耦合，不符合面向对象的设计原则（任务和执行者应该分离）。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="1-3-2-实现Runnable接口"><a href="#1-3-2-实现Runnable接口" class="headerlink" title="1.3.2 实现Runnable接口"></a>1.3.2 实现<code>Runnable</code>接口</h4><p>这是最常用、最推荐的方式，它将任务和线程的执行解耦。</p>
<p><strong>核心步骤：</strong></p>
<ol>
<li>定义一个类，实现<code>java.lang.Runnable</code>接口。</li>
<li>实现接口中的<code>run()</code>方法。</li>
<li>创建该实现类的实例，这个实例就是“任务”。</li>
<li>创建一个<code>Thread</code>对象，并将上一步创建的“任务”实例作为构造函数参数传入。</li>
<li>调用<code>Thread</code>对象的<code>start()</code>方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的任务代码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            Thread t= Thread.currentThread();</span><br><span class="line">            System.out.println(t.getName()+<span class="string">&quot;正在运行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyThread m1=<span class="keyword">new</span> <span class="title class_">MyThread</span>(); <span class="comment">// 1. 创建任务</span></span><br><span class="line">        MyThread m2=<span class="keyword">new</span> <span class="title class_">MyThread</span>(); </span><br><span class="line"></span><br><span class="line">        Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(m1); <span class="comment">// 2. 创建线程并关联任务</span></span><br><span class="line">        Thread t2=<span class="keyword">new</span> <span class="title class_">Thread</span>(m2);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>); </span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start(); <span class="comment">// 3. 启动线程</span></span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">...</span><br><span class="line">线程<span class="number">2</span>正在运行</span><br><span class="line">线程<span class="number">2</span>正在运行</span><br><span class="line">线程<span class="number">1</span>正在运行</span><br><span class="line">线程<span class="number">2</span>正在运行</span><br><span class="line">线程<span class="number">1</span>正在运行</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：<ol>
<li><strong>解耦</strong>：任务（<code>Runnable</code>）和线程（<code>Thread</code>）分离，<code>Runnable</code>对象可以被多个<code>Thread</code>对象共享，适用于多个线程执行相同任务的场景。</li>
<li><strong>无继承限制</strong>：你的任务类可以自由地继承其他任何类。</li>
<li><strong>符合面向对象思想</strong>：更清晰地划分了职责。</li>
</ol>
</li>
<li><strong>缺点</strong>：<code>run()</code>方法没有返回值，也不能抛出受检异常（Checked Exception）。</li>
</ul>
<hr>
<h4 id="1-3-3-实现Callable接口-配合-FutureTask"><a href="#1-3-3-实现Callable接口-配合-FutureTask" class="headerlink" title="1.3.3 实现Callable接口 (配合 FutureTask)"></a>1.3.3 实现<code>Callable</code>接口 (配合 <code>FutureTask</code>)</h4><p>这种方式是<code>Runnable</code>的增强版，解决了<code>Runnable</code>无法返回结果和抛出异常的痛点。</p>
<p><code>Callable</code>是<code>Executor</code>框架的一部分。</p>
<p><strong>核心步骤：</strong></p>
<ol>
<li>定义一个类，实现<code>java.util.concurrent.Callable&lt;V&gt;</code>接口，<code>V</code>是返回值的类型。</li>
<li>实现接口中的<code>call()</code>方法，这个方法可以有返回值，并且可以<code>throws Exception</code>。</li>
<li>创建该实现类的实例。</li>
<li>使用<code>java.util.concurrent.FutureTask&lt;V&gt;</code>来包装<code>Callable</code>对象。<code>FutureTask</code>本身实现了<code>Runnable</code>接口，所以可以被<code>Thread</code>接受。</li>
<li>创建<code>Thread</code>对象，并将<code>FutureTask</code>实例作为参数传入。</li>
<li>启动线程。</li>
<li>通过<code>FutureTask</code>的<code>get()</code>方法来获取线程执行的返回结果（<code>get()</code>方法会阻塞，直到任务执行完毕）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 模拟耗时计算</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程名: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;任务执行完毕，返回结果！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">callableTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        <span class="comment">// 使用FutureTask包装MyCallable实例，FutureTask是Runnable和Future的实现类</span></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callableTask);</span><br><span class="line">        <span class="comment">// 创建线程并传入FutureTask实例，FutureTask可以作为Runnable被线程执行</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        <span class="comment">// 启动线程执行任务</span></span><br><span class="line">        thread.start();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;主线程继续执行其他任务...&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// get()方法会阻塞当前线程，直到call()方法执行完成并返回结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get(); </span><br><span class="line">        System.out.println(<span class="string">&quot;主线程获取到异步任务结果: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="number">4950</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：<ol>
<li><strong>有返回值</strong>：可以获取异步任务的执行结果。</li>
<li><strong>可抛出异常</strong>：可以在<code>call()</code>方法中抛出异常，并在主线程中通过<code>get()</code>捕获和处理。</li>
<li>功能强大，是现代并发编程（尤其是线程池）的基础。</li>
</ol>
</li>
<li><strong>缺点</strong>：编码比<code>Runnable</code>稍复杂。</li>
</ul>
<hr>
<h4 id="1-3-4-start-与-run-的区别"><a href="#1-3-4-start-与-run-的区别" class="headerlink" title="1.3.4 start() 与 run() 的区别"></a>1.3.4 <code>start()</code> 与 <code>run()</code> 的区别</h4><ul>
<li><strong><code>thread.start()</code></strong>:<ul>
<li><strong>作用</strong>：<strong>启动一个新线程</strong>。</li>
<li><strong>过程</strong>：它会请求JVM，JVM再请求操作系统，为这个线程分配必要的资源，并将其置于**可运行（RUNNABLE）**状态。当该线程获得CPU时间片后，JVM会自动调用其 <code>run()</code> 方法。</li>
<li><strong>结果</strong>：实现了真正的多线程并发执行。调用 <code>start()</code> 的线程（如主线程）会立即返回，不会等待新线程的 <code>run()</code> 方法执行完毕。</li>
</ul>
</li>
<li><strong><code>thread.run()</code></strong>:<ul>
<li><strong>作用</strong>：<strong>仅仅是调用一个普通的方法</strong>。</li>
<li><strong>过程</strong>：它不会创建新线程。<code>run()</code> 方法中的代码会在<strong>调用它的那个线程</strong>（例如，主线程）中同步执行。</li>
<li><strong>结果</strong>：程序依然是单线程的，没有实现并发。只有当 <code>run()</code> 方法执行完毕后，调用者才能继续执行下面的代码。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-4-线程核心API"><a href="#1-4-线程核心API" class="headerlink" title="1.4 线程核心API"></a>1.4 线程核心API</h3><p><code>java.lang.Thread</code> 类提供了一系列静态方法和实例方法来控制和查询线程的状态与行为。</p>
<h4 id="1-4-1-启动与执行"><a href="#1-4-1-启动与执行" class="headerlink" title="1.4.1 启动与执行"></a>1.4.1 启动与执行</h4><p><strong><code>void start()</code></strong></p>
<ul>
<li><strong>描述</strong>：启动一个新线程，使其进入 <code>RUNNABLE</code> 状态。JVM会调用该线程的 <code>run()</code> 方法。这是实现并发的唯一正确方式。</li>
<li><strong>注意</strong>：一个线程对象只能调用一次 <code>start()</code>。</li>
</ul>
<p><strong><code>void run()</code></strong></p>
<ul>
<li><strong>描述</strong>：线程要执行的任务逻辑。如果直接调用 <code>run()</code>，它将作为普通方法在当前线程中同步执行，不会创建新线程。</li>
</ul>
<hr>
<h4 id="1-4-2-控制线程执行"><a href="#1-4-2-控制线程执行" class="headerlink" title="1.4.2 控制线程执行"></a>1.4.2 控制线程执行</h4><p><strong><code>static void sleep(long millis)</code></strong></p>
<ul>
<li><p><strong>描述</strong>：使<strong>当前</strong>正在执行的线程暂停执行指定的毫秒数。这是一个<strong>静态方法</strong>。</p>
</li>
<li><p><strong>核心特点</strong>：</p>
<ol>
<li><strong>让出CPU</strong>：线程会从 <code>RUNNABLE</code> 状态进入 <code>TIMED_WAITING</code> 状态，暂时让出CPU执行权。</li>
<li><strong>不释放锁</strong>：如果当前线程持有一个锁（例如在 <code>synchronized</code> 块内调用 <code>sleep</code>），它在睡眠期间<strong>不会释放这个锁</strong>。这可能导致其他需要该锁的线程长时间阻塞。</li>
<li><strong>响应中断</strong>：<code>sleep</code> 期间如果其他线程调用了该线程的 <code>interrupt()</code> 方法，<code>sleep</code>会立即终止，并抛出 <code>InterruptedException</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;主线程开始...&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 让主线程休眠2秒</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 如果在休眠期间被中断，会进入这里</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;主线程结束。&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>void join()</code> &#x2F; <code>void join(long millis)</code></strong></p>
<ul>
<li><p><strong>描述</strong>：<strong>等待</strong>该线程执行终止。调用 <code>t.join()</code> 的线程（例如主线程）会被阻塞，直到线程 <code>t</code> 的 <code>run()</code> 方法执行完毕。</p>
</li>
<li><p><strong>核心特点</strong>：</p>
<ol>
<li><strong>线程协同</strong>：用于实现线程之间的同步。常用于主线程等待子线程完成任务后再继续执行的场景。</li>
<li><strong>阻塞调用者</strong>：<code>t.join()</code> 阻塞的是<strong>调用它的线程</strong>，而不是线程<code>t</code>本身。</li>
<li><strong>响应中断</strong>：等待期间，如果调用 <code>join()</code> 的线程被中断，<code>join()</code> 方法会抛出 <code>InterruptedException</code>。</li>
<li><strong>超时版本</strong>：<code>join(long millis)</code> 提供了一个超时机制，如果在指定时间内目标线程还未结束，等待的线程将自动恢复执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;工作线程开始执行...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟耗时任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;工作线程执行完毕。&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">worker.start();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;主线程等待工作线程完成...&quot;</span>);</span><br><span class="line">worker.join(); <span class="comment">// 主线程在此处阻塞，直到 worker 线程执行完毕</span></span><br><span class="line">System.out.println(<span class="string">&quot;主线程继续执行。&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>static void yield()</code></strong></p>
<ul>
<li><strong>描述</strong>：一个<strong>提示性</strong>的静态方法，建议线程调度器可以将CPU让给其他同优先级的线程。</li>
<li><strong>核心特点</strong>：<ol>
<li><strong>不保证生效</strong>：<code>yield()</code> 只是一个“建议”，调度器完全可以忽略它。</li>
<li><strong>不进入阻塞</strong>：线程只是从“运行中”状态转回“就绪”状态，仍在 <code>RUNNABLE</code> 状态，随时可能再次被调度。</li>
<li><strong>不释放锁</strong>：和 <code>sleep</code> 一样，<code>yield</code> 期间<strong>不会释放锁</strong>。</li>
</ol>
</li>
<li><strong>用途</strong>：由于其不确定性，在实际开发中很少使用。主要用于调试或测试场景。</li>
</ul>
<hr>
<h4 id="1-4-3-线程中断机制-推荐的线程终止方式"><a href="#1-4-3-线程中断机制-推荐的线程终止方式" class="headerlink" title="1.4.3 线程中断机制 (推荐的线程终止方式)"></a>1.4.3 线程中断机制 (推荐的线程终止方式)</h4><p>中断是一种协作式的线程终止机制。它不像 <code>stop()</code> 方法那样强制停止，而是向目标线程发送一个“中断请求”信号，由目标线程自行决定如何响应。</p>
<p><strong><code>void interrupt()</code></strong></p>
<ul>
<li><strong>描述</strong>：设置目标线程的**中断标志位 (interrupt flag)**为 <code>true</code>。</li>
<li><strong>特殊效果</strong>：如果目标线程正处于 <code>sleep()</code>, <code>wait()</code>, <code>join()</code> 等阻塞状态，调用 <code>interrupt()</code> 会立即唤醒它，并使其抛出 <code>InterruptedException</code>。抛出异常后，<strong>中断标志位会被清除（重置为 <code>false</code>）</strong>。</li>
</ul>
<p><strong><code>boolean isInterrupted()</code></strong></p>
<ul>
<li><strong>描述</strong>：一个<strong>实例方法</strong>，用于检查<strong>目标线程</strong>的中断标志位是否为 <code>true</code>。</li>
<li><strong>核心特点</strong>：<strong>不清除</strong>中断标志位。即连续多次调用会返回相同的结果。</li>
</ul>
<p><strong><code>static boolean interrupted()</code></strong></p>
<ul>
<li><strong>描述</strong>：一个<strong>静态方法</strong>，用于检查<strong>当前线程</strong>的中断标志位是否为 <code>true</code>。</li>
<li><strong>核心特点</strong>：这是一个有副作用的方法，它在返回中断状态后，会<strong>立即清除</strong>中断标志位（将其重置为 <code>false</code>）。</li>
</ul>
<p><strong>正确使用中断的示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">interruptibleTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// isInterrupted() 是循环的退出条件</span></span><br><span class="line">    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务正在运行...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// sleep可以响应中断</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 当 sleep 被中断时，会抛出此异常，并清除中断标志位</span></span><br><span class="line">            System.out.println(<span class="string">&quot;任务在休眠中被中断！&quot;</span>);</span><br><span class="line">            <span class="comment">// 需要重新设置中断标志位，以便循环条件能正确退出</span></span><br><span class="line">            Thread.currentThread().interrupt(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务已终止。&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">interruptibleTask.start();</span><br><span class="line">Thread.sleep(<span class="number">3000</span>); <span class="comment">// 让任务运行3秒</span></span><br><span class="line">System.out.println(<span class="string">&quot;主线程请求中断任务...&quot;</span>);</span><br><span class="line">interruptibleTask.interrupt(); <span class="comment">// 发送中断信号</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-4-4-获取线程信息"><a href="#1-4-4-获取线程信息" class="headerlink" title="1.4.4 获取线程信息"></a>1.4.4 获取线程信息</h4><p><strong><code>static Thread currentThread()</code></strong></p>
<ul>
<li><strong>描述</strong>：返回当前正在执行的线程对象的引用。</li>
</ul>
<p><strong><code>String getName()</code> &#x2F; <code>void setName(String name)</code></strong></p>
<ul>
<li><strong>描述</strong>：获取或设置线程的名称。为线程设置一个有意义的名称是调试并发问题的良好实践。</li>
</ul>
<p><strong><code>long getId()</code></strong></p>
<ul>
<li><strong>描述</strong>：返回线程的唯一标识符（ID）。</li>
</ul>
<p><strong><code>Thread.State getState()</code></strong></p>
<ul>
<li><strong>描述</strong>：返回线程当前的生命周期状态（<code>NEW</code>, <code>RUNNABLE</code>, <code>BLOCKED</code>, etc.）。</li>
</ul>
<hr>
<h4 id="1-4-5-守护线程与优先级"><a href="#1-4-5-守护线程与优先级" class="headerlink" title="1.4.5 守护线程与优先级"></a>1.4.5 守护线程与优先级</h4><p>这部分将在后续章节详细讲解，这里先做API介绍。</p>
<p><strong><code>void setDaemon(boolean on)</code></strong></p>
<ul>
<li><strong>描述</strong>：将线程标记为守护线程或用户线程。必须在 <code>start()</code> 方法调用之前设置。</li>
</ul>
<p><strong><code>void setPriority(int newPriority)</code></strong></p>
<ul>
<li><strong>描述</strong>：设置线程的优先级。范围是1-10，默认为5。但这只是给操作系统的一个“建议”，不保证严格按优先级执行。</li>
</ul>
<hr>
<h4 id="1-4-6-已废弃的危险方法-不要使用！"><a href="#1-4-6-已废弃的危险方法-不要使用！" class="headerlink" title="1.4.6 已废弃的危险方法 (不要使用！)"></a>1.4.6 已废弃的危险方法 (不要使用！)</h4><p><strong><code>void stop()</code></strong>: 强行终止线程。<strong>极其危险</strong>，因为它会立即释放线程持有的所有锁，可能导致共享数据处于不一致的“脏”状态。</p>
<p><strong><code>void suspend()</code> &#x2F; <code>void resume()</code></strong>: 暂停和恢复线程。<strong>容易导致死锁</strong>。如果一个线程在持有锁时被 <code>suspend()</code>，它将永远不会释放锁，其他等待该锁的线程将永久阻塞。</p>
<hr>
<h4 id="1-4-7-总结表格"><a href="#1-4-7-总结表格" class="headerlink" title="1.4.7 总结表格"></a>1.4.7 总结表格</h4><table>
<thead>
<tr>
<th>方法签名</th>
<th>类型</th>
<th>作用</th>
<th>是否释放锁</th>
<th>关键说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>void start()</code></td>
<td>实例方法</td>
<td>启动新线程，异步调用<code>run()</code></td>
<td>-</td>
<td>只能调用一次</td>
</tr>
<tr>
<td><code>void run()</code></td>
<td>实例方法</td>
<td>线程执行体，同步调用</td>
<td>-</td>
<td>直接调用等于普通方法调用</td>
</tr>
<tr>
<td><code>static void sleep(long)</code></td>
<td>静态方法</td>
<td>使<strong>当前</strong>线程休眠指定时间</td>
<td><strong>否</strong></td>
<td>会抛出<code>InterruptedException</code></td>
</tr>
<tr>
<td><code>void join()</code> &#x2F; <code>void join(long)</code></td>
<td>实例方法</td>
<td>使<strong>调用者</strong>线程等待该线程结束</td>
<td>-</td>
<td>阻塞调用者，用于线程协同</td>
</tr>
<tr>
<td><code>void interrupt()</code></td>
<td>实例方法</td>
<td>设置目标线程的中断标志位</td>
<td>-</td>
<td>可唤醒阻塞状态的线程（并抛出<code>InterruptedException</code>）</td>
</tr>
<tr>
<td><code>boolean isInterrupted()</code></td>
<td>实例方法</td>
<td>检查目标线程的中断状态</td>
<td>-</td>
<td><strong>不</strong>清除中断标志位</td>
</tr>
<tr>
<td><code>static boolean interrupted()</code></td>
<td>静态方法</td>
<td>检查<strong>当前</strong>线程的中断状态</td>
<td>-</td>
<td><strong>会</strong>清除中断标志位</td>
</tr>
<tr>
<td><code>static void yield()</code></td>
<td>静态方法</td>
<td>建议调度器让出CPU</td>
<td><strong>否</strong></td>
<td>仅为提示，不保证生效</td>
</tr>
<tr>
<td><code>static Thread currentThread()</code></td>
<td>静态方法</td>
<td>获取当前执行的线程对象</td>
<td>-</td>
<td>非常常用</td>
</tr>
<tr>
<td><code>void stop()</code> &#x2F; <code>suspend()</code> &#x2F; <code>resume()</code></td>
<td>实例方法</td>
<td><strong>已废弃，绝对不要使用</strong></td>
<td>危险操作</td>
<td>导致数据不一致或死锁</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-5-守护线程"><a href="#1-5-守护线程" class="headerlink" title="1.5 守护线程"></a>1.5 守护线程</h3><h4 id="1-5-1-概念"><a href="#1-5-1-概念" class="headerlink" title="1.5.1 概念"></a>1.5.1 概念</h4><p>守护线程（Daemon Thread）是一种特殊的线程，它在后台运行，为其他线程（即用户线程）提供服务。可以将其理解为程序的“服务员”或“后台工作者”。</p>
<p>守护线程最核心的特性是：<strong>它的生命周期与JVM的生命周期“绑定”在一起，但它不会阻止JVM的退出</strong>。换句话说，当程序中所有的<strong>用户线程</strong>（User Thread，也称非守护线程）都执行完毕后，JVM就会自动退出，而无论此时是否还有守护线程在运行。JVM在退出时会直接、粗暴地终止所有守护线程，不会等待它们执行完毕。</p>
<p>Java程序中最典型的守护线程就是<strong>垃圾回收器（Garbage Collector, GC）</strong>。只要我们的主程序还在运行，GC就会在后台默默地回收内存；一旦主程序结束（所有用户线程都结束了），GC线程也会随之被终止。</p>
<hr>
<h4 id="1-5-2-守护线程与用户线程的区别"><a href="#1-5-2-守护线程与用户线程的区别" class="headerlink" title="1.5.2 守护线程与用户线程的区别"></a>1.5.2 守护线程与用户线程的区别</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">用户线程 (User Thread)</th>
<th align="left">守护线程 (Daemon Thread)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>角色</strong></td>
<td align="left">程序的主体，执行核心业务逻辑。</td>
<td align="left">后台服务者，为用户线程提供支持。</td>
</tr>
<tr>
<td align="left"><strong>JVM退出</strong></td>
<td align="left">只要有一个用户线程还在运行，JVM就不会退出。</td>
<td align="left">守护线程不会影响JVM的退出。</td>
</tr>
<tr>
<td align="left"><strong>生命周期</strong></td>
<td align="left">独立，执行完毕后才算结束。</td>
<td align="left">依赖于所有用户线程，当用户线程全部结束后，它会被强制终止。</td>
</tr>
<tr>
<td align="left"><strong>资源清理</strong></td>
<td align="left">能够保证<code>finally</code>代码块的执行，可以进行可靠的资源清理。</td>
<td align="left">被强制终止时，<strong>不保证<code>finally</code>代码块会被执行</strong>，因此不适合执行关键的资源清理操作。</td>
</tr>
<tr>
<td align="left"><strong>默认状态</strong></td>
<td align="left"><code>main</code>线程和默认创建的线程都是用户线程。</td>
<td align="left">需要显式设置。</td>
</tr>
</tbody></table>
<hr>
<h4 id="1-5-3-创建与使用"><a href="#1-5-3-创建与使用" class="headerlink" title="1.5.3 创建与使用"></a>1.5.3 创建与使用</h4><p>我们可以通过 <code>Thread</code> 类的 <code>setDaemon(boolean on)</code> 方法来设置一个线程是否为守护线程。</p>
<p><strong>核心API:</strong></p>
<ul>
<li><code>void setDaemon(boolean on)</code>: 将线程标记为守护线程或用户线程。如果参数为 <code>true</code>，则为守护线程；<code>false</code> 则为用户线程。</li>
<li><code>boolean isDaemon()</code>: 判断该线程是否为守护线程。</li>
</ul>
<p><strong>关键规则：<code>setDaemon(true)</code> 方法必须在调用 <code>thread.start()</code> 方法之前设置，否则会抛出 <code>IllegalThreadStateException</code> 异常。</strong></p>
<p><strong>代码示例：</strong></p>
<p>下面是一个监控程序运行状态的守护线程示例。主线程（用户线程）模拟一个耗时5秒的任务，守护线程在后台每秒打印一次监控信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonThreadExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个任务作为守护线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;守护线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 开始运行...&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 无限循环，模拟持续监控</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;守护线程正在监控...&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 守护线程在被终止时，sleep会抛出InterruptedException</span></span><br><span class="line">                System.out.println(<span class="string">&quot;守护线程被中断。&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 这个 finally 块中的代码不保证会被执行！</span></span><br><span class="line">                System.out.println(<span class="string">&quot;守护线程的 finally 块执行了。&quot;</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Daemon-Monitor&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 将该线程设置为守护线程</span></span><br><span class="line">        <span class="comment">// 必须在 start() 之前调用</span></span><br><span class="line">        daemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 启动守护线程</span></span><br><span class="line">        daemonThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main线程（用户线程）开始执行任务</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 开始运行...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟主线程工作5秒</span></span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程 &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 运行结束。&quot;</span>);</span><br><span class="line">        <span class="comment">// 当 main 线程结束后，程序中没有其他用户线程，JVM即将退出</span></span><br><span class="line">        <span class="comment">// 守护线程 daemonThread 将被强制终止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">主线程 main 开始运行...</span><br><span class="line">守护线程 Daemon-Monitor 开始运行...</span><br><span class="line">守护线程正在监控...</span><br><span class="line">守护线程正在监控...</span><br><span class="line">守护线程正在监控...</span><br><span class="line">守护线程正在监控...</span><br><span class="line">守护线程正在监控...</span><br><span class="line">主线程 main 运行结束。</span><br><span class="line"><span class="comment">// 程序到此结束，&quot;守护线程的 finally 块执行了。&quot; 这句话大概率不会被打印出来。</span></span><br></pre></td></tr></table></figure>

<p>从输出结果可以看出，当 <code>main</code> 线程结束后，整个程序就退出了，守护线程被立即终止，甚至来不及执行它的<code>finally</code>代码块。</p>
<hr>
<h4 id="1-5-4-注意事项与最佳实践"><a href="#1-5-4-注意事项与最佳实践" class="headerlink" title="1.5.4 注意事项与最佳实践"></a>1.5.4 注意事项与最佳实践</h4><ol>
<li><strong>设置时机</strong>: <code>setDaemon(true)</code> 必须在线程启动（调用 <code>start()</code>）之前完成。一旦线程启动，其守护状态就不能再改变。</li>
<li><strong>不适合关键任务</strong>: 由于守护线程的终止是突然且不可预测的，它不保证会执行 <code>finally</code> 块中的代码。因此，<strong>绝对不要在守护线程中执行任何涉及资源操作（如I&#x2F;O读写、数据库连接关闭、锁的释放等）的逻辑</strong>，否则可能导致资源泄露或数据不一致。</li>
<li><strong>继承性</strong>: 一个线程创建的新线程，其守护状态<strong>默认与创建它的线程（父线程）保持一致</strong>。例如，如果一个守护线程创建了一个新线程，那么这个新线程默认也是一个守护线程。由于 <code>main</code> 线程是用户线程，所以由 <code>main</code> 线程创建的线程默认也都是用户线程。</li>
<li><strong>典型应用场景</strong>:<ul>
<li><strong>后台监控</strong>: 监控系统健康状况、内存使用情况等。</li>
<li><strong>日志记录</strong>: 后台线程负责将日志信息异步写入文件。</li>
<li><strong>缓存管理</strong>: 定时清理过期的缓存数据。</li>
<li><strong>Java自带的守护线程</strong>: 垃圾回收（GC）、JMX（Java Management Extensions）等。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-并发编程的理论基石"><a href="#2-并发编程的理论基石" class="headerlink" title="2. 并发编程的理论基石"></a>2. 并发编程的理论基石</h2><h3 id="2-1-Java内存模型-JMM"><a href="#2-1-Java内存模型-JMM" class="headerlink" title="2.1 Java内存模型(JMM)"></a>2.1 Java内存模型(JMM)</h3><h4 id="2-1-1-概念"><a href="#2-1-1-概念" class="headerlink" title="2.1.1 概念"></a>2.1.1 概念</h4><p>在早期的单核CPU时代，所有线程都在同一个CPU上执行，共享同一份内存，内存的读写操作都是相对可预测的。然而，现代计算机系统几乎都是多核CPU架构。为了弥补CPU与主内存之间巨大的速度差异，每个CPU核心都有自己的高速缓存（如L1, L2, L3 Cache）。</p>
<p>这带来了并发编程中的一个核心挑战：<strong>数据一致性问题</strong>。当多个线程在不同的CPU核心上运行时，它们会各自将共享变量从主内存（Main Memory）加载到自己的工作内存（Working Memory，即高速缓存）中进行操作。一个线程对变量的修改，如果没能及时同步回主内存，那么其他线程就无法看到这个最新的值，从而导致数据不一致。</p>
<p>此外，为了提升性能，编译器和处理器还会对指令进行<strong>重排序（Reordering）</strong>。在单线程环境下，重排序不会影响最终结果，但在多线程环境下，这种“无序”的执行可能会导致程序出现意想不到的错误。</p>
<p><strong>Java内存模型（JMM）</strong> 的诞生就是为了解决这些问题。它不是一个物理存在，而是一套<strong>抽象的规范和规则</strong>，旨在：</p>
<ol>
<li><strong>屏蔽底层硬件和操作系统的内存访问差异</strong>，让Java程序在各种平台上都能达到一致的内存访问效果。</li>
<li><strong>定义多线程之间共享变量的可见性、原子性和有序性问题</strong>，为开发者提供一套清晰的、可预测的并发编程保障。</li>
</ol>
<hr>
<h4 id="2-1-2-JMM的抽象模型"><a href="#2-1-2-JMM的抽象模型" class="headerlink" title="2.1.2 JMM的抽象模型"></a>2.1.2 JMM的抽象模型</h4><p>JMM定义了一个抽象的、逻辑上的内存结构，它将内存分为两部分：</p>
<ul>
<li><strong>主内存（Main Memory）</strong>: 存储所有线程共享的变量（实例字段、静态字段、数组元素等）。主内存是所有线程都能访问的区域。</li>
<li><strong>工作内存（Working Memory）</strong>: 每个线程私有的内存区域，存储了该线程需要使用的共享变量的<strong>副本</strong>。线程对变量的所有操作（读取、赋值等）都必须在自己的工作内存中进行，而不能直接读写主内存中的变量。</li>
</ul>
<p><strong>线程间变量交互的过程如下：</strong></p>
<ol>
<li><strong>Read &amp; Load</strong>: 线程A要使用共享变量X，首先会从主内存中读取X的值，并加载（Load）到自己的工作内存A中，形成一个副本。</li>
<li><strong>Use &amp; Assign</strong>: 线程A在自己的工作内存中对变量X的副本进行操作（Use），并将结果赋值（Assign）给这个副本。</li>
<li><strong>Store &amp; Write</strong>: 当线程A需要将修改后的值同步回主内存时，它会先将工作内存中的副本存储（Store）起来，然后写入（Write）到主内存中。</li>
</ol>
<p><strong>关键问题</strong>: 如果线程A修改了变量X但没有及时写回主内存，那么线程B读取到的仍然是主内存中的旧值，这就是<strong>可见性问题</strong>的根源。</p>
<hr>
<h4 id="2-1-3-JMM围绕并发处理的三个核心特性"><a href="#2-1-3-JMM围绕并发处理的三个核心特性" class="headerlink" title="2.1.3 JMM围绕并发处理的三个核心特性"></a>2.1.3 JMM围绕并发处理的三个核心特性</h4><p>JMM主要是为了在并发编程中保证以下三个特性，从而确保程序的正确性。</p>
<h5 id="1-原子性-Atomicity"><a href="#1-原子性-Atomicity" class="headerlink" title="1. 原子性 (Atomicity)"></a>1. 原子性 (Atomicity)</h5><p>原子性指一个或多个操作，要么全部执行成功，要么全部不执行，中间不会被任何其他因素（如线程切换）中断。</p>
<ul>
<li><strong>基本类型原子性</strong>: 在Java中，对基本数据类型（<code>long</code>和<code>double</code>除外）的变量的读取和赋值操作是原子性的。例如 <code>int i = 10;</code> 是原子操作。</li>
<li><strong><code>long</code>和<code>double</code>的非原子性</strong>: 对于64位的<code>long</code>和<code>double</code>，JMM允许JVM将其读&#x2F;写操作拆分为两个32位的操作。在32位系统上，这可能导致一个线程只修改了高32位，就被另一个线程读取，造成“撕裂读”（Torn Read）。不过，现代商用JVM基本都实现了对<code>long</code>和<code>double</code>的原子性读写。</li>
<li><strong>复合操作的非原子性</strong>: 像 <code>count++</code> 这样的操作不是原子的。它包含三个步骤：1) 读取<code>count</code>的值；2) 将值加1；3) 将新值写回。在多线程环境下，这三个步骤之间可能被其他线程打断，导致结果错误。</li>
<li><strong>如何保证原子性</strong>: JMM提供了<code>synchronized</code>关键字和<code>java.util.concurrent.locks</code>（如<code>ReentrantLock</code>）来保证一个代码块的原子性。<code>java.util.concurrent.atomic</code>包下的原子类（如<code>AtomicInteger</code>）则通过CAS操作来保证单个变量操作的原子性。</li>
</ul>
<hr>
<h5 id="2-可见性-Visibility"><a href="#2-可见性-Visibility" class="headerlink" title="2. 可见性 (Visibility)"></a>2. 可见性 (Visibility)</h5><p>可见性指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。</p>
<ul>
<li><strong>问题根源</strong>: CPU缓存、编译器优化和处理器优化都可能导致可见性问题。一个线程在自己的工作内存中修改了变量，但未刷新到主内存，导致其他线程不可见。</li>
<li><strong>如何保证可见性</strong>:<ul>
<li><strong><code>volatile</code></strong>: 使用<code>volatile</code>关键字修饰的变量，JMM会保证每次修改后都立即写回主内存，并且每次读取前都从主内存刷新。这强制实现了缓存一致性。</li>
<li><strong><code>synchronized</code>和<code>Lock</code></strong>: 对一个变量执行<code>unlock</code>操作之前，必须将该变量同步回主内存。而执行<code>lock</code>操作时，会清空工作内存中共享变量的副本，强制从主内存中重新加载。</li>
<li><strong><code>final</code></strong>: 被<code>final</code>修饰的字段在构造函数中一旦初始化完成，并且构造函数没有把<code>this</code>引用泄露出去，那么在其他线程中就能保证看到<code>final</code>字段的正确初始化值。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-有序性-Ordering"><a href="#3-有序性-Ordering" class="headerlink" title="3. 有序性 (Ordering)"></a>3. 有序性 (Ordering)</h5><p>有序性指程序代码的执行顺序与代码的书写顺序一致。</p>
<ul>
<li><strong>问题根源</strong>: 为了提高性能，编译器和处理器可能会对指令进行重排序。<ul>
<li><strong>编译器优化重排序</strong>: 编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li><strong>指令级并行重排序</strong>: 现代处理器采用指令级并行技术，将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
</ul>
</li>
<li><strong>如何保证有序性</strong>:<ul>
<li><strong><code>volatile</code></strong>: <code>volatile</code>关键字本身就包含“禁止指令重排序”的语义，从而在一定程度上保证了有序性。</li>
<li><strong><code>synchronized</code>和<code>Lock</code></strong>: <code>synchronized</code>和<code>Lock</code>保证了同一时刻只有一个线程能进入临界区，这使得临界区内的代码在宏观上是串行执行的，从而保证了有序性。</li>
<li><strong>Happens-Before原则</strong>: 这是JMM中最重要的一个概念，是判断数据是否存在竞争、线程是否安全的主要依据。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-4-Happens-Before-原则"><a href="#2-1-4-Happens-Before-原则" class="headerlink" title="2.1.4 Happens-Before 原则"></a>2.1.4 Happens-Before 原则</h4><p>为了让开发者更容易地理解和使用并发，JMM提出了<strong>Happens-Before</strong>（先行发生）原则。这个原则是JMM对可见性和有序性的核心体现。</p>
<p><strong>定义</strong>: 如果操作A happens-before 操作B，那么A操作的执行结果对B操作是可见的，并且A操作的执行顺序在B操作之前。</p>
<p>这两个操作可以在同一个线程内，也可以在不同线程之间。JMM天然定义了以下几条Happens-Before规则，无需开发者额外处理：</p>
<ol>
<li><strong>程序次序规则 (Program Order Rule)</strong>: 在一个线程内，按照代码的先后顺序，书写在前面的操作happens-before书写在后面的操作。</li>
<li><strong>管程锁定规则 (Monitor Lock Rule)</strong>: 一个<code>unlock</code>操作happens-before后续对<strong>同一个锁</strong>的<code>lock</code>操作。</li>
<li><strong><code>volatile</code>变量规则 (Volatile Variable Rule)</strong>: 对一个<code>volatile</code>变量的<strong>写</strong>操作happens-before后续对这个<code>volatile</code>变量的<strong>读</strong>操作。</li>
<li><strong>线程启动规则 (Thread Start Rule)</strong>: <code>Thread</code>对象的<code>start()</code>方法happens-before此线程的任何一个动作。</li>
<li><strong>线程终止规则 (Thread Termination Rule)</strong>: 线程中的所有操作都happens-before对此线程的终止检测，例如可以通过<code>Thread.join()</code>方法结束、<code>Thread.isAlive()</code>的返回<code>false</code>等手段检测到线程已经终止执行。</li>
<li><strong>线程中断规则 (Thread Interruption Rule)</strong>: 对线程<code>interrupt()</code>方法的调用happens-before被中断线程的代码检测到中断事件的发生。</li>
<li><strong>对象终结规则 (Finalizer Rule)</strong>: 一个对象的初始化完成（构造函数执行结束）happens-before它的<code>finalize()</code>方法的开始。</li>
<li><strong>传递性 (Transitivity)</strong>: 如果操作A happens-before 操作B，操作B happens-before 操作C，那么可以得出操作A happens-before 操作C。</li>
</ol>
<hr>
<h3 id="2-2-关键字与底层实现"><a href="#2-2-关键字与底层实现" class="headerlink" title="2.2 关键字与底层实现"></a>2.2 关键字与底层实现</h3><h4 id="2-2-1-synchronized：重量级的内置锁"><a href="#2-2-1-synchronized：重量级的内置锁" class="headerlink" title="2.2.1 synchronized：重量级的内置锁"></a>2.2.1 <code>synchronized</code>：重量级的内置锁</h4><p><code>synchronized</code> 是 Java 中最经典、最常用的同步机制。它是一种<strong>悲观锁</strong>，总是在操作数据前先加锁，确保同一时间只有一个线程能访问被保护的代码块或方法。</p>
<h5 id="1-核心作用"><a href="#1-核心作用" class="headerlink" title="1. 核心作用"></a>1. 核心作用</h5><p><code>synchronized</code> 提供了两大核心保证：</p>
<ol>
<li><strong>原子性 (Atomicity)</strong>：<code>synchronized</code> 关键字包裹的代码块（称为“同步块”或“临界区”）是原子的。一个线程一旦进入同步块，就会持有锁，直到执行完毕或抛出异常才会释放锁。在此期间，其他任何线程都无法进入该同步块。</li>
<li><strong>可见性 (Visibility)</strong>：根据JMM的管程锁定规则（Happens-Before），对一个锁的 <code>unlock</code> 操作 happens-before 后续对同一个锁的 <code>lock</code> 操作。这意味着：<ul>
<li><strong>释放锁时</strong>：线程必须将工作内存中修改过的共享变量值刷新到主内存。</li>
<li><strong>获取锁时</strong>：线程会清空工作内存，强制从主内存中重新加载共享变量的最新值。</li>
<li>通过这一进一出的机制，<code>synchronized</code> 保证了线程间的可见性。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="2-使用方式"><a href="#2-使用方式" class="headerlink" title="2. 使用方式"></a>2. 使用方式</h5><p><code>synchronized</code> 有三种主要的使用方式：</p>
<ol>
<li><p><strong>修饰实例方法</strong>：锁对象是当前实例对象 (<code>this</code>)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">instanceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 同步代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修饰静态方法</strong>：锁对象是当前类的 <code>Class</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 同步代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修饰代码块</strong>：可以显式指定任何对象作为锁对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">blockMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 锁对象是 lock</span></span><br><span class="line">        <span class="comment">// 同步代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; <span class="comment">// 锁对象是 this</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="3-底层实现原理：Monitor-与锁升级"><a href="#3-底层实现原理：Monitor-与锁升级" class="headerlink" title="3. 底层实现原理：Monitor 与锁升级"></a>3. 底层实现原理：Monitor 与锁升级</h5><p><code>synchronized</code> 的底层实现严重依赖于 <strong>JVM</strong> 和<strong>操作系统</strong>。核心围绕 <strong>对象监视器（Object Monitor）</strong> 和 <strong>锁升级</strong> 两个关键概念展开。</p>
<p><strong>重量级锁的基石：<code>ObjectMonitor</code></strong></p>
<p>在 <code>synchronized</code> 的世界里，每个Java对象天生就是一个潜在的锁。当一个对象首次被用作同步锁时，JVM 会为其关联一个 <strong>Monitor</strong> 对象。这个 Monitor 并不是 Java 语言层面的对象，而是 JVM 内部基于 C++ 实现的一个结构，通常是 <code>ObjectMonitor</code>。</p>
<p>你可以将 <code>ObjectMonitor</code> 想象成一个管理同步的“调度室”，它包含了几个核心组件：</p>
<ul>
<li><code>_owner</code>: 一个指针，指向当前持有该 Monitor 的线程。这是判断锁是否被占用的关键。</li>
<li><code>_EntryList</code>: 一个<strong>入口等待队列</strong>。当多个线程同时竞争锁时，未能获取锁的线程会被封装成 <code>ObjectWaiter</code> 节点，放入此队列中，并进入**阻塞（Blocked）**状态，等待被唤醒。</li>
<li><code>_WaitSet</code>: 一个<strong>条件等待队列</strong>。当持有锁的线程调用了对象的 <code>wait()</code> 方法后，该线程会释放锁，并进入此队列中，进入**等待（Waiting）**状态，等待其他线程调用 <code>notify()</code> 或 <code>notifyAll()</code> 来唤醒。</li>
<li><code>_recursions</code>: 一个重入计数器。如果一个线程已经持有了锁，它再次尝试获取同一个锁时（即锁重入），<code>_recursions</code> 计数器会加1。每次退出一个同步块，计数器减1。当计数器减为0时，该线程才真正释放锁。这保证了 <code>synchronized</code> 的<strong>可重入性</strong>。</li>
</ul>
<hr>
<p><strong>底层指令的体现：<code>monitorenter</code> 与 <code>monitorexit</code></strong></p>
<p>Java 编译器会将 <code>synchronized</code> 关键字转化为特定的字节码指令，嵌入到方法的字节码中。其实现方式根据 <code>synchronized</code> 修饰的是代码块还是方法而有所不同：</p>
<ul>
<li><strong>同步代码块</strong>:<br>编译器会在同步代码块的开始处插入 <code>monitorenter</code> 指令，在结束处插入 <code>monitorexit</code> 指令。为了保证即使在同步代码块中发生异常，锁也能被正确释放，编译器会巧妙地生成一个 <code>try-finally</code> 结构。<code>monitorexit</code> 指令会被放在 <code>finally</code> 块中，确保无论代码是正常执行完毕还是异常退出，<code>monitorexit</code> 都会被执行。<ul>
<li><code>monitorenter</code>: 当线程执行到此时，会尝试获取对象所关联的 <code>ObjectMonitor</code> 的所有权。</li>
<li><code>monitorexit</code>: 线程执行完毕，释放 <code>ObjectMonitor</code> 的所有权，并将 <code>_owner</code> 置为 <code>null</code>，以便其他线程可以获取。</li>
</ul>
</li>
<li><strong>同步方法</strong>:<br>对于同步方法，JVM 采用了一种更高效的方式。它不会在字节码中插入 <code>monitorenter</code>&#x2F;<code>monitorexit</code> 指令，而是在方法的元数据中设置一个 <code>ACC_SYNCHRONIZED</code> 访问标志。当 JVM 执行到一个带有此标志的方法时，它会<strong>隐式地</strong>在方法调用前获取 Monitor，在方法返回（正常或异常）前释放Monitor。</li>
</ul>
<hr>
<p><strong>锁状态的载体：Java 对象头与 Mark Word</strong></p>
<p>锁升级的所有秘密都隐藏在 <strong>Java 对象头（Object Header）</strong> 中。一个Java对象在内存中由三部分组成：对象头、实例数据和对齐填充。对象头本身又包含两部分：</p>
<ol>
<li><strong>Mark Word</strong>: 这是锁升级机制的核心。它是一个非固定的数据结构，在 64 位 JVM 中占 8 个字节（64 位）。它的比特位会被复用，根据对象的锁状态存储不同的信息，如哈希码、GC分代年龄、线程ID、锁记录指针等。</li>
<li><strong>Klass Pointer</strong>: 类型指针，指向该对象所属的类元数据。</li>
</ol>
<p><strong>Mark Word 在不同锁状态下的结构（以64位JVM为例）：</strong></p>
<table>
<thead>
<tr>
<th align="left">锁状态</th>
<th align="left">标志位</th>
<th align="left">存储内容 (低位 -&gt; 高位)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>无锁</strong></td>
<td align="left"><code>01</code></td>
<td align="left">[未使用:25] [identity_hashcode:31] [GC年龄:4] [0] [<strong>01</strong>]</td>
</tr>
<tr>
<td align="left"><strong>偏向锁</strong></td>
<td align="left"><code>101</code></td>
<td align="left">[持有锁的线程ID:54] [Epoch:2] [GC年龄:4] [1] [<strong>01</strong>]</td>
</tr>
<tr>
<td align="left"><strong>轻量级锁</strong></td>
<td align="left"><code>00</code></td>
<td align="left">[指向线程栈中锁记录的指针:62] [<strong>00</strong>]</td>
</tr>
<tr>
<td align="left"><strong>重量级锁</strong></td>
<td align="left"><code>10</code></td>
<td align="left">[指向重量级Monitor的指针:62] [<strong>10</strong>]</td>
</tr>
</tbody></table>
<hr>
<p><strong>锁升级</strong></p>
<p>正是因为直接使用 <code>ObjectMonitor</code>（即重量级锁）涉及线程阻塞和操作系统介入，开销巨大。从 JDK 1.6 开始，<code>synchronized</code> 引入了智能的锁升级机制，以适应不同的竞争场景。<strong>这个过程通常是单向的，一旦升级就不能降级。</strong></p>
<ol>
<li><strong>无锁状态 (No Lock)</strong><br>对象被创建时，默认处于无锁状态。Mark Word 的锁标志位为 <code>01</code>，且偏向锁标志位为 <code>0</code>。</li>
<li><strong>偏向锁 (Biased Locking)</strong><ul>
<li><strong>动机</strong>：绝大多数情况下，锁不仅不存在竞争，而且总是由同一个线程反复获取。在这种场景下，连轻量级锁的 CAS 操作都是多余的。</li>
<li><strong>工作原理</strong>：<ol>
<li><strong>加锁</strong>：当线程A第一次进入同步块时，JVM 使用 CAS 操作，尝试将<strong>线程A的ID</strong>写入 Mark Word，并将偏向锁标志位置为 <code>1</code>。</li>
<li><strong>重入</strong>：之后，线程A再次进入该同步块时，它只需检查 Mark Word 中记录的线程ID是否是自己。如果是，它就<strong>无需任何同步操作</strong>，直接进入代码执行。这是偏向锁性能最高的原因。</li>
</ol>
</li>
<li><strong>撤销与升级 (Revocation)</strong>：这是偏向锁最复杂的部分。当有<strong>另一个线程B</strong>尝试获取这个锁时，偏向锁模式结束。JVM 会暂停持有偏向锁的线程A，检查其状态：<ul>
<li>如果线程A已退出同步块，则将对象头恢复为无锁状态或重新偏向给线程B。</li>
<li>如果线程A仍在同步块中，锁会<strong>升级为轻量级锁</strong>。对象头的 Mark Word 会被修改为指向线程A栈帧中的锁记录，然后线程B开始以自旋方式尝试获取锁。</li>
</ul>
</li>
<li><strong>注意</strong>：偏向锁的撤销需要等待全局安全点（Safepoint），在高并发场景下可能成为性能瓶颈，因此在 JDK 15 中已被默认禁用。</li>
</ul>
</li>
<li><strong>轻量级锁 (Lightweight Locking)</strong><ul>
<li><strong>动机</strong>：当偏向锁被撤销后，JVM 认为存在竞争，但它乐观地认为这种竞争是<strong>短暂且交替</strong>的（即线程A刚释放，线程B就来获取）。为了避免线程阻塞带来的巨大开销，引入了轻量级锁。</li>
<li><strong>工作原理</strong>：<ol>
<li><strong>加锁</strong>：在进入同步块时，JVM 会在当前线程的栈帧中创建一个<strong>锁记录（Lock Record）</strong>。然后，它使用 <strong>CAS（Compare-And-Swap）</strong> 原子操作，尝试将对象的 Mark Word 更新为指向这个锁记录的指针。</li>
<li><strong>成功</strong>：如果 CAS 成功，线程获得锁。</li>
<li><strong>失败（自旋）</strong>：如果 CAS 失败，表示锁已被其他线程持有。当前线程并<strong>不会立即阻塞</strong>，而是会进入**自旋（Spinning）**状态——执行一个忙等待循环，不断重试 CAS 操作。它期望持有锁的线程能很快释放锁。</li>
</ol>
</li>
<li><strong>升级</strong>：自旋并非无限的。如果一个线程自旋了一定次数后（这个次数是<strong>自适应</strong>的，JVM会根据历史成功率动态调整）仍未成功，或者自旋的线程过多，JVM 就会认为竞争已经变得激烈。此时，轻量级锁就会<strong>膨胀（Inflate）为重量级锁</strong>。</li>
</ul>
</li>
<li><strong>重量级锁 (Heavyweight Locking)</strong><ul>
<li><strong>动机</strong>：能够处理长时间、高强度的锁竞争。</li>
<li><strong>工作原理</strong>：<ol>
<li><strong>膨胀</strong>：锁升级为重量级锁后，对象的 Mark Word 会被修改为指向与之关联的<strong>重量级Monitor</strong>（即我们第一部分讲的 <code>ObjectMonitor</code>）。</li>
<li><strong>阻塞</strong>：所有后续尝试获取该锁但失败的线程，将不再自旋消耗CPU，而是会被直接<strong>阻塞</strong>，并放入 Monitor 的 <code>_EntryList</code> 队列中，等待持有锁的线程释放锁后，由操作系统调度唤醒。</li>
<li>这个过程完全回到了传统的基于 Monitor 和操作系统互斥量（Mutex）的锁机制，虽然性能开销大，但能保证在任何高并发场景下的公平性和正确性。</li>
</ol>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-2-2-volatile：轻量级的同步机制"><a href="#2-2-2-volatile：轻量级的同步机制" class="headerlink" title="2.2.2 volatile：轻量级的同步机制"></a>2.2.2 <code>volatile</code>：轻量级的同步机制</h4><p><code>volatile</code> 是一个变量修饰符。与 <code>synchronized</code> 相比，它更轻量级，因为它不会导致线程上下文切换和调度。</p>
<h5 id="1-核心作用-1"><a href="#1-核心作用-1" class="headerlink" title="1. 核心作用"></a>1. 核心作用</h5><p><code>volatile</code> 提供了两大核心保证，但<strong>不保证原子性</strong>。</p>
<ol>
<li><strong>可见性 (Visibility)</strong>：这是 <code>volatile</code> 最主要的作用。根据JMM的 <code>volatile</code> 变量规则：<ul>
<li><strong>写操作</strong>：当一个线程对 <code>volatile</code> 变量进行写操作时，JMM会立即将该线程工作内存中的新值刷新到主内存中。</li>
<li><strong>读操作</strong>：当一个线程对 <code>volatile</code> 变量进行读操作时，JMM会使该线程的工作内存中的副本失效，强制从主内存中重新读取最新值。</li>
</ul>
</li>
<li><strong>有序性 (Ordering)</strong>：<code>volatile</code> 可以禁止<strong>指令重排序</strong>优化，从而在一定程度上保证有序性。<ul>
<li>当程序执行到 <code>volatile</code> 变量的读或写操作时，其前面的所有普通读写操作都已经执行完成，且结果对后续操作可见；其后面的所有普通读写操作都还没有执行。</li>
<li>简单来说，<code>volatile</code> 像一个屏障，它前面的指令不能跑到它后面，它后面的指令不能跑到它前面。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="2-底层实现原理：内存屏障"><a href="#2-底层实现原理：内存屏障" class="headerlink" title="2. 底层实现原理：内存屏障"></a>2. 底层实现原理：内存屏障</h5><p><code>volatile</code> 的底层实现主要依赖于 <strong>内存屏障（Memory Barriers &#x2F; Memory Fences）</strong>。</p>
<ul>
<li><strong>内存屏障</strong>: 是一种CPU指令，它有两个作用：<ol>
<li>确保特定操作的执行顺序，防止编译器和处理器为了性能优化而对指令进行重排序。</li>
<li>强制将对缓存的修改操作立即写入主内存，并使其他CPU核心的缓存失效。</li>
</ol>
</li>
<li><strong>JVM的实现</strong>: 当JVM遇到 <code>volatile</code> 关键字时，它会在生成的字节码中，围绕 <code>volatile</code> 变量的读写操作插入特定的内存屏障指令：<ul>
<li><strong>在每个<code>volatile</code>写操作前</strong>，插入一个<code>StoreStore</code>屏障，确保前面的普通写操作对所有处理器可见。</li>
<li><strong>在每个<code>volatile</code>写操作后</strong>，插入一个<code>StoreLoad</code>屏障，避免 <code>volatile</code> 写与后面可能有的 <code>volatile</code> 读&#x2F;写操作重排序。</li>
<li><strong>在每个<code>volatile</code>读操作后</strong>，插入一个<code>LoadLoad</code>屏障和一个<code>LoadStore</code>屏障，确保 <code>volatile</code> 读与后面的普通读&#x2F;写操作不会重排序。</li>
</ul>
</li>
</ul>
<p><strong>经典案例：双重检查锁定（DCL）的单例模式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 必须使用 volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第二次检查</span></span><br><span class="line">                    <span class="comment">// new Singleton() 不是原子操作</span></span><br><span class="line">                    <span class="comment">// 1. 分配内存空间</span></span><br><span class="line">                    <span class="comment">// 2. 初始化对象</span></span><br><span class="line">                    <span class="comment">// 3. 将 instance 引用指向分配的内存地址</span></span><br><span class="line">                    <span class="comment">// 如果没有 volatile，2和3可能重排序，导致其他线程拿到一个未完全初始化的对象</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>volatile</code> 就是为了禁止 <code>instance = new Singleton()</code> 这步操作中的指令重排序。</p>
<hr>
<h4 id="2-2-3-对比"><a href="#2-2-3-对比" class="headerlink" title="2.2.3 对比"></a>2.2.3 对比</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>synchronized</code></th>
<th align="left"><code>volatile</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>原子性</strong></td>
<td align="left"><strong>保证</strong></td>
<td align="left"><strong>不保证</strong> (仅保证单次读&#x2F;写的原子性)</td>
</tr>
<tr>
<td align="left"><strong>可见性</strong></td>
<td align="left"><strong>保证</strong></td>
<td align="left"><strong>保证</strong></td>
</tr>
<tr>
<td align="left"><strong>有序性</strong></td>
<td align="left"><strong>保证</strong> (通过串行执行保证)</td>
<td align="left"><strong>保证</strong> (通过内存屏障禁止重排序)</td>
</tr>
<tr>
<td align="left"><strong>使用范围</strong></td>
<td align="left">方法、代码块</td>
<td align="left">成员变量</td>
</tr>
<tr>
<td align="left"><strong>底层实现</strong></td>
<td align="left">对象监视器(Monitor)、锁升级</td>
<td align="left">内存屏障</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">重量级，可能引起线程阻塞和上下文切换</td>
<td align="left">轻量级，不会引起线程阻塞</td>
</tr>
<tr>
<td align="left"><strong>是否阻塞</strong></td>
<td align="left"><strong>会</strong></td>
<td align="left"><strong>不会</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="3-锁的深入剖析与-J-U-C"><a href="#3-锁的深入剖析与-J-U-C" class="headerlink" title="3. 锁的深入剖析与 J.U.C"></a>3. <strong>锁的深入剖析与 J.U.C</strong></h2><h3 id="3-1-锁的分类与概念"><a href="#3-1-锁的分类与概念" class="headerlink" title="3.1 锁的分类与概念"></a>3.1 锁的分类与概念</h3><p>为了应对不同的并发场景、优化性能，锁被设计出了多种类型和特性。</p>
<h4 id="3-1-1-乐观锁-Optimistic-Lock-vs-悲观锁-Pessimistic-Lock"><a href="#3-1-1-乐观锁-Optimistic-Lock-vs-悲观锁-Pessimistic-Lock" class="headerlink" title="3.1.1 乐观锁 (Optimistic Lock) vs. 悲观锁 (Pessimistic Lock)"></a>3.1.1 乐观锁 (Optimistic Lock) vs. 悲观锁 (Pessimistic Lock)</h4><p>这是从<strong>对并发冲突的态度</strong>角度进行的划分，是两种最基本的设计思想。</p>
<h5 id="1-悲观锁-Pessimistic-Lock"><a href="#1-悲观锁-Pessimistic-Lock" class="headerlink" title="1. 悲观锁 (Pessimistic Lock)"></a>1. 悲观锁 (Pessimistic Lock)</h5><ul>
<li><strong>概念</strong>: 总是假设最坏的情况，认为数据在被访问时总会发生并发冲突。因此，在每次对数据进行操作之前，都会先<strong>加锁</strong>，确保在自己操作数据的整个过程中，其他线程无法进行修改，操作完成后再<strong>解锁</strong>。</li>
<li><strong>实现方式</strong>: Java 中的 <code>synchronized</code> 关键字和 <code>java.util.concurrent.locks.Lock</code> 接口的所有实现类（如 <code>ReentrantLock</code>）都是典型的悲观锁。</li>
<li><strong>优点</strong>: 实现简单，数据一致性强，适用于<strong>写多读少</strong>、<strong>并发冲突激烈</strong>的场景。</li>
<li><strong>缺点</strong>: 无论是否存在竞争，都会进行加锁和解锁操作，这会带来额外的开销，尤其是在低竞争环境下，会降低系统吞吐量。线程阻塞和唤醒涉及上下文切换，成本较高。</li>
</ul>
<hr>
<h5 id="2-乐观锁-Optimistic-Lock"><a href="#2-乐观锁-Optimistic-Lock" class="headerlink" title="2. 乐观锁 (Optimistic Lock)"></a>2. 乐观锁 (Optimistic Lock)</h5><ul>
<li><strong>概念</strong>: 总是假设最好的情况，认为数据在被访问时不会发生并发冲突。因此，它<strong>不会加锁</strong>，而是在<strong>更新数据时</strong>去判断，在此期间是否有其他线程修改了数据。</li>
<li><strong>实现方式</strong>: 通常通过 <strong>CAS (Compare-And-Swap) 机制</strong>实现。CAS 操作包含三个操作数：内存位置（V）、预期原值（A）和新值（B）。当且仅当内存位置 V 的值与预期原值 A 相同时，处理器才会原子地将该位置的值更新为新值 B。否则，不做任何操作。</li>
<li><strong>实现举例</strong>: J.U.C 包中的原子类（如 <code>AtomicInteger</code>）就是通过 CAS 实现的乐观锁。</li>
<li><strong>优点</strong>: 避免了线程阻塞和唤醒的开销，在<strong>读多写少</strong>、<strong>并发冲突不激烈</strong>的场景下，性能远超悲观锁。</li>
<li><strong>缺点</strong>: 如果并发冲突频繁（写操作多），会导致 CAS 操作不断失败并重试（自旋），这会<strong>消耗大量的 CPU 资源</strong>。此外，CAS 只能保证单个共享变量的原子操作，对于多个变量的原子性保证比较复杂（可以使用 <code>AtomicReference</code> 解决）。</li>
</ul>
<hr>
<h5 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><p><strong>场景设定</strong></p>
<p>我们以一个经典的“银行账户取款”场景为例。假设一个账户初始有 1000 元，两个线程（比如两个人 A 和 B）同时从中各取 800 元。</p>
<ul>
<li><strong>正确结果</strong>：一个人取款成功，账户余额变为 200 元；另一个人取款失败，因为余额不足。</li>
<li><strong>错误结果（无锁）</strong>：A 读取余额 1000，B 也读取余额 1000。A 计算新余额 200，B 也计算新余额 200。A 写入 200，B 也写入 200。最终账户余额为 200，但实际上取走了 1600，导致数据不一致（“丢掉的更新”问题）。</li>
</ul>
<p><strong>悲观锁实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 悲观锁示例</span></span><br><span class="line"><span class="comment"> * 使用 synchronized 关键字实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PessimisticAccount</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PessimisticAccount</span><span class="params">(<span class="type">int</span> initialBalance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = initialBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 synchronized 关键字对整个方法加锁</span></span><br><span class="line">    <span class="comment">// 任何线程在执行此方法前，必须先获得该对象的锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="comment">// 打印当前线程尝试取款的信息</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;线程 %s 尝试取款 %d, 当前余额: %d\n&quot;</span>, Thread.currentThread().getName(), amount, <span class="built_in">this</span>.balance);</span><br><span class="line">        <span class="comment">// 检查余额是否足够</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt;= amount) &#123;</span><br><span class="line">            <span class="comment">// 模拟一些业务处理耗时</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 扣除金额并打印成功信息</span></span><br><span class="line">            <span class="built_in">this</span>.balance -= amount;</span><br><span class="line">            System.out.printf(<span class="string">&quot;线程 %s 取款成功, 剩余余额: %d\n&quot;</span>, Thread.currentThread().getName(), <span class="built_in">this</span>.balance);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 打印失败信息</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;线程 %s 取款失败, 余额不足, 剩余余额: %d\n&quot;</span>, Thread.currentThread().getName(), <span class="built_in">this</span>.balance);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前余额</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 悲观锁演示类</span></span><br><span class="line"><span class="comment"> * 展示了在多线程环境下如何使用悲观锁机制保证数据一致性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PessimisticLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个初始余额为1000的账户</span></span><br><span class="line">        <span class="type">PessimisticAccount</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PessimisticAccount</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 创建一个包含2个线程的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义取款任务：每个线程尝试取款800</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; account.withdraw(<span class="number">800</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交两个取款任务到线程池</span></span><br><span class="line">        executor.submit(task);</span><br><span class="line">        executor.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池并等待所有任务完成</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        executor.awaitTermination(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印最终账户余额</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n最终账户余额: &quot;</span> + account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">1</span> 尝试取款 <span class="number">800</span>, 当前余额: <span class="number">1000</span></span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">1</span> 取款成功, 剩余余额: <span class="number">200</span></span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 尝试取款 <span class="number">800</span>, 当前余额: <span class="number">200</span></span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 取款失败, 余额不足, 剩余余额: <span class="number">200</span></span><br><span class="line"></span><br><span class="line">最终账户余额: <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p><strong>乐观锁实现</strong></p>
<p>这里我们模拟数据库中常用的版本号（version）机制。每次更新数据时，版本号加一。更新前，检查当前版本号是否与自己之前读取的一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 乐观锁示例</span></span><br><span class="line"><span class="comment"> * 使用 &quot;版本号&quot; 机制，版本号本身用原子类 AtomicInteger 保证线程安全</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OptimisticAccount</span> &#123;</span><br><span class="line">    <span class="comment">// 账户余额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">    <span class="comment">// 使用原子类作为版本号，保证版本号自身的原子性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">version</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，初始化账户余额</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialBalance 初始余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OptimisticAccount</span><span class="params">(<span class="type">int</span> initialBalance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = initialBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 乐观锁取款操作</span></span><br><span class="line"><span class="comment">     * 通过版本号机制实现线程安全的取款操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> amount 取款金额</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 取款是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;线程 %s 准备取款 %d...\n&quot;</span>, Thread.currentThread().getName(), amount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用自旋（spin）的方式不断重试</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 读取当前余额和版本号 (Read)</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">currentBalance</span> <span class="operator">=</span> <span class="built_in">this</span>.balance;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentVersion</span> <span class="operator">=</span> <span class="built_in">this</span>.version.get();</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">&quot;线程 %s 读取数据 - 余额: %d, 版本: %d\n&quot;</span>, Thread.currentThread().getName(), currentBalance, currentVersion);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查余额是否足够</span></span><br><span class="line">            <span class="keyword">if</span> (currentBalance &lt; amount) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;线程 %s 发现余额不足, 退出操作\n&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟业务计算耗时</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 尝试更新 (Compare And Swap)</span></span><br><span class="line">            <span class="comment">// 比较版本号是否被其他线程修改过</span></span><br><span class="line">            <span class="comment">// 如果 version.compareAndSet 成功，说明从读取到准备更新的期间，数据没有被其他线程动过</span></span><br><span class="line">            <span class="keyword">if</span> (version.compareAndSet(currentVersion, currentVersion + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 版本号未变，可以安全地更新余额</span></span><br><span class="line">                <span class="built_in">this</span>.balance = currentBalance - amount;</span><br><span class="line">                System.out.printf(<span class="string">&quot;线程 %s 取款成功! 余额: %d, 版本更新为: %d\n&quot;</span>, Thread.currentThread().getName(), <span class="built_in">this</span>.balance, <span class="built_in">this</span>.version.get());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 版本号变了，说明数据已经被其他线程修改，本次操作失败，进行重试</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;线程 %s 操作失败, 数据已被修改 (版本从 %d 变为 %d), 进行重试...\n&quot;</span>,</span><br><span class="line">                        Thread.currentThread().getName(), currentVersion, <span class="built_in">this</span>.version.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前账户余额</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 乐观锁演示类</span></span><br><span class="line"><span class="comment"> * 展示了在多线程环境下如何使用乐观锁机制保证数据一致性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptimisticLockDemo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主函数，启动两个线程同时进行取款操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 命令行参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException 线程中断异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建账户，初始余额1000</span></span><br><span class="line">        <span class="type">OptimisticAccount</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptimisticAccount</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 创建固定大小为2的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两个线程同时取款 800</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; account.withdraw(<span class="number">800</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交两个取款任务</span></span><br><span class="line">        executor.submit(task);</span><br><span class="line">        executor.submit(task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池并等待所有任务完成</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        executor.awaitTermination(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最终账户余额</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n最终账户余额: &quot;</span> + account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">1</span> 准备取款 <span class="number">800.</span>..</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">1</span> 读取数据 - 余额: <span class="number">1000</span>, 版本: <span class="number">0</span></span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 准备取款 <span class="number">800.</span>..</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 读取数据 - 余额: <span class="number">1000</span>, 版本: <span class="number">0</span></span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">1</span> 取款成功! 余额: <span class="number">200</span>, 版本更新为: <span class="number">1</span></span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 操作失败, 数据已被修改 (版本从 <span class="number">0</span> 变为 <span class="number">1</span>), 进行重试...</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 读取数据 - 余额: <span class="number">200</span>, 版本: <span class="number">1</span></span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 发现余额不足, 退出操作</span><br><span class="line"></span><br><span class="line">最终账户余额: <span class="number">200</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">悲观锁 (<code>synchronized</code>)</th>
<th align="left">乐观锁 (CAS + 版本号)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心思想</strong></td>
<td align="left">假定会发生冲突，先加锁再操作</td>
<td align="left">假定不发生冲突，操作时不加锁，提交时验证</td>
</tr>
<tr>
<td align="left"><strong>数据一致性</strong></td>
<td align="left">强一致性，通过阻塞其他线程来保证</td>
<td align="left">最终一致性，通过重试机制来保证</td>
</tr>
<tr>
<td align="left"><strong>性能开销</strong></td>
<td align="left">线程阻塞和唤醒的开销较大，尤其是在低冲突环境下</td>
<td align="left">在低冲突环境下，无锁操作性能很高；但在高冲突环境下，反复重试会消耗大量 CPU</td>
</tr>
<tr>
<td align="left"><strong>死锁风险</strong></td>
<td align="left">有可能产生死锁（例如，多个锁嵌套）</td>
<td align="left">一般不会产生死锁</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left"><strong>写多读少</strong>的场景。冲突频繁，加锁的成本相对较低。</td>
<td align="left"><strong>读多写少</strong>的场景。冲突较少，可以避免加锁带来的性能损耗。</td>
</tr>
</tbody></table>
<hr>
<h4 id="3-1-2-公平锁-Fair-Lock-vs-非公平锁-Unfair-Lock"><a href="#3-1-2-公平锁-Fair-Lock-vs-非公平锁-Unfair-Lock" class="headerlink" title="3.1.2 公平锁 (Fair Lock) vs. 非公平锁 (Unfair Lock)"></a>3.1.2 公平锁 (Fair Lock) vs. 非公平锁 (Unfair Lock)</h4><p>这是从<strong>线程获取锁的排队策略</strong>角度进行的划分。</p>
<h5 id="1-公平锁-Fair-Lock"><a href="#1-公平锁-Fair-Lock" class="headerlink" title="1. 公平锁 (Fair Lock)"></a>1. 公平锁 (Fair Lock)</h5><ul>
<li><strong>概念</strong>: 遵循<strong>先来后到 (FIFO)</strong> 的原则。多个线程请求锁时，会进入一个等待队列，等待时间最长的线程会优先获得锁。</li>
<li><strong>实现方式</strong>: <code>ReentrantLock</code> 可以通过构造函数 <code>new ReentrantLock(true)</code> 创建公平锁。</li>
<li><strong>优点</strong>: 所有线程都能获得执行机会，可以<strong>避免线程饥饿</strong>。</li>
<li><strong>缺点</strong>: 需要维护一个等待队列，并进行复杂的调度，导致上下文切换频繁，系统<strong>吞吐量较低</strong>。</li>
</ul>
<hr>
<h5 id="2-非公平锁-Unfair-Lock"><a href="#2-非公平锁-Unfair-Lock" class="headerlink" title="2. 非公平锁 (Unfair Lock)"></a>2. 非公平锁 (Unfair Lock)</h5><ul>
<li><strong>概念</strong>: 不遵循先来后到原则，允许“插队”。当一个线程请求锁时，如果恰好锁是可用的，它会直接尝试获取锁，而不管等待队列中是否有其他线程在等待。</li>
<li><strong>实现方式</strong>: <code>synchronized</code> 就是一种非公平锁。<code>ReentrantLock</code> 默认也是非公平锁 (<code>new ReentrantLock()</code>)。</li>
<li><strong>优点</strong>: 减少了线程挂起和唤醒的开销。如果一个线程刚释放锁，恰好它又需要再次获取，它可以立即获得，<strong>减少了上下文切换，提高了系统吞吐量</strong>。</li>
<li><strong>缺点</strong>: 可能会导致等待队列中的线程长时间无法获取锁，造成<strong>线程饥饿</strong>。</li>
</ul>
<blockquote>
<p><strong>为什么非公平锁性能更高？</strong></p>
<p>因为它减少了CPU进行线程上下文切换的次数。当线程A释放锁后，如果线程A马上又要获取锁，它可以立即获取，无需唤醒队列中的线程B。而公平锁则必须先将线程A挂起，再唤醒线程B，这个过程开销很大。</p>
</blockquote>
<hr>
<h5 id="3-代码示例-1"><a href="#3-代码示例-1" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁的公平性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FairnessLockDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 程序入口点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 命令行参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException 当线程被中断时抛出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 演示公平锁：线程将按照请求锁的顺序获得锁</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--- Fair Lock Demo ---&quot;</span>);</span><br><span class="line">        runDemo(<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>)); <span class="comment">// 构造函数传入 true 创建公平锁</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- Non-Fair Lock Demo ---&quot;</span>);</span><br><span class="line">        runDemo(<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>)); <span class="comment">// 构造函数传入 false 或不传参数，创建非公平锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行一个演示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lock 要使用的锁（公平或非公平）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException 当线程被中断时抛出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runDemo</span><span class="params">(Lock lock)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建5个线程去竞争同一个锁</span></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Job</span>(lock), <span class="string">&quot;Thread-&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次启动线程</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一个简单的任务，它会循环两次获取和释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Job</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Lock lock;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造函数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> lock 要使用的锁</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Job</span><span class="params">(Lock lock)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程执行的任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 每个线程循环2次，以便观察锁的分配模式</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 标准的锁使用模式：在try-finally块中加锁和解锁</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">                    System.out.printf(<span class="string">&quot;线程 [%s] 获得了锁 (第 %d 次)\n&quot;</span>, threadName, i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 模拟工作耗时</span></span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 处理中断异常</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 确保锁最终会被释放</span></span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--- Fair Lock Demo ---</span><br><span class="line">线程 [Thread-<span class="number">0</span>] 获得了锁 (第 <span class="number">1</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">1</span>] 获得了锁 (第 <span class="number">1</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">2</span>] 获得了锁 (第 <span class="number">1</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">3</span>] 获得了锁 (第 <span class="number">1</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">4</span>] 获得了锁 (第 <span class="number">1</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">0</span>] 获得了锁 (第 <span class="number">2</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">1</span>] 获得了锁 (第 <span class="number">2</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">2</span>] 获得了锁 (第 <span class="number">2</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">3</span>] 获得了锁 (第 <span class="number">2</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">4</span>] 获得了锁 (第 <span class="number">2</span> 次)</span><br><span class="line"></span><br><span class="line">--- Non-Fair Lock Demo ---</span><br><span class="line">线程 [Thread-<span class="number">0</span>] 获得了锁 (第 <span class="number">1</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">0</span>] 获得了锁 (第 <span class="number">2</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">1</span>] 获得了锁 (第 <span class="number">1</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">2</span>] 获得了锁 (第 <span class="number">1</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">2</span>] 获得了锁 (第 <span class="number">2</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">4</span>] 获得了锁 (第 <span class="number">1</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">4</span>] 获得了锁 (第 <span class="number">2</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">3</span>] 获得了锁 (第 <span class="number">1</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">3</span>] 获得了锁 (第 <span class="number">2</span> 次)</span><br><span class="line">线程 [Thread-<span class="number">1</span>] 获得了锁 (第 <span class="number">2</span> 次)</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-总结-1"><a href="#4-总结-1" class="headerlink" title="4. 总结"></a>4. 总结</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">公平锁 (<code>ReentrantLock(true)</code>)</th>
<th align="left">非公平锁 (<code>ReentrantLock(false)</code>, <code>synchronized</code>)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>获取顺序</strong></td>
<td align="left">先来后到 (FIFO)</td>
<td align="left">抢占式，无固定顺序</td>
</tr>
<tr>
<td align="left"><strong>线程饥饿</strong></td>
<td align="left">不会发生</td>
<td align="left">可能发生</td>
</tr>
<tr>
<td align="left"><strong>吞吐量</strong></td>
<td align="left">较低</td>
<td align="left">较高（因为减少了上下文切换）</td>
</tr>
<tr>
<td align="left"><strong>实现</strong></td>
<td align="left"><code>new ReentrantLock(true)</code></td>
<td align="left"><code>new ReentrantLock()</code> 或 <code>synchronized</code></td>
</tr>
</tbody></table>
<hr>
<h4 id="3-1-3-独占锁-Exclusive-Lock-vs-共享锁-Shared-Lock"><a href="#3-1-3-独占锁-Exclusive-Lock-vs-共享锁-Shared-Lock" class="headerlink" title="3.1.3 独占锁 (Exclusive Lock) vs. 共享锁 (Shared Lock)"></a>3.1.3 独占锁 (Exclusive Lock) vs. 共享锁 (Shared Lock)</h4><p>这是从<strong>锁的并发访问模式</strong>角度进行的划分。</p>
<h5 id="1-独占锁-Exclusive-Lock"><a href="#1-独占锁-Exclusive-Lock" class="headerlink" title="1. 独占锁 (Exclusive Lock)"></a>1. 独占锁 (Exclusive Lock)</h5><ul>
<li><strong>概念</strong>: 该锁一次只能被一个线程所持有。如果一个线程获取了独占锁，其他任何线程（无论是读还是写）都必须等待，直到该锁被释放。</li>
<li><strong>实现方式</strong>: <code>synchronized</code> 和 <code>ReentrantLock</code> 都是独占锁。</li>
</ul>
<hr>
<h5 id="2-共享锁-Shared-Lock"><a href="#2-共享锁-Shared-Lock" class="headerlink" title="2. 共享锁 (Shared Lock)"></a>2. 共享锁 (Shared Lock)</h5><ul>
<li><strong>概念</strong>: 该锁可以被多个线程同时持有。它通常区分读写操作，允许多个线程同时进行读操作，但只允许一个线程进行写操作，且写操作会阻塞所有的读写。也称为<strong>读写锁 (Read-Write Lock)</strong>。</li>
<li><strong>实现方式</strong>: <code>ReentrantReadWriteLock</code> 是典型的共享锁实现。</li>
<li><strong>优点</strong>: 在<strong>读多写少</strong>的场景下，可以极大地提高程序的并发能力和吞吐量。</li>
</ul>
<hr>
<h5 id="3-代码示例-2"><a href="#3-代码示例-2" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><p><strong>场景设定</strong></p>
<p>我们来模拟一个<strong>缓存系统</strong>的场景：</p>
<ul>
<li><strong>读取缓存 (get)</strong>：这是一个读操作，应该是并发的，允许多个线程同时进行。</li>
<li><strong>写入&#x2F;更新缓存 (put)</strong>：这是一个写操作，必须是独占的，写入时不允许任何其他读或写操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 ReentrantReadWriteLock 实现的简单缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedDataCache</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存数据存储结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 创建一个可重入的读写锁，用于控制并发访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">// 从读写锁中分离出读锁（共享锁），允许多个线程同时读取</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> rwLock.readLock();</span><br><span class="line">    <span class="comment">// 从读写锁中分离出写锁（独占锁），确保写操作的独占性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> rwLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取缓存 - 使用共享锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取读锁，允许多个线程同时读取</span></span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            System.out.printf(<span class="string">&quot;线程 [%s] 正在读取数据...\n&quot;</span>, threadName);</span><br><span class="line">            <span class="comment">// 模拟读取耗时，让并发效果更明显</span></span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">            System.out.printf(<span class="string">&quot;线程 [%s] 读取完成, 值为: %s\n&quot;</span>, threadName, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 处理线程中断异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 释放读锁，确保锁一定会被释放</span></span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入缓存 - 使用独占锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   缓存键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 缓存值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取写锁，确保写操作的独占性</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            System.out.printf(<span class="string">&quot;线程 [%s] 正在写入数据 (key=%s, value=%s)...\n&quot;</span>, threadName, key, value);</span><br><span class="line">            <span class="comment">// 模拟写入耗时，让并发效果更明显</span></span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            cache.put(key, value);</span><br><span class="line">            System.out.printf(<span class="string">&quot;线程 [%s] 写入完成.\n&quot;</span>, threadName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 处理线程中断异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 释放写锁，确保锁一定会被释放</span></span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharedExclusiveLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建共享数据缓存实例</span></span><br><span class="line">        <span class="type">SharedDataCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedDataCache</span>();</span><br><span class="line">        <span class="comment">// 创建固定大小的线程池，用于执行读写任务</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动一个写线程，向缓存中写入数据</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">writerTask</span> <span class="operator">=</span> () -&gt; cache.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        executor.submit(writerTask);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 稍微等待，让写线程先开始执行</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动多个读线程，从缓存中读取数据</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">readerTask</span> <span class="operator">=</span> () -&gt; cache.get(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        executor.submit(readerTask); <span class="comment">// Reader 1</span></span><br><span class="line">        executor.submit(readerTask); <span class="comment">// Reader 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再启动一个写线程，向缓存中写入另一条数据</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">writerTask2</span> <span class="operator">=</span> () -&gt; cache.put(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">        executor.submit(writerTask2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再启动两个读线程，从缓存中读取数据</span></span><br><span class="line">        executor.submit(readerTask); <span class="comment">// Reader 3</span></span><br><span class="line">        executor.submit(readerTask); <span class="comment">// Reader 4</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池，不再接受新任务</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="comment">// 等待所有任务执行完成，最多等待1分钟</span></span><br><span class="line">        executor.awaitTermination(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个写线程获取了独占锁，开始写入</span></span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">1</span>] 正在写入数据 (key=key1, value=value1)...</span><br><span class="line"><span class="comment">// Reader1 和 Reader2 尝试获取读锁，但因为写锁被占用，它们必须等待</span></span><br><span class="line"><span class="comment">// Writer2 尝试获取写锁，也必须等待</span></span><br><span class="line"><span class="comment">// 第一个写线程完成并释放锁</span></span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">1</span>] 写入完成.</span><br><span class="line"><span class="comment">// 写锁释放后，所有等待的读线程（Reader1, Reader2）可以同时获取读锁，并发执行</span></span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">2</span>] 正在读取数据...</span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">3</span>] 正在读取数据...</span><br><span class="line"><span class="comment">// 两个读线程几乎同时完成</span></span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">2</span>] 读取完成, 值为: value1</span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">3</span>] 读取完成, 值为: value1</span><br><span class="line"><span class="comment">// 所有读锁都释放后，等待的写线程（Writer2）才能获取独占锁</span></span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">4</span>] 正在写入数据 (key=key2, value=value2)...</span><br><span class="line"><span class="comment">// Reader3, Reader4 尝试获取读锁，但因为写锁被占用，它们必须等待</span></span><br><span class="line"><span class="comment">// 第二个写线程完成并释放锁</span></span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">4</span>] 写入完成.</span><br><span class="line"><span class="comment">// 写锁释放后，等待的读线程（Reader3, Reader4）可以同时获取读锁，并发执行</span></span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">5</span>] 正在读取数据...</span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">3</span>] 正在读取数据...  &lt;-- 注意这里可能是之前等待的线程复用</span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">5</span>] 读取完成, 值为: value1</span><br><span class="line">线程 [pool-<span class="number">1</span>-thread-<span class="number">3</span>] 读取完成, 值为: value1</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-总结-2"><a href="#4-总结-2" class="headerlink" title="4. 总结"></a>4. 总结</h5><table>
<thead>
<tr>
<th align="left">锁类型</th>
<th align="left">别名</th>
<th align="left">特性</th>
<th align="left">Java 实现</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>独占锁</strong></td>
<td align="left">写锁, 排他锁</td>
<td align="left">一次只能被一个线程持有。</td>
<td align="left"><code>ReentrantReadWriteLock.writeLock()</code></td>
<td align="left">数据修改操作，如 <code>update</code>, <code>delete</code>, <code>insert</code>。</td>
</tr>
<tr>
<td align="left"><strong>共享锁</strong></td>
<td align="left">读锁</td>
<td align="left">可以被多个线程同时持有。</td>
<td align="left"><code>ReentrantReadWriteLock.readLock()</code></td>
<td align="left">数据读取操作，如 <code>select</code>, <code>get</code>。</td>
</tr>
</tbody></table>
<hr>
<h4 id="3-1-4-可重入锁-Reentrant-Lock-vs-不可重入锁-Non-Reentrant-Lock"><a href="#3-1-4-可重入锁-Reentrant-Lock-vs-不可重入锁-Non-Reentrant-Lock" class="headerlink" title="3.1.4 可重入锁 (Reentrant Lock) vs. 不可重入锁 (Non-Reentrant Lock)"></a>3.1.4 可重入锁 (Reentrant Lock) vs. 不可重入锁 (Non-Reentrant Lock)</h4><p>这是从<strong>同一个线程对同一个锁的重复获取</strong>角度进行的划分。</p>
<h5 id="1-可重入锁-Reentrant-Lock"><a href="#1-可重入锁-Reentrant-Lock" class="headerlink" title="1. 可重入锁 (Reentrant Lock)"></a>1. 可重入锁 (Reentrant Lock)</h5><ul>
<li><strong>概念</strong>: 也称为<strong>递归锁</strong>。指同一个线程在外层方法获取了锁之后，在内层方法仍然可以再次自动获取该锁，而不会因为之前已经获取过锁而被自己阻塞。</li>
<li><strong>原理</strong>: 锁内部维护一个计数器和一个指向持有者线程的引用。当线程请求锁时，如果持有者是自己，则计数器加1；释放锁时，计数器减1。当计数器为0时，锁才被真正释放。</li>
<li><strong>实现方式</strong>: <code>synchronized</code> 和 <code>ReentrantLock</code> 都是可重入锁。</li>
<li><strong>优点</strong>: <strong>可以避免死锁</strong>。例如，在一个 <code>synchronized</code> 方法中调用了另一个 <code>synchronized</code> 方法，如果不是可重入锁，就会造成自己死锁。</li>
</ul>
<hr>
<h5 id="2-不可重入锁"><a href="#2-不可重入锁" class="headerlink" title="2. 不可重入锁"></a>2. 不可重入锁</h5><ul>
<li><strong>概念</strong>: 一个线程获取了锁之后，如果再次尝试获取该锁，就会被阻塞。</li>
<li><strong>缺点</strong>: 容易造成死锁。在现代并发编程中已很少使用。</li>
</ul>
<hr>
<h5 id="3-代码示例-3"><a href="#3-代码示例-3" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><p><strong>场景设定</strong></p>
<p>我们将创建一个场景：一个线程调用一个 <code>outer()</code> 方法，该方法会获取锁；在 <code>outer()</code> 方法内部，再调用一个 <code>inner()</code> 方法，该方法会<strong>尝试再次获取同一个锁</strong>。</p>
<ul>
<li><strong>对于可重入锁</strong>：<code>inner()</code> 方法会成功获取锁，程序正常执行完毕。</li>
<li><strong>对于不可重入锁</strong>：<code>inner()</code> 方法在尝试获取锁时会失败，导致线程永久等待，程序被挂起（死锁）。</li>
</ul>
<p><strong>不可重入锁的实现与演示</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的不可重入锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="comment">// 标记锁是否被持有</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isLocked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 记录持有锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Thread</span> <span class="variable">lockedBy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果锁已经被持有，则当前线程等待</span></span><br><span class="line">        <span class="keyword">while</span> (isLocked) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待，直到被唤醒</span></span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// 恢复中断状态</span></span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="comment">// 由于中断，提前退出</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 成功获得锁</span></span><br><span class="line">        isLocked = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 记录持有锁的线程</span></span><br><span class="line">        lockedBy = Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 只有持有锁的线程才能释放锁</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() == lockedBy) &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            isLocked = <span class="literal">false</span>;</span><br><span class="line">            lockedBy = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 唤醒一个正在等待的线程</span></span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 其他 Lock 接口的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123; </span><br><span class="line">        <span class="comment">// 可中断地获取锁，这里未实现完整逻辑</span></span><br><span class="line">        <span class="comment">/* ... */</span> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// 尝试非阻塞地获取锁，这里未实现完整逻辑</span></span><br><span class="line">        <span class="comment">/* ... */</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123; </span><br><span class="line">        <span class="comment">// 在给定时间内尝试获取锁，这里未实现完整逻辑</span></span><br><span class="line">        <span class="comment">/* ... */</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// 返回一个与该锁关联的条件变量，这里未实现完整逻辑</span></span><br><span class="line">        <span class="comment">/* ... */</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NonReentrantLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建不可重入锁实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NonReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入 outer() 方法&quot;</span>);</span><br><span class="line">            <span class="comment">// 在持有锁的情况下，调用 inner() 方法</span></span><br><span class="line">            inner();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试再次获取锁（对于不可重入锁，这会导致死锁）</span></span><br><span class="line">        lock.lock(); </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入 inner() 方法&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NonReentrantLockDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NonReentrantLockDemo</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;--- 不可重入锁演示 ---&quot;</span>);</span><br><span class="line">        <span class="comment">// 在一个新线程中运行，以防主线程被阻塞</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::outer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--- 不可重入锁演示 ---</span><br><span class="line">进入 outer() 方法</span><br></pre></td></tr></table></figure>

<p><strong>可重入锁的演示</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Java 标准库提供的可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外层方法，首先获取锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outer</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入 outer() 方法, lock count: &quot;</span> + ((ReentrantLock) lock).getHoldCount());</span><br><span class="line">            <span class="comment">// 在持有锁的情况下，调用 inner() 方法</span></span><br><span class="line">            inner();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot;离开 outer() 方法, lock count: &quot;</span> + ((ReentrantLock) lock).getHoldCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内层方法，演示可重入特性，可以再次获取已被当前线程持有的锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inner</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 再次获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入 inner() 方法, lock count: &quot;</span> + ((ReentrantLock) lock).getHoldCount());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot;离开 inner() 方法, lock count: &quot;</span> + ((ReentrantLock) lock).getHoldCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReentrantLockDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLockDemo</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;--- 可重入锁演示 ---&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建一个新线程来执行 outer() 方法，展示可重入锁的工作原理</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(demo::outer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--- 可重入锁演示 ---</span><br><span class="line">进入 outer() 方法, lock count: <span class="number">1</span></span><br><span class="line">进入 inner() 方法, lock count: <span class="number">2</span></span><br><span class="line">离开 inner() 方法, lock count: <span class="number">1</span></span><br><span class="line">离开 outer() 方法, lock count: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-总结-3"><a href="#4-总结-3" class="headerlink" title="4. 总结"></a>4. 总结</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">可重入锁 (<code>ReentrantLock</code>, <code>synchronized</code>)</th>
<th align="left">不可重入锁 (我们自己实现的)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心机制</strong></td>
<td align="left">记录锁的持有者和重入次数</td>
<td align="left">仅用一个布尔标记锁是否被占用</td>
</tr>
<tr>
<td align="left"><strong>嵌套调用</strong></td>
<td align="left">安全。同一个线程可以多次获取锁。</td>
<td align="left"><strong>危险</strong>。同一个线程再次获取锁会导致死锁。</td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td align="left">绝大多数并发场景。</td>
<td align="left">极少数特殊场景，或者作为教学示例来理解锁的原理。</td>
</tr>
<tr>
<td align="left"><strong>实现复杂度</strong></td>
<td align="left">较复杂，需要维护计数器和所有者。</td>
<td align="left">较简单，一个布尔值即可。</td>
</tr>
</tbody></table>
<hr>
<h4 id="3-1-5-自旋锁-Spin-Lock"><a href="#3-1-5-自旋锁-Spin-Lock" class="headerlink" title="3.1.5 自旋锁 (Spin Lock)"></a>3.1.5 自旋锁 (Spin Lock)</h4><p>这是一种<strong>等待锁释放时的策略</strong>，通常与互斥锁（阻塞锁）相对。</p>
<ul>
<li><strong>概念</strong>: 当一个线程尝试获取锁但失败时，它不会立即被挂起（进入阻塞状态），而是会执行一个<strong>忙循环（自旋）</strong>，不断地尝试获取锁。</li>
<li><strong>适用场景</strong>: 适用于锁被占用的时间<strong>非常短</strong>的场景。因为自旋避免了线程上下文切换的巨大开销。</li>
<li><strong>缺点</strong>: 如果锁被占用的时间很长，自旋会一直消耗 CPU 资源，造成性能浪费。</li>
<li><strong>Java中的应用</strong>:<ul>
<li><code>synchronized</code> 在 JDK 1.6 引入锁升级后，在<strong>轻量级锁</strong>阶段就采用了自旋策略。</li>
<li>J.U.C 包中的原子类 (<code>AtomicInteger</code> 等) 的 <code>getAndAdd</code> 等操作，底层就是基于 CAS 的自旋。</li>
<li><strong>自适应自旋</strong>: JDK 1.6 后引入的更智能的自旋，自旋的次数不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</li>
</ul>
</li>
</ul>
<h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自旋锁示例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpinLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自旋锁保护的计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">countWithLock</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 无锁保护的计数器，用于展示竞态条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">countWithoutLock</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建一个简单的自旋锁实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleSpinLock</span> <span class="variable">spinLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleSpinLock</span>();</span><br><span class="line">    <span class="comment">// 定义线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREAD_COUNT</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 每个线程执行的增量操作次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INCREMENTS_PER_THREAD</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--- 演示开始 ---&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 场景1: 使用自旋锁</span></span><br><span class="line">        runTest(<span class="literal">true</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;使用自旋锁的最终结果: %d\n&quot;</span>, countWithLock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 场景2: 不使用锁（展示竞态条件）</span></span><br><span class="line">        runTest(<span class="literal">false</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;不使用锁的最终结果:   %d\n&quot;</span>, countWithoutLock);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- 演示结束 ---&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;理论正确结果应为: %d\n&quot;</span>, THREAD_COUNT * INCREMENTS_PER_THREAD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行测试方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> useLock 是否使用自旋锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException 如果等待过程中被中断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runTest</span><span class="params">(<span class="type">boolean</span> useLock)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建固定大小的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义任务：每个线程都会对相应的计数器进行INCREMENTS_PER_THREAD次自增操作</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; INCREMENTS_PER_THREAD; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (useLock) &#123;</span><br><span class="line">                    <span class="comment">// 使用自旋锁保护临界区</span></span><br><span class="line">                    spinLock.lock();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        countWithLock++;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 确保锁被释放</span></span><br><span class="line">                        spinLock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不使用锁，直接修改计数器（会导致竞态条件）</span></span><br><span class="line">                    countWithoutLock++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交THREAD_COUNT个任务到线程池</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            executor.submit(task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池并等待所有任务完成</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        executor.awaitTermination(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的、不可重入的自旋锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleSpinLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 AtomicReference 来持有当前占用锁的线程。</span></span><br><span class="line">    <span class="comment">// 如果值为 null，表示锁未被占用。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Thread&gt; owner = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁</span></span><br><span class="line"><span class="comment">     * 通过CAS操作尝试获取锁，如果失败则自旋等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试通过 CAS（Compare-And-Swap）将 owner 从 null 设置为当前线程。</span></span><br><span class="line">        <span class="comment">// 如果设置失败，说明锁已被其他线程持有，进入 while 循环自旋。</span></span><br><span class="line">        <span class="keyword">while</span> (!owner.compareAndSet(<span class="literal">null</span>, currentThread)) &#123;</span><br><span class="line">            <span class="comment">// 空转，不做任何事，就是所谓的&quot;自旋&quot;</span></span><br><span class="line">            <span class="comment">// 在这个循环里，CPU 会一直高速运转，持续检查</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     * 只有持有锁的线程才能释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只有当前持有锁的线程才能释放锁。</span></span><br><span class="line">        <span class="comment">// 尝试通过 CAS 将 owner 从当前线程设置回 null。</span></span><br><span class="line">        <span class="comment">// 这个检查可以防止一个线程释放另一个线程持有的锁。</span></span><br><span class="line">        <span class="keyword">if</span> (!owner.compareAndSet(currentThread, <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果失败，意味着当前线程并不持有锁，或者发生了某些逻辑错误。</span></span><br><span class="line">            <span class="comment">// 在严格的实现中，这里可以抛出异常，如 IllegalMonitorStateException。</span></span><br><span class="line">            <span class="comment">// 为了简单起见，我们这里不做处理，但在实际应用中很重要。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-5-总结"><a href="#3-1-5-总结" class="headerlink" title="3.1.5 总结"></a>3.1.5 总结</h4><table>
<thead>
<tr>
<th align="left">分类维度</th>
<th align="left">类型A</th>
<th align="left">类型B</th>
<th align="left">核心区别</th>
<th align="left">Java中的例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>冲突态度</strong></td>
<td align="left">悲观锁</td>
<td align="left">乐观锁</td>
<td align="left">操作前加锁 vs 更新时检查</td>
<td align="left"><code>synchronized</code>, <code>ReentrantLock</code> vs <code>Atomic*</code>类(CAS)</td>
</tr>
<tr>
<td align="left"><strong>排队策略</strong></td>
<td align="left">公平锁</td>
<td align="left">非公平锁</td>
<td align="left">先来后到 vs 允许插队</td>
<td align="left"><code>ReentrantLock(true)</code> vs <code>synchronized</code>, <code>ReentrantLock()</code></td>
</tr>
<tr>
<td align="left"><strong>访问模式</strong></td>
<td align="left">独占锁</td>
<td align="left">共享锁</td>
<td align="left">单线程持有 vs 多线程持有</td>
<td align="left"><code>ReentrantLock</code> vs <code>ReentrantReadWriteLock</code></td>
</tr>
<tr>
<td align="left"><strong>重复获取</strong></td>
<td align="left">可重入锁</td>
<td align="left">不可重入锁</td>
<td align="left">同一线程可重复获取 vs 不可</td>
<td align="left"><code>synchronized</code>, <code>ReentrantLock</code> vs 自定义实现的锁</td>
</tr>
<tr>
<td align="left"><strong>等待策略</strong></td>
<td align="left">自旋锁</td>
<td align="left">互斥&#x2F;阻塞锁</td>
<td align="left">忙循环等待 vs 挂起等待</td>
<td align="left">CAS操作, 轻量级锁 vs 重量级锁</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-2-JUC-Lock接口与实现"><a href="#3-2-JUC-Lock接口与实现" class="headerlink" title="3.2 JUC-Lock接口与实现"></a>3.2 JUC-Lock接口与实现</h3><p><code>synchronized</code> 关键字是 Java 中最基础的内置锁，它简单易用，能够满足大部分并发场景。但它也存在一些局限性，例如：无法中断一个正在等待获取锁的线程、无法实现公平锁、无法绑定多个条件等。</p>
<p>为了解决这些问题，<code>java.util.concurrent.locks</code> 包（通常简称为 JUC Lock）提供了一套更为强大和灵活的锁机制。它的核心是 <code>Lock</code> 接口。</p>
<h4 id="3-2-1-Lock-接口核心-API"><a href="#3-2-1-Lock-接口核心-API" class="headerlink" title="3.2.1 Lock 接口核心 API"></a>3.2.1 Lock 接口核心 API</h4><p><code>Lock</code> 接口是 <code>synchronized</code> 的一种替代方案，它提供了对锁的更多控制。与 <code>synchronized</code> 自动释放锁不同，<code>Lock</code> <strong>必须手动释放</strong>。通常的使用范式是在 <code>try-finally</code> 块中进行，以确保锁一定会被释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ... 临界区代码 ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// 在 finally 块中释放锁，保证一定执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Lock</code> 接口的主要方法：</p>
<ul>
<li><strong><code>void lock()</code></strong>: 获取锁。如果锁已被其他线程持有，则当前线程将被阻塞，直到获取到锁。这是最常用的方法。</li>
<li><strong><code>void lockInterruptibly()</code> throws InterruptedException</strong>: 可中断地获取锁。与 <code>lock()</code> 类似，但如果当前线程在等待锁的过程中被中断（<code>Thread.interrupt()</code>），它会抛出 <code>InterruptedException</code> 并停止等待。这为处理死锁等问题提供了可能性。</li>
<li><strong><code>boolean tryLock()</code></strong>: 尝试非阻塞地获取锁。该方法会立即返回，如果获取成功，返回 <code>true</code>；如果锁已被其他线程持有，立即返回 <code>false</code>，当前线程不会被阻塞。</li>
<li><strong><code>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</code></strong>: 带超时的尝试获取锁。在指定的时间内尝试获取锁，如果在超时前获取成功，返回 <code>true</code>；如果在超时前锁仍未被释放或等待过程中被中断，返回 <code>false</code>。</li>
<li><strong><code>void unlock()</code></strong>: 释放锁。</li>
<li><strong><code>Condition newCondition()</code></strong>: 创建一个新的 <code>Condition</code> 对象，它与当前 <code>Lock</code> 实例绑定。<code>Condition</code> 提供了比 <code>Object</code> 的 <code>wait()</code>&#x2F;<code>notify()</code>&#x2F;<code>notifyAll()</code> 更强大、更灵活的线程协作机制。</li>
</ul>
<hr>
<h4 id="3-2-2-ReentrantLock-重入锁"><a href="#3-2-2-ReentrantLock-重入锁" class="headerlink" title="3.2.2 ReentrantLock (重入锁)"></a>3.2.2 ReentrantLock (重入锁)</h4><p><code>ReentrantLock</code> 是 <code>Lock</code> 接口最常见和最主要的实现。正如其名，它是一个<strong>可重入</strong>的互斥锁，功能上与 <code>synchronized</code> 非常相似，但提供了更多高级特性。</p>
<p><strong>核心特性：</strong></p>
<ol>
<li><p><strong>可重入性 (Reentrancy)</strong></p>
<ul>
<li>与 <code>synchronized</code> 一样，一个已经持有锁的线程可以再次成功获取该锁而不会被阻塞。</li>
<li>内部维护了一个计数器，每次加锁，计数器加一；每次解锁，计数器减一。当计数器为 0 时，锁才被真正释放。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ... do something ...</span></span><br><span class="line">        innerMethod();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock(); <span class="comment">// 同一线程再次获取锁，成功</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ... do something else ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>公平性 (Fairness)</strong></p>
<ul>
<li><code>ReentrantLock</code> 允许我们选择锁的公平策略。</li>
<li><strong>公平锁 (Fair Lock)</strong>：线程获取锁的顺序按照它们发出请求的顺序。就像排队买票，先到先得。</li>
<li><strong>非公平锁 (Non-fair Lock)</strong>：允许“插队”。新来的线程可能比已经在等待队列中的线程先获取到锁。这是 <strong>默认</strong> 策略。</li>
<li><strong>构造函数</strong>: <code>new ReentrantLock()</code> (默认非公平), <code>new ReentrantLock(true)</code> (公平)。</li>
<li><strong>为什么默认非公平？</strong> 因为非公平锁的性能（吞吐量）通常优于公平锁。减少了线程挂起和唤醒的开销，系统总的吞吐量更高。但可能导致某些线程长时间无法获取锁（饥饿）。</li>
</ul>
</li>
<li><p><strong>条件变量 (Condition)</strong></p>
<ul>
<li><code>ReentrantLock</code> 可以通过 <code>newCondition()</code> 方法创建多个 <code>Condition</code> 对象。</li>
<li>每个 <code>Condition</code> 对象都拥有一套自己的等待&#x2F;通知机制 (<code>await()</code> &#x2F; <code>signal()</code> &#x2F; <code>signalAll()</code>)，可以实现对不同条件的线程进行分组和精确唤醒。</li>
<li>相比之下，<code>synchronized</code> 只有一个与之关联的条件队列，<code>notify()</code> 唤醒哪个线程是不确定的，<code>notifyAll()</code> 则会唤醒所有等待的线程，效率较低。</li>
</ul>
</li>
</ol>
<p><strong><code>ReentrantLock</code> 与 <code>synchronized</code> 对比</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>synchronized</code></th>
<th><code>ReentrantLock</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>实现层面</strong></td>
<td>Java 关键字，由 JVM 实现</td>
<td>JUC 包中的一个类，基于 AQS (AbstractQueuedSynchronizer) 实现</td>
</tr>
<tr>
<td><strong>锁的释放</strong></td>
<td>自动释放（代码块结束或异常）</td>
<td><strong>必须手动释放</strong>（通常在 <code>finally</code> 块中调用 <code>unlock()</code>）</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>简单，功能固定</td>
<td>功能丰富，可中断、可超时、可选择公平性</td>
</tr>
<tr>
<td><strong>公平性</strong></td>
<td>非公平锁</td>
<td>可选择公平或非公平（默认非公平）</td>
</tr>
<tr>
<td><strong>线程协作</strong></td>
<td><code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code></td>
<td><code>Condition</code> 接口 (<code>await()</code>, <code>signal()</code>, <code>signalAll()</code>), 可绑定多个 <code>Condition</code></td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>Java 1.6 后优化显著，与 <code>ReentrantLock</code> 性能相当</td>
<td>在高竞争下通常有更好的性能表现，但具体取决于场景</td>
</tr>
<tr>
<td><strong>使用建议</strong></td>
<td>竞争不激烈，功能简单时首选，代码更简洁。</td>
<td>需要高级功能（如公平性、可中断、超时</td>
</tr>
</tbody></table>
<hr>
<h4 id="3-2-3-ReentrantReadWriteLock-读写锁"><a href="#3-2-3-ReentrantReadWriteLock-读写锁" class="headerlink" title="3.2.3 ReentrantReadWriteLock (读写锁)"></a>3.2.3 ReentrantReadWriteLock (读写锁)</h4><p>在很多业务场景中，读操作的频率远高于写操作，例如缓存、配置中心等。如果对这类资源使用 <code>ReentrantLock</code>，即使是多个读操作也必须互斥，这会极大地降低并发性能。</p>
<p><code>ReentrantReadWriteLock</code> 就是为了解决这个问题而设计的。它内部维护了两个锁：一个<strong>读锁</strong>和一个<strong>写锁</strong>。</p>
<p><strong>核心规则：</strong></p>
<ol>
<li><strong>读锁 (Read Lock)</strong>：是<strong>共享锁</strong>。多个线程可以同时持有读锁，只要没有线程持有写锁。</li>
<li><strong>写锁 (Write Lock)</strong>：是<strong>独占锁&#x2F;排他锁</strong>。当一个线程持有写锁时，其他任何线程（无论是读还是写）都必须等待。</li>
</ol>
<p><strong>特点：</strong></p>
<ul>
<li><strong>读读共享</strong>：多个线程可以同时读取资源。</li>
<li><strong>读写互斥</strong>：读操作和写操作不能同时进行。</li>
<li><strong>写写互斥</strong>：写操作和写操作不能同时进行。</li>
<li><strong>锁降级</strong>：允许一个持有写锁的线程，在不释放写锁的情况下，继续获取读锁。反之（从读锁升级到写锁）则不允许。</li>
</ul>
<p><strong>使用场景示例（缓存实现）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CachedData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> cacheValid;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> rwl.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        readLock.lock(); <span class="comment">// 获取读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                <span class="comment">// 必须释放读锁，否则写锁无法获取（锁升级不允许）</span></span><br><span class="line">                readLock.unlock();</span><br><span class="line">                writeLock.lock(); <span class="comment">// 获取写锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 再次检查，防止其他线程已更新</span></span><br><span class="line">                    <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                        data = <span class="string">&quot;Some data from database&quot;</span>; <span class="comment">// 模拟从DB获取数据</span></span><br><span class="line">                        cacheValid = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 在释放写锁前，获取读锁（锁降级）</span></span><br><span class="line">                    <span class="comment">// 保证数据一致性，防止其他写线程修改</span></span><br><span class="line">                    readLock.lock(); </span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    writeLock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此处已持有读锁</span></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock(); <span class="comment">// 释放读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-4-StampedLock-Java-8"><a href="#3-2-4-StampedLock-Java-8" class="headerlink" title="3.2.4 StampedLock (Java 8+)"></a>3.2.4 StampedLock (Java 8+)</h4><p><code>StampedLock</code> 是 Java 8 引入的一种新的锁机制，可以看作是 <code>ReentrantReadWriteLock</code> 的性能增强版。它支持三种模式：<strong>写锁、悲观读锁、乐观读</strong>。</p>
<ul>
<li><strong>写锁 (Writing)</strong>：与 <code>ReentrantReadWriteLock</code> 的写锁类似，是独占的。<code>writeLock()</code> 返回一个“戳”（stamp），用于 <code>unlockWrite()</code>。</li>
<li><strong>悲观读锁 (Pessimistic Reading)</strong>：与 <code>ReentrantReadWriteLock</code> 的读锁类似，是共享的，会阻塞写。<code>readLock()</code> 返回一个“戳”，用于 <code>unlockRead()</code>。</li>
<li><strong>乐观读 (Optimistic Reading)</strong>：<ul>
<li>这是 <code>StampedLock</code> 的核心优化。它假设读操作期间很少有写操作发生。</li>
<li><code>tryOptimisticRead()</code> 方法会返回一个非 0 的“戳”，然后线程可以去读取共享变量。</li>
<li>读取后，通过 <code>validate(stamp)</code> 方法校验之前获取的“戳”是否仍然有效。</li>
<li>如果有效，说明期间没有写操作发生，读取成功，避免了加锁的开销。</li>
<li>如果无效，说明有写操作修改了数据，此时需要升级为悲观读锁，重新读取数据。</li>
</ul>
</li>
</ul>
<p><strong>注意点：</strong></p>
<ul>
<li><code>StampedLock</code> <strong>不可重入</strong>。如果一个线程已经持有了写锁，再尝试获取写锁会导致死锁。</li>
<li>所有获取锁的方法都会返回一个 long 类型的 stamp，解锁时需要传入这个 stamp。</li>
<li>使用起来比 <code>ReentrantReadWriteLock</code> 更复杂，适用于读多写少的极致性能优化场景。</li>
</ul>
<hr>
<h3 id="3-3-JUC-并发编程的原子基石：CAS-与-AQS"><a href="#3-3-JUC-并发编程的原子基石：CAS-与-AQS" class="headerlink" title="3.3 JUC - 并发编程的原子基石：CAS 与 AQS"></a>3.3 JUC - 并发编程的原子基石：CAS 与 AQS</h3><p>如果说 <code>Lock</code> 接口定义了锁的行为，那么 <code>CAS</code> 和 <code>AQS</code> 就是构建这些高级锁（如 <code>ReentrantLock</code>, <code>ReentrantReadWriteLock</code> 等）的底层核心技术。它们是整个 JUC 框架的基石。</p>
<h4 id="3-3-1-CAS-CompareAndSwap-比较并交换"><a href="#3-3-1-CAS-CompareAndSwap-比较并交换" class="headerlink" title="3.3.1 CAS (CompareAndSwap) - 比较并交换"></a>3.3.1 CAS (CompareAndSwap) - 比较并交换</h4><p>CAS 是一种无锁（Lock-Free）的原子操作，通常由硬件直接支持，以保证其原子性。它是一种乐观锁的实现思想。</p>
<h5 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h5><p>CAS 操作包含三个操作数：</p>
<ol>
<li><strong>内存位置 V (Variable)</strong>：要更新的变量。</li>
<li><strong>预期原值 A (Expected)</strong>：你认为这个变量现在的值。</li>
<li><strong>新值 B (New)</strong>：如果变量的值符合你的预期，你希望更新成的新值。</li>
</ol>
<p><strong>执行过程</strong>：当一个线程执行 CAS 操作时，它会原子性地比较内存位置 V 的值是否与预期原值 A 相等。</p>
<ul>
<li>如果 <strong>相等</strong>，就将 V 的值更新为 B，并返回 <code>true</code>。</li>
<li>如果 <strong>不相等</strong>，说明在当前线程准备更新的期间，V 的值已经被其他线程修改了。此时，操作失败，不做任何修改，并返回 <code>false</code>。</li>
</ul>
<p>这个 “比较并交换” 的过程是一条 CPU 原子指令，不会被中断，从而保证了操作的原子性。</p>
<hr>
<h5 id="2-Java中的实现"><a href="#2-Java中的实现" class="headerlink" title="2. Java中的实现"></a>2. Java中的实现</h5><p>Java 无法直接操作硬件指令，而是通过 <code>sun.misc.Unsafe</code> 类中的一系列 <code>compareAndSwap*</code> 方法（如 <code>compareAndSwapInt</code>, <code>compareAndSwapLong</code>）来调用底层 C&#x2F;C++ 代码，最终实现 CAS。</p>
<p>JUC 中的原子类，如 <code>AtomicInteger</code>、<code>AtomicLong</code> 等，其核心就是封装了 <code>Unsafe</code> 类的 CAS 操作。</p>
<p><strong>示例：<code>AtomicInteger</code> 的 <code>incrementAndGet()</code> 伪代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AtomicInteger 内部实现类似逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 使用自旋的方式不断尝试</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get(); <span class="comment">// 1. 获取当前值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>; <span class="comment">// 2. 计算新值</span></span><br><span class="line">        <span class="comment">// 3. 使用 CAS 尝试更新</span></span><br><span class="line">        <span class="comment">// 如果当前值仍然是 current，就更新为 next，并返回 true</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next)) &#123; </span><br><span class="line">            <span class="keyword">return</span> next; <span class="comment">// 更新成功，退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 CAS 失败，说明 current 值被其他线程修改了</span></span><br><span class="line">        <span class="comment">// 循环会继续，重新获取最新值，再次尝试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种 “CAS + 自旋” 的模式是无锁编程的经典范式。</p>
<hr>
<h5 id="3-CAS的三大问题及解决方案"><a href="#3-CAS的三大问题及解决方案" class="headerlink" title="3. CAS的三大问题及解决方案"></a>3. CAS的三大问题及解决方案</h5><p><strong>ABA 问题</strong></p>
<ul>
<li><strong>问题描述</strong>：一个值从 A 变成了 B，然后又变回了 A。CAS 检查时会发现它的值仍然是 A，于是操作成功。但实际上，这个值已经被改变过了。在某些场景下，这会引发问题（例如，链表的节点被复用）。</li>
<li><strong>解决方案</strong>：使用<strong>版本号</strong>或<strong>时间戳</strong>。JUC 提供了 <code>AtomicStampedReference</code> 类，它在更新时不仅会检查当前值，还会检查当前版本号。只有值和版本号都符合预期，才会更新成功，并且更新时会同时更新值和版本号。</li>
</ul>
<p><strong>自旋时间长，开销大</strong></p>
<ul>
<li><strong>问题描述</strong>：如果并发冲突非常激烈，很多线程会反复尝试 CAS 操作但都失败，这会导致它们长时间地“自旋”，空耗 CPU 资源。</li>
<li><strong>解决方案</strong>：这方面没有完美的解决方案。Java 8 之后对自旋锁进行了一些优化，例如适应性自旋。但在高竞争环境下，传统锁（如 <code>ReentrantLock</code>）的性能可能会优于纯 CAS，因为失败的线程会被挂起，而不是空转。</li>
</ul>
<p><strong>只能保证一个共享变量的原子操作</strong></p>
<ul>
<li><strong>问题描述</strong>：CAS 操作一次只能保证一个内存地址上的值的原子性。如果需要同时对多个变量进行原子操作，CAS 无能为力。</li>
<li><strong>解决方案</strong>：<ul>
<li>将多个变量封装成一个对象，然后使用 <code>AtomicReference</code> 对这个对象的引用进行 CAS 操作。</li>
<li>使用传统的锁（<code>synchronized</code> 或 <code>Lock</code>）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-3-2-AQS-AbstractQueuedSynchronizer-抽象队列同步器"><a href="#3-3-2-AQS-AbstractQueuedSynchronizer-抽象队列同步器" class="headerlink" title="3.3.2 AQS (AbstractQueuedSynchronizer) - 抽象队列同步器"></a>3.3.2 AQS (AbstractQueuedSynchronizer) - 抽象队列同步器</h4><p>AQS 是一个用于构建锁和同步器的<strong>框架</strong>。JUC 包中的许多同步器（如 <code>ReentrantLock</code>, <code>Semaphore</code>, <code>CountDownLatch</code>, <code>ReentrantReadWriteLock</code>）都是基于 AQS 构建的。</p>
<p>AQS 的核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态。如果共享资源被占用，就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用一个 <strong>CLH 队列锁</strong> 的变体实现的，即将暂时获取不到锁的线程加入到一个虚拟的<strong>双向队列</strong>中。</p>
<h5 id="1-AQS核心设计"><a href="#1-AQS核心设计" class="headerlink" title="1. AQS核心设计"></a>1. AQS核心设计</h5><p>AQS 内部维护了两个核心部分：</p>
<ol>
<li><strong><code>state</code> 状态变量 (volatile int)</strong><ul>
<li>它是一个 <code>volatile</code> 的整型变量，用于表示同步状态。</li>
<li>它的具体含义由实现 AQS 的子类来定义。例如：<ul>
<li>在 <code>ReentrantLock</code> 中，<code>state</code> 表示锁的重入次数。<code>state=0</code> 表示无锁，<code>state&gt;0</code> 表示已被持有，值代表重入的层数。</li>
<li>在 <code>CountDownLatch</code> 中，<code>state</code> 表示计数器的值。</li>
<li>在 <code>Semaphore</code> 中，<code>state</code> 表示剩余的许可数量。</li>
</ul>
</li>
<li>AQS 提供了 <code>getState()</code>, <code>setState()</code>, <code>compareAndSetState()</code> 等方法来原子性地操作这个状态，其中 <code>compareAndSetState()</code> 就是基于 <strong>CAS</strong> 实现的。</li>
</ul>
</li>
<li><strong>FIFO 等待队列 (双向链表)</strong><ul>
<li>这是一个先进先出的双向队列，用于存放等待获取锁的线程。</li>
<li>当一个线程获取锁失败后，AQS 会将该线程和其等待状态封装成一个 <code>Node</code> 对象，并将其加入到队列的尾部。</li>
<li>当锁被释放时，AQS 会唤醒队列头部的 <code>Node</code> 对应的线程，让它尝试再次获取锁。</li>
<li>队列的头部节点是当前持有锁的线程（或一个虚拟节点），它在释放锁后会唤醒下一个节点。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="2-AQS-的两种模式"><a href="#2-AQS-的两种模式" class="headerlink" title="2. AQS 的两种模式"></a>2. AQS 的两种模式</h5><p>AQS 支持两种资源共享模式，子类在实现时需要选择其中一种或两种都支持：</p>
<ol>
<li><strong>独占模式 (Exclusive)</strong>：资源在同一时刻只能被一个线程持有。如 <code>ReentrantLock</code>。</li>
<li><strong>共享模式 (Shared)</strong>：资源在同一时刻可以被多个线程持有。如 <code>Semaphore</code>, <code>CountDownLatch</code>, <code>ReentrantReadWriteLock</code> 的读锁。</li>
</ol>
<hr>
<h5 id="3-AQS-的模板方法模式"><a href="#3-AQS-的模板方法模式" class="headerlink" title="3. AQS 的模板方法模式"></a>3. AQS 的模板方法模式</h5><p>AQS 的设计采用了<strong>模板方法模式</strong>。它将同步器的通用逻辑（如线程的排队、阻塞、唤醒）都封装好了，而将特定的获取&#x2F;释放锁的逻辑定义为几个 “钩子”（hook）方法，交由子类去实现。</p>
<p>子类需要重写（实现）的关键方法：</p>
<ul>
<li><code>tryAcquire(int arg)</code>: 独占模式下，尝试获取资源。成功返回 <code>true</code>，失败返回 <code>false</code>。</li>
<li><code>tryRelease(int arg)</code>: 独占模式下，尝试释放资源。成功返回 <code>true</code>，失败返回 <code>false</code>。</li>
<li><code>tryAcquireShared(int arg)</code>: 共享模式下，尝试获取资源。返回负数表示失败；0 表示成功但无剩余资源；正数表示成功且有剩余资源。</li>
<li><code>tryReleaseShared(int arg)</code>: 共享模式下，尝试释放资源。</li>
<li><code>isHeldExclusively()</code>: 当前线程是否持有独占锁。</li>
</ul>
<hr>
<h5 id="4-源码分析：ReentrantLock-lock-的工作流程"><a href="#4-源码分析：ReentrantLock-lock-的工作流程" class="headerlink" title="4. 源码分析：ReentrantLock.lock() 的工作流程"></a>4. 源码分析：<code>ReentrantLock.lock()</code> 的工作流程</h5><p>以 <code>ReentrantLock</code> 的非公平锁为例，<code>lock()</code> 方法的调用流程大致如下：</p>
<ol>
<li>调用 <code>lock()</code> 方法。</li>
<li>内部调用 AQS 的 <code>acquire(1)</code> 方法。</li>
<li><code>acquire(1)</code> 方法首先会调用子类（<code>NonfairSync</code>）实现的 <code>tryAcquire(1)</code>。</li>
<li><code>tryAcquire()</code> 逻辑：<br>a. 检查 <code>state</code> 是否为 0（无锁状态）。如果是，则用 <strong>CAS</strong> 尝试将 <code>state</code> 设置为 1。如果成功，将锁的持有者设为当前线程，返回 <code>true</code>。<br>b. 如果 <code>state</code> 不为 0，检查当前锁的持有者是否是当前线程。如果是，则增加 <code>state</code> 的值（实现重入），返回 <code>true</code>。<br>c. 如果以上都不满足，返回 <code>false</code>。</li>
<li>如果 <code>tryAcquire()</code> 返回 <code>true</code>，<code>acquire()</code> 方法直接结束，线程获取锁成功。</li>
<li>如果 <code>tryAcquire()</code> 返回 <code>false</code>，<code>acquire()</code> 方法会将当前线程封装成 <code>Node</code>，加入到 AQS 的等待队列尾部，然后通过 <code>LockSupport.park()</code> 将当前线程挂起，等待被唤醒。</li>
<li>当持有锁的线程调用 <code>unlock()</code> 时，最终会调用 AQS 的 <code>release()</code> 方法，该方法会调用子类实现的 <code>tryRelease()</code> 来减少 <code>state</code>，当 <code>state</code> 变为 0 时，会唤醒队列头部的下一个等待线程。</li>
</ol>
<hr>
<h2 id="4-JUC-核心工具类"><a href="#4-JUC-核心工具类" class="headerlink" title="4. JUC 核心工具类"></a>4. JUC 核心工具类</h2><h3 id="4-1-原子操作类"><a href="#4-1-原子操作类" class="headerlink" title="4.1 原子操作类"></a>4.1 原子操作类</h3><h4 id="4-1-1-概述与原理"><a href="#4-1-1-概述与原理" class="headerlink" title="4.1.1 概述与原理"></a>4.1.1 概述与原理</h4><p>在多线程环境下，对共享变量进行 <code>i++</code> 这样的操作并不是原子的，它包含了“读取-修改-写入”三个步骤，任何一步都可能被其他线程打断，导致数据不一致。虽然 <code>synchronized</code> 和 <code>Lock</code> 可以解决这个问题，但它们属于悲观锁，在高并发场景下可能引起线程阻塞和上下文切换，开销较大。</p>
<p><code>java.util.concurrent.atomic</code> (J.U.C.atomic) 包提供了一系列原子操作类，它们是基于前一节提到的 <strong>CAS (Compare-And-Swap)</strong> 机制实现的。这些类提供了一种性能更高、开销更小的“无锁”（Lock-Free）方式来保证对单个变量操作的原子性。</p>
<p><strong>核心原理：</strong></p>
<p>原子操作类内部通常组合使用了 <code>volatile</code> 关键字和 <code>CAS</code> 操作。</p>
<ul>
<li><code>volatile</code>：保证了多线程之间变量的<strong>可见性</strong>，即一个线程修改了变量的值，其他线程能立刻看到。</li>
<li><code>CAS</code>：保证了“比较并更新”这个操作的<strong>原子性</strong>。</li>
</ul>
<p>通过“CAS + 自旋”的方式，原子类实现了非阻塞的线程安全。</p>
<p><strong>核心 API (以 <code>AtomicInteger</code> 为例):</strong></p>
<ul>
<li><code>get()</code>: 获取当前值。</li>
<li><code>set(int newValue)</code>: 设置新值。</li>
<li><code>getAndSet(int newValue)</code>: 设置新值并返回旧值。</li>
<li><code>compareAndSet(int expect, int update)</code>: CAS 核心方法。如果当前值等于 <code>expect</code>，则原子性地更新为 <code>update</code>，并返回 <code>true</code>；否则返回 <code>false</code>。</li>
<li><code>getAndIncrement()</code>: 原子性地将当前值加 1，并返回旧值 (类似 <code>i++</code>)。</li>
<li><code>incrementAndGet()</code>: 原子性地将当前值加 1，并返回新值 (类似 <code>++i</code>)。</li>
<li><code>getAndDecrement()</code> &#x2F; <code>decrementAndGet()</code>: 类似的减 1 操作。</li>
<li><code>getAndAdd(int delta)</code> &#x2F; <code>addAndGet(int delta)</code>: 原子性地增加一个指定的值。</li>
</ul>
<hr>
<h4 id="4-1-2-原子类的分类"><a href="#4-1-2-原子类的分类" class="headerlink" title="4.1.2 原子类的分类"></a>4.1.2 原子类的分类</h4><h5 id="1-基本类型原子类"><a href="#1-基本类型原子类" class="headerlink" title="1. 基本类型原子类"></a>1. 基本类型原子类</h5><p>这是最常用的一类，用于对基本数据类型进行原子操作。</p>
<ul>
<li><code>AtomicInteger</code>: 原子更新整型。</li>
<li><code>AtomicLong</code>: 原子更新长整型。</li>
<li><code>AtomicBoolean</code>: 原子更新布尔值。</li>
</ul>
<p><strong>使用示例（线程安全的计数器）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 AtomicInteger 代替 int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet(); <span class="comment">// 原子操作，线程安全</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                counter.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终结果总是 20000，不会出现线程安全问题</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Final count: &quot;</span> + counter.getCount()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-引用类型原子类"><a href="#2-引用类型原子类" class="headerlink" title="2. 引用类型原子类"></a>2. 引用类型原子类</h5><p>用于对对象的引用进行原子操作。</p>
<ul>
<li><code>AtomicReference&lt;V&gt;</code>: 原子更新引用类型。</li>
<li><code>AtomicStampedReference&lt;V&gt;</code>: 解决 <strong>CAS 的 ABA 问题</strong>。它在内部维护了一个“版本号”（stamp），更新时不仅要比较值，还要比较版本号。只有两者都相同时才能更新成功。</li>
<li><code>AtomicMarkableReference&lt;V&gt;</code>: 与 <code>AtomicStampedReference</code> 类似，但版本号是一个布尔值（mark），用于表示数据是否被修改过。更轻量，适用于只关心“变过&#x2F;没变过”的场景。</li>
</ul>
<p><strong>ABA 问题示例：</strong></p>
<p>线程1想把 A 更新为 C。它读取到 A，然后被挂起。</p>
<p>线程2把 A 更新为 B，然后又更新回 A。</p>
<p>线程1恢复执行，CAS 检查发现值仍然是 A，于是成功更新为 C。</p>
<p>但实际上 A 的状态已经发生了变化，这在某些业务逻辑中是致命的。</p>
<hr>
<h5 id="3-数组类型原子类"><a href="#3-数组类型原子类" class="headerlink" title="3. 数组类型原子类"></a>3. 数组类型原子类</h5><p>对数组中的某个元素进行原子操作。</p>
<ul>
<li><code>AtomicIntegerArray</code>: 原子更新整型数组里的元素。</li>
<li><code>AtomicLongArray</code>: 原子更新长整型数组里的元素。</li>
<li><code>AtomicReferenceArray&lt;E&gt;</code>: 原子更新引用类型数组里的元素。</li>
</ul>
<p><strong>注意</strong>：这些类保证的是对数组中<strong>单个元素</strong>的操作是原子的，而不是对整个数组的操作是原子的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] values = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">AtomicIntegerArray</span> <span class="variable">atomicArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(values);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子地将索引为 0 的元素加 10</span></span><br><span class="line">atomicArray.getAndAdd(<span class="number">0</span>, <span class="number">10</span>); </span><br><span class="line"><span class="comment">// 原子地将索引为 1 的元素与期望值 2 比较，如果相等则更新为 20</span></span><br><span class="line">atomicArray.compareAndSet(<span class="number">1</span>, <span class="number">2</span>, <span class="number">20</span>); </span><br><span class="line"></span><br><span class="line">System.out.println(atomicArray); <span class="comment">// 输出 [11, 20, 3]</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-字段更新器"><a href="#4-字段更新器" class="headerlink" title="4. 字段更新器"></a>4. 字段更新器</h5><p>以一种更轻量、基于反射的方式，对一个对象的<strong>某个 <code>volatile</code> 字段</strong>进行原子操作。当你不想为了一个字段就引入一个完整的原子类包装时，或者操作的类不能被修改时，这是一个很好的选择。</p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>: 原子更新对象的 <code>volatile int</code> 字段。</li>
<li><code>AtomicLongFieldUpdater</code>: 原子更新对象的 <code>volatile long</code> 字段。</li>
<li><code>AtomicReferenceFieldUpdater</code>: 原子更新对象的 <code>volatile</code> 引用字段。</li>
</ul>
<p><strong>使用要求：</strong></p>
<ol>
<li>字段必须是 <code>volatile</code> 类型。</li>
<li>字段的访问修饰符不能是 <code>private</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 字段必须是 volatile</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldUpdaterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        </span><br><span class="line">        AtomicIntegerFieldUpdater&lt;User&gt; updater = </span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 使用 updater 对 user 对象的 age 字段进行原子操作</span></span><br><span class="line">        updater.compareAndSet(user, <span class="number">0</span>, <span class="number">18</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;User age: &quot;</span> + user.age); <span class="comment">// 输出 18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-累加器-Adder-Accumulator-Java-8"><a href="#5-累加器-Adder-Accumulator-Java-8" class="headerlink" title="5. 累加器 (Adder&#x2F;Accumulator - Java 8+)"></a>5. 累加器 (Adder&#x2F;Accumulator - Java 8+)</h5><p><code>AtomicLong</code> 在高并发下的竞争非常激烈，因为所有线程都在对同一个变量进行 CAS 操作，失败的线程会不断自旋，消耗 CPU。为了解决这个问题，Java 8 引入了 <code>LongAdder</code> 和 <code>DoubleAdder</code>。</p>
<ul>
<li><code>LongAdder</code> &#x2F; <code>DoubleAdder</code>: 高性能的原子累加器。</li>
<li><code>LongAccumulator</code> &#x2F; <code>DoubleAccumulator</code>: <code>LongAdder</code> 的更通用版本，可以自定义累加规则。</li>
</ul>
<p><strong><code>LongAdder</code> 的核心思想（分段锁&#x2F;分散热点）：</strong><br><code>LongAdder</code> 内部维护了一个 <code>base</code> 变量和一个 <code>Cell[]</code> 数组。</p>
<ul>
<li><strong>低并发</strong>：当没有竞争时，数据会直接累加到 <code>base</code> 上，与 <code>AtomicLong</code> 类似。</li>
<li><strong>高并发</strong>：当对 <code>base</code> 的 CAS 更新失败时，线程会尝试在 <code>Cell</code> 数组的一个槽（Cell）中进行累加。每个线程通过哈希等算法映射到自己的槽位，从而将对单个变量的竞争<strong>分散</strong>到多个变量上。</li>
<li><strong>获取总和</strong>：调用 <code>sum()</code> 方法时，会把 <code>base</code> 的值和所有 <code>Cell</code> 数组中的值相加，返回最终结果。</li>
</ul>
<p><strong><code>AtomicLong</code> vs <code>LongAdder</code></strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>AtomicLong</code></th>
<th><code>LongAdder</code> (Java 8+)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>实现原理</strong></td>
<td>对单个 <code>value</code> 变量进行 CAS 操作</td>
<td>“分段锁”思想，<code>base</code> + <code>Cell[]</code> 数组，分散竞争压力</td>
</tr>
<tr>
<td><strong>高并发写性能</strong></td>
<td>性能较差，因为所有线程竞争同一个变量</td>
<td><strong>性能极高</strong>，因为竞争被分散到多个 <code>Cell</code> 中</td>
</tr>
<tr>
<td><strong>读性能</strong></td>
<td>性能高，直接返回 <code>value</code></td>
<td>性能稍低，需要累加 <code>base</code> 和所有 <code>Cell</code></td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>读多写少，或并发度不高。需要完整的 CAS 功能。</td>
<td><strong>写多读少</strong>的高并发场景，如监控统计、计数器等。</td>
</tr>
<tr>
<td><strong>一致性</strong></td>
<td>强一致性</td>
<td>调用 <code>sum()</code> 时是<strong>最终一致性</strong>，可能不是最新的精确值。</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>功能全面，支持 <code>compareAndSet</code> 等丰富的原子操作。</td>
<td>功能单一，主要用于 <code>add()</code> 和 <code>sum()</code>，没有 <code>compareAndSet</code>。</td>
</tr>
</tbody></table>
<p>在 JDK 8+ 的环境下，如果你的需求仅仅是高并发下的<strong>累加计数</strong>，优先选择 <code>LongAdder</code> 而不是 <code>AtomicLong</code>。</p>
<hr>
<h3 id="4-2-并发容器"><a href="#4-2-并发容器" class="headerlink" title="4.2 并发容器"></a>4.2 并发容器</h3><p>并发容器还记得不，在第四章集合中介绍过一部分了这里再简单提一下</p>
<p>标准的集合类如 <code>ArrayList</code>、<code>HashMap</code> 等都不是线程安全的。如果在多线程环境下对它们进行读写操作，可能会导致数据不一致、<code>ConcurrentModificationException</code> 等问题。</p>
<p>虽然可以通过 <code>Collections.synchronizedMap()</code>、<code>Collections.synchronizedList()</code> 等工具类将它们包装成线程安全的版本，但这种方式的性能较差。因为它仅仅是在每个方法上加了一把全局锁（<code>synchronized</code>），相当于一个时刻只允许一个线程访问该容器，大大降低了并发性。</p>
<p>JUC 包提供了一系列高性能的并发容器，它们通过更精细的锁机制（如分段锁、CAS）或特殊的数据结构来提升并发性能。</p>
<hr>
<h4 id="4-2-1-ConcurrentHashMap"><a href="#4-2-1-ConcurrentHashMap" class="headerlink" title="4.2.1 ConcurrentHashMap"></a>4.2.1 ConcurrentHashMap</h4><p><code>ConcurrentHashMap</code> 是线程安全的 <code>HashMap</code>，也是 JUC 中最重要、最常用的并发容器之一。它通过巧妙的设计，在保证线程安全的同时，提供了极高的并发性能。</p>
<h5 id="1-核心思想演进"><a href="#1-核心思想演进" class="headerlink" title="1 核心思想演进"></a>1 核心思想演进</h5><ul>
<li><strong>JDK 1.7 - 分段锁 (Segment)</strong><ul>
<li><code>ConcurrentHashMap</code> 内部由一个 <code>Segment</code> 数组构成，每个 <code>Segment</code> 本身就像一个小型的 <code>HashMap</code>（内部是 <code>HashEntry</code> 数组）。</li>
<li>当需要对数据进行操作时，不是锁住整个 <code>Map</code>，而是根据 key 的 hash 值定位到对应的 <code>Segment</code>，然后只锁住那一个 <code>Segment</code>。</li>
<li><code>Segment</code> 继承自 <code>ReentrantLock</code>，因此可以实现细粒度的加锁。默认有 16 个 <code>Segment</code>，意味着理论上最多可以支持 16 个线程同时对 <code>Map</code> 进行写操作（只要它们操作的不是同一个 <code>Segment</code>）。</li>
<li>这种设计大大提高了并发度，<code>get</code> 操作大多数情况下甚至不需要加锁。</li>
</ul>
</li>
<li><strong>JDK 1.8 - CAS + synchronized + 红黑树</strong><ul>
<li>JDK 1.8 对 <code>ConcurrentHashMap</code> 进行了重大重构，摒弃了 <code>Segment</code> 的设计，锁的粒度更细。</li>
<li><strong>数据结构</strong>：与 <code>HashMap</code> 在 JDK 1.8 的实现类似，采用 <strong>数组 + 链表&#x2F;红黑树</strong> 的结构。</li>
<li><strong>锁粒度</strong>：锁的粒度从 <code>Segment</code> 级别降低到了 <strong>数组桶（bucket）的头节点</strong> 级别。</li>
<li><strong>加锁方式</strong>：<ol>
<li><strong>初始化&#x2F;插入首节点</strong>：当向一个空的 bucket 插入第一个节点时，使用 <strong>CAS</strong> 操作，不加锁，乐观地尝试写入。</li>
<li><strong>发生哈希冲突</strong>：如果 bucket 中已经有节点（链表或红黑树），则使用 <code>synchronized</code> 锁住该 bucket 的<strong>头节点</strong>。这样，只有在操作同一个 bucket 的线程之间才会产生竞争和阻塞，不同 bucket 之间的操作完全不受影响。</li>
</ol>
</li>
<li><strong>性能优化</strong>：当链表长度超过一定阈值（默认为 8）且数组长度大于 64 时，链表会转化为<strong>红黑树</strong>，将查找时间复杂度从 O(n) 降为 O(log n)。</li>
</ul>
</li>
</ul>
<h5 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h5><p><code>ConcurrentHashMap</code> 是 <code>Hashtable</code> 和 <code>Collections.synchronizedMap</code> 的完美替代品，在需要线程安全 Map 的场景下，几乎总是首选。</p>
<hr>
<h4 id="4-2-2-CopyOnWriteArrayList-CopyOnWriteArraySet"><a href="#4-2-2-CopyOnWriteArrayList-CopyOnWriteArraySet" class="headerlink" title="4.2.2 CopyOnWriteArrayList &#x2F; CopyOnWriteArraySet"></a>4.2.2 CopyOnWriteArrayList &#x2F; CopyOnWriteArraySet</h4><p><code>CopyOnWrite</code>（写时复制）是一种用于实现并发优化的策略。</p>
<ul>
<li><strong>核心思想</strong>:<ul>
<li><strong>读操作</strong>：不加锁，直接读取底层数组的数据。这使得读操作非常快且完全无阻塞。</li>
<li><strong>写操作（add, set, remove）</strong>：加锁，并且不是在原数组上修改，而是：<ol>
<li>复制一份底层数组的<strong>全新副本</strong>。</li>
<li>在新副本上进行修改操作。</li>
<li>将指向旧数组的引用，原子性地切换到指向新数组。</li>
</ol>
</li>
</ul>
</li>
<li><strong>特点</strong>:<ul>
<li><strong>读写分离</strong>：读和写操作在不同的数据结构上进行，读操作不会被写操作阻塞。</li>
<li><strong>缺点1：内存开销大</strong>：每次写操作都会复制整个数组，如果容器很大，会占用大量内存。</li>
<li><strong>缺点2：数据一致性问题</strong>：读操作读取的是某个时间点的快照。在一个写操作发生后，其他线程可能在一段时间内仍然读取到旧的数据。它只能保证数据的<strong>最终一致性</strong>，而不是实时一致性。</li>
<li><strong>迭代器</strong>：它的迭代器是安全的（不会抛出 <code>ConcurrentModificationException</code>），因为它遍历的是创建迭代器那一刻的数组快照，后续的修改不会反映在迭代器中。</li>
</ul>
</li>
<li><strong>适用场景</strong>:<ul>
<li><strong>读多写少</strong>的场景。例如：黑白名单、系统配置、监听器列表等。如果写操作频繁，其性能会急剧下降。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-2-3-BlockingQueue-阻塞队列"><a href="#4-2-3-BlockingQueue-阻塞队列" class="headerlink" title="4.2.3 BlockingQueue - 阻塞队列"></a>4.2.3 BlockingQueue - 阻塞队列</h4><p><code>BlockingQueue</code> 是 JUC 中非常重要的一个接口，它在标准 <code>Queue</code> 的基础上增加了两个核心特性：</p>
<ol>
<li>当队列满时，尝试<strong>入队</strong>（<code>put</code>）的线程会被<strong>阻塞</strong>，直到队列有空闲空间。</li>
<li>当队列空时，尝试<strong>出队</strong>（<code>take</code>）的线程会被<strong>阻塞</strong>，直到队列中有元素。</li>
</ol>
<p>阻塞队列是<strong>生产者-消费者</strong>模式的经典实现，也是线程池等高级并发工具的核心组件。</p>
<h5 id="1-核心方法"><a href="#1-核心方法" class="headerlink" title="1. 核心方法"></a>1. 核心方法</h5><table>
<thead>
<tr>
<th>操作类型</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>阻塞</th>
<th>超时阻塞</th>
</tr>
</thead>
<tbody><tr>
<td><strong>入队</strong></td>
<td><code>add(e)</code></td>
<td><code>offer(e)</code></td>
<td><code>put(e)</code></td>
<td><code>offer(e, time, unit)</code></td>
</tr>
<tr>
<td><strong>出队</strong></td>
<td><code>remove()</code></td>
<td><code>poll()</code></td>
<td><code>take()</code></td>
<td><code>poll(time, unit)</code></td>
</tr>
<tr>
<td><strong>检查队头</strong></td>
<td><code>element()</code></td>
<td><code>peek()</code></td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<hr>
<h5 id="2-主要实现类"><a href="#2-主要实现类" class="headerlink" title="2. 主要实现类"></a>2. 主要实现类</h5><ul>
<li><strong><code>ArrayBlockingQueue</code></strong>:<ul>
<li>基于<strong>数组</strong>实现的<strong>有界</strong>阻塞队列。</li>
<li>创建时必须指定容量。</li>
<li>内部使用一个 <code>ReentrantLock</code> 和两个 <code>Condition</code>（<code>notEmpty</code>, <code>notFull</code>）来控制并发。</li>
<li>支持公平&#x2F;非公平策略（默认非公平）。</li>
</ul>
</li>
<li><strong><code>LinkedBlockingQueue</code></strong>:<ul>
<li>基于<strong>链表</strong>实现的阻塞队列。</li>
<li>容量是<strong>可选的</strong>，如果不指定，默认为 <code>Integer.MAX_VALUE</code>，相当于一个无界队列。</li>
<li>内部采用<strong>读写锁分离</strong>的思想，使用两个锁（<code>putLock</code>, <code>takeLock</code>）分别控制入队和出队操作，在高并发的生产者-消费者场景下，性能优于 <code>ArrayBlockingQueue</code>。</li>
</ul>
</li>
<li><strong><code>SynchronousQueue</code></strong>:<ul>
<li>一个<strong>不存储元素</strong>的阻塞队列，容量为 0。</li>
<li>每个 <code>put</code> 操作必须等待一个 <code>take</code> 操作，反之亦然。它更像是一个线程之间传递元素的“通道”或“手递手”的交接点。</li>
<li>常用于线程池 <code>Executors.newCachedThreadPool()</code> 中。</li>
</ul>
</li>
<li><strong><code>PriorityBlockingQueue</code></strong>:<ul>
<li>支持<strong>优先级</strong>的<strong>无界</strong>阻塞队列。</li>
<li>存入的元素必须实现 <code>Comparable</code> 接口或在构造时传入 <code>Comparator</code>。队列会根据元素的优先级进行排序。</li>
</ul>
</li>
<li><strong><code>DelayQueue</code></strong>:<ul>
<li>支持<strong>延时获取</strong>元素的<strong>无界</strong>阻塞队列。</li>
<li>队列中的元素必须实现 <code>Delayed</code> 接口，该接口定义了 <code>getDelay()</code> 方法。</li>
<li>只有当元素的延时时间到了，才能从队列中取出。</li>
<li>常用于实现定时任务、缓存过期等场景。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-2-4-ConcurrentLinkedQueue"><a href="#4-2-4-ConcurrentLinkedQueue" class="headerlink" title="4.2.4 ConcurrentLinkedQueue"></a>4.2.4 ConcurrentLinkedQueue</h4><ul>
<li>一个基于<strong>链表</strong>的<strong>无界</strong>、<strong>非阻塞</strong>的线程安全队列。</li>
<li>它使用 <strong>CAS</strong> 原子操作来实现元素的入队和出队，性能非常高。</li>
<li>由于是非阻塞的，当队列为空时，<code>poll()</code> 方法会立即返回 <code>null</code> 而不会等待。</li>
<li>适用于需要高吞吐量，并且不希望线程在队列操作上被阻塞的场景。</li>
</ul>
<hr>
<h4 id="4-2-5-ConcurrentSkipListMap-ConcurrentSkipListSet"><a href="#4-2-5-ConcurrentSkipListMap-ConcurrentSkipListSet" class="headerlink" title="4.2.5 ConcurrentSkipListMap &#x2F; ConcurrentSkipListSet"></a>4.2.5 ConcurrentSkipListMap &#x2F; ConcurrentSkipListSet</h4><ul>
<li><code>ConcurrentSkipListMap</code> 是一个线程安全的、<strong>有序的</strong> <code>Map</code>。</li>
<li>底层数据结构是<strong>跳表 (Skip List)</strong>。跳表是一种可以与平衡树（如红黑树）相媲美的、通过增加多级索引来提高查找效率的链表结构，且实现相对简单。</li>
<li><strong>特点</strong>:<ul>
<li><strong>有序性</strong>：key 是自然排序或根据指定的 <code>Comparator</code> 排序的。</li>
<li><strong>高并发性</strong>：通过 CAS 操作实现，提供了较好的并发性能。</li>
</ul>
</li>
<li><strong>适用场景</strong>:<ul>
<li>需要一个线程安全的、并且<strong>有序</strong>的 Map&#x2F;Set 时。例如，在一个排行榜应用中，需要根据分数动态排序并保证线程安全。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-3-线程同步工具"><a href="#4-3-线程同步工具" class="headerlink" title="4.3 线程同步工具"></a>4.3 线程同步工具</h3><p>除了锁和原子类提供的原子性保证外，JUC 还提供了一些用于多线程协作的同步工具，它们可以帮助我们更精细地控制线程的执行时机和流程。这些工具通常用于解决“一个或多个线程等待其他线程完成某项操作”的场景。</p>
<h4 id="4-3-1-CountDownLatch-倒计时门闩"><a href="#4-3-1-CountDownLatch-倒计时门闩" class="headerlink" title="4.3.1 CountDownLatch - 倒计时门闩"></a>4.3.1 CountDownLatch - 倒计时门闩</h4><p><code>CountDownLatch</code> 就像一个倒数计时器。它允许一个或多个线程等待，直到其他线程完成一系列操作后，再继续执行。</p>
<ul>
<li><p><strong>核心思想</strong>:<br><code>CountDownLatch</code> 在初始化时会设置一个计数值。线程可以通过调用 <code>await()</code> 方法来阻塞等待，直到计数值被减到 0。其他线程则可以通过调用 <code>countDown()</code> 方法来将计数值减 1。这个过程是<strong>一次性</strong>的，一旦计数值变为 0，<code>CountDownLatch</code> 就不能再被重置或重复使用。</p>
</li>
<li><p><strong>比喻</strong>:<br>想象一下火箭发射。主控室（主线程）按下 <code>await()</code> 按钮后进入等待状态。多个子系统的检查员（工作线程）各自进行检查，每完成一项就调用 <code>countDown()</code>。当所有检查员都报告完成（计数值减到 0），主控室的等待结束，火箭点火发射。</p>
</li>
<li><p><strong>核心 API</strong>:</p>
<ul>
<li><code>CountDownLatch(int count)</code>: 构造方法，设置初始计数值。</li>
<li><code>void await()</code>: 阻塞当前线程，直到计数值变为 0。</li>
<li><code>boolean await(long timeout, TimeUnit unit)</code>: 带超时的等待。</li>
<li><code>void countDown()</code>: 将计数值减 1。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>:</p>
<ol>
<li><strong>主线程等待所有子任务完成</strong>：启动多个线程执行子任务，主线程调用 <code>await()</code> 等待所有子任务执行完毕后再汇总结果或继续下一步。</li>
<li><strong>实现最大并行性</strong>：多个线程在 <code>CountDownLatch</code> 上等待，直到某个启动信号发出（调用 <code>countDown()</code>），所有线程才同时开始执行，用于模拟并发测试。</li>
</ol>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 设置计数值为 3</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程：等待所有运动员准备就绪...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;运动员 &quot;</span> + num + <span class="string">&quot; 准备好了&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">2000</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown(); <span class="comment">// 准备完毕，计数减 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await(); <span class="comment">// 主线程阻塞，直到计数值为 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有运动员准备完毕，比赛开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-3-2-CyclicBarrier-循环屏障"><a href="#4-3-2-CyclicBarrier-循环屏障" class="headerlink" title="4.3.2 CyclicBarrier - 循环屏障"></a>4.3.2 CyclicBarrier - 循环屏障</h4><p><code>CyclicBarrier</code> 意为“循环的屏障”。它让一组线程互相等待，直到所有线程都到达一个公共的屏障点（barrier point），然后这些线程再<strong>同时</strong>继续执行。</p>
<ul>
<li><strong>核心思想</strong>:<br>与 <code>CountDownLatch</code> 不同，<code>CyclicBarrier</code> 是<strong>可重用</strong>的。当所有等待的线程都到达屏障后，屏障会被重置，可以用于下一轮的等待。它还可以在所有线程到达屏障时，选择性地执行一个 <code>Runnable</code> 任务。</li>
<li><strong>比喻</strong>:<br>想象一个旅行团约定在某个景点门口集合。每个游客（线程）到达后，调用 <code>await()</code> 方法开始等待。直到所有游客都到达（满足设定的数量），大家才一起进入景点。游览完后，他们可以约定在下一个景点门口再次使用这个“集合”规则。</li>
<li><strong>核心 API</strong>:<ul>
<li><code>CyclicBarrier(int parties)</code>: 构造方法，<code>parties</code> 指的是需要等待的线程数量。</li>
<li><code>CyclicBarrier(int parties, Runnable barrierAction)</code>: 构造方法，增加一个 <code>barrierAction</code>，当所有线程都到达屏障时，会优先执行这个 <code>Runnable</code> 任务。</li>
<li><code>int await()</code>: 线程调用此方法表示已到达屏障，并开始阻塞等待其他线程。</li>
</ul>
</li>
<li><strong>应用场景</strong>:<ol>
<li><strong>多线程数据处理</strong>：在进行大规模数据计算时，可以分阶段进行。用 <code>CyclicBarrier</code> 保证所有线程都完成了当前阶段的计算，才能进入下一阶段。</li>
<li><strong>模拟并发场景</strong>：与 <code>CountDownLatch</code> 类似，可以确保多个线程在同一时刻开始执行任务。</li>
</ol>
</li>
<li><strong><code>CountDownLatch</code> vs <code>CyclicBarrier</code></strong></li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>CountDownLatch</code></th>
<th><code>CyclicBarrier</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用对象</strong></td>
<td>一个或多个线程等待<strong>其他</strong>线程完成操作</td>
<td>一组线程<strong>互相等待</strong></td>
</tr>
<tr>
<td><strong>可重用性</strong></td>
<td><strong>不可重用</strong>，计数值减到0后就失效了</td>
<td><strong>可重用</strong>（循环的）</td>
</tr>
<tr>
<td><strong>核心方法</strong></td>
<td><code>countDown()</code> 和 <code>await()</code></td>
<td><code>await()</code></td>
</tr>
<tr>
<td><strong>功能扩展</strong></td>
<td>无</td>
<td>可以在屏障点执行一个 <code>Runnable</code> 任务</td>
</tr>
<tr>
<td><strong>内部实现</strong></td>
<td>基于 AQS 的共享模式</td>
<td>基于 <code>ReentrantLock</code> 和 <code>Condition</code></td>
</tr>
</tbody></table>
<hr>
<h4 id="4-3-3-Semaphore-信号量"><a href="#4-3-3-Semaphore-信号量" class="headerlink" title="4.3.3 Semaphore - 信号量"></a>4.3.3 Semaphore - 信号量</h4><p><code>Semaphore</code> 用于控制<strong>同时访问</strong>特定资源的线程数量，它通过协调各个线程，以保证合理地使用公共资源。</p>
<ul>
<li><p><strong>核心思想</strong>:<br><code>Semaphore</code> 内部维护了一组“许可”（permits）。线程可以通过 <code>acquire()</code> 方法获取一个许可，如果许可已经用完，线程将被阻塞。当线程使用完资源后，必须通过 <code>release()</code> 方法归还许可。</p>
</li>
<li><p><strong>比喻</strong>:<br><code>Semaphore</code> 就像一个停车场。停车场有固定数量的车位（permits）。车辆（线程）要进入时，需要从入口拿到一个停车许可 (<code>acquire()</code>)。如果车位已满，车辆就得在入口外排队等待。有车离开时，会归还许可 (<code>release()</code>)，等待的车辆才能进入。</p>
</li>
<li><p><strong>核心 API</strong>:</p>
<ul>
<li><code>Semaphore(int permits)</code>: 构造方法，设置许可的数量。</li>
<li><code>Semaphore(int permits, boolean fair)</code>: 可选择公平&#x2F;非公平模式。</li>
<li><code>void acquire()</code>: 获取一个许可，若无可用许可则阻塞。</li>
<li><code>void acquire(int n)</code>: 获取 n 个许可。</li>
<li><code>void release()</code>: 释放一个许可。</li>
<li><code>void release(int n)</code>: 释放 n 个许可。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>:</p>
<ol>
<li><strong>流量控制</strong>：例如，控制同时访问数据库连接的线程数，防止数据库因连接过多而崩溃。</li>
<li><strong>资源池管理</strong>：如连接池、对象池，限制池中资源的最大并发使用数。</li>
<li><strong>服务限流</strong>：在网关或服务入口，限制某个接口的并发请求量。</li>
</ol>
</li>
<li><p><strong>代码示例 (模拟抢车位)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3个车位</span></span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6辆车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">carNum</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire(); <span class="comment">// 抢占车位</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;汽车 &quot;</span> + carNum + <span class="string">&quot; 抢到了车位&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 停车2秒</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;汽车 &quot;</span> + carNum + <span class="string">&quot; 离开了车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release(); <span class="comment">// 释放车位</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-3-4-Exchanger-数据交换器"><a href="#4-3-4-Exchanger-数据交换器" class="headerlink" title="4.3.4 Exchanger - 数据交换器"></a>4.3.4 Exchanger - 数据交换器</h4><p><code>Exchanger</code> 是一个用于两个线程之间交换数据的工具。它提供了一个同步点，在这个同步点，两个线程可以交换彼此的数据。</p>
<ul>
<li><strong>核心思想</strong>:<br>当一个线程调用 <code>exchange(V x)</code> 方法时，它会阻塞等待，直到另一个线程也调用了 <code>exchange()</code> 方法。当两个线程都到达同步点时，它们会交换传递给 <code>exchange()</code> 方法的数据，然后各自返回，拿到对方的数据。</li>
<li><strong>应用场景</strong>（相对较少）:<ol>
<li><strong>数据校对</strong>：两个线程分别从不同来源加载数据到缓冲区，然后通过 <code>Exchanger</code> 交换缓冲区，进行数据比对。</li>
<li><strong>生产者-消费者</strong>：一个线程生产数据到 buffer，另一个线程消费数据。它们可以通过 <code>Exchanger</code> 交换满的 buffer 和空的 buffer，提高效率。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-4-线程池"><a href="#4-4-线程池" class="headerlink" title="4.4 线程池"></a>4.4 线程池</h3><h4 id="4-4-1-概述"><a href="#4-4-1-概述" class="headerlink" title="4.4.1 概述"></a>4.4.1 概述</h4><p>在并发编程中，如果每次需要执行异步任务时都 <code>new Thread()</code>，会存在以下问题：</p>
<ol>
<li><strong>资源消耗</strong>：频繁地创建和销毁线程会消耗大量的系统资源（如内存），因为线程的创建和销毁是有成本的。</li>
<li><strong>性能瓶颈</strong>：创建和销毁线程的开销可能会大于任务本身执行的开销，导致系统响应变慢。</li>
<li><strong>缺乏管理</strong>：无限制地创建线程可能会耗尽系统资源（如内存或 CPU），导致系统崩溃或 <code>OutOfMemoryError</code>。无法对线程进行统一的管理、监控和调优。</li>
</ol>
<p><strong>线程池</strong>就是为了解决这些问题而生的。它是一种池化技术，核心思想是<strong>复用已经创建好的线程</strong>，从而避免频繁创建和销-毁带来的开销。</p>
<p><strong>线程池的好处：</strong></p>
<ul>
<li><strong>降低资源消耗</strong>：通过复用线程，减少了线程创建和销毁的开销。</li>
<li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li>
<li><strong>提高线程的可管理性</strong>：可以对线程进行统一分配、调优和监控，控制最大并发数，防止资源耗尽。</li>
<li><strong>提供更多功能</strong>：支持定时执行、周期性执行、单线程执行、并发数控制等。</li>
</ul>
<hr>
<h4 id="4-4-2-线程池的核心体系-Executor-框架"><a href="#4-4-2-线程池的核心体系-Executor-框架" class="headerlink" title="4.4.2 线程池的核心体系 - Executor 框架"></a>4.4.2 线程池的核心体系 - <code>Executor</code> 框架</h4><p>JUC 中的线程池实现是围绕 <code>Executor</code> 框架展开的。</p>
<ul>
<li><strong><code>Executor</code></strong>: 顶级接口，只定义了一个 <code>execute(Runnable command)</code> 方法，用于提交任务。它将任务提交与任务执行解耦。</li>
<li><strong><code>ExecutorService</code></strong>: <code>Executor</code> 的子接口，增加了对线程池生命周期的管理，如 <code>shutdown()</code>, <code>shutdownNow()</code>, <code>isTerminated()</code> 等，并且可以通过 <code>submit()</code> 方法提交带返回值的 <code>Callable</code> 任务。</li>
<li><strong><code>AbstractExecutorService</code></strong>: <code>ExecutorService</code> 的抽象实现类，实现了 <code>submit()</code> 等方法。</li>
<li><strong><code>ThreadPoolExecutor</code></strong>: <strong>线程池的核心实现类</strong>。绝大多数我们使用的线程池都是该类的实例。</li>
<li><strong><code>ScheduledExecutorService</code></strong>: <code>ExecutorService</code> 的子接口，支持定时及周期性任务执行。</li>
<li><strong><code>ScheduledThreadPoolExecutor</code></strong>: <code>ScheduledExecutorService</code> 的实现类。</li>
<li><strong><code>Executors</code></strong>: <strong>工具类</strong>，提供了快速创建常见配置线程池的静态工厂方法（如 <code>newFixedThreadPool</code>, <code>newSingleThreadExecutor</code> 等）。</li>
</ul>
<hr>
<h4 id="4-4-3-ThreadPoolExecutor-的核心参数"><a href="#4-4-3-ThreadPoolExecutor-的核心参数" class="headerlink" title="4.4.3 ThreadPoolExecutor 的核心参数"></a>4.4.3 <code>ThreadPoolExecutor</code> 的核心参数</h4><p><code>ThreadPoolExecutor</code> 是最核心的实现类，理解它的构造函数参数至关重要。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong><code>corePoolSize</code> (核心线程数)</strong><ul>
<li>线程池中长期保持的线程数量，即使它们处于空闲状态，也不会被销毁（除非设置了 <code>allowCoreThreadTimeOut</code>）。</li>
<li>这是线程池处理任务的主力军。</li>
</ul>
</li>
<li><strong><code>maximumPoolSize</code> (最大线程数)</strong><ul>
<li>线程池能够容纳同时执行的线程最大数量。</li>
<li>当工作队列满了，并且当前线程数小于最大线程数时，线程池会创建新的非核心线程来处理任务。</li>
</ul>
</li>
<li><strong><code>keepAliveTime</code> (空闲线程存活时间)</strong><ul>
<li>当线程池中的线程数量<strong>超过 <code>corePoolSize</code></strong> 时，如果一个非核心线程空闲时间达到 <code>keepAliveTime</code>，它就会被销毁，直到线程数缩减回 <code>corePoolSize</code>。</li>
</ul>
</li>
<li><strong><code>unit</code> (时间单位)</strong><ul>
<li><code>keepAliveTime</code> 的时间单位（如 <code>TimeUnit.SECONDS</code>）。</li>
</ul>
</li>
<li><strong><code>workQueue</code> (工作队列&#x2F;任务队列)</strong><ul>
<li>一个阻塞队列，用于存放<strong>等待执行</strong>的任务。当核心线程都在忙时，新提交的任务会被放入这个队列中。</li>
<li>常用的队列类型：<ul>
<li><code>ArrayBlockingQueue</code>: 基于数组的有界阻塞队列。</li>
<li><code>LinkedBlockingQueue</code>: 基于链表的阻塞队列。如果不指定容量，默认为 <code>Integer.MAX_VALUE</code>，可能导致内存溢出。</li>
<li><code>SynchronousQueue</code>: 不存储元素的阻塞队列，任务直接提交给线程，没有则创建新线程，直到达到 <code>maximumPoolSize</code>。</li>
<li><code>PriorityBlockingQueue</code>: 带有优先级的无界阻塞队列。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>threadFactory</code> (线程工厂)</strong><ul>
<li>用于创建新线程的工厂。可以自定义线程的名称、是否为守护线程、优先级等。</li>
</ul>
</li>
<li><strong><code>handler</code> (拒绝策略)</strong><ul>
<li>当<strong>队列已满</strong>且<strong>线程数已达到 <code>maximumPoolSize</code></strong> 时，线程池会采取的拒绝策略。</li>
<li>内置策略：<ul>
<li><code>AbortPolicy</code> (默认): 直接抛出 <code>RejectedExecutionException</code> 异常，阻止系统正常运行。</li>
<li><code>CallerRunsPolicy</code>: “调用者运行”策略。既不抛弃任务，也不抛出异常，而是将任务回退给调用者（提交任务的线程）来执行。</li>
<li><code>DiscardPolicy</code>: 直接丢弃任务，不予处理也不抛异常。</li>
<li><code>DiscardOldestPolicy</code>: 丢弃队列最前面的任务，然后重新尝试执行当前任务。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-4-4-线程池的工作流程"><a href="#4-4-4-线程池的工作流程" class="headerlink" title="4.4.4 线程池的工作流程"></a>4.4.4 线程池的工作流程</h4><p>当一个新任务通过 <code>execute()</code> 方法提交时：</p>
<ol>
<li><strong>判断核心线程池是否已满？</strong><ul>
<li>如果当前运行的线程数 &lt; <code>corePoolSize</code>，则<strong>创建新核心线程</strong>来执行任务，即使其他核心线程是空闲的。</li>
</ul>
</li>
<li><strong>判断工作队列是否已满？</strong><ul>
<li>如果核心线程池已满（线程数 &gt;&#x3D; <code>corePoolSize</code>），则将任务放入<strong>工作队列 <code>workQueue</code></strong> 中等待。</li>
</ul>
</li>
<li><strong>判断最大线程池是否已满？</strong><ul>
<li>如果工作队列也满了，则判断当前运行的线程数是否 &lt; <code>maximumPoolSize</code>。</li>
<li>如果是，则<strong>创建新的非核心线程</strong>来执行任务。</li>
</ul>
</li>
<li><strong>触发拒绝策略</strong><ul>
<li>如果当前线程数已经达到 <code>maximumPoolSize</code>，则由 <code>RejectedExecutionHandler</code> 来处理这个任务。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-4-5-Executors-工具类与潜在风险"><a href="#4-4-5-Executors-工具类与潜在风险" class="headerlink" title="4.4.5 Executors 工具类与潜在风险"></a>4.4.5 <code>Executors</code> 工具类与潜在风险</h4><p><code>Executors</code> 提供了一些方便的静态方法来创建线程池，但阿里巴巴《Java开发手册》中<strong>强烈建议</strong>开发者通过 <code>ThreadPoolExecutor</code> 的构造函数手动创建线程池，因为 <code>Executors</code> 创建的线程池可能存在资源耗尽的风险。</p>
<ul>
<li><strong><code>Executors.newFixedThreadPool(int nThreads)</code></strong>:<ul>
<li><strong>特点</strong>: 创建一个固定大小的线程池。<code>corePoolSize</code> 和 <code>maximumPoolSize</code> 相等。</li>
<li><strong>队列</strong>: 使用 <code>LinkedBlockingQueue</code> (无界队列)。</li>
<li><strong>风险</strong>: 由于队列是无界的，如果任务提交速度远大于处理速度，会导致大量任务堆积在队列中，可能引发 <strong>OOM (OutOfMemoryError)</strong>。</li>
</ul>
</li>
<li><strong><code>Executors.newSingleThreadExecutor()</code></strong>:<ul>
<li><strong>特点</strong>: 创建一个只有一个线程的线程池。</li>
<li><strong>队列</strong>: 使用 <code>LinkedBlockingQueue</code> (无界队列)。</li>
<li><strong>风险</strong>: 与 <code>newFixedThreadPool</code> 类似，存在 <strong>OOM</strong> 风险。</li>
</ul>
</li>
<li><strong><code>Executors.newCachedThreadPool()</code></strong>:<ul>
<li><strong>特点</strong>: 创建一个可缓存的线程池。<code>corePoolSize</code> 为 0，<code>maximumPoolSize</code> 为 <code>Integer.MAX_VALUE</code>。</li>
<li><strong>队列</strong>: 使用 <code>SynchronousQueue</code>。</li>
<li><strong>工作方式</strong>: 来一个任务，如果没有空闲线程，就创建一个新线程来处理。空闲线程存活 60 秒。</li>
<li><strong>风险</strong>: <code>maximumPoolSize</code> 设置为几乎无限大，如果短时间内有大量任务涌入，会创建大量线程，可能耗尽系统资源，导致 <strong>OOM</strong>。</li>
</ul>
</li>
<li><strong><code>Executors.newScheduledThreadPool(int corePoolSize)</code></strong>:<ul>
<li><strong>特点</strong>: 创建一个支持定时及周期性任务执行的线程池。</li>
<li><strong>风险</strong>: 与 <code>newCachedThreadPool</code> 类似，<code>maximumPoolSize</code> 也是 <code>Integer.MAX_VALUE</code>，存在 <strong>OOM</strong> 风险。</li>
</ul>
</li>
</ul>
<p><strong>最佳实践</strong>：根据业务场景，明确线程池的核心参数，<strong>手动创建 <code>ThreadPoolExecutor</code></strong>。这样可以避免资源耗尽的风险，让线程池的行为更加可控。</p>
<p><strong>如何合理配置线程池参数？</strong></p>
<ul>
<li><strong>CPU密集型任务</strong> (大量计算): <code>corePoolSize</code> &#x3D; CPU核心数 + 1。这能保证 CPU 的高效利用，+1 是为了防止线程因偶尔的页错误或其他原因阻塞时，CPU能有其他线程顶上。</li>
<li><strong>I&#x2F;O密集型任务</strong> (网络请求、文件读写): <code>corePoolSize</code> 可以设置得更大，通常是 CPU 核心数的数倍。因为线程在执行 I&#x2F;O 操作时会阻塞，CPU 处于空闲状态，可以切换到其他线程执行任务。一个经验公式是：<code>CPU核心数 * (1 + 平均等待时间 / 平均计算时间)</code>。</li>
</ul>
<hr>
<h4 id="4-4-6-关闭线程池"><a href="#4-4-6-关闭线程池" class="headerlink" title="4.4.6 关闭线程池"></a>4.4.6 关闭线程池</h4><ul>
<li><strong><code>shutdown()</code></strong>: 平滑关闭。不再接受新任务，但会等待已提交到队列中的任务执行完毕。</li>
<li><strong><code>shutdownNow()</code></strong>: 立即关闭。尝试停止所有正在执行的任务（通过 <code>Thread.interrupt()</code>），并返回队列中未执行的任务列表。不保证正在执行的任务一定能成功停止。</li>
</ul>
<hr>
<h3 id="4-5-ThreadLocal"><a href="#4-5-ThreadLocal" class="headerlink" title="4.5 ThreadLocal"></a>4.5 ThreadLocal</h3><h4 id="4-5-1-概述"><a href="#4-5-1-概述" class="headerlink" title="4.5.1. 概述"></a>4.5.1. 概述</h4><p><code>ThreadLocal</code>，直译为“线程本地变量”，它提供了一种创建<strong>线程私有变量</strong>的机制。对于一个 <code>ThreadLocal</code> 变量，每个使用该变量的线程都会拥有一个独立的、私有的副本。一个线程无法访问或修改其他线程的 <code>ThreadLocal</code> 变量副本。</p>
<p><strong>核心思想</strong>：<br><code>ThreadLocal</code> 并非用于解决多线程共享变量的并发问题，恰恰相反，它通过“<strong>空间换时间</strong>”的方式，为每个线程都提供一份变量的副本，从而避免了多线程之间的竞争和同步开销。它是一种<strong>线程隔离</strong>的解决方案。</p>
<p><strong>与 <code>synchronized</code> 的对比</strong>：</p>
<ul>
<li><code>synchronized</code>：通过加锁来保证在同一时间只有一个线程能访问共享变量，是一种“<strong>时间换空间</strong>”的策略，多个线程排队访问同一个变量。</li>
<li><code>ThreadLocal</code>：为每个线程创建独立的变量副本，线程之间互不干扰，是一种“<strong>空间换时间</strong>”的策略，多个线程同时访问各自的变量。</li>
</ul>
<h4 id="4-5-2-核心API"><a href="#4-5-2-核心API" class="headerlink" title="4.5.2 核心API"></a>4.5.2 核心API</h4><p><code>ThreadLocal</code> 的使用非常简单，主要有以下几个方法：</p>
<ul>
<li><code>void set(T value)</code>: 为当前线程设置一个线程本地变量的值。</li>
<li><code>T get()</code>: 获取当前线程对应的线程本地变量的值。如果当前线程是第一次调用 <code>get</code>，它会通过调用 <code>initialValue()</code> 方法来获取初始值。</li>
<li><code>void remove()</code>: 移除当前线程的线程本地变量的值。<strong>这是一个非常重要的方法，用于防止内存泄漏。</strong></li>
<li><code>protected T initialValue()</code>: 返回该线程局部变量的初始值。该方法是一个 <code>protected</code> 方法，一般是开发人员在使用时通过匿名内部类的方式覆盖它，指定初始值。默认实现是返回 <code>null</code>。</li>
</ul>
<p><strong>使用示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个 ThreadLocal 变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; userContext = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以通过覆盖 initialValue() 来设置默认值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; idContext = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            userContext.set(<span class="string">&quot;User-&quot;</span> + threadName); <span class="comment">// 2. 为当前线程设置值</span></span><br><span class="line">            idContext.set((<span class="type">int</span>)(Math.random() * <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">            System.out.println(threadName + <span class="string">&quot; 的 user 是: &quot;</span> + userContext.get());</span><br><span class="line">            System.out.println(threadName + <span class="string">&quot; 的 id 是: &quot;</span> + idContext.get());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 使用完毕后，务必调用 remove()</span></span><br><span class="line">            userContext.remove();</span><br><span class="line">            idContext.remove();</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出（顺序可能不同）：</span></span><br><span class="line"><span class="comment">// Thread-A 的 user 是: User-Thread-A</span></span><br><span class="line"><span class="comment">// Thread-A 的 id 是: ...</span></span><br><span class="line"><span class="comment">// Thread-B 的 user 是: User-Thread-B</span></span><br><span class="line"><span class="comment">// Thread-B 的 id 是: ...</span></span><br></pre></td></tr></table></figure>

<p>从输出可以看出，<code>Thread-A</code> 和 <code>Thread-B</code> 各自拥有独立的 <code>userContext</code> 和 <code>idContext</code> 副本，互不影响。</p>
<hr>
<h4 id="4-5-3-ThreadLocal-的实现原理"><a href="#4-5-3-ThreadLocal-的实现原理" class="headerlink" title="4.5.3 ThreadLocal 的实现原理"></a>4.5.3 ThreadLocal 的实现原理</h4><p>要理解 <code>ThreadLocal</code> 的原理，必须深入其源码，关键在于 <code>Thread</code>、<code>ThreadLocal</code> 和 <code>ThreadLocalMap</code> 这三者的关系。</p>
<ol>
<li><p><strong><code>Thread</code> 类</strong>:<br>每个 <code>Thread</code> 对象内部都有一个成员变量 <code>threadLocals</code>，它的类型是 <code>ThreadLocal.ThreadLocalMap</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread.java</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>这个 <code>threadLocals</code> 变量存储了该线程所有 <code>ThreadLocal</code> 变量的副本。</p>
</li>
<li><p><strong><code>ThreadLocalMap</code> 类</strong>:<br><code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的一个静态内部类，它是一个定制版的 <code>HashMap</code>。</p>
<ul>
<li><strong>Key</strong>: <code>ThreadLocal</code> 对象本身，并且是一个<strong>弱引用 (WeakReference)</strong>。</li>
<li><strong>Value</strong>: 线程需要存储的变量副本。</li>
</ul>
</li>
<li><p><strong>工作流程</strong>:</p>
<ul>
<li><strong><code>set(value)</code></strong>: 当一个线程调用 <code>threadLocal.set(value)</code> 时，实际上是：<ol>
<li>获取当前线程 <code>Thread.currentThread()</code>。</li>
<li>通过当前线程获取其内部的 <code>ThreadLocalMap</code> 对象 <code>threadLocals</code>。</li>
<li>如果 <code>threadLocals</code> 为 null，则创建一个新的 <code>ThreadLocalMap</code> 并赋给当前线程。</li>
<li>以 <code>threadLocal</code> 对象本身作为 key，<code>value</code> 作为值，存入 <code>threadLocals</code> 这个 Map 中。</li>
</ol>
</li>
<li><strong><code>get()</code></strong>: 调用 <code>threadLocal.get()</code> 时：<ol>
<li>获取当前线程的 <code>ThreadLocalMap</code>。</li>
<li>以 <code>threadLocal</code> 对象为 key，从 Map 中查找对应的 Entry。</li>
<li>如果找到，返回 Entry 的 value；如果找不到（或 Map 为 null），则返回 <code>initialValue()</code> 的值。</li>
</ol>
</li>
</ul>
</li>
</ol>
<p><strong>总结关系</strong>：每个 <code>Thread</code> 持有一个 <code>ThreadLocalMap</code>，这个 Map 的 Key 是 <code>ThreadLocal</code> 实例，Value 是线程私有的变量副本。<code>ThreadLocal</code> 本身不存储任何数据，它只是一个“钥匙”，用来从当前线程的 Map 中存取数据。</p>
<hr>
<h4 id="4-5-4-内存泄漏问题"><a href="#4-5-4-内存泄漏问题" class="headerlink" title="4.5.4 内存泄漏问题"></a>4.5.4 内存泄漏问题</h4><p><strong>什么是内存泄漏？</strong><br>一个对象已经不再被使用，但由于存在其他对象的强引用，导致垃圾回收器（GC）无法回收它，这个对象所占用的内存就泄漏了。</p>
<p><strong>ThreadLocal 为什么会内存泄漏？</strong><br>前面提到，<code>ThreadLocalMap</code> 的 <strong>key</strong> 是对 <code>ThreadLocal</code> 对象的<strong>弱引用</strong>。</p>
<ul>
<li><strong>弱引用 (WeakReference)</strong>: 当一个对象只被弱引用指向时，下一次垃圾回收发生时，无论内存是否充足，这个对象都会被回收。</li>
</ul>
<p><strong>泄漏过程分析</strong>：</p>
<ol>
<li>当 <code>threadLocal</code> 对象在外部作用域不再被使用时（例如，<code>threadLocal = null</code>），它会变成一个只有 <code>ThreadLocalMap</code> 中的弱引用指向的对象。</li>
<li>下一次 GC 发生时，这个 <code>ThreadLocal</code> 对象（作为 key）就会被回收。此时，<code>ThreadLocalMap</code> 中就会出现 <strong>key 为 null</strong> 的 Entry。</li>
<li><strong>问题来了</strong>：虽然 key 被回收了，但 Entry 中的 <strong>value</strong> 仍然存在一条从 <code>Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; value</code> 的<strong>强引用链</strong>。</li>
<li>只要这个线程不消亡，这个强引用链就一直存在，导致 <strong>value 对象无法被回收</strong>，从而造成内存泄漏。</li>
</ol>
<p><strong>为什么 Key 要设计成弱引用？</strong><br>这是一个权衡。如果 key 是强引用，那么即使 <code>threadLocal</code> 对象在外部被置为 null，<code>ThreadLocalMap</code> 依然持有它的强引用，<code>ThreadLocal</code> 对象本身也无法被回收。相比之下，弱引用至少能保证 <code>ThreadLocal</code> 对象本身被回收。<code>ThreadLocalMap</code> 在其 <code>set</code>, <code>get</code>, <code>remove</code> 方法中，会顺便检查并清理那些 key 为 null 的 Entry，这是一种<strong>补偿机制</strong>。</p>
<p><strong>如何避免内存泄漏？</strong><br>最根本、最有效的解决方法是：<strong>在每次使用完 <code>ThreadLocal</code> 后，手动调用 <code>remove()</code> 方法</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;Object&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    tl.set(<span class="keyword">new</span> <span class="title class_">MyObject</span>());</span><br><span class="line">    <span class="comment">// ... use tl.get() ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    tl.remove(); <span class="comment">// 保证在任何情况下都能清理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>remove()</code> 方法会把当前线程的 <code>ThreadLocalMap</code> 中对应的 Entry（包括 key 和 value）都移除，从而彻底断开引用链，避免内存泄漏。特别是在使用<strong>线程池</strong>的场景下，这一点尤为重要，因为线程池中的线程是会被复用的，如果不清理 <code>ThreadLocal</code> 变量，上一个任务的脏数据可能会被下一个任务读取到，并且内存泄漏会不断累积。</p>
<hr>
<h4 id="4-5-6-InheritableThreadLocal"><a href="#4-5-6-InheritableThreadLocal" class="headerlink" title="4.5.6 InheritableThreadLocal"></a>4.5.6 InheritableThreadLocal</h4><p><code>ThreadLocal</code> 的一个问题是，父线程中设置的值，在子线程中无法获取。<code>InheritableThreadLocal</code> 类解决了这个问题。</p>
<p>当父线程创建一个子线程时，<code>InheritableThreadLocal</code> 会将父线程中存储的本地变量值复制一份给子线程。注意，这只是在<strong>创建子线程时</strong>的一次性复制，之后父子线程的变量副本就是独立的了。</p>
<p><strong>应用场景</strong>：<br>在一些需要将上下文信息（如用户身份、请求ID、事务信息等）从父线程传递到子线程的场景中非常有用。例如，在使用线程池异步处理任务时，希望子线程也能获取到主线程的上下文信息。</p>
<hr>
<h2 id="5-实践与总结"><a href="#5-实践与总结" class="headerlink" title="5. 实践与总结"></a>5. 实践与总结</h2><h3 id="5-1-死锁"><a href="#5-1-死锁" class="headerlink" title="5.1 死锁"></a>5.1 死锁</h3><h4 id="5-1-1-概述"><a href="#5-1-1-概述" class="headerlink" title="5.1.1 概述"></a>5.1.1 概述</h4><p><strong>死锁</strong> 是指在并发环境中，两个或多个线程（或进程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干预，它们都将无法继续向前推进。</p>
<p>一个经典的死锁场景可以这样描述：</p>
<blockquote>
<p><strong>线程 A 持有锁 1，并且正在尝试获取锁 2；与此同时，线程 B 持有锁 2，并正在尝试获取锁 1。</strong></p>
</blockquote>
<p>由于两个线程都在等待对方释放自己需要的锁，但它们自己又都持有对方需要的锁不肯释放，这就形成了一个**“僵局”**，导致两个线程都永远地阻塞下去。</p>
<hr>
<h4 id="5-1-2-死锁的四个必要条件"><a href="#5-1-2-死锁的四个必要条件" class="headerlink" title="5.1.2 死锁的四个必要条件"></a>5.1.2 死锁的四个必要条件</h4><p>死锁的发生必须<strong>同时满足</strong>以下四个条件。只要破坏其中任意一个，就可以预防死锁的发生。</p>
<ol>
<li><strong>互斥条件 (Mutual Exclusion)</strong><ul>
<li><strong>定义</strong>：一个资源在同一时刻只能被一个线程占用。当一个线程已经占用了该资源，其他任何试图获取该资源的线程都必须等待，直到资源被释放。</li>
<li><strong>生活类比</strong>：一间只有一个座位的厕所，一次只能进去一个人。</li>
<li><strong>在Java中</strong>：<code>synchronized</code> 关键字和 <code>JUC</code> 包下的各种 <code>Lock</code> 实现都满足互斥条件。</li>
</ul>
</li>
<li><strong>请求与保持条件 (Hold and Wait)</strong><ul>
<li><strong>定义</strong>：一个线程在已经持有了<strong>至少一个</strong>资源的情况下，又去请求其他资源。如果请求的资源被其他线程占用，那么该线程会进入阻塞状态，并且在等待期间<strong>不会释放</strong>自己已经持有的资源。</li>
<li><strong>生活类比</strong>：你左手拿着筷子，又想去拿勺子，但勺子被别人拿着，你不会放下筷子，而是拿着筷子干等着。</li>
</ul>
</li>
<li><strong>非剥夺条件 (No Preemption)</strong><ul>
<li><strong>定义</strong>：线程已经获得的资源，在未使用完毕之前，不能被其他线程强行剥夺。只能由持有资源的线程自己主动释放。</li>
<li><strong>生活类比</strong>：别人不能从你手里强行抢走你正在使用的筷子，只能等你用完自己放下。</li>
</ul>
</li>
<li><strong>循环等待条件 (Circular Wait)</strong><ul>
<li><strong>定义</strong>：存在一个线程—资源的循环等待链。线程集合 {T0, T1, T2, …, Tn} 中，T0 在等待 T1 持有的资源，T1 在等待 T2 持有的资源，…，Tn 在等待 T0 持有的资源，形成一个闭环。</li>
<li><strong>生活类比</strong>：A 等 B，B 等 C，C 又在等 A。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-1-3-示例"><a href="#5-1-3-示例" class="headerlink" title="5.1.3 示例"></a>5.1.3 示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线程 1</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 持有 lockA，尝试获取 lockB...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 制造一些耗时操作，给另一个线程获取 lockB 的机会</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 成功获取 lockA 和 lockB！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程 2</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 持有 lockB，尝试获取 lockA...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 成功获取 lockB 和 lockA！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread finished.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Main thread finished.</span><br><span class="line">线程A 持有 lockA，尝试获取 lockB...</span><br><span class="line">线程B 持有 lockB，尝试获取 lockA...</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-1-4-如何排查死锁"><a href="#5-1-4-如何排查死锁" class="headerlink" title="5.1.4 如何排查死锁"></a>5.1.4 如何排查死锁</h4><p>当线上应用出现无响应、CPU利用率不高但线程数很多等情况时，就需要怀疑是否发生了死锁。JDK 提供了强大的命令行工具来帮助我们定位问题。</p>
<ol>
<li><p><strong>使用 <code>jps</code> 找到 Java 进程 ID (PID)</strong></p>
<p>在命令行中输入 <code>jps -l</code>，可以列出所有正在运行的 Java 进程及其 PID。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jps -l</span><br><span class="line">18872 com.example.DeadlockDemo  &lt;-- 找到我们的死锁程序PID</span><br><span class="line">12345 sun.tools.jps.Jps</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>jstack</code> 分析线程堆栈</strong></p>
<p><code>jstack</code> 是排查 Java 线程问题的神器，它可以打印出指定 PID 进程的线程堆栈信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstack 18872</span><br></pre></td></tr></table></figure>

<p>如果存在死锁，<code>jstack</code> 会在输出的末尾明确地检测出来并给出详细报告。</p>
<p><strong><code>jstack</code> 输出示例：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">... (前面是所有线程的堆栈信息)</span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;线程B&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007f9a8c003d08 (object 0x000000076acb3a00, a java.lang.Object),</span><br><span class="line">  which is held by &quot;线程A&quot;</span><br><span class="line">&quot;线程A&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007f9a8c006378 (object 0x000000076acb3a10, a java.lang.Object),</span><br><span class="line">  which is held by &quot;线程B&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;线程B&quot;:</span><br><span class="line">    at com.example.DeadlockDemo.lambda$main$1(DeadlockDemo.java:35)</span><br><span class="line">    - waiting to lock &lt;0x000000076acb3a00&gt; (a java.lang.Object)</span><br><span class="line">    - locked &lt;0x000000076acb3a10&gt; (a java.lang.Object)</span><br><span class="line">    at com.example.DeadlockDemo$$Lambda$2/0x0000000800061440.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;线程A&quot;:</span><br><span class="line">    at com.example.DeadlockDemo.lambda$main$0(DeadlockDemo.java:21)</span><br><span class="line">    - waiting to lock &lt;0x000000076acb3a10&gt; (a java.lang.Object)</span><br><span class="line">    - locked &lt;0x000000076acb3a00&gt; (a java.lang.Object)</span><br><span class="line">    at com.example.DeadlockDemo$$Lambda$1/0x0000000800060c40.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<p>从这份报告中，我们可以清晰地看到：</p>
<ul>
<li><code>&quot;线程B&quot;</code> 正在等待一个锁 (<code>0x...3a00</code>)，而这个锁正被 <code>&quot;线程A&quot;</code> 持有。</li>
<li><code>&quot;线程A&quot;</code> 正在等待另一个锁 (<code>0x...3a10</code>)，而这个锁正被 <code>&quot;线程B&quot;</code> 持有。</li>
<li>报告还指出了发生等待的代码行号 (<code>DeadlockDemo.java:35</code> 和 <code>DeadlockDemo.java:21</code>)。</li>
</ul>
</li>
<li><p><strong>使用图形化工具 (JConsole, VisualVM)</strong></p>
<p>JDK 自带的 JConsole 或功能更强大的 VisualVM 也提供了图形化的线程监控和死锁检测功能。连接到目标 Java 进程后，在 “线程” (Threads) 标签页下，通常会有一个 “检测死锁” (Detect Deadlock) 的按钮，点击后可以直观地看到死锁的线程和它们之间的依赖关系。</p>
</li>
</ol>
<hr>
<h4 id="5-1-5-如何预防和避免死锁"><a href="#5-1-5-如何预防和避免死锁" class="headerlink" title="5.1.5 如何预防和避免死锁"></a>5.1.5 如何预防和避免死锁</h4><p>预防死锁的核心思想是<strong>破坏其四个必要条件中的至少一个</strong>。</p>
<ol>
<li><p><strong>破坏“循环等待”条件（最常用）</strong></p>
<ul>
<li><p><strong>方法</strong>：<strong>按序加锁 (Lock Ordering)</strong>。规定所有线程必须按照一个全局统一的、固定的顺序来获取锁。</p>
</li>
<li><p><strong>示例</strong>：在上面的例子中，我们可以规定：无论在哪个线程中，都必须先获取 <code>lockA</code>，再获取 <code>lockB</code>。</p>
</li>
<li><p><strong>修复后的代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程 B 的代码修改为</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 同样先获取 lockA</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 持有 lockA，尝试获取 lockB...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再获取 lockB</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 成功获取 lockA 和 lockB！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;线程B&quot;</span>).start();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原理</strong>：线程 B 现在也会先尝试获取 <code>lockA</code>。如果 <code>lockA</code> 被线程 A 持有，线程 B 就会在获取第一个锁时就阻塞，而不会持有 <code>lockB</code> 再去请求 <code>lockA</code>，从而打破了循环等待的链条。</p>
</li>
</ul>
</li>
<li><p><strong>破坏“请求与保持”条件</strong></p>
<ul>
<li><p><strong>方法</strong>：一次性申请所有需要的资源。如果不能一次性获得所有资源，则一个都不占有。</p>
</li>
<li><p><strong>实现</strong>：这种方式在 <code>synchronized</code> 关键字上很难直接实现。但可以使用 <code>JUC</code> 下的 <code>Lock</code> 接口。例如，<code>ReentrantLock</code> 的 <code>tryLock()</code> 方法。</p>
</li>
<li><p><strong>示例 (使用 <code>tryLock</code>)</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lockA.tryLock()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lockB.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 成功获取两个锁，执行业务逻辑</span></span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 退出循环</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lockB.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lockA.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取锁失败，可以等待一小段时间后重试，避免活锁</span></span><br><span class="line">    Thread.sleep(<span class="number">10</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原理</strong>：<code>tryLock()</code> 会立即返回获取锁的结果（<code>true</code> 或 <code>false</code>），而不是一直阻塞。如果获取 <code>lockB</code> 失败，线程会释放已经持有的 <code>lockA</code>，然后重试，这就破坏了“持有并等待”的条件。</p>
</li>
</ul>
</li>
<li><p><strong>破坏“非剥夺”条件</strong></p>
<ul>
<li><strong>方法</strong>：当一个线程请求的资源不可得时，它可以主动释放已经占有的资源。</li>
<li><strong>实现</strong>：这和使用 <code>tryLock()</code> 的思想类似。<code>synchronized</code> 是非剥夺的，一旦持有锁，除非代码块执行完毕或抛出异常，否则不会释放。而 <code>Lock</code> 接口提供了可中断的 (<code>lockInterruptibly()</code>) 和可超时的 (<code>tryLock(long time, TimeUnit unit)</code>) 获取锁的方式，这些方式提供了从阻塞状态中退出的能力，从而可以手动释放已持有的锁，间接实现了“剥夺”。</li>
</ul>
</li>
<li><p><strong>破坏“互斥”条件</strong></p>
<ul>
<li><strong>方法</strong>：允许资源被多个线程同时访问。</li>
<li><strong>实现</strong>：这在大多数场景下是不可行的，因为我们使用锁的目的就是为了保证互斥。但可以考虑使用更乐观的并发策略，如使用 <strong>CAS (Compare-And-Swap)</strong> 操作（详见 <code>4.1 原子操作类</code>），它不涉及阻塞，也就不存在死锁问题。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="5-2-线程安全的设计方式"><a href="#5-2-线程安全的设计方式" class="headerlink" title="5.2 线程安全的设计方式"></a>5.2 线程安全的设计方式</h3><p><strong>线程安全</strong>的核心在于<strong>正确地管理共享的可变状态 (Shared Mutable State)</strong>。当多个线程需要访问和修改同一个对象或数据时，如果没有采取正确的措施，就会导致数据不一致、程序崩溃等各种问题。</p>
<p>设计线程安全的代码，本质上就是围绕如何处理这个“共享的可变状态”来展开。主要的设计思路可以分为三大类：<strong>避免共享、不可变、安全共享</strong>。</p>
<h4 id="5-2-1-避免共享-Avoid-Sharing-从根源上杜绝问题"><a href="#5-2-1-避免共享-Avoid-Sharing-从根源上杜绝问题" class="headerlink" title="5.2.1 避免共享 (Avoid Sharing) - 从根源上杜绝问题"></a>5.2.1 避免共享 (Avoid Sharing) - 从根源上杜绝问题</h4><p>这是最简单、最安全的策略。如果没有共享数据，那么每个线程操作的都是自己的数据，自然就不会有线程安全问题。</p>
<h5 id="1-栈封闭-Stack-Confinement"><a href="#1-栈封闭-Stack-Confinement" class="headerlink" title="1. 栈封闭 (Stack Confinement)"></a>1. 栈封闭 (Stack Confinement)</h5><ul>
<li><p><strong>概念</strong>：将数据完全限制在线程的栈（Stack）上。最典型的就是方法的<strong>局部变量</strong>。</p>
</li>
<li><p><strong>原理</strong>：每个线程都有自己独立的虚拟机栈，局部变量存储在栈帧中，是线程私有的，其他线程无法访问。因此，局部变量永远是线程安全的。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// userRequest 和 connection 都是局部变量，是线程安全的</span></span><br><span class="line">    <span class="type">UserRequest</span> <span class="variable">userRequest</span> <span class="operator">=</span> parseRequest();</span><br><span class="line">    <span class="type">DBConnection</span> <span class="variable">connection</span> <span class="operator">=</span> connectionManager.getConnection();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在方法内部使用，不会被其他线程访问</span></span><br><span class="line">    connection.execute(userRequest.getSql());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意</strong>：如果局部变量是一个<strong>对象引用</strong>，要确保这个对象没有“逃逸”(escape)出当前方法的作用域，即没有被赋值给类的成员变量，或者作为返回值返回给其他线程可能访问的地方。</p>
</li>
</ul>
<hr>
<h5 id="2-线程封闭-Thread-Confinement"><a href="#2-线程封闭-Thread-Confinement" class="headerlink" title="2. 线程封闭 (Thread Confinement)"></a>2. 线程封闭 (Thread Confinement)</h5><ul>
<li><p><strong>概念</strong>：当无法使用栈封闭时，可以通过设计将一个可变对象“封闭”或“限制”在单个线程内部，不允许其他线程访问它。</p>
</li>
<li><p><strong>实现方式</strong>：</p>
<ul>
<li><strong>Ad-hoc 线程封闭</strong>：这是一种纯粹靠程序设计纪律来保证的线程封闭。例如，在一个单线程的 Executor 中处理任务，所有任务操作的对象都自然地被封闭在该 Executor 的工作线程中。这种方式非常脆弱，需要团队有严格的编码规范。</li>
<li><strong><code>ThreadLocal</code> 类</strong>：这是实现线程封闭的强大工具。<code>ThreadLocal</code> 为每个使用该变量的线程都提供一个独立的变量副本，每个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</li>
</ul>
</li>
<li><p><strong><code>ThreadLocal</code> 经典应用</strong>：</p>
<ol>
<li><strong>管理数据库连接</strong>：在每个线程中保存自己的数据库连接，避免了连接的频繁创建和关闭，也避免了多线程使用同一个连接的冲突。</li>
<li><strong>保存用户身份信息</strong>：在 Web 应用中，可以将当前登录用户的信息存放在 <code>ThreadLocal</code> 中，这样在业务逻辑的任何深层调用中都可以方便地获取，而无需通过方法参数层层传递。</li>
</ol>
</li>
<li><p><strong><code>ThreadLocal</code> 示例与注意事项</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserContextHolder</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 ThreadLocal 变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; holder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        holder.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 关键：用完后务必清理，防止内存泄漏</span></span><br><span class="line">        holder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Web 过滤器或拦截器中使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getUserFromRequest(req);</span><br><span class="line">        UserContextHolder.set(user);</span><br><span class="line">        chain.doFilter(req, res);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 必须在 finally 块中调用 remove()</span></span><br><span class="line">        UserContextHolder.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心注意点：在使用线程池的场景下，线程是会被复用的。如果不调用<code>remove()</code>，那么上一个请求在该线程中设置的数据会“污染”下一个使用该线程的请求，并可能导致内存泄漏。</p>
</li>
</ul>
<hr>
<h4 id="5-2-2-不可变-Immutability-让共享变得安全"><a href="#5-2-2-不可变-Immutability-让共享变得安全" class="headerlink" title="5.2.2 不可变 (Immutability) - 让共享变得安全"></a>5.2.2 不可变 (Immutability) - 让共享变得安全</h4><p>如果共享的数据是不可变的，那么它天生就是线程安全的。因为所有线程都只能读取它，不能修改它，所以无论多少线程同时访问，都不会产生数据不一致的问题。</p>
<ul>
<li><p><strong>定义</strong>：一个对象的状态在创建之后就不能再被修改。</p>
</li>
<li><p><strong>实现不可变对象的规则</strong>：</p>
<ol>
<li>类声明为 <code>final</code>，防止被继承。</li>
<li>所有成员变量都声明为 <code>private</code> 和 <code>final</code>。</li>
<li>不提供任何可以修改状态的 “setter” 方法。</li>
<li>如果成员变量是可变对象（如 <code>Date</code>, <code>List</code>），在构造函数和 getter 方法中要进行<strong>防御性拷贝 (Defensive Copy)</strong>，确保外部代码无法通过引用修改内部状态。</li>
</ol>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ImmutableUserInfo</span> &#123; <span class="comment">// 1. final class</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;         <span class="comment">// 2. private final 字段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; permissions; <span class="comment">// 4. 可变对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImmutableUserInfo</span><span class="params">(String name, <span class="type">int</span> age, List&lt;String&gt; permissions)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="comment">// 4. 构造时进行防御性拷贝</span></span><br><span class="line">        <span class="built_in">this</span>.permissions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(permissions); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 只有 getter, 没有 setter</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getPermissions</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 4. 返回时也进行防御性拷贝</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(permissions); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>JDK 中的例子</strong>：<code>String</code>、<code>Integer</code> 等包装类。</p>
</li>
</ul>
<hr>
<h4 id="5-2-3-安全共享-Safe-Sharing-精细化管理并发访问"><a href="#5-2-3-安全共享-Safe-Sharing-精细化管理并发访问" class="headerlink" title="5.2.3 安全共享 (Safe Sharing) - 精细化管理并发访问"></a>5.2.3 安全共享 (Safe Sharing) - 精细化管理并发访问</h4><p>当状态必须是可变且共享的时候，我们就需要使用同步机制来保证线程安全。</p>
<h5 id="1-同步-Synchronization"><a href="#1-同步-Synchronization" class="headerlink" title="1. 同步 (Synchronization)"></a>1. 同步 (Synchronization)</h5><p>使用锁来保证在同一时刻，只有一个线程可以访问共享的可变状态。</p>
<ul>
<li><p><strong><code>synchronized</code> 关键字</strong>：</p>
<ul>
<li><strong>同步方法</strong>：<code>public synchronized void increment() { count++; }</code>，锁是当前对象实例 (<code>this</code>)。</li>
<li><strong>同步代码块</strong>：<code>synchronized(lockObject) { ... }</code>，提供更细粒度的控制，锁是 <code>lockObject</code> 对象。</li>
<li><strong>最佳实践</strong>：<ol>
<li><strong>减小锁的粒度</strong>：<code>synchronized</code> 代码块应尽可能小，只包含必须同步的代码，以提高并发性。</li>
<li><strong>使用私有锁对象</strong>：<code>private final Object lock = new Object();</code>，避免使用 <code>this</code> 或公开的对象作为锁，防止外部代码无意中获取了你的锁而导致死锁或活性问题。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>JUC <code>Lock</code> 接口 (<code>ReentrantLock</code> 等)</strong>：</p>
<ul>
<li><p>相比 <code>synchronized</code> 提供了更高级的功能，如：可中断的锁获取、可超时的锁获取、公平性选择、一个锁绑定多个条件变量 (Condition)。</p>
</li>
<li><p><strong>标准使用范式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performAction</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ... 访问共享资源的代码 ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 必须在 finally 块中释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-使用线程安全的容器"><a href="#2-使用线程安全的容器" class="headerlink" title="2. 使用线程安全的容器"></a>2. 使用线程安全的容器</h5><p>JDK 在 <code>java.util.concurrent</code> (JUC) 包中提供了大量高性能的线程安全容器，应当优先使用它们，而不是自己去同步 <code>ArrayList</code> 或 <code>HashMap</code>。</p>
<ul>
<li><code>ConcurrentHashMap</code>：高性能的线程安全哈希表，是 <code>Hashtable</code> 和 <code>Collections.synchronizedMap</code> 的优选替代品。</li>
<li><code>CopyOnWriteArrayList</code>：<strong>读多写少</strong>场景下的利器。读取操作完全不加锁，性能极高。写入操作（add, set, remove）时，会复制一份底层数组，在新数组上修改，然后将引用指向新数组。写入成本高，但保证了读写的绝对分离。非常适合用于事件监听器列表等场景。</li>
<li><code>BlockingQueue</code> (如 <code>ArrayBlockingQueue</code>, <code>LinkedBlockingQueue</code>)：阻塞队列，是实现<strong>生产者-消费者</strong>模式的基石，线程池的内部实现也依赖它。它封装了所有同步细节，使用者只需调用 <code>put()</code> 和 <code>take()</code> 方法即可。</li>
</ul>
<hr>
<h5 id="3-使用原子变量-Atomic-Variables"><a href="#3-使用原子变量-Atomic-Variables" class="headerlink" title="3. 使用原子变量 (Atomic Variables)"></a>3. 使用原子变量 (Atomic Variables)</h5><p>对于简单的、单一的数值操作（如计数器），使用锁的开销可能过大。JUC 的 <code>java.util.concurrent.atomic</code> 包提供了一系列原子类。</p>
<ul>
<li><p><strong>原理</strong>：基于硬件级别的 <strong>CAS (Compare-And-Swap)</strong> 指令，这是一种乐观的、非阻塞的同步技术。</p>
</li>
<li><p><strong>示例</strong>：实现一个线程安全的计数器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不安全的计数器</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123; count++; &#125; <span class="comment">// 非原子操作，线程不安全</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 AtomicInteger 的安全计数器</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">safeIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    atomicCount.incrementAndGet(); <span class="comment">// 原子操作，线程安全</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点</strong>：在高并发下，性能通常优于基于锁的实现，因为它避免了线程的阻塞和上下文切换。</p>
</li>
</ul>
<hr>
<h4 id="5-2-4-原子性问题"><a href="#5-2-4-原子性问题" class="headerlink" title="5.2.4 原子性问题"></a>5.2.4 原子性问题</h4><p>一个或多个操作，要么全部执行成功，要么全部不执行，中间不能被任何其他线程中断。</p>
<h5 id="1-发生原子性错误的代码"><a href="#1-发生原子性错误的代码" class="headerlink" title="1. 发生原子性错误的代码"></a>1. 发生原子性错误的代码</h5><p>在这个版本中，共享变量 <code>count</code> 没有使用任何同步机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicityErrorExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非原子性的自增方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这个操作不是原子的</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM_THREADS</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ITERATIONS_PER_THREAD</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXPECTED_COUNT</span> <span class="operator">=</span> NUM_THREADS * ITERATIONS_PER_THREAD;</span><br><span class="line"></span><br><span class="line">        <span class="type">AtomicityErrorExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicityErrorExample</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程列表</span></span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NUM_THREADS; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ITERATIONS_PER_THREAD; j++) &#123;</span><br><span class="line">                    example.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads.add(thread);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动所有线程</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有线程执行完毕</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;期望的最终结果: &quot;</span> + EXPECTED_COUNT);</span><br><span class="line">        System.out.println(<span class="string">&quot;实际的最终结果: &quot;</span> + example.getCount());</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (example.getCount() != EXPECTED_COUNT) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;错误：发生了原子性问题！实际结果小于期望结果。&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;丢失的更新次数: &quot;</span> + (EXPECTED_COUNT - example.getCount()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜！在本次运行中未发生原子性问题（小概率事件）。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">期望的最终结果: <span class="number">100000</span></span><br><span class="line">实际的最终结果: <span class="number">15245</span></span><br><span class="line">------------------------------------</span><br><span class="line">错误：发生了原子性问题！实际结果小于期望结果。</span><br><span class="line">丢失的更新次数: <span class="number">84755</span></span><br></pre></td></tr></table></figure>

<p><strong>问题分析</strong> </p>
<p>假设 <code>count</code> 当前值为 <code>100</code>，线程A和线程B同时执行 <code>increment()</code>：</p>
<ol>
<li><strong>线程A</strong> 读取 <code>count</code> 的值，得到 <code>100</code>。</li>
<li><strong>线程B</strong> 也读取 <code>count</code> 的值，同样得到 <code>100</code>。（此时线程A还没来得及把新值写回去）</li>
<li><strong>线程A</strong> 在自己的工作内存中计算 <code>100 + 1</code>，得到 <code>101</code>。</li>
<li><strong>线程B</strong> 也在自己的工作内存中计算 <code>100 + 1</code>，得到 <code>101</code>。</li>
<li><strong>线程A</strong> 将 <code>101</code> 写回主内存，此时 <code>count</code> 变为 <code>101</code>。</li>
<li><strong>线程B</strong> 也将 <code>101</code> 写回主内存，此时 <code>count</code> 仍然是 <code>101</code>。</li>
</ol>
<p><strong>结果</strong>：两个线程都执行了自增操作，但 <code>count</code> 的值只增加了1。一次自增操作被“丢失”了。当成千上万次这样的操作发生时，最终的结果会远小于期望值。</p>
<h5 id="2-使用-synchronized-解决原子性错误"><a href="#2-使用-synchronized-解决原子性错误" class="headerlink" title="2. 使用 synchronized 解决原子性错误"></a>2. 使用 <code>synchronized</code> 解决原子性错误</h5><p><code>synchronized</code> 关键字可以保证同一时刻只有一个线程能进入被它修饰的代码块或方法，从而保证了操作的原子性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 synchronized 解决原子性问题的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicityFixedWithSynchronized</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 synchronized 关键字确保方法的原子性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// ... (main 方法与上面的例子完全相同)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM_THREADS</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ITERATIONS_PER_THREAD</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXPECTED_COUNT</span> <span class="operator">=</span> NUM_THREADS * ITERATIONS_PER_THREAD;</span><br><span class="line"></span><br><span class="line">        <span class="type">AtomicityFixedWithSynchronized</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicityFixedWithSynchronized</span>();</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; NUM_THREADS; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ITERATIONS_PER_THREAD; j++) &#123;</span><br><span class="line">                    example.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads.add(thread);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123; t.start(); &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : threads) &#123; t.join(); &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;期望的最终结果: &quot;</span> + EXPECTED_COUNT);</span><br><span class="line">        System.out.println(<span class="string">&quot;实际的最终结果: &quot;</span> + example.getCount());</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (example.getCount() == EXPECTED_COUNT) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正确：使用了 synchronized，结果符合预期。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>synchronized</code> 的作用</strong>：它为 <code>increment</code> 方法上了一把锁。任何线程想要执行这个方法，必须先获得这把锁。执行完毕后，释放锁。这样就保证了 “读取-修改-写入” 这三步作为一个不可分割的整体来执行。</p>
<h5 id="3-使用-AtomicInteger-解决原子性错误"><a href="#3-使用-AtomicInteger-解决原子性错误" class="headerlink" title="3. 使用 AtomicInteger 解决原子性错误"></a>3. 使用 <code>AtomicInteger</code> 解决原子性错误</h5><p>对于计数器这样的场景，Java 并发包（J.U.C）提供了更高效的原子类，如 <code>AtomicInteger</code>。它使用了一种称为**CAS（Compare-And-Swap）**的无锁技术，性能通常比 <code>synchronized</code> 更好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 AtomicInteger 解决原子性问题的类 (推荐方式)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicityFixedWithAtomic</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用原子类 AtomicInteger</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用原子类的原子方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... (main 方法与上面的例子完全相同, 只需修改类名)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXPECTED_COUNT</span> <span class="operator">=</span> <span class="number">10</span> * <span class="number">10000</span>;</span><br><span class="line">        <span class="type">AtomicityFixedWithAtomic</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicityFixedWithAtomic</span>();</span><br><span class="line">        <span class="comment">// ... (线程创建、启动、等待逻辑不变)</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;期望的最终结果: &quot;</span> + EXPECTED_COUNT);</span><br><span class="line">        System.out.println(<span class="string">&quot;实际的最终结果: &quot;</span> + example.getCount());</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (example.getCount() == EXPECTED_COUNT) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正确：使用了 AtomicInteger，结果符合预期。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>AtomicInteger</code> 的作用</strong>：<code>incrementAndGet()</code> 方法是一个原子操作。它在硬件级别上得到支持，能够在一个指令周期内完成 “比较并交换” 的操作，从而避免了传统锁的开销。</p>
<hr>
<h4 id="5-2-5-可见性"><a href="#5-2-5-可见性" class="headerlink" title="5.2.5 可见性"></a>5.2.5 可见性</h4><p>当一个线程修改了共享变量的值，其他线程能够立即看到这个修改。由于CPU缓存的存在，一个线程对共享变量的修改可能只存在于自己的CPU缓存中，而没有及时写回主内存，导致其他线程读取到的仍然是旧值。</p>
<h5 id="1-发生可见性错误的代码"><a href="#1-发生可见性错误的代码" class="headerlink" title="1. 发生可见性错误的代码"></a>1. 发生可见性错误的代码</h5><p>在这个版本中，共享变量 <code>running</code> 没有使用任何同步机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;工作线程已启动...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="comment">// 如果循环体内部为空，JIT编译器更容易进行优化，</span></span><br><span class="line">            <span class="comment">// 导致它可能只从CPU缓存中读取running的值。</span></span><br><span class="line">            <span class="comment">// 为了让问题更容易复现，我们在这里做一个简单的计数。</span></span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;工作线程已停止。 Counter = &quot;</span> + counter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">workerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">        workerThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程休眠1秒，确保工作线程已经开始运行并可能缓存了 running 的值</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程修改共享变量 running 的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程尝试停止工作线程...&quot;</span>);</span><br><span class="line">        myThread.running = <span class="literal">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程已将 running 设置为 false&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待工作线程结束，如果发生可见性问题，程序会卡在这里</span></span><br><span class="line">        workerThread.join(<span class="number">2000</span>); <span class="comment">// 最多等待2秒</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(workerThread.isAlive()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;错误：工作线程未能按预期停止！可见性问题发生。&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;程序将无法正常退出。&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;程序正常结束。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">工作线程已启动...</span><br><span class="line">主线程尝试停止工作线程...</span><br><span class="line">主线程已将 running 设置为 <span class="literal">false</span></span><br><span class="line">------------------------------------</span><br><span class="line">错误：工作线程未能按预期停止！可见性问题发生。</span><br><span class="line">程序将无法正常退出。</span><br><span class="line">------------------------------------</span><br><span class="line">(程序会一直挂起，不会自动终止)</span><br></pre></td></tr></table></figure>

<p><strong>问题分析</strong></p>
<ol>
<li><strong>CPU 缓存</strong>：每个CPU核心都有自己的高速缓存（L1, L2 Cache）。工作线程启动后，可能会将主内存中的 <code>running = true</code> 读取到自己的CPU缓存中。</li>
<li><strong>JIT 编译器优化</strong>：Java的即时（JIT）编译器在运行时会优化代码。对于 <code>while(running)</code> 这样的循环，如果它检测到循环体内没有修改 <code>running</code> 的代码，它可能会做出一个假设：<code>running</code> 的值不会改变。于是，它可能将代码优化为类似 <code>if(running) { while(true) { ... } }</code> 的形式，只在循环开始前检查一次 <code>running</code>。</li>
<li><strong>结果</strong>：当主线程在主内存中将 <code>running</code> 修改为 <code>false</code> 时，工作线程由于以上原因，可能仍然从自己的缓存中读取旧的 <code>true</code> 值，或者由于JIT优化，根本不再检查 <code>running</code> 的值，导致循环无法停止。</li>
</ol>
<h5 id="2-使用-volatile-解决可见性错误"><a href="#2-使用-volatile-解决可见性错误" class="headerlink" title="2. 使用 volatile 解决可见性错误"></a>2. 使用 <code>volatile</code> 解决可见性错误</h5><p>现在，我们通过为 <code>running</code> 变量添加 <code>volatile</code> 关键字来解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;工作线程已启动...&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="comment">// 如果循环体内部为空，JIT编译器更容易进行优化，</span></span><br><span class="line">            <span class="comment">// 导致它可能只从CPU缓存中读取running的值。</span></span><br><span class="line">            <span class="comment">// 为了让问题更容易复现，我们在这里做一个简单的计数。</span></span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;工作线程已停止。 Counter = &quot;</span> + counter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">workerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">        workerThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程休眠1秒，确保工作线程已经开始运行并可能缓存了 running 的值</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程修改共享变量 running 的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程尝试停止工作线程...&quot;</span>);</span><br><span class="line">        myThread.running = <span class="literal">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程已将 running 设置为 false&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待工作线程结束，如果发生可见性问题，程序会卡在这里</span></span><br><span class="line">        workerThread.join(<span class="number">2000</span>); <span class="comment">// 最多等待2秒</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(workerThread.isAlive()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;错误：工作线程未能按预期停止！可见性问题发生。&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;程序将无法正常退出。&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;程序正常结束。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">工作线程已启动...</span><br><span class="line">主线程尝试停止工作线程...</span><br><span class="line">主线程已将 running 设置为 <span class="literal">false</span></span><br><span class="line">工作线程已停止。 Counter = -<span class="number">1237374496</span></span><br><span class="line">程序正常结束。</span><br></pre></td></tr></table></figure>

<p><strong><code>volatile</code> 关键字的作用</strong></p>
<p><code>volatile</code> 关键字能提供两个重要的保证：</p>
<ol>
<li><strong>可见性（Visibility）</strong>：<ul>
<li>当一个线程<strong>写入</strong>一个 <code>volatile</code> 变量时，JMM（Java内存模型）会强制将该线程工作内存（CPU缓存）中的值立即刷新到主内存中。</li>
<li>当一个线程<strong>读取</strong>一个 <code>volatile</code> 变量时，JMM会强制让该线程的工作内存（CPU缓存）失效，并从主内存中重新读取最新值。</li>
</ul>
</li>
<li><strong>有序性（Ordering）</strong>：<ul>
<li>禁止指令重排序优化。确保 <code>volatile</code> 变量之前的代码都执行完毕，<code>volatile</code> 变量之后执行的代码都在它之后执行（建立所谓的 “happens-before” 关系）。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-2-6-有序性"><a href="#5-2-6-有序性" class="headerlink" title="5.2.6 有序性"></a>5.2.6 有序性</h4><p>为了提高性能，编译器和处理器可能会对指令进行重排序。在单线程中，这不会影响最终结果。但在多线程中，重排序可能会破坏逻辑上的先后关系，导致意想不到的错误。</p>
<h5 id="1-发生有序性错误的代码"><a href="#1-发生有序性错误的代码" class="headerlink" title="1. 发生有序性错误的代码"></a>1. 发生有序性错误的代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示指令重排序（有序性）问题的类</span></span><br><span class="line"><span class="comment"> * 这个错误不是每次都发生，需要多次运行来触发。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstructionReorderingError</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 用来存储读线程的计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写线程执行的任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这两行代码理论上可能被重排序</span></span><br><span class="line">        a = <span class="number">1</span>;         <span class="comment">// 操作1</span></span><br><span class="line">        flag = <span class="literal">true</span>;   <span class="comment">// 操作2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读线程执行的任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;      <span class="comment">// 操作3</span></span><br><span class="line">            result = a * a; <span class="comment">// 操作4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="type">InstructionReorderingError</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstructionReorderingError</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建写线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">writerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example::writer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建读线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">readerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example::reader);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 同时启动两个线程</span></span><br><span class="line">            writerThread.start();</span><br><span class="line">            readerThread.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待两个线程执行完毕</span></span><br><span class="line">            writerThread.join();</span><br><span class="line">            readerThread.join();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查结果</span></span><br><span class="line">            <span class="comment">// 如果 result == 0，说明读线程在 flag=true 时，读到的 a 仍然是 0。</span></span><br><span class="line">            <span class="comment">// 这就证明了 writer 线程中的 a=1 和 flag=true 发生了重排序。</span></span><br><span class="line">            <span class="comment">// 读线程看到了重排序后的结果：先执行了 flag=true，然后才执行 a=1。</span></span><br><span class="line">            <span class="keyword">if</span> (example.result == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">                System.out.printf(<span class="string">&quot;错误发生在第 %d 次执行！\n&quot;</span>, count);</span><br><span class="line">                System.out.println(<span class="string">&quot;Result is 0, which means reordering occurred.&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Reader thread saw flag=true, but a was still 0.&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 找到错误后退出循环</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 为了避免无限输出，可以注释掉这部分</span></span><br><span class="line">                <span class="comment">// System.out.printf(&quot;第 %d 次执行：正常, result = %d\n&quot;, count, example.result);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">------------------------------------</span><br><span class="line">错误发生在第 [一个比较大的数字] 次执行！</span><br><span class="line">Result is <span class="number">0</span>, which means reordering occurred.</span><br><span class="line">Reader thread saw flag=<span class="literal">true</span>, but a was still <span class="number">0.</span></span><br><span class="line">------------------------------------</span><br></pre></td></tr></table></figure>

<p><strong>问题分析</strong></p>
<ol>
<li><strong>代码的逻辑顺序</strong>：<code>writer()</code> 方法中，我们希望 <code>a = 1</code> 在 <code>flag = true</code> 之前执行。</li>
<li><strong>可能的执行顺序 (重排序后)</strong>：<ul>
<li><code>flag = true;</code></li>
<li><code>a = 1;</code></li>
</ul>
</li>
<li><strong>线程交叉执行</strong>：<ul>
<li><strong>写线程</strong>：执行了重排序后的第一步 <code>flag = true;</code>，然后CPU时间片切换。</li>
<li><strong>读线程</strong>：开始执行，检查 <code>if (flag)</code>，发现 <code>flag</code> 已经是 <code>true</code>。</li>
<li><strong>读线程</strong>：进入 <code>if</code> 语句块，执行 <code>result = a * a;</code>。但此时写线程的 <code>a = 1</code> 还没有执行，所以 <code>a</code> 的值仍然是 <code>0</code>。<code>result</code> 被计算为 <code>0</code>。</li>
<li><strong>程序错误</strong>：程序出现了一个不符合预期的结果。我们期望 <code>result</code> 的值要么是 <code>-1</code> (读线程先执行完)，要么是 <code>1</code> (写线程正常执行完)，但绝不应该是 <code>0</code>。<code>result == 0</code> 就是指令重排序的铁证。</li>
</ul>
</li>
</ol>
<h5 id="2-使用-volatile-解决有序性错误"><a href="#2-使用-volatile-解决有序性错误" class="headerlink" title="2. 使用 volatile 解决有序性错误"></a>2. 使用 <code>volatile</code> 解决有序性错误</h5><p><code>volatile</code> 关键字除了保证可见性，还能禁止指令重排序，从而解决这个问题。</p>
<p>我们将 <code>flag</code> 变量声明为 <code>volatile</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 volatile 解决指令重排序问题的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstructionReorderingFixed</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 使用 volatile 修饰 flag 变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 对 volatile 变量的写操作，会确保在此之前的普通写操作都已完成，</span></span><br><span class="line">        <span class="comment">// 并且结果对其他线程可见。</span></span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 对 volatile 变量的读操作，会确保在此之后的所有读操作都能看到之前写入的值。</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            result = a * a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 运行这个版本，程序将永远不会打印出错误信息，会一直运行下去。</span></span><br><span class="line">        <span class="comment">// 因为 volatile 保证了有序性。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="type">InstructionReorderingFixed</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstructionReorderingFixed</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">writerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example::writer);</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">readerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example::reader);</span><br><span class="line"></span><br><span class="line">            writerThread.start();</span><br><span class="line">            readerThread.start();</span><br><span class="line"></span><br><span class="line">            writerThread.join();</span><br><span class="line">            readerThread.join();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (example.result == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 这段代码理论上永远不会被执行</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;错误！在第 %d 次执行时，result 仍然为 0！\n&quot;</span>, count);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count % <span class="number">100000</span> == <span class="number">0</span>) &#123; <span class="comment">// 每10万次打印一次，证明程序在正常运行</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;已正常执行 %d 次...\n&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>volatile</code> 如何解决有序性问题</strong></p>
<p><code>volatile</code> 通过**内存屏障（Memory Barrier）**来禁止指令重排序，它遵循以下规则：</p>
<ol>
<li><strong>写 volatile 变量</strong>：当程序向一个 <code>volatile</code> 变量写入时（如 <code>flag = true</code>），JMM会插入一个<strong>写屏障</strong>。这个屏障会确保：<ul>
<li>在此屏障之前的所有普通变量的写入（如 <code>a = 1</code>）都已经被刷新到主内存。</li>
<li>禁止屏障之前的写操作与屏障之后的写操作重排序。</li>
</ul>
</li>
<li><strong>读 volatile 变量</strong>：当程序读取一个 <code>volatile</code> 变量时（如 <code>if (flag)</code>），JMM会插入一个<strong>读屏障</strong>。这个屏障会确保：<ul>
<li>禁止屏障之后的读操作与屏障之前的读操作重排序。</li>
</ul>
</li>
</ol>
<p>这个机制建立了一个 <strong>“happens-before”</strong> 关系：对 <code>volatile</code> 变量 <code>flag</code> 的写操作 <em>happens-before</em> 任何后续对 <code>flag</code> 的读操作。因此，当读线程读到 <code>flag</code> 为 <code>true</code> 时，它也一定能看到在写 <code>flag</code> 之前发生的所有操作的结果，即 <code>a = 1</code>。</p>
<hr>
<hr>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E5%85%AB%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="prev" title="八、网络编程">
                  <i class="fa fa-angle-left"></i> 八、网络编程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/09/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E5%AD%98%E5%82%A8/Mysql/" rel="next" title="Mysql">
                  Mysql <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
