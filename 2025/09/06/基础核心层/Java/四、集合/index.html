<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="四、集合1. 集合框架整体架构Java 集合框架主要分为两大家族：Collection 和 Map。  Collection： 存储单一元素的集合。 Map： 存储键值对（Key-Value）的集合。  graph TD     %% 样式定义     classDef interfaceStyle fill:#262626,stroke:#2ecc71,stroke-width:2px,colo">
<meta property="og:type" content="article">
<meta property="og:title" content="四、集合">
<meta property="og:url" content="http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E5%9B%9B%E3%80%81%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="四、集合1. 集合框架整体架构Java 集合框架主要分为两大家族：Collection 和 Map。  Collection： 存储单一元素的集合。 Map： 存储键值对（Key-Value）的集合。  graph TD     %% 样式定义     classDef interfaceStyle fill:#262626,stroke:#2ecc71,stroke-width:2px,colo">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-09-06T10:15:00.000Z">
<meta property="article:modified_time" content="2025-10-17T03:08:19.238Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E5%9B%9B%E3%80%81%E9%9B%86%E5%90%88/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E5%9B%9B%E3%80%81%E9%9B%86%E5%90%88/","path":"2025/09/06/基础核心层/Java/四、集合/","title":"四、集合"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>四、集合 | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E9%9B%86%E5%90%88"><span class="nav-text">四、集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="nav-text">1. 集合框架整体架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Collection-%E6%8E%A5%E5%8F%A3%E4%BD%93%E7%B3%BB"><span class="nav-text">2. Collection 接口体系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Collection"><span class="nav-text">2.1 Collection</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E6%A6%82%E5%BF%B5"><span class="nav-text">2.2.1 概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="nav-text">2.2.2 核心方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="nav-text">2.2.3 遍历方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-List-%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-text">2.2 List 接口及其实现类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E6%A0%B8%E5%BF%83%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="nav-text">2.2.1 核心特征：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E7%89%B9%E6%9C%89%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="nav-text">2.2.2 特有的核心方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-ArrayList%E3%80%90%E6%A0%B8%E5%BF%83%E6%8E%8C%E6%8F%A1%E3%80%91"><span class="nav-text">2.2.3 ArrayList【核心掌握】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">1. 核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7"><span class="nav-text">2. 底层数据结构和关键属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">3. 构造方法与初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6-Grow"><span class="nav-text">4. 扩容机制 (Grow)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0-Add"><span class="nav-text">5. 添加元素(Add)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-Remove"><span class="nav-text">6. 删除元素(Remove)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E8%8E%B7%E5%8F%96%E4%B8%8E%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0-Get-Set"><span class="nav-text">7. 获取与修改元素(Get&amp;Set)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-%E6%9F%A5%E6%89%BE-indexOf-lastIndexOf"><span class="nav-text">8. 查找(indexOf&#x2F;lastIndexOf)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="nav-text">9. 遍历方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">10. 典型应用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-LinkedList%E3%80%90%E6%A0%B8%E5%BF%83%E6%8E%8C%E6%8F%A1%E3%80%91"><span class="nav-text">2.2.4 LinkedList【核心掌握】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-1"><span class="nav-text">1. 核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7-1"><span class="nav-text">2. 底层数据结构和关键属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%EF%BC%88Add%EF%BC%89"><span class="nav-text">3. 添加元素（Add）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%88Remove%EF%BC%89"><span class="nav-text">4. 删除元素（Remove）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E8%8E%B7%E5%8F%96%E4%B8%8E%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0%EF%BC%88Get-Set%EF%BC%89"><span class="nav-text">5. 获取与修改元素（Get &amp; Set）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">6. 典型应用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-5-CopyOnWriteArrayList%E3%80%90%E4%BA%86%E8%A7%A3%E3%80%91"><span class="nav-text">2.2.5 CopyOnWriteArrayList【了解】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-2"><span class="nav-text">1. 核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7-2"><span class="nav-text">2. 底层数据结构和关键属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="nav-text">3. 构造方法与初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0-Add"><span class="nav-text">4. 添加元素(Add)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0-Get"><span class="nav-text">5. 获取元素(Get)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0-Set"><span class="nav-text">6. 修改元素(Set)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-Remove"><span class="nav-text">7. 删除元素(Remove)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-%E9%81%8D%E5%8E%86%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator"><span class="nav-text">8. 遍历与迭代器(Iterator)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">9. 典型应用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-6-Vector%E3%80%90%E8%BF%87%E6%97%B6%E3%80%91"><span class="nav-text">2.2.6 Vector【过时】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-3"><span class="nav-text">1. 核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80"><span class="nav-text">2. 性能开销</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%8A%9F%E8%83%BD%E9%99%88%E6%97%A7%E4%B8%94%E8%AE%BE%E8%AE%A1%E4%B8%8D%E4%BD%B3"><span class="nav-text">3. 功能陈旧且设计不佳</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="nav-text">4. 替代方案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-7-Stack%E3%80%90%E8%BF%87%E6%97%B6%E3%80%91"><span class="nav-text">2.2.7 Stack【过时】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-4"><span class="nav-text">1. 核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%B3%9F%E7%B3%95%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-text">2. 糟糕的继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80"><span class="nav-text">3. 性能开销</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-Deque-%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0"><span class="nav-text">4. 官方推荐使用 Deque 接口及其实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="nav-text">5. 替代方案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-8-%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-text">2.2.8 实现类的对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Set-%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-text">2.3 Set 接口及其实现类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E6%A0%B8%E5%BF%83%E7%89%B9%E5%BE%81"><span class="nav-text">2.3.1 核心特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-HashSet%E3%80%90%E6%A0%B8%E5%BF%83%E6%8E%8C%E6%8F%A1%E3%80%91"><span class="nav-text">2.3.2 HashSet【核心掌握】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-5"><span class="nav-text">1. 核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7-3"><span class="nav-text">2. 底层数据结构和关键属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-2"><span class="nav-text">3. 构造方法与初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0-Add-%E4%B8%8E%E4%BF%9D%E8%AF%81%E5%85%83%E7%B4%A0%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="nav-text">4. 添加元素(Add)与保证元素唯一的机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-Remove"><span class="nav-text">5. 删除元素(Remove)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0-Contains"><span class="nav-text">6. 查找元素(Contains)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="nav-text">7. 遍历方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">8. 典型应用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-LinkedHashSet%E3%80%90%E6%A0%B8%E5%BF%83%E6%8E%8C%E6%8F%A1%E3%80%91"><span class="nav-text">2.3.3 LinkedHashSet【核心掌握】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-6"><span class="nav-text">1. 核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7-4"><span class="nav-text">2. 底层数据结构和关键属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-3"><span class="nav-text">3. 构造方法与初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E7%BB%B4%E6%8A%A4%E6%8F%92%E5%85%A5%E9%A1%BA%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="nav-text">4. 维护插入顺序的机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%B7%BB%E5%8A%A0%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="nav-text">5. 添加、删除、查找元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="nav-text">6. 遍历方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">7. 典型应用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-TreeSet%E3%80%90%E6%A0%B8%E5%BF%83%E6%8E%8C%E6%8F%A1%E3%80%91"><span class="nav-text">2.3.4 TreeSet【核心掌握】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-7"><span class="nav-text">1. 核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7-5"><span class="nav-text">2. 底层数据结构和关键属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-4"><span class="nav-text">3. 构造方法与初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0-Add-%E4%B8%8E%E4%BF%9D%E8%AF%81%E5%85%83%E7%B4%A0%E5%94%AF%E4%B8%80%E5%92%8C%E6%9C%89%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="nav-text">4. 添加元素(Add)与保证元素唯一和有序的机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-Remove-1"><span class="nav-text">5. 删除元素(Remove)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0-Contains-1"><span class="nav-text">6. 查找元素(Contains)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E5%AF%BC%E8%88%AA%E6%96%B9%E6%B3%95%EF%BC%88Navigation-Methods%EF%BC%89"><span class="nav-text">7. 导航方法（Navigation Methods）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="nav-text">8. 遍历方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-text">9. 典型应用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-5-EnumSet%E3%80%90%E4%BA%86%E8%A7%A3%E3%80%91"><span class="nav-text">2.3.5 EnumSet【了解】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-8"><span class="nav-text">1. 核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7-6"><span class="nav-text">2. 底层数据结构和关键属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-5"><span class="nav-text">3. 构造方法与初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0-Add-1"><span class="nav-text">4. 添加元素(Add)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-Remove-2"><span class="nav-text">5. 删除元素(Remove)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E5%8C%85%E5%90%AB%E5%88%A4%E6%96%AD-Contains"><span class="nav-text">6. 包含判断(Contains)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C"><span class="nav-text">7. 批量操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F-1"><span class="nav-text">8. 遍历方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E9%9D%A2"><span class="nav-text">9. 典型应用场面</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-6-CopyOnWriteArraySet%E3%80%90%E4%BA%86%E8%A7%A3%E3%80%91"><span class="nav-text">2.3.6 CopyOnWriteArraySet【了解】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-9"><span class="nav-text">1. 核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7-7"><span class="nav-text">2. 底层数据结构和关键属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-6"><span class="nav-text">3. 构造方法与初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0-Add-2"><span class="nav-text">4. 添加元素(Add)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-Remove-3"><span class="nav-text">5. 删除元素(Remove)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E5%8C%85%E5%90%AB%E5%88%A4%E6%96%AD-Contains-1"><span class="nav-text">6. 包含判断(Contains)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E9%81%8D%E5%8E%86%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">7. 遍历与迭代器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-text">8. 典型应用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-7-%E7%BB%BC%E5%90%88%E5%AF%B9%E6%AF%94"><span class="nav-text">2.3.7 综合对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-Queue-Deque-%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-text">2.4 Queue &#x2F; Deque 接口及其实现类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-Queue"><span class="nav-text">2.4.1 Queue</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="nav-text">1.核心特征：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%89%B9%E6%9C%89%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="nav-text">2.特有的核心方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-LinkedBlockingQueue%E3%80%90%E4%BA%86%E8%A7%A3%E3%80%91"><span class="nav-text">2.4.2 LinkedBlockingQueue【了解】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-10"><span class="nav-text">1. 核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7-8"><span class="nav-text">2. 底层数据结构和关键属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-7"><span class="nav-text">3. 构造方法与初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C-Put-Offer"><span class="nav-text">4. 入队操作(Put&#x2F;Offer)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C-Take-Poll"><span class="nav-text">5. 出队操作(Take&#x2F;Poll)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E6%9F%A5%E7%9C%8B%E5%85%83%E7%B4%A0-Peek"><span class="nav-text">6. 查看元素(Peek)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-text">7.  典型应用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-ConcurrentLinkedQueue%E3%80%90%E4%BA%86%E8%A7%A3%E3%80%91"><span class="nav-text">2.4.3 ConcurrentLinkedQueue【了解】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-11"><span class="nav-text">1. 核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7-9"><span class="nav-text">2. 底层数据结构和关键属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-8"><span class="nav-text">3. 构造方法与初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C-Offer"><span class="nav-text">4. 入队操作(Offer)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C-Poll"><span class="nav-text">5. 出队操作(Poll)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E6%9F%A5%E7%9C%8B%E5%85%83%E7%B4%A0-Peek-1"><span class="nav-text">6. 查看元素(Peek)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E5%A4%A7%E5%B0%8F-Size-%E4%B8%8E%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-text">7. 大小(Size)与弱一致性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E6%80%A7%E8%83%BD"><span class="nav-text">8. 线程安全与性能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-text">9.  典型应用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-4-PriorityQueue%E3%80%90%E4%BA%86%E8%A7%A3%E3%80%91"><span class="nav-text">2.4.4 PriorityQueue【了解】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-12"><span class="nav-text">1. 核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7-10"><span class="nav-text">2. 底层数据结构和关键属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-9"><span class="nav-text">3. 构造方法与初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6-Grow-1"><span class="nav-text">4. 扩容机制 (Grow)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0-Offer-Add"><span class="nav-text">5. 添加元素(Offer&#x2F;Add)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E8%8E%B7%E5%8F%96%E4%B8%8E%E5%88%A0%E9%99%A4%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0-Poll-Remove"><span class="nav-text">6. 获取与删除队头元素(Poll&#x2F;Remove)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E6%9F%A5%E7%9C%8B%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0-Peek-Element"><span class="nav-text">7. 查看队头元素(Peek&#x2F;Element)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-%E6%9F%A5%E6%89%BE-Contains-%E4%B8%8E%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0-Remove"><span class="nav-text">8. 查找(Contains)与删除指定元素(Remove)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F-1"><span class="nav-text">9. 遍历方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-5-ArrayBlockingQueue%E3%80%90%E4%BA%86%E8%A7%A3%E3%80%91"><span class="nav-text">2.4.5 ArrayBlockingQueue【了解】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-13"><span class="nav-text">1. 核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7-11"><span class="nav-text">2. 底层数据结构和关键属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-10"><span class="nav-text">3. 构造方法与初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-text">4. 扩容机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0-Put-Offer-Add"><span class="nav-text">5. 添加元素(Put&#x2F;Offer&#x2F;Add)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E8%8E%B7%E5%8F%96%E4%B8%8E%E5%88%A0%E9%99%A4%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0-Take-Poll-Remove"><span class="nav-text">6. 获取与删除队头元素(Take&#x2F;Poll&#x2F;Remove)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E6%9F%A5%E7%9C%8B%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0-Peek-Element-1"><span class="nav-text">7. 查看队头元素(Peek&#x2F;Element)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F-2"><span class="nav-text">8. 遍历方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-6-Deque-%E7%BB%A7%E6%89%BF"><span class="nav-text">2.4.6 Deque(继承)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E7%89%B9%E5%BE%81%EF%BC%9A-1"><span class="nav-text">1.核心特征：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%89%B9%E6%9C%89%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95-1"><span class="nav-text">2.特有的核心方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-7-ArrayDeque%E3%80%90%E4%BA%86%E8%A7%A3%E3%80%91"><span class="nav-text">2.4.7 ArrayDeque【了解】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-14"><span class="nav-text">1. 核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7-12"><span class="nav-text">2. 底层数据结构和关键属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-11"><span class="nav-text">3. 构造方法与初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6-doubleCapacity"><span class="nav-text">4. 扩容机制 (doubleCapacity)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0-Add-1"><span class="nav-text">5. 添加元素(Add)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-Remove-1"><span class="nav-text">6. 删除元素(Remove)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E8%8E%B7%E5%8F%96%E4%B8%8E%E6%9F%A5%E7%9C%8B%E5%85%83%E7%B4%A0-Get-Peek"><span class="nav-text">7. 获取与查看元素(Get&amp;Peek)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-%E6%9F%A5%E6%89%BE-Contains"><span class="nav-text">8. 查找(Contains)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F-2"><span class="nav-text">9. 遍历方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-%E5%AF%B9%E6%AF%94"><span class="nav-text">10. 对比</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Map-%E6%8E%A5%E5%8F%A3%E4%BD%93%E7%B3%BB"><span class="nav-text">3. Map 接口体系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Map"><span class="nav-text">3.1 Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E6%A6%82%E8%BF%B0"><span class="nav-text">3.1.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="nav-text">3.1.2 核心方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="nav-text">3.1.3 遍历方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Map-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-text">3.2 Map 接口的实现类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-HashMap%E3%80%90-%E6%A0%B8%E5%BF%83%E6%8E%8C%E6%8F%A1-%E3%80%91"><span class="nav-text">3.2.1 HashMap【!核心掌握!】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-15"><span class="nav-text">1. 核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7-13"><span class="nav-text">2. 底层数据结构和关键属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-12"><span class="nav-text">3. 构造方法与初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%93%88%E5%B8%8C%E8%AE%A1%E7%AE%97%E4%B8%8E%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E5%AE%9A%E4%BD%8D"><span class="nav-text">4. 哈希计算与数组下标定位</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%B7%BB%E5%8A%A0-%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0-Put"><span class="nav-text">5. 添加&#x2F;更新元素(Put)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6-Resize"><span class="nav-text">6. 扩容机制 (Resize)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0-Get"><span class="nav-text">7. 获取元素(Get)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-Remove"><span class="nav-text">8. 删除元素(Remove)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F-3"><span class="nav-text">9. 遍历方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-LinkedHashMap%E3%80%90%E6%A0%B8%E5%BF%83%E6%8E%8C%E6%8F%A1%E3%80%91"><span class="nav-text">3.2.2 LinkedHashMap【核心掌握】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-16"><span class="nav-text">1. 核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7-14"><span class="nav-text">2. 底层数据结构和关键属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-13"><span class="nav-text">3. 构造方法与初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9A%E7%BB%B4%E6%8A%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95"><span class="nav-text">4. 核心机制：维护链表的钩子方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0-Get-1"><span class="nav-text">5. 获取元素(Get)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E5%AE%9E%E7%8E%B0LRU%E7%BC%93%E5%AD%98%E7%A4%BA%E4%BE%8B"><span class="nav-text">6. 实现LRU缓存示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F-1"><span class="nav-text">7. 遍历方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-TreeMap%E3%80%90%E6%A0%B8%E5%BF%83%E6%8E%8C%E6%8F%A1%E3%80%91"><span class="nav-text">3.2.3 TreeMap【核心掌握】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-17"><span class="nav-text">1. 核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7-15"><span class="nav-text">2. 底层数据结构和关键属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-14"><span class="nav-text">3. 构造方法与初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%B7%BB%E5%8A%A0-%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0%EF%BC%88Put%EF%BC%89"><span class="nav-text">4. 添加&#x2F;更新元素（Put）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%EF%BC%88Get%EF%BC%89"><span class="nav-text">5. 获取元素（Get）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%88Remove%EF%BC%89"><span class="nav-text">6. 删除元素（Remove）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F-2"><span class="nav-text">7. 遍历方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-%E7%89%B9%E6%9C%89%E6%96%B9%E6%B3%95%EF%BC%88%E6%9D%A5%E8%87%AA-NavigableMap%EF%BC%89"><span class="nav-text">8. 特有方法（来自 NavigableMap）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">9. 使用场景与最佳实践</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-Hashtable%E3%80%90%E4%BA%86%E8%A7%A3%E3%80%91"><span class="nav-text">3.2.4 Hashtable【了解】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-18"><span class="nav-text">1. 核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7-16"><span class="nav-text">2. 底层数据结构和关键属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-15"><span class="nav-text">3. 构造方法与初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%93%88%E5%B8%8C%E8%AE%A1%E7%AE%97%E4%B8%8E%E4%B8%8B%E6%A0%87%E5%AE%9A%E4%BD%8D"><span class="nav-text">4. 哈希计算与下标定位</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%B7%BB%E5%8A%A0-%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0%EF%BC%88Put%EF%BC%89"><span class="nav-text">5. 添加&#x2F;更新元素（Put）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%EF%BC%88Get%EF%BC%89"><span class="nav-text">6. 获取元素（Get）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%88Remove%EF%BC%89"><span class="nav-text">7. 删除元素（Remove）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F-3"><span class="nav-text">8. 遍历方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-5-ConcurrentHashMap%E3%80%90%E6%A0%B8%E5%BF%83%E6%8E%8C%E6%8F%A1%E3%80%91"><span class="nav-text">3.2.5 ConcurrentHashMap【核心掌握】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-19"><span class="nav-text">1. 核心概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7-17"><span class="nav-text">2. 底层数据结构和关键属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96-16"><span class="nav-text">3. 构造方法与初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%B7%BB%E5%8A%A0-%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0"><span class="nav-text">4. 添加&#x2F;更新元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0"><span class="nav-text">5. 获取元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-text">6. 删除元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-text">7. 扩容机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F-4"><span class="nav-text">8. 遍历方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-6-%E7%BB%BC%E5%90%88%E5%AF%B9%E6%AF%94"><span class="nav-text">3.2.6 综合对比</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="nav-text">1. 核心特性对比表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="nav-text">2. 如何选择</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9ACollections"><span class="nav-text">4. 工具类：Collections</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%A6%82%E8%BF%B0"><span class="nav-text">4.1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E4%B8%8E%E6%96%B9%E6%B3%95%E5%88%86%E7%B1%BB"><span class="nav-text">4.2 主要功能与方法分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE%EF%BC%88Sorting-and-Searching%EF%BC%89"><span class="nav-text">4.2.1 排序和查找（Sorting and Searching）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%EF%BC%88Synchronization-Wrappers%EF%BC%89"><span class="nav-text">4.2.2 同步控制（Synchronization Wrappers）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88%EF%BC%88Unmodifiable-Wrappers%EF%BC%89"><span class="nav-text">4.2.3 不可变集合（Unmodifiable Wrappers）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-4-%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5%EF%BC%88Checked-Wrappers%EF%BC%89"><span class="nav-text">4.2.4 类型安全检查（Checked Wrappers）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-5-%E5%85%B6%E4%BB%96%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">4.2.5 其他实用方法</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E5%9B%9B%E3%80%81%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="四、集合 | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          四、集合
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-06 18:15:00" itemprop="dateCreated datePublished" datetime="2025-09-06T18:15:00+08:00">2025-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 11:08:19" itemprop="dateModified" datetime="2025-10-17T11:08:19+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/" itemprop="url" rel="index"><span itemprop="name">基础核心层</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="四、集合"><a href="#四、集合" class="headerlink" title="四、集合"></a>四、集合</h1><h2 id="1-集合框架整体架构"><a href="#1-集合框架整体架构" class="headerlink" title="1. 集合框架整体架构"></a>1. 集合框架整体架构</h2><p>Java 集合框架主要分为两大家族：<strong><code>Collection</code></strong> 和 <strong><code>Map</code></strong>。</p>
<ul>
<li><strong><code>Collection</code></strong>： 存储单一元素的集合。</li>
<li><strong><code>Map</code></strong>： 存储键值对（Key-Value）的集合。</li>
</ul>
<pre><code class="highlight mermaid">graph TD
    %% 样式定义
    classDef interfaceStyle fill:#262626,stroke:#2ecc71,stroke-width:2px,color:#fff
    classDef abstractClassStyle fill:#262626,stroke:#e67e22,stroke-width:2px,color:#fff
    classDef concreteClassStyle fill:#262626,stroke:#ecf0f1,stroke-width:2px,color:#fff
    classDef privateClassStyle fill:#262626,stroke:#e74c3c,stroke-width:2px,color:#fff

    %% Collection 体系
    Collection(&quot;Collection&quot;) -.-&gt; Set(&quot;Set&quot;)
    Collection -.-&gt; List(&quot;List&quot;)
    Collection -.-&gt; Queue(&quot;Queue&quot;)

    %% Set 分支
    Set --&gt; EnumSet(&quot;EnumSet&quot;)
    Set --&gt; HashSet(&quot;HashSet&quot;)
    Set --&gt; TreeSet(&quot;TreeSet&quot;)
    Set --&gt; CopyOnWriteArraySet(&quot;CopyOnWriteArraySet&quot;)
    EnumSet --&gt; RegularEnumSet(&quot;Regular EnumSet&quot;)
    EnumSet --&gt; JumboEnumSet(&quot;Jumbo EnumSet&quot;)
    HashSet -.-&gt; LinkedHashSet(&quot;Linked HashSet&quot;)

    %% List 分支
    List --&gt; ArrayList(&quot;ArrayList&quot;)
    List --&gt; CopyOnWriteArrayList(&quot;CopyOnWrite ArrayList&quot;)
    List --&gt; Vector(&quot;Vector&quot;)
    List --&gt; LinkedList(&quot;LinkedList&quot;)
    Vector -.-&gt; Stack(&quot;Stack&quot;)

    %% Queue 分支
    Queue -.-&gt; Deque(&quot;Deque&quot;)
    Deque --&gt; ArrayDeque(&quot;ArrayDeque&quot;)
    LinkedList --&gt; Deque
    
    PriorityQueue(&quot;PriorityQueue&quot;) --&gt; Queue
    LinkedBlockingQueue(&quot;LinkedBlockingQueue&quot;) --&gt; Queue
    ConcurrentLinkedQueue(&quot;ConcurrentLinkedQueue&quot;) --&gt; Queue
    ArrayBlockingQueue(&quot;ArrayBlockingQueue&quot;) --&gt; Queue

    %% Map 体系 (独立分支)
    Map(&quot;Map&quot;) -.-&gt; HashMap(&quot;HashMap&quot;)
    Map -.-&gt; TreeMap(&quot;TreeMap&quot;)
    Map -.-&gt; Hashtable(&quot;Hashtable&quot;)
    Map -.-&gt; ConcurrentHashMap(&quot;Concurrent HashMap&quot;)
    HashMap -.-&gt; LinkedHashMap(&quot;Linked HashMap&quot;)

    %% 应用样式
    class Collection,Set,List,Queue,Deque,Map interfaceStyle
    class EnumSet abstractClassStyle
    class RegularEnumSet,JumboEnumSet privateClassStyle
    class HashSet,LinkedHashSet,TreeSet,CopyOnWriteArraySet,ArrayList,CopyOnWriteArrayList,Vector,Stack,LinkedList,ArrayDeque,PriorityQueue,LinkedBlockingQueue,ConcurrentLinkedQueue,ArrayBlockingQueue,HashMap,LinkedHashMap,TreeMap,Hashtable,ConcurrentHashMap concreteClassStyle</code></pre>

<hr>
<h2 id="2-Collection-接口体系"><a href="#2-Collection-接口体系" class="headerlink" title="2. Collection 接口体系"></a>2. Collection 接口体系</h2><h3 id="2-1-Collection"><a href="#2-1-Collection" class="headerlink" title="2.1 Collection"></a>2.1 Collection</h3><h4 id="2-2-1-概念"><a href="#2-2-1-概念" class="headerlink" title="2.2.1 概念"></a>2.2.1 概念</h4><p><code>Collection</code> 是Java集合框架的<strong>根接口</strong>之一，用于表示一组对象，这些对象也称为集合的<strong>元素</strong>。它定义了所有单列集合（即每个元素都是一个独立对象，如 <code>[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</code>）将具备的<strong>通用操作</strong>。</p>
<hr>
<h4 id="2-2-2-核心方法"><a href="#2-2-2-核心方法" class="headerlink" title="2.2.2 核心方法"></a>2.2.2 核心方法</h4><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">功能描述</th>
<th align="left">注意点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>boolean add(E e)</code></td>
<td align="left">确保此集合包含指定的元素。</td>
<td align="left">如果集合因调用而改变则返回 <code>true</code>（例如，<code>Set</code> 添加重复元素会返回 <code>false</code>）。</td>
</tr>
<tr>
<td align="left"><code>boolean remove(Object o)</code></td>
<td align="left">从此集合中移除指定元素的单个实例（如果存在）。</td>
<td align="left">移除成功返回 <code>true</code>。</td>
</tr>
<tr>
<td align="left"><code>void clear()</code></td>
<td align="left">移除此集合中的所有元素。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>boolean contains(Object o)</code></td>
<td align="left">如果此集合包含指定的元素，则返回 <code>true</code>。</td>
<td align="left">依赖对象的 <code>equals()</code> 方法进行判断，如果集合存储自定义对象，一定要重写equals方法。</td>
</tr>
<tr>
<td align="left"><code>int size()</code></td>
<td align="left">返回此集合中的元素数。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>boolean isEmpty()</code></td>
<td align="left">如果此集合不包含任何元素，则返回 <code>true</code>。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>Iterator&lt;E&gt; iterator()</code></td>
<td align="left"><strong>返回在此集合的元素上进行迭代的迭代器。</strong></td>
<td align="left">这是<strong>遍历集合</strong>最基本和通用的方式。</td>
</tr>
<tr>
<td align="left"><code>Object[] toArray()</code></td>
<td align="left">返回包含此集合中所有元素的数组。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>&lt;T&gt; T[] toArray(T[] a)</code></td>
<td align="left">返回包含此集合中所有元素的数组；返回数组的运行时类型与指定数组的相同。</td>
<td align="left">更常用的方式，可以指定返回数组的类型。</td>
</tr>
<tr>
<td align="left"><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></td>
<td align="left">将指定集合中的所有元素添加到此集合中。</td>
<td align="left"><strong>批量操作</strong></td>
</tr>
<tr>
<td align="left"><code>boolean removeAll(Collection&lt;?&gt; c)</code></td>
<td align="left">移除此集合中那些也包含在指定集合中的所有元素（差集）。</td>
<td align="left"><strong>批量操作</strong></td>
</tr>
<tr>
<td align="left"><code>boolean retainAll(Collection&lt;?&gt; c)</code></td>
<td align="left">仅保留此集合中那些也包含在指定集合中的元素（交集）。</td>
<td align="left"><strong>批量操作</strong></td>
</tr>
<tr>
<td align="left"><code>boolean containsAll(Collection&lt;?&gt; c)</code></td>
<td align="left">如果此集合包含指定集合中的所有元素，则返回 <code>true</code>（子集判断）。</td>
<td align="left"><strong>批量操作</strong></td>
</tr>
</tbody></table>
<hr>
<h4 id="2-2-3-遍历方式"><a href="#2-2-3-遍历方式" class="headerlink" title="2.2.3 遍历方式"></a>2.2.3 遍历方式</h4><ol>
<li><p><strong>迭代器（Iterator）</strong>： 最通用、最标准的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ... 添加元素</span></span><br><span class="line">Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(element);</span><br><span class="line">    <span class="comment">// it.remove(); // 可以在遍历时安全地移除元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>增强 for 循环（for-each）</strong>： 语法糖，底层仍然是迭代器。<strong>更简洁，但不能在遍历时直接删除元素（会抛异常）</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String element : coll) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Lambda 表达式 + forEach() 方法（JDK8+）</strong>： 非常简洁的遍历方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">coll.forEach(element -&gt; System.out.println(element));</span><br><span class="line"><span class="comment">// 或使用方法引用</span></span><br><span class="line">coll.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="2-2-List-接口及其实现类"><a href="#2-2-List-接口及其实现类" class="headerlink" title="2.2 List 接口及其实现类"></a>2.2 <strong>List 接口及其实现类</strong></h3><p><code>List</code> 是 <code>Collection</code> 接口的一个极其重要的子接口。它代表了一个<strong>有序的、可重复的</strong>元素序列，有时也称为<strong>序列</strong>（Sequence）。</p>
<h4 id="2-2-1-核心特征："><a href="#2-2-1-核心特征：" class="headerlink" title="2.2.1 核心特征："></a>2.2.1 核心特征：</h4><ol>
<li><strong>有序（Ordered）</strong>： 元素以一种特定的顺序存储，并且允许以索引（下标）的方式精确控制每个元素的插入位置。<strong>存取顺序一致</strong>（例如，先存”a”再存”b”，遍历时也是先得到”a”再得到”b”）。</li>
<li><strong>可重复（Allow Duplicates）</strong>： 允许存储相同的元素（包括 <code>null</code> 元素）。它依赖元素的 <code>equals()</code> 方法来判断是否重复。</li>
<li><strong>有索引（Indexed）</strong>： 提供了基于整数索引（从 <code>0</code> 开始）的访问方式。用户可以通过 <code>list.get(int index)</code> 直接访问特定位置的元素，这是它与 <code>Set</code> 最明显的区别。</li>
</ol>
<p>正因为这些特性，<code>List</code> 可以被看作是<strong>长度可变的、功能更强大的数组</strong>。</p>
<hr>
<h4 id="2-2-2-特有的核心方法"><a href="#2-2-2-特有的核心方法" class="headerlink" title="2.2.2 特有的核心方法"></a>2.2.2 特有的核心方法</h4><p>除了继承自 <code>Collection</code> 的所有方法外，<code>List</code> 接口定义了大量与<strong>索引</strong>相关的特有方法。</p>
<table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>E get(int index)</code></td>
<td align="left">返回列表中指定位置的元素。<strong>这是List最常用的特性之一。</strong></td>
</tr>
<tr>
<td align="left"><code>E set(int index, E element)</code></td>
<td align="left">用指定元素替换列表中指定位置的元素，并返回被替换的元素。</td>
</tr>
<tr>
<td align="left"><code>void add(int index, E element)</code></td>
<td align="left">在列表的指定位置插入指定元素，原该位置及之后的元素向后移动。</td>
</tr>
<tr>
<td align="left"><code>E remove(int index)</code></td>
<td align="left">移除列表中指定位置的元素，并将后续元素向左移动，<strong>返回被移除的元素</strong>。</td>
</tr>
<tr>
<td align="left"><code>int indexOf(Object o)</code></td>
<td align="left">返回此列表中<strong>第一次</strong>出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。</td>
</tr>
<tr>
<td align="left"><code>int lastIndexOf(Object o)</code></td>
<td align="left">返回此列表中<strong>最后一次</strong>出现的指定元素的索引。</td>
</tr>
<tr>
<td align="left"><code>ListIterator&lt;E&gt; listIterator()</code></td>
<td align="left">返回此列表元素的<strong>列表迭代器</strong>（功能比普通 <code>Iterator</code> 更强大）。</td>
</tr>
<tr>
<td align="left"><code>ListIterator&lt;E&gt; listIterator(int index)</code></td>
<td align="left">从列表的指定位置开始，返回列表迭代器。</td>
</tr>
<tr>
<td align="left"><code>List&lt;E&gt; subList(int fromIndex, int toIndex)</code></td>
<td align="left">返回列表中指定的 <code>fromIndex</code>（包括）和 <code>toIndex</code>（不包括）之间的部分<strong>视图</strong>。对子列表的修改会影响原列表。</td>
</tr>
</tbody></table>
<hr>
<h4 id="2-2-3-ArrayList【核心掌握】"><a href="#2-2-3-ArrayList【核心掌握】" class="headerlink" title="2.2.3 ArrayList【核心掌握】"></a>2.2.3 ArrayList【核心掌握】</h4><h5 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>ArrayList</code> 是 <code>List</code> 接口的<strong>可调整大小的数组实现</strong>。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>有序（Ordered）</strong>： 元素按照插入顺序存放。</li>
<li><strong>可重复（Allows Duplicates）</strong>： 允许存储相同的元素和 <code>null</code>。</li>
<li><strong>有索引（Indexed）</strong>： 可以通过从 <code>0</code> 开始的索引高速访问元素。</li>
<li><strong>非线程安全（Not Thread-Safe）</strong>： 多线程环境下未经同步直接使用会导致不确定的结果。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层使用一个 <strong><code>Object[] elementData</code></strong> 数组来存储所有元素。所有看似“动态”的行为（如自动扩容）都是通过操作这个数组来实现的。</li>
<li>**设计思想：**用动态数组实现一个“可变长、随机访问快、尾插效率高”的容器，满足绝大多数读多写少的业务场景需求，同时在扩容策略、接口抽象、并发检测等方面做了权衡。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性"><a href="#2-底层数据结构和关键属性" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>ArrayList</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 序列化ID</span></span><br><span class="line">    <span class="meta">@java</span>.io.Serial</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于空实例的共享空数组（在初始化容量为0时使用）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于默认大小空实例的共享空数组（与EMPTY_ELEMENTDATA区分开来，以知道第一次添加元素时要扩容多少）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 真正存储ArrayList元素的数组缓冲区。</span></span><br><span class="line"><span class="comment">     * ArrayList的容量就是这个数组缓冲区的长度。</span></span><br><span class="line"><span class="comment">     * 当第一个元素被添加时，任何以DEFAULTCAPACITY_EMPTY_ELEMENTDATA初始化的ArrayList</span></span><br><span class="line"><span class="comment">     * 都会被扩容到DEFAULT_CAPACITY（10）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList中实际包含的元素数量（size &lt;= elementData.length）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他方法和构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>elementData</code></strong>： 元素真正存储的区域。它被 <code>transient</code> 修饰，是因为 <code>ArrayList</code> 自定义了序列化逻辑以节省空间。</li>
<li><strong><code>size</code></strong>： 记录当前列表中<strong>实际有多少个有效元素</strong>。</li>
<li><strong><code>DEFAULT_CAPACITY</code></strong>： 默认初始容量（10）。<strong>注意：只有在使用无参构造器且第一次添加元素时，才会真正初始化为这个容量。</strong></li>
</ul>
<hr>
<h5 id="3-构造方法与初始化"><a href="#3-构造方法与初始化" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>ArrayList</code> 提供了三种构造方式：</p>
<ol>
<li><p><strong><code>public ArrayList()</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 将 <code>elementData</code> 指向 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>。</p>
</li>
<li><p><strong>特点</strong>： <strong>懒加载</strong>。此时数组长度为0，节省内存。在<strong>第一次调用 <code>add()</code> 方法添加元素时</strong>，才会将容量真正初始化为 <code>DEFAULT_CAPACITY</code>（10）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个初始容量为 10 的空列表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public ArrayList(int initialCapacity)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 如果 <code>initialCapacity &gt; 0</code>，则新建一个指定大小的 <code>Object[]</code>；如果等于0，则指向 <code>EMPTY_ELEMENTDATA</code>；小于0则抛异常。</p>
</li>
<li><p><strong>特点</strong>： <strong>显式指定初始容量</strong>。如果你能预估数据量，使用此构造器可以避免多次扩容，提升性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造具有指定初始容量的空列表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity 列表的初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果指定的初始容量为负数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public ArrayList(Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 将传入的集合通过 <code>c.toArray()</code> 转为数组，并赋值给 <code>elementData</code>。如果转换后的数组长度不为0，还会检查其类型是否为 <code>Object[]</code>，不是则用 <code>Arrays.copyOf</code> 进行转换。</p>
</li>
<li><p><strong>特点</strong>： <strong>用一个已有集合来构造</strong>，元素顺序由该集合的迭代器决定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含指定集合元素的列表，按照集合迭代器返回的顺序排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 其元素要放入此列表中的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的集合为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">            elementData = a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 替换为空数组</span></span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-扩容机制-Grow"><a href="#4-扩容机制-Grow" class="headerlink" title="4. 扩容机制 (Grow)"></a>4. 扩容机制 (Grow)</h5><p>当试图向已满的数组（<code>size == elementData.length</code>）添加新元素时，就会触发扩容。</p>
<p><strong>源码逻辑：</strong></p>
<ol>
<li><strong>取出当前数组长度。</strong></li>
<li><strong>判断是否是“第一次添加元素”</strong>：<ul>
<li>如果 <code>oldCapacity == 0</code> 且 <code>elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>（还没初始化过数组），直接分配一个新数组，长度为 <code>max(默认容量10, minCapacity)</code>。</li>
<li>否则，进入正常扩容逻辑。</li>
</ul>
</li>
<li><strong>正常扩容逻辑</strong>：调用 <code>ArraysSupport.newLength</code> 来计算新数组容量。</li>
<li><strong>在 newLength 中的逻辑</strong>：<ul>
<li>计算推荐容量：<br> <code>prefLength = oldCapacity + max(minGrowth, prefGrowth)</code><br> → 既要满足<strong>最小需求</strong>，又尽量走 <strong>1.5倍扩容策略</strong>。</li>
<li>如果 <code>prefLength</code> 合法（没溢出，且 ≤ SOFT_MAX_ARRAY_LENGTH），直接返回。</li>
<li>否则进入 <strong>hugeLength</strong> 处理超大数组情况。</li>
</ul>
</li>
<li><strong>hugeLength 逻辑</strong>（接近 <code>Integer.MAX_VALUE</code> 时）：<ul>
<li>先计算 <code>minLength = oldLength + minGrowth</code>。</li>
<li>如果溢出（&lt;0），抛 <code>OutOfMemoryError</code>。</li>
<li>如果 <code>minLength</code> 还没超过软最大值（<code>Integer.MAX_VALUE - 8</code>），取软最大值。</li>
<li>否则返回 <code>minLength</code>（可能就是 <code>Integer.MAX_VALUE</code>）。</li>
</ul>
</li>
<li><strong>最终扩容</strong>：申请一个新数组，把旧数据复制过去，完成扩容。</li>
</ol>
<ul>
<li><p><strong>最佳实践</strong>： 如果能预估数据量，<strong>务必使用 <code>ArrayList(int initialCapacity)</code> 构造器指定初始容量</strong>，避免或减少扩容次数。</p>
</li>
<li><p><strong>时间复杂度</strong>：<strong>单次扩容操作</strong>O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加容量以确保它至少可以容纳最小容量参数指定的元素数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity 所需的最小容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> OutOfMemoryError 如果 minCapacity &lt; 0（溢出）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length; <span class="comment">// 旧数组的长度</span></span><br><span class="line">    <span class="comment">// 如果当前数组已经初始化过（不是空数组）</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">// 计算新的容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> ArraysSupport.newLength(</span><br><span class="line">                oldCapacity,</span><br><span class="line">                minCapacity - oldCapacity, <span class="comment">// minGrowth：最小需要增长的数量</span></span><br><span class="line">                oldCapacity &gt;&gt; <span class="number">1</span>           <span class="comment">// prefGrowth：首选增长（旧容量的一半，即 1.5 倍扩容）</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 拷贝数据到新数组</span></span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果还是空数组（第一次添加元素）</span></span><br><span class="line">        <span class="comment">// 初始化容量为 默认值 (10) 或者 minCapacity（取大者）</span></span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArraysSupport.newLength源码</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算扩容后的数组长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> oldLength  原数组长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minGrowth  最小需要增长的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> prefGrowth 首选增长数量（通常是 oldLength / 2，即扩容 1.5 倍）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">newLength</span><span class="params">(<span class="type">int</span> oldLength, <span class="type">int</span> minGrowth, <span class="type">int</span> prefGrowth)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算“首选长度”：旧容量 + (max(最小需要增长, 首选增长))</span></span><br><span class="line">    <span class="comment">// 保证至少能容纳新元素，同时优先使用 1.5 倍扩容策略</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">prefLength</span> <span class="operator">=</span> oldLength + Math.max(minGrowth, prefGrowth);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新长度合法（&gt;0 且没有超过软最大值）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> prefLength; <span class="comment">// 直接返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，尝试计算更大的长度（可能接近 Integer.MAX_VALUE）</span></span><br><span class="line">        <span class="keyword">return</span> hugeLength(oldLength, minGrowth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ArraysSupport.hugeLength源码</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理极大数组的扩容情况（接近 Integer.MAX_VALUE）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeLength</span><span class="params">(<span class="type">int</span> oldLength, <span class="type">int</span> minGrowth)</span> &#123;</span><br><span class="line">    <span class="comment">// 最小需要的数组长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> oldLength + minGrowth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果溢出（&lt;0），抛出 OOM</span></span><br><span class="line">    <span class="keyword">if</span> (minLength &lt; <span class="number">0</span>) &#123; <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>(</span><br><span class="line">            <span class="string">&quot;Required array length &quot;</span> + oldLength + <span class="string">&quot; + &quot;</span> + minGrowth + <span class="string">&quot; is too large&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 如果还没超过软最大值（2^31 - 1 - 8），直接取软最大值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (minLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;</span><br><span class="line">        <span class="keyword">return</span> SOFT_MAX_ARRAY_LENGTH;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 否则，返回真正的最小需求值（可能就是 Integer.MAX_VALUE）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-添加元素-Add"><a href="#5-添加元素-Add" class="headerlink" title="5. 添加元素(Add)"></a>5. 添加元素(Add)</h5><ul>
<li><p><strong><code>public boolean add(E e)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li>计数器++</li>
<li>如果数组已满 → 扩容（grow）。</li>
<li>元素插入数组末尾</li>
<li>size++</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong>摊销常数时间 <code>O(1)</code></strong>（因为扩容操作被分摊到了多次添加操作中）。最坏情况（触发扩容）是 <code>O(n)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向列表末尾追加一个元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要添加的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 永远返回 true（符合 Collection#add 的规范）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;                <span class="comment">// 修改次数计数器（用于快速失败机制）</span></span><br><span class="line">    add(e, elementData, size); <span class="comment">// 调用辅助方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是从 add(E) 方法中拆分出来的辅助方法，</span></span><br><span class="line"><span class="comment"> * 目的是让 add(E) 的字节码长度小于 35（JVM 参数 -XX:MaxInlineSize 的默认值），</span></span><br><span class="line"><span class="comment"> * 这样在 JIT 编译时 add(E) 在 C1 编译器的循环里更容易被内联优化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, Object[] elementData, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果数组已满，需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    <span class="comment">// 将元素放入数组末尾</span></span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    <span class="comment">// size 增加 1</span></span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public void add(int index, E element)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑：</strong></p>
<ol>
<li><code>rangeCheckForAdd(index)</code> 检查下标是否合法（是否在0~size之间）。</li>
<li>修改计数器 <code>modCount++</code>。</li>
<li>如果数组已满 → 扩容（grow）。</li>
<li>使用 <code>System.arraycopy</code> 将 <code>[index, size-1]</code> 区间的元素整体向右移动一格。</li>
<li>把新元素放到 <code>elementData[index]</code>。</li>
<li><code>size++</code>。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>。因为涉及到数组元素的移动。<strong>在列表头部或中间插入元素效率很低</strong>，插入到末尾时（等价于 <code>add(E e)</code>）→ O(1) 均摊。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定位置插入元素，</span></span><br><span class="line"><span class="comment"> * 会将该位置及之后的元素整体向右移动一格。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 插入位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果 index 越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index); <span class="comment">// 检查索引是否有效</span></span><br><span class="line">    modCount++;              <span class="comment">// 修改次数计数器 +1</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> s;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="comment">// 如果数组已满，先扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((s = size) == (elementData = <span class="built_in">this</span>.elementData).length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    <span class="comment">// 将 index 及之后的元素整体向右移动一位</span></span><br><span class="line">    System.arraycopy(elementData, index,</span><br><span class="line">                     elementData, index + <span class="number">1</span>,</span><br><span class="line">                     s - index);</span><br><span class="line">    <span class="comment">// 把新元素放到指定位置</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">// size 增加 1</span></span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * add 和 addAll 使用的 rangeCheck 版本。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="6-删除元素-Remove"><a href="#6-删除元素-Remove" class="headerlink" title="6. 删除元素(Remove)"></a>6. 删除元素(Remove)</h5><p><strong><code>public E remove(int index)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong></p>
<ol>
<li>校验下标是否越界。</li>
<li>取出 <code>elementData[index]</code> 的值，保存为返回值。</li>
<li>调用 <code>fastRemove()</code> 删除该元素。</li>
</ol>
</li>
<li><p><strong>最坏情况 O(n)</strong>：删除第一个元素时，需要移动 <code>n-1</code> 个元素。</p>
</li>
<li><p><strong>最好情况 O(1)</strong>：删除最后一个元素时，无需移动，只是 <code>null</code> 清空和 <code>size--</code>。</p>
</li>
<li><p><strong>平均情况 O(n&#x2F;2)</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除列表中指定位置的元素。</span></span><br><span class="line"><span class="comment"> * 删除后会将该位置之后的元素整体左移一位（索引减 1）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要删除元素的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 被删除的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果下标越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查下标是否有效（0 &lt;= index &lt; size），无效则抛异常</span></span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="comment">// 获取底层数组的引用</span></span><br><span class="line">    <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line">    <span class="comment">// 取出被删除的元素，返回时强转为 E</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> (E) es[index];</span><br><span class="line">    <span class="comment">// 执行快速删除（内部方法），会移动数组元素并更新 size</span></span><br><span class="line">    fastRemove(es, index);</span><br><span class="line">    <span class="comment">// 返回被删除的元素</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内部删除方法，不做边界检查。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(Object[] es, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    modCount++;                  <span class="comment">// 修改次数计数器 +1（迭代器快速失败机制）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> newSize;</span><br><span class="line">    <span class="keyword">if</span> ((newSize = size - <span class="number">1</span>) &gt; i) &#123;</span><br><span class="line">        <span class="comment">// 如果删除的不是最后一个元素：</span></span><br><span class="line">        <span class="comment">// 将 i+1 到 size-1 的元素整体向左移动一位</span></span><br><span class="line">        System.arraycopy(es, i + <span class="number">1</span>, es, i, newSize - i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让最后一个位置为 null，便于 GC 回收对象</span></span><br><span class="line">    es[size = newSize] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="7-获取与修改元素-Get-Set"><a href="#7-获取与修改元素-Get-Set" class="headerlink" title="7. 获取与修改元素(Get&amp;Set)"></a>7. 获取与修改元素(Get&amp;Set)</h5><ul>
<li><p><strong><code>public E get(int index)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li>检查索引越界 。</li>
<li>直接返回 <code>(E) elementData[index]</code>。<strong>纯粹的数组随机访问</strong>。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public E set(int index, E element)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li>检查索引越界。</li>
<li>取出旧元素 <code>E oldValue = elementData(index)</code>。</li>
<li>将新元素放入指定位置 <code>elementData[index] = element</code>。</li>
<li>返回旧元素。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="8-查找-indexOf-lastIndexOf"><a href="#8-查找-indexOf-lastIndexOf" class="headerlink" title="8. 查找(indexOf&#x2F;lastIndexOf)"></a>8. 查找(indexOf&#x2F;lastIndexOf)</h5><ul>
<li><p><strong>indexOf(第一次出现的位置)</strong></p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li>调用 <code>indexOfRange(o, 0, size)</code>。</li>
<li>如果 <code>o == null</code>：从左到右遍历数组，找到第一个 <code>null</code>。</li>
<li>如果 <code>o != null</code>：从左到右遍历数组，调用 <code>o.equals(es[i])</code> 比较。</li>
<li>找到则返回下标；否则返回 <code>-1</code>。</li>
</ol>
</li>
<li><p><strong>最坏情况 O(n)</strong>：元素不存在，需要遍历完整个数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定元素在列表中第一次出现的位置（最小下标），</span></span><br><span class="line"><span class="comment"> * 如果不存在则返回 -1。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 更正式的说：返回最小的下标 i，</span></span><br><span class="line"><span class="comment"> * 满足 Objects.equals(o, get(i))，</span></span><br><span class="line"><span class="comment"> * 如果没有则返回 -1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOfRange(o, <span class="number">0</span>, size); <span class="comment">// 实际调用区间搜索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定范围 [start, end) 内查找元素第一次出现的下标。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要查找的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 搜索起始位置（包含）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end 搜索结束位置（不包含）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 第一次出现的位置，如果不存在返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOfRange</span><span class="params">(Object o, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    Object[] es = elementData;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 查找 null 元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (es[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 查找非 null 元素，调用 equals 比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(es[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>lastIndexOf(最后一次出现)</strong></p>
<ul>
<li><p><strong>源码逻辑：</strong></p>
<ol>
<li>调用 <code>lastIndexOfRange(o, 0, size)</code>。</li>
<li>如果 <code>o == null</code>：从右到左遍历数组，找到最后一个 <code>null</code>。</li>
<li>如果 <code>o != null</code>：从右到左遍历数组，调用 <code>o.equals(es[i])</code> 比较。</li>
<li>找到则返回下标；否则返回 <code>-1</code>。</li>
</ol>
</li>
<li><p><strong>最坏情况 O(n)</strong>：元素不存在，需要遍历完整个数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定元素在列表中最后一次出现的位置（最大下标），</span></span><br><span class="line"><span class="comment"> * 如果不存在则返回 -1。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 更正式的说：返回最大的下标 i，</span></span><br><span class="line"><span class="comment"> * 满足 Objects.equals(o, get(i))，</span></span><br><span class="line"><span class="comment"> * 如果没有则返回 -1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lastIndexOfRange(o, <span class="number">0</span>, size); <span class="comment">// 实际调用区间搜索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定范围 [start, end) 内查找元素最后一次出现的下标。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要查找的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 搜索起始位置（包含）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end 搜索结束位置（不包含）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最后一次出现的位置，如果不存在返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOfRange</span><span class="params">(Object o, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    Object[] es = elementData;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 倒序查找 null 元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end - <span class="number">1</span>; i &gt;= start; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (es[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 倒序查找非 null 元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end - <span class="number">1</span>; i &gt;= start; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(es[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="9-遍历方式"><a href="#9-遍历方式" class="headerlink" title="9. 遍历方式"></a>9. 遍历方式</h5><ul>
<li><strong>索引for循环</strong>： <code>for (int i=0; i&lt;list.size(); i++) { list.get(i); }</code> —— <strong>最高效</strong>，充分利用了 <code>O(1)</code> 的随机访问特性。</li>
<li><strong>迭代器（Iterator）</strong>： 也是常见方式。</li>
<li><strong>for-each循环</strong>： 语法糖，底层是迭代器。</li>
</ul>
<p><strong>注意</strong>： <strong>严禁在遍历过程中使用 <code>ArrayList</code> 的 <code>remove()</code> 等方法修改集合结构</strong>，否则会抛出 <code>ConcurrentModificationException</code>。如需遍历时删除，必须使用 <strong><code>Iterator.remove()</code></strong> 方法。</p>
<hr>
<h5 id="10-典型应用场景"><a href="#10-典型应用场景" class="headerlink" title="10. 典型应用场景"></a>10. 典型应用场景</h5><p><strong>1. “读多写少”或“主要追加操作”的集合</strong></p>
<p>​	这是 ArrayList <strong>最经典、最合适的应用场景</strong>。</p>
<ul>
<li><strong>场景描述</strong>：你需要一个容器来存储数据，大部分操作是<strong>查询和遍历</strong>，而添加操作主要是<strong>在列表末尾追加</strong>，很少或几乎不在列表的中间进行插入和删除。</li>
<li><strong>举例</strong>：<ul>
<li><strong>商品列表</strong>：从数据库查询出一批商品信息展示给用户，用户会频繁地浏览（查询）、翻页、过滤（遍历），但商品列表本身不会频繁变动。</li>
<li><strong>日志记录</strong>：应用程序将日志事件依次添加到日志列表中，最后再统一处理或输出。这主要是追加操作。</li>
<li><strong>配置信息列表</strong>：程序启动时加载一批配置信息到内存中供后续频繁读取。</li>
</ul>
</li>
</ul>
<p><strong>2. 需要通过索引进行频繁随机访问</strong></p>
<ul>
<li><strong>场景描述</strong>：你需要根据位置（第几个）来快速获取或设置元素。</li>
<li><strong>举例</strong>：<ul>
<li>一个学生列表，需要快速获取第 5 个学生的信息。</li>
</ul>
</li>
</ul>
<p><strong>3. 作为临时容器用于计算或转换</strong></p>
<ul>
<li><strong>场景描述</strong>：在进行一些数据处理时，我们常常需要一个有序的、可重复的临时容器来存放中间结果。</li>
<li><strong>举例</strong>：<ul>
<li>从数据库或文件中读出一批数据，先放入 ArrayList，然后在内存中进行排序、过滤、统计等操作。</li>
<li>将一个 Set（集合）转换成一个有序的列表。</li>
</ul>
</li>
</ul>
<p><strong>4. 替代数组，提供更丰富的功能</strong></p>
<ul>
<li><strong>场景描述</strong>：你需要一个类似数组的结构，但希望它的大小能够动态增长，并且不想自己手动处理数组扩容的复杂逻辑。</li>
<li><strong>举例</strong>：<ul>
<li>存储一个不确定数量的对象，比如解析一个 CSV 文件，每一行读到一个 ArrayList 中。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-4-LinkedList【核心掌握】"><a href="#2-2-4-LinkedList【核心掌握】" class="headerlink" title="2.2.4 LinkedList【核心掌握】"></a>2.2.4 LinkedList【核心掌握】</h4><h5 id="1-核心概念-1"><a href="#1-核心概念-1" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>LinkedList</code> 是一个实现了 <code>List</code> 和 <code>Deque</code> 接口的<strong>双向链表</strong>。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>有序（Ordered）</strong>： 元素按照插入顺序存放。</li>
<li><strong>可重复（Allows Duplicates）</strong>： 允许存储相同的元素和 <code>null</code>。</li>
<li><strong>无索引（但模拟索引）</strong>： 底层没有数组，索引访问需要通过遍历实现。</li>
<li><strong>非线程安全（Not Thread-Safe）</strong>： 和 <code>ArrayList</code> 一样，多线程环境下需要手动同步。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层通过一个<strong>双向链表（Doubly-linked list）</strong> 来存储所有元素。所有操作都是通过指针的引用来完成。</li>
<li><strong>设计思想</strong>：用 <strong>双向链表结构</strong> 实现一个 <strong>插入、删除高效，不依赖连续内存</strong> 的通用容器；</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-1"><a href="#2-底层数据结构和关键属性-1" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>LinkedList</code> 的源码（以OpenJDK为例）：</p>
<p>核心节点类是 <strong><code>Node&lt;E&gt;</code></strong>（静态内部类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;         <span class="comment">// 当前节点存储的实际元素</span></span><br><span class="line">    Node&lt;E&gt; next;   <span class="comment">// 指向下一个节点的引用</span></span><br><span class="line">    Node&lt;E&gt; prev;   <span class="comment">// 指向前一个节点的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每个节点都知道 <strong>前驱节点</strong> 和 <strong>后继节点</strong>。</li>
<li>支持从前向后、从后向前遍历。</li>
<li>插入&#x2F;删除节点只需改指针，效率 O(1)。</li>
</ul>
<p>同时，<code>LinkedList</code> 类本身有三个关键属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;       <span class="comment">// 当前链表的元素个数</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;      <span class="comment">// 指向第一个节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;       <span class="comment">// 指向最后一个节点</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>size</code></strong>：记录链表中元素的数量，支持 O(1) 获取长度。</p>
</li>
<li><p><strong><code>first</code></strong>：指向链表头节点，方便 <code>addFirst</code> &#x2F; <code>removeFirst</code> 操作。</p>
</li>
<li><p><strong><code>last</code></strong>：指向链表尾节点，方便 <code>addLast</code> &#x2F; <code>removeLast</code> 操作。</p>
</li>
</ul>
<hr>
<h5 id="3-添加元素（Add）"><a href="#3-添加元素（Add）" class="headerlink" title="3. 添加元素（Add）"></a>3. 添加元素（Add）</h5><ul>
<li><p><strong><code>public boolean add(E e)</code></strong>： <strong>在链表末尾添加元素</strong>。</p>
<ul>
<li><p><strong>源码逻辑</strong></p>
<ol>
<li>内部调用 <code>linkLast(e)</code>。</li>
<li>保存原来的尾节点 <code>last</code>。</li>
<li>创建一个新节点 <code>newNode</code>，其前驱指向原尾节点，数据域存储 <code>e</code>，后继为 <code>null</code>。</li>
<li>更新 <code>last = newNode</code>，使链表尾指针指向新节点。</li>
<li>如果原链表为空（<code>last == null</code>），说明这是第一个节点 → 更新 <code>first = newNode</code>。</li>
<li>否则，将原尾节点的 <code>next</code> 指向 <code>newNode</code>，把新节点接到链表尾部。</li>
<li>更新 <code>size</code> 和 <code>modCount</code>。</li>
</ol>
</li>
<li><p><strong>时间复杂度：O(1)</strong>：直接在尾部插入，不涉及遍历或移动元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在链表末尾添加一个元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要添加的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 永远返回 true（符合 Collection#add 的规范）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);   <span class="comment">// 将元素链接到链表尾部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素作为最后一个节点插入链表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要插入的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;                 <span class="comment">// 取出当前尾节点（可能是 null）</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>); <span class="comment">// 创建新节点，前驱 = l，数据 = e，后继 = null</span></span><br><span class="line">    last = newNode;                         <span class="comment">// 更新尾节点指针</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)                          <span class="comment">// 如果链表之前为空</span></span><br><span class="line">        first = newNode;                    <span class="comment">// 头节点也指向新节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;                   <span class="comment">// 否则，将原尾节点的 next 指向新节点</span></span><br><span class="line">    size++;                                 <span class="comment">// 链表长度 +1</span></span><br><span class="line">    modCount++;                             <span class="comment">// 修改次数计数器 +1（用于 fail-fast 机制）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public void add(int index, E element)</code></strong>： <strong>在指定索引处插入元素</strong>。</p>
<ul>
<li><p><strong>源码逻辑：</strong></p>
<ol>
<li>检查索引是否越界 (<code>checkPositionIndex(index)</code>)。</li>
<li>如果 <code>index == size</code>，说明是在尾部插入，直接调用 <code>linkLast(element)</code>。</li>
<li>否则，调用 <code>linkBefore(element, node(index))</code>。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>。主要是因为 <code>node(index)</code> 查找目标节点需要 <code>O(n)</code> 的时间。但<strong>实际的插入操作（修改指针）本身是 <code>O(1)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在链表的指定位置插入一个元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index   插入位置（范围：0 &lt;= index &lt;= size）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果下标越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    checkPositionIndex(index);   <span class="comment">// 检查下标是否合法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)           <span class="comment">// 插入位置在链表尾部</span></span><br><span class="line">        linkLast(element);       <span class="comment">// 直接追加到末尾</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index)); <span class="comment">// 在指定位置的节点前插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据下标返回对应的节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要查找的节点下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 目标位置的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果在前半部分，从头开始遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果在后半部分，从尾开始向前遍历</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定节点 &#123;<span class="doctag">@code</span> succ&#125; 之前插入新节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e    要插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> succ 插入位置的节点，新节点将插入到它前面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;                     <span class="comment">// succ 的前驱节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);  <span class="comment">// 创建新节点</span></span><br><span class="line">    succ.prev = newNode;                                <span class="comment">// succ 的前驱改为新节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)                                   <span class="comment">// 如果插入位置在头部</span></span><br><span class="line">        first = newNode;                                <span class="comment">// 更新头指针</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;                            <span class="comment">// 前驱的 next 指向新节点</span></span><br><span class="line"></span><br><span class="line">    size++;                                             <span class="comment">// 链表大小 +1</span></span><br><span class="line">    modCount++;                                         <span class="comment">// 修改次数 +1（fail-fast 用）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-删除元素（Remove）"><a href="#4-删除元素（Remove）" class="headerlink" title="4. 删除元素（Remove）"></a>4. 删除元素（Remove）</h5><p><strong><code>public E remove(int index)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li>检查索引越界。</li>
<li>用 <code>node(index)</code> 找到要删除的节点 <code>x</code>。</li>
<li>调用 <code>unlink(Node&lt;E&gt; x)</code> 执行删除。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>。同样，主要时间耗费在 <code>node(index)</code> 查找上，<strong>实际的删除操作（修改指针）是 <code>O(1)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;       <span class="comment">// 要删除的元素</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;    <span class="comment">// 前驱节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;             <span class="comment">// 1. 如果前驱为null，说明x是头节点</span></span><br><span class="line">        first = next;               <span class="comment">//    让first指向x的后继</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;           <span class="comment">// 2. 否则，让前驱节点的next绕过x，指向x的后继</span></span><br><span class="line">        x.prev = <span class="literal">null</span>;              <span class="comment">//    帮助GC</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;             <span class="comment">// 3. 如果后继为null，说明x是尾节点</span></span><br><span class="line">        last = prev;                <span class="comment">//    让last指向x的前驱</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;           <span class="comment">// 4. 否则，让后继节点的prev绕过x，指向x的前驱</span></span><br><span class="line">        x.next = <span class="literal">null</span>;              <span class="comment">//    帮助GC</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="literal">null</span>;                  <span class="comment">// 5. 清空数据，帮助GC</span></span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-获取与修改元素（Get-Set）"><a href="#5-获取与修改元素（Get-Set）" class="headerlink" title="5. 获取与修改元素（Get &amp; Set）"></a>5. 获取与修改元素（Get &amp; Set）</h5><ul>
<li><p><strong><code>public E get(int index)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li>检查索引越界。</li>
<li>调用 <code>node(index)</code> 遍历找到对应节点。</li>
<li>返回 <code>node.item</code>。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public E set(int index, E element)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li>检查索引越界。</li>
<li>调用 <code>node(index)</code> 找到对应节点 <code>x</code>。</li>
<li>保存旧值 <code>E oldVal = x.item</code>。</li>
<li>将新值赋给节点 <code>x.item = element</code>。</li>
<li>返回旧值。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="6-典型应用场景"><a href="#6-典型应用场景" class="headerlink" title="6. 典型应用场景"></a>6. 典型应用场景</h5><ol>
<li><strong>频繁在列表中间进行插入和删除操作</strong></li>
</ol>
<p>​	这是 LinkedList <strong>最经典、最合适的应用场景</strong>。</p>
<ul>
<li><strong>场景描述</strong>：你的业务逻辑需要频繁地在列表的<strong>任意位置</strong>（而不仅仅是末尾）添加或移除元素。</li>
<li><strong>原理</strong>：对于 LinkedList，只要你已经拥有了要操作的节点的引用（例如，通过列表迭代器定位到了那里），插入和删除操作的时间复杂度就是 <strong>O(1)</strong>。相比之下，ArrayList 需要移动后续所有元素，是 <strong>O(n)</strong> 的操作。</li>
<li><strong>举例</strong>：<ul>
<li><strong>任务管理系统</strong>：一个待办事项列表，用户可以随时在列表中间插入高优先级的任务，或者完成&#x2F;删除任意位置的任务。</li>
<li><strong>音乐播放列表</strong>：用户频繁地拖动歌曲改变顺序（先删除再插入），或者从播放列表中间删除歌曲。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>需要实现栈、队列或双端队列</strong></li>
</ol>
<ul>
<li><p><strong>场景描述</strong>：你需要一个后进先出（LIFO）的栈，或者先进先出（FIFO）的队列，或者两端都能进出的双端队列。</p>
</li>
<li><p><strong>原理</strong>：由于 <code>LinkedList</code> 实现了 <code>Deque</code> 接口，它天然提供了这些数据结构所需的所有方法，并且在这些操作的性能上都很好（均为 O(1)）。</p>
</li>
<li><p><strong>举例</strong>：</p>
<ul>
<li><p><strong>作为栈使用</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">stack.push(<span class="string">&quot;A&quot;</span>); <span class="comment">// 入栈</span></span><br><span class="line">stack.push(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop(); <span class="comment">// 出栈，返回 &quot;B&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>作为队列使用</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">queue.offer(<span class="string">&quot;A&quot;</span>); <span class="comment">// 入队</span></span><br><span class="line">queue.offer(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> queue.poll(); <span class="comment">// 出队，返回 &quot;A&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>作为双端队列（Deque）使用</strong>：适合实现“撤销”功能（栈）和“历史记录”功能（队列）的结合。</p>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>内存使用效率不确定的场景</strong></li>
</ol>
<ul>
<li><strong>场景描述</strong>：列表的大小变化非常剧烈且不可预测，有时很大，有时很小。</li>
<li><strong>原理</strong>：<code>LinkedList</code> 的每个元素都是独立分配内存的，添加元素就分配一个新节点，删除元素就释放一个节点，没有像 <code>ArrayList</code> 那样“预分配”的容量概念，因此不会造成内存的空闲浪费。但请注意，每个节点因为要存储两个指针，所以单个元素的内存开销比 ArrayList 大。</li>
<li><strong>举例</strong>：处理一个数据流，其流量极不稳定，可能长时间为空，也可能瞬间涌入大量数据。</li>
</ul>
<hr>
<h4 id="2-2-5-CopyOnWriteArrayList【了解】"><a href="#2-2-5-CopyOnWriteArrayList【了解】" class="headerlink" title="2.2.5 CopyOnWriteArrayList【了解】"></a>2.2.5 CopyOnWriteArrayList【了解】</h4><h5 id="1-核心概念-2"><a href="#1-核心概念-2" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>CopyOnWriteArrayList</code> 是 <code>List</code> 接口的一个<strong>线程安全</strong>的实现。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>有序（Ordered）</strong>： 元素按照插入顺序存放。</li>
<li><strong>可重复（Allows Duplicates）</strong>： 允许存储相同的元素和 <code>null</code>。</li>
<li><strong>有索引（Indexed）</strong>： 可以通过从 <code>0</code> 开始的索引访问元素。</li>
<li><strong>线程安全（Thread-Safe）</strong>： 所有可变操作（add, set, remove等）都是通过<strong>创建底层数组的新副本</strong>来实现的，这保证了线程安全。</li>
<li><strong>写时复制（Copy-On-Write）</strong>： 这是其实现线程安全的核心机制。任何会修改集合结构的操作（写操作）都不是在原数组上进行的，而是先复制一份新的数组，在新数组上进行修改，修改完成后，再将集合的数组引用指向这个新数组。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层使用一个 <strong><code>volatile Object[] array</code></strong> 数组来存储所有元素。其线程安全性不是通过传统的同步锁（如 <code>synchronized</code>）来实现，而是通过 <code>volatile</code> 语义和数组副本的原子性替换来保证的。</li>
<li><strong>设计思想</strong>：<strong>在多线程下用空间换时间，通过写时复制保证读操作无锁且一致，适合读多写少的场景</strong>。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-2"><a href="#2-底层数据结构和关键属性-2" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>CopyOnWriteArrayList</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 通过可重入锁保证线程安全 */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 真正存储ArrayList元素的数组缓冲区，用 volatile 修饰。</span></span><br><span class="line"><span class="comment">     * 任何写操作完成后，都会将新的数组引用原子性地赋值给它，</span></span><br><span class="line"><span class="comment">     * 这保证了读线程能立即看到最新的数组引用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前的数组快照（用于读操作）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原子地设置数组引用（用于写操作完成时）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">        array = a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他方法和构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>array</code></strong>： 这是 <code>CopyOnWriteArrayList</code> 的核心。所有读操作都直接访问这个数组。<code>volatile</code> 关键字确保了数组引用的内存可见性。当一个写操作完成并调用 <code>setArray</code> 后，所有其他线程能立即看到这个新数组。</li>
<li><strong><code>lock</code></strong>： 一个可重入锁 (<strong><code>ReentrantLock</code></strong>)。<strong>所有写操作都必须先获取这把锁</strong>，从而保证同一时刻只有一个线程在进行修改（复制新数组和设置新引用的操作）。这防止了多个写操作同时创建多个不必要的副本，是保证数据一致性的关键。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-1"><a href="#3-构造方法与初始化-1" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>CopyOnWriteArrayList</code> 提供了三种构造方式：</p>
<ol>
<li><p><strong><code>public CopyOnWriteArrayList()</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 初始化一个长度为 0 的空数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个空列表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]); <span class="comment">// 初始化为一个空数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 将传入集合的元素转换为数组，并将此数组设置为底层 <code>array</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个包含指定集合元素的列表，</span></span><br><span class="line"><span class="comment"> * 顺序由集合的迭代器决定。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList.class)</span><br><span class="line">        elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        elements = c.toArray();</span><br><span class="line">        <span class="comment">// c.toArray 可能不会返回 Object[]</span></span><br><span class="line">        <span class="keyword">if</span> (elements.getClass() != Object[].class)</span><br><span class="line">            elements = Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public CopyOnWriteArrayList(E[] toCopyIn)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 使用 <code>Arrays.copyOf</code> 将传入数组的元素复制到一个新数组中，并将此新数组设置为底层 <code>array</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个包含给定数组副本的列表。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> &#123;</span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-添加元素-Add"><a href="#4-添加元素-Add" class="headerlink" title="4. 添加元素(Add)"></a>4. 添加元素(Add)</h5><p><strong><code>public boolean add(E e)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li><strong>加锁</strong>：防止多个线程同时写入，保证线程安全。</li>
<li><strong>获取快照</strong>：取得当前存储数据的数组副本。</li>
<li><strong>复制数组</strong>：通过 <code>Arrays.copyOf</code> 复制一个新的数组，长度 +1。</li>
<li><strong>写入新元素</strong>：把新元素放到新数组的最后一位。</li>
<li><strong>替换引用</strong>：底层数组引用替换为新数组。</li>
<li><strong>释放锁</strong>：保证其他线程可以继续写。</li>
<li><strong>返回 true</strong>。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 线程安全，使用独占锁保证写操作互斥</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;  </span><br><span class="line">        <span class="comment">// 2. 获取当前底层数组（快照）</span></span><br><span class="line">        Object[] es = getArray();</span><br><span class="line">        <span class="comment">// 3. 获取当前数组长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> es.length;</span><br><span class="line">        <span class="comment">// 4. 创建新数组，长度比原数组多 1</span></span><br><span class="line">        <span class="comment">//   -&gt; 注意不是扩容机制，而是直接复制一份新数组</span></span><br><span class="line">        es = Arrays.copyOf(es, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 5. 在新数组最后一个位置放入新元素</span></span><br><span class="line">        es[len] = e;</span><br><span class="line">        <span class="comment">// 6. 将底层数组引用指向新数组</span></span><br><span class="line">        setArray(es);</span><br><span class="line">        <span class="comment">// 7. 返回添加成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-获取元素-Get"><a href="#5-获取元素-Get" class="headerlink" title="5. 获取元素(Get)"></a>5. 获取元素(Get)</h5><p><strong><code>public E get(int index)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li><strong>加锁</strong>：子列表操作必须同步，避免和写操作冲突。</li>
<li><strong>rangeCheck(index)</strong>：检查传入的 <code>index</code> 是否在子列表范围内，否则抛出 <code>IndexOutOfBoundsException</code>。</li>
<li><strong>checkForComodification()</strong>：检测 <code>SubList</code> 的快照是否和父 <code>CopyOnWriteArrayList</code> 一致。如果外部修改了结构，就抛出 <code>ConcurrentModificationException</code>。</li>
<li><strong>调用父列表 get()</strong>：真正的数据存在父 <code>CopyOnWriteArrayList</code> 的数组里，通过 <code>offset + index</code> 计算出全局下标，然后调用父列表的 <code>get()</code>。</li>
<li><strong>返回元素</strong>。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 加锁，保证多线程下子列表访问安全</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;  </span><br><span class="line">        <span class="comment">// 2. 校验下标是否合法（0 &lt;= index &lt; size）</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="comment">// 3. 校验结构是否被外部修改过</span></span><br><span class="line">        <span class="comment">//    确保子列表和父列表一致，避免并发修改问题</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">// 4. 调用外部 CopyOnWriteArrayList 的 get() 方法</span></span><br><span class="line">        <span class="comment">//    offset 表示子列表相对于父列表的起始偏移</span></span><br><span class="line">        <span class="keyword">return</span> CopyOnWriteArrayList.<span class="built_in">this</span>.get(offset + index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="6-修改元素-Set"><a href="#6-修改元素-Set" class="headerlink" title="6. 修改元素(Set)"></a>6. 修改元素(Set)</h5><p><strong><code>public E set(int index, E element)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li><strong>加锁</strong>：子列表操作必须同步，避免写操作冲突。</li>
<li><strong>rangeCheck(index)</strong>：确认 <code>index</code> 在子列表范围内。</li>
<li><strong>checkForComodification()</strong>：确保子列表和父列表共享同一个快照数组。<ul>
<li><strong>调用父列表的 <code>set</code> 方法</strong>：真正的写操作由 <code>CopyOnWriteArrayList.this.set()</code> 完成。<ul>
<li>父列表的 <code>set()</code> 会执行：<ul>
<li>复制整个底层数组（写时复制机制，O(n)）。</li>
<li>修改指定位置的元素。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>更新 expectedArray</strong>：子列表记录最新快照，防止后续一致性错误。</li>
<li><strong>返回旧值</strong>：返回被替换掉的元素。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 子列表加锁，保证线程安全</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;  </span><br><span class="line">        <span class="comment">// 2. 检查下标是否越界（0 &lt;= index &lt; size）</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="comment">// 3. 检查子列表是否和父列表的快照一致</span></span><br><span class="line">        <span class="comment">//    避免并发修改引发数据不一致</span></span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="comment">// 4. 调用父列表 CopyOnWriteArrayList 的 set() 方法</span></span><br><span class="line">        <span class="comment">//    offset 表示子列表起始偏移量</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> CopyOnWriteArrayList.<span class="built_in">this</span>.set(offset + index, element);</span><br><span class="line">        <span class="comment">// 5. 更新当前子列表的 expectedArray 引用</span></span><br><span class="line">        <span class="comment">//    让子列表快照保持和父列表一致</span></span><br><span class="line">        expectedArray = getArray();</span><br><span class="line">        <span class="comment">// 6. 返回被替换掉的旧值</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="7-删除元素-Remove"><a href="#7-删除元素-Remove" class="headerlink" title="7. 删除元素(Remove)"></a>7. 删除元素(Remove)</h5><p><strong><code>public E remove(int index)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li><p><strong>加锁</strong> ： 保证并发删除安全。</p>
</li>
<li><p><strong>获取快照</strong> ： 拿到当前底层数组。</p>
</li>
<li><p><strong>定位要删除的元素</strong> ： 存储在 <code>oldValue</code>。</p>
</li>
<li><p><strong>判断是否删除尾部</strong>：</p>
<ul>
<li><p><strong>尾部删除</strong>：直接 <code>Arrays.copyOf()</code> 拷贝前 <code>len-1</code> 个元素。</p>
</li>
<li><p><strong>中间删除</strong>：新建一个数组，分别拷贝 <strong>前半部分</strong> 和 <strong>后半部分</strong>。</p>
</li>
</ul>
</li>
<li><p><strong>更新底层数组引用</strong> ： 指向新数组。</p>
</li>
<li><p><strong>返回被删除的元素</strong>。</p>
</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>。最坏情况（删除第一个元素）需要复制 <code>n-1</code> 个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 加锁，保证写操作线程安全</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;  </span><br><span class="line">        <span class="comment">// 2. 获取当前底层数组（快照）</span></span><br><span class="line">        Object[] es = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> es.length;</span><br><span class="line">        <span class="comment">// 3. 取出要删除的元素（返回值用）</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementAt(es, index);</span><br><span class="line">        <span class="comment">// 4. 计算要移动的元素个数</span></span><br><span class="line">        <span class="comment">//    如果删的是中间元素，右边的部分要整体往前挪</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> len - index - <span class="number">1</span>;</span><br><span class="line">        Object[] newElements;</span><br><span class="line">        <span class="comment">// 5. 如果删除的是最后一个元素（尾删）</span></span><br><span class="line">        <span class="comment">//    直接复制前 len-1 个即可</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            newElements = Arrays.copyOf(es, len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 如果删除的是中间的元素</span></span><br><span class="line">            <span class="comment">//    需要新建一个数组（比原来少 1）</span></span><br><span class="line">            newElements = <span class="keyword">new</span> <span class="title class_">Object</span>[len - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 6.1 拷贝前半部分（[0, index-1]）</span></span><br><span class="line">            System.arraycopy(es, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            <span class="comment">// 6.2 拷贝后半部分（[index+1, len-1]）</span></span><br><span class="line">            System.arraycopy(es, index + <span class="number">1</span>, newElements, index, numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7. 用新数组替换旧数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="comment">// 8. 返回被删除的旧值</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="8-遍历与迭代器-Iterator"><a href="#8-遍历与迭代器-Iterator" class="headerlink" title="8. 遍历与迭代器(Iterator)"></a>8. 遍历与迭代器(Iterator)</h5><p><strong><code>public Iterator&lt;E&gt; iterator()</code></strong>：</p>
<ul>
<li><p>返回的迭代器是基于<strong>调用 <code>iterator()</code> 方法时</strong>的底层数组快照（<code>snapshot</code>）工作的。</p>
</li>
<li><p>这个迭代器在构造后就不再受后续任何对集合修改操作的影响。<strong>它在迭代过程中不会抛出 <code>ConcurrentModificationException</code></strong>。</p>
</li>
<li><p><strong>不支持</strong>在迭代过程中通过迭代器的 <code>remove()</code>、<code>set()</code>、<code>add()</code> 方法修改集合，调用这些方法会直接抛出 <code>UnsupportedOperationException</code>。</p>
</li>
<li><p><strong>特性</strong>： 这种迭代器被称为 <strong>“弱一致性”（Weakly Consistent）</strong> 迭代器。它反映的是创建迭代器那一刻的集合状态，但不保证能反映迭代过程中集合的后续修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">COWIterator</span>&lt;E&gt;(getArray(), <span class="number">0</span>); <span class="comment">// 传入当前数组快照</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">COWIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">/** 迭代器创建时刻的数组快照 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cursor;</span><br><span class="line">    </span><br><span class="line">    COWIterator(Object[] elements, <span class="type">int</span> initialCursor) &#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements; <span class="comment">// 持有快照引用，后续写操作与此快照无关</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(); <span class="comment">// 不支持修改</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 其他方法同样不支持修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="9-典型应用场景"><a href="#9-典型应用场景" class="headerlink" title="9. 典型应用场景"></a>9. 典型应用场景</h5><ol>
<li><strong>事件监听器或回调函数列表（Most Classic Use Case）</strong></li>
</ol>
<p>这是 <code>CopyOnWriteArrayList</code> <strong>最经典、最完美的应用场景</strong>。</p>
<ul>
<li><strong>场景描述</strong>：在一个事件发布&#x2F;订阅模型中，需要维护一个监听器列表。事件发生时，需要遍历这个列表并通知每一个监听器。</li>
<li><strong>为何适用</strong>：<ul>
<li><strong>读多写极少</strong>：<strong>注册&#x2F;注销监听器（写操作）</strong> 通常发生在系统初始化或配置阶段，频率极低。而<strong>触发事件（读操作，即遍历列表）</strong> 会发生成千上万次，频率极高。</li>
<li><strong>线程安全需求</strong>：事件发布和监听器的注册注销可能来自不同线程。</li>
<li><strong>避免 <code>ConcurrentModificationException</code></strong>：使用普通 <code>ArrayList</code> 时，如果在遍历通知监听器的过程中，另一个线程注销了一个监听器，就会抛出此异常。而 <code>CopyOnWriteArrayList</code> 的迭代器基于旧的快照，遍历过程不会受任何写操作影响，非常安全。</li>
</ul>
</li>
<li><strong>举例</strong>：<ul>
<li>Java Swing&#x2F;AWT 中的 GUI 事件监听器管理。</li>
<li>Spring 框架中的应用事件（<code>ApplicationEvent</code>）和监听器（<code>ApplicationListener</code>）。</li>
<li>任何自定义的观察者模式实现。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>读多写少的“黑名单”或“白名单”</strong></li>
</ol>
<ul>
<li><strong>场景描述</strong>：你需要一个内存中的名单来进行快速查询（例如，检查一个用户ID是否在黑名单中），而这个名单只会被很少量的更新。</li>
<li><strong>为何适用</strong>：<ul>
<li><strong>查询（读）操作</strong>是主体，可能每秒发生几万次，需要极快的速度和无锁。</li>
<li><strong>更新（写）操作</strong>可能每天只有几次，由管理员后台操作。即使复制整个数组，开销也完全可以接受。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>只读操作远多于修改操作的缓存</strong></li>
</ol>
<ul>
<li><strong>场景描述</strong>：缓存一些几乎不变的数据供所有线程频繁读取，偶尔需要重新加载整个缓存。</li>
<li><strong>为何适用</strong>：<ul>
<li>读取无需加锁，性能极高。</li>
<li>当数据源变化需要更新缓存时，直接创建一个新的数组并替换掉旧的（一次写操作）。虽然这次写操作开销大，但频率极低，可以接受。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-6-Vector【过时】"><a href="#2-2-6-Vector【过时】" class="headerlink" title="2.2.6 Vector【过时】"></a>2.2.6 Vector【过时】</h4><h5 id="1-核心概念-3"><a href="#1-核心概念-3" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><p><code>Vector</code> 是 Java 早期版本（1.0）中就存在的一个集合类，它实现了<strong>动态数组</strong>的数据结构，类似于 <code>ArrayList</code>。它的主要特点包括：</p>
<ol>
<li><strong>动态扩容</strong>：当元素数量超过当前容量时，它会自动增长其内部数组的大小（默认增长一倍）。</li>
<li><strong>线程安全</strong>：其几乎所有方法（如 <code>add</code>, <code>get</code>, <code>size</code>）都使用了 <strong><code>synchronized</code></strong> 关键字进行同步，保证了在多线程环境下的线程安全。</li>
<li><strong>顺序访问</strong>：像数组一样，它通过整数索引来访问元素，提供了快速的随机访问能力。</li>
<li><strong>遗留类</strong>：它是 Java 集合框架（Java Collections Framework, 始于 JDK 1.2）诞生之前的类，后来为了融入新的框架，对其进行了改造，使其实现了 <code>List</code> 接口。</li>
</ol>
<hr>
<h5 id="2-性能开销"><a href="#2-性能开销" class="headerlink" title="2. 性能开销"></a>2. 性能开销</h5><p><code>Vector</code> 的线程安全是通过在每个方法上添加 <strong><code>synchronized</code></strong> 同步锁来实现的。</p>
<ul>
<li><strong>单线程场景下的性能损失</strong>：在绝大多数不需要线程安全的单线程应用场景中（这类场景其实占大多数），每次调用 <code>add()</code>, <code>get()</code> 等方法都会进行一次不必要的加锁和解锁操作。这带来了显著的性能开销。</li>
<li><strong>对比 <code>ArrayList</code></strong>：<code>ArrayList</code> 没有使用任何同步机制，因此在单线程环境下速度远快于 <code>Vector</code>。现代开发哲学是 <strong>“默认非线程安全，需要时再由开发者控制同步”</strong>，这样能为大多数场景提供最佳性能。</li>
</ul>
<hr>
<h5 id="3-功能陈旧且设计不佳"><a href="#3-功能陈旧且设计不佳" class="headerlink" title="3. 功能陈旧且设计不佳"></a>3. 功能陈旧且设计不佳</h5><p><code>Vector</code> 是一个遗留类，它有一些在现代集合框架看来比较怪异的设计。</p>
<ul>
<li><strong>枚举器（Enumeration）</strong>：<code>Vector</code> 提供了一个 <code>elements()</code> 方法来返回一个 <code>Enumeration</code> 接口的实例来遍历集合。这是一个古老的迭代器，功能不如后来的 <code>Iterator</code> 强大（例如，<code>Iterator</code> 支持安全的 <code>remove()</code> 操作，而 <code>Enumeration</code> 不支持）。</li>
<li><strong>冗余的方法</strong>：为了保持向后兼容，它拥有一些独特的方法，如 <code>addElement()</code>, <code>elementAt()</code> 等，这些方法与从 <code>List</code> 接口继承来的 <code>add()</code>, <code>get()</code> 功能重复，导致 API 变得臃肿和不清晰。</li>
</ul>
<hr>
<h5 id="4-替代方案"><a href="#4-替代方案" class="headerlink" title="4. 替代方案"></a>4. 替代方案</h5><p>Java 集合框架（Collections Framework）提供了更多、更灵活、更高效的选择。</p>
<ul>
<li><strong>单线程替代品：<code>ArrayList</code></strong><br>在不需要线程安全的情况下，<strong><code>ArrayList</code> 是毫无疑问的首选</strong>。它没有任何同步开销，性能卓越。</li>
<li><strong>多线程替代品：</strong><ul>
<li><strong><code>Collections.synchronizedList()</code></strong>：如果你需要一个线程安全的列表，可以使用 <code>Collections.synchronizedList(new ArrayList())</code> 来包装一个 <code>ArrayList</code>。这提供了和 <code>Vector</code> 类似的同步行为，但更加灵活（你可以选择何时需要同步包装）。</li>
<li><strong><code>CopyOnWriteArrayList</code></strong>：这是 <code>java.util.concurrent</code> 包下的一个高级并发集合。它采用“写时复制”技术，对于<strong>读多写少</strong>的并发场景性能极高。所有的读操作都不需要加锁，只有在写入时才会复制底层数组。它在概念和实现上都比古老的 <code>Vector</code> 更先进。</li>
<li><strong>其他并发集合</strong>：根据不同的场景，还有 <code>ConcurrentLinkedQueue</code> 等更多选择。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-7-Stack【过时】"><a href="#2-2-7-Stack【过时】" class="headerlink" title="2.2.7 Stack【过时】"></a>2.2.7 Stack【过时】</h4><h5 id="1-核心概念-4"><a href="#1-核心概念-4" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><p><code>Stack</code> 类是 Java 早期版本（JDK 1.0）中提供的一个集合类，它代表了一个<strong>后进先出</strong>（LIFO, Last-In-First-Out）的<strong>对象栈</strong>。你可以把它想象成一摞盘子，你总是取最上面的那个（最后放上去的），新的盘子也只能放在最上面。</p>
<p>它继承自 <code>Vector</code> 类，这意味着它<strong>内部使用数组实现</strong>，并且所有<strong>基本操作都是线程安全</strong>的（因为它的父类 <code>Vector</code> 的方法是 <code>synchronized</code> 的）。</p>
<hr>
<h5 id="2-糟糕的继承"><a href="#2-糟糕的继承" class="headerlink" title="2. 糟糕的继承"></a>2. 糟糕的继承</h5><p>这是 <code>Stack</code> 最根本的设计缺陷。栈应该是一个只提供 <code>push</code>、<code>pop</code>、<code>peek</code> 等操作的接口，但 Java 的 <code>Stack</code> 却是一个具体的类，并且继承了 <code>Vector</code> 的所有公共方法。</p>
<p>这意味着，可以完全<strong>破坏栈的 LIFO 原则</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">stack.push(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">stack.push(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本应是栈，却可以使用 Vector 的方法随意操作！</span></span><br><span class="line">stack.add(<span class="number">1</span>, <span class="string">&quot;C&quot;</span>); <span class="comment">// 在中间插入元素！这违反了栈的原则</span></span><br><span class="line"><span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> stack.get(<span class="number">0</span>); <span class="comment">// 随机访问底部元素！</span></span><br><span class="line">stack.remove(<span class="number">0</span>); <span class="comment">// 移除底部元素！</span></span><br><span class="line"></span><br><span class="line">System.out.println(stack); <span class="comment">// 输出什么？栈的结构完全被破坏了。</span></span><br></pre></td></tr></table></figure>

<p>一个真正的栈应该只允许在顶端操作，而 <code>Stack</code> 类暴露了太多不属于栈概念的方法，这使得它非常不严谨。</p>
<hr>
<h5 id="3-性能开销"><a href="#3-性能开销" class="headerlink" title="3. 性能开销"></a>3. 性能开销</h5><p>和 <code>Vector</code> 一样，<code>Stack</code> 的方法是同步的（<code>synchronized</code>）。在绝大多数<strong>单线程</strong>使用栈的场景下（例如算法实现、表达式求值），这种同步带来了<strong>不必要的性能开销</strong>。</p>
<hr>
<h5 id="4-官方推荐使用-Deque-接口及其实现"><a href="#4-官方推荐使用-Deque-接口及其实现" class="headerlink" title="4. 官方推荐使用 Deque 接口及其实现"></a>4. 官方推荐使用 <code>Deque</code> 接口及其实现</h5><p>在 Java 1.6 之后，官方推荐使用 <strong><code>Deque</code></strong>（双端队列）接口来实现栈的功能。<code>Deque</code> 提供了更完整、更一致且性能更好的 LIFO 栈操作方&#96;法。</p>
<blockquote>
<p><strong>JDK 文档原文（<code>Stack</code> 类的注释中）：</strong><br><strong>A more complete and consistent set of LIFO stack operations is provided by the <code>Deque</code> interface and its implementations, which should be used in preference to this class.</strong><br>（<code>Deque</code> 接口及其实现提供了一组更完整、更一致的 LIFO 栈操作，<strong>应该优先于这个类（指Stack）使用</strong>。）</p>
</blockquote>
<hr>
<h5 id="5-替代方案"><a href="#5-替代方案" class="headerlink" title="5. 替代方案"></a>5. 替代方案</h5><p><code>Deque</code> 接口的实现类，如 <strong><code>ArrayDeque</code></strong> 和 <strong><code>LinkedList</code></strong>，是取代 <code>Stack</code> 的完美选择。其中，<strong><code>ArrayDeque</code></strong> 在大多数场景下是性能最好的选择。</p>
<hr>
<h4 id="2-2-8-实现类的对比"><a href="#2-2-8-实现类的对比" class="headerlink" title="2.2.8 实现类的对比"></a>2.2.8 实现类的对比</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>ArrayList</code></th>
<th align="left"><code>LinkedList</code></th>
<th align="left"><code>Vector</code></th>
<th align="left"><code>Stack</code></th>
<th align="left"><strong><code>CopyOnWriteArrayList</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>底层数据结构</strong></td>
<td align="left"><strong>动态数组（Object[]）</strong></td>
<td align="left"><strong>双向链表（Node）</strong></td>
<td align="left"><strong>动态数组（Object[]）</strong></td>
<td align="left"><strong>动态数组（Object[]）</strong>（继承自<code>Vector</code>）</td>
<td align="left"><strong>动态数组（Object[]）</strong></td>
</tr>
<tr>
<td align="left"><strong>所在包</strong></td>
<td align="left"><code>java.util</code></td>
<td align="left"><code>java.util</code></td>
<td align="left"><code>java.util</code></td>
<td align="left"><code>java.util</code></td>
<td align="left"><strong><code>java.util.concurrent</code></strong></td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>是</strong>（方法大多用 <code>synchronized</code> 修饰）</td>
<td align="left"><strong>是</strong>（继承自<code>Vector</code>）</td>
<td align="left"><strong>是</strong>（通过写时复制和锁实现）</td>
</tr>
<tr>
<td align="left"><strong>锁机制</strong></td>
<td align="left">无</td>
<td align="left">无</td>
<td align="left">悲观锁（<code>synchronized</code>方法级）</td>
<td align="left">悲观锁（<code>synchronized</code>方法级）</td>
<td align="left"><strong>写时复制 + 独占锁（<code>ReentrantLock</code>）</strong></td>
</tr>
<tr>
<td align="left"><strong>随机访问性能</strong></td>
<td align="left"><strong>极快（O(1)）</strong></td>
<td align="left"><strong>慢（O(n)）</strong></td>
<td align="left"><strong>快（O(1)）</strong></td>
<td align="left"><strong>快（O(1)）</strong></td>
<td align="left"><strong>快（O(1)）</strong>（读操作无锁）</td>
</tr>
<tr>
<td align="left"><strong>头部插入&#x2F;删除</strong></td>
<td align="left"><strong>慢（O(n)）</strong></td>
<td align="left"><strong>极快（O(1)）</strong></td>
<td align="left"><strong>慢（O(n)）</strong></td>
<td align="left"><strong>不应在此操作</strong></td>
<td align="left"><strong>极慢（O(n)）</strong>（需要复制整个数组）</td>
</tr>
<tr>
<td align="left"><strong>尾部插入&#x2F;删除</strong></td>
<td align="left"><strong>快（O(1)）</strong>（摊销）</td>
<td align="left"><strong>快（O(1)）</strong></td>
<td align="left"><strong>快（O(1)）</strong></td>
<td align="left"><strong>快（O(1)）</strong>（栈顶操作）</td>
<td align="left"><strong>极慢（O(n)）</strong>（需要复制整个数组）</td>
</tr>
<tr>
<td align="left"><strong>内存占用</strong></td>
<td align="left">较小（可能有空闲容量）</td>
<td align="left">较大（需存储指针）</td>
<td align="left">类似<code>ArrayList</code></td>
<td align="left">类似<code>Vector</code></td>
<td align="left"><strong>很大</strong>（写操作时会短暂出现两份完整数据）</td>
</tr>
<tr>
<td align="left"><strong>迭代器</strong></td>
<td align="left"><strong>快速失败（Fail-Fast）</strong></td>
<td align="left"><strong>快速失败（Fail-Fast）</strong></td>
<td align="left"><strong>快速失败（Fail-Fast）</strong></td>
<td align="left"><strong>快速失败（Fail-Fast）</strong></td>
<td align="left"><strong>弱一致性（Weakly Consistent）</strong>（不会抛出<code>CME</code>）</td>
</tr>
<tr>
<td align="left"><strong>扩容机制</strong></td>
<td align="left"><strong>当前容量 * 1.5</strong></td>
<td align="left"><strong>无扩容</strong></td>
<td align="left"><strong>当前容量 * 2</strong></td>
<td align="left"><strong>当前容量 * 2</strong></td>
<td align="left"><strong>每次写操作都按需扩容（len+1或其他）</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="2-3-Set-接口及其实现类"><a href="#2-3-Set-接口及其实现类" class="headerlink" title="2.3 Set 接口及其实现类"></a>2.3 <strong>Set 接口及其实现类</strong></h3><p><code>Set</code> 是 <code>Collection</code> 接口的一个极其重要的子接口。它代表了一个<strong>无序的、不重复、无索引</strong>元素序列。</p>
<h4 id="2-3-1-核心特征"><a href="#2-3-1-核心特征" class="headerlink" title="2.3.1 核心特征"></a>2.3.1 核心特征</h4><ol>
<li><strong>不重复</strong>：这是 <code>Set</code> 最核心、最重要的特性。一个 <code>Set</code> 中不能包含两个相同的元素。更具体地说，<code>Set</code> 不允许包含满足 <code>e1.equals(e2)</code> 的元素对。</li>
<li><strong>无序性（大多数实现）</strong>：<code>Set</code> 不保证维护元素的插入顺序。当然，也有特例（如 <code>LinkedHashSet</code>）和特殊情况（如 <code>TreeSet</code> 根据元素排序）。</li>
<li><strong>无索引</strong>：<code>Set</code> 不像 <code>List</code> 那样有位置的概念，因此没有 <code>get(int index)</code> 方法</li>
<li><strong>最多一个 null 元素</strong>：由于不允许重复，一个 <code>Set</code> 最多只能包含一个 <code>null</code> 元素。</li>
</ol>
<p>正因为这些特性，<code>Set</code> 是处理<strong>去重</strong>业务的完美选择。</p>
<hr>
<h4 id="2-3-2-HashSet【核心掌握】"><a href="#2-3-2-HashSet【核心掌握】" class="headerlink" title="2.3.2 HashSet【核心掌握】"></a>2.3.2 HashSet【核心掌握】</h4><h5 id="1-核心概念-5"><a href="#1-核心概念-5" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>HashSet</code> 是 <code>Set</code> 接口的一个<strong>基于哈希表的实现</strong>。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>唯一性（Uniqueness）</strong>： 不允许存储重复的元素。</li>
<li><strong>无序性（Unordered）</strong>： 不保证元素的迭代顺序，特别是不能保证顺序恒久不变（<code>LinkedHashSet</code> 除外，它维护插入顺序）。</li>
<li><strong>允许Null元素</strong>： 允许存储一个 <code>null</code> 元素。</li>
<li><strong>非线程安全（Not Thread-Safe）</strong>： 多线程环境下未经同步直接使用会导致不确定的结果。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层本质上是一个 <strong><code>HashMap</code></strong> 实例。<code>HashSet</code> 的元素被存储为这个 <code>HashMap</code> 的键（Key），而所有的键都共享同一个<strong>虚拟值（PRESENT）</strong>。</li>
<li><strong>设计思想</strong>： 利用哈希表存储元素，依赖 <code>hashCode</code> 和 <code>equals</code> 保证唯一性，以 O(1) 的代价实现高效的去重和查询。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-3"><a href="#2-底层数据结构和关键属性-3" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>HashSet</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 序列化ID</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5024744406713321676L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet底层存储数据的HashMap实例。</span></span><br><span class="line"><span class="comment">     * HashSet的所有元素实际上是作为该HashMap的Key来存储的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一个静态的、不可变的虚拟对象，用于作为底层HashMap中每个键对应的值。</span></span><br><span class="line"><span class="comment">     * 因为HashSet只关心Key，Value无实际意义。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他方法和构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>map</code></strong>： 所有元素都作为键（Key）存储在这个 <code>HashMap</code> 中。</li>
<li><strong><code>PRESENT</code></strong>： 这是 <code>HashSet</code> 的<strong>虚拟值</strong>。所有键（Key）对应的值（Value）都是这个同一个对象的引用，以此节省内存。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-2"><a href="#3-构造方法与初始化-2" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>HashSet</code> 提供了五种构造方式：</p>
<ol>
<li><p><strong><code>public HashSet()</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 创建一个默认初始容量为16，默认加载因子为0.75的 <code>HashMap</code>。</p>
</li>
<li><p><strong>特点</strong>： <strong>最常用</strong>的构造器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个新的空集合；其底层使用的 &#123;<span class="doctag">@code</span> HashMap&#125; 实例</span></span><br><span class="line"><span class="comment"> * 具有默认的初始容量 (16) 和负载因子 (0.75)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public HashSet(int initialCapacity)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 创建一个指定初始容量，默认加载因子为0.75的 <code>HashMap</code>。</p>
</li>
<li><p><strong>特点</strong>： <strong>显式指定初始容量</strong>。如果能预估元素数量，可以避免早期扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个新的空集合；其底层使用的 &#123;<span class="doctag">@code</span> HashMap&#125; 实例</span></span><br><span class="line"><span class="comment"> * 具有指定的初始容量和默认的负载因子 (0.75)。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@apiNote</span></span></span><br><span class="line"><span class="comment"> * 如果想创建一个能够容纳预期元素数量的 &#123;<span class="doctag">@code</span> HashSet&#125;，</span></span><br><span class="line"><span class="comment"> * 建议使用 &#123;<span class="doctag">@link</span> #newHashSet(int) newHashSet&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 哈希表的初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果初始容量小于 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public HashSet(int initialCapacity, float loadFactor)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 创建一个指定初始容量和指定加载因子的 <code>HashMap</code>。</p>
</li>
<li><p><strong>特点</strong>： <strong>更精细地控制哈希表性能</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个新的空集合；其底层使用的 &#123;<span class="doctag">@code</span> HashMap&#125; 实例</span></span><br><span class="line"><span class="comment"> * 具有指定的初始容量和指定的负载因子。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@apiNote</span></span></span><br><span class="line"><span class="comment"> * 如果想创建一个能够容纳预期元素数量的 &#123;<span class="doctag">@code</span> HashSet&#125;，</span></span><br><span class="line"><span class="comment"> * 建议使用 &#123;<span class="doctag">@link</span> #newHashSet(int) newHashSet&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 哈希映射的初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor      哈希映射的负载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果初始容量小于 0，或者负载因子不大于 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public HashSet(Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 创建一个足以容纳指定集合元素的 <code>HashMap</code>（容量为 <code>c.size()</code> 和 12 中的较大者），然后将集合中的所有元素添加到本 <code>HashSet</code> 中。</p>
</li>
<li><p><strong>特点</strong>： <strong>用一个已有集合来构造</strong>，常用于集合去重。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个新的集合，包含指定集合中的元素。</span></span><br><span class="line"><span class="comment"> * 底层使用的 &#123;<span class="doctag">@code</span> HashMap&#125; 采用默认的负载因子 (0.75)，</span></span><br><span class="line"><span class="comment"> * 并具有足以容纳指定集合中所有元素的初始容量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 要将其元素放入此集合的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的集合为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    map = HashMap.newHashMap(Math.max(c.size(), <span class="number">12</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-添加元素-Add-与保证元素唯一的机制"><a href="#4-添加元素-Add-与保证元素唯一的机制" class="headerlink" title="4. 添加元素(Add)与保证元素唯一的机制"></a>4. 添加元素(Add)与保证元素唯一的机制</h5><p><strong><code>public boolean add(E e)</code></strong></p>
<ul>
<li><p>底层调用<code>HashMap</code>时间复杂度与处理逻辑与<code>HashMap</code>的<code>put</code>方法相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果指定的元素尚未存在于此集合中，则将其添加到集合中。</span></span><br><span class="line"><span class="comment"> * 更正式地说，如果此集合中不存在任何元素 &#123;<span class="doctag">@code</span> e2&#125;，</span></span><br><span class="line"><span class="comment"> * 使得 &#123;<span class="doctag">@code</span> Objects.equals(e, e2)&#125; 返回 true，</span></span><br><span class="line"><span class="comment"> * 则将指定元素 &#123;<span class="doctag">@code</span> e&#125; 添加到集合中。</span></span><br><span class="line"><span class="comment"> * 如果此集合已包含该元素，则不做任何更改并返回 &#123;<span class="doctag">@code</span> false&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要添加到此集合的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此集合之前不包含指定元素，则返回 &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT) == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>最佳实践</strong>： 当你要把自定义类的对象放入 <code>HashSet</code>时，<strong>必须重写该类的 <code>hashCode()</code> 和 <code>equals(Object obj)</code> 方法</strong>，并且要保证相等的对象必须具有相等的哈希码。</p>
<hr>
<h5 id="5-删除元素-Remove"><a href="#5-删除元素-Remove" class="headerlink" title="5. 删除元素(Remove)"></a>5. 删除元素(Remove)</h5><p><strong><code>public boolean remove(Object o)</code></strong></p>
<ul>
<li><p>底层调用<code>HashMap</code>时间复杂度与处理逻辑与<code>HashMap</code>的<code>remove</code>方法相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果指定的元素存在，则将其从集合中移除。</span></span><br><span class="line"><span class="comment"> * 更正式地说，移除集合中满足 &#123;<span class="doctag">@code</span> Objects.equals(o, e)&#125; 的某个元素 &#123;<span class="doctag">@code</span> e&#125;。</span></span><br><span class="line"><span class="comment"> * 如果此集合包含该元素，则返回 &#123;<span class="doctag">@code</span> true&#125;；</span></span><br><span class="line"><span class="comment"> * 换句话说，如果调用导致集合发生了变化，则返回 &#123;<span class="doctag">@code</span> true&#125;。</span></span><br><span class="line"><span class="comment"> * （调用返回后，此集合将不再包含该元素。）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 如果存在，要从此集合中移除的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果集合包含指定元素，则返回 &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o) == PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="6-查找元素-Contains"><a href="#6-查找元素-Contains" class="headerlink" title="6. 查找元素(Contains)"></a>6. 查找元素(Contains)</h5><p><strong><code>public boolean contains(Object o)</code></strong></p>
<ul>
<li><p>底层调用<code>HashMap</code>时间复杂度与处理逻辑与<code>HashMap</code>的<code>containsKey</code>方法相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果此集合包含指定的元素，则返回 &#123;<span class="doctag">@code</span> true&#125;。</span></span><br><span class="line"><span class="comment"> * 更正式地说，当且仅当集合中存在某个元素 &#123;<span class="doctag">@code</span> e&#125;，</span></span><br><span class="line"><span class="comment"> * 使得 &#123;<span class="doctag">@code</span> Objects.equals(o, e)&#125; 返回 true 时，返回 &#123;<span class="doctag">@code</span> true&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o 要测试是否存在于集合中的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此集合包含指定元素，则返回 &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="7-遍历方式"><a href="#7-遍历方式" class="headerlink" title="7. 遍历方式"></a>7. 遍历方式</h5><p>由于 <code>HashSet</code> 没有索引且无序，不能使用普通的 <code>for</code> 循环（基于索引）遍历。</p>
<ol>
<li><p><strong>迭代器（Iterator）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = hashSet.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">element</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>增强for循环（for-each）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Integer element : hashSet) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>forEach + Lambda（Java 8+）</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashSet.forEach(element -&gt; System.out.println(element));</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意</strong>： <strong>严禁在遍历过程中使用 <code>HashSet</code> 的 <code>remove()</code> 等方法修改集合结构</strong>，否则会抛出 <code>ConcurrentModificationException</code>。如需遍历时删除，必须使用 <strong><code>Iterator.remove()</code></strong> 方法。</p>
<hr>
<h5 id="8-典型应用场景"><a href="#8-典型应用场景" class="headerlink" title="8. 典型应用场景"></a>8. 典型应用场景</h5><p><strong>1. 数据去重（最经典、最常用的场景）</strong></p>
<p>这是 <code>HashSet</code> 最直接、最广泛的应用。当你有一个数据集合（如列表、数组），需要快速去除其中的重复项时，使用 <code>HashSet</code> 是最高效便捷的方式。</p>
<p><strong>示例场景</strong>：</p>
<ul>
<li><strong>统计一篇文章中使用了多少个不同的单词</strong>：将文章分割成单词，然后全部添加到一个 <code>HashSet</code> 中，重复的单词会被自动过滤，最后 <code>set.size()</code> 就是不同单词的数量。</li>
<li><strong>清洗数据</strong>：从数据库或文件中读取数据，其中可能包含重复记录，使用 <code>HashSet</code> 可以轻松去除重复项。</li>
<li><strong>提取集合中的唯一值</strong>：例如，从一个用户ID列表中找出所有不重复的活跃用户。</li>
</ul>
<hr>
<p><strong>2. 快速成员检测（检查存在性）</strong></p>
<p><strong>示例场景</strong>：</p>
<ul>
<li><strong>白名单&#x2F;黑名单过滤</strong>：将禁止访问的IP地址（黑名单）或允许访问的用户ID（白名单）预先加载到一个 <code>HashSet</code> 中。当有新的请求到来时，只需调用 <code>set.contains(ip)</code> 即可瞬间判断是否允许通过。</li>
<li><strong>避免重复操作</strong>：在处理任务队列时，可以用一个 <code>HashSet</code> 来记录已经处理过的任务ID，防止同一个任务被重复处理。</li>
<li><strong>图算法中记录已访问节点</strong>：在广度优先搜索（BFS）或深度优先搜索（DFS）中，用一个 <code>HashSet</code> 来记录已经访问过的节点，可以高效防止走回头路和无限循环。</li>
</ul>
<hr>
<p><strong>3. 集合运算</strong></p>
<p><strong>示例场景</strong>：</p>
<ul>
<li><strong>社交网络中的共同好友</strong>：用户A的好友列表是一个Set，用户B的好友列表是另一个Set，它们的交集就是A和B的共同好友。</li>
<li><strong>商品推荐系统</strong>：用户喜欢的商品集合为Set A，另一个用户喜欢的商品集合为Set B，A和B的交集可以用于计算用户相似度，而差集（B - A）则可以用于向A用户推荐他可能感兴趣但还没购买的商品。</li>
<li><strong>权限管理</strong>：一个用户拥有多个角色，每个角色有对应的权限集合。计算用户的全部权限就是所有角色权限集的并</li>
</ul>
<hr>
<h4 id="2-3-3-LinkedHashSet【核心掌握】"><a href="#2-3-3-LinkedHashSet【核心掌握】" class="headerlink" title="2.3.3 LinkedHashSet【核心掌握】"></a>2.3.3 LinkedHashSet【核心掌握】</h4><h5 id="1-核心概念-6"><a href="#1-核心概念-6" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>LinkedHashSet</code> 是 <code>HashSet</code> 的一个子类，是 <code>Set</code> 接口的<strong>哈希表和链表实现</strong>。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>唯一性（Uniqueness）</strong>： 继承自 <code>HashSet</code>，不允许存储重复的元素。</li>
<li><strong>有序性（Ordered）</strong>： <strong>维护元素的插入顺序</strong>。迭代顺序即是元素最初被插入集合的顺序（insertion-order）。</li>
<li><strong>允许Null元素</strong>： 允许存储一个 <code>null</code> 元素。</li>
<li><strong>非线程安全（Not Thread-Safe）</strong>： 多线程环境下未经同步直接使用会导致不确定的结果。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层本质上是一个 <strong><code>LinkedHashMap</code></strong> 实例。它继承了 <code>HashSet</code> 的所有特性，并通过维护一个<strong>运行于所有条目的双向链表</strong>来扩展功能，从而定义了迭代顺序。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-4"><a href="#2-底层数据结构和关键属性-4" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p><code>LinkedHashSet</code> 本身没有定义新的属性，它完全依赖于其父类 <code>HashSet</code> 和底层的 <code>LinkedHashMap</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2851667679971038690L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 构造方法和其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其核心机制隐藏在 <code>HashSet</code> 的一个特殊构造器中，该构造器被 <code>LinkedHashSet</code> 使用：</p>
<p>在 <code>HashSet</code> 类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个新的空的链式哈希集合（仅由 LinkedHashSet 调用的包内私有构造方法）。</span></span><br><span class="line"><span class="comment"> * 底层使用的 HashMap 实例是一个 LinkedHashMap，</span></span><br><span class="line"><span class="comment"> * 其初始容量和负载因子由参数指定。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 哈希映射的初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor      哈希映射的负载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dummy           忽略（用于区分与其他 int、float 构造函数）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果初始容量小于 0，或者负载因子不大于 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>底层结构</strong>： <code>LinkedHashMap</code>。它包含一个 <code>HashMap</code> 的桶数组用于快速查找，同时包含一个<strong>双向链表（Doubly-Linked List）</strong> 用于维护顺序。</li>
<li><strong>链表节点</strong>： <code>LinkedHashMap.Entry</code> 继承自 <code>HashMap.Node</code>，并额外添加了 <code>before</code> 和 <code>after</code> 引用，指向前一个和后一个插入的节点，从而串起整个链表。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-3"><a href="#3-构造方法与初始化-3" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>LinkedHashSet</code> 完全复用了 <code>HashSet</code> 的构造逻辑，并通过调用上述特殊构造器来创建 <code>LinkedHashMap</code> 实例。</p>
<ol>
<li><p><strong><code>public LinkedHashSet()</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 调用父类 <code>HashSet</code> 的特殊构造器，创建一个初始容量为16，加载因子为0.75的 <code>LinkedHashMap</code>。</p>
</li>
<li><p><strong>特点</strong>： <strong>最常用</strong>的构造器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="number">16</span>, <span class="number">.75f</span>, <span class="literal">true</span>); <span class="comment">// 调用HashSet(int, float, boolean)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public LinkedHashSet(int initialCapacity)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 调用父类构造器，创建一个指定初始容量，默认加载因子为0.75的 <code>LinkedHashMap</code>。</p>
</li>
<li><p><strong>特点</strong>： <strong>显式指定初始容量</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public LinkedHashSet(int initialCapacity, float loadFactor)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 调用父类构造器，创建一个指定初始容量和指定加载因子的 <code>LinkedHashMap</code>。</p>
</li>
<li><p><strong>特点</strong>： <strong>更精细地控制哈希表性能</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public LinkedHashSet(Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 创建一个足以容纳指定集合元素的 <code>LinkedHashMap</code>（容量为 <code>Math.max(2*c.size(), 11)</code>），然后将集合中的所有元素按迭代器顺序添加到本 <code>LinkedHashSet</code> 中。</p>
</li>
<li><p><strong>特点</strong>： <strong>用一个已有集合来构造</strong>，新集合的迭代顺序由原集合 <code>c</code> 的迭代器顺序决定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-维护插入顺序的机制"><a href="#4-维护插入顺序的机制" class="headerlink" title="4. 维护插入顺序的机制"></a>4. 维护插入顺序的机制</h5><p>这是 <code>LinkedHashSet</code> 最核心的特性，其实现完全委托给底层的 <code>LinkedHashMap</code>。</p>
<hr>
<h5 id="5-添加、删除、查找元素"><a href="#5-添加、删除、查找元素" class="headerlink" title="5. 添加、删除、查找元素"></a>5. 添加、删除、查找元素</h5><p><code>LinkedHashSet</code> <strong>没有重写</strong> <code>HashSet</code> 的 <code>add</code>, <code>remove</code>, <code>contains</code> 等方法。它完全继承了 <code>HashSet</code> 的实现，只是底层Map的实现从 <code>HashMap</code> 换成了 <code>LinkedHashMap</code>。</p>
<p>因此，这些操作的<strong>时间复杂度与 <code>HashSet</code> 完全一致</strong>：</p>
<ul>
<li><strong><code>add(E e)</code></strong>, <strong><code>remove(Object o)</code></strong>, <strong><code>contains(Object o)</code></strong>: 平均情况 <code>O(1)</code>，最坏情况 <code>O(n)</code> 或 <code>O(log n)</code>。</li>
</ul>
<p>唯一的区别是，在执行这些操作时，底层的 <code>LinkedHashMap</code> 会额外地维护双向链表，这会带来微小的常数级时间开销，但时间复杂度级别不变。</p>
<hr>
<h5 id="6-遍历方式"><a href="#6-遍历方式" class="headerlink" title="6. 遍历方式"></a>6. 遍历方式</h5><p>与 <code>HashSet</code> 相同，但由于有内部链表维护顺序，遍历结果是有保障的。</p>
<ol>
<li><strong>迭代器（Iterator）</strong>： <strong>按插入顺序</strong>进行迭代。</li>
<li><strong>增强for循环（for-each）</strong>： 底层是迭代器，<strong>按插入顺序</strong>进行迭代。</li>
<li><strong>forEach + Lambda（Java 8+）</strong>: <strong>按插入顺序</strong>进行迭代。</li>
</ol>
<hr>
<h5 id="7-典型应用场景"><a href="#7-典型应用场景" class="headerlink" title="7. 典型应用场景"></a>7. 典型应用场景</h5><p><strong>1. 需要维护插入顺序的去重场景（最核心场景）</strong></p>
<p>当你需要一个集合自动去重，但又希望遍历顺序和添加顺序一致时，<code>LinkedHashSet</code> 是最完美、最直观的选择。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>记录用户操作流水并去重</strong>：需要记录用户一系列唯一的操作（如点击的菜单ID），并且后续需要按照用户的点击顺序来进行分析或回放。使用 <code>HashSet</code> 会丢失顺序，使用 <code>ArrayList</code> 需要自己处理去重逻辑，而 <code>LinkedHashSet</code> 一举两得。</li>
<li><strong>数据清洗与保序</strong>：从文件或数据库中读取数据，需要去除重复行，但必须保持剩余行的原始顺序。例如，处理一个日志文件，要剔除重复的错误记录，但分析时需要按发生时间（即读取顺序）排列。</li>
<li><strong>生成有序的唯一值集合</strong>：例如，从一个无序的、含重复项的列表中提取所有不重复的元素，并要求结果列表保持元素第一次出现的相对顺序。</li>
</ul>
<hr>
<p><strong>2. 实现简单的 LRU（最近最少使用）缓存</strong></p>
<p>LRU 缓存是一种常见的缓存淘汰算法，其核心思想是“如果数据最近被访问过，那么将来被访问的概率也更高”。当缓存满时，它会优先淘汰最久未被访问的数据。</p>
<p><code>LinkedHashSet</code> 本身并不直接支持完整的 LRU 缓存实现（因为它缺乏根据访问重新排序的特性），但它为实现 LRU 缓存提供了绝佳的基础。通过重写其 <code>removeEldestEntry</code> 方法（实际上是在其父类 <code>LinkedHashMap</code> 中），可以非常轻松地创建一个具有 LRU 策略的缓存。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>缓存热点数据</strong>：缓存用户信息、商品信息等，当缓存达到容量上限时，自动淘汰最久未被访问的数据。</li>
<li><strong>连接池、线程池</strong>：管理有限的资源，保持最近被使用的资源。</li>
</ul>
<hr>
<p><strong>3. 需要预测迭代顺序的集合</strong></p>
<p>在某些场景下，集合的迭代顺序必须是可预测的，而不能是 <code>HashSet</code> 那样随机的顺序。<code>LinkedHashSet</code> 提供的稳定的插入顺序，使得程序的行为更加确定，有利于调试和日志记录。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>单元测试</strong>：测试一个返回集合的方法时，如果顺序是固定的，断言就更容易编写和阅读。</li>
<li><strong>生成确定性输出</strong>：例如，根据处理过程生成一个报告，报告中的项目顺序需要与输入源中第一次出现的顺序一致，以确保每次运行的结果都是相同的。</li>
</ul>
<hr>
<h4 id="2-3-4-TreeSet【核心掌握】"><a href="#2-3-4-TreeSet【核心掌握】" class="headerlink" title="2.3.4 TreeSet【核心掌握】"></a>2.3.4 TreeSet【核心掌握】</h4><h5 id="1-核心概念-7"><a href="#1-核心概念-7" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>TreeSet</code> 是 <code>Set</code> 接口的一个<strong>基于红黑树（Red-Black tree）的 NavigableSet 实现</strong>。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>唯一性（Uniqueness）</strong>： 不允许存储重复的元素。</li>
<li><strong>有序性（Ordered）</strong>： <strong>元素按照某种明确的规则自动排序</strong>。排序规则可以是元素的自然顺序（实现 <code>Comparable</code> 接口），也可以是创建 <code>TreeSet</code> 时提供的 <code>Comparator</code> 所定义的顺序。</li>
<li><strong>不允许Null元素</strong>： 如果使用自然排序，或者提供的 <code>Comparator</code> 不支持与 <code>null</code> 比较，尝试添加 <code>null</code> 元素将抛出 <code>NullPointerException</code>。</li>
<li><strong>非线程安全（Not Thread-Safe）</strong>： 多线程环境下未经同步直接使用会导致不确定的结果。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层本质上是一个 <strong><code>TreeMap</code></strong> 实例。<code>TreeSet</code> 的元素被存储为这个 <code>TreeMap</code> 的键（Key），而所有的键都共享同一个<strong>虚拟值（PRESENT）</strong>。元素的排序和存储由 <code>TreeMap</code> 的红黑树数据结构保证。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-5"><a href="#2-底层数据结构和关键属性-5" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>TreeSet</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TreeSet底层存储数据的TreeMap实例。</span></span><br><span class="line"><span class="comment">     * TreeSet的所有元素实际上是作为该TreeMap的Key来存储的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一个静态的、不可变的虚拟对象，用于作为底层TreeMap中每个键对应的值。</span></span><br><span class="line"><span class="comment">     * 因为TreeSet只关心Key，Value无实际意义。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他方法和构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>m</code></strong>： 所有元素都作为键（Key）存储在这个 <code>NavigableMap</code>（实际上是 <code>TreeMap</code>）中。</li>
<li><strong><code>PRESENT</code></strong>： 这是 <code>TreeSet</code> 的<strong>虚拟值</strong>。所有键（Key）对应的值（Value）都是这个同一个对象的引用。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-4"><a href="#3-构造方法与初始化-4" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>TreeSet</code> 提供了四种构造方式，决定了其排序规则：</p>
<ol>
<li><p><strong><code>public TreeSet()</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 创建一个使用元素的<strong>自然顺序</strong>进行排序的 <code>TreeMap</code>。</p>
</li>
<li><p><strong>特点</strong>： 集合中的元素<strong>必须实现 <code>Comparable</code> 接口</strong>，否则在添加时会抛出 <code>ClassCastException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;()); <span class="comment">// 使用自然排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public TreeSet(Comparator&lt;? super E&gt; comparator)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 创建一个使用指定的<strong>定制比较器（Comparator）</strong> 进行排序的 <code>TreeMap</code>。</p>
</li>
<li><p><strong>特点</strong>： <strong>优先级高于自然排序</strong>。即使元素实现了 <code>Comparable</code> 接口，也会使用此 <code>Comparator</code> 来排序。允许更灵活的排序逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public TreeSet(Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 创建一个使用自然顺序的 <code>TreeSet</code>，并将指定集合 <code>c</code> 中的所有元素添加进来。</p>
</li>
<li><p><strong>特点</strong>： 集合 <code>c</code> 中的元素必须实现 <code>Comparable</code> 接口，或者都是可以相互比较的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(); <span class="comment">// 调用无参构造器</span></span><br><span class="line">    addAll(c); <span class="comment">// 添加所有元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public TreeSet(SortedSet&lt;E&gt; s)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 创建一个新的 <code>TreeSet</code>，其排序规则与指定的有序集合 <code>s</code> 相同，并包含 <code>s</code> 中的所有元素。</p>
</li>
<li><p><strong>特点</strong>： 高效地复制一个已有有序集合的排序规则和元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(s.comparator()); <span class="comment">// 使用s的比较器</span></span><br><span class="line">    addAll(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-添加元素-Add-与保证元素唯一和有序的机制"><a href="#4-添加元素-Add-与保证元素唯一和有序的机制" class="headerlink" title="4. 添加元素(Add)与保证元素唯一和有序的机制"></a>4. 添加元素(Add)与保证元素唯一和有序的机制</h5><p><strong><code>public boolean add(E e)</code></strong></p>
<ul>
<li><p>底层调用<code>TreeMap</code>时间复杂度与处理逻辑与<code>TreeMap</code>的<code>put</code>方法相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-删除元素-Remove-1"><a href="#5-删除元素-Remove-1" class="headerlink" title="5. 删除元素(Remove)"></a>5. 删除元素(Remove)</h5><p><strong><code>public boolean remove(Object o)</code></strong></p>
<ul>
<li><p>底层调用<code>TreeMap</code>时间复杂度与处理逻辑与<code>TreeMap</code>的<code>remove</code>方法相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="6-查找元素-Contains-1"><a href="#6-查找元素-Contains-1" class="headerlink" title="6. 查找元素(Contains)"></a>6. 查找元素(Contains)</h5><p><strong><code>public boolean contains(Object o)</code></strong></p>
<ul>
<li><p>底层调用<code>TreeMap</code>时间复杂度与处理逻辑与<code>TreeMap</code>的<code>containsKey</code>方法相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="7-导航方法（Navigation-Methods）"><a href="#7-导航方法（Navigation-Methods）" class="headerlink" title="7. 导航方法（Navigation Methods）"></a>7. 导航方法（Navigation Methods）</h5><p>作为 <code>NavigableSet</code> 的实现，<code>TreeSet</code> 提供了一系列强大的导航方法，用于报告给定搜索目标的最接近匹配项。这是 <code>TreeSet</code> 相比 <code>HashSet</code> 和 <code>LinkedHashSet</code> 的一大优势（底层都是调用<code>TreeMap</code>提供的方法）。</p>
<ul>
<li><strong><code>E ceiling(E e)</code></strong>： 返回<strong>大于等于</strong> <code>e</code> 的<strong>最小</strong>元素，不存在则返回 <code>null</code>。</li>
<li><strong><code>E floor(E e)</code></strong>： 返回<strong>小于等于</strong> <code>e</code> 的<strong>最大</strong>元素，不存在则返回 <code>null</code>。</li>
<li><strong><code>E higher(E e)</code></strong>： 返回<strong>严格大于</strong> <code>e</code> 的<strong>最小</strong>元素，不存在则返回 <code>null</code>。</li>
<li><strong><code>E lower(E e)</code></strong>： 返回<strong>严格小于</strong> <code>e</code> 的<strong>最大</strong>元素，不存在则返回 <code>null</code>。</li>
<li><strong><code>E pollFirst()</code></strong>： 获取并移除<strong>第一个（最小）</strong> 元素。</li>
<li><strong><code>E pollLast()</code></strong>： 获取并移除<strong>最后一个（最大）</strong> 元素。</li>
</ul>
<p>这些方法的时间复杂度也都是 <strong><code>O(log n)</code></strong>。</p>
<hr>
<h5 id="8-遍历方式"><a href="#8-遍历方式" class="headerlink" title="8. 遍历方式"></a>8. 遍历方式</h5><p><code>TreeSet</code> 的迭代器按排序顺序返回元素。这是通过红黑树的<strong>中序遍历</strong>实现的。</p>
<ol>
<li><p><strong>迭代器（Iterator）</strong>： **按排序顺序（升序）**进行迭代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = treeSet.iterator();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>降序迭代器（Descending Iterator）</strong>： **按排序顺序的逆序（降序）**进行迭代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; descIterator = treeSet.descendingIterator();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>增强for循环（for-each）</strong>： 底层是升序迭代器，**按排序顺序（升序）**进行迭代。</p>
</li>
<li><p><strong>forEach + Lambda（Java 8+）</strong>: **按排序顺序（升序）**进行迭代。</p>
</li>
</ol>
<p><strong>注意</strong>： 与其它 <code>Set</code> 一样，<strong>严禁在遍历过程中使用 <code>TreeSet</code> 的 <code>remove()</code> 等方法修改集合结构</strong>，否则会抛出 <code>ConcurrentModificationException</code>。如需遍历时删除，必须使用 <strong><code>Iterator.remove()</code></strong> 方法。</p>
<hr>
<h5 id="9-典型应用场景-1"><a href="#9-典型应用场景-1" class="headerlink" title="9. 典型应用场景"></a>9. 典型应用场景</h5><p><strong>1. 需要维护一个自动排序的唯一集合（核心场景）</strong></p>
<p>这是 <code>TreeSet</code> 最直接、最经典的应用。当你需要一个集合，它既能自动去重，又能始终保持所有元素处于排序状态时，<code>TreeSet</code> 是唯一的选择。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>排行榜</strong>：记录游戏玩家的分数，要求分数从高到低排序且不能重复（或者处理同分情况后唯一）。每当玩家分数更新时，只需将其新分数对象添加到 <code>TreeSet</code>，集合会自动将其放在正确的位置。</li>
<li><strong>日程安排</strong>：存储一系列唯一的、未来的时间点（<code>Date</code> 或 <code>Instant</code> 对象），<code>TreeSet</code> 可以自动按时间先后排序，方便快速找到下一个要执行的任务。</li>
<li><strong>词汇表</strong>：存储单词并要求按字母顺序排列。</li>
</ul>
<p><strong>代码示例（排行榜）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有一个PlayerScore类，实现了Comparable接口按分数降序排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlayerScore</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;PlayerScore&gt; &#123;</span><br><span class="line">    String playerName;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 构造方法、getter ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(PlayerScore other)</span> &#123;</span><br><span class="line">        <span class="comment">// 按分数降序排，分数相同按名字排（保证唯一性）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">scoreCompare</span> <span class="operator">=</span> Integer.compare(other.score, <span class="built_in">this</span>.score);</span><br><span class="line">        <span class="keyword">return</span> scoreCompare != <span class="number">0</span> ? scoreCompare : <span class="built_in">this</span>.playerName.compareTo(other.playerName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用TreeSet自动维护排行榜</span></span><br><span class="line">NavigableSet&lt;PlayerScore&gt; leaderboard = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">leaderboard.add(<span class="keyword">new</span> <span class="title class_">PlayerScore</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">950</span>));</span><br><span class="line">leaderboard.add(<span class="keyword">new</span> <span class="title class_">PlayerScore</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">1200</span>));</span><br><span class="line">leaderboard.add(<span class="keyword">new</span> <span class="title class_">PlayerScore</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">750</span>));</span><br><span class="line">leaderboard.add(<span class="keyword">new</span> <span class="title class_">PlayerScore</span>(<span class="string">&quot;David&quot;</span>, <span class="number">1200</span>)); <span class="comment">// 与Bob同分，但名字不同，会被加入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动按分数从高到低输出</span></span><br><span class="line"><span class="keyword">for</span> (PlayerScore ps : leaderboard) &#123;</span><br><span class="line">    System.out.println(ps.getPlayerName() + <span class="string">&quot;: &quot;</span> + ps.getScore());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Bob: 1200</span></span><br><span class="line"><span class="comment">// David: 1200</span></span><br><span class="line"><span class="comment">// Alice: 950</span></span><br><span class="line"><span class="comment">// Charlie: 750</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2. 需要频繁进行范围查询和导航操作</strong></p>
<p>得益于 <code>NavigableSet</code> 接口，<code>TreeSet</code> 提供了极其强大的方法来查询相对于某个元素的“邻居”，或者获取集合中的某个子集（范围查询）。这些操作都非常高效（O(log n)）。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>查找界限</strong>：在一个考试成绩集合中，快速找到“比85分低一分的那个成绩” (<code>lower(85)</code>）或者“比60分高的第一个成绩” (<code>higher(60)</code>）。</li>
<li><strong>获取数据切片</strong>：处理有序数据时，需要获取某一范围内的所有数据，例如获取所有分数在 70 到 90 分之间的学生 (<code>subSet(70, true, 90, true)</code>)。</li>
<li><strong>实现最近邻搜索</strong>：在一个坐标集合中，快速找到与某个给定值最接近的元素（通过 <code>floor()</code> 和 <code>ceiling()</code> 方法比较即可）。</li>
</ul>
<p><strong>代码示例（范围查询）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Integer&gt; scores = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(Arrays.asList(<span class="number">56</span>, <span class="number">72</span>, <span class="number">83</span>, <span class="number">90</span>, <span class="number">65</span>, <span class="number">100</span>, <span class="number">45</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有及格（&gt;=60）的成绩</span></span><br><span class="line">NavigableSet&lt;Integer&gt; passingScores = scores.tailSet(<span class="number">60</span>, <span class="literal">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Passing Scores: &quot;</span> + passingScores); <span class="comment">// [65, 72, 83, 90, 100]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有80分到90分之间的成绩（包括80，不包括90）</span></span><br><span class="line">NavigableSet&lt;Integer&gt; between80And90 = scores.subSet(<span class="number">80</span>, <span class="literal">true</span>, <span class="number">90</span>, <span class="literal">false</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Between 80 and 90: &quot;</span> + between80And90); <span class="comment">// [83]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出比85分小的最大元素（即小于85的最大值）</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">justBelow85</span> <span class="operator">=</span> scores.lower(<span class="number">85</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Just below 85: &quot;</span> + justBelow85); <span class="comment">// 83</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>3. 需要按顺序处理数据且允许高效插入&#x2F;删除</strong></p>
<p>虽然 <code>ArrayList</code> 也可以排序 (<code>Collections.sort()</code>)，但每次插入新元素后都要重新排序的成本是 O(n log n)。而 <code>TreeSet</code> 在每次插入时维护有序性的成本仅为 O(log n)。如果数据是动态变化的，并且需要随时保持有序，<code>TreeSet</code> 的整体性能会远优于“列表+重复排序”的方案。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>实时数据流排序</strong>：传感器数据源源不断地传来，你需要实时维护一个唯一且有序的数据集合来进行监控。</li>
<li><strong>优先级队列的替代方案</strong>：<code>TreeSet</code> 提供了比 <code>PriorityQueue</code> 更丰富的操作（如查看中间元素、删除任意元素等）。如果你需要的是一个有序集合而不仅仅是按优先级取出，<code>TreeSet</code> 是更好的选择。（注意：<code>PriorityQueue</code> 允许重复元素，而 <code>TreeSet</code> 不允许）。</li>
</ul>
<hr>
<h4 id="2-3-5-EnumSet【了解】"><a href="#2-3-5-EnumSet【了解】" class="headerlink" title="2.3.5 EnumSet【了解】"></a>2.3.5 EnumSet【了解】</h4><h5 id="1-核心概念-8"><a href="#1-核心概念-8" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>EnumSet</code> 是一个专用于<strong>枚举类型</strong>的高性能 <code>Set</code> 实现。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>专属（Specialized）</strong>： 只能存储<strong>单一枚举类型</strong>的元素。枚举类型在创建集合时显式或隐式地指定。</li>
<li><strong>高性能（High Performance）</strong>： 所有基本操作（如 <code>add</code>, <code>remove</code>, <code>contains</code>）都在<strong>常数时间 <code>O(1)</code></strong> 内完成，且非常快，因为它基于位向量（Bit Vector）实现。</li>
<li><strong>内存高效（Memory Efficient）</strong>： 内部使用位掩码（bitmask）或长整型（long）来表示集合，非常节省空间。</li>
<li><strong>类型安全（Type-Safe）</strong>： 由于专用于单一枚举类型，提供了编译时的类型安全。</li>
<li><strong>非线程安全（Not Thread-Safe）</strong>： 与大多数标准集合实现一样，未经同步直接在多线程环境下使用会导致不确定的结果。可以使用 <code>Collections.synchronizedSet</code> 包装。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层使用一个 <strong><code>long</code></strong> 类型的位向量（或 <code>long[]</code>）<code>elements</code> 来存储集合的状态。枚举实例的序数（<code>ordinal</code>）作为位的位置，该位是 1 还是 0 表示元素是否存在。所有操作都通过高效的位运算（如 <code>|</code>, <code>&amp;</code>, <code>^</code>, <code>~</code>）来完成。</li>
<li><strong>设计思想</strong>：<strong>利用枚举类型的有限性，通过位向量表示集合，实现高效、类型安全、低内存占用的 Set 实现</strong>。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-6"><a href="#2-底层数据结构和关键属性-6" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>EnumSet</code> 的源码（以OpenJDK为例），它是一个抽象类，有两个包私有的具体实现：<code>RegularEnumSet</code>（用于枚举常量数 &lt;&#x3D; 64）和 <code>JumboEnumSet</code>（用于枚举常量数 &gt; 64）。它们的核心属性如下：</p>
<p><strong><code>RegularEnumSet</code> (用于小枚举，&lt;&#x3D; 64个元素)：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RegularEnumSet</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; <span class="keyword">extends</span> <span class="title class_">EnumSet</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 位向量（Bit vector），每一位代表对应序数的枚举常量是否存在。</span></span><br><span class="line"><span class="comment">     * 枚举常量 e 的存在性由表达式 (elements &amp; (1L &lt;&lt; e.ordinal())) != 0) 判断。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">elements</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">// 初始状态，所有位为0，表示空集</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>JumboEnumSet</code> (用于大枚举，&gt; 64个元素)：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JumboEnumSet</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; <span class="keyword">extends</span> <span class="title class_">EnumSet</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 位向量数组。每一位代表对应序数的枚举常量是否存在。</span></span><br><span class="line"><span class="comment">     * 数组的长度为：((universe.length - 1) &gt;&gt;&gt; 6) + 1</span></span><br><span class="line"><span class="comment">     * 即 (元素总数 - 1) / 64 + 1，向上取整。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> elements[]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组中有效元素（long）的个数，减少某些计算中的循环次数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>elements</code> (long 或 long[])</strong>： 这是 <code>EnumSet</code> 的<strong>心脏</strong>。所有集合成员信息都压缩存储在这里。</li>
<li><strong><code>size</code> (仅在 <code>JumboEnumSet</code> 中)</strong>： 记录当前集合中<strong>实际有多少个有效元素</strong>。在 <code>RegularEnumSet</code> 中，通过计算 <code>Long.bitCount(elements)</code> 来获得大小。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-5"><a href="#3-构造方法与初始化-5" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>EnumSet</code> 是一个抽象类，所有构造器都是包私有的。它提供了一系列<strong>静态工厂方法</strong>来创建实例。工厂方法会根据枚举类型的常量数量自动选择 <code>RegularEnumSet</code> 或 <code>JumboEnumSet</code>。</p>
<ol>
<li><p><strong><code>public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 获取枚举的所有常量 <code>E[] universe = getUniverse(elementType)</code>。如果常量数 &lt;&#x3D; 64，创建 <code>RegularEnumSet</code>，否则创建 <code>JumboEnumSet</code>。</p>
</li>
<li><p><strong>特点</strong>： 创建一个空的 <code>EnumSet</code>。这是最基础的工厂方法，其他方法（如 <code>of</code>, <code>range</code>）内部都调用了它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt; EnumSet&lt;E&gt; <span class="title function_">noneOf</span><span class="params">(Class&lt;E&gt; elementType)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取该枚举类型的所有实例</span></span><br><span class="line">    E[] universe = getUniverse(elementType);</span><br><span class="line">    <span class="keyword">if</span> (universe == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassCastException</span>(elementType + <span class="string">&quot; not an enum&quot;</span>);</span><br><span class="line">    <span class="comment">// 根据数量决定具体实现</span></span><br><span class="line">    <span class="keyword">if</span> (universe.length &lt;= <span class="number">64</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegularEnumSet</span>&lt;&gt;(elementType, universe);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JumboEnumSet</span>&lt;&gt;(elementType, universe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; allOf(Class&lt;E&gt; elementType)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 调用 <code>noneOf</code> 创建空集，然后调用 <code>complement()</code> 或直接设置所有位为 1，来填充所有元素。</p>
</li>
<li><p><strong>特点</strong>： 创建一个包含指定枚举类型所有常量的 <code>EnumSet</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegularEnumSet 的实现</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (universe.length != <span class="number">0</span>)</span><br><span class="line">        elements = -<span class="number">1L</span> &gt;&gt;&gt; -universe.length; <span class="comment">// 将前 universe.length 位设为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JumboEnumSet 的实现</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; elements.length; i++)</span><br><span class="line">        elements[i] = -<span class="number">1</span>; <span class="comment">// 每个 long 都设为全1</span></span><br><span class="line">    elements[elements.length - <span class="number">1</span>] &gt;&gt;&gt;= -universe.length; <span class="comment">// 清理末尾多余的位</span></span><br><span class="line">    size = universe.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; of(E e1, E e2, E e3, E e4, E e5)</code></strong> 及其重载</p>
<ul>
<li><strong>源码逻辑</strong>： 调用 <code>noneOf(e1.getDeclaringClass())</code> 创建空集，然后依次 <code>add</code> 传入的元素。</li>
<li><strong>特点</strong>： 创建一个最初包含指定元素的 <code>EnumSet</code>。有多个重载版本（1到5个参数），以及一个可变参数版本 <code>(E... elements)</code>。</li>
</ul>
</li>
<li><p><strong><code>public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; range(E from, E to)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 调用 <code>noneOf</code> 创建空集，然后通过位运算设置从 <code>from.ordinal()</code> 到 <code>to.ordinal()</code> 之间的所有位。</li>
<li><strong>特点</strong>： 创建一个包含指定范围内所有元素的 <code>EnumSet</code>。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-添加元素-Add-1"><a href="#4-添加元素-Add-1" class="headerlink" title="4. 添加元素(Add)"></a>4. 添加元素(Add)</h5><p><strong><code>public boolean add(E e)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑：</strong></p>
<ol>
<li>类型检查，确保 <code>e</code> 属于正确的枚举类型。</li>
<li>计算该元素对应的位 <code>ordinal = e.ordinal()</code>。</li>
<li>执行位运算，将对应位设为 1。</li>
<li>如果该位之前是 0（即元素是新添加的），返回 <code>true</code>。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong>。纯粹的位操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegularEnumSet 的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    typeCheck(e); <span class="comment">// 检查类型</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">oldElements</span> <span class="operator">=</span> elements;</span><br><span class="line">    <span class="comment">// 1L &lt;&lt; e.ordinal() 计算出要设置的位</span></span><br><span class="line">    <span class="comment">// |= 操作将该位设为1</span></span><br><span class="line">    elements |= (<span class="number">1L</span> &lt;&lt; e.ordinal()); </span><br><span class="line">    <span class="keyword">return</span> elements != oldElements; <span class="comment">// 如果相等，说明元素已存在，添加失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-删除元素-Remove-2"><a href="#5-删除元素-Remove-2" class="headerlink" title="5. 删除元素(Remove)"></a>5. 删除元素(Remove)</h5><p><strong><code>public boolean remove(Object e)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li>如果 <code>e</code> 为 <code>null</code> 或类型不匹配，返回 <code>false</code>。</li>
<li>计算该元素对应的位 <code>ordinal = e.ordinal()</code>。</li>
<li>执行位运算，将对应位设为 0。</li>
<li>如果该位之前是 1（即元素原本存在），返回 <code>true</code>。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong>。纯粹的位操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegularEnumSet 的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Class&lt;?&gt; eClass = e.getClass();</span><br><span class="line">    <span class="keyword">if</span> (eClass != elementType &amp;&amp; eClass.getSuperclass() != elementType)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 类型不匹配</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">oldElements</span> <span class="operator">=</span> elements;</span><br><span class="line">    <span class="comment">// ~(1L &lt;&lt; e.ordinal()) 得到一个只有目标位是0的掩码</span></span><br><span class="line">    <span class="comment">// &amp;= 操作将目标位清零</span></span><br><span class="line">    elements &amp;= ~(<span class="number">1L</span> &lt;&lt; ((Enum&lt;?&gt;)e).ordinal());</span><br><span class="line">    <span class="keyword">return</span> elements != oldElements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="6-包含判断-Contains"><a href="#6-包含判断-Contains" class="headerlink" title="6. 包含判断(Contains)"></a>6. 包含判断(Contains)</h5><p><strong><code>public boolean contains(Object e)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>：</p>
<ol>
<li>如果 <code>e</code> 为 <code>null</code> 或类型不匹配，返回 <code>false</code>。</li>
<li>计算该元素对应的位 <code>ordinal = e.ordinal()</code>。</li>
<li>执行位与运算 <code>(elements &amp; (1L &lt;&lt; ordinal)) != 0</code>，检查对应位是否为 1。</li>
</ol>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong>。纯粹的位操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegularEnumSet 的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Class&lt;?&gt; eClass = e.getClass();</span><br><span class="line">    <span class="keyword">if</span> (eClass != elementType &amp;&amp; eClass.getSuperclass() != elementType)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 检查对应位是否为1</span></span><br><span class="line">    <span class="keyword">return</span> (elements &amp; (<span class="number">1L</span> &lt;&lt; ((Enum&lt;?&gt;)e).ordinal())) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="7-批量操作"><a href="#7-批量操作" class="headerlink" title="7. 批量操作"></a>7. 批量操作</h5><p><code>EnumSet</code> 的批量操作（如 <code>addAll</code>, <code>removeAll</code>, <code>retainAll</code>）都通过位运算实现，效率极高。</p>
<ul>
<li><strong><code>complement()</code></strong>： 求补集。将位向量取反（<code>~</code>），然后清理掉超出枚举常量数量的高位。</li>
<li><strong><code>addAll(Collection c)</code></strong>： 如果参数是另一个 <code>EnumSet</code> 且类型相同，直接进行位或运算（<code>|=</code>）。</li>
<li><strong><code>retainAll(Collection c)</code></strong>： 如果参数是另一个 <code>EnumSet</code> 且类型相同，直接进行位与运算（<code>&amp;=</code>）。</li>
</ul>
<hr>
<h5 id="8-遍历方式-1"><a href="#8-遍历方式-1" class="headerlink" title="8. 遍历方式"></a>8. 遍历方式</h5><ul>
<li><strong>迭代器（Iterator）</strong>： <code>EnumSet</code> 提供了自己的 <code>Iterator</code> 实现，它预先生成了所有有效元素的序列，遍历效率很高。</li>
<li><strong>for-each循环</strong>： 推荐方式，语法简洁，底层也是迭代器。</li>
</ul>
<p><strong>注意</strong>： <code>EnumSet</code> 的迭代器是<strong>弱一致性的（weakly consistent）</strong>，它不会抛出 <code>ConcurrentModificationException</code>。但如果在迭代期间修改集合，迭代结果是不确定的。</p>
<hr>
<h5 id="9-典型应用场面"><a href="#9-典型应用场面" class="headerlink" title="9. 典型应用场面"></a>9. 典型应用场面</h5><p><strong>1. 替代位掩码（Bit Flags &#x2F; Bitmask） - 最经典的场景</strong></p>
<p>在历史上，为了表示一组开关、状态或选项，程序员经常使用位掩码操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统位掩码做法（不推荐）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STYLE_BOLD</span>     <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">0</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STYLE_ITALIC</span>   <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STYLE_UNDERLINE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">myStyles</span> <span class="operator">=</span> STYLE_BOLD | STYLE_ITALIC; <span class="comment">// 使用 OR 操作组合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((myStyles &amp; STYLE_BOLD) != <span class="number">0</span>) &#123; <span class="comment">// 使用 AND 操作检查</span></span><br><span class="line">    <span class="comment">// 粗体生效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法虽然高效，但有很多缺点：类型不安全、打印调试不直观、易出错、可读性差。</p>
<p><strong><code>EnumSet</code> 完美地解决了所有这些问题，同时保留了位操作的性能优势</strong>。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>文本样式</strong>：字体可以是粗体、斜体、下划线等的任意组合。</li>
<li><strong>系统权限</strong>：一个用户可能拥有读、写、执行、删除等权限的任意组合。</li>
<li><strong>游戏状态</strong>：一个游戏实体可能同时处于“移动中”、“受伤”、“无敌”等多种状态。</li>
<li><strong>配置选项</strong>：启用或禁用一系列功能选项。</li>
</ul>
<p><strong>代码示例（用EnumSet替代位掩码）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TextStyle</span> &#123;</span><br><span class="line">    BOLD, ITALIC, UNDERLINE, STRIKETHROUGH</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 使用EnumSet</span></span><br><span class="line">Set&lt;TextStyle&gt; myStyles = EnumSet.of(TextStyle.BOLD, TextStyle.ITALIC);</span><br><span class="line"><span class="comment">// 检查是否包含 - 可读性极高，且性能极快</span></span><br><span class="line"><span class="keyword">if</span> (myStyles.contains(TextStyle.BOLD)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;文本是粗体&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加样式</span></span><br><span class="line">myStyles.add(TextStyle.UNDERLINE);</span><br><span class="line"><span class="comment">// 移除样式</span></span><br><span class="line">myStyles.remove(TextStyle.ITALIC);</span><br><span class="line"><span class="comment">// 遍历所有应用的样式</span></span><br><span class="line"><span class="keyword">for</span> (TextStyle style : myStyles) &#123;</span><br><span class="line">    System.out.println(style);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2. 表示有限的状态机或工作流</strong></p>
<p>在许多系统中，一个对象只能处于有限状态集合中的某一个状态，并且状态之间的转换是预定义的。<code>EnumSet</code> 非常适合用来表示“从一个状态可以转移到哪些状态”的集合。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>订单状态流</strong>：订单可能处于 <code>NEW</code>, <code>PAID</code>, <code>SHIPPED</code>, <code>DELIVERED</code>, <code>CANCELLED</code> 等状态。<code>EnumSet</code> 可以用来定义，例如，<code>PAID</code> 状态的下一个状态只能是 <code>SHIPPED</code> 或 <code>CANCELLED</code>。</li>
<li><strong>线程生命周期</strong>：线程状态 <code>NEW</code>, <code>RUNNABLE</code>, <code>BLOCKED</code>, <code>WAITING</code>, <code>TIMED_WAITING</code>, <code>TERMINATED</code>。</li>
</ul>
<p><strong>代码示例（状态机）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OrderStatus</span> &#123; NEW, CONFIRMED, PAID, SHIPPED, DELIVERED, CANCELLED &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个状态转换规则：当前状态 -&gt; 可能的下一个状态集合</span></span><br><span class="line">Map&lt;OrderStatus, EnumSet&lt;OrderStatus&gt;&gt; stateTransitions = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化状态转换规则</span></span><br><span class="line">    stateTransitions.put(OrderStatus.NEW,</span><br><span class="line">            EnumSet.of(OrderStatus.CONFIRMED, OrderStatus.CANCELLED));</span><br><span class="line">    stateTransitions.put(OrderStatus.CONFIRMED,</span><br><span class="line">            EnumSet.of(OrderStatus.PAID, OrderStatus.CANCELLED));</span><br><span class="line">    stateTransitions.put(OrderStatus.PAID,</span><br><span class="line">            EnumSet.of(OrderStatus.SHIPPED));</span><br><span class="line">    <span class="comment">// ... 其他规则</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法：检查一个状态转换是否合法</span></span><br><span class="line"><span class="type">OrderStatus</span> <span class="variable">currentStatus</span> <span class="operator">=</span> OrderStatus.PAID;</span><br><span class="line"><span class="type">OrderStatus</span> <span class="variable">nextStatus</span> <span class="operator">=</span> OrderStatus.SHIPPED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stateTransitions.get(currentStatus).contains(nextStatus)) &#123;</span><br><span class="line">    currentStatus = nextStatus; <span class="comment">// 合法，执行状态转换</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Invalid state transition!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>3. 处理枚举的所有值或某个范围的值</strong></p>
<p><code>EnumSet</code> 提供了非常方便的静态工厂方法来快速创建包含枚举所有值或某个连续范围值的集合。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>批量操作</strong>：需要处理除了某几个值之外的所有枚举值。</li>
<li><strong>初始化</strong>：在系统初始化时，需要启用一整套默认功能。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">DayOfWeek</span> &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY &#125;</span><br><span class="line"><span class="comment">// 创建一个包含所有值的集合</span></span><br><span class="line">EnumSet&lt;DayOfWeek&gt; allDays = EnumSet.allOf(DayOfWeek.class);</span><br><span class="line"><span class="comment">// 创建一个工作日集合（从周一到周五）</span></span><br><span class="line">EnumSet&lt;DayOfWeek&gt; weekdays = EnumSet.range(DayOfWeek.MONDAY, DayOfWeek.FRIDAY);</span><br><span class="line"><span class="comment">// 创建一个周末集合（用“所有值”减去“工作日”）</span></span><br><span class="line">EnumSet&lt;DayOfWeek&gt; weekend = EnumSet.complementOf(weekdays); <span class="comment">// 包含 SATURDAY, SUNDAY</span></span><br><span class="line"><span class="comment">// 创建一个空的EnumSet，并指定元素类型</span></span><br><span class="line">EnumSet&lt;DayOfWeek&gt; none = EnumSet.noneOf(DayOfWeek.class);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-6-CopyOnWriteArraySet【了解】"><a href="#2-3-6-CopyOnWriteArraySet【了解】" class="headerlink" title="2.3.6 CopyOnWriteArraySet【了解】"></a>2.3.6 CopyOnWriteArraySet【了解】</h4><h5 id="1-核心概念-9"><a href="#1-核心概念-9" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>CopyOnWriteArraySet</code> 是 <code>Set</code> 接口的一个<strong>线程安全</strong>的实现。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>线程安全（Thread-Safe）</strong>： 所有操作都是线程安全的，无需外部同步。</li>
<li><strong>写时复制（Copy-On-Write）</strong>： 所有修改操作（如 <code>add</code>, <code>remove</code>）都会创建底层数组的一个新副本。这是它线程安全的基础。</li>
<li><strong>弱一致性迭代（Weakly Consistent Iteration）</strong>： 迭代器在创建时持有创建那一刻底层数组的快照（Snapshot）。在迭代过程中不会抛出 <code>ConcurrentModificationException</code>，但迭代器反映的是创建时的状态，看不到迭代开始后其他线程的修改。</li>
<li><strong>无序（Unordered）</strong>： 不保证元素的遍历顺序，特别是它不保证像 <code>HashSet</code> 那样基于哈希码的顺序。</li>
<li><strong>允许空元素（Allows Null）</strong>： 支持添加 <code>null</code> 元素。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 其所有操作都是通过委托给一个内部的 <code>CopyOnWriteArrayList</code> 实例来完成的。<code>Set</code> 的特性（元素唯一性）由 <code>CopyOnWriteArrayList</code> 的 <code>addIfAbsent</code> 和 <code>addAllAbsent</code> 方法来保证。</li>
<li><strong>设计思想</strong>：<code>CopyOnWriteArraySet</code> 基于 <code>CopyOnWriteArrayList</code>，采用写时复制策略实现线程安全和无重复元素集合。它的设计是为了解决“读多写少”场景下的并发安全问题，读操作无锁且高效，写操作开销较大但简单安全。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-7"><a href="#2-底层数据结构和关键属性-7" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>CopyOnWriteArraySet</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// 序列化ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">5457747651344034263L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 核心！所有操作都委托给这个 CopyOnWriteArrayList 实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个空集合。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CopyOnWriteArraySet</span><span class="params">()</span> &#123;</span><br><span class="line">        al = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个包含指定集合所有元素的集合。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CopyOnWriteArraySet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == CopyOnWriteArraySet.class) &#123;</span><br><span class="line">            <span class="comment">// 如果传入的集合就是 CopyOnWriteArraySet，直接获取其内部的 ArrayList</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            CopyOnWriteArraySet&lt;E&gt; cc = (CopyOnWriteArraySet&lt;E&gt;)c;</span><br><span class="line">            al = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;(cc.al);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，新建一个空的 ArrayList，然后添加所有元素</span></span><br><span class="line">            al = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;();</span><br><span class="line">            al.addAllAbsent(c); <span class="comment">// 使用 addAllAbsent 保证元素唯一性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 所有方法都委托给 &#x27;al&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>al</code> (CopyOnWriteArrayList)</strong>： 所有集合操作都通过调用这个内部列表的相应方法来完成。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-6"><a href="#3-构造方法与初始化-6" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>CopyOnWriteArraySet</code> 提供了两种构造方式：</p>
<ol>
<li><p><strong><code>public CopyOnWriteArraySet()</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 初始化内部引用 <code>al</code> 为一个新的、空的 <code>CopyOnWriteArrayList</code>。</p>
</li>
<li><p><strong>特点</strong>： 创建一个空的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个空的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArraySet</span><span class="params">()</span> &#123;</span><br><span class="line">    al = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public CopyOnWriteArraySet(Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 如果传入的集合本身就是 <code>CopyOnWriteArraySet</code>，则直接访问其内部的 <code>al</code> 来构造新的列表，效率较高。否则，创建一个新的空 <code>CopyOnWriteArrayList</code>，然后调用 <code>addAllAbsent(c)</code> 来添加元素，此方法能保证元素唯一性。</p>
</li>
<li><p><strong>特点</strong>： 用一个已有集合来构造。<strong>注意：如果传入的集合包含重复元素，重复项会被自动去除。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个包含指定集合中所有元素的 Set。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 要初始化到该集合中的元素集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的集合为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CopyOnWriteArraySet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line"> 	<span class="comment">// 如果传入的集合本身就是一个 CopyOnWriteArraySet</span></span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArraySet.class) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> CopyOnWriteArraySet&lt;E&gt; cc =</span><br><span class="line">            (CopyOnWriteArraySet&lt;E&gt;)c;</span><br><span class="line">     	<span class="comment">// 直接用传入集合内部的 CopyOnWriteArrayList 来初始化</span></span><br><span class="line">        al = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;(cc.al);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">     	<span class="comment">// 否则，创建一个新的 CopyOnWriteArrayList</span></span><br><span class="line">        al = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;();</span><br><span class="line">       	<span class="comment">// 将集合 c 中的所有元素添加进来，跳过已有的重复元素</span></span><br><span class="line">        al.addAllAbsent(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-添加元素-Add-2"><a href="#4-添加元素-Add-2" class="headerlink" title="4. 添加元素(Add)"></a>4. 添加元素(Add)</h5><p><strong><code>public boolean add(E e)</code></strong>：</p>
<ul>
<li><p>底层调用<code>CopyOnWriteArrayList</code>时间复杂度与处理逻辑与<code>CopyOnWriteArrayList</code>的<code>addIfAbsent</code>方法相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> al.addIfAbsent(e); <span class="comment">// 核心调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-删除元素-Remove-3"><a href="#5-删除元素-Remove-3" class="headerlink" title="5. 删除元素(Remove)"></a>5. 删除元素(Remove)</h5><p><strong><code>public boolean remove(Object o)</code></strong>：</p>
<ul>
<li><p>底层调用<code>CopyOnWriteArrayList</code>时间复杂度与处理逻辑与<code>CopyOnWriteArrayList</code>的<code>remove</code>方法相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> al.remove(o); <span class="comment">// 核心调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="6-包含判断-Contains-1"><a href="#6-包含判断-Contains-1" class="headerlink" title="6. 包含判断(Contains)"></a>6. 包含判断(Contains)</h5><p><strong><code>public boolean contains(Object o)</code></strong>：</p>
<ul>
<li><p>底层调用<code>CopyOnWriteArrayList</code>时间复杂度与处理逻辑与<code>CopyOnWriteArrayList</code>的<code>contains</code>方法相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> al.contains(o); <span class="comment">// 核心调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="7-遍历与迭代器"><a href="#7-遍历与迭代器" class="headerlink" title="7. 遍历与迭代器"></a>7. 遍历与迭代器</h5><p><strong><code>public Iterator&lt;E&gt; iterator()</code></strong>：</p>
<ul>
<li><p>底层调用<code>CopyOnWriteArrayList</code>的<code>iterator</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> al.iterator(); <span class="comment">// 返回一个基于快照的迭代器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="8-典型应用场景-1"><a href="#8-典型应用场景-1" class="headerlink" title="8. 典型应用场景"></a>8. 典型应用场景</h5><p><strong>1. 读操作极度频繁，写操作非常稀少的场景（最核心场景）</strong></p>
<p>这是 <code>CopyOnWriteArraySet</code> 设计的初衷和最主要的应用场景。系统的性能瓶颈在于需要高吞吐量的读操作，而写操作只是偶尔发生。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>事件监听器列表 (Listener Lists)</strong>：这是一个教科书级的例子。在 GUI 框架（如 Swing）或事件驱动系统中，需要维护一个事件监听器的集合。<br>* <strong>读操作极度频繁</strong>：当事件发生时，需要遍历所有监听器并通知它们（<code>for (Listener l : listeners) l.onEvent();</code>）。这个过程会非常频繁地发生。<br>* <strong>写操作非常稀少</strong>：监听器的注册 (<code>addListener</code>) 和注销 (<code>removeListener</code>) 通常在程序初始化或用户交互时发生，频率比事件触发低几个数量级。<ul>
<li>使用 <code>CopyOnWriteArraySet</code>，事件通知（读遍历）可以<strong>无锁、高速</strong>地进行，而偶尔的注册&#x2F;注销操作（写）带来的性能开销是可以接受的。</li>
</ul>
</li>
<li><strong>只读为主的缓存</strong>：缓存的数据几乎不变化，但会被成千上万的线程并发读取。偶尔需要重新加载或更新整个缓存集。</li>
<li><strong>存储不变的配置信息</strong>：配置信息在启动后基本不会改变，但需要被许多线程频繁查询。</li>
</ul>
<p><strong>代码示例（事件监听器）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventSource</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 CopyOnWriteArraySet 保存监听器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;EventListener&gt; listeners = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册监听器（写操作，慢但稀少）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(EventListener listener)</span> &#123;</span><br><span class="line">        listeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除监听器（写操作，慢但稀少）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeListener</span><span class="params">(EventListener listener)</span> &#123;</span><br><span class="line">        listeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件（读操作，快且频繁！）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历操作不需要同步，极快！</span></span><br><span class="line">        <span class="comment">// 这里迭代的是触发事件那一刻的集合快照</span></span><br><span class="line">        <span class="keyword">for</span> (EventListener listener : listeners) &#123;</span><br><span class="line">            listener.onEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2. 需要避免在迭代过程中加锁的场景</strong></p>
<p>在某些情况下，你需要对集合进行长时间的遍历（例如，处理集合中的每个元素需要执行一些耗时的操作），并且在此期间不希望阻塞其他线程的读操作。使用传统的同步集合（如 <code>Collections.synchronizedSet()</code>）会在整个迭代期间持有锁，导致其他线程无法访问，严重降低吞吐量。</p>
<p><code>CopyOnWriteArraySet</code> 的“快照”迭代器完美解决了这个问题。</p>
<p><strong>场景示例</strong>：</p>
<ul>
<li><strong>批量数据处理</strong>：一个后台线程需要遍历当前所有连接的会话（Session）来进行健康检查或统计。这个遍历过程可能很慢，但你不希望在这个过程中阻塞新的连接请求（添加新会话）或正常的消息处理（读取会话信息）。</li>
<li><strong>分析诊断</strong>：需要获取系统当前状态的快照（如所有活跃任务、所有打开的文件）进行分析，分析过程不希望被后续的状态变化所影响。</li>
</ul>
<hr>
<p><strong>3. 需要保证不会抛出 <code>ConcurrentModificationException</code></strong></p>
<p>如果你受够了在迭代集合时因为其他线程修改集合而抛出 <code>ConcurrentModificationException</code>，但又不想在遍历时用锁同步整个集合，<code>CopyOnWriteArraySet</code> 是一个简单的解决方案。它的迭代器基于创建时的快照，绝对安全。</p>
<hr>
<h4 id="2-3-7-综合对比"><a href="#2-3-7-综合对比" class="headerlink" title="2.3.7 综合对比"></a>2.3.7 综合对比</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>HashSet</code></th>
<th align="left"><code>LinkedHashSet</code></th>
<th align="left"><code>TreeSet</code></th>
<th align="left"><code>EnumSet</code></th>
<th align="left"><code>CopyOnWriteArraySet</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>底层数据结构</strong></td>
<td align="left"><strong>哈希表 (HashMap)</strong></td>
<td align="left"><strong>哈希表 + 双向链表</strong></td>
<td align="left"><strong>红黑树</strong></td>
<td align="left"><strong>位向量 (Bit Vector)</strong></td>
<td align="left"><strong>动态数组 (CopyOnWriteArrayList)</strong></td>
</tr>
<tr>
<td align="left"><strong>所在包</strong></td>
<td align="left"><code>java.util</code></td>
<td align="left"><code>java.util</code></td>
<td align="left"><code>java.util</code></td>
<td align="left"><code>java.util</code></td>
<td align="left"><strong><code>java.util.concurrent</code></strong></td>
</tr>
<tr>
<td align="left"><strong>元素顺序</strong></td>
<td align="left"><strong>无顺序</strong> (不保证迭代顺序)</td>
<td align="left"><strong>插入顺序</strong> (按添加顺序迭代)</td>
<td align="left"><strong>自然顺序 或 定制排序</strong> (排序顺序)</td>
<td align="left"><strong>枚举常量声明顺序</strong> (在枚举类中定义的顺序)</td>
<td align="left"><strong>插入顺序</strong> (但迭代器创建时的快照顺序)</td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>是</strong></td>
</tr>
<tr>
<td align="left"><strong>允许 <code>null</code> 元素</strong></td>
<td align="left"><strong>是</strong> (最多一个)</td>
<td align="left"><strong>是</strong> (最多一个)</td>
<td align="left"><strong>否</strong> (如果使用自然排序) <strong>可能</strong> (如果使用Comparator)</td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>是</strong></td>
</tr>
<tr>
<td align="left"><strong>性能 (增删查)</strong></td>
<td align="left"><strong>O(1)</strong> (平均情况)</td>
<td align="left"><strong>O(1)</strong> (平均情况，略慢于HashSet)</td>
<td align="left"><strong>O(log n)</strong></td>
<td align="left"><strong>极快 O(1)</strong></td>
<td align="left"><strong>读: O(1)</strong> <strong>写: O(n)</strong> (极慢)</td>
</tr>
<tr>
<td align="left"><strong>迭代器性能</strong></td>
<td align="left">受容量影响 (较好)</td>
<td align="left"><strong>极快</strong> (直接遍历链表)</td>
<td align="left"><strong>O(n)</strong> (中序遍历)</td>
<td align="left"><strong>极快</strong></td>
<td align="left"><strong>极快</strong> (遍历快照，无并发冲突)</td>
</tr>
<tr>
<td align="left"><strong>内存占用</strong></td>
<td align="left">较低</td>
<td align="left">较高 (需要维护链表结构)</td>
<td align="left">较低</td>
<td align="left"><strong>极低</strong> (位操作)</td>
<td align="left"><strong>较高</strong> (写时复制机制导致)</td>
</tr>
<tr>
<td align="left"><strong>迭代器类型</strong></td>
<td align="left"><strong>快速失败 (Fail-Fast)</strong></td>
<td align="left"><strong>快速失败 (Fail-Fast)</strong></td>
<td align="left"><strong>快速失败 (Fail-Fast)</strong></td>
<td align="left"><strong>快速失败 (Fail-Fast)</strong></td>
<td align="left"><strong>弱一致性 (Weakly Consistent)</strong> (不会抛<code>CME</code>)</td>
</tr>
<tr>
<td align="left"><strong>比较方式</strong></td>
<td align="left"><code>equals()</code> 和 <code>hashCode()</code></td>
<td align="left"><code>equals()</code> 和 <code>hashCode()</code></td>
<td align="left"><code>compareTo()</code> 或 <code>Comparator</code></td>
<td align="left"><code>equals()</code></td>
<td align="left"><code>equals()</code></td>
</tr>
<tr>
<td align="left"><strong>核心用途</strong></td>
<td align="left">需要快速查找、去重，且不关心顺序的场景</td>
<td align="left">需要保证插入顺序的快速查找和去重</td>
<td align="left">需要元素始终保持排序状态的场景</td>
<td align="left">专门用于存储<strong>同一枚举类型</strong>的元素，性能极致优化</td>
<td align="left"><strong>读多写极少</strong>的高并发场景，需要线程安全且避免迭代时抛异常</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-4-Queue-Deque-接口及其实现类"><a href="#2-4-Queue-Deque-接口及其实现类" class="headerlink" title="2.4 Queue &#x2F; Deque 接口及其实现类"></a>2.4 <strong>Queue &#x2F; Deque 接口及其实现类</strong></h3><h4 id="2-4-1-Queue"><a href="#2-4-1-Queue" class="headerlink" title="2.4.1 Queue"></a>2.4.1 Queue</h4><p><code>Queue</code> 接口设计用于在处理元素<strong>之前</strong>保存元素。它通常（但并非一定）遵循<strong>先进先出（FIFO）</strong> 的原则。</p>
<h5 id="1-核心特征："><a href="#1-核心特征：" class="headerlink" title="1.核心特征："></a>1.<strong>核心特征：</strong></h5><ol>
<li><strong>有序（Ordered）</strong>： 元素以一种特定的顺序存储，这个顺序由队列的类型决定（如 FIFO、LIFO 或优先级）。</li>
<li><strong>可重复（Allow Duplicates）</strong>： 通常允许存储相同的元素（包括 <code>null</code> 元素，但具体实现可能有限制，例如 <code>PriorityQueue</code> 不允许 <code>null</code>）。</li>
<li><strong>无索引（Non-Indexed）</strong>： <strong>不能</strong>通过索引访问队列中间的元素。所有操作都仅限于队列的<strong>头部</strong>或<strong>尾部</strong>。</li>
<li><strong>核心操作（Core Operations）</strong>： 提供了插入、移除和检查元素的方法，每种操作都有两种形式：一种在操作<strong>失败时抛出异常</strong>，另一种则返回一个<strong>特殊值</strong>（如 <code>null</code> 或 <code>false</code>）。</li>
</ol>
<hr>
<h5 id="2-特有的核心方法"><a href="#2-特有的核心方法" class="headerlink" title="2.特有的核心方法"></a>2.<strong>特有的核心方法</strong></h5><p><code>Queue</code> 接口的方法主要围绕其<strong>头部（出队端）</strong> 和<strong>尾部（入队端）</strong> 进行。</p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>抛出异常的方法</th>
<th>返回特殊值的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>插入（Insert）</strong></td>
<td><code>boolean add(E e)</code></td>
<td><code>boolean offer(E e)</code></td>
<td>将元素插入队列尾部。如果成功，<code>add()</code> 返回 <code>true</code>，失败则抛出 <code>IllegalStateException</code>（容量受限时）。<code>offer()</code> 在成功时返回 <code>true</code>，失败时返回 <code>false</code>。</td>
</tr>
<tr>
<td><strong>移除（Remove）</strong></td>
<td><code>E remove()</code></td>
<td><code>E poll()</code></td>
<td>移除并返回队列头部的元素。如果队列为空，<code>remove()</code> 抛出 <code>NoSuchElementException</code>，而 <code>poll()</code> 返回 <code>null</code>。</td>
</tr>
<tr>
<td><strong>检查（Examine）</strong></td>
<td><code>E element()</code></td>
<td><code>E peek()</code></td>
<td>返回队列头部的元素（但不移除）。如果队列为空，<code>element()</code> 抛出 <code>NoSuchElementException</code>，而 <code>peek()</code> 返回 <code>null</code>。</td>
</tr>
</tbody></table>
<p><strong>典型使用场景</strong>：任务调度、消息传递、BFS 算法等。</p>
<hr>
<h4 id="2-4-2-LinkedBlockingQueue【了解】"><a href="#2-4-2-LinkedBlockingQueue【了解】" class="headerlink" title="2.4.2 LinkedBlockingQueue【了解】"></a>2.4.2 LinkedBlockingQueue【了解】</h4><h5 id="1-核心概念-10"><a href="#1-核心概念-10" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>LinkedBlockingQueue</code> 是一个基于<strong>单向链表</strong>实现的、可选容量的、<strong>线程安全</strong>的阻塞队列。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>FIFO（先进先出）</strong>： 队列的头部是在队列中时间最长的元素，队列的尾部是在队列中时间最短的元素。</li>
<li><strong>线程安全（Thread-Safe）</strong>： 内部采用<strong>两把锁（ReentrantLock）</strong> 和<strong>条件变量（Condition）</strong> 的机制来保证并发安全，并实现阻塞操作。</li>
<li><strong>阻塞操作（Blocking Operations）</strong>： 当队列为空时，尝试从队列<strong>取出（take）</strong> 元素的线程会被阻塞，直到队列中有可用元素；当队列已满时，尝试向队列<strong>放入（put）</strong> 元素的线程会被阻塞，直到队列出现空位。</li>
<li><strong>可选容量（Optionally Bounded）</strong>： 可以在构造时指定队列的最大容量。如果未指定，则默认容量为 <code>Integer.MAX_VALUE</code>，可近似认为是一个“无界”队列（但仍受限于物理资源）。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层使用一个<strong>单向链表</strong> (<code>Node</code>) 来存储元素。通过 <code>head</code> 和 <code>last</code>（或 <code>tail</code>）节点来维护队列的头部和尾部。通过<strong>分离<code>putLock</code>（入队锁）和<code>takeLock</code>（出队锁）</strong> 以及对应的条件变量 <code>notFull</code> 和 <code>notEmpty</code>，实现了高并发的入队和出队操作。</li>
<li><strong>设计思想</strong>：基于链表实现的有界阻塞队列，采用读写分离锁+Condition实现线程安全，支持高并发、阻塞等待和容量控制，特别适合生产者-消费者场景。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-8"><a href="#2-底层数据结构和关键属性-8" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>LinkedBlockingQueue</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6903933977591709194L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表节点类。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 可能的取值：</span></span><br><span class="line"><span class="comment">         * - 真正的后继节点（successor Node）</span></span><br><span class="line"><span class="comment">         * - 当前节点自身（this Node），表示后继节点是 head.next</span></span><br><span class="line"><span class="comment">         * - null，表示没有后继节点（即这是最后一个节点）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 容量上限，如果没有限制则为 Integer.MAX_VALUE */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 当前元素数量 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表头结点。</span></span><br><span class="line"><span class="comment">     * 不变量：head.item == null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表尾结点。</span></span><br><span class="line"><span class="comment">     * 不变量：last.next == null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 被 take、poll 等操作持有的锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** take 操作等待的条件队列 */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;serial&quot;)</span> <span class="comment">// 实现 Condition 的类可能是可序列化的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 被 put、offer 等操作持有的锁 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** put 操作等待的条件队列 */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;serial&quot;)</span> <span class="comment">// 实现 Condition 的类可能是可序列化的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> putLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他方法和构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>Node&lt;E&gt;</code></strong>： 链表的节点，是 <code>LinkedBlockingQueue</code> 的<strong>心脏</strong>。<code>item</code> 存储元素，<code>next</code> 指向下一个节点。</li>
<li><strong><code>head</code> &amp; <code>last</code></strong>： 分别指向链表的头部（哑元节点）和尾部，是操作队列的<strong>指针</strong>。</li>
<li><strong><code>count</code></strong>： 使用 <code>AtomicInteger</code> 记录当前队列中的元素数量。它是<strong>连接两把锁的桥梁</strong>，所有需要同时判断数量和状态的操作（如 <code>signalNotFull</code>）都需要先获取这个值。</li>
<li><strong><code>takeLock</code> &amp; <code>notEmpty</code></strong>： <strong>出队锁</strong>。当线程要取元素时，需要先获取这把锁。如果队列为空，线程会在 <code>notEmpty</code> 条件上等待。</li>
<li><strong><code>putLock</code> &amp; <code>notFull</code></strong>： <strong>入队锁</strong>。当线程要放元素时，需要先获取这把锁。如果队列已满，线程会在 <code>notFull</code> 条件上等待。</li>
<li><strong><code>capacity</code></strong>： 队列的<strong>容量限制</strong>。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-7"><a href="#3-构造方法与初始化-7" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>LinkedBlockingQueue</code> 提供了三种构造方式：</p>
<ol>
<li><p><strong><code>public LinkedBlockingQueue()</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 调用 <code>this(Integer.MAX_VALUE)</code>，即创建一个默认容量为 <code>Integer.MAX_VALUE</code> 的“无界”队列。</p>
</li>
<li><p><strong>特点</strong>： <strong>默认容量极大</strong>，在使用时要注意可能的内存耗尽（OOM）风险。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public LinkedBlockingQueue(int capacity)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 校验容量值，初始化 <code>head</code> 和 <code>last</code> 指向同一个<strong>哑元（Dummy）节点</strong>，并设置 <code>capacity</code>。</p>
</li>
<li><p><strong>特点</strong>： <strong>显式指定队列容量</strong>。这是<strong>推荐的使用方式</strong>，可以防止系统资源被耗尽。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个具有给定（固定）容量的 LinkedBlockingQueue。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 队列的容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果 capacity 不大于 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public LinkedBlockingQueue(Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 使用 <code>Integer.MAX_VALUE</code> 容量初始化队列，然后获取 <code>putLock</code>（<strong>注意：这里会锁住所有的入队操作</strong>），遍历集合并将元素逐个加入队列。</p>
</li>
<li><p><strong>特点</strong>： <strong>用一个已有集合来构造</strong>。如果集合元素数量超过 <code>capacity</code>（这里默认是MAX），则会抛出 <code>IllegalStateException</code> (“Queue full”)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue，</span></span><br><span class="line"><span class="comment"> * 最初包含给定集合的元素，按集合迭代器的遍历顺序添加。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 其元素要放入此队列的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定集合或其任何元素为 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException 如果由于容量限制，此时无法添加所有元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    putLock.lock(); <span class="comment">// 从未在序列化中竞争的条件获取可见性</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">if</span> (n == capacity)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">            enqueue(<span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e)); <span class="comment">// 内部入队方法</span></span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        count.set(n); <span class="comment">// 原子设置计数器</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-入队操作-Put-Offer"><a href="#4-入队操作-Put-Offer" class="headerlink" title="4. 入队操作(Put&#x2F;Offer)"></a>4. 入队操作(Put&#x2F;Offer)</h5><ul>
<li><p><strong><code>public void put(E e) throws InterruptedException</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑：</strong></p>
<ol>
<li>如果元素为 <code>null</code>，抛出 <code>NullPointerException</code>。</li>
<li>获取 <code>putLock</code>（可中断地）。<ol>
<li>检查当前元素数量 <code>count</code>：<ul>
<li>如果 <code>count == capacity</code>（队列已满），则当前线程在 <code>notFull</code> 条件上等待。</li>
</ul>
</li>
</ol>
</li>
<li>调用 <code>enqueue(Node&lt;E&gt; node)</code> 方法将新节点插入链表尾部。</li>
<li>原子性地增加 <code>count</code> (<code>c = count.getAndIncrement()</code>)。</li>
<li>如果增加后 <code>c + 1 &lt; capacity</code>（队列还没满），则唤醒一个可能在 <code>notFull</code> 上等待的<strong>生产者</strong>线程。</li>
<li>释放 <code>putLock</code>。</li>
<li>如果插入前队列是空的 (<code>c == 0</code>)，则还需要<strong>尝试唤醒可能在 <code>notEmpty</code> 上等待的消费者线程</strong>（这一步需要获取 <code>takeLock</code>）。</li>
</ol>
</li>
<li><p><strong>特点</strong>： <strong>阻塞</strong>。如果队列满，会一直等待直到有空位或被中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在队列尾部插入指定元素，如果必要则等待空间可用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException 如果在等待时被中断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定元素为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当队列满时，等待 notFull 条件</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">// 获取旧计数并自增</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// 如果放入后还没满，唤醒其他生产者</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果放入前队列是空的 (c==0)，唤醒一个消费者</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有入队方法：将节点链接到 last 后面，并更新 last</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> &#123;</span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发出非空信号（需要获取 takeLock）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">signalNotEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public boolean offer(E e, long timeout, TimeUnit unit)</code></strong>：</p>
<ul>
<li>逻辑与 <code>put</code> 类似，但使用 <code>notFull.awaitNanos(nanos)</code> 进行<strong>超时等待</strong>。</li>
<li>如果在超时时间内等到空位，则插入元素并返回 <code>true</code>。</li>
<li>如果超时时间到仍未等到空位，则返回 <code>false</code>。</li>
</ul>
</li>
<li><p><strong><code>public boolean offer(E e)</code></strong>：</p>
<ul>
<li><strong>非阻塞</strong>版本。</li>
<li>如果队列未满，则立即插入并返回 <code>true</code>。</li>
<li>如果队列已满，则<strong>立即返回 <code>false</code></strong>，不会等待。</li>
</ul>
</li>
</ul>
<h5 id="5-出队操作-Take-Poll"><a href="#5-出队操作-Take-Poll" class="headerlink" title="5. 出队操作(Take&#x2F;Poll)"></a>5. 出队操作(Take&#x2F;Poll)</h5><ul>
<li><p><strong><code>public E take() throws InterruptedException</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong></p>
<ol>
<li><p>获取 <code>takeLock</code>（可中断地）。</p>
<ol start="2">
<li>检查当前元素数量 <code>count</code>：<ul>
<li>如果 <code>count == 0</code>（队列为空），则当前线程在 <code>notEmpty</code> 条件上等待。</li>
</ul>
</li>
</ol>
</li>
<li><p>调用 <code>dequeue()</code> 方法从链表头部（<code>head.next</code>）取出元素。</p>
</li>
<li><p>原子性地减少 <code>count</code> (<code>c = count.getAndDecrement()</code>)。</p>
</li>
<li><p>如果减少后 <code>c &gt; 1</code>（队列还不为空），则唤醒一个可能在 <code>notEmpty</code> 上等待的<strong>消费者</strong>线程。</p>
</li>
<li><p>释放 <code>takeLock</code>。</p>
</li>
<li><p>如果取出前队列是满的 (<code>c == capacity</code>)，则还需要<strong>尝试唤醒可能在 <code>notFull</code> 上等待的生产者线程</strong>（这一步需要获取 <code>putLock</code>）。</p>
</li>
</ol>
</li>
<li><p><strong>特点</strong>： <strong>阻塞</strong>。如果队列空，会一直等待直到有元素或被中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> E x;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当队列空时，等待 notEmpty 条件</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出队</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        <span class="comment">// 获取旧计数并自减</span></span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="comment">// 如果取出后还不为空，唤醒其他消费者</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果取出前队列是满的 (c == capacity)，唤醒一个生产者</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有出队方法：移除头节点的下一个节点，并返回其 item</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    Node&lt;E&gt; h = head;      <span class="comment">// 当前头节点</span></span><br><span class="line">    Node&lt;E&gt; first = h.next; <span class="comment">// 第一个实际数据节点</span></span><br><span class="line">    h.next = h; <span class="comment">// 帮助 GC（断开原头节点的引用）</span></span><br><span class="line">    head = first;          <span class="comment">// 将第一个数据节点设为新的头节点</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> first.item;      <span class="comment">// 获取要返回的数据</span></span><br><span class="line">    first.item = <span class="literal">null</span>;     <span class="comment">// 将新头节点的 item 置为 null，恢复哑元状态</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发出非满信号（需要获取 putLock）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">signalNotFull</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public E poll(long timeout, TimeUnit unit)</code></strong>：</p>
<ul>
<li>逻辑与 <code>take</code> 类似，但使用 <code>notEmpty.awaitNanos(nanos)</code> 进行<strong>超时等待</strong>。</li>
<li>如果在超时时间内等到元素，则取出并返回。</li>
<li>如果超时时间到仍未等到元素，则返回 <code>null</code>。</li>
</ul>
</li>
<li><p><strong><code>public E poll()</code></strong>：</p>
<ul>
<li><strong>非阻塞</strong>版本。</li>
<li>如果队列不为空，则立即取出并返回元素。</li>
<li>如果队列为空，则<strong>立即返回 <code>null</code></strong>，不会等待。</li>
</ul>
</li>
</ul>
<h5 id="6-查看元素-Peek"><a href="#6-查看元素-Peek" class="headerlink" title="6. 查看元素(Peek)"></a>6. 查看元素(Peek)</h5><ul>
<li><strong><code>public E peek()</code></strong>：<ul>
<li>获取 <code>takeLock</code>。</li>
<li>查看头节点的下一个节点（即第一个有效数据节点）的 <code>item</code> (<code>(head.next == null) ? null : head.next.item</code>)。</li>
<li>释放 <code>takeLock</code>。</li>
<li><strong>特点</strong>： <strong>只查看不移除</strong>，如果队列为空则返回 <code>null</code>。</li>
</ul>
</li>
</ul>
<h5 id="7-典型应用场景-1"><a href="#7-典型应用场景-1" class="headerlink" title="7.  典型应用场景"></a>7.  典型应用场景</h5><p><strong>1. 线程池的任务队列 (最经典的应用)</strong></p>
<p>这是 <code>LinkedBlockingQueue</code> 最重要、最广泛的应用场景，没有之一。</p>
<ul>
<li><strong>如何工作</strong>： Java <code>ThreadPoolExecutor</code> 的核心组件之一就是工作队列。当提交到线程池的任务数超过核心线程数时，新来的任务不会被立即执行，而是被放入这个工作队列中等待空闲的线程来处理。</li>
<li><strong>为什么是它</strong>：<ul>
<li><strong>线程安全</strong>： 线程池本身是多线程环境，任务提交（生产者）和工作线程获取任务（消费者）是并发进行的，必须保证队列操作的线程安全。</li>
<li><strong>阻塞特性</strong>： 当队列为空时，工作线程会通过 <code>take()</code> 方法被阻塞并等待，直到有新任务进来。这避免了工作线程无谓的循环空转，节省了CPU资源。</li>
<li><strong>管理负载</strong>： 作为有界队列使用时（<strong>推荐</strong>），它可以防止内存溢出。当队列满时，<code>ThreadPoolExecutor</code> 可以根据指定的拒绝策略来处理新提交的任务（如抛出异常、丢弃等），从而为系统提供背压（Backpressure）保护。</li>
</ul>
</li>
</ul>
<p><strong>简单来说，你所使用的 <code>ExecutorService</code>，其底层很可能就依赖 <code>LinkedBlockingQueue</code> 来管理待执行的任务。</strong></p>
<hr>
<p><strong>2. 通用的生产者-消费者问题</strong></p>
<p>任何需要解耦生产数据和消费数据过程的场景，都是 <code>LinkedBlockingQueue</code> 的用武之地。</p>
<ul>
<li><strong>日志记录</strong>： 多个应用线程（生产者）产生日志消息，并快速放入一个 <code>LinkedBlockingQueue</code>，然后由一个专门的日志线程（消费者）从队列中取出消息并写入磁盘文件。这样做避免了多个线程竞争磁盘IO，提升了性能。</li>
<li><strong>订单处理</strong>： 在电商系统中，用户下单（生产者）和后端的库存扣减、发货等复杂操作（消费者）可以解耦。订单先被放入队列，然后由后端的消费者线程池慢慢处理，峰值流量可以被队列缓冲，避免系统被冲垮。</li>
<li><strong>数据采集与处理</strong>： 从网络或传感器采集数据（生产者）的速度可能很快，但后续的数据分析处理（消费者）可能较慢。使用 <code>LinkedBlockingQueue</code> 作为中间缓冲区，可以平衡两者的速度差异。</li>
</ul>
<hr>
<p><strong>3. 实现异步处理和提高响应性</strong></p>
<p>通过将耗时的操作放入队列，交由后台线程处理，可以立即释放请求处理线程，从而快速响应用户。</p>
<ul>
<li><strong>Web服务器中的请求处理</strong>： 收到用户请求后，主线程可以迅速将需要处理的“任务对象”放入 <code>LinkedBlockingQueue</code>，然后立即返回一个“已接收”的响应。后台的工作线程会异步地从队列中取出任务并执行真正的耗时操作（如生成报表、发送邮件等）。</li>
</ul>
<hr>
<h4 id="2-4-3-ConcurrentLinkedQueue【了解】"><a href="#2-4-3-ConcurrentLinkedQueue【了解】" class="headerlink" title="2.4.3 ConcurrentLinkedQueue【了解】"></a>2.4.3 ConcurrentLinkedQueue【了解】</h4><h5 id="1-核心概念-11"><a href="#1-核心概念-11" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>ConcurrentLinkedQueue</code> 是一个基于<strong>单向链表</strong>实现的、<strong>无界的</strong>、<strong>线程安全</strong>的非阻塞队列。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>FIFO（先进先出）</strong>： 队列的头部是在队列中时间最长的元素，队列的尾部是在队列中时间最短的元素。</li>
<li><strong>线程安全（Thread-Safe）</strong>： 内部采用<strong>无锁（Lock-Free）</strong> 算法，使用 <strong>CAS（Compare-And-Swap）</strong> 操作来保证并发安全。这意味着它不会使用传统的锁（如 <code>synchronized</code> 或 <code>ReentrantLock</code>），从而避免了线程挂起和上下文切换的开销。</li>
<li><strong>非阻塞（Non-Blocking）</strong>： 所有操作（如 <code>offer</code>, <code>poll</code>）都采用<strong>忙等（Busy-Wait）</strong> 策略，通过循环不断尝试CAS操作直到成功，线程不会被挂起。这使得它在高并发、多线程竞争激烈的环境下通常能提供更好的吞吐量。</li>
<li><strong>无界（Unbounded）</strong>： 队列没有容量限制（仅受限于物理内存），因此 <code>put</code>&#x2F;<code>offer</code> 操作<strong>永远不会等待</strong>。</li>
<li><strong>弱一致性（Weakly Consistent）</strong>： 它的迭代器和 <code>size()</code> 等方法返回的是<strong>某一时刻的估计值</strong>，而不是精确的当前状态。这些方法主要用于监控，而不用于程序控制逻辑。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层使用一个<strong>单向链表</strong> (<code>Node</code>) 来存储元素。通过 <code>head</code> 和 <code>tail</code> 节点来维护队列的头部和尾部。所有修改操作（入队、出队）都通过 <strong>CAS</strong> 来原子性地更新链表指针（如 <code>next</code>, <code>tail</code>），如果CAS失败（被其他线程抢先修改），则循环重试。</li>
<li><strong>设计思想：基于单向链表+CAS 原子操作实现的无锁化、非阻塞、高并发 FIFO 队列，通过弱一致性迭代器和滞后指针策略，最大限度减少锁竞争，适合高并发、低延迟的消息传递场景。</strong></li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-9"><a href="#2-底层数据结构和关键属性-9" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>ConcurrentLinkedQueue</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@java</span>.io.Serial</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">196745693267521676L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点的静态内部类。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="comment">// 使用 volatile 修饰，保证多线程下的可见性</span></span><br><span class="line">        <span class="keyword">volatile</span> E item;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(E item) &#123;</span><br><span class="line">            <span class="comment">// 使用 lazySet 进行延迟写，是一种性能优化</span></span><br><span class="line">            UNSAFE.putObject(<span class="built_in">this</span>, itemOffset, item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 CAS 操作来修改节点的 item 和 next 字段</span></span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">casItem</span><span class="params">(E cmp, E val)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, itemOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> &#123;</span><br><span class="line">            UNSAFE.putOrderedObject(<span class="built_in">this</span>, nextOffset, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, nextOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略 Unsafe 机制的初始化代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的头节点（并非总是第一个元素节点，会被延迟更新）。</span></span><br><span class="line"><span class="comment">     * 约定：head.item 可能为 null（节点已出队），head != null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表的尾节点（并非总是最后一个元素节点，会被延迟更新）。</span></span><br><span class="line"><span class="comment">     * 约定：tail.next 可能不为 null（并非真正的尾部），tail != null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他方法和构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>Node&lt;E&gt;</code></strong>： 链表的节点，是 <code>ConcurrentLinkedQueue</code> 的<strong>心脏</strong>。<ul>
<li><code>item</code> 和 <code>next</code> 都用 <code>volatile</code> 修饰，保证了多线程环境下的<strong>可见性</strong>。</li>
<li>提供了 <code>casItem</code> 和 <code>casNext</code> 方法，使用 <strong>CAS</strong> 来原子性地修改节点的内容，这是实现无锁算法的<strong>基石</strong>。</li>
</ul>
</li>
<li><strong><code>head</code></strong>： 指向链表的头部。为了性能优化，它并不总是精确地指向第一个元素节点（它可能指向一个已经被 <code>poll</code> 掉的“哑元”节点），这种策略称为**“延迟更新”**。</li>
<li><strong><code>tail</code></strong>： 指向链表的尾部。同样为了性能优化，它并不总是精确地指向最后一个元素节点（它可能滞后），这也是一种**“延迟更新”**策略。这可以减少CAS操作的次数，提升整体吞吐量。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-8"><a href="#3-构造方法与初始化-8" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>ConcurrentLinkedQueue</code> 提供了两种构造方式：</p>
<ol>
<li><p><strong><code>public ConcurrentLinkedQueue()</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 初始化 <code>head</code> 和 <code>tail</code>，让它们都指向一个 <code>item</code> 为 <code>null</code> 的<strong>哑元节点</strong>。</p>
</li>
<li><p><strong>特点</strong>： 创建一个空队列。初始状态 <code>head = tail = new Node&lt;E&gt;(null)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个最初为空的 ConcurrentLinkedQueue。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentLinkedQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    head = tail = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public ConcurrentLinkedQueue(Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 初始化队列后，遍历集合，调用 <code>add</code> (内部是 <code>offer</code>) 方法将元素逐个加入队列。</p>
</li>
<li><p><strong>特点</strong>： <strong>用一个已有集合来构造</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个最初包含给定集合元素的 ConcurrentLinkedQueue，</span></span><br><span class="line"><span class="comment"> * 按集合迭代器的遍历顺序添加。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 其元素要放入此队列的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定集合或其任何元素为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentLinkedQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Node&lt;E&gt; h = <span class="literal">null</span>, t = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="literal">null</span>)</span><br><span class="line">            h = t = newNode;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            t.lazySetNext(newNode);</span><br><span class="line">            t = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>)</span><br><span class="line">        h = t = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">    head = h;</span><br><span class="line">    tail = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-入队操作-Offer"><a href="#4-入队操作-Offer" class="headerlink" title="4. 入队操作(Offer)"></a>4. 入队操作(Offer)</h5><p><strong><code>public boolean offer(E e)</code></strong>：</p>
<ol>
<li><strong>检查非空</strong>： <code>checkNotNull(e)</code>，不允许插入 <code>null</code> 元素。</li>
<li><strong>创建新节点</strong>： <code>final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e)</code>。</li>
<li><strong>循环CAS尝试</strong>： 进入一个无限循环 <code>for (;;)</code>。<ul>
<li>获取当前的尾节点 <code>t</code> 和它的下一个节点 <code>p.next</code>。</li>
<li>如果 <code>p == null</code> (<code>p</code> 是真正的尾节点)，尝试用 <code>casNext(t, newNode)</code> 将新节点链入。<ul>
<li>如果成功，再尝试用 <code>casTail(t, newNode)</code> <strong>延迟更新</strong> <code>tail</code> 指针（即使这一步失败也没关系，其他线程后续会帮它完成更新）。</li>
<li>然后返回 <code>true</code>。</li>
</ul>
</li>
<li>如果 <code>p != null</code> 且 <code>p == q</code> (<code>p</code> 指向了自己，说明该节点已被移除)，说明 <code>tail</code> 已滞后，需要重新定位到新的 <code>head</code> 开始查找真正的尾节点。</li>
<li>否则，说明 <code>tail</code> 不是真正的尾节点，尝试将 <code>p</code> 作为新的候选尾节点，继续循环查找。</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>特点</strong>： <strong>无锁、非阻塞</strong>。通过循环CAS不断尝试，直到成功。由于无界，该方法<strong>永远不会返回 <code>false</code></strong>（除非传入 <code>null</code> 抛出异常）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 tail 节点开始循环尝试</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// p 是最后一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="literal">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="comment">// CAS 成功，新节点已链接</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// 允许 tail 更新失败（跳一次）</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// 失败也没事</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// CAS 失败，被其他线程抢先，重试</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">// 遇到自链接节点，说明节点已被移除（p.next == p）</span></span><br><span class="line">            <span class="comment">// 需要从 head 重新开始查找（如果 tail 被修改，则从新的 tail 开始）</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 继续向后检查下一个节点</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-出队操作-Poll"><a href="#5-出队操作-Poll" class="headerlink" title="5. 出队操作(Poll)"></a>5. 出队操作(Poll)</h5><p><strong><code>public E poll()</code></strong>：</p>
<ol>
<li><strong>循环CAS尝试</strong>： 进入一个无限循环 <code>for (;;)</code>。<ul>
<li>获取当前的头节点 <code>h</code>，第一个元素节点 <code>p = h.next</code>，以及它的 item。</li>
<li>如果 <code>p == null</code>，队列为空，返回 <code>null</code>。</li>
<li>如果 <code>p != null</code>，尝试用 <code>casItem(p.item, null)</code> 将节点的 item 置为 <code>null</code>（标记为已移除）。<ul>
<li>如果成功，再尝试用 <code>casHead(h, p)</code> <strong>延迟更新</strong> <code>head</code> 指针（将 <code>head</code> 指向刚刚出队的节点，使其成为新的哑元头节点）。然后返回删除的元素。</li>
</ul>
</li>
<li>如果上述CAS失败，或者发现节点已被其他线程移除 (<code>p == q</code>)，则重新循环尝试。</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>特点</strong>： <strong>无锁、非阻塞</strong>。通过循环CAS不断尝试，直到成功或发现队列为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            <span class="type">E</span> <span class="variable">item</span> <span class="operator">=</span> p.item;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前节点的 item 不为空，尝试 CAS 置 null</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="literal">null</span> &amp;&amp; p.casItem(item, <span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// CAS 成功</span></span><br><span class="line">                <span class="keyword">if</span> (p != h) <span class="comment">// 跳多次才更新一次 head</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="literal">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查 p 的下一个节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 队列为空</span></span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="comment">// 节点已自移除，需要从 head 重新开始</span></span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 移动到下一个节点继续尝试</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 head 节点</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">updateHead</span><span class="params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">        h.lazySetNext(h); <span class="comment">// 将旧 head 节点指向自己，帮助 GC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="6-查看元素-Peek-1"><a href="#6-查看元素-Peek-1" class="headerlink" title="6. 查看元素(Peek)"></a>6. 查看元素(Peek)</h5><p><strong><code>public E peek()</code></strong>：</p>
<ul>
<li>与 <code>poll</code> 逻辑类似，但它只<strong>查看而不移除</strong>元素。</li>
<li>它获取第一个有效数据节点（<code>head.next</code>）的 <code>item</code>。</li>
<li>如果遇到已被移除的节点（<code>item == null</code>），它会继续寻找下一个有效节点。</li>
<li><strong>特点</strong>： 由于弱一致性，它可能返回 <code>null</code>，即使此时可能有其他线程正在入队元素。</li>
</ul>
<hr>
<h5 id="7-大小-Size-与弱一致性"><a href="#7-大小-Size-与弱一致性" class="headerlink" title="7. 大小(Size)与弱一致性"></a>7. 大小(Size)与弱一致性</h5><p><strong><code>public int size()</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>： 遍历整个链表，统计 <code>item != null</code> 的节点数量。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ol>
<li><strong>时间复杂度高</strong>： <code>O(n)</code>，需要遍历整个链表，效率很低。</li>
<li><strong>弱一致性</strong>： 在遍历过程中，队列可能被其他线程并发修改。因此，返回的 <code>size</code> <strong>只是一个估计值</strong>，不能用于精确的控制（如 <code>if (queue.size() &gt; 0) { ... }</code> 是<strong>错误</strong>的用法）。</li>
<li><strong>设计目的</strong>： 该方法通常仅用于监控和调试，<strong>不应用于核心的业务逻辑判断</strong>。判断队列是否为空应使用 <code>isEmpty()</code>，但它也是弱一致性的。</li>
</ol>
</li>
</ul>
<hr>
<h5 id="8-线程安全与性能"><a href="#8-线程安全与性能" class="headerlink" title="8. 线程安全与性能"></a>8. 线程安全与性能</h5><ul>
<li><strong>无锁（Lock-Free）算法</strong>： 这是 <code>ConcurrentLinkedQueue</code> 高性能的核心。它通过 <strong>CAS</strong> 避免了使用重量级锁带来的性能开销（线程挂起、上下文切换、锁竞争）。在高并发场景下，它能提供极高的吞吐量。</li>
<li><strong>延迟更新（Lazy Update）</strong>： 对 <code>head</code> 和 <code>tail</code> 指针的更新不是每次操作都进行，而是采用“跳几次更新一次”的策略（HOPS）。这大大减少了CAS操作的次数，进一步提升了性能，但代价是增加了代码的复杂度和 <code>size()</code> 等方法的计算成本。</li>
<li><strong>ABA 问题</strong>： 无锁算法需要处理ABA问题（一个值从A变成B又变回A，CAS检查不出变化）。在此队列中，通过将已出队的节点 <code>next</code> 指针指向自己（<code>self-link</code>）来避免这个问题。</li>
</ul>
<hr>
<h5 id="9-典型应用场景-2"><a href="#9-典型应用场景-2" class="headerlink" title="9.  典型应用场景"></a>9.  典型应用场景</h5><p><strong>1. 高性能的生产者-消费者模型</strong></p>
<p>这是最经典的应用场景。当你有多个线程生产任务（生产者），多个线程处理任务（消费者）时，<code>ConcurrentLinkedQueue</code> 可以作为中间的任务传输通道。</p>
<ul>
<li><strong>为什么适用？</strong><ul>
<li><strong>高吞吐</strong>： 在生产者或消费者线程非常多的情况下，非阻塞算法能提供远超阻塞队列（如 <code>LinkedBlockingQueue</code>）的吞吐量。</li>
<li><strong>生产者无等待</strong>： 由于队列无界，生产者可以全力生产任务而不用担心被阻塞，特别适合“爆发性”的任务提交。</li>
</ul>
</li>
<li><strong>典型例子</strong>：<ul>
<li><strong>线程池任务调度</strong>： 许多高性能的线程池（如 <code>ForkJoinPool</code> 或 <code>Executors.newWorkStealingPool()</code> 背后的实现）在其内部工作窃取队列中使用了类似 <code>ConcurrentLinkedQueue</code> 的非阻塞算法。</li>
<li><strong>事件总线&#x2F;消息分发</strong>： 在一个事件驱动架构中，事件发布者（生产者）可以快速将事件放入队列，然后由多个事件处理器（消费者）异步取出并处理。例如，GUI应用中的点击事件处理、游戏服务器中的玩家操作事件等。</li>
<li><strong>日志记录</strong>： 多个应用线程将日志消息快速放入一个共享的 <code>ConcurrentLinkedQueue</code>，然后由一个专用的后台消费者线程负责将日志写入磁盘或网络。这样可以避免昂贵的 I&#x2F;O 操作阻塞主业务线程。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>2. 连接池、资源池</strong></p>
<p><code>ConcurrentLinkedQueue</code> 可以用来实现一个轻量级的连接池或资源池。</p>
<ul>
<li><strong>为什么适用？</strong><ul>
<li><strong>借出和归还可以高度并发</strong>： 当大量线程同时请求和归还资源（如数据库连接、网络连接、对象实例）时，非阻塞的入队和出队操作效率极高。</li>
</ul>
</li>
<li><strong>如何实现</strong>：<ul>
<li>池初始化时，将所有空闲资源对象放入 <code>ConcurrentLinkedQueue</code>。</li>
<li>线程调用 <code>poll()</code> 尝试借出一个资源（如果队列为空则返回 <code>null</code>，池可以创建新资源或让线程等待）。</li>
<li>线程归还资源时，调用 <code>offer()</code> 方法将资源放回队列。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>3. 交换数据或传递消息</strong></p>
<p>在一些协作式多线程算法中，线程之间需要安全地交换一些数据或消息，而不希望因为锁而阻塞自己的执行流程。</p>
<ul>
<li><strong>为什么适用？</strong><ul>
<li><strong>非阻塞</strong>： 线程可以“顺便”尝试投递或获取一个消息，如果成功很好，如果不成功（例如队列空或满？但它无界所以不会满）就继续做其他事情，不会停滞</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-4-4-PriorityQueue【了解】"><a href="#2-4-4-PriorityQueue【了解】" class="headerlink" title="2.4.4 PriorityQueue【了解】"></a>2.4.4 PriorityQueue【了解】</h4><h5 id="1-核心概念-12"><a href="#1-核心概念-12" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>PriorityQueue</code> 是一个基于<strong>优先级堆（Priority Heap）</strong> 的无界优先级队列。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>有序（Ordered）</strong>： 元素并非按插入顺序排序，而是根据其<strong>自然顺序（Natural Ordering）</strong> 或构造时提供的 <strong><code>Comparator</code>（比较器）</strong> 进行排序。队头（<code>peek</code>&#x2F;<code>poll</code>）总是当前优先级最高（或最低，取决于排序规则）的元素。</li>
<li><strong>不允许 <code>null</code> 元素</strong>： 尝试添加 <code>null</code> 会抛出 <code>NullPointerException</code>。</li>
<li><strong>非线程安全（Not Thread-Safe）</strong>： 多线程环境下需要额外同步。</li>
<li><strong>无界（Unbounded）</strong>： 队列的容量会根据需要自动增长。但有一个基于数组最大大小的限制（<code>MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8</code>）。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层使用一个 <strong>平衡二叉堆（通常是最小堆）</strong> 来实现，并使用 <strong><code>Object[]</code> 数组</strong> 来存储这个堆结构。所有操作（如入队、出队）都围绕着维护堆的特性来进行。</li>
<li><strong>设计思想</strong>：利用基于数组实现的完全二叉最小堆，通过上浮和下沉操作在 O(log n) 时间内完成入队和出队，保证队首始终是最高优先级元素，从而高效实现优先级队列。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-10"><a href="#2-底层数据结构和关键属性-10" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>PriorityQueue</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化ID</span></span><br><span class="line">    <span class="meta">@java</span>.io.Serial</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">7720805057305804111L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优先级队列的底层存储数组。它维护了一个平衡二叉堆：</span></span><br><span class="line"><span class="comment">     * queue[n] 的两个孩子分别是 queue[2*n+1] 和 queue[2*(n+1)]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] queue; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列中的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较器。如果为 null，则使用元素的自然顺序（元素必须实现 Comparable 接口）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改次数计数器，用于实现迭代器的快速失败机制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他方法和构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>queue</code></strong>： 这是 <code>PriorityQueue</code> 的<strong>心脏</strong>。所有元素都存储在这个数组中，并且<strong>数组的逻辑结构是一个二叉堆</strong>。</li>
<li><strong><code>comparator</code></strong>： 这是 <code>PriorityQueue</code> 的<strong>大脑</strong>。它决定了元素的排列顺序。如果为 <code>null</code>，则依赖元素自身的 <code>Comparable</code> 实现。</li>
<li><strong><code>size</code></strong>： 记录了队列中实际的有效元素数量。</li>
<li><strong><code>DEFAULT_INITIAL_CAPACITY</code></strong>： 默认初始容量（11）。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-9"><a href="#3-构造方法与初始化-9" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>PriorityQueue</code> 提供了多种构造方式，核心是初始化 <code>queue</code> 数组和 <code>comparator</code>。</p>
<ol>
<li><p><strong><code>public PriorityQueue()</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 使用默认初始容量（11），并且默认按元素的<strong>自然顺序</strong>排序（<code>comparator = null</code>）。</li>
<li><strong>特点</strong>： <strong>元素必须实现 <code>Comparable</code> 接口</strong>，否则在添加时会抛出 <code>ClassCastException</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public PriorityQueue(int initialCapacity)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 指定初始容量，但仍使用元素的自然顺序（<code>comparator = null</code>）。</li>
<li><strong>特点</strong>： 避免初期频繁扩容。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public PriorityQueue(Comparator&lt;? super E&gt; comparator)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 使用默认初始容量，但提供一个自定义的 <code>Comparator</code>。</li>
<li><strong>特点</strong>： <strong>元素无需实现 <code>Comparable</code> 接口</strong>，顺序完全由比较器决定。或者可以用此比较器覆盖元素自身的自然顺序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 综合以上两者，是最底层的构造器。</li>
<li><strong>特点</strong>： 完全自定义容量和排序规则。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                     Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public PriorityQueue(Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 用一个已有集合来构造优先级队列。</li>
<li><strong>特点</strong>： 如果传入的集合是另一个 <code>SortedSet</code> 或 <code>PriorityQueue</code>，则会继承其比较器。否则使用自然顺序，并需要<strong>将无序集合“堆化”（Heapify）</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PriorityQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">        <span class="comment">// 如果传入的是 SortedSet，继承其比较器</span></span><br><span class="line">        SortedSet&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; ss = (SortedSet&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt;) c;</span><br><span class="line">        <span class="built_in">this</span>.comparator = (Comparator&lt;? <span class="built_in">super</span> E&gt;) ss.comparator();</span><br><span class="line">        initElementsFromCollection(ss);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityQueue&lt;?&gt;) &#123;</span><br><span class="line">        <span class="comment">// 如果传入的是 PriorityQueue，继承其比较器</span></span><br><span class="line">        PriorityQueue&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; pq = (PriorityQueue&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt;) c;</span><br><span class="line">        <span class="built_in">this</span>.comparator = (Comparator&lt;? <span class="built_in">super</span> E&gt;) pq.comparator();</span><br><span class="line">        initFromPriorityQueue(pq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他集合（如List, Set），使用自然顺序，并需要堆化</span></span><br><span class="line">        <span class="built_in">this</span>.comparator = <span class="literal">null</span>;</span><br><span class="line">        initFromCollection(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="4-扩容机制-Grow-1"><a href="#4-扩容机制-Grow-1" class="headerlink" title="4. 扩容机制 (Grow)"></a>4. 扩容机制 (Grow)</h5><p>当尝试向已满的数组（<code>size &gt;= queue.length</code>）添加新元素时，就会触发扩容。</p>
<p><strong>源码流程（以 <code>add(E e)</code> &#x2F; <code>offer(E e)</code> 为例）：</strong></p>
<ol>
<li><p><code>offer(E e)</code> -&gt; <code>if (i &gt;= size)</code> （判断容量是否已满）</p>
</li>
<li><p><code>grow(i + 1)</code> -&gt; <code>grow(int minCapacity)</code></p>
</li>
<li><p><strong><code>grow(int minCapacity)</code></strong>： <strong>扩容核心方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增加数组容量以确保它至少可以容纳 minCapacity 个元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> queue.length;</span><br><span class="line">    <span class="comment">// 计算新容量：如果旧容量 &lt; 64，则 double (oldCapacity + oldCapacity + 2)；</span></span><br><span class="line">    <span class="comment">//            否则，增长 50% (oldCapacity + oldCapacity / 2)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                     (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                     (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 处理溢出情况</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 拷贝数据到新数组</span></span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// 溢出，minCapacity 变成了负数</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>扩容策略</strong>： 小容量时加倍增长（<code>&lt;64</code> 时 <code>old*2+2</code>），大容量时增长 50%（<code>old*1.5</code>），以避免频繁扩容。与 <code>ArrayList</code> 的固定 1.5 倍略有不同。</p>
<hr>
<h5 id="5-添加元素-Offer-Add"><a href="#5-添加元素-Offer-Add" class="headerlink" title="5. 添加元素(Offer&#x2F;Add)"></a>5. 添加元素(Offer&#x2F;Add)</h5><ul>
<li><p><strong><code>public boolean offer(E e)</code></strong>：</p>
<ol>
<li>检查元素是否为 <code>null</code>，是则抛 <code>NPE</code>。</li>
<li>修改计数器 <code>modCount++</code>。</li>
<li>判断容量，不足则扩容 <code>grow(size + 1)</code>。</li>
<li>调用 <code>siftUp(int k, E x)</code> <strong>“上浮”</strong> 操作，将新元素 <code>x</code> 从堆底 <code>k</code> 的位置开始，向上与父节点比较并交换，直到找到其正确的位置，以维持堆的性质。</li>
<li><code>size++</code>。</li>
<li>返回 <code>true</code>。</li>
</ol>
<ul>
<li><p><strong>时间复杂度</strong>： <strong><code>O(log n)</code></strong>。因为上浮操作最多需要遍历堆的高度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>); <span class="comment">// 扩容</span></span><br><span class="line">    siftUp(i, e);   <span class="comment">// 关键：上浮操作，维护堆结构</span></span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据是否有比较器，选择不同的上浮方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">        siftUpUsingComparator(k, x, queue, comparator);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUpComparable(k, x, queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自然顺序的上浮实现</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">siftUpComparable</span><span class="params">(<span class="type">int</span> k, T x, Object[] es)</span> &#123;</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> T&gt; key = (Comparable&lt;? <span class="built_in">super</span> T&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 找到父节点的索引</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> es[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>) <span class="comment">// 如果当前节点 &gt;= 父节点，满足最小堆，停止</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        es[k] = e; <span class="comment">// 否则，父节点下沉</span></span><br><span class="line">        k = parent; <span class="comment">// 当前指针 k 上移到父节点位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    es[k] = key; <span class="comment">// 找到最终位置，放入元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public boolean add(E e)</code></strong>：</p>
<ul>
<li><p>内部直接调用 <code>offer(e)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="6-获取与删除队头元素-Poll-Remove"><a href="#6-获取与删除队头元素-Poll-Remove" class="headerlink" title="6. 获取与删除队头元素(Poll&#x2F;Remove)"></a>6. 获取与删除队头元素(Poll&#x2F;Remove)</h5><ul>
<li><p><strong><code>public E poll()</code></strong>：</p>
<ol>
<li>如果 <code>size == 0</code>，返回 <code>null</code>。</li>
<li>修改计数器 <code>modCount++</code>。</li>
<li>取出堆顶元素 <code>result = (E) queue[0]</code>（即优先级最高的元素）。</li>
<li>取出堆尾元素 <code>E x = (E) queue[s]</code>，并将堆尾置 <code>null</code>。</li>
<li><code>size--</code>。</li>
<li>如果队列不为空，调用 <code>siftDown(int k, E x)</code> <strong>“下沉”</strong> 操作，将堆尾元素 <code>x</code> 从堆顶 <code>k=0</code> 的位置开始，向下与子节点中较小的那个比较并交换，直到找到其正确的位置，以维持堆的性质。</li>
<li>返回取出的堆顶元素 <code>result</code>。</li>
</ol>
<ul>
<li><p><strong>时间复杂度</strong>： <strong><code>O(log n)</code></strong>。因为下沉操作最多需要遍历堆的高度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es;</span><br><span class="line">    <span class="keyword">final</span> E result;</span><br><span class="line">    <span class="keyword">if</span> ((result = (E) ((es = queue)[<span class="number">0</span>])) != <span class="literal">null</span>) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) es[(n = --size)]; <span class="comment">// 取出最后一个元素</span></span><br><span class="line">        es[n] = <span class="literal">null</span>; <span class="comment">// 最后一个位置置空</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            siftDown(<span class="number">0</span>, x); <span class="comment">// 关键：将最后一个元素放到顶部并下沉</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据是否有比较器，选择不同的下沉方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x, queue, size, comparator);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x, queue, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自然顺序的下沉实现</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">siftDownComparable</span><span class="params">(<span class="type">int</span> k, T x, Object[] es, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> T&gt; key = (Comparable&lt;? <span class="built_in">super</span> T&gt;) x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> n &gt;&gt;&gt; <span class="number">1</span>;           <span class="comment">// 只需要遍历到非叶子节点（无子节点的节点）即可</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 左孩子索引</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> es[child];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;    <span class="comment">// 右孩子索引</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; n &amp;&amp;</span><br><span class="line">            ((Comparable&lt;? <span class="built_in">super</span> T&gt;) c).compareTo((T) es[right]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果右孩子存在且比左孩子小，则 c 指向右孩子（选择更小的孩子）</span></span><br><span class="line">            c = es[child = right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) c) &lt;= <span class="number">0</span>) <span class="comment">// 如果当前节点 &lt;= 最小的孩子，满足堆，停止</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        es[k] = c; <span class="comment">// 否则，最小的孩子上浮</span></span><br><span class="line">        k = child; <span class="comment">// 当前指针 k 下移到孩子位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    es[k] = key; <span class="comment">// 找到最终位置，放入元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public E remove()</code></strong>：</p>
<ul>
<li><p>内部调用 <code>poll()</code>，但如果队列为空会抛出 <code>NoSuchElementException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> poll();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="7-查看队头元素-Peek-Element"><a href="#7-查看队头元素-Peek-Element" class="headerlink" title="7. 查看队头元素(Peek&#x2F;Element)"></a>7. 查看队头元素(Peek&#x2F;Element)</h5><ul>
<li><p><strong><code>public E peek()</code></strong>：</p>
<ul>
<li><p>直接返回 <code>(E) queue[0]</code>。</p>
</li>
<li><p><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) queue[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public E element()</code></strong>：</p>
<ul>
<li><p>内部调用 <code>peek()</code>，但如果队列为空会抛出 <code>NoSuchElementException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">element</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> peek();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="8-查找-Contains-与删除指定元素-Remove"><a href="#8-查找-Contains-与删除指定元素-Remove" class="headerlink" title="8. 查找(Contains)与删除指定元素(Remove)"></a>8. 查找(Contains)与删除指定元素(Remove)</h5><ul>
<li><p><strong><code>public boolean contains(Object o)</code></strong>：</p>
<ul>
<li><strong>源码逻辑</strong>： 直接遍历底层数组 <code>queue</code>，使用 <code>equals</code> 方法进行比较。</li>
<li><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>。无法利用堆的特性进行高效查找。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] es = queue;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = size; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(es[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public boolean remove(Object o)</code></strong>：</p>
<ul>
<li><strong>源码逻辑</strong>：<ol>
<li>先调用 <code>indexOf(o)</code> 找到元素索引 <code>i</code>。</li>
<li>如果没找到 (<code>i == -1</code>)，返回 <code>false</code>。</li>
<li>调用 <code>removeAt(int i)</code> 方法删除该索引处的元素。</li>
</ol>
</li>
<li><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>（查找 <code>O(n)</code> + 删除 <code>O(log n)</code> ≈ <code>O(n)</code>）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexOf(o);</span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        removeAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定位置的元素</span></span><br><span class="line">E <span class="title function_">removeAt</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es = queue;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> --size; <span class="comment">// size 先减 1</span></span><br><span class="line">    <span class="keyword">if</span> (s == i) &#123; <span class="comment">// 如果删除的是最后一个元素，直接置空即可</span></span><br><span class="line">        es[i] = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">moved</span> <span class="operator">=</span> (E) es[s]; <span class="comment">// 取出最后一个元素</span></span><br><span class="line">        es[s] = <span class="literal">null</span>;        <span class="comment">// 最后一个位置置空</span></span><br><span class="line">        siftDown(i, moved);  <span class="comment">// 先尝试将最后一个元素在 i 位置下沉</span></span><br><span class="line">        <span class="comment">// 如果下沉后 moved 元素还在原位 i，说明它无法下沉，</span></span><br><span class="line">        <span class="comment">// 可能需要尝试上浮（例如，它比子节点小，但比父节点大）</span></span><br><span class="line">        <span class="keyword">if</span> (es[i] == moved) &#123;</span><br><span class="line">            siftUp(i, moved); <span class="comment">// 尝试上浮</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 返回被删除的元素（此处省略）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="9-遍历方式-1"><a href="#9-遍历方式-1" class="headerlink" title="9. 遍历方式"></a>9. 遍历方式</h5><ul>
<li><strong>迭代器（Iterator）</strong>： 通过 <code>iterator()</code> 方法返回的迭代器进行遍历。<ul>
<li><strong>重要警告</strong>： <strong>迭代器不保证以任何特定的顺序遍历队列中的元素</strong>。它只是简单地遍历底层数组。如果需要按优先级顺序处理，应该使用 <code>poll()</code> 循环取出。</li>
</ul>
</li>
<li><strong><code>Object[] toArray()</code></strong>： 返回包含队列所有元素的数组。<ul>
<li><strong>同样不保证顺序</strong>。数组是底层 <code>queue</code> 数组的拷贝，但未经过堆排序。</li>
</ul>
</li>
</ul>
<p><strong>最佳实践</strong>： <strong>永远不要使用迭代器或 <code>toArray()</code> 来获取有序序列</strong>。唯一能保证顺序的操作是循环调用 <code>poll()</code>。</p>
<hr>
<h4 id="2-4-5-ArrayBlockingQueue【了解】"><a href="#2-4-5-ArrayBlockingQueue【了解】" class="headerlink" title="2.4.5 ArrayBlockingQueue【了解】"></a>2.4.5 ArrayBlockingQueue【了解】</h4><h5 id="1-核心概念-13"><a href="#1-核心概念-13" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>ArrayBlockingQueue</code> 是一个由<strong>数组</strong>支持的、<strong>有界的</strong>、<strong>阻塞的</strong>、<strong>线程安全的</strong> FIFO（先进先出）队列。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>有界（Bounded）</strong>： 队列的容量在创建时被固定，一旦满员，尝试插入的操作将被阻塞。</li>
<li><strong>阻塞（Blocking）</strong>： 当队列操作条件不满足时（如空队列取元素，满队列存元素），调用线程会被<strong>阻塞</strong>，直到条件满足或被中断。</li>
<li><strong>线程安全（Thread-Safe）</strong>： 所有公共方法都通过一个<strong>全局锁（ReentrantLock）</strong> 来实现线程安全。</li>
<li><strong>FIFO（First-In-First-Out）</strong>： 队列头是在队列中时间最长的元素，队列尾是在队列中时间最短的元素。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层使用一个定长的 <code>Object[]</code> 数组来存储元素，通过两个索引 (<code>takeIndex</code>, <code>putIndex</code>) 来实现循环数组（Circular Array）。通过一个 <code>ReentrantLock</code> 和与之关联的两个 <code>Condition</code>（<code>notEmpty</code>, <code>notFull</code>) 来实现线程间的等待&#x2F;通知机制。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-11"><a href="#2-底层数据结构和关键属性-11" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>ArrayBlockingQueue</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化ID</span></span><br><span class="line">    <span class="meta">@java</span>.io.Serial</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">817911632652898426L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 存储元素的底层数组 */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 下一个要执行 take, poll, peek 或 remove 操作的索引位置 */</span></span><br><span class="line">    <span class="type">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 下一个要执行 put, offer, 或 add 操作的索引位置 */</span></span><br><span class="line">    <span class="type">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 队列中的元素个数 */</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 保护所有访问的主锁 */</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于等待“非空”条件的 Condition */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于等待“未满”条件的 Condition */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他方法和构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>items</code></strong>： 定长数组，是队列的存储核心。</li>
<li><strong><code>takeIndex</code> &amp; <code>putIndex</code></strong>： 这两个索引是实现<strong>循环数组</strong>的关键。当索引到达数组末尾时，会绕回数组开头（<code>0</code>）。</li>
<li><strong><code>count</code></strong>： 当前队列中的元素数量。</li>
<li><strong><code>lock</code></strong>： <strong>全局锁（<code>ReentrantLock</code>）</strong>。所有对队列的访问都必须先获得此锁，这是实现线程安全的基础。</li>
<li><strong><code>notEmpty</code> &amp; <code>notFull</code></strong>： 两个 <code>Condition</code> 对象，分别与“队列不为空”和“队列未满”这两个条件关联。当条件不满足时，线程会在这些条件上等待；当条件可能被满足时，其他线程会唤醒在此条件上等待的线程。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-10"><a href="#3-构造方法与初始化-10" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>ArrayBlockingQueue</code> 提供了三种构造方式，核心是初始化数组和锁。</p>
<ol>
<li><p><strong><code>public ArrayBlockingQueue(int capacity)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 创建指定容量的队列，默认使用<strong>非公平</strong>的锁策略。</li>
<li><strong>特点</strong>： 非公平锁的吞吐量通常更高，但可能造成线程饥饿。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(capacity, <span class="literal">false</span>); <span class="comment">// 默认非公平锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public ArrayBlockingQueue(int capacity, boolean fair)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 创建指定容量的队列，并指定锁的公平性。</li>
<li><strong>特点</strong>： 如果 <code>fair</code> 为 <code>true</code>，则锁使用公平策略，等待时间最长的线程会优先获得锁，避免饥饿，但可能会降低整体吞吐量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity]; <span class="comment">// 初始化定长数组</span></span><br><span class="line">    lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(fair);     <span class="comment">// 创建指定公平策略的锁</span></span><br><span class="line">    notEmpty = lock.newCondition();     <span class="comment">// 从锁创建条件变量</span></span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 创建指定容量和锁策略的队列，并用一个集合来初始化。</li>
<li><strong>特点</strong>： 初始化操作也会在锁的保护下进行，保证线程安全。如果集合大小超过指定容量，会抛出异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair,</span></span><br><span class="line"><span class="params">                          Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(capacity, fair); <span class="comment">// 调用双参数构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 初始化也需要加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">                items[i++] = e; <span class="comment">// 将集合元素放入数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        count = i;         <span class="comment">// 更新元素数量</span></span><br><span class="line">        putIndex = (i == capacity) ? <span class="number">0</span> : i; <span class="comment">// 更新 putIndex</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">// 必须在 finally 块中解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="4-扩容机制"><a href="#4-扩容机制" class="headerlink" title="4. 扩容机制"></a>4. 扩容机制</h5><ul>
<li><strong><code>ArrayBlockingQueue</code> 是有界队列，创建后容量固定，不支持动态扩容。</strong> 这是它与 <code>ArrayList</code> 和 <code>PriorityQueue</code> 最根本的区别之一。尝试向已满队列添加元素的操作会根据不同方法而阻塞、返回特殊值或抛出异常。</li>
</ul>
<hr>
<h5 id="5-添加元素-Put-Offer-Add"><a href="#5-添加元素-Put-Offer-Add" class="headerlink" title="5. 添加元素(Put&#x2F;Offer&#x2F;Add)"></a>5. 添加元素(Put&#x2F;Offer&#x2F;Add)</h5><ul>
<li><p><strong><code>public void put(E e) throws InterruptedException</code></strong>：</p>
<ol>
<li>检查非空，可响应中断。</li>
<li>获取锁 <code>lock.lockInterruptibly()</code>。</li>
<li>循环检查 <code>while (count == items.length)</code>，如果队列满，则在 <code>notFull</code> 条件上等待 <code>notFull.await()</code>。</li>
<li>调用 <code>enqueue(E x)</code> 方法将元素入队。</li>
<li>释放锁 <code>lock.unlock()</code>。</li>
</ol>
<ul>
<li><p><strong>特点</strong>： <strong>阻塞</strong>。如果队列满，当前线程会一直等待，直到有空间被唤醒或被中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">// 获取可中断的锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) <span class="comment">// 循环检查（防止虚假唤醒）</span></span><br><span class="line">            notFull.await();         <span class="comment">// 在 notFull 条件上等待</span></span><br><span class="line">        enqueue(e);                  <span class="comment">// 队列未满，执行入队</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入队核心方法（必须在持有锁时调用）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E x)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    items[putIndex] = x; <span class="comment">// 将元素放入 putIndex 位置</span></span><br><span class="line">    <span class="comment">// 循环数组：如果 putIndex 到达末尾，则绕回 0</span></span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;             <span class="comment">// 元素数量增加</span></span><br><span class="line">    notEmpty.signal();   <span class="comment">// 唤醒一个在 notEmpty 上等待的线程（消费者）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public boolean offer(E e)</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>： 与 <code>put</code> 类似，但<strong>非阻塞</strong>。如果队列满，立即返回 <code>false</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length) <span class="comment">// 队列已满</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;         <span class="comment">// 立即返回 false</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            enqueue(e);          <span class="comment">// 队列未满，执行入队</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;         <span class="comment">// 返回 true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>： <strong>超时阻塞</strong>。如果队列满，会在 <code>notFull</code> 条件上等待指定的超时时间。如果在超时前被唤醒或有空间了，则入队；如果超时了还是满的，则返回 <code>false</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout); <span class="comment">// 转换为纳秒</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)      <span class="comment">// 超时时间已用完</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">// 返回 false</span></span><br><span class="line">            nanos = notFull.awaitNanos(nanos); <span class="comment">// 进行超时等待，返回剩余时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public boolean add(E e)</code></strong>：</p>
<ul>
<li>内部调用 <code>offer(e)</code>。</li>
<li>如果队列满，<code>offer(e)</code> 返回 <code>false</code>，<code>add</code> 会抛出 <code>IllegalStateException(&quot;Queue full&quot;)</code>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="6-获取与删除队头元素-Take-Poll-Remove"><a href="#6-获取与删除队头元素-Take-Poll-Remove" class="headerlink" title="6. 获取与删除队头元素(Take&#x2F;Poll&#x2F;Remove)"></a>6. 获取与删除队头元素(Take&#x2F;Poll&#x2F;Remove)</h5><ul>
<li><p><strong><code>public E take() throws InterruptedException</code></strong>：</p>
<ol>
<li>获取可中断的锁。</li>
<li>循环检查 <code>while (count == 0)</code>，如果队列空，则在 <code>notEmpty</code> 条件上等待 <code>notEmpty.await()</code>。</li>
<li>调用 <code>dequeue()</code> 方法将元素出队。</li>
<li>释放锁。</li>
<li>返回取出的元素。</li>
</ol>
<ul>
<li><p><strong>特点</strong>： <strong>阻塞</strong>。如果队列空，当前线程会一直等待，直到有元素被唤醒或被中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)     <span class="comment">// 循环检查（防止虚假唤醒）</span></span><br><span class="line">            notEmpty.await(); <span class="comment">// 在 notEmpty 条件上等待</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();     <span class="comment">// 队列不空，执行出队</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出队核心方法（必须在持有锁时调用）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) items[takeIndex]; <span class="comment">// 取出 takeIndex 位置的元素</span></span><br><span class="line">    items[takeIndex] = <span class="literal">null</span>;    <span class="comment">// 将该位置置空，帮助 GC</span></span><br><span class="line">    <span class="comment">// 循环数组：如果 takeIndex 到达末尾，则绕回 0</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;                <span class="comment">// 元素数量减少</span></span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="literal">null</span>)</span><br><span class="line">        itrs.elementDequeued(); <span class="comment">// 更新迭代器状态（如果存在）</span></span><br><span class="line">    notFull.signal();       <span class="comment">// 唤醒一个在 notFull 上等待的线程（生产者）</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public E poll()</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>： <strong>非阻塞</strong>。如果队列空，立即返回 <code>null</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="literal">null</span> : dequeue(); <span class="comment">// 三目运算</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public E poll(long timeout, TimeUnit unit) throws InterruptedException</code></strong>：</p>
<ul>
<li><strong>源码逻辑</strong>： <strong>超时阻塞</strong>。与 <code>offer(E, long, TimeUnit)</code> 逻辑类似，但是在 <code>notEmpty</code> 条件上等待。</li>
</ul>
</li>
<li><p><strong><code>public E remove()</code></strong>：</p>
<ul>
<li>内部调用 <code>poll()</code>。</li>
<li>如果队列空，<code>poll()</code> 返回 <code>null</code>，<code>remove</code> 会抛出 <code>NoSuchElementException</code>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="7-查看队头元素-Peek-Element-1"><a href="#7-查看队头元素-Peek-Element-1" class="headerlink" title="7. 查看队头元素(Peek&#x2F;Element)"></a>7. 查看队头元素(Peek&#x2F;Element)</h5><ul>
<li><p><strong><code>public E peek()</code></strong>：</p>
<ul>
<li><p><strong>源码逻辑</strong>： 加锁后，直接返回 <code>(E) items[takeIndex]</code>（即队头元素），但<strong>不移除</strong>它。如果队列为空则返回 <code>null</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// 如果队列空，返回 null</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> E <span class="title function_">itemAt</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) items[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public E element()</code></strong>：</p>
<ul>
<li>内部调用 <code>peek()</code>，但如果队列为空会抛出 <code>NoSuchElementException</code>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="8-遍历方式-2"><a href="#8-遍历方式-2" class="headerlink" title="8. 遍历方式"></a>8. 遍历方式</h5><ul>
<li><strong>迭代器（Iterator）</strong>： 通过 <code>iterator()</code> 方法返回的迭代器进行遍历。<ul>
<li><strong>特点</strong>： 迭代器是<strong>弱一致性（Weakly Consistent）</strong> 的。它反映的是创建迭代器那一刻或之后某个时刻的队列状态，<strong>不会抛出 <code>ConcurrentModificationException</code></strong>，但可能不会反映出迭代过程中所有的修改。</li>
<li>迭代器的实现同样需要获取主锁，以保证遍历过程中状态的相对一致性。</li>
</ul>
</li>
</ul>
<p><strong>最佳实践</strong>： <code>ArrayBlockingQueue</code> 是实现<strong>生产者-消费者（Producer-Consumer）</strong> 模式的经典工具。生产者线程调用 <code>put()</code> 或 <code>offer()</code>，消费者线程调用 <code>take()</code> 或 <code>poll()</code>，通过内置的锁和条件变量高效地协调工作。</p>
<hr>
<h4 id="2-4-6-Deque-继承"><a href="#2-4-6-Deque-继承" class="headerlink" title="2.4.6 Deque(继承)"></a>2.4.6 Deque(继承)</h4><p><code>Deque</code>（Double Ended Queue，发音为 “deck”）是 <code>Queue</code> 的直接子接口。它支持在<strong>队列的两端</strong>插入、移除和检查元素。因此，它既可以作为 FIFO 的<strong>队列</strong>使用，也可以作为 LIFO 的<strong>栈</strong>使用。</p>
<h5 id="1-核心特征：-1"><a href="#1-核心特征：-1" class="headerlink" title="1.核心特征："></a>1.<strong>核心特征：</strong></h5><ol>
<li><strong>双端操作（Double-Ended）</strong>： 这是其最核心的特征，允许在头部和尾部进行添加、删除和查看操作。</li>
<li><strong>可作队列和栈（Queue &amp; Stack）</strong>： 它完全包含了 <code>Queue</code> 的所有功能，并且提供了一组与 <code>Stack</code> 类（古老类，不推荐使用）等效的方法。</li>
<li><strong>无索引（Non-Indexed）</strong>： 同样<strong>不能</strong>通过索引访问中间的元素。</li>
<li><strong>方法对（Method Pairs）</strong>： 对于每个操作，都提供了针对“第一端”（头部）和“最后一端”（尾部）的两个方法，并且每个方法都有“抛出异常”和“返回特殊值”两种形式。</li>
</ol>
<h5 id="2-特有的核心方法-1"><a href="#2-特有的核心方法-1" class="headerlink" title="2.特有的核心方法"></a>2.<strong>特有的核心方法</strong></h5><p><code>Deque</code> 的方法非常对称，其方法名通常以 <code>First</code>（头部）或 <code>Last</code>（尾部）结尾。</p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>头部（First Element &#x2F; Head）</th>
<th>尾部（Last Element &#x2F; Tail）</th>
<th>等效的栈方法</th>
</tr>
</thead>
<tbody><tr>
<td><strong>插入</strong></td>
<td><code>void addFirst(E e)</code></td>
<td><code>void addLast(E e)</code></td>
<td></td>
</tr>
<tr>
<td><strong>移除</strong></td>
<td><code>E removeFirst()</code></td>
<td><code>E removeLast()</code></td>
<td><code>E pop()</code></td>
</tr>
<tr>
<td><strong>检查</strong></td>
<td><code>E getFirst()</code></td>
<td><code>E getLast()</code></td>
<td><code>E peek()</code></td>
</tr>
</tbody></table>
<p><strong>说明</strong>：</p>
<ul>
<li><strong>作为队列（FIFO）</strong>：<ul>
<li><strong>入队</strong>：使用 <code>addLast(e)</code> &#x2F; <code>offerLast(e)</code></li>
<li><strong>出队</strong>：使用 <code>removeFirst()</code> &#x2F; <code>pollFirst()</code></li>
</ul>
</li>
<li><strong>作为栈（LIFO）</strong>：<ul>
<li><strong>入栈（Push）</strong>：使用 <code>addFirst(e)</code> &#x2F; <code>push(e)</code></li>
<li><strong>出栈（Pop）</strong>：使用 <code>removeFirst()</code> &#x2F; <code>pop()</code></li>
<li><strong>查看栈顶（Peek）</strong>：使用 <code>getFirst()</code> &#x2F; <code>peekFirst()</code> &#x2F; <code>peek()</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-4-7-ArrayDeque【了解】"><a href="#2-4-7-ArrayDeque【了解】" class="headerlink" title="2.4.7 ArrayDeque【了解】"></a>2.4.7 ArrayDeque【了解】</h4><h5 id="1-核心概念-14"><a href="#1-核心概念-14" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>ArrayDeque</code> 是 <code>Deque</code> 接口的<strong>基于可变数组的实现</strong>。<code>Deque</code> 是“Double Ended Queue”的缩写，即双端队列。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>双端操作</strong>： 可以在队列的<strong>头部</strong>和<strong>尾部</strong>高效地进行插入、删除和查看操作。</li>
<li><strong>无容量限制</strong>： 像 <code>ArrayList</code> 一样，会根据需要自动扩容。</li>
<li><strong>非线程安全</strong>： 多线程环境下未经同步直接使用会导致不确定的结果。</li>
<li><strong>禁止 null 元素</strong>： 不允许插入 <code>null</code> 元素，因为 <code>null</code> 被用作某些方法的特殊返回值（如 poll 失败时返回 <code>null</code>）。</li>
<li><strong>性能</strong>： 作为栈使用时，性能优于 <code>Stack</code>；作为队列使用时，性能优于 <code>LinkedList</code>。它是大多数场景下实现栈和队列的<strong>首选</strong>。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 底层使用一个 <strong><code>Object[] elements</code></strong> 数组来存储所有元素。通过两个整型变量 <strong><code>head</code></strong> 和 <strong><code>tail</code></strong> 来标记队列的头部和尾部，从而构成一个<strong>逻辑上的循环数组</strong>。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-12"><a href="#2-底层数据结构和关键属性-12" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>ArrayDeque</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDeque</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt;</span><br><span class="line">                           <span class="keyword">implements</span> <span class="title class_">Deque</span>&lt;E&gt;, Cloneable, Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储双端队列元素的数组。</span></span><br><span class="line"><span class="comment">     * 双端队列的容量就是这个数组的长度，它总是 2 的幂。</span></span><br><span class="line"><span class="comment">     * 数组永远不允许变满，除非在 addX 方法中短暂地变满，然后立即调整大小（参见双倍容量）。</span></span><br><span class="line"><span class="comment">     * 这避免了 head 和 tail 缠绕在一起时变得相等。</span></span><br><span class="line"><span class="comment">     * 数组也永远不允许变空，但会保持至少一个空位。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头部元素的索引（即将被 remove() 或 pop() 移除的元素）。</span></span><br><span class="line"><span class="comment">     * 如果双端队列为空，head 可能等于 tail。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个元素将被添加到尾部的索引（通过 addLast(E), add(E), offer(E)）。</span></span><br><span class="line"><span class="comment">     * 如果双端队列为空，tail 可能等于 head。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最小初始容量，必须是 2 的幂。</span></span><br><span class="line"><span class="comment">     * 至少为 8。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他方法和构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>elements</code></strong>： 这是 <code>ArrayDeque</code> 的<strong>存储核心</strong>。所有元素都存储在这个数组中。</li>
<li><strong><code>head</code></strong>： <strong>头部索引</strong>。指向当前队列中<strong>第一个有效元素</strong>的位置。</li>
<li><strong><code>tail</code></strong>： <strong>尾部索引</strong>。指向当前队列中<strong>下一个元素将被添加的位置</strong>（即最后一个有效元素的下一个空位）。</li>
<li><strong><code>MIN_INITIAL_CAPACITY</code></strong>： 最小初始容量（8）。底层数组的容量<strong>永远是 2 的幂</strong>，这是为了使用位运算 (<code>&amp; (length-1)</code>) 来高效计算索引，实现数组的循环利用。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-11"><a href="#3-构造方法与初始化-11" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>ArrayDeque</code> 提供了三种构造方式：</p>
<ol>
<li><p><strong><code>public ArrayDeque()</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 将数组初始化为一个默认大小的空数组（通常是 16，但具体实现是 <code>calculateSize(numElements)</code> 方法计算的结果）。</p>
</li>
<li><p><strong>特点</strong>： <strong>默认构造器</strong>。创建一个初始容量为 16 的空数组双端队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个初始容量为 16 的空数组双端队列。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">()</span> &#123;</span><br><span class="line">    elements = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">16</span>]; <span class="comment">// 实际上是调用 calculateSize(16) 的结果，但 16 正好是 2 的幂</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public ArrayDeque(int numElements)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 调用 <code>allocateElements(numElements)</code> 方法，该方法会计算一个<strong>大于等于 <code>numElements</code> 的最小的 2 的幂</strong>作为初始容量。</p>
</li>
<li><p><strong>特点</strong>： <strong>显式指定初始容量</strong>。避免一开始就进行多次扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个初始容量足以容纳指定数量元素的空数组双端队列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> numElements 要容纳的元素数量的下限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(<span class="type">int</span> numElements)</span> &#123;</span><br><span class="line">    elements = <span class="keyword">new</span> <span class="title class_">Object</span>[calculateSize(numElements)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算容量，返回大于等于 numElements 的最小的 2 的幂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateSize</span><span class="params">(<span class="type">int</span> numElements)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">initialCapacity</span> <span class="operator">=</span> MIN_INITIAL_CAPACITY;</span><br><span class="line">    <span class="comment">// 如果指定了更大的容量，则计算最小的 2 的幂来容纳它</span></span><br><span class="line">    <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">        initialCapacity = numElements;</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">        initialCapacity++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   <span class="comment">// 太大，溢出了</span></span><br><span class="line">            initialCapacity &gt;&gt;&gt;= <span class="number">1</span>; <span class="comment">// 回退到 2^30</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> initialCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>public ArrayDeque(Collection&lt;? extends E&gt; c)</code></strong></p>
<ul>
<li><p><strong>源码逻辑</strong>： 使用默认构造器的逻辑初始化一个足够大的数组，然后使用 <code>addAll(c)</code> 将集合中的所有元素添加到双端队列的尾部。</p>
</li>
<li><p><strong>特点</strong>： <strong>用一个已有集合来构造</strong>，元素顺序由该集合的迭代器决定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含指定集合所有元素的双端队列，</span></span><br><span class="line"><span class="comment"> * 元素顺序由集合的迭代器返回顺序决定。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 其元素要被放入此双端队列的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 如果指定的集合为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    allocateElements(c.size());</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-扩容机制-doubleCapacity"><a href="#4-扩容机制-doubleCapacity" class="headerlink" title="4. 扩容机制 (doubleCapacity)"></a>4. 扩容机制 (doubleCapacity)</h5><p>当队列已满（即 <code>head == tail</code>）时，尝试添加元素就会触发扩容。</p>
<p><strong>源码流程：</strong></p>
<ol>
<li><p>判断 <code>head</code> 是否等于 <code>tail</code>。</p>
</li>
<li><p>调用 <strong><code>doubleCapacity()</code></strong>： <strong>扩容核心方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将双端队列的容量增加一倍。</span></span><br><span class="line"><span class="comment"> * 仅在 head == tail 时调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doubleCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 断言：head == tail，队列已满</span></span><br><span class="line">    <span class="keyword">assert</span> head == tail;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> elements.length; <span class="comment">// 旧数组长度</span></span><br><span class="line">    <span class="comment">// head 右边（到数组末尾）的元素数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> n - p; </span><br><span class="line">    <span class="comment">// 新容量是旧容量的两倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 检查是否溢出</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Sorry, deque too big&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    Object[] a = <span class="keyword">new</span> <span class="title class_">Object</span>[newCapacity];</span><br><span class="line">    <span class="comment">// 分两段拷贝数据到新数组</span></span><br><span class="line">    <span class="comment">// 1. 拷贝从 head 到数组末尾的元素 [p, n)</span></span><br><span class="line">    System.arraycopy(elements, p, a, <span class="number">0</span>, r);</span><br><span class="line">    <span class="comment">// 2. 拷贝从数组开头到 head 的元素 [0, p)</span></span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, a, r, p);</span><br><span class="line">    <span class="comment">// 更新 elements 引用</span></span><br><span class="line">    elements = a;</span><br><span class="line">    <span class="comment">// 重置 head 和 tail</span></span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    tail = n; <span class="comment">// n 是旧数组长度，也是新数组中有效元素的末尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>关键点</strong>：</p>
<ul>
<li>新容量是旧容量的<strong>两倍</strong>。</li>
<li>拷贝数据时分为两段：从 <code>head</code> 到数组末尾，以及从数组开头到 <code>head</code>。这是因为 <code>ArrayDeque</code> 是循环数组，<code>head</code> 可能在数组中间。</li>
<li>扩容后，<code>head</code> 被重置为 <code>0</code>，<code>tail</code> 被重置为旧数组的长度 <code>n</code>，整个队列在物理上变得连续。</li>
</ul>
<hr>
<h5 id="5-添加元素-Add-1"><a href="#5-添加元素-Add-1" class="headerlink" title="5. 添加元素(Add)"></a>5. 添加元素(Add)</h5><ul>
<li><p><strong>头部添加 <code>public void addFirst(E e)</code> &#x2F; <code>offerFirst(E e)</code></strong>：</p>
<ol>
<li>检查元素是否为 <code>null</code>，是则抛出 <code>NullPointerException</code>。</li>
<li>将 <code>head</code> 指针<strong>向前（向左）移动一位</strong>。由于是循环数组，使用 <code>(head - 1) &amp; (elements.length - 1)</code> 计算新位置（利用了 <code>length</code> 是 2 的幂的特性，<code>&amp; (length-1)</code> 等价于 <code>% length</code>，但效率更高）。</li>
<li>将新元素放入新的 <code>head</code> 位置。</li>
<li>检查是否 <code>head == tail</code>，如果是则调用 <code>doubleCapacity()</code> 扩容。</li>
</ol>
<ul>
<li><p><strong>时间复杂度</strong>： <strong>摊销常数时间 <code>O(1)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 计算新的 head 位置： (head - 1) mod (elements.length)</span></span><br><span class="line">    <span class="keyword">final</span> Object[] es = elements;</span><br><span class="line">    es[head = dec(head, es.length)] = e;</span><br><span class="line">    <span class="keyword">if</span> (head == tail)</span><br><span class="line">        grow(<span class="number">1</span>); <span class="comment">// 最终会调用 doubleCapacity()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算前移一位的索引（循环）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> modulus)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (--i &lt; <span class="number">0</span>) i = modulus - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更高效的位运算写法（因为 modulus 是 2 的幂）：</span></span><br><span class="line"><span class="comment">// head = (head - 1) &amp; (elements.length - 1)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>尾部添加 <code>public void addLast(E e)</code> &#x2F; <code>offerLast(E e)</code> &#x2F; <code>add(E e)</code> &#x2F; <code>offer(E e)</code></strong>：</p>
<ol>
<li>检查元素是否为 <code>null</code>。</li>
<li>将新元素放入当前的 <code>tail</code> 位置。</li>
<li>将 <code>tail</code> 指针<strong>向后（向右）移动一位</strong>，使用 <code>(tail + 1) &amp; (elements.length - 1)</code> 计算新位置。</li>
<li>检查是否 <code>head == tail</code>，如果是则调用 <code>doubleCapacity()</code> 扩容。</li>
</ol>
<ul>
<li><p><strong>时间复杂度</strong>： <strong>摊销常数时间 <code>O(1)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">final</span> Object[] es = elements;</span><br><span class="line">    es[tail] = e;</span><br><span class="line">    <span class="comment">// 计算新的 tail 位置： (tail + 1) mod (elements.length)</span></span><br><span class="line">    <span class="keyword">if</span> (head == (tail = inc(tail, es.length)))</span><br><span class="line">        grow(<span class="number">1</span>); <span class="comment">// 最终会调用 doubleCapacity()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算后移一位的索引（循环）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">inc</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> modulus)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (++i &gt;= modulus) i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更高效的位运算写法：</span></span><br><span class="line"><span class="comment">// tail = (tail + 1) &amp; (elements.length - 1)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="6-删除元素-Remove-1"><a href="#6-删除元素-Remove-1" class="headerlink" title="6. 删除元素(Remove)"></a>6. 删除元素(Remove)</h5><ul>
<li><p><strong>头部删除 <code>public E removeFirst()</code> &#x2F; <code>pollFirst()</code> &#x2F; <code>poll()</code> &#x2F; <code>pop()</code></strong>：</p>
<ol>
<li>获取 <code>head</code> 位置的元素。</li>
<li>如果元素为 <code>null</code>（即队列为空），<code>pollFirst()</code> 返回 <code>null</code>，<code>removeFirst()</code> 和 <code>pop()</code> 抛出 <code>NoSuchElementException</code>。</li>
<li>将原 <code>head</code> 位置的元素置为 <code>null</code>（帮助 GC）。</li>
<li>将 <code>head</code> 指针<strong>向后移动一位</strong>。</li>
</ol>
<ul>
<li><p><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> h;</span><br><span class="line">    <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> elementAt(es = elements, h = head);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        es[h] = <span class="literal">null</span>; <span class="comment">// 清空引用</span></span><br><span class="line">        head = inc(h, es.length); <span class="comment">// head 后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;E&gt; E <span class="title function_">elementAt</span><span class="params">(Object[] es, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) es[i]; <span class="comment">// 如果 es[i] 为 null 则返回 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>尾部删除 <code>public E removeLast()</code> &#x2F; <code>pollLast()</code></strong>：</p>
<ol>
<li>将 <code>tail</code> 指针<strong>向前移动一位</strong>，得到要删除的元素位置。</li>
<li>获取该位置的元素。</li>
<li>如果元素为 <code>null</code>（即队列为空），<code>pollLast()</code> 返回 <code>null</code>，<code>removeLast()</code> 抛出 <code>NoSuchElementException</code>。</li>
<li>将该位置的元素置为 <code>null</code>。</li>
<li>更新 <code>tail</code> 为新的位置。</li>
</ol>
<ul>
<li><p><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] es;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> t;</span><br><span class="line">    <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> elementAt(es = elements, t = dec(tail, es.length));</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        es[tail = t] = <span class="literal">null</span>; <span class="comment">// 清空引用并更新 tail</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="7-获取与查看元素-Get-Peek"><a href="#7-获取与查看元素-Get-Peek" class="headerlink" title="7. 获取与查看元素(Get&amp;Peek)"></a>7. 获取与查看元素(Get&amp;Peek)</h5><ul>
<li><strong>获取头部元素 <code>public E getFirst()</code> &#x2F; <code>peekFirst()</code> &#x2F; <code>peek()</code></strong>：<ul>
<li>直接返回 <code>head</code> 位置的元素。</li>
<li>如果队列为空，<code>getFirst()</code> 抛出异常，<code>peekFirst()</code> 和 <code>peek()</code> 返回 <code>null</code>。</li>
<li><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong>。</li>
</ul>
</li>
<li><strong>获取尾部元素 <code>public E getLast()</code> &#x2F; <code>peekLast()</code></strong>：<ul>
<li>计算 <code>tail</code> 的前一个位置 (<code>dec(tail, length)</code>)，返回该位置的元素。</li>
<li>如果队列为空，<code>getLast()</code> 抛出异常，<code>peekLast()</code> 返回 <code>null</code>。</li>
<li><strong>时间复杂度</strong>： <strong><code>O(1)</code></strong>。</li>
</ul>
</li>
</ul>
<p><strong>注意</strong>： <code>ArrayDeque</code> <strong>没有实现 <code>get(int index)</code> 方法</strong>，因为它不是为随机访问设计的。要按索引访问元素，必须通过迭代器遍历。</p>
<hr>
<h5 id="8-查找-Contains"><a href="#8-查找-Contains" class="headerlink" title="8. 查找(Contains)"></a>8. 查找(Contains)</h5><ul>
<li><p><strong><code>public boolean contains(Object o)</code></strong>：</p>
<ol>
<li>如果 <code>o == null</code>，返回 <code>false</code>（因为不允许 <code>null</code> 元素）。</li>
<li>从 <code>head</code> 开始遍历有效元素，直到 <code>tail</code>，使用 <code>o.equals(es[i])</code> 进行比较。</li>
<li>找到返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ol>
<ul>
<li><strong>时间复杂度</strong>： <strong><code>O(n)</code></strong>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="9-遍历方式-2"><a href="#9-遍历方式-2" class="headerlink" title="9. 遍历方式"></a>9. 遍历方式</h5><ul>
<li><strong>迭代器（Iterator）</strong>： <code>ArrayDeque</code> 提供了两种迭代器：<code>Iterator</code>（从头到尾）和<code>DescendingIterator</code>（从尾到头）。这是<strong>推荐</strong>的遍历方式。</li>
<li><strong>for-each循环</strong>： 语法糖，底层是 <code>Iterator</code>。</li>
</ul>
<p><strong>注意</strong>： 和 <code>ArrayList</code> 一样，<strong>严禁在遍历过程中使用 <code>ArrayDeque</code> 的 <code>remove()</code> 等方法修改集合结构</strong>，否则会抛出 <code>ConcurrentModificationException</code>。如需遍历时删除，必须使用 <strong><code>Iterator.remove()</code></strong> 方法。2.4.8 综合对比</p>
<hr>
<h5 id="10-对比"><a href="#10-对比" class="headerlink" title="10. 对比"></a>10. 对比</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>LinkedBlockingQueue</code></th>
<th align="left"><code>ConcurrentLinkedQueue</code></th>
<th align="left"><code>PriorityQueue</code></th>
<th align="left"><code>ArrayBlockingQueue</code></th>
<th align="left"><code>ArrayDeque</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>所在包</strong></td>
<td align="left"><code>java.util.concurrent</code></td>
<td align="left"><code>java.util.concurrent</code></td>
<td align="left"><code>java.util</code></td>
<td align="left"><code>java.util.concurrent</code></td>
<td align="left"><code>java.util</code></td>
</tr>
<tr>
<td align="left"><strong>边界 (Boundedness)</strong></td>
<td align="left"><strong>有界</strong> (可选，默认 <code>Integer.MAX_VALUE</code>)</td>
<td align="left"><strong>无界</strong></td>
<td align="left"><strong>无界</strong></td>
<td align="left"><strong>有界</strong> (构造时必须指定)</td>
<td align="left"><strong>无界</strong> (会自动扩容)</td>
</tr>
<tr>
<td align="left"><strong>数据结构</strong></td>
<td align="left"><strong>链表</strong> (Node)</td>
<td align="left"><strong>链表</strong> (基于CAS的无锁算法)</td>
<td align="left"><strong>数组</strong> (二叉堆)</td>
<td align="left"><strong>数组</strong></td>
<td align="left"><strong>数组</strong> (循环数组)</td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td align="left"><strong>是</strong> (ReentrantLock 两把锁)</td>
<td align="left"><strong>是</strong> (CAS 无锁算法)</td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>是</strong> (ReentrantLock 一把锁)</td>
<td align="left"><strong>否</strong></td>
</tr>
<tr>
<td align="left"><strong>锁机制</strong></td>
<td align="left"><strong>阻塞锁</strong> (<code>put</code>&#x2F;<code>take</code> 会阻塞)</td>
<td align="left"><strong>无锁</strong> (CAS, 非阻塞)</td>
<td align="left">-</td>
<td align="left"><strong>阻塞锁</strong> (<code>put</code>&#x2F;<code>take</code> 会阻塞)</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><strong>排序&#x2F;FIFO</strong></td>
<td align="left"><strong>FIFO</strong></td>
<td align="left"><strong>FIFO</strong></td>
<td align="left"><strong>按优先级</strong> (堆顶出队)</td>
<td align="left"><strong>FIFO</strong></td>
<td align="left"><strong>FIFO&#x2F;LIFO</strong> (双端操作)</td>
</tr>
<tr>
<td align="left"><strong>阻塞操作</strong></td>
<td align="left"><strong>支持</strong> (<code>put()</code>, <code>take()</code>, 限时的 <code>offer()</code>, <code>poll()</code>)</td>
<td align="left"><strong>不支持</strong></td>
<td align="left"><strong>不支持</strong></td>
<td align="left"><strong>支持</strong> (<code>put()</code>, <code>take()</code>, 限时的 <code>offer()</code>, <code>poll()</code>)</td>
<td align="left"><strong>不支持</strong></td>
</tr>
<tr>
<td align="left"><strong>允许 <code>null</code> 元素</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
</tr>
<tr>
<td align="left"><strong>性能特点</strong></td>
<td align="left">高并发下吞吐量较好 (生产消费可并行)</td>
<td align="left"><strong>极高</strong>的并发吞吐量 (无锁)</td>
<td align="left"><strong>O(log n)</strong> 的入队出队</td>
<td align="left">低于 <code>LinkedBlockingQueue</code> (生产消费争用同一把锁)</td>
<td align="left"><strong>极快</strong>的数组操作 (非并发下性能最优)</td>
</tr>
<tr>
<td align="left"><strong>典型用途</strong></td>
<td align="left"><strong>经典的生产者-消费者模型</strong>，线程池任务队列 (<code>ThreadPoolExecutor</code>)</td>
<td align="left"><strong>高并发非阻塞场景</strong>，对吞吐量要求极高的多线程通信</td>
<td align="left"><strong>任务调度</strong>，需要按优先级处理元素的场景</td>
<td align="left"><strong>有界的生产者-消费者模型</strong></td>
<td align="left"><strong>替代<code>Stack</code></strong> (栈)，<strong>单线程任务队列</strong>，<strong>双端操作</strong>场景</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-Map-接口体系"><a href="#3-Map-接口体系" class="headerlink" title="3. Map 接口体系"></a>3. <strong>Map 接口体系</strong></h2><h3 id="3-1-Map"><a href="#3-1-Map" class="headerlink" title="3.1 Map"></a>3.1 Map</h3><h4 id="3-1-1-概述"><a href="#3-1-1-概述" class="headerlink" title="3.1.1 概述"></a>3.1.1 概述</h4><p><code>Map</code> 是Java集合框架的<strong>根接口</strong>之一，用于表示<strong>键值对（Key-Value）</strong> 的集合。每个元素包含一个键（Key）和一个值（Value），键不可重复，每个键最多映射到一个值（即键唯一，值可以重复）。它定义了所有双列集合（如 <code>{&quot;Key1&quot;: &quot;Value1&quot;, &quot;Key2&quot;: &quot;Value2&quot;}</code>）将具备的<strong>通用操作</strong>。</p>
<p><code>Map</code> 接口的常见实现类有：<code>HashMap</code>, <code>TreeMap</code>, <code>LinkedHashMap</code>, 和 <code>Hashtable</code>。</p>
<hr>
<h4 id="3-1-2-核心方法"><a href="#3-1-2-核心方法" class="headerlink" title="3.1.2 核心方法"></a>3.1.2 核心方法</h4><table>
<thead>
<tr>
<th align="left">方法签名</th>
<th align="left">功能描述</th>
<th align="left">注意点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>V put(K key, V value)</code></td>
<td align="left">将指定的键值对添加到映射中。</td>
<td align="left">如果键已存在，则用新值替换旧值，并返回旧值；否则返回 <code>null</code>。</td>
</tr>
<tr>
<td align="left"><code>V get(Object key)</code></td>
<td align="left">返回指定键所映射的值。</td>
<td align="left">如果键不存在，则返回 <code>null</code>。</td>
</tr>
<tr>
<td align="left"><code>V remove(Object key)</code></td>
<td align="left">如果键存在，则从此映射中移除键值对。</td>
<td align="left">返回被移除的值，如果键不存在则返回 <code>null</code>。</td>
</tr>
<tr>
<td align="left"><code>void clear()</code></td>
<td align="left">移除此映射中的所有键值对。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>boolean containsKey(Object key)</code></td>
<td align="left">如果此映射包含指定键，则返回 <code>true</code>。</td>
<td align="left">依赖键的 <code>equals()</code> 方法进行判断。</td>
</tr>
<tr>
<td align="left"><code>boolean containsValue(Object value)</code></td>
<td align="left">如果此映射包含指定值，则返回 <code>true</code>。</td>
<td align="left">依赖值的 <code>equals()</code> 方法进行判断。</td>
</tr>
<tr>
<td align="left"><code>int size()</code></td>
<td align="left">返回此映射中的键值对数量。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>boolean isEmpty()</code></td>
<td align="left">如果此映射不包含任何键值对，则返回 <code>true</code>。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>Set&lt;K&gt; keySet()</code></td>
<td align="left">返回此映射中包含的键的 <code>Set</code> 视图。</td>
<td align="left">键的集合，常用于遍历所有键。</td>
</tr>
<tr>
<td align="left"><code>Collection&lt;V&gt; values()</code></td>
<td align="left">返回此映射中包含的值的 <code>Collection</code> 视图。</td>
<td align="left">值的集合，常用于遍历所有值。</td>
</tr>
<tr>
<td align="left"><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code></td>
<td align="left">返回此映射中包含的键值对的 <code>Set</code> 视图。</td>
<td align="left">键值对的集合，常用于同时遍历键和值。</td>
</tr>
<tr>
<td align="left"><code>void putAll(Map&lt;? extends K, ? extends V&gt; m)</code></td>
<td align="left">将指定映射中的所有键值对复制到此映射中。</td>
<td align="left"><strong>批量操作</strong></td>
</tr>
</tbody></table>
<hr>
<h4 id="3-1-3-遍历方式"><a href="#3-1-3-遍历方式" class="headerlink" title="3.1.3 遍历方式"></a>3.1.3 遍历方式</h4><ol>
<li><p><strong>通过键集合（keySet）遍历</strong>： 先获取所有键，再通过键获取值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ... 添加键值对</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    System.out.println(key + <span class="string">&quot; : &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过键值对集合（entrySet）遍历</strong>： <strong>推荐的高效方式</strong>，直接获取键值对。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot; : &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过值集合（values）遍历</strong>： 仅遍历值，不包含键信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Lambda 表达式 + forEach() 方法（JDK8+）</strong>： 简洁的遍历方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; System.out.println(key + <span class="string">&quot; : &quot;</span> + value));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>迭代器（Iterator）</strong>： 通用方式，可与 <code>keySet()</code> 或 <code>entrySet()</code> 结合使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, Integer&gt; entry = it.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot; : &quot;</span> + value);</span><br><span class="line">    <span class="comment">// it.remove(); // 可以在遍历时安全地移除键值对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="3-2-Map-接口的实现类"><a href="#3-2-Map-接口的实现类" class="headerlink" title="3.2 Map 接口的实现类"></a>3.2 Map 接口的实现类</h3><h4 id="3-2-1-HashMap【-核心掌握-】"><a href="#3-2-1-HashMap【-核心掌握-】" class="headerlink" title="3.2.1 HashMap【!核心掌握!】"></a>3.2.1 HashMap【!核心掌握!】</h4><h5 id="1-核心概念-15"><a href="#1-核心概念-15" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ol>
<li><strong>定义</strong>： <code>HashMap</code> 是 <code>Map</code> 接口基于哈希表的实现。它存储键值对（key-value）映射。</li>
<li><strong>核心特征：</strong><ul>
<li><strong>键不可重复（Keys are unique）</strong>： 不允许重复的键。如果插入的键已存在，新的值会覆盖旧的值。</li>
<li><strong>允许 Null 键和值（Allows null key and values）</strong>： 可以存储一个 <code>null</code> 键和多个 <code>null</code> 值。</li>
<li><strong>非有序（Not Ordered）</strong>： 迭代顺序不保证是插入顺序（与 <code>LinkedHashMap</code> 区别）。</li>
<li><strong>非线程安全（Not Thread-Safe）</strong>： 多线程环境下未经同步直接使用会导致不确定的结果。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 它通过计算键（key）的哈希值（hash code）来决定键值对的存储位置，以实现高速的查找。底层结构是“数组 + 链表 + 红黑树”，通过拉链法解决哈希冲突。</li>
</ol>
<hr>
<h5 id="2-底层数据结构和关键属性-13"><a href="#2-底层数据结构和关键属性-13" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>HashMap</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量 —— 必须是 2 的幂。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 即 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大容量，如果在构造函数中隐式指定了更大的值，</span></span><br><span class="line"><span class="comment">     * 则会使用此值。必须是 2 的幂，且 &lt;= 1&lt;&lt;30。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认负载因子（当构造函数未指定时使用）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将链表转换为红黑树的阈值（当桶中节点数达到此值时）。</span></span><br><span class="line"><span class="comment">     * 该值必须大于 2，并且至少为 8，以便和树节点删除时退化回链表的逻辑保持一致。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将红黑树退化为链表的阈值（当桶中节点数小于此值时，在扩容时发生）。</span></span><br><span class="line"><span class="comment">     * 必须小于 TREEIFY_THRESHOLD，最大不能超过 6，</span></span><br><span class="line"><span class="comment">     * 以便在删除节点时能够正确检测并退化为链表。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许进行树化的最小表容量。否则，如果桶中节点太多，会先选择扩容。</span></span><br><span class="line"><span class="comment">     * 建议至少为 4 * TREEIFY_THRESHOLD，以避免扩容与树化阈值冲突。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表（数组），在第一次使用时初始化，并根据需要调整大小。</span></span><br><span class="line"><span class="comment">     * 长度总是 2 的幂次方。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存 entrySet() 的结果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此映射中包含的键值对数量。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此 HashMap 被结构修改的次数（用于迭代器的快速失败机制）。</span></span><br><span class="line"><span class="comment">     * 结构修改是指更改 HashMap 中的映射数量或以其他方式修改其内部结构（例如，重新哈希）的修改。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一次需要调整大小（扩容）的阈值（容量 * 加载因子）。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表的加载因子。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基本的哈希桶节点，用于大多数普通的键值对。</span></span><br><span class="line"><span class="comment">     * （TreeNode 是其子类，LinkedHashMap 里有 Entry 子类）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;      <span class="comment">// 哈希值</span></span><br><span class="line">        <span class="keyword">final</span> K key;         <span class="comment">// 键</span></span><br><span class="line">        V value;             <span class="comment">// 值</span></span><br><span class="line">        Node&lt;K,V&gt; next;      <span class="comment">// 指向链表下一个节点</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// ... getKey(), getValue(), toString(), equals(), hashCode() 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 红黑树节点（当链表转树时使用）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// 红黑树链接</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// 在删除后需要取消链接</span></span><br><span class="line">        <span class="type">boolean</span> red;</span><br><span class="line">        TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... 一系列红黑树相关的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>table</code>： 这是 <code>HashMap</code> 的心脏，一个 <code>Node</code> 类型的数组。每个数组位置被称为一个“桶”（bucket）或“槽”（bin）。所有元素都分布在这个数组中。</li>
<li><code>Node</code>： 是链表节点结构，包含 <code>hash</code>, <code>key</code>, <code>value</code>, <code>next</code> 四个属性。<code>next</code> 用于解决哈希冲突，形成链表。</li>
<li><code>TreeNode</code>： 是红黑树节点结构。当链表过长时，会转换为红黑树，以提升查询效率。</li>
<li><code>size</code>： 记录当前映射中键值对的数量。</li>
<li><code>loadFactor</code>： <strong>加载因子</strong>。这是一个权衡时间和空间成本的因子，决定了哈希表在多少满时进行扩容。</li>
<li><code>threshold</code>： <strong>扩容阈值</strong>。其值为 <code>(capacity * loadFactor)</code>。当 <code>size</code> 超过 <code>threshold</code> 时，就会触发扩容（resize）。</li>
<li><code>DEFAULT_INITIAL_CAPACITY</code> 和 <code>DEFAULT_LOAD_FACTOR</code>： 默认的初始容量（16）和加载因子（0.75）。这是时间和空间的经典折衷。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-12"><a href="#3-构造方法与初始化-12" class="headerlink" title="3. 构造方法与初始化"></a><strong>3. 构造方法与初始化</strong></h5><p><code>HashMap</code> 提供了四种构造方式：</p>
<ol>
<li><p><strong><code>public HashMap()</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 将 <code>loadFactor</code> 设置为 <code>DEFAULT_LOAD_FACTOR</code> (0.75f)。<code>table</code> 数组此时并未初始化。</li>
<li><strong>特点</strong>： 懒加载。在第一次调用 <code>put()</code> 方法时，才会将 <code>table</code> 真正初始化为默认容量（16）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个空的 &#123;<span class="doctag">@code</span> HashMap&#125;，</span></span><br><span class="line"><span class="comment"> * 默认初始容量为 16，默认负载因子为 0.75。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// 其他字段使用默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public HashMap(int initialCapacity)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 调用 <code>this(initialCapacity, DEFAULT_LOAD_FACTOR)</code>。</li>
<li><strong>特点</strong>： 允许用户指定初始容量。<code>HashMap</code> 内部会将其规范化为大于等于该值的最小 2 的幂次方（如传入 10，实际初始容量为 16）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个空的 &#123;<span class="doctag">@code</span> HashMap&#125;，并指定初始容量，</span></span><br><span class="line"><span class="comment"> * 默认负载因子为 0.75。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@apiNote</span></span></span><br><span class="line"><span class="comment"> * 如果要创建一个能够容纳预期映射数量的 &#123;<span class="doctag">@code</span> HashMap&#125;，</span></span><br><span class="line"><span class="comment"> * 请使用 &#123;<span class="doctag">@link</span> #newHashMap(int) newHashMap&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity 初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果初始容量为负数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public HashMap(int initialCapacity, float loadFactor)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 对参数进行合法性校验。计算并设置初始的 <code>threshold</code>（注意，此时 <code>threshold</code> 是下一次扩容的大小，而不是 <code>capacity * loadFactor</code>，在第一次 <code>put</code> 时会用这个 <code>threshold</code> 来初始化 <code>table</code> 的容量）。</li>
<li><strong>特点</strong>： 允许用户完全自定义初始容量和加载因子。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个空的 &#123;<span class="doctag">@code</span> HashMap&#125;，并指定初始容量和负载因子。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@apiNote</span></span></span><br><span class="line"><span class="comment"> * 如果要创建一个能够容纳预期映射数量的 &#123;<span class="doctag">@code</span> HashMap&#125;，</span></span><br><span class="line"><span class="comment"> * 请使用 &#123;<span class="doctag">@link</span> #newHashMap(int) newHashMap&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity 初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      负载因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException 如果初始容量为负数，</span></span><br><span class="line"><span class="comment"> *         或者负载因子小于等于 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个大于等于指定目标容量的 2 的幂大小。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="comment">// 减 1 的目的是 如果 cap 本身已经是 2 的幂，cap - 1 的二进制会把低位全部置 1。</span></span><br><span class="line">    <span class="comment">// 				如果 cap 本身已经是 2 的幂，cap - 1 的二进制会把低位全部置 1。</span></span><br><span class="line">    <span class="comment">// Integer.numberOfLeadingZeros(cap - 1) 返回 cap-1 的二进制表示里，前导 0 的个数</span></span><br><span class="line">    <span class="comment">// -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1) 无符号右移 k 位（&gt;&gt;&gt;）之后，得到的是 低位有 (32-k) 个 1 的掩码</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public HashMap(Map&lt;? extends K, ? extends V&gt; m)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 设置 <code>loadFactor</code> 为默认值，然后调用 <code>putMapEntries(m, false)</code> 方法将传入映射的所有元素放入本映射中。</li>
<li><strong>特点</strong>： 用一个已有映射来构造。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个新的 &#123;<span class="doctag">@code</span> HashMap&#125;，其内容与指定的 &#123;<span class="doctag">@code</span> Map&#125; 相同。</span></span><br><span class="line"><span class="comment"> * 新创建的 &#123;<span class="doctag">@code</span> HashMap&#125; 默认负载因子为 0.75，</span></span><br><span class="line"><span class="comment"> * 初始容量足以容纳指定 &#123;<span class="doctag">@code</span> Map&#125; 中的所有映射。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   m 要拷贝映射数据的 Map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  NullPointerException 如果传入的 Map 为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 Map.putAll 方法和 Map 构造函数所需的逻辑。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m 要拷贝的 map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 如果是在构造 HashMap 时调用，则为 false；</span></span><br><span class="line"><span class="comment"> *              否则为 true（传递给 afterNodeInsertion 方法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// 当前哈希表还没初始化</span></span><br><span class="line">            <span class="comment">// 期望容量</span></span><br><span class="line">          	<span class="type">double</span> <span class="variable">dt</span> <span class="operator">=</span> Math.ceil(s / (<span class="type">double</span>)loadFactor);</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((dt &lt; (<span class="type">double</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)dt : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 由于链表桶的限制，不能一次性扩容到位，</span></span><br><span class="line">            <span class="comment">// 但可以通过现在多次翻倍来减少后续的扩容成本</span></span><br><span class="line">            <span class="keyword">while</span> (s &gt; threshold &amp;&amp; table.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将传入 Map 的所有键值对插入到当前 HashMap 中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="4-哈希计算与数组下标定位"><a href="#4-哈希计算与数组下标定位" class="headerlink" title="4. 哈希计算与数组下标定位"></a><strong>4. 哈希计算与数组下标定位</strong></h5><p>在插入或查找一个元素时，首先要确定键值对应该放在 <code>table</code> 数组的哪个位置。</p>
<ol>
<li><p><strong>计算哈希值（hash(Object key)）</strong>：<br>为了防止质量较差的哈希函数（<code>key.hashCode()</code>）导致严重的哈希冲突，<code>HashMap</code> 会用自己的 <code>hash()</code> 方法对原始哈希码进行二次处理（扰动函数）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 <code>key</code> 为 <code>null</code>，哈希值为 <code>0</code>，这就是 <code>HashMap</code> 支持 <code>null</code> 键的原因。</li>
<li>如果 <code>key</code> 不为 <code>null</code>，则计算 <code>key.hashCode()</code>，并将该值的高 16 位与低 16 位进行异或操作。这样做是为了将高位的特征也融入到低位中，从而减少哈希冲突。</li>
</ul>
</li>
<li><p><strong>计算数组下标</strong>：<br>得到扰动后的哈希值 <code>hash</code> 后，通过与操作 <code>(table.length - 1) &amp; hash</code> 来计算下标。、</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (n - <span class="number">1</span>) &amp; hash; <span class="comment">// n 是 table 的长度</span></span><br></pre></td></tr></table></figure>

<ul>
<li>因为 <code>n</code>（数组长度）永远是 2 的幂次方，所以 <code>n-1</code> 的二进制形式永远是全 <code>1</code>（例如，16-1&#x3D;15，二进制为 <code>1111</code>）。</li>
<li>这个操作实质上是 <code>hash % n</code>，但位运算的效率远高于取模运算。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="5-添加-更新元素-Put"><a href="#5-添加-更新元素-Put" class="headerlink" title="5. 添加&#x2F;更新元素(Put)"></a><strong>5. 添加&#x2F;更新元素(Put)</strong></h5><p><code>public V put(K key, V value)</code> 方法是核心：</p>
<ul>
<li><p><strong>源码流程</strong>：</p>
<ol>
<li>调用 <code>hash(key)</code> 计算键的哈希值。</li>
<li>如果 <code>table</code> 为空或长度为 0，则调用 <code>resize()</code> 进行初始化（懒加载）。</li>
<li>计算下标 <code>i = (n - 1) &amp; hash</code>。</li>
<li><strong>检查桶是否为空</strong><ul>
<li><strong>情况 A</strong>：桶为空 → 直接新建节点放进去。</li>
<li><strong>情况 B</strong>：桶非空 → 存在冲突，继续处理：<ul>
<li>判断桶首节点：<ul>
<li>如果 <strong>hash 相同 + key 相等</strong> → 找到已有节点，覆盖其值。</li>
<li>如果桶是 <strong>红黑树</strong> → 调用 <code>putTreeVal</code> 插入。</li>
<li>否则就是 <strong>链表</strong>：<ul>
<li>遍历链表：<ul>
<li>如果找到相同 key → 覆盖值。</li>
<li>如果没找到 → 在链尾插入新节点。</li>
<li>如果链表长度 ≥ 8 → 转换为红黑树（<code>treeifyBin</code>）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>如果覆盖已有节点值</strong><ul>
<li>直接返回旧值，不做扩容。</li>
</ul>
</li>
<li><strong>如果是新插入的节点</strong><ul>
<li><code>modCount++</code>（结构修改次数，用于快速失败机制）</li>
<li><code>size++</code></li>
<li>如果 <code>size &gt; threshold</code> → 调用 <code>resize()</code> 扩容。</li>
</ul>
</li>
<li><strong>执行钩子方法</strong><ul>
<li><code>afterNodeAccess(e)</code>（节点访问后的回调，LinkedHashMap 会用）</li>
<li><code>afterNodeInsertion(evict)</code>（节点插入后的回调）</li>
</ul>
</li>
<li><strong>返回结果</strong><ul>
<li>如果是覆盖 → 返回旧值</li>
<li>如果是新增 → 返回 <code>null</code></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的值与此映射中的指定键关联。</span></span><br><span class="line"><span class="comment"> * 如果映射之前为该键存在映射，则旧值被替换。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 要关联指定值的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要与指定键关联的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 与 &#123;<span class="doctag">@code</span> key&#125; 先前关联的值，或者如果没有映射则返回 &#123;<span class="doctag">@code</span> null&#125;。</span></span><br><span class="line"><span class="comment"> *         （返回 &#123;<span class="doctag">@code</span> null&#125; 也可能表示该映射先前将 &#123;<span class="doctag">@code</span> null&#125; 作为值与该键关联。）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 Map.put 及相关方法的内部逻辑。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 键的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要放入的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 如果为 true，则不要更改已有值（即 putIfAbsent 的行为）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 如果为 false，表处于创建（resize）模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 先前的值，或者如果没有则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// HashMap 的 数组（桶数组），每个位置存一个链表或红黑树的头节点</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    <span class="comment">// 指向当前桶的第一个节点</span></span><br><span class="line">    Node&lt;K,V&gt; p; </span><br><span class="line">    <span class="comment">// n当前tab的长度，i桶的索引位置</span></span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果 table 为空，初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 计算桶索引</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 桶为空：直接插入新节点</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 桶非空 → 处理碰撞</span></span><br><span class="line">        <span class="comment">// 在查找/遍历时，表示 可能已经存在的目标节点。</span></span><br><span class="line">        Node&lt;K,V&gt; e; </span><br><span class="line">        <span class="comment">// 临时变量，存放节点的 key</span></span><br><span class="line">        K k;</span><br><span class="line">        <span class="comment">// 比较桶首节点：hash相同 + key相同 → 找到目标节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 找到已有节点，把它赋给 e</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果桶是红黑树，调用树的插入逻辑</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 否则就是链表：遍历</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 到达链表尾部 → 插入新节点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                  	<span class="comment">// 如果链长超过阈值 8 → 转红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遍历中途发现 key 已存在 → 退出</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到了已有节点 e → 处理 value 替换</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">        	<span class="comment">// 钩子</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入新节点成功 → 更新 size，判断是否需要扩容</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 钩子</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>时间复杂度</strong>：</p>
<ul>
<li><strong>平均复杂度</strong>：O(1)</li>
<li><strong>最坏复杂度</strong>：O(n) （极端情况下所有 key 落在同一桶，并且未转树）</li>
</ul>
</li>
</ul>
<hr>
<h5 id="6-扩容机制-Resize"><a href="#6-扩容机制-Resize" class="headerlink" title="6. 扩容机制 (Resize)"></a><strong>6. 扩容机制 (Resize)</strong></h5><p>这是 <code>HashMap</code> 性能的关键。当元素数量超过 <code>threshold</code> 时，容量会扩大为原来的 <strong>2 倍</strong>。</p>
<ul>
<li><p><strong>源码流程（<code>resize()</code>）</strong>：</p>
<ol>
<li>获取旧表信息。</li>
<li>计算新容量和阈值。<ul>
<li><strong>情况 A：旧容量 &gt; 0</strong><ul>
<li>如果达到最大值 <code>MAXIMUM_CAPACITY</code> → 不再扩容，<code>threshold = Integer.MAX_VALUE</code></li>
<li>否则：新容量 &#x3D; <code>oldCap &lt;&lt; 1</code>（扩容为 2 倍）<br> 新阈值 &#x3D; <code>oldThr &lt;&lt; 1</code>（翻倍）</li>
</ul>
</li>
<li><strong>情况 B：旧容量 &#x3D; 0，但 oldThr &gt; 0</strong><ul>
<li>说明是第一次初始化 → <code>newCap = oldThr</code></li>
</ul>
</li>
<li><strong>情况 C：oldCap &#x3D; 0 且 oldThr &#x3D; 0</strong><ul>
<li>使用默认容量 <code>DEFAULT_INITIAL_CAPACITY</code>（16）和默认阈值（16×0.75&#x3D;12）</li>
</ul>
</li>
<li>最后根据 <code>loadFactor</code> 重新计算 <code>threshold</code></li>
</ul>
</li>
<li>创建新数组。</li>
<li>数据迁移<ul>
<li>如果旧表非空，需要把元素迁移到新表中，遍历每个桶。</li>
<li>单节点：直接放到新表位置</li>
<li>红黑树节点：调用 <code>TreeNode.split(...)</code>，把树拆分为 <strong>低位链表&#x2F;树</strong> 和 <strong>高位链表&#x2F;树</strong>。</li>
<li>链表节点：<ul>
<li>遍历链表，按 <code>(e.hash &amp; oldCap)</code> 分成 <strong>两条链表</strong>：</li>
<li><strong>低位链表（loHead&#x2F;loTail）</strong> → 放到新表索引 <code>j</code></li>
<li><strong>高位链表（hiHead&#x2F;hiTail）</strong> → 放到新表索引 <code>j + oldCap</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化或将哈希表扩容为原来的两倍。</span></span><br><span class="line"><span class="comment"> * - 如果 table 为空，则会按照 threshold 里保存的初始容量目标来分配；</span></span><br><span class="line"><span class="comment"> * - 否则，由于我们使用的是 2 的幂次方扩容，原数组中每个 bin（桶）的元素要么留在原位置，</span></span><br><span class="line"><span class="comment"> *   要么移动到新表中索引位置 + 原容量（oldCap）的地方。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新的哈希表数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 原哈希表数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 原数组容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 扩容阈值（容量 * 负载因子）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 旧容量左移一位（即 2 倍扩容）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 阈值翻倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// threshold 被用作初始化容量</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// oldThr == 0 表示使用默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新计算阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 迁移旧数据</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历旧数组的每一个桶</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 桶非空，释放旧桶引用，帮助 GC</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 情况 1：桶里只有一个节点（既不是链表也不是树）</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 直接放到新数组的新位置（通过新容量计算索引）</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 情况 2：桶里是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 调用红黑树的 split 方法，拆成低位树和高位树</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 情况 3：桶里是链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 保持原有节点顺序</span></span><br><span class="line">                    <span class="comment">// 低位链表头尾</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 高位链表头尾</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                 	<span class="comment">// 遍历当前桶的链表</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 根据 e.hash &amp; oldCap 判断该节点应该留在原位置还是去新位置</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 低位链表：索引不变，仍然放在 j</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 高位链表：索引 = j + oldCap</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 把低位链表挂到新数组 j 位置</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 把高位链表挂到新数组 j+oldCap 位置</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>最佳实践</strong>： 如果能预估数据量，应使用 <code>HashMap(int initialCapacity)</code> 构造器并传入 <code>(预计元素个数 / 0.75f) + 1</code> 来指定初始容量，这样可以避免或减少扩容次数。</p>
</li>
</ul>
<hr>
<h5 id="7-获取元素-Get"><a href="#7-获取元素-Get" class="headerlink" title="7. 获取元素(Get)"></a><strong>7. 获取元素(Get)</strong></h5><p><code>public V get(Object key)</code>：</p>
<ul>
<li><p><strong>源码流程</strong>：</p>
<ol>
<li>判断<code>table</code>是否为空并计算索引。</li>
<li>如果桶不为空：<ul>
<li>如果桶中第一个节点的 <code>key</code> 就匹配，直接返回。</li>
<li>如果第一个节点不匹配，且是树节点，则调用树的查找方法 <code>getTreeNode()</code>。</li>
<li>如果是链表，则遍历链表查找。</li>
</ul>
</li>
<li>都没找到则返回 <code>null</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定键所映射的值，</span></span><br><span class="line"><span class="comment"> * 如果此映射不包含该键的映射，则返回 &#123;<span class="doctag">@code</span> null&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;更正式地讲，如果此映射包含一个从键 &#123;<span class="doctag">@code</span> k&#125; 映射到值 &#123;<span class="doctag">@code</span> v&#125; 的映射，</span></span><br><span class="line"><span class="comment"> * 并且满足 &#123;<span class="doctag">@code</span> (key==null ? k==null : key.equals(k))&#125;，</span></span><br><span class="line"><span class="comment"> * 那么此方法返回 &#123;<span class="doctag">@code</span> v&#125;；否则返回 &#123;<span class="doctag">@code</span> null&#125;。</span></span><br><span class="line"><span class="comment"> * （最多只会存在一个这样的映射。）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;返回值为 &#123;<span class="doctag">@code</span> null&#125; 并&lt;i&gt;不一定&lt;/i&gt;表示此映射中没有该键的映射；</span></span><br><span class="line"><span class="comment"> * 也有可能是该映射显式地将该键映射到了 &#123;<span class="doctag">@code</span> null&#125;。</span></span><br><span class="line"><span class="comment"> * 可以使用 &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; 方法来区分这两种情况。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现了 Map.get 及其相关方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 节点，如果不存在则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n, hash; K k;</span><br><span class="line">    <span class="comment">// 判断table是否为空，计算索引</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; (hash = hash(key))]) != <span class="literal">null</span>) &#123;</span><br><span class="line">  		<span class="comment">// 判断头节点      </span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp;</span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是树节点调用树方法</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 如果是链表遍历链表</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>时间复杂度</strong>： 与 <code>put</code> 类似，理想 O(1)，最坏 O(n)。</p>
</li>
</ul>
<hr>
<h5 id="8-删除元素-Remove"><a href="#8-删除元素-Remove" class="headerlink" title="8. 删除元素(Remove)"></a><strong>8. 删除元素(Remove)</strong></h5><p><code>public V remove(Object key)</code>：</p>
<ul>
<li><p><strong>源码流程</strong>：</p>
<ol>
<li>先根据 <code>key</code> 找到对应的节点（过程类似 <code>get</code>）。</li>
<li>如果找到，则执行删除。<ul>
<li>如果是链表节点，修改前后节点的指针。</li>
<li>如果是树节点，调用树的删除方法。</li>
</ul>
</li>
<li><code>modCount++</code>，<code>size--</code>。</li>
<li>在删除树节点后，如果树变得太小（节点数 <code>&lt;= UNTREEIFY_THRESHOLD (6)</code>），则会调用 <code>untreeify()</code> 方法将红黑树退化为链表。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除指定 key 对应的映射关系（如果存在）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  key 要被移除的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回 key 之前对应的 value，</span></span><br><span class="line"><span class="comment"> *         如果不存在映射则返回 null。</span></span><br><span class="line"><span class="comment"> *         （注意：返回 null 也可能表示该 key 对应的 value 本身就是 null）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 调用 removeNode 进行实际删除，若删除成功则返回被删除的 value，否则返回 null</span></span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 Map.remove 以及相关方法的底层逻辑。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key 的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 要删除的键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 仅当 matchValue = true 时才会用来比较，其他情况忽略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue 是否要求匹配指定 value（true 表示 key 和 value 同时匹配才删除）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable 是否允许在删除节点时进行结构调整（比如红黑树节点删除需要旋转）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 被删除的节点，如果没有找到则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="comment">// 哈希表数组</span></span><br><span class="line">    Node&lt;K,V&gt; p;     <span class="comment">// 当前桶的首节点</span></span><br><span class="line">    <span class="type">int</span> n, index;    <span class="comment">// n = table 长度，index = 桶下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// table 不为空，长度大于 0，并且定位到的桶内有元素</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; </span><br><span class="line">        K k; V v;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情况 1：桶的首节点就是目标节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情况 2：目标节点在链表或树的后续节点中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) </span><br><span class="line">                <span class="comment">// 在红黑树节点中查找</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 普通链表遍历查找目标节点</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e; <span class="comment">// 更新前驱节点，便于删除操作</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到目标节点，且需要时 value 也匹配成功</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 情况 A：删除树节点</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 情况 B：删除的是桶的首节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 情况 C：删除链表中的非首节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改计数器，触发 fail-fast 机制</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">// 元素数量减一</span></span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">// 钩子方法</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到目标节点，返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>时间复杂度</strong>： 与 <code>get</code> 类似。</p>
</li>
</ul>
<hr>
<h5 id="9-遍历方式-3"><a href="#9-遍历方式-3" class="headerlink" title="9. 遍历方式"></a><strong>9. 遍历方式</strong></h5><p><code>HashMap</code> 的遍历通常通过三种视图（View）进行：</p>
<ol>
<li><code>Set&lt;K&gt; keySet()</code>： 返回所有键的集合。</li>
<li><code>Collection&lt;V&gt; values()</code>： 返回所有值的集合。</li>
<li><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code>： 返回所有键值对的集合（<strong>最常用</strong>）。</li>
</ol>
<p><strong>注意</strong>：</p>
<ul>
<li><strong>性能</strong>： 遍历 <code>HashMap</code> 的时间复杂度是 O(n)，与 <code>capacity</code>（数组长度）无关，只与 <code>size</code>（实际元素个数）有关。因为它会依次访问每一个非空桶。</li>
<li><strong>快速失败机制</strong>： 使用迭代器遍历时，如果创建迭代器后映射被结构性地修改（非 <code>Iterator.remove</code> 方法），则会抛出 <code>ConcurrentModificationException</code>。</li>
<li><strong>最佳实践</strong>： 遍历键值对时，使用 <code>entrySet</code> 比先遍历 <code>keySet</code> 再调用 <code>get(key)</code> 效率高得多，因为后者相当于遍历了两次。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐的遍历方式</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 低效的遍历方式（不推荐）</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key); <span class="comment">// 这里又进行了一次哈希计算和查找！</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-2-LinkedHashMap【核心掌握】"><a href="#3-2-2-LinkedHashMap【核心掌握】" class="headerlink" title="3.2.2 LinkedHashMap【核心掌握】"></a>3.2.2 LinkedHashMap【核心掌握】</h4><h5 id="1-核心概念-16"><a href="#1-核心概念-16" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ul>
<li><strong>定义</strong>： <code>LinkedHashMap</code> 是 <code>HashMap</code> 的一个子类，它继承了 <code>HashMap</code> 的哈希表核心功能，并通过维护一个贯穿所有条目的<strong>双向链表</strong>，额外提供了可预测的迭代顺序。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>有序（Ordered）</strong>： 迭代顺序可以是 <strong>插入顺序（Insertion-order）</strong> 或 <strong>访问顺序（Access-order）</strong>。这是它与 <code>HashMap</code> 最根本的区别。</li>
<li><strong>键不可重复（Keys are unique）</strong>： 继承自 <code>HashMap</code>。</li>
<li><strong>允许 Null 键和值（Allows null key and values）</strong>： 继承自 <code>HashMap</code>。</li>
<li><strong>性能</strong>： 迭代性能优于 <code>HashMap</code>，因为它只需遍历链表而非整个桶数组。增删改查操作的时间复杂度与 <code>HashMap</code> 相同，仅为维护链表付出了少量常数级别的额外开销。</li>
<li><strong>非线程安全（Not Thread-Safe）</strong>： 继承自 <code>HashMap</code>。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>： 在 <code>HashMap</code> 的“数组+链表&#x2F;红黑树”结构之上，为每一个键值对节点（<code>Entry</code>）增加了<strong>前驱（<code>before</code>）</strong> 和<strong>后继（<code>after</code>）</strong> 两个指针，将所有 <code>Entry</code> 节点链接成一个双向链表。这个链表定义了迭代的顺序。</li>
</ul>
<hr>
<h5 id="2-底层数据结构和关键属性-14"><a href="#2-底层数据结构和关键属性-14" class="headerlink" title="2. 底层数据结构和关键属性"></a><strong>2. 底层数据结构和关键属性</strong></h5><p>打开 <code>LinkedHashMap</code> 的源码（以OpenJDK为例）：打开 <code>LinkedHashMap</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap.Node 的子类，为 LinkedHashMap 的条目添加了 before 和 after 指针。</span></span><br><span class="line"><span class="comment">     * 这构成了双向链表。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after; <span class="comment">// 新增的双向链表指针</span></span><br><span class="line">        Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双向链表的头节点（最老的节点，或最久未被访问的节点）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双向链表的尾节点（最新的节点，或最近被访问的节点）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代顺序的模式。</span></span><br><span class="line"><span class="comment">     * true: 访问顺序 (access-order) -&gt; 非常适合构建 LRU 缓存。</span></span><br><span class="line"><span class="comment">     * false: 插入顺序 (insertion-order) -&gt; 默认模式。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Entry&lt;K,V&gt;</code>： 核心节点结构。它继承了 <code>HashMap.Node</code>，并增加了 <code>before</code> 和 <code>after</code> 两个指针，从而具备了成为双向链表节点的能力。</li>
<li><code>head</code> 和 <code>tail</code>： 分别指向这个双向链表的头部和尾部。<code>head</code> 是链表中最“老”的节点（最先插入或最久未被访问），<code>tail</code> 是最“新”的节点（最后插入或最近被访问）。</li>
<li><code>accessOrder</code>： <strong>决定迭代顺序模式的最终属性</strong>。此属性在构造时设定，之后不可更改。<ul>
<li><code>false</code>（默认）： <strong>插入顺序（Insertion-order）</strong>。迭代顺序就是元素被插入映射的顺序。</li>
<li><code>true</code>： <strong>访问顺序（Access-order）</strong>。迭代顺序是元素被访问的顺序。任何一次 <code>get</code> 或 <code>put</code> 操作都会将被访问的条目移动到链表尾部（成为最新的）。这使得 <code>LinkedHashMap</code> 非常适合实现 <strong>LRU（Least Recently Used）缓存</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-13"><a href="#3-构造方法与初始化-13" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>LinkedHashMap</code> 提供了五种构造方式，其逻辑与 <code>HashMap</code> 类似，主要增加了对 <code>accessOrder</code> 参数的设置。</p>
<ol>
<li><p><strong><code>public LinkedHashMap()</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 调用父类 <code>HashMap</code> 的无参构造器，并将 <code>accessOrder</code> 设为 <code>false</code>。</li>
<li><strong>特点</strong>： 创建一个默认初始容量（16）和加载因子（0.75）的，按<strong>插入顺序</strong>排序的 <code>LinkedHashMap</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public LinkedHashMap(int initialCapacity)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 调用父类构造器，并将 <code>accessOrder</code> 设为 <code>false</code>。</li>
<li><strong>特点</strong>： 创建一个指定初始容量和默认加载因子（0.75）的，按<strong>插入顺序</strong>排序的 <code>LinkedHashMap</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public LinkedHashMap(int initialCapacity, float loadFactor)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 调用父类构造器，并将 <code>accessOrder</code> 设为 <code>false</code>。</li>
<li><strong>特点</strong>： 创建一个指定初始容量和加载因子的，按<strong>插入顺序</strong>排序的 <code>LinkedHashMap</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 调用父类无参构造器，将 <code>accessOrder</code> 设为 <code>false</code>，然后调用 <code>putMapEntries(m, false)</code> 将传入映射的所有元素放入本映射中。</li>
<li><strong>特点</strong>： 用一个已有映射来构造一个按<strong>插入顺序</strong>排序的 <code>LinkedHashMap</code>。新映射的迭代顺序由原映射的迭代器决定。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    accessOrder = <span class="literal">false</span>;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)</code></strong></p>
<ul>
<li><strong>源码逻辑</strong>： 调用父类构造器设置容量和因子，并设置本类的 <code>accessOrder</code> 属性。</li>
<li><strong>特点</strong>： 这是唯一可以创建<strong>访问顺序</strong>模式的构造器。<strong>这是实现 LRU 缓存的关键</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                     <span class="type">float</span> loadFactor,</span></span><br><span class="line"><span class="params">                     <span class="type">boolean</span> accessOrder)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.accessOrder = accessOrder; <span class="comment">// 可以设置为 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="4-核心机制：维护链表的钩子方法"><a href="#4-核心机制：维护链表的钩子方法" class="headerlink" title="4. 核心机制：维护链表的钩子方法"></a>4. 核心机制：维护链表的钩子方法</h5><p><code>HashMap</code> 在设计时，预留了三个空的“钩子”方法（<code>afterNodeAccess</code>, <code>afterNodeInsertion</code>, <code>afterNodeRemoval</code>），专门供 <code>LinkedHashMap</code> 重写，以便在哈希表操作后维护双向链表的结构。</p>
<ol>
<li><p><strong><code>afterNodeInsertion(boolean evict)</code> - 插入后可能删除最老节点</strong></p>
<ul>
<li><strong>调用时机</strong>： 在 <code>HashMap</code> 的 <code>put</code> 或 <code>putAll</code> 方法成功插入一个新节点后被调用。</li>
<li><strong><code>LinkedHashMap</code> 中的逻辑</strong>： 检查是否应该移除链表中最老的节点（即 <code>head</code>）。<code>removeEldestEntry(first)</code> 方法默认返回 <code>false</code>。<strong>如果重写该方法并返回 <code>true</code>，则会删除 <code>head</code> 节点</strong>。这是实现固定大小 LRU 缓存的精髓所在。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>); <span class="comment">// 调用HashMap的remove方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认实现，总是返回false（永不删除最老节点）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>afterNodeAccess(Node&lt;K,V&gt; e)</code> - 访问后调整顺序</strong></p>
<ul>
<li><strong>调用时机</strong>： 在 <code>HashMap</code> 的 <code>get</code>, <code>replace</code> (成功时)，<code>put</code> (更新现有值时) 等方法访问到一个现有节点后被调用。<strong>注意：<code>put</code> 插入新值时不会调用。</strong></li>
<li><strong><code>LinkedHashMap</code> 中的逻辑</strong>： 如果 <code>accessOrder</code> 为 <code>true</code>（访问顺序模式），则将当前被访问的节点 <code>e</code> 移动到双向链表的尾部，使其成为“最新”的节点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123; <span class="comment">// 如果是访问模式且当前节点不是尾节点</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// ... 复杂的链表指针调整，将p节点从原位置取出 ...</span></span><br><span class="line">        <span class="comment">// ... 并将p节点链接到链表尾部 ...</span></span><br><span class="line">        tail = p; <span class="comment">// 新的尾节点是p</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>afterNodeRemoval(Node&lt;K,V&gt; e)</code> - 删除后维护链表</strong></p>
<ul>
<li><strong>调用时机</strong>： 在 <code>HashMap</code> 的 <code>remove</code> 方法成功删除一个节点后被调用。</li>
<li><strong><code>LinkedHashMap</code> 中的逻辑</strong>： 将节点 <code>e</code> 从双向链表中安全地移除，修补其前后节点的指针。这是纯粹的链表操作，保证删除节点后链表不断开。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="literal">null</span>; <span class="comment">// 将待删除节点p的指针置空</span></span><br><span class="line">    <span class="comment">// 修复其前驱和后继节点的指针</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="5-获取元素-Get-1"><a href="#5-获取元素-Get-1" class="headerlink" title="5. 获取元素(Get)"></a>5. 获取元素(Get)</h5><p><code>public V get(Object key)</code>：</p>
<ul>
<li><strong>源码逻辑</strong>： 它重写了 <code>HashMap</code> 的 <code>get</code> 方法。<ol>
<li>调用父类 <code>HashMap</code> 的 <code>getNode</code> 方法通过哈希查找节点。</li>
<li>如果找到了节点且 <code>accessOrder</code> 为 <code>true</code>，则会调用 <code>afterNodeAccess(e)</code> 将被访问的节点移动到链表尾部。</li>
<li>返回找到的值。</li>
</ol>
</li>
<li><strong>与 <code>HashMap</code> 的区别</strong>： 增加了在访问顺序模式下维护链表顺序的逻辑。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>) <span class="comment">// 调用HashMap的getNode</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder) <span class="comment">// 如果是访问顺序模式</span></span><br><span class="line">        afterNodeAccess(e); <span class="comment">// 将被访问的节点e移到链表尾部</span></span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="6-实现LRU缓存示例"><a href="#6-实现LRU缓存示例" class="headerlink" title="6. 实现LRU缓存示例"></a>6. 实现LRU缓存示例</h5><p>利用 <code>accessOrder</code> 模式和重写 <code>removeEldestEntry</code> 方法，可以轻松实现一个固定大小的 LRU 缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ENTRIES</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 缓存最大容量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="literal">true</span>); <span class="comment">// 关键：accessOrder设为true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写此方法，当映射数量大于缓存容量时，返回true，触发删除最老节点（最近最少使用）。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eldest 链表中最老的节点（头节点）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the eldest entry should be removed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">LRUCache&lt;String, String&gt; cache = <span class="keyword">new</span> <span class="title class_">LRUCache</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">cache.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;One&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;Two&quot;</span>);</span><br><span class="line">cache.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;Three&quot;</span>);</span><br><span class="line">cache.get(<span class="string">&quot;1&quot;</span>); <span class="comment">// 访问&quot;1&quot;，使其成为“最新”的</span></span><br><span class="line">cache.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;Four&quot;</span>); <span class="comment">// 此时容量已满，添加新元素会触发删除最老的节点（即&quot;2&quot;）</span></span><br><span class="line"></span><br><span class="line">System.out.println(cache); <span class="comment">// 输出: &#123;3=Three, 1=One, 4=Four&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="7-遍历方式-1"><a href="#7-遍历方式-1" class="headerlink" title="7. 遍历方式"></a>7. 遍历方式</h5><p><code>LinkedHashMap</code> 没有重写 <code>put</code>, <code>remove</code> 等核心数据操作逻辑，但它重写了<strong>迭代器</strong>的生成方法。</p>
<ul>
<li><strong><code>keySet().iterator()</code>, <code>values().iterator()</code>, <code>entrySet().iterator()</code></strong>： 这些方法返回的迭代器，其遍历顺序是双向链表的顺序（插入顺序或访问顺序），而不是像 <code>HashMap</code> 那样遍历整个桶数组。</li>
<li><strong>性能</strong>： 迭代 <code>LinkedHashMap</code> 的时间复杂度是 <strong>O(n)</strong>，其中 <code>n</code> 是 <code>size</code>。它只需要简单地遍历双向链表，因此<strong>迭代性能只与实际元素数量有关，与容量（capacity）无关</strong>。这在元素很多但散列良好的情况下，迭代性能远优于需要遍历整个空桶数组的 <code>HashMap</code>。</li>
<li><strong>快速失败机制</strong>： 与 <code>HashMap</code> 和 <code>ArrayList</code> 相同。</li>
</ul>
<hr>
<h4 id="3-2-3-TreeMap【核心掌握】"><a href="#3-2-3-TreeMap【核心掌握】" class="headerlink" title="3.2.3 TreeMap【核心掌握】"></a>3.2.3 TreeMap【核心掌握】</h4><h5 id="1-核心概念-17"><a href="#1-核心概念-17" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ul>
<li><strong>定义</strong>：<br><code>TreeMap</code> 是 <code>Map</code> 接口的一个基于<strong>红黑树（Red-Black tree）</strong> 的实现。它保证了所有键值对按照键的<strong>自然顺序</strong>或<strong>构造时提供的 <code>Comparator</code></strong> 进行排序。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>有序（Ordered）</strong>： 迭代顺序由键的排序顺序决定，而不是插入顺序。</li>
<li><strong>键不可重复（Keys are unique）</strong>： 继承自 <code>Map</code> 接口。</li>
<li><strong>不允许 Null 键（Does not allow null keys）</strong>： 如果使用自然排序，且键为 <code>null</code>，会抛出 <code>NullPointerException</code>。但允许 <code>null</code> 值。</li>
<li><strong>性能</strong>： 查找、插入、删除操作的时间复杂度为 <strong>O(log n)</strong>，优于线性结构，但比 <code>HashMap</code> 慢。</li>
<li><strong>非线程安全（Not Thread-Safe）</strong>： 需外部同步或使用 <code>Collections.synchronizedSortedMap</code> 包装。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>：<br>使用红黑树（一种自平衡的二叉搜索树）来存储键值对。每个节点包含键、值、颜色标志（红&#x2F;黑）以及左右子节点引用。红黑树通过旋转和变色保持平衡，确保最坏情况下基本操作仍为对数时间复杂度。</li>
</ul>
<hr>
<h5 id="2-底层数据结构和关键属性-15"><a href="#2-底层数据结构和关键属性-15" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>TreeMap</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableMap</span>&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于排序的比较器，若为 null 则使用键的自然顺序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 红黑树的根节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 树中键值对的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构修改次数（用于迭代器的快速失败机制）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 红黑树节点结构</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; left;</span><br><span class="line">        Entry&lt;K,V&gt; right;</span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK; <span class="comment">// 默认黑色</span></span><br><span class="line"></span><br><span class="line">        Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>comparator</code>： 决定键的排序方式。若为 <code>null</code>，则键必须实现 <code>Comparable</code> 接口。</li>
<li><code>root</code>： 红黑树的根节点。</li>
<li><code>Entry</code>： 红黑树节点，包含键、值、左右子节点、父节点和颜色标志。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-14"><a href="#3-构造方法与初始化-14" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>TreeMap</code> 提供四种构造方式：</p>
<ol>
<li><strong><code>public TreeMap()</code></strong><br>使用键的<strong>自然顺序</strong>排序，键必须实现 <code>Comparable</code> 接口。</li>
<li><strong><code>public TreeMap(Comparator&lt;? super K&gt; comparator)</code></strong><br>使用指定的比较器进行排序。</li>
<li><strong><code>public TreeMap(Map&lt;? extends K, ? extends V&gt; m)</code></strong><br>使用原有 Map 的内容，并按键的自然顺序排序。</li>
<li><strong><code>public TreeMap(SortedMap&lt;K, ? extends V&gt; m)</code></strong><br>使用原有 <code>SortedMap</code> 的内容和排序规则。</li>
</ol>
<hr>
<h5 id="4-添加-更新元素（Put）"><a href="#4-添加-更新元素（Put）" class="headerlink" title="4. 添加&#x2F;更新元素（Put）"></a>4. 添加&#x2F;更新元素（Put）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">        compare(key, key); <span class="comment">// 类型检查（可能抛出 ClassCastException）</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value); <span class="comment">// 键已存在，覆盖值</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用自然顺序</span></span><br><span class="line">        <span class="comment">// ... 类似逻辑，使用 key.compareTo(t.key)</span></span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e); <span class="comment">// 红黑树平衡调整</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>流程</strong>：<ol>
<li>若树为空，直接创建根节点。</li>
<li>否则从根开始遍历，根据比较器或自然顺序找到插入位置。</li>
<li>若找到相同键，覆盖值并返回旧值。</li>
<li>插入新节点后调用 <code>fixAfterInsertion(e)</code> 进行红黑树平衡调整（旋转+变色）。</li>
</ol>
</li>
</ul>
<hr>
<h5 id="5-获取元素（Get）"><a href="#5-获取元素（Get）" class="headerlink" title="5. 获取元素（Get）"></a>5. 获取元素（Get）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> (p == <span class="literal">null</span> ? <span class="literal">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="comment">// 使用自然顺序遍历查找</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>：O(log n)</li>
<li>通过比较器或自然顺序递归查找键所在的节点。</li>
</ul>
<hr>
<h5 id="6-删除元素（Remove）"><a href="#6-删除元素（Remove）" class="headerlink" title="6. 删除元素（Remove）"></a>6. 删除元素（Remove）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> p.value;</span><br><span class="line">    deleteEntry(p); <span class="comment">// 删除节点并平衡红黑树</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>deleteEntry(p)</code> 方法负责：<ul>
<li>处理三种删除情况（无子节点、一个子节点、两个子节点）。</li>
<li>调用 <code>fixAfterDeletion(p)</code> 进行红黑树平衡调整。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="7-遍历方式-2"><a href="#7-遍历方式-2" class="headerlink" title="7. 遍历方式"></a>7. 遍历方式</h5><p><code>TreeMap</code> 提供了三种视图的迭代器，其遍历顺序为<strong>键的排序顺序</strong>：</p>
<ol>
<li><code>keySet().iterator()</code></li>
<li><code>values().iterator()</code></li>
<li><code>entrySet().iterator()</code></li>
</ol>
<p><strong>中序遍历（In-order traversal）</strong> 保证键从小到大输出。</p>
<hr>
<h5 id="8-特有方法（来自-NavigableMap）"><a href="#8-特有方法（来自-NavigableMap）" class="headerlink" title="8. 特有方法（来自 NavigableMap）"></a>8. 特有方法（来自 <code>NavigableMap</code>）</h5><p><code>TreeMap</code> 实现了 <code>NavigableMap</code>，提供了丰富的导航方法：</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>K firstKey()</code></td>
<td align="left">返回最小的键</td>
</tr>
<tr>
<td align="left"><code>K lastKey()</code></td>
<td align="left">返回最大的键</td>
</tr>
<tr>
<td align="left"><code>Map.Entry&lt;K,V&gt; ceilingEntry(K key)</code></td>
<td align="left">返回 ≥ 给定键的最小键值对</td>
</tr>
<tr>
<td align="left"><code>Map.Entry&lt;K,V&gt; floorEntry(K key)</code></td>
<td align="left">返回 ≤ 给定键的最大键值对</td>
</tr>
<tr>
<td align="left"><code>Map.Entry&lt;K,V&gt; higherEntry(K key)</code></td>
<td align="left">返回 &gt; 给定键的最小键值对</td>
</tr>
<tr>
<td align="left"><code>Map.Entry&lt;K,V&gt; lowerEntry(K key)</code></td>
<td align="left">返回 &lt; 给定键的最大键值对</td>
</tr>
<tr>
<td align="left"><code>NavigableMap&lt;K,V&gt; descendingMap()</code></td>
<td align="left">返回逆序视图</td>
</tr>
</tbody></table>
<hr>
<h5 id="9-使用场景与最佳实践"><a href="#9-使用场景与最佳实践" class="headerlink" title="9. 使用场景与最佳实践"></a>9. 使用场景与最佳实践</h5><ul>
<li><strong>适用场景</strong>：<ul>
<li>需要键有序遍历的场景。</li>
<li>需要范围查询（如找最接近的键）的场景。</li>
<li>键的类型没有好的哈希函数，但可实现 <code>Comparable</code> 或提供 <code>Comparator</code>。</li>
</ul>
</li>
<li><strong>不适用场景</strong>：<ul>
<li>对插入和查找性能要求极高且无需排序的场景（应使用 <code>HashMap</code>）。</li>
</ul>
</li>
<li><strong>最佳实践</strong>：<ul>
<li>若键为自定义类，应正确实现 <code>Comparable</code> 或提供 <code>Comparator</code>。</li>
<li>避免在迭代过程中结构性修改（否则触发 <code>ConcurrentModificationException</code>）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-4-Hashtable【了解】"><a href="#3-2-4-Hashtable【了解】" class="headerlink" title="3.2.4 Hashtable【了解】"></a>3.2.4 Hashtable【了解】</h4><h5 id="1-核心概念-18"><a href="#1-核心概念-18" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ul>
<li><strong>定义</strong>：<br><code>Hashtable</code> 是 Java 集合框架中最早实现的键值对存储结构之一，实现了 <code>Map</code> 接口。它是一个<strong>线程安全</strong>的哈希表，所有公共方法都使用 <code>synchronized</code> 关键字修饰，保证多线程环境下的安全性。</li>
<li><strong>核心特性</strong>：<ul>
<li><strong>线程安全（Thread-Safe）</strong>：所有方法都是同步的，适合多线程环境。</li>
<li><strong>键和值均不允许为 null</strong>：<code>Hashtable</code> 不允许键或值为 <code>null</code>，否则会抛出 <code>NullPointerException</code>。</li>
<li><strong>键不可重复</strong>：与 <code>HashMap</code> 相同，键是唯一的。</li>
<li><strong>无序</strong>：迭代顺序不保证与插入顺序一致。</li>
<li><strong>性能较低</strong>：由于同步开销，单线程环境下性能不如 <code>HashMap</code>。</li>
</ul>
</li>
<li><strong>核心实现原理</strong>：<br>基于“数组 + 链表”的结构实现，使用拉链法解决哈希冲突。与 <code>HashMap</code> 类似，但没有引入红黑树优化。</li>
</ul>
<hr>
<h5 id="2-底层数据结构和关键属性-16"><a href="#2-底层数据结构和关键属性-16" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>Hashtable</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hashtable</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Dictionary</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table; <span class="comment">// 哈希桶数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> count;          <span class="comment">// 元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> threshold;                <span class="comment">// 扩容阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> loadFactor;             <span class="comment">// 负载因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">// 结构修改次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表节点结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">Entry</span><span class="params">(<span class="type">int</span> hash, K key, V value, Entry&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>table</code>：存储链表的数组。</li>
<li><code>count</code>：当前元素数量。</li>
<li><code>threshold</code>：扩容阈值，等于 <code>容量 * 负载因子</code>。</li>
<li><code>loadFactor</code>：负载因子，默认 0.75。</li>
<li><code>modCount</code>：用于快速失败机制。</li>
</ul>
<hr>
<h5 id="3-构造方法与初始化-15"><a href="#3-构造方法与初始化-15" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>Hashtable</code> 提供四种构造方法：</p>
<ol>
<li><strong><code>public Hashtable()</code></strong><br>默认初始容量为 11，负载因子为 0.75。</li>
<li><strong><code>public Hashtable(int initialCapacity)</code></strong><br>指定初始容量，负载因子为 0.75。</li>
<li><strong><code>public Hashtable(int initialCapacity, float loadFactor)</code></strong><br>完全自定义初始容量和负载因子。</li>
<li><strong><code>public Hashtable(Map&lt;? extends K, ? extends V&gt; t)</code></strong><br>使用已有 Map 初始化，容量为 <code>Math.max(2*t.size(), 11)</code>。</li>
</ol>
<hr>
<h5 id="4-哈希计算与下标定位"><a href="#4-哈希计算与下标定位" class="headerlink" title="4. 哈希计算与下标定位"></a>4. 哈希计算与下标定位</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode(); <span class="comment">// 不允许 null key</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % table.length;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>key.hashCode()</code> 计算哈希值。</li>
<li>通过取模运算定位桶下标（<code>%</code> 运算，非位运算）。</li>
</ul>
<hr>
<h5 id="5-添加-更新元素（Put）"><a href="#5-添加-更新元素（Put）" class="headerlink" title="5. 添加&#x2F;更新元素（Put）"></a>5. 添加&#x2F;更新元素（Put）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="comment">// 遍历链表，若找到相同 key 则覆盖</span></span><br><span class="line">    <span class="comment">// 否则在链表头部插入新节点</span></span><br><span class="line">    <span class="comment">// 若 size &gt;= threshold，则调用 rehash() 扩容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>线程安全</strong>：方法使用 <code>synchronized</code> 修饰。</li>
<li><strong>不允许 null 值</strong>：会抛出 <code>NullPointerException</code>。</li>
<li><strong>扩容机制</strong>：当 <code>count &gt;= threshold</code> 时，调用 <code>rehash()</code> 方法扩容为 <code>2 * oldCapacity + 1</code>。</li>
</ul>
<hr>
<h5 id="6-获取元素（Get）"><a href="#6-获取元素（Get）" class="headerlink" title="6. 获取元素（Get）"></a>6. 获取元素（Get）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历链表查找对应键的值。</li>
<li>若未找到则返回 <code>null</code>。</li>
</ul>
<hr>
<h5 id="7-删除元素（Remove）"><a href="#7-删除元素（Remove）" class="headerlink" title="7. 删除元素（Remove）"></a>7. 删除元素（Remove）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="comment">// 遍历链表，找到并移除节点</span></span><br><span class="line">    <span class="comment">// 修改 modCount 和 count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除节点并维护链表结构。</li>
<li>同步方法，线程安全。</li>
</ul>
<hr>
<h5 id="8-遍历方式-3"><a href="#8-遍历方式-3" class="headerlink" title="8. 遍历方式"></a>8. 遍历方式</h5><p>与 <code>HashMap</code> 类似，支持三种视图：</p>
<ul>
<li><code>Enumeration&lt;K&gt; keys()</code>：返回键的枚举。</li>
<li><code>Enumeration&lt;V&gt; elements()</code>：返回值的枚举。</li>
<li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：返回键值对的集合。</li>
</ul>
<blockquote>
<p>⚠️ 注意：<code>Hashtable</code> 的迭代器不是快速失败的（没有 <code>modCount</code> 检查），但枚举器是。</p>
</blockquote>
<hr>
<h4 id="3-2-5-ConcurrentHashMap【核心掌握】"><a href="#3-2-5-ConcurrentHashMap【核心掌握】" class="headerlink" title="3.2.5 ConcurrentHashMap【核心掌握】"></a>3.2.5 ConcurrentHashMap【核心掌握】</h4><h5 id="1-核心概念-19"><a href="#1-核心概念-19" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><ul>
<li><p><strong>定义</strong>：</p>
<p><code>ConcurrentHashMap</code> 是 <code>java.util.concurrent</code> 包下的一个线程安全的哈希表实现，它实现了 <code>ConcurrentMap</code> 接口。它通过细粒度的锁机制（JDK 7 的分段锁和 JDK 8 的 CAS + synchronized）来实现高并发下的高性能访问，是 <code>Hashtable</code> 的高性能替代品。</p>
</li>
<li><p><strong>核心特征</strong>：</p>
<ul>
<li><strong>线程安全（Thread-Safe）</strong>：支持高并发的读和写操作，不同段或桶上的操作可以并行进行。</li>
<li><strong>高性能</strong>：读操作通常不需要加锁，写操作使用锁分段或CAS优化，性能远高于 <code>Hashtable</code>。</li>
<li><strong>允许 Null 值</strong>：<strong>不允许 null 键或 null 值</strong>，否则会抛出 <code>NullPointerException</code>。</li>
<li><strong>键不可重复</strong>：与 <code>HashMap</code> 一致，键是唯一的。</li>
<li><strong>无序</strong>：迭代顺序不保证与插入顺序一致。</li>
<li><strong>弱一致性迭代器</strong>：迭代器反映的是创建迭代器时或之前的映射状态，不保证反映之后的修改。</li>
</ul>
</li>
<li><p><strong>核心实现原理（JDK8+）</strong></p>
<p>在 JDK 8 及之后，<code>ConcurrentHashMap</code> 放弃了分段锁（Segment），改为采用与 <code>HashMap</code> 类似的 <strong>“数组 + 链表 + 红黑树”</strong> 结构，但通过以下技术实现并发控制：</p>
<ol>
<li><strong>CAS (Compare-And-Swap)</strong>：用于无锁化的初始化、节点插入等操作。</li>
<li><strong>synchronized</strong>：对单个数组桶（链表头节点&#x2F;树根节点）进行同步，锁粒度更细。</li>
<li><strong>volatile</strong>：保证变量的可见性（如 <code>table</code>, <code>nextTable</code>, <code>sizeCtl</code> 等）。</li>
</ol>
</li>
</ul>
<hr>
<h5 id="2-底层数据结构和关键属性-17"><a href="#2-底层数据结构和关键属性-17" class="headerlink" title="2. 底层数据结构和关键属性"></a>2. 底层数据结构和关键属性</h5><p>打开 <code>concurrentHashMap</code> 的源码（以OpenJDK为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K,V&gt;, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表数组，延迟初始化，长度总是 2 的幂</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容时使用的下一张哈希表（非空时表示正在扩容）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制表初始化和扩容的状态标志。</span></span><br><span class="line">    <span class="comment">// 负数：-1 表示正在初始化，-N 表示有 N-1 个线程正在扩容。</span></span><br><span class="line">    <span class="comment">// 正数：0 表示未初始化，&gt;0 表示下一次扩容的阈值（容量 * 负载因子）。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认初始容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认并发级别（为了兼容旧版API，实际不再使用分段锁）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认负载因子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表转红黑树的阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 红黑树退化为链表的阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最小树化容量（表长度达到此值才允许树化）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本哈希节点类，用于链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">        <span class="comment">// ... 构造方法和其他实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 红黑树节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;</span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;</span><br><span class="line">        <span class="type">boolean</span> red;</span><br><span class="line">        <span class="comment">// ... 树相关方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  forwarding 节点（在扩容时使用，指向 nextTable）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">        ForwardingNode(Node&lt;K,V&gt;[] nextTable) &#123;</span><br><span class="line">            <span class="built_in">super</span>(MOVED, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="built_in">this</span>.nextTable = nextTable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... 查找方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-构造方法与初始化-16"><a href="#3-构造方法与初始化-16" class="headerlink" title="3. 构造方法与初始化"></a>3. 构造方法与初始化</h5><p><code>ConcurrentHashMap</code> 提供多种构造方式：</p>
<ol>
<li><strong><code>public ConcurrentHashMap()</code></strong><ul>
<li>创建一个默认初始容量（16）、默认负载因子（0.75）和默认并发级别（16）的空映射。</li>
</ul>
</li>
<li><strong><code>public ConcurrentHashMap(int initialCapacity)</code></strong><ul>
<li>创建指定初始容量的空映射。</li>
</ul>
</li>
<li><strong><code>public ConcurrentHashMap(int initialCapacity, float loadFactor)</code></strong><ul>
<li>创建指定初始容量和负载因子的空映射。</li>
</ul>
</li>
<li><strong><code>public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)</code></strong><ul>
<li>指定初始容量、负载因子和并发级别（ hint，JDK8 中主要用于兼容性）。</li>
</ul>
</li>
<li><strong><code>public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</code></strong><ul>
<li>用给定映射中的键值对初始化。</li>
</ul>
</li>
</ol>
<p>初始化表（<code>table</code>）是<strong>延迟</strong>进行的，在第一次插入（<code>put</code>）时通过 CAS 操作完成。</p>
<hr>
<h5 id="4-添加-更新元素"><a href="#4-添加-更新元素" class="headerlink" title="4. 添加&#x2F;更新元素"></a>4. 添加&#x2F;更新元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable(); <span class="comment">// 延迟初始化表</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 桶为空，CAS 尝试插入新节点</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) <span class="comment">// MOVED = -1，表示正在扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f); <span class="comment">// 协助扩容</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123; <span class="comment">// 锁住桶头节点</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123; <span class="comment">// 再次验证防止被修改</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 普通链表节点</span></span><br><span class="line">                        <span class="comment">// ... 遍历链表，更新或插入节点</span></span><br><span class="line">                        <span class="comment">// 若链表长度达到 TREEIFY_THRESHOLD，调用 treeifyBin 尝试树化</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 红黑树节点</span></span><br><span class="line">                        <span class="comment">// ... 调用红黑树的插入方法</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i); <span class="comment">// 尝试树化</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount); <span class="comment">// 更新计数，并检查是否需要扩容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-获取元素"><a href="#5-获取元素" class="headerlink" title="5. 获取元素"></a>5. 获取元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val; <span class="comment">// 直接命中头节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) <span class="comment">// 特殊节点（树节点或ForwardingNode）</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123; <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>读操作通常无锁</strong>：通过 <code>volatile</code> 变量 <code>val</code> 和 <code>next</code> 保证可见性。</li>
<li>遇到特殊节点（如 <code>ForwardingNode</code>）时，会调用其 <code>find</code> 方法到新表中查找。</li>
</ul>
<hr>
<h5 id="6-删除元素"><a href="#6-删除元素" class="headerlink" title="6. 删除元素"></a>6. 删除元素</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> replaceNode(key, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">            (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">validated</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// ... 验证桶头节点未变</span></span><br><span class="line">                <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 链表</span></span><br><span class="line">                    <span class="comment">// ... 遍历查找并删除</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 树</span></span><br><span class="line">                    <span class="comment">// ... 树中查找并删除</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (validated) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 若树太小，退化为链表</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="7-扩容机制"><a href="#7-扩容机制" class="headerlink" title="7. 扩容机制"></a>7. 扩容机制</h5><p>当元素数量达到阈值（<code>容量 * 负载因子</code>）时，会触发扩容。扩容由多个线程协同完成：</p>
<ol>
<li><strong>生成新表</strong>：新表大小为原表的2倍。</li>
<li><strong>分配任务</strong>：线程每次处理一个桶（链表&#x2F;树），处理完成后将该桶标记为 <code>ForwardingNode</code>。</li>
<li><strong>协助扩容</strong>：其他线程在执行操作时若发现桶为 <code>ForwardingNode</code>，则会协助进行数据迁移。</li>
<li><strong>迁移完成</strong>：所有桶迁移完成后，用 <code>nextTable</code> 替换 <code>table</code>。</li>
</ol>
<hr>
<h5 id="8-遍历方式-4"><a href="#8-遍历方式-4" class="headerlink" title="8. 遍历方式"></a>8. 遍历方式</h5><p>提供三种视图的迭代器，均为<strong>弱一致性</strong>（weakly consistent）：</p>
<ul>
<li><code>KeySetView&lt;K,V&gt; keySet()</code></li>
<li><code>ValuesView&lt;K,V&gt; values()</code></li>
<li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code></li>
</ul>
<p>弱一致性指迭代器反映的是创建迭代器时或之前的映射状态，但不保证反映迭代过程中的修改，且不会抛出 <code>ConcurrentModificationException</code>。</p>
<hr>
<h4 id="3-2-6-综合对比"><a href="#3-2-6-综合对比" class="headerlink" title="3.2.6 综合对比"></a>3.2.6 综合对比</h4><h5 id="1-核心特性对比表"><a href="#1-核心特性对比表" class="headerlink" title="1. 核心特性对比表"></a>1. 核心特性对比表</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>HashMap</code></th>
<th align="left"><code>LinkedHashMap</code></th>
<th align="left"><code>TreeMap</code></th>
<th align="left"><code>Hashtable</code></th>
<th align="left"><code>ConcurrentHashMap</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>底层数据结构</strong></td>
<td align="left"><strong>数组 + 链表&#x2F;红黑树 (JDK8+)</strong></td>
<td align="left"><strong>数组 + 链表&#x2F;红黑树 + 双向链表</strong></td>
<td align="left"><strong>红黑树</strong></td>
<td align="left"><strong>数组 + 链表</strong></td>
<td align="left"><strong>数组 + 链表&#x2F;红黑树 (JDK8+)</strong></td>
</tr>
<tr>
<td align="left"><strong>所在包</strong></td>
<td align="left"><code>java.util</code></td>
<td align="left"><code>java.util</code></td>
<td align="left"><code>java.util</code></td>
<td align="left"><code>java.util</code></td>
<td align="left"><strong><code>java.util.concurrent</code></strong></td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>是</strong> (方法大多用 <code>synchronized</code> 修饰)</td>
<td align="left"><strong>是</strong> (通过 CAS + <code>synchronized</code> 实现 (JDK8+))</td>
</tr>
<tr>
<td align="left"><strong>锁机制</strong></td>
<td align="left">无</td>
<td align="left">无</td>
<td align="left">无</td>
<td align="left">悲观锁 (<code>synchronized</code> 方法级)</td>
<td align="left"><strong>分段锁 (JDK7) &#x2F; 桶级别锁 (CAS + <code>synchronized</code>, JDK8+)</strong></td>
</tr>
<tr>
<td align="left"><strong>是否允许 Null Key&#x2F;Value</strong></td>
<td align="left"><strong>是</strong> (允许多个Null Value和1个Null Key)</td>
<td align="left"><strong>是</strong> (允许多个Null Value和1个Null Key)</td>
<td align="left"><strong>否</strong> (Key不能为null，Value可为null，取决于Comparator)</td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>否</strong></td>
</tr>
<tr>
<td align="left"><strong>元素顺序</strong></td>
<td align="left"><strong>无序</strong> (遍历顺序不确定)</td>
<td align="left"><strong>有序</strong> (默认按<strong>插入顺序</strong>，可配置为<strong>访问顺序</strong>)</td>
<td align="left"><strong>有序</strong> (按Key的<strong>自然顺序</strong>或<strong>Comparator排序</strong>)</td>
<td align="left"><strong>无序</strong></td>
<td align="left"><strong>无序</strong></td>
</tr>
<tr>
<td align="left"><strong>get&#x2F;put&#x2F;remove 性能</strong></td>
<td align="left"><strong>O(1)</strong> (平均，哈希函数良好)</td>
<td align="left"><strong>O(1)</strong> (平均)</td>
<td align="left"><strong>O(log n)</strong></td>
<td align="left"><strong>O(1)</strong> (平均)</td>
<td align="left"><strong>O(1)</strong> (平均)</td>
</tr>
<tr>
<td align="left"><strong>迭代性能</strong></td>
<td align="left">与容量相关，较好</td>
<td align="left"><strong>极快</strong> (直接遍历双向链表，与容量无关)</td>
<td align="left"><strong>O(n)</strong> (中序遍历)</td>
<td align="left">与容量相关，较好</td>
<td align="left">与容量相关，较好 (弱一致性迭代器)</td>
</tr>
<tr>
<td align="left"><strong>内存占用</strong></td>
<td align="left">较小</td>
<td align="left"><strong>较大</strong> (额外维护双向链表)</td>
<td align="left"><strong>较大</strong> (存储树结构开销)</td>
<td align="left">类似<code>HashMap</code></td>
<td align="left"><strong>较高</strong> (为实现并发控制的结构复杂度)</td>
</tr>
<tr>
<td align="left"><strong>迭代器</strong></td>
<td align="left"><strong>快速失败 (Fail-Fast)</strong></td>
<td align="left"><strong>快速失败 (Fail-Fast)</strong></td>
<td align="left"><strong>快速失败 (Fail-Fast)</strong></td>
<td align="left"><strong>快速失败 (Fail-Fast)</strong> (但已过时)</td>
<td align="left"><strong>弱一致性 (Weakly Consistent)</strong> (不会抛出<code>CME</code>)</td>
</tr>
<tr>
<td align="left"><strong>扩容机制</strong></td>
<td align="left"><strong>初始容量16，扩容为2的幂次 (2n)</strong></td>
<td align="left"><strong>同 <code>HashMap</code></strong></td>
<td align="left"><strong>无扩容</strong> (通过红黑树自平衡)</td>
<td align="left"><strong>初始容量11，扩容为 2n+1</strong></td>
<td align="left"><strong>类似 <code>HashMap</code>，但实现更复杂以支持并发</strong></td>
</tr>
</tbody></table>
<h5 id="2-如何选择"><a href="#2-如何选择" class="headerlink" title="2. 如何选择"></a>2. 如何选择</h5><p>选择的原则主要基于：<strong>性能需求</strong>、<strong>线程安全需求</strong>、<strong>顺序需求</strong> 和 <strong>对 Null 值的支持</strong>。</p>
<p><strong><code>HashMap</code> (单线程默认首选)</strong></p>
<ul>
<li><strong>场景</strong>：<strong>绝大多数单线程情况下的默认选择</strong>。</li>
<li><strong>原因</strong>：<ul>
<li><strong>性能最佳</strong> (平均O(1)时间复杂度)。</li>
<li><strong>通用性强</strong>。</li>
</ul>
</li>
<li><strong>注意</strong>：非线程安全。遍历顺序不可预测。</li>
</ul>
<p><strong><code>LinkedHashMap</code> (需要保持插入或访问顺序)</strong></p>
<ul>
<li><strong>场景</strong>：需要<strong>保持元素的插入顺序</strong>，或实现<strong>LRU (最近最少使用) 缓存</strong>。</li>
<li><strong>原因</strong>：<ul>
<li><strong>提供了可预测的迭代顺序</strong>。</li>
<li><strong>性能接近 <code>HashMap</code></strong>。</li>
</ul>
</li>
<li><strong>典型用例</strong>：缓存、需要按顺序处理或展示数据的场景。</li>
</ul>
<p><strong><code>TreeMap</code> (需要按Key排序)</strong></p>
<ul>
<li><strong>场景</strong>：需要让<strong>元素按照Key的自然顺序或者自定义顺序进行排序</strong>。</li>
<li><strong>原因</strong>：<ul>
<li><strong>Key有序</strong>，支持<strong>范围查找</strong>和<strong>顺序访问</strong>。</li>
<li>实现了 <code>NavigableMap</code> 接口，提供了一系列导航方法 (如 <code>ceilingKey</code>, <code>floorEntry</code>)。</li>
</ul>
</li>
<li><strong>缺点</strong>：平均性能为 O(log n)，比哈希实现的Map慢。</li>
</ul>
<p><strong><code>Hashtable</code> (历史遗留，不推荐使用)</strong></p>
<ul>
<li><strong>结论</strong>：<strong>基本上不应该在新的代码中使用</strong>。</li>
<li><strong>原因</strong>：<ul>
<li><strong>性能开销</strong>：粗粒度的<code>synchronized</code>方法级锁导致性能极其低下。</li>
<li><strong>有更好的替代品</strong>：<strong><code>ConcurrentHashMap</code></strong> 在任何需要线程安全的场景下都是更优的选择。</li>
<li><strong>API设计过时</strong>：是遗留类，不属于集合框架。</li>
</ul>
</li>
</ul>
<p><strong><code>ConcurrentHashMap</code> (高并发场景首选)</strong></p>
<ul>
<li><strong>场景</strong>：<strong>高并发</strong>环境下需要线程安全的Map。</li>
<li><strong>典型用例</strong>：<strong>多线程共享的缓存</strong>、<strong>并发计算</strong>等。</li>
<li><strong>选择原因</strong>：<ul>
<li><strong>高并发高性能</strong>：采用更细粒度的锁机制 (JDK8+是桶级别锁)，并发读基本无阻塞，并发写性能远高于 <code>Hashtable</code> 和 <code>Collections.synchronizedMap</code>。</li>
<li><strong>线程安全</strong>：提供线程安全的保证。</li>
<li><strong>迭代安全</strong>：迭代器是弱一致性的，不会抛出 <code>ConcurrentModificationException</code>。</li>
</ul>
</li>
<li><strong>注意</strong>：不允许 <code>null</code> 键或值。</li>
</ul>
<hr>
<h2 id="4-工具类：Collections"><a href="#4-工具类：Collections" class="headerlink" title="4. 工具类：Collections"></a>4. 工具类：Collections</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><ul>
<li><p><strong>定义</strong>：</p>
<p><code>Collections</code> <strong>提供了一系列静态方法，用于对集合（Collection）进行操作、包装和管理</strong>。这些方法极大地增强了 Java 集合框架的功能，提供了很多通用算法和数据操作的实现，使得开发者无需重复造轮子。</p>
</li>
<li><p><strong>核心特点</strong>：</p>
<ol>
<li><strong>静态工具类</strong>：它所有的方法都是静态的，不需要创建 <code>Collections</code> 的实例，直接通过类名调用即可（例如：<code>Collections.sort(list)</code>）。</li>
<li><strong>操作对象</strong>：主要操作 <code>Collection</code> 接口下的对象，最常用的是 <code>List</code>，也有些方法用于 <code>Set</code>、<code>Map</code> 等。</li>
<li><strong>包含算法</strong>：排序、查找、替换、同步控制、不可变集合创建等。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-2-主要功能与方法分类"><a href="#4-2-主要功能与方法分类" class="headerlink" title="4.2 主要功能与方法分类"></a>4.2 主要功能与方法分类</h3><h4 id="4-2-1-排序和查找（Sorting-and-Searching）"><a href="#4-2-1-排序和查找（Sorting-and-Searching）" class="headerlink" title="4.2.1 排序和查找（Sorting and Searching）"></a>4.2.1 排序和查找（Sorting and Searching）</h4><p>这是 <code>Collections</code> 最常用的功能之一。</p>
<ul>
<li><strong><code>sort(List&lt;T&gt; list)</code></strong>:<ul>
<li><strong>功能</strong>：根据元素的自然顺序（<code>Comparable</code> 接口）对指定列表进行升序排序。</li>
<li><strong>要求</strong>：列表中的所有元素都必须实现 <code>Comparable</code> 接口。</li>
</ul>
</li>
<li><strong><code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code></strong>:<ul>
<li><strong>功能</strong>：根据指定的比较器 <code>Comparator</code> 对列表进行排序。这提供了更大的灵活性，可以自定义排序规则。</li>
</ul>
</li>
<li><strong><code>binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)</code></strong>:<ul>
<li><strong>功能</strong>：使用二分查找算法在<strong>已排序的</strong>列表中搜索指定元素。</li>
<li><strong>重要</strong>：<strong>列表必须是有序的（通常是升序）</strong>，否则结果不可预测。</li>
<li><strong>返回值</strong>：如果找到则返回索引；否则返回一个负值。</li>
</ul>
</li>
<li><strong><code>reverse(List&lt;?&gt; list)</code></strong>:<ul>
<li><strong>功能</strong>：反转指定列表中元素的顺序。</li>
</ul>
</li>
<li><strong><code>shuffle(List&lt;?&gt; list)</code></strong>:<ul>
<li><strong>功能</strong>：使用默认的随机源随机打乱列表元素的顺序（洗牌）。</li>
</ul>
</li>
</ul>
<p><strong>示例代码：排序和查找</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        numbers.add(<span class="number">5</span>);</span><br><span class="line">        numbers.add(<span class="number">1</span>);</span><br><span class="line">        numbers.add(<span class="number">8</span>);</span><br><span class="line">        numbers.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;原始列表: &quot;</span> + numbers); <span class="comment">// [5, 1, 8, 3]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 自然排序（升序）</span></span><br><span class="line">        Collections.sort(numbers);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后: &quot;</span> + numbers); <span class="comment">// [1, 3, 5, 8]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 自定义排序（降序）</span></span><br><span class="line">        Collections.sort(numbers, Comparator.reverseOrder());</span><br><span class="line">        <span class="comment">// 或者使用 Lambda: Collections.sort(numbers, (a, b) -&gt; b - a);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;降序后: &quot;</span> + numbers); <span class="comment">// [8, 5, 3, 1]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 二分查找（必须先排序！这里先重新排序成升序）</span></span><br><span class="line">        Collections.sort(numbers); <span class="comment">// 恢复为 [1, 3, 5, 8]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Collections.binarySearch(numbers, <span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;元素 5 的索引是: &quot;</span> + index); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 反转</span></span><br><span class="line">        Collections.reverse(numbers);</span><br><span class="line">        System.out.println(<span class="string">&quot;反转后: &quot;</span> + numbers); <span class="comment">// [8, 5, 3, 1]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 洗牌</span></span><br><span class="line">        Collections.shuffle(numbers);</span><br><span class="line">        System.out.println(<span class="string">&quot;洗牌后: &quot;</span> + numbers); <span class="comment">// 顺序随机，如 [3, 8, 1, 5]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-2-同步控制（Synchronization-Wrappers）"><a href="#4-2-2-同步控制（Synchronization-Wrappers）" class="headerlink" title="4.2.2 同步控制（Synchronization Wrappers）"></a>4.2.2 同步控制（Synchronization Wrappers）</h4><p>标准的集合实现（如 <code>ArrayList</code>, <code>HashSet</code>, <code>HashMap</code>）是<strong>非线程安全</strong>的。<code>Collections</code> 提供了创建线程安全版本的方法，这些方法返回一个同步（线程安全）的集合包装器。</p>
<ul>
<li><strong><code>synchronizedCollection(Collection&lt;T&gt; c)</code></strong></li>
<li><strong><code>synchronizedList(List&lt;T&gt; list)</code></strong></li>
<li><strong><code>synchronizedSet(Set&lt;T&gt; s)</code></strong></li>
<li><strong><code>synchronizedMap(Map&lt;K, V&gt; m)</code></strong></li>
</ul>
<p><strong>原理</strong>：这些方法返回的包装器对象，<strong>将所有方法（如 <code>add</code>, <code>get</code>, <code>put</code>）包装在同步块（<code>synchronized</code>）中</strong>，从而保证多线程环境下的安全。</p>
<p><strong>示例与注意</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; syncList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在可以在多线程中安全地使用 syncList 了</span></span><br><span class="line"><span class="comment">// 但是，在迭代遍历它时，仍然需要手动同步</span></span><br><span class="line"><span class="keyword">synchronized</span>(syncList) &#123;</span><br><span class="line">    Iterator&lt;String&gt; it = syncList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：在现代 Java 开发中，<strong>更推荐使用 <code>java.util.concurrent</code> 包下的并发集合</strong>（如 <code>CopyOnWriteArrayList</code>, <code>ConcurrentHashMap</code>），它们的性能通常优于这种同步包装器。</p>
<hr>
<h4 id="4-2-3-不可变集合（Unmodifiable-Wrappers）"><a href="#4-2-3-不可变集合（Unmodifiable-Wrappers）" class="headerlink" title="4.2.3 不可变集合（Unmodifiable Wrappers）"></a>4.2.3 不可变集合（Unmodifiable Wrappers）</h4><p>用于创建只读的、不可修改的集合视图。任何试图修改返回集合的操作（如 <code>add</code>, <code>remove</code>, <code>set</code>）都会抛出 <code>UnsupportedOperationException</code>。</p>
<ul>
<li><strong><code>unmodifiableCollection(Collection&lt;? extends T&gt; c)</code></strong></li>
<li><strong><code>unmodifiableList(List&lt;? extends T&gt; list)</code></strong></li>
<li><strong><code>unmodifiableSet(Set&lt;? extends T&gt; s)</code></strong></li>
<li><strong><code>unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></strong></li>
</ul>
<p><strong>用途</strong>：常用于向外部客户端暴露一个内部集合的只读视图，防止内部数据被意外修改。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; originalList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">originalList.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">originalList.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个不可修改的视图</span></span><br><span class="line">List&lt;String&gt; unmodifiableList = Collections.unmodifiableList(originalList);</span><br><span class="line"></span><br><span class="line">System.out.println(unmodifiableList); <span class="comment">// [A, B]</span></span><br><span class="line"><span class="comment">// unmodifiableList.add(&quot;C&quot;); // 抛出 UnsupportedOperationException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是，修改原始集合仍然会影响这个“视图”</span></span><br><span class="line">originalList.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">System.out.println(unmodifiableList); <span class="comment">// [A, B, C]</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：它只是一个“视图”，如果底层的原始集合被修改，不可变视图的内容也会随之改变。如果需要真正的不可变集合，可以考虑使用 Java 9+ 的 <code>List.of()</code>, <code>Set.of()</code>, <code>Map.of()</code> 方法。</p>
<hr>
<h4 id="4-2-4-类型安全检查（Checked-Wrappers）"><a href="#4-2-4-类型安全检查（Checked-Wrappers）" class="headerlink" title="4.2.4 类型安全检查（Checked Wrappers）"></a>4.2.4 类型安全检查（Checked Wrappers）</h4><p>用于在运行时对添加到集合中的元素进行类型检查，确保类型安全，防止在泛型集合中插入错误类型的元素（例如，通过原始类型操作）。</p>
<ul>
<li><strong><code>checkedCollection(Collection&lt;E&gt; c, Class&lt;E&gt; type)</code></strong></li>
<li><strong><code>checkedList(List&lt;E&gt; list, Class&lt;E&gt; type)</code></strong></li>
<li><strong><code>checkedSet(Set&lt;E&gt; s, Class&lt;E&gt; type)</code></strong></li>
<li><strong><code>checkedMap(Map&lt;K, V&gt; m, Class&lt;K&gt; keyType, Class&lt;V&gt; valueType)</code></strong></li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个原本只能存放 String 的 List</span></span><br><span class="line">List&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 通过原始类型进行错误的插入（绕过编译期检查）</span></span><br><span class="line"><span class="type">List</span> <span class="variable">rawList</span> <span class="operator">=</span> strings;</span><br><span class="line">rawList.add(<span class="number">100</span>); <span class="comment">// 编译没问题，运行也没问题，但埋下了隐患</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 checkedList 包装</span></span><br><span class="line">List&lt;String&gt; safeStrings = Collections.checkedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), String.class);</span><br><span class="line"><span class="type">List</span> <span class="variable">rawList2</span> <span class="operator">=</span> safeStrings;</span><br><span class="line">rawList2.add(<span class="number">100</span>); <span class="comment">// 这一步会立即抛出 ClassCastException，而不是在后续遍历时才出错</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-5-其他实用方法"><a href="#4-2-5-其他实用方法" class="headerlink" title="4.2.5 其他实用方法"></a>4.2.5 其他实用方法</h4><ul>
<li><strong><code>copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</code></strong>: 将源列表中的所有元素复制到目标列表中。</li>
<li><strong><code>fill(List&lt;? super T&gt; list, T obj)</code></strong>: 用指定元素替换列表中的所有元素。</li>
<li><strong><code>max(Collection&lt;? extends T&gt; coll)</code> &#x2F; <code>min(...)</code></strong>: 根据自然顺序或比较器返回集合中的最大或最小元素。</li>
<li><strong><code>replaceAll(List&lt;T&gt; list, T oldVal, T newVal)</code></strong>: 将列表中所有出现的旧值替换为新值。</li>
<li><strong><code>frequency(Collection&lt;?&gt; c, Object o)</code></strong>: 返回指定元素在集合中出现的次数。</li>
<li><strong><code>disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2)</code></strong>: 如果两个集合没有共同的元素，则返回 <code>true</code>。</li>
<li><strong><code>addAll(Collection&lt;? super T&gt; c, T... elements)</code></strong>: 一种向集合中添加多个元素的便捷方式（变长参数）。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 一次性添加多个元素</span></span><br><span class="line">System.out.println(list); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;最大值: &quot;</span> + Collections.max(list)); <span class="comment">// 5</span></span><br><span class="line">System.out.println(<span class="string">&quot;最小值: &quot;</span> + Collections.min(list)); <span class="comment">// 1</span></span><br><span class="line">System.out.println(<span class="string">&quot;3 出现的频率: &quot;</span> + Collections.frequency(list, <span class="number">3</span>)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">Collections.replaceAll(list, <span class="number">3</span>, <span class="number">99</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;替换后: &quot;</span> + list); <span class="comment">// [1, 2, 99, 4, 5]</span></span><br></pre></td></tr></table></figure>

<hr>
<hr>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%B8%89%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" rel="prev" title="三、面向对象编程">
                  <i class="fa fa-angle-left"></i> 三、面向对象编程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%BA%94%E3%80%81IO/" rel="next" title="五、IO">
                  五、IO <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
