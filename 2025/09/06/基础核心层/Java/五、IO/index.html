<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="五、IO1. IO流概述1.1 什么是IO流 定义：输入&#x2F;输出流的抽象，数据在设备（文件、网络、键盘等）与程序之间的流动像“流”一样。 核心思想：顺序读写，先进先出。   1.2 流的分类标准 按流向分（以程序为参照物）： 输入流 (InputStream&#x2F;Reader)：从源（文件、网络等）读取数据到程序。 输出流 (OutputStream&#x2F;Writer)：从程序写出数据到目标（文件">
<meta property="og:type" content="article">
<meta property="og:title" content="五、IO">
<meta property="og:url" content="http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%BA%94%E3%80%81IO/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="五、IO1. IO流概述1.1 什么是IO流 定义：输入&#x2F;输出流的抽象，数据在设备（文件、网络、键盘等）与程序之间的流动像“流”一样。 核心思想：顺序读写，先进先出。   1.2 流的分类标准 按流向分（以程序为参照物）： 输入流 (InputStream&#x2F;Reader)：从源（文件、网络等）读取数据到程序。 输出流 (OutputStream&#x2F;Writer)：从程序写出数据到目标（文件">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-09-06T10:20:00.000Z">
<meta property="article:modified_time" content="2025-10-16T08:42:17.113Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%BA%94%E3%80%81IO/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%BA%94%E3%80%81IO/","path":"2025/09/06/基础核心层/Java/五、IO/","title":"五、IO"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>五、IO | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81IO"><span class="nav-number">1.</span> <span class="nav-text">五、IO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-IO%E6%B5%81%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">1. IO流概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AFIO%E6%B5%81"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 什么是IO流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB%E6%A0%87%E5%87%86"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 流的分类标准</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-File%E3%80%90%E5%AD%98%E5%9C%A8%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7%EF%BC%8C%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-Path%E3%80%91"><span class="nav-number">1.2.</span> <span class="nav-text">2. File【存在设计缺陷，推荐使用 Path】</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 核心概念与方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E6%9E%84%E9%80%A0File%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">2.2.1 构造File对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">2.2.2 文件与目录的检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">2.2.3 文件与目录的操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">2.2.4 获取文件信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-5-%E7%9B%AE%E5%BD%95%E5%88%97%E8%A1%A8"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">2.2.5 目录列表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E9%87%8D%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 重要注意事项与局限性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-RandomAccessFile%E3%80%90%E7%89%B9%E5%AE%9A%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8%EF%BC%8C%E9%80%9A%E5%B8%B8%E5%8F%AF%E8%A2%AB-NIO-FileChannel-%E6%9B%BF%E4%BB%A3%E3%80%91"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 RandomAccessFile【特定场景使用，通常可被 NIO FileChannel 替代】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">2.4.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%94%A8%E6%B3%95"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">2.4.2 核心功能与用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">2.4.3 典型使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-Apache-FileUtils%E7%B1%BB"><span class="nav-number">1.2.5.</span> <span class="nav-text">2.5 Apache FileUtils类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1-%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">2.5.1 概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%94%A8%E6%B3%95"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">2.5.2 核心功能与用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-3-%E5%85%B8%E5%9E%8B%E5%BC%95%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">2.5.3 典型引用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-Hutool-FileUtil%E7%B1%BB"><span class="nav-number">1.2.6.</span> <span class="nav-text">2.6 Hutool FileUtil类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-1-%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">2.6.1 概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-2-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%94%A8%E6%B3%95"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">2.6.2 核心功能与用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-3-%E5%85%B8%E5%9E%8B%E5%BC%95%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">2.6.3 典型引用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">1.2.6.4.</span> <span class="nav-text">示例代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%AD%97%E8%8A%82%E6%B5%81"><span class="nav-number">1.3.</span> <span class="nav-text">3. 字节流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-OutPutStream-%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 OutPutStream (输出流)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-FileOutPutStream-%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 FileOutPutStream (文件输出流)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-InPutStream-%E8%BE%93%E5%85%A5%E6%B5%81"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3 InPutStream (输入流)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-FileInPutStream-%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E6%B5%81"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.4 FileInPutStream (文件输入流)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="nav-number">1.4.</span> <span class="nav-text">4. 字符流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Reader%EF%BC%88%E8%AF%BB%E5%8F%96%E5%99%A8%EF%BC%89"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 Reader（读取器）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-FileReder%EF%BC%88%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%99%A8%EF%BC%89"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2 FileReder（文件读取器）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-Writer%EF%BC%88%E5%86%99%E5%85%A5%E5%99%A8%EF%BC%89"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.3 Writer（写入器）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-FileWriter%EF%BC%88%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E5%99%A8%EF%BC%89"><span class="nav-number">1.4.4.</span> <span class="nav-text">4.4 FileWriter（文件写入器）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-number">1.5.</span> <span class="nav-text">5. 缓冲流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-BufferedInputStream-BufferedOutputStream%EF%BC%88%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81%EF%BC%89"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.1 BufferedInputStream &amp; BufferedOutputStream（字节缓冲流）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-BufferedReader-BufferedWriter%EF%BC%88%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%EF%BC%89"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.2 BufferedReader &amp; BufferedWriter（字符缓冲流）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-number">1.6.</span> <span class="nav-text">6. 数据流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.6.1.</span> <span class="nav-text">6.1 核心功能与应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-1-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">6.1.1 核心功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-2-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">6.1.2 典型应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-DataOutputStream-%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">1.6.2.</span> <span class="nav-text">6.2 DataOutputStream (数据输出流)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">6.2.1 构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">6.2.2 核心方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-DataInputStream-%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%E6%B5%81"><span class="nav-number">1.6.3.</span> <span class="nav-text">6.3 DataInputStream (数据输入流)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">6.3.1 构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-2-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">6.3.2 核心方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E9%87%8D%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.6.4.</span> <span class="nav-text">6.4 重要注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8E%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="nav-number">1.7.</span> <span class="nav-text">7. 字符编码与转换流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81"><span class="nav-number">1.7.1.</span> <span class="nav-text">7.1 编码与解码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-1-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81-Character-Encoding"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">7.1.1 字符编码 (Character Encoding)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-2-%E5%A4%9A%E5%AA%92%E4%BD%93%E7%BC%96%E7%A0%81-Multimedia-Encoding"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">7.1.2 多媒体编码 (Multimedia Encoding)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-3-%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81-Transfer-Encoding"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">7.1.3 传输编码 (Transfer Encoding)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-4-%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-Encryption-Decryption"><span class="nav-number">1.7.1.4.</span> <span class="nav-text">7.1.4 加密与解密 (Encryption &amp; Decryption)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-InputStreamReader-OutPutStreamWriter"><span class="nav-number">1.7.2.</span> <span class="nav-text">7.2 InputStreamReader &amp; OutPutStreamWriter</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-1-InputStreamReader"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">7.2.1 InputStreamReader</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%85%B3%E9%94%AE%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.7.2.1.1.</span> <span class="nav-text">1. 关键构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.7.2.1.2.</span> <span class="nav-text">2. 工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.2.1.3.</span> <span class="nav-text">3. 常用方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-2-OutputStreamWriter"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">7.2.2 OutputStreamWriter</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%85%B3%E9%94%AE%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="nav-number">1.7.2.2.1.</span> <span class="nav-text">1. 关键构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1"><span class="nav-number">1.7.2.2.2.</span> <span class="nav-text">2. 工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="nav-number">1.7.2.2.3.</span> <span class="nav-text">3. 常用方法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%BA%8F%E5%88%97%E6%B5%81%E3%80%90%E5%AD%98%E5%9C%A8%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9%EF%BC%8C%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%9C%89%E7%8E%B0%E4%BB%A3%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%E3%80%91"><span class="nav-number">1.8.</span> <span class="nav-text">8 序列流【存在安全风险，不推荐使用，有现代替代方案】</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">1.8.1.</span> <span class="nav-text">8.1 序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-1-%E6%A6%82%E5%BF%B5"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">8.1.1 概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-2-Serializable-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A0%B8%E5%BF%83%E8%A7%92%E8%89%B2"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">8.1.2 Serializable 接口的核心角色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-3-%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.8.1.3.</span> <span class="nav-text">8.1.3 实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-4-%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7%E4%B8%8E%E6%B7%B1%E5%85%A5%E6%A6%82%E5%BF%B5"><span class="nav-number">1.8.1.4.</span> <span class="nav-text">8.1.4 关键特性与深入概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-serialVersionUID"><span class="nav-number">1.8.1.4.1.</span> <span class="nav-text">1. serialVersionUID</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-transient-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.8.1.4.2.</span> <span class="nav-text">2. transient 关键字</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">1.8.1.4.3.</span> <span class="nav-text">3. 继承关系中的序列化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B%EF%BC%9AwriteObject-%E5%92%8C-readObject"><span class="nav-number">1.8.1.4.4.</span> <span class="nav-text">4. 自定义序列化过程：writeObject 和 readObject</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%EF%BC%9AreadResolve-%E5%92%8C-writeReplace"><span class="nav-number">1.8.1.4.5.</span> <span class="nav-text">5. 特殊方法：readResolve 和 writeReplace</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.8.1.4.6.</span> <span class="nav-text">6. 优缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="nav-number">1.8.1.4.7.</span> <span class="nav-text">7. 替代方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-ObjectOutPutStream-ObjectInPutStream"><span class="nav-number">1.8.2.</span> <span class="nav-text">8.2 ObjectOutPutStream &amp; ObjectInPutStream</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-1-ObjectOutputStream-%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">8.2.1 ObjectOutputStream 的序列化过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-2-ObjectInputStream-%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">8.2.2 ObjectInputStream 的反序列化过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E6%89%93%E5%8D%B0%E6%B5%81"><span class="nav-number">1.9.</span> <span class="nav-text">9. 打印流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9"><span class="nav-number">1.9.1.</span> <span class="nav-text">9.1 核心特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-PrintStream%EF%BC%88%E5%AD%97%E8%8A%82%E6%89%93%E5%8D%B0%E6%B5%81%EF%BC%89"><span class="nav-number">1.9.2.</span> <span class="nav-text">9.2 PrintStream（字节打印流）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-1-%E5%B8%B8%E8%A7%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">9.2.1 常见构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-2-%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">9.2.2 重要方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-3-%E6%9C%80%E8%91%97%E5%90%8D%E7%9A%84%E5%AE%9E%E4%BE%8B%EF%BC%9ASystem-out-%E5%92%8C-System-err"><span class="nav-number">1.9.2.3.</span> <span class="nav-text">9.2.3 最著名的实例：System.out 和 System.err</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-PrintWriter%EF%BC%88%E5%AD%97%E7%AC%A6%E6%89%93%E5%8D%B0%E6%B5%81%EF%BC%89"><span class="nav-number">1.9.3.</span> <span class="nav-text">9.3 PrintWriter（字符打印流）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3-1-%E5%B8%B8%E8%A7%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.3.1.</span> <span class="nav-text">9.3.1 常见构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-3-2-%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.3.2.</span> <span class="nav-text">9.3.2 重要方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81IO%E6%B5%81"><span class="nav-number">1.10.</span> <span class="nav-text">10. 其他重要IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E6%B5%81-In-Memory-I-O"><span class="nav-number">1.10.1.</span> <span class="nav-text">10.1 内存操作流 (In-Memory I&#x2F;O)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-1-ByteArrayInputStream-ByteArrayOutputStream-%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E6%B5%81"><span class="nav-number">1.10.1.1.</span> <span class="nav-text">10.1.1 ByteArrayInputStream &amp; ByteArrayOutputStream (字节数组流)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-2-StringReader-StringWriter-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%81"><span class="nav-number">1.10.1.2.</span> <span class="nav-text">10.1.2 StringReader &amp; StringWriter (字符串流)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-3-%E6%A0%B8%E5%BF%83%E5%BA%94%E7%94%A8%EF%BC%9A%E9%9D%A2%E5%90%91%E5%86%85%E5%AD%98%E7%9A%84IO%E6%93%8D%E4%BD%9C%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.10.1.3.</span> <span class="nav-text">10.1.3 核心应用：面向内存的IO操作与数据转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-%E7%AE%A1%E9%81%93%E6%B5%81-Piped-I-O"><span class="nav-number">1.10.2.</span> <span class="nav-text">10.2 管道流 (Piped I&#x2F;O)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-1-PipedInputStream-PipedOutputStream"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">10.2.1 PipedInputStream &amp; PipedOutputStream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-2-%E6%A0%B8%E5%BF%83%E5%BA%94%E7%94%A8%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">1.10.2.2.</span> <span class="nav-text">10.2.2 核心应用：线程间通信</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-%E5%8A%9F%E8%83%BD%E7%BB%84%E5%90%88%E6%B5%81"><span class="nav-number">1.10.3.</span> <span class="nav-text">10.3 功能组合流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3-1-SequenceInputStream-%E5%BA%8F%E5%88%97%E8%BE%93%E5%85%A5%E6%B5%81"><span class="nav-number">1.10.3.1.</span> <span class="nav-text">10.3.1 SequenceInputStream (序列输入流)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-3-2-LineNumberReader-%E8%A1%8C%E5%8F%B7%E8%AF%BB%E5%8F%96%E5%99%A8"><span class="nav-number">1.10.3.2.</span> <span class="nav-text">10.3.2 LineNumberReader (行号读取器)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-%E6%B5%81%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">1.10.4.</span> <span class="nav-text">10.4 流的选择</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-1-%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9"><span class="nav-number">1.10.4.1.</span> <span class="nav-text">10.4.1 根据数据类型选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-2-%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90-%E7%9B%AE%E7%9A%84%E5%9C%B0%E9%80%89%E6%8B%A9"><span class="nav-number">1.10.4.2.</span> <span class="nav-text">10.4.2 根据数据来源&#x2F;目的地选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-%E6%A0%B9%E6%8D%AE%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82%E9%80%89%E6%8B%A9"><span class="nav-number">1.10.4.3.</span> <span class="nav-text">10.4.3 根据功能需求选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-4-%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E5%BB%BA%E8%AE%AE"><span class="nav-number">1.10.4.4.</span> <span class="nav-text">10.4.4 常见使用场景和建议</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%EF%BC%88%E6%8E%A8%E8%8D%90%E6%96%B9%E5%BC%8F%EF%BC%89%EF%BC%9A"><span class="nav-number">1.10.4.4.1.</span> <span class="nav-text">1. 读取文本文件（推荐方式）：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%86%99%E5%85%A5%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%EF%BC%88%E6%8E%A8%E8%8D%90%E6%96%B9%E5%BC%8F%EF%BC%89%EF%BC%9A"><span class="nav-number">1.10.4.4.2.</span> <span class="nav-text">2. 写入文本文件（推荐方式）：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%A4%8D%E5%88%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%EF%BC%88%E6%8E%A8%E8%8D%90%E6%96%B9%E5%BC%8F%EF%BC%89%EF%BC%9A"><span class="nav-number">1.10.4.4.3.</span> <span class="nav-text">3. 复制二进制文件（推荐方式）：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E8%AF%BB%E5%8F%96%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="nav-number">1.10.4.4.4.</span> <span class="nav-text">4. 读取基本数据类型：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="nav-number">1.10.4.4.5.</span> <span class="nav-text">5. 序列化对象：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-5-%E6%80%A7%E8%83%BD%E8%80%83%E8%99%91"><span class="nav-number">1.10.4.5.</span> <span class="nav-text">10.4.5 性能考虑</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-NIO"><span class="nav-number">1.11.</span> <span class="nav-text">11. NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-number">1.11.1.</span> <span class="nav-text">11.1 核心思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-number">1.11.2.</span> <span class="nav-text">11.2 三大核心组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-1-Buffer-%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">1.11.2.1.</span> <span class="nav-text">11.2.1 Buffer (缓冲区)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-2-Channel-%E9%80%9A%E9%81%93"><span class="nav-number">1.11.2.2.</span> <span class="nav-text">11.2.2 Channel (通道)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-2-3-Selector-%E9%80%89%E6%8B%A9%E5%99%A8"><span class="nav-number">1.11.2.3.</span> <span class="nav-text">11.2.3 Selector (选择器)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-Paths-Files"><span class="nav-number">1.11.3.</span> <span class="nav-text">11.3 Paths &amp; Files</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-1-Paths"><span class="nav-number">1.11.3.1.</span> <span class="nav-text">11.3.1 Paths</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Path%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.11.3.1.1.</span> <span class="nav-text">1. Path接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%EF%BC%9APaths-get"><span class="nav-number">1.11.3.1.2.</span> <span class="nav-text">2. 核心方法：Paths.get()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Path-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.11.3.1.3.</span> <span class="nav-text">3. Path 接口的常用方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-3-2-Files"><span class="nav-number">1.11.3.2.</span> <span class="nav-text">11.3.2 Files</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A3%80%E6%9F%A5%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81%EF%BC%88%E5%B8%B8%E7%94%A8%E4%BD%9C%E6%93%8D%E4%BD%9C%E5%89%8D%E6%8F%90%EF%BC%89"><span class="nav-number">1.11.3.2.1.</span> <span class="nav-text">1. 检查文件状态（常用作操作前提）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%EF%BC%88%E9%9D%9E%E5%B8%B8%E6%96%B9%E4%BE%BF%EF%BC%89"><span class="nav-number">1.11.3.2.2.</span> <span class="nav-text">2. 读写文件内容（非常方便）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%88%9B%E5%BB%BA%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E7%A7%BB%E5%8A%A8%E3%80%81%E5%88%A0%E9%99%A4"><span class="nav-number">1.11.3.2.3.</span> <span class="nav-text">3. 创建、复制、移动、删除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="nav-number">1.11.3.2.4.</span> <span class="nav-text">4. 获取和设置文件属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="nav-number">1.11.4.</span> <span class="nav-text">11.4 总结与应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#11-4-1-%E4%BC%98%E5%8A%A3%E5%8A%BF"><span class="nav-number">1.11.4.1.</span> <span class="nav-text">11.4.1 优劣势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-4-2-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">1.11.4.2.</span> <span class="nav-text">11.4.2 最佳实践</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-AIO%E3%80%90%E6%9C%AA%E6%9D%A5%E3%80%91"><span class="nav-number">1.12.</span> <span class="nav-text">12. AIO【未来】</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-%E6%A6%82%E5%BF%B5"><span class="nav-number">1.12.1.</span> <span class="nav-text">12.1 概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-number">1.12.2.</span> <span class="nav-text">12.2 核心组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-AIO%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.12.3.</span> <span class="nav-text">12.3 AIO工作模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#12-3-1-%E5%9B%9E%E8%B0%83%E6%A8%A1%E5%BC%8F-Callback-based-%E6%9B%B4%E2%80%9C%E5%BC%82%E6%AD%A5%E2%80%9D"><span class="nav-number">1.12.3.1.</span> <span class="nav-text">12.3.1 回调模式 (Callback-based) - 更“异步”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-3-2-Future-%E6%A8%A1%E5%BC%8F-Future-based-%E6%9B%B4%E2%80%9C%E5%8F%AF%E6%8E%A7%E2%80%9D"><span class="nav-number">1.12.3.2.</span> <span class="nav-text">12.3.2 Future 模式 (Future-based) - 更“可控”</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-4-AIO-%E7%9A%84%E7%8E%B0%E7%8A%B6%E4%B8%8E%E6%80%BB%E7%BB%93"><span class="nav-number">1.12.4.</span> <span class="nav-text">12.4 AIO 的现状与总结</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%BA%94%E3%80%81IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="五、IO | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          五、IO
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-06 18:20:00" itemprop="dateCreated datePublished" datetime="2025-09-06T18:20:00+08:00">2025-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-16 16:42:17" itemprop="dateModified" datetime="2025-10-16T16:42:17+08:00">2025-10-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="五、IO"><a href="#五、IO" class="headerlink" title="五、IO"></a>五、IO</h1><h2 id="1-IO流概述"><a href="#1-IO流概述" class="headerlink" title="1. IO流概述"></a>1. IO流概述</h2><h3 id="1-1-什么是IO流"><a href="#1-1-什么是IO流" class="headerlink" title="1.1 什么是IO流"></a>1.1 什么是IO流</h3><ul>
<li>定义：输入&#x2F;输出流的抽象，数据在设备（文件、网络、键盘等）与程序之间的流动像“流”一样。</li>
<li>核心思想：顺序读写，先进先出。</li>
</ul>
<hr>
<h3 id="1-2-流的分类标准"><a href="#1-2-流的分类标准" class="headerlink" title="1.2 流的分类标准"></a>1.2 流的分类标准</h3><ul>
<li><strong>按流向分</strong>（以程序为参照物）：<ul>
<li><code>输入流 (InputStream/Reader)</code>：从源（文件、网络等）读取数据到程序。</li>
<li><code>输出流 (OutputStream/Writer)</code>：从程序写出数据到目标（文件、网络等）。</li>
</ul>
</li>
<li><strong>按操作数据类型分</strong>：<ul>
<li><code>字节流 (Byte Streams)</code>：以字节（8bit, <code>byte</code>）为单位，操作所有类型的数据（图片、视频、文本等）。基类：<code>InputStream</code>, <code>OutputStream</code>。</li>
<li><code>字符流 (Character Streams)</code>：以字符（16bit, <code>char</code>）为单位，专门处理文本数据，能自动处理编码问题。基类：<code>Reader</code>, <code>Writer</code>。</li>
</ul>
</li>
<li><strong>按角色功能分</strong>：<ul>
<li><code>节点流 (Node Streams)</code>：直接从数据源或目的地读写数据。如：<code>FileInputStream</code>。</li>
<li><code>处理流/包装流 (Processing Streams)</code>：对已存在的流进行封装，提供更强大、更方便的功能（如缓冲、转换等）。使用了<strong>装饰器模式</strong>。如：<code>BufferedInputStream</code>。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-File【存在设计缺陷，推荐使用-Path】"><a href="#2-File【存在设计缺陷，推荐使用-Path】" class="headerlink" title="2. File【存在设计缺陷，推荐使用 Path】"></a>2. File【存在设计缺陷，推荐使用 <code>Path</code>】</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><ul>
<li><strong>不代表文件本身</strong>：<code>File</code> 对象不是文件，它只是一个路径的“包装器”。</li>
<li><strong>抽象路径</strong>：它使用一个与系统无关的“抽象路径名”来屏蔽不同操作系统（Windows, Linux, macOS）在路径表示上的差异（例如，使用 <code>/</code> 而不是 <code>\</code>）。</li>
<li><strong>功能</strong>：主要用于文件和目录的<strong>元数据操作</strong>（创建、删除、重命名、查询属性等），<strong>而不是文件内容的读写</strong>。文件内容的读写需要配合 <code>FileInputStream</code>, <code>FileOutputStream</code> 等流类使用。</li>
<li><strong>现状</strong>：<strong>已过时（Legacy）</strong>。请使用Path与</li>
</ul>
<hr>
<h3 id="2-2-核心概念与方法"><a href="#2-2-核心概念与方法" class="headerlink" title="2.2 核心概念与方法"></a>2.2 核心概念与方法</h3><h4 id="2-2-1-构造File对象"><a href="#2-2-1-构造File对象" class="headerlink" title="2.2.1 构造File对象"></a>2.2.1 构造File对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 通过父路径字符串和子路径字符串创建</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/tmp&quot;</span>, <span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过完整的路径字符串创建</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/tmp/test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 通过另一个File对象（父目录）和子路径字符串创建</span></span><br><span class="line"><span class="type">File</span> <span class="variable">parentDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/tmp&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentDir, <span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 使用相对路径（相对于当前工作目录）</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;relative_path.txt&quot;</span>); <span class="comment">// 例如在IDE中运行，相对项目根目录</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-2-文件与目录的检测"><a href="#2-2-2-文件与目录的检测" class="headerlink" title="2.2.2 文件与目录的检测"></a>2.2.2 文件与目录的检测</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查文件或目录是否存在</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> file.exists();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否是文件（而不是目录）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFile</span> <span class="operator">=</span> file.isFile();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否是目录</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isDirectory</span> <span class="operator">=</span> file.isDirectory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否是一个隐藏文件（取决于操作系统）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isHidden</span> <span class="operator">=</span> file.isHidden();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否可读</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">canRead</span> <span class="operator">=</span> file.canRead();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否可写</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">canWrite</span> <span class="operator">=</span> file.canWrite();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否可执行（对于程序或脚本）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">canExecute</span> <span class="operator">=</span> file.canExecute();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-3-文件与目录的操作"><a href="#2-2-3-文件与目录的操作" class="headerlink" title="2.2.3 文件与目录的操作"></a>2.2.3 文件与目录的操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;new_file.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件：如果文件不存在且创建成功，返回true；如果文件已存在，返回false。</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> file.createNewFile();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除文件或目录（如果是空目录）：删除成功返回true。</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">deleted</span> <span class="operator">=</span> file.delete();</span><br><span class="line"></span><br><span class="line"><span class="comment">// JVM退出时删除文件或目录：通常用于临时文件</span></span><br><span class="line">file.deleteOnExit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建目录：只能创建一级目录</span></span><br><span class="line"><span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;new_dir&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">dirCreated</span> <span class="operator">=</span> dir.mkdir();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多级目录：创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。</span></span><br><span class="line"><span class="type">File</span> <span class="variable">multiLevelDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;level1/level2/level3&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">dirsCreated</span> <span class="operator">=</span> multiLevelDir.mkdirs();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名或移动文件/目录</span></span><br><span class="line"><span class="type">File</span> <span class="variable">oldFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;old_name.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">newFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;new_name.txt&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">renamed</span> <span class="operator">=</span> oldFile.renameTo(newFile); <span class="comment">// 也可用于移动到另一个目录</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-4-获取文件信息"><a href="#2-2-4-获取文件信息" class="headerlink" title="2.2.4 获取文件信息"></a>2.2.4 获取文件信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件名称（包含扩展名）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> file.getName(); <span class="comment">// &quot;test.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父目录的路径字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">parentPath</span> <span class="operator">=</span> file.getParent(); <span class="comment">// 例如 “/tmp”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父目录的File对象</span></span><br><span class="line"><span class="type">File</span> <span class="variable">parentFile</span> <span class="operator">=</span> file.getParentFile();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件绝对路径（字符串）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">absolutePath</span> <span class="operator">=</span> file.getAbsolutePath();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件规范路径（字符串），会解析其中的 `..` 和 `.` 等符号链接（Unix）或快捷方式（Windows）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">canonicalPath</span> <span class="operator">=</span> file.getCanonicalPath();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件长度（字节数），如果文件不存在则返回0L</span></span><br><span class="line"><span class="type">long</span> <span class="variable">length</span> <span class="operator">=</span> file.length();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件最后修改时间（毫秒数，自1970年纪元起）</span></span><br><span class="line"><span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> file.lastModified();</span><br><span class="line"><span class="comment">// 通常转换为Date对象</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">lastModifiedDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(lastModified);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-5-目录列表"><a href="#2-2-5-目录列表" class="headerlink" title="2.2.5 目录列表"></a>2.2.5 目录列表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/tmp&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出目录下的所有文件和子目录的名称（字符串数组）</span></span><br><span class="line">String[] fileNames = dir.list();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出目录下的所有文件和子目录的File对象（更常用）</span></span><br><span class="line">File[] files = dir.listFiles();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用FilenameFilter过滤器列出文件</span></span><br><span class="line"><span class="comment">// 例如，列出所有 .txt 文件</span></span><br><span class="line">File[] txtFiles = dir.listFiles(<span class="keyword">new</span> <span class="title class_">FilenameFilter</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name.toLowerCase().endsWith(<span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Java 8+ Lambda 表达式写法</span></span><br><span class="line">File[] txtFilesLambda = dir.listFiles((d, name) -&gt; name.endsWith(<span class="string">&quot;.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-重要注意事项与局限性"><a href="#2-3-重要注意事项与局限性" class="headerlink" title="2.3 重要注意事项与局限性"></a>2.3 重要注意事项与局限性</h3><ol>
<li><p><strong>路径分隔符</strong>：使用 <code>File.separator</code>（字符串）或 <code>File.separatorChar</code>（字符）来代替硬编码的 <code>/</code> 或 <code>\</code>，以保证跨平台兼容性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">betterFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dir&quot;</span> + File.separator + <span class="string">&quot;file.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>异常处理</strong>：许多方法（如 <code>createNewFile()</code>, <code>canonicalPath()</code>）会抛出 <code>IOException</code>，必须使用 <code>try-catch</code> 进行处理。</p>
</li>
<li><p><strong>原子性</strong>：由于文件系统是共享的，某些操作不是原子的。例如，在调用 <code>exists()</code> 和 <code>createNewFile()</code> 之间，另一个进程可能已经创建或删除了该文件。</p>
</li>
<li><p><strong>符号链接</strong>：<code>File</code> 类对符号链接的处理可能因平台而异，有时会解析链接，有时不会，行为不够一致。</p>
</li>
<li><p><strong>性能</strong>：对于遍历大型目录结构（如整个磁盘），<code>listFiles()</code> 性能较差，因为它会一次性返回所有结果。</p>
</li>
<li><p><strong>功能有限</strong>：缺少一些现代文件系统所需的高级功能，如文件属性、符号链接的精细控制、文件更改通知等。</p>
</li>
</ol>
<hr>
<h3 id="2-4-RandomAccessFile【特定场景使用，通常可被-NIO-FileChannel-替代】"><a href="#2-4-RandomAccessFile【特定场景使用，通常可被-NIO-FileChannel-替代】" class="headerlink" title="2.4 RandomAccessFile【特定场景使用，通常可被 NIO FileChannel 替代】"></a>2.4 RandomAccessFile【特定场景使用，通常可被 NIO <code>FileChannel</code> 替代】</h3><h4 id="2-4-1-概述"><a href="#2-4-1-概述" class="headerlink" title="2.4.1 概述"></a>2.4.1 概述</h4><p><code>RandomAccessFile</code> 是Java标准库（<code>java.io</code>包）中的一个类，用于支持对文件的<strong>随机访问</strong>读写。它的名字“随机”意味着你可以从文件的任意位置（通过移动文件指针）开始读取或写入数据，而不像<code>InputStream</code>或<code>OutputStream</code>那样只能顺序进行。</p>
<hr>
<h4 id="2-4-2-核心功能与用法"><a href="#2-4-2-核心功能与用法" class="headerlink" title="2.4.2 核心功能与用法"></a>2.4.2 核心功能与用法</h4><ol>
<li><strong>模式（Mode）</strong>：构造时需要指定访问模式。<ul>
<li><code>&quot;r&quot;</code>: 只读。</li>
<li><code>&quot;rw&quot;</code>: 读写。如果文件不存在，会尝试创建。</li>
<li><code>&quot;rws&quot;</code>: 读写，并且要求对文件内容或元数据的每次更新都同步写入底层存储设备。</li>
<li><code>&quot;rwd&quot;</code>: 读写，并且要求对文件内容的每次更新都同步写入底层存储设备。</li>
</ul>
</li>
<li><strong>文件指针（File Pointer）</strong>：这是其核心机制。<ul>
<li><code>long getFilePointer()</code>: 返回当前指针的位置。</li>
<li><code>void seek(long pos)</code>: 设置文件指针偏移量（从文件开头开始的字节数）。通过这个方法可以跳转到文件的任何位置。</li>
</ul>
</li>
<li><strong>读写方法</strong>：<ul>
<li>提供了多种基本数据类型的读写方法，如 <code>readInt()</code>, <code>writeChar()</code>, <code>readLine()</code>, <code>writeUTF(String str)</code> 等。这些方法使得读写结构化数据非常方便。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-4-3-典型使用场景"><a href="#2-4-3-典型使用场景" class="headerlink" title="2.4.3 典型使用场景"></a>2.4.3 典型使用场景</h4><ul>
<li><strong>DIY数据库或索引文件</strong>：你可以自己设计文件格式，比如前8个字节是long型表示记录数，后面是每条记录。通过<code>seek()</code>可以快速定位到某条记录。</li>
<li><strong>大文件的部分读取</strong>：例如一个巨大的日志文件，你只想看最后1MB的内容，可以用<code>seek()</code>跳到文件末尾附近开始读。</li>
<li><strong>多线程下载&#x2F;断点续传</strong>：将文件分成几块，不同的线程通过<code>seek()</code>到不同位置并行写入。</li>
</ul>
<p><strong>示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;test.dat&quot;</span>, <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 写入一个int和一個String</span></span><br><span class="line">    raf.writeInt(<span class="number">100</span>);</span><br><span class="line">    raf.writeUTF(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// UTF格式写入，会先写入长度信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指针重置到文件开头，重新读取</span></span><br><span class="line">    raf.seek(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> raf.readInt();</span><br><span class="line">    <span class="type">String</span> <span class="variable">greeting</span> <span class="operator">=</span> raf.readUTF();</span><br><span class="line"></span><br><span class="line">    System.out.println(number);    <span class="comment">// 输出 100</span></span><br><span class="line">    System.out.println(greeting);  <span class="comment">// 输出 Hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：JDK原生，无需额外依赖。功能强大且独特，能解决顺序读写无法解决的问题。</li>
<li><strong>缺点</strong>：API相对古老和繁琐。对于简单的文件操作，它远不如<code>Files</code>类方便。性能在某些场景下可能不如NIO的<code>FileChannel</code>。</li>
</ul>
<hr>
<h3 id="2-5-Apache-FileUtils类"><a href="#2-5-Apache-FileUtils类" class="headerlink" title="2.5 Apache FileUtils类"></a>2.5 Apache FileUtils类</h3><h4 id="2-5-1-概念"><a href="#2-5-1-概念" class="headerlink" title="2.5.1 概念"></a>2.5.1 概念</h4><p><code>FileUtils</code>是Apache Commons IO库中的一个<strong>工具类</strong>。它的设计理念与<code>java.nio.file.Files</code>类似，提供了大量<strong>静态方法</strong>来简化常见的文件操作，但其功能比早期的JDK <code>File</code>类强大得多，甚至对<code>Files</code>类也是一个很好的补充，API设计也非常直观。</p>
<hr>
<h4 id="2-5-2-核心功能与用法"><a href="#2-5-2-核心功能与用法" class="headerlink" title="2.5.2 核心功能与用法"></a>2.5.2 核心功能与用法</h4><ul>
<li><strong>读写文件内容</strong>：<ul>
<li><code>String readFileToString(File file, String encoding)</code>: 一次性读取整个文件到字符串。</li>
<li><code>void writeStringToFile(File file, String data, String encoding)</code>: 将字符串写入文件。</li>
<li><code>List&lt;String&gt; readLines(File file, String encoding)</code>: 按行读取文件到字符串列表。</li>
</ul>
</li>
<li><strong>文件操作</strong>：<ul>
<li><code>copyFile(File srcFile, File destFile)</code>: 复制文件。</li>
<li><code>copyDirectory(File srcDir, File destDir)</code>: 复制整个目录。</li>
<li><code>deleteDirectory(File directory)</code>: 删除整个目录（包括子目录和文件）。</li>
<li><code>cleanDirectory(File directory)</code>: 清空目录内的所有内容。</li>
</ul>
</li>
<li><strong>文件比较与校验</strong>：<ul>
<li><code>boolean contentEquals(File file1, File file2)</code>: 比较两个文件内容是否完全相同。</li>
</ul>
</li>
<li><strong>临时文件操作</strong>：<ul>
<li><code>File getTempDirectory()</code>, <code>File getUserDirectory()</code></li>
</ul>
</li>
<li><strong>文件监控</strong>：提供了<code>FileAlterationMonitor</code>等类用于监听文件变化。</li>
</ul>
<hr>
<h4 id="2-5-3-典型引用场景"><a href="#2-5-3-典型引用场景" class="headerlink" title="2.5.3 典型引用场景"></a>2.5.3 典型引用场景</h4><ul>
<li>需要快速完成一个文件操作任务，不希望写太多样板代码（Boilerplate Code）。</li>
<li>在Java 7之前（没有<code>Files</code>类）的项目中，它是文件操作的“神器”。</li>
<li>即使有<code>Files</code>类，它的某些功能（如整个目录的复制、删除、比较文件内容）仍然非常方便。</li>
</ul>
<p><strong>示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入Apache Commons IO依赖后使用</span></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 读取文件内容</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> FileUtils.readFileToString(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 写入文件</span></span><br><span class="line">FileUtils.writeStringToFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;output.txt&quot;</span>), <span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 复制整个目录</span></span><br><span class="line">FileUtils.copyDirectory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/sourceDir&quot;</span>), <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/destDir&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：API极其友好和强大，大大简化了代码。是Java界历史悠久、广泛使用的顶级开源库，稳定可靠。</li>
<li><strong>缺点</strong>：需要额外引入第三方依赖（commons-io）。在有了JDK 7+的<code>Files</code>之后，其部分功能可以被替代。</li>
</ul>
<hr>
<h3 id="2-6-Hutool-FileUtil类"><a href="#2-6-Hutool-FileUtil类" class="headerlink" title="2.6 Hutool FileUtil类"></a>2.6 Hutool FileUtil类</h3><h4 id="2-6-1-概念"><a href="#2-6-1-概念" class="headerlink" title="2.6.1 概念"></a>2.6.1 概念</h4><p><code>FileUtil</code>是国产开源工具库<strong>Hutool</strong>中的一个工具类。它的定位与Apache的<code>FileUtils</code>非常相似，也是一个提供大量静态方法的工具类，旨在用一行代码完成文件操作。它的设计更符合中文用户的习惯，并且整合了JDK中<code>File</code>、<code>Files</code>、<code>Paths</code>等多个类的功能，并做了进一步增强。</p>
<hr>
<h4 id="2-6-2-核心功能与用法"><a href="#2-6-2-核心功能与用法" class="headerlink" title="2.6.2 核心功能与用法"></a>2.6.2 核心功能与用法</h4><p>它的功能覆盖了<code>FileUtils</code>的几乎所有功能，并且还有自己的特色：</p>
<ul>
<li><strong>基本文件操作</strong>：与<code>FileUtils</code>类似，提供了<code>readString</code>, <code>writeString</code>, <code>copy</code>, <code>mkdir</code>等方法。</li>
<li><strong>路径处理</strong>：<ul>
<li><code>File file(String path)</code>: 创建<code>File</code>对象（自动处理<code>~</code>表示用户home目录）。</li>
<li><code>getAbsolutePath(String path)</code>: 获取绝对路径。</li>
</ul>
</li>
<li><strong>文件类型判断</strong>：<ul>
<li><code>getType(File file)</code>: 通过文件扩展名获取MIME类型。</li>
<li><code>isModified(File file, long lastModifyTime)</code>: 判断文件是否被修改过。</li>
</ul>
</li>
<li><strong>文件名处理</strong>：<ul>
<li><code>mainName(File file)</code>: 获取主文件名（不含扩展名）。</li>
<li><code>extName(File file)</code>: 获取扩展名。</li>
</ul>
</li>
<li><strong>与流转换</strong>：提供了方便的方法在<code>File</code>、<code>InputStream</code>、<code>OutputStream</code>之间转换。</li>
</ul>
<hr>
<h4 id="2-6-3-典型引用场景"><a href="#2-6-3-典型引用场景" class="headerlink" title="2.6.3 典型引用场景"></a>2.6.3 典型引用场景</h4><ul>
<li>与<code>FileUtils</code>几乎完全一致，希望用最简洁的代码完成文件操作。</li>
<li>项目已经引入了Hutool作为核心工具库（Hutool不仅仅有IO工具，还提供了集合、日期、HTTP客户端、加密解密等海量工具）。</li>
<li>对中文文档和社区支持有偏好。</li>
</ul>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入Hutool依赖后使用</span></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.io.FileUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 读取文件内容 (UTF-8)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> FileUtil.readString(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 写入文件</span></span><br><span class="line">FileUtil.writeString(<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 复制文件或目录 (方法名与Linux命令相同，非常直观)</span></span><br><span class="line">FileUtil.copy(<span class="string">&quot;/sourceDir&quot;</span>, <span class="string">&quot;/destDir&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：API设计极其简洁，符合国人习惯。功能全面，不仅仅是文件操作，Hutool整个生态非常强大，“一个工具库解决所有问题”。</li>
<li><strong>缺点</strong>：同样是第三方依赖。在一些对依赖管理极其严格的公司，可能更倾向于使用Apache这种“国际标准”或者直接使用JDK原生API。</li>
</ul>
<hr>
<h2 id="3-字节流"><a href="#3-字节流" class="headerlink" title="3. 字节流"></a>3. 字节流</h2><h3 id="3-1-OutPutStream-输出流"><a href="#3-1-OutPutStream-输出流" class="headerlink" title="3.1 OutPutStream (输出流)"></a>3.1 OutPutStream (输出流)</h3><p><code>OutputStream</code> 是一个抽象类，是所有字节输出流的超类。它定义了向目标写入字节的基本方法。</p>
<p><strong>主要方法：</strong></p>
<ul>
<li><code>void write(int b)</code>：向输出流写入<strong>一个字节</strong>（参数 <code>int b</code> 的低8位，高24位被忽略）。</li>
<li><code>void write(byte[] b)</code>：将字节数组 <code>b</code> 中的<strong>所有字节</strong>写入输出流。</li>
<li><code>void write(byte[] b, int off, int len)</code>：将字节数组 <code>b</code> 中从偏移量 <code>off</code> 开始的 <code>len</code> 个字节写入输出流。这是最常用、最灵活的方法。</li>
<li><code>void flush()</code>：<strong>刷新</strong>此输出流。对于缓冲流（如 <code>BufferedOutputStream</code>），此方法会强制将缓冲区中的所有数据立即写入目标，而不是等缓冲区满了再写。</li>
<li><code>void close()</code>：<strong>关闭</strong>此输出流并释放与之关联的所有系统资源。<strong>非常重要！</strong> 必须调用此方法来避免资源泄漏。通常放在 <code>finally</code> 块或使用 try-with-resources 语句自动关闭。</li>
</ul>
<hr>
<h3 id="3-2-FileOutPutStream-文件输出流"><a href="#3-2-FileOutPutStream-文件输出流" class="headerlink" title="3.2 FileOutPutStream (文件输出流)"></a>3.2 FileOutPutStream (文件输出流)</h3><p><code>FileOutputStream</code> 是 <code>OutputStream</code> 的子类，用于将数据写入文件。它负责将字节流写入文件系统中的一个具体文件。</p>
<p><strong>构造方法 (常用)：</strong></p>
<ul>
<li><code>FileOutputStream(File file)</code>：创建一个向指定 <code>File</code> 对象表示的文件写入数据的文件输出流。</li>
<li><code>FileOutputStream(File file, boolean append)</code>：同上，但 <code>append</code> 参数决定是追加还是覆盖。<code>true</code> 表示追加到文件末尾，<code>false</code> 表示覆盖原文件。</li>
<li><code>FileOutputStream(String name)</code>：创建一个向具有指定名称的文件写入数据的输出流。</li>
<li><code>FileOutputStream(String name, boolean append)</code>：同上，带追加模式。</li>
</ul>
<p><strong>使用示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 try-with-resources 语法，无需手动调用 close()</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="literal">true</span>)) &#123; <span class="comment">// true 表示追加模式</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 将字符串转换为字节数组并写入</span></span><br><span class="line">    fos.write(text.getBytes()); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以逐个字节写入</span></span><br><span class="line">    <span class="comment">// fos.write(&#x27;H&#x27;);</span></span><br><span class="line">    <span class="comment">// fos.write(&#x27;i&#x27;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新缓冲区 (对于FileOutputStream，每次write通常直接写盘，但刷新是好习惯)</span></span><br><span class="line">    fos.flush(); </span><br><span class="line">    System.out.println(<span class="string">&quot;数据写入成功！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点：</strong></p>
<ul>
<li>如果文件不存在，<code>FileOutputStream</code> 会<strong>自动创建</strong>该文件（但如果路径中的目录不存在，会抛出 <code>FileNotFoundException</code>）。</li>
<li>如果不指定 <code>append</code> 参数或设置为 <code>false</code>，<strong>每次创建流都会清空原文件内容</strong>。</li>
<li>它直接操作字节，所以如果你要写入字符串，需要调用 <code>String.getBytes()</code> 方法进行转换。</li>
</ul>
<hr>
<h3 id="3-3-InPutStream-输入流"><a href="#3-3-InPutStream-输入流" class="headerlink" title="3.3 InPutStream (输入流)"></a>3.3 InPutStream (输入流)</h3><p><code>InputStream</code> 是一个抽象类，是所有字节输入流的超类。它定义了从源读取字节的基本方法。</p>
<p><strong>主要方法：</strong></p>
<ul>
<li><code>int read()</code>：从输入流读取<strong>一个字节</strong>，返回的是读取到的字节值（0-255）。如果已到达流末尾，则返回 <code>-1</code>。</li>
<li><code>int read(byte[] b)</code>：从输入流中读取一些字节并将其存储到字节数组 <code>b</code> 中。返回实际读取的字节数，如果到达末尾则返回 <code>-1</code>。</li>
<li><code>int read(byte[] b, int off, int len)</code>：尝试读取最多 <code>len</code> 个字节到数组 <code>b</code> 中，从偏移量 <code>off</code> 开始存储。返回实际读取的字节数。</li>
<li><code>long skip(long n)</code>：跳过并丢弃此输入流中的 <code>n</code> 个字节数据。</li>
<li><code>int available()</code>：返回此流中<strong>立即可读</strong>的估计字节数（不是文件总大小）。</li>
<li><code>void close()</code>：关闭此输入流并释放资源。同样至关重要。</li>
</ul>
<hr>
<h3 id="3-4-FileInPutStream-文件输入流"><a href="#3-4-FileInPutStream-文件输入流" class="headerlink" title="3.4 FileInPutStream (文件输入流)"></a>3.4 FileInPutStream (文件输入流)</h3><p><code>FileInputStream</code> 是 <code>InputStream</code> 的子类，用于从文件系统中的某个文件获取输入字节，即读取文件内容。</p>
<p><strong>构造方法 (常用)：</strong></p>
<ul>
<li><code>FileInputStream(File file)</code>：通过打开一个到实际文件的连接来创建一个 <code>FileInputStream</code>，该文件通过文件系统中的 <code>File</code> 对象指定。</li>
<li><code>FileInputStream(String name)</code>：通过打开一个到实际文件的连接来创建一个 <code>FileInputStream</code>，该文件通过文件系统中的路径名 <code>name</code> 指定。</li>
</ul>
<p><strong>使用示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FISExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 try-with-resources</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 方法1：逐个字节读取 (效率低，不推荐用于大文件)</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            int content;</span></span><br><span class="line"><span class="comment">            while ((content = fis.read()) != -1) &#123;</span></span><br><span class="line"><span class="comment">                System.out.print((char) content); // 将字节转换为字符打印</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方法2：使用字节数组缓冲区读取 (高效，推荐)</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 1KB的缓冲区</span></span><br><span class="line">            <span class="type">int</span> bytesRead; <span class="comment">// 实际读取的字节数</span></span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 将读取到的字节转换为字符串并输出</span></span><br><span class="line">                <span class="comment">// 使用 0 到 bytesRead 的范围，避免读取旧数据</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">                System.out.print(text);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点：</strong></p>
<ul>
<li>如果指定的文件<strong>不存在</strong>，会抛出 <code>FileNotFoundException</code>。</li>
<li>使用缓冲区（<code>byte[]</code>）一次性读取多个字节，比逐个字节读取<strong>效率高得多</strong>，是标准做法。</li>
<li>它读取的是原始字节。如果你知道文件内容是文本，需要将其转换为字符串（<code>new String(byteArray)</code>），并注意字符编码问题（最好指定编码，如 <code>new String(buffer, 0, bytesRead, &quot;UTF-8&quot;)</code>）。</li>
</ul>
<hr>
<h2 id="4-字符流"><a href="#4-字符流" class="headerlink" title="4. 字符流"></a>4. 字符流</h2><h3 id="4-1-Reader（读取器）"><a href="#4-1-Reader（读取器）" class="headerlink" title="4.1 Reader（读取器）"></a>4.1 Reader（读取器）</h3><p><code>java.io.Reader</code> 是一个<strong>抽象类</strong>，定义了所有字符输入流的共同行为。</p>
<p><strong>主要方法：</strong></p>
<ul>
<li><code>int read()</code>: 读取<strong>单个字符</strong>。返回作为整数读取的字符，如果已到达流的末尾，则返回 -1。</li>
<li><code>int read(char[] cbuf)</code>: 将字符读入一个数组。返回实际读取的字符数，如果已到达流的末尾，则返回 -1。<strong>更高效</strong>，因为它减少了实际的物理读取次数。</li>
<li><code>int read(char[] cbuf, int off, int len)</code>: 将字符读入数组的某一部分。</li>
<li><code>void close()</code>: <strong>至关重要！</strong> 关闭流并释放与之关联的所有系统资源。必须在 finally 块中或使用 try-with-resources 语句来关闭，以避免资源泄漏。</li>
</ul>
<hr>
<h3 id="4-2-FileReder（文件读取器）"><a href="#4-2-FileReder（文件读取器）" class="headerlink" title="4.2 FileReder（文件读取器）"></a>4.2 FileReder（文件读取器）</h3><p><code>java.io.FileReader</code> 是 <code>InputStreamReader</code> 的子类，是专门用于从<strong>文件</strong>中读取字符数据的便捷类。</p>
<ul>
<li><strong>作用</strong>：它假定文件使用<strong>系统默认的字符编码</strong>（如 Windows 中文版可能是 GBK，macOS&#x2F;Linux 可能是 UTF-8）。这对于简单的、与平台紧密相关的文本读取很方便，但也是其主要缺点。</li>
<li><strong>缺点</strong>：无法指定编码。如果文件的编码与系统默认编码不同（例如，一个 UTF-8 编码的文件在默认编码为 GBK 的系统上读取），就会导致<strong>乱码</strong>。</li>
</ul>
<p><strong>构造方法</strong></p>
<ul>
<li><code>FileReader(String fileName)</code></li>
<li><code>FileReader(File file)</code></li>
</ul>
<p><strong>使用示例</strong><br>	这种方式会自动关闭资源，代码更简洁安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReaderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 在 try 语句中声明资源，会自动关闭</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;test.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> length;</span><br><span class="line">            <span class="keyword">while</span> ((length = reader.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-Writer（写入器）"><a href="#4-3-Writer（写入器）" class="headerlink" title="4.3 Writer（写入器）"></a>4.3 Writer（写入器）</h3><p><code>java.io.Writer</code> 是一个<strong>抽象类</strong>，定义了所有字符输出流的共同行为。</p>
<p><strong>主要方法：</strong></p>
<ul>
<li><code>void write(int c)</code>: 写入<strong>单个字符</strong>。</li>
<li><code>void write(char[] cbuf)</code>: 写入一个字符数组。</li>
<li><code>void write(char[] cbuf, int off, int len)</code>: 写入字符数组的某一部分。</li>
<li><code>void write(String str)</code>: 写入一个字符串。</li>
<li><code>void write(String str, int off, int len)</code>: 写入字符串的某一部分。</li>
<li><code>void flush()</code>: <strong>刷新</strong>该流。如果缓冲区中有任何字符，立即将它们强制写入目标文件。写入器通常是有缓冲的。</li>
<li><code>void close()</code>: 关闭流，先刷新它。关闭后再调用 write() 或 flush() 将抛出异常。</li>
</ul>
<hr>
<h3 id="4-4-FileWriter（文件写入器）"><a href="#4-4-FileWriter（文件写入器）" class="headerlink" title="4.4 FileWriter（文件写入器）"></a>4.4 FileWriter（文件写入器）</h3><p><code>java.io.FileWriter</code> 是 <code>OutputStreamWriter</code> 的子类，是专门用于向<strong>文件</strong>写入字符数据的便捷类。</p>
<ul>
<li><strong>作用</strong>：它使用<strong>系统默认的字符编码</strong>将字符写入文件。同样，这可能导致在不同编码环境的系统上出现写入乱码的问题。</li>
<li><strong>模式</strong>：构造函数可以接受一个 <code>boolean</code> 参数来指定是<strong>追加</strong>（append）还是<strong>覆盖</strong>（overwrite）文件。<ul>
<li><code>FileWriter(String fileName, boolean append)</code></li>
<li><code>append</code> 为 <code>true</code>：将数据追加到文件末尾。</li>
<li><code>append</code> 为 <code>false</code> 或默认：清空原文件内容再写入。</li>
</ul>
</li>
</ul>
<p><strong>构造方法</strong></p>
<ul>
<li><code>FileWriter(String fileName)</code> （覆盖模式）</li>
<li><code>FileWriter(String fileName, boolean append)</code> （追加模式）</li>
<li><code>FileWriter(File file)</code></li>
<li><code>FileWriter(File file, boolean append)</code></li>
</ul>
<p><strong>使用示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 try-with-resources 自动关闭，注意这里设置为追加模式 (true)</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="literal">true</span>)) &#123; </span><br><span class="line">            writer.write(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="string">&quot;这是一段中文。\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="number">65</span>); <span class="comment">// 写入字符 &#x27;A&#x27;</span></span><br><span class="line">            <span class="comment">// 不需要显式调用 flush()，因为 close() 会自动调用它</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-缓冲流"><a href="#5-缓冲流" class="headerlink" title="5. 缓冲流"></a>5. 缓冲流</h2><p>在内存中创建一个<strong>缓冲区</strong>（一个字节或字符数组）。当进行读写操作时，数据首先被批量地读取到缓冲区中，或从缓冲区中批量地写入。这样就极大地减少了与实际物理设备（如硬盘）的直接交互次数。</p>
<h3 id="5-1-BufferedInputStream-BufferedOutputStream（字节缓冲流）"><a href="#5-1-BufferedInputStream-BufferedOutputStream（字节缓冲流）" class="headerlink" title="5.1 BufferedInputStream &amp; BufferedOutputStream（字节缓冲流）"></a>5.1 BufferedInputStream &amp; BufferedOutputStream（字节缓冲流）</h3><p>它们为字节流提供缓冲，是 <code>FilterInputStream</code> 和 <code>FilterOutputStream</code> 的子类。</p>
<p><strong>核心方法（与其父类基本一致，但带缓冲）：</strong></p>
<ul>
<li><code>read()</code>: 读取一个字节。</li>
<li><code>read(byte[] b)</code>: 读取多个字节到数组。</li>
<li><code>write(int b)</code>: 写入一个字节。</li>
<li><code>write(byte[] b, int off, int len)</code>: 写入字节数组的一部分。</li>
</ul>
<p><strong>示例：复制一个文件（效率远超逐个字节复制）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedByteStreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;source.jpg&quot;</span>);</span><br><span class="line">             <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis); <span class="comment">// 包装</span></span><br><span class="line">             <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;target.jpg&quot;</span>);</span><br><span class="line">             <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos)) &#123; <span class="comment">// 包装</span></span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span>]; <span class="comment">// 8KB 的缓冲区</span></span><br><span class="line">            <span class="type">int</span> length;</span><br><span class="line">            <span class="comment">// bis.read(buffer) 会尝试一次性从文件中读取最多 8KB 数据到 buffer</span></span><br><span class="line">            <span class="keyword">while</span> ((length = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// bos.write(buffer, 0, length) 将 buffer 中的数据写入内部缓冲区</span></span><br><span class="line">                bos.write(buffer, <span class="number">0</span>, length); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// try-with-resources 自动关闭流，在关闭 bos 前会自动调用 flush() 将缓冲区数据强制写入文件</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-2-BufferedReader-BufferedWriter（字符缓冲流）"><a href="#5-2-BufferedReader-BufferedWriter（字符缓冲流）" class="headerlink" title="5.2 BufferedReader &amp; BufferedWriter（字符缓冲流）"></a>5.2 BufferedReader &amp; BufferedWriter（字符缓冲流）</h3><p>它们为字符流提供缓冲，是 <code>Reader</code> 和 <code>Writer</code> 的子类。它们比字节缓冲流更常用，因为提供了额外的方法。</p>
<p><strong><code>BufferedReader</code> 的核心增强方法：</strong></p>
<ul>
<li><code>String readLine()</code>: <strong>读取一行文本</strong>。遇到换行符 (<code>&#39;\n&#39;</code>)、回车符 (<code>&#39;\r&#39;</code>) 或回车后直接跟着换行 (<code>&quot;\r\n&quot;</code>) 时停止。返回的字符串不包含行终止符。如果已到达流末尾，则返回 <code>null</code>。这是读取文本文件最常用的方法。</li>
</ul>
<p><strong><code>BufferedWriter</code> 的核心增强方法：</strong></p>
<ul>
<li><code>void newLine()</code>: <strong>写入一个行分隔符</strong>。这个方法会根据操作系统自动选择正确的行分隔符（<code>\n</code>、<code>\r</code> 或 <code>\r\n</code>），比直接写 <code>&quot;\n&quot;</code> 更可移植。</li>
</ul>
<p><strong>示例：读写文本文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedCharStreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 读取一个文本文件并打印到控制台</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line">             <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr)) &#123;</span><br><span class="line"></span><br><span class="line">            String line;</span><br><span class="line">            <span class="comment">// 使用 readLine() 方法逐行读取，非常方便</span></span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将内容写入一个文本文件</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">             <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw)) &#123;</span><br><span class="line"></span><br><span class="line">            bw.write(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">            bw.newLine(); <span class="comment">// 换行</span></span><br><span class="line">            bw.write(<span class="string">&quot;这是第二行。&quot;</span>);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            <span class="comment">// 无需手动 flush(), close() 会自动执行</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-数据流"><a href="#6-数据流" class="headerlink" title="6. 数据流"></a>6. 数据流</h2><h3 id="6-1-核心功能与应用场景"><a href="#6-1-核心功能与应用场景" class="headerlink" title="6.1 核心功能与应用场景"></a><strong>6.1 核心功能与应用场景</strong></h3><h4 id="6-1-1-核心功能"><a href="#6-1-1-核心功能" class="headerlink" title="6.1.1 核心功能"></a>6.1.1 核心功能</h4><ul>
<li><strong>类型保持 (Type Preservation):</strong> 数据流的核心功能是允许你直接写入一个 <code>int</code>，读取时也能直接得到一个 <code>int</code>。它负责将Java基本类型与其二进制表示进行转换。例如，<code>writeInt(65)</code> 会写入4个字节的二进制数据，而不是字符’A’或字符串”65”的字节。</li>
<li><strong>平台无关性 (Platform Independence):</strong> 数据流以一种标准化的方式写入数据（例如，使用大端字节序 Big-Endian），确保了在任何Java虚拟机（JVM）上写入的数据，都可以在其他任何JVM上被正确读取，无需担心底层操作系统的差异。</li>
<li><strong>二进制格式 (Binary Format):</strong> 数据以紧凑的二进制格式存储，通常比文本格式（如XML、JSON）占用更少的空间，读写速度也更快。但是，生成的文件是不可直接阅读的。</li>
<li><strong>方便的API (Convenient API):</strong> 提供了如 <code>writeInt()</code>, <code>readDouble()</code>, <code>writeUTF()</code> 等一系列直观的方法，使得操作基本数据类型变得非常简单。</li>
</ul>
<hr>
<h4 id="6-1-2-典型应用场景"><a href="#6-1-2-典型应用场景" class="headerlink" title="6.1.2 典型应用场景"></a>6.1.2 典型应用场景</h4><ul>
<li><strong>简单的数据持久化 (Simple Data Persistence):</strong> 当你需要存储一些结构化但非复杂对象的数据时，数据流是一个很好的选择。</li>
<li><strong>自定义二进制文件格式 (Custom Binary File Formats):</strong> 当你需要定义一个私有的、高效的二进制文件格式来存储数据时，数据流是理想的工具。</li>
<li><strong>网络通信 (Network Communication):</strong> 在基于Java的客户端&#x2F;服务器之间进行通信时，可以使用数据流来定义一个简单的应用层协议。例如，发送消息长度（<code>int</code>），后跟一个消息（<code>String</code>）。</li>
</ul>
<hr>
<h3 id="6-2-DataOutputStream-数据输出流"><a href="#6-2-DataOutputStream-数据输出流" class="headerlink" title="6.2 DataOutputStream (数据输出流)"></a>6.2 DataOutputStream (数据输出流)</h3><h4 id="6-2-1-构造方法"><a href="#6-2-1-构造方法" class="headerlink" title="6.2.1 构造方法"></a>6.2.1 构造方法</h4><p>它只有一个构造方法，用于包装一个已存在的 <code>OutputStream</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DataOutputStream</span><span class="params">(OutputStream out)</span></span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数据写入文件 data.dat</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data.dat&quot;</span>);</span><br><span class="line"><span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了提高效率，通常会再包装一层缓冲流</span></span><br><span class="line"><span class="type">DataOutputStream</span> <span class="variable">dosBuffered</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(</span><br><span class="line">                                 <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(</span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data.dat&quot;</span>)</span><br><span class="line">                                 )</span><br><span class="line">                             );</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-2-2-核心方法"><a href="#6-2-2-核心方法" class="headerlink" title="6.2.2 核心方法"></a>6.2.2 核心方法</h4><ul>
<li><code>void writeInt(int v)</code>: 将一个 <code>int</code> 值作为4字节数据写入。</li>
<li><code>void writeDouble(double v)</code>: 将一个 <code>double</code> 值作为8字节数据写入。</li>
<li><code>void writeBoolean(boolean v)</code>: 将一个 <code>boolean</code> 值作为1字节数据写入（1表示<code>true</code>，0表示<code>false</code>）。</li>
<li><code>void writeLong(long v)</code>: 将一个 <code>long</code> 值作为8字节数据写入。</li>
<li><code>void writeFloat(float v)</code>: 将一个 <code>float</code> 值作为4字节数据写入。</li>
<li><code>void writeShort(int v)</code>: 将一个 <code>short</code> 值作为2字节数据写入。</li>
<li><code>void writeByte(int v)</code>: 将一个 <code>byte</code> 值作为1字节数据写入。</li>
<li><code>void writeChar(int v)</code>: 将一个 <code>char</code> 值作为2字节数据写入。</li>
<li><code>void writeUTF(String str)</code>: 以一种改进的UTF-8编码格式写入字符串。它会先写入两个字节表示字符串的长度，然后才是字符串的内容。这使得 <code>readUTF()</code> 知道需要读取多少字节。</li>
<li><code>void flush()</code>: 刷新此数据输出流。这迫使所有缓冲的输出字节被写出到底层流。</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;player.dat&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Knight&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">75</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">health</span> <span class="operator">=</span> <span class="number">98.5</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasKey</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    dos.writeUTF(name);</span><br><span class="line">    dos.writeInt(level);</span><br><span class="line">    dos.writeDouble(health);</span><br><span class="line">    dos.writeBoolean(hasKey);</span><br><span class="line">    </span><br><span class="line">    dos.flush(); <span class="comment">// 确保数据写入文件</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-3-DataInputStream-数据输入流"><a href="#6-3-DataInputStream-数据输入流" class="headerlink" title="6.3 DataInputStream (数据输入流)"></a>6.3 DataInputStream (数据输入流)</h3><h4 id="6-3-1-构造方法"><a href="#6-3-1-构造方法" class="headerlink" title="6.3.1 构造方法"></a>6.3.1 构造方法</h4><p>同样，它也只有一个构造方法，用于包装一个已存在的 <code>InputStream</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DataInputStream</span><span class="params">(InputStream in)</span></span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从文件 data.dat 读取数据</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.dat&quot;</span>);</span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(fis);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样，推荐结合缓冲流使用</span></span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">disBuffered</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(</span><br><span class="line">                                 <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.dat&quot;</span>)</span><br><span class="line">                                 )</span><br><span class="line">                             );</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-3-2-核心方法"><a href="#6-3-2-核心方法" class="headerlink" title="6.3.2 核心方法"></a>6.3.2 核心方法</h4><p>核心方法与 <code>DataOutputStream</code> 的写入方法一一对应：</p>
<ul>
<li><code>int readInt()</code></li>
<li><code>double readDouble()</code></li>
<li><code>boolean readBoolean()</code></li>
<li><code>long readLong()</code></li>
<li><code>float readFloat()</code></li>
<li><code>short readShort()</code></li>
<li><code>byte readByte()</code></li>
<li><code>char readChar()</code></li>
<li><code>String readUTF()</code></li>
</ul>
<p><strong>代码示例 (读取上面写入的数据):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;player.dat&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">    <span class="type">double</span> <span class="variable">health</span> <span class="operator">=</span> dis.readDouble();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasKey</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Name: &quot;</span> + name);</span><br><span class="line">    System.out.println(<span class="string">&quot;Level: &quot;</span> + level);</span><br><span class="line">    System.out.println(<span class="string">&quot;Health: &quot;</span> + health);</span><br><span class="line">    System.out.println(<span class="string">&quot;Has Key: &quot;</span> + hasKey);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (EOFException e) &#123;</span><br><span class="line">    <span class="comment">// 当读取到文件末尾时，会抛出此异常，这是正常结束的标志</span></span><br><span class="line">    System.out.println(<span class="string">&quot;数据读取完毕。&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-4-重要注意事项"><a href="#6-4-重要注意事项" class="headerlink" title="6.4 重要注意事项"></a>6.4 重要注意事项</h3><ol>
<li><p><strong>读写顺序必须严格一致 (Read&#x2F;Write Order Must Be Identical):</strong> 这是使用数据流时最重要、也最容易出错的一点。必须以写入时完全相同的顺序和类型来读取数据。如果写入顺序是 <code>int -&gt; double -&gt; String</code>，那么读取顺序也必须是 <code>readInt() -&gt; readDouble() -&gt; readUTF()</code>。任何顺序或类型的错乱都会导致数据损坏或抛出异常。</p>
</li>
<li><p><strong><code>EOFException</code> 的正确处理 (Correctly Handling <code>EOFException</code>):</strong> 当使用 <code>readXxx()</code> 方法尝试从一个已经没有数据的流中读取时，会抛出 <code>java.io.EOFException</code> (End Of File Exception)。这通常不是一个程序错误，而是<strong>程序正常结束读取的信号</strong>。因此，在循环读取未知长度的数据时，通常将读取逻辑放在 <code>try</code> 块内，并捕获 <code>EOFException</code> 来优雅地终止循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环读取多个记录的模式</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;records.dat&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">        <span class="comment">// ... process record</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (EOFException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;所有记录读取完成。&quot;</span>); <span class="comment">// 正常退出循环</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// 其他IO错误</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>非对象序列化 (Not for Object Serialization):</strong> 数据流只能处理基本类型和 <code>String</code>。它不能直接写入或读取一个复杂的Java对象（例如一个 <code>Player</code>类的实例）。要实现对象的持久化，需要使用后面提到的对象流 (<code>ObjectOutputStream</code>)。</p>
</li>
<li><p><strong>与缓冲流结合 (Combining with Buffered Streams):</strong> 对于文件或网络IO，每次 <code>writeXxx()</code> 或 <code>readXxx()</code> 都可能触发一次底层的IO操作，这非常低效。强烈建议在数据流和节点流之间加入缓冲流（<code>BufferedInputStream</code> &#x2F; <code>BufferedOutputStream</code>），以显著提高性能。缓冲流会将多次小规模的读写操作合并为一次大规模的IO操作。</p>
</li>
</ol>
<hr>
<h2 id="7-字符编码与转换流"><a href="#7-字符编码与转换流" class="headerlink" title="7. 字符编码与转换流"></a>7. 字符编码与转换流</h2><h3 id="7-1-编码与解码"><a href="#7-1-编码与解码" class="headerlink" title="7.1 编码与解码"></a>7.1 编码与解码</h3><h4 id="7-1-1-字符编码-Character-Encoding"><a href="#7-1-1-字符编码-Character-Encoding" class="headerlink" title="7.1.1 字符编码 (Character Encoding)"></a>7.1.1 字符编码 (Character Encoding)</h4><p>这是最常见、最基础的编码类型，解决了“如何用二进制数字表示文字”的问题。</p>
<ul>
<li><strong>问题</strong>：计算机如何表示 <code>A</code>, <code>中</code>, <code>😊</code> 这些字符？</li>
<li><strong>编码过程</strong>：字符 -&gt; 二进制数字（编号）</li>
<li><strong>解码过程</strong>：二进制数字（编号） -&gt; 字符</li>
</ul>
<p><strong>常见标准：</strong></p>
<ul>
<li><p><strong>ASCII</strong>：最早的标准，用7位二进制数（0-127）表示英文字母、数字和一些控制符。只能处理英文。</p>
</li>
<li><p><strong>GB2312&#x2F;GBK</strong>：中国制定的国家标准，用2个字节表示汉字和中文符号，兼容ASCII。解决了中文编码问题（简体中文版Windows系统默认使用的就是GBK,系统显示ANSI）。</p>
</li>
<li><p><strong>Unicode</strong>：<strong>终极解决方案</strong>，旨在包含世界上所有文字和符号。它为每个字符分配一个<strong>唯一的编号（码点）</strong>，例如 <code>A</code> 的码点是 <code>U+0041</code>， <code>中</code> 的码点是 <code>U+4E2D</code>。</p>
</li>
<li><p><strong>UTF-8</strong>：<strong>Unicode的一种实现方式（编码格式）</strong>，是目前互联网上最主流的编码。它最大的优点是<strong>变长编码</strong>，兼容ASCII（ASCII字符用1个字节，汉字通常用3个字节），非常节省空间。</p>
<pre><code class="highlight mermaid">graph TD
    A[&quot;
    &lt;div style=&#x27;text-align:left;&#x27;&gt;
    &lt;b&gt;UTF-8编码方式&lt;/b&gt;
    &lt;hr&gt;
    0xxxxxxx (ASCII码)
    &lt;hr&gt;
    110xxxxx&amp;nbsp;10xxxxxx
    &lt;hr&gt;
    1110xxxx&amp;nbsp;10xxxxxx&amp;nbsp;10xxxxxx
    &lt;hr&gt;
    11110xxx&amp;nbsp;10xxxxxx&amp;nbsp;10xxxxxx&amp;nbsp;10xxxxxx
    &lt;/div&gt;
    &quot;]

    style A fill:#222, stroke:#fff, color:#fff</code></pre></li>
</ul>
<p><strong>示例：</strong></p>
<p>字符串 “Hello中文” 保存到文件：</p>
<ol>
<li><strong>编码</strong>：程序根据UTF-8规则，将每个字符转换成对应的二进制序列。<ul>
<li><code>H</code> -&gt; <code>01001000</code> (1字节)</li>
<li><code>中</code> -&gt; <code>11100100 10111000 10101101</code> (3字节)</li>
<li>…等等</li>
</ul>
</li>
<li>硬盘存储的是这一长串二进制位。</li>
<li><strong>解码</strong>：另一个程序打开文件，识别出这是UTF-8编码（通常通过文件头部的BOM或上下文推断），然后根据UTF-8规则，将二进制序列一一对应地转换回字符 <code>H</code>, <code>中</code> 等，最终正确显示 “Hello中文”。</li>
</ol>
<p><strong>乱码的产生</strong>：当用错误的编码方式去解码时就会发生。例如，一个用UTF-8编码的“中文”文本，如果你用GBK编码去打开，就会显示成一堆无意义的乱码，如“涓枃”。</p>
<hr>
<h4 id="7-1-2-多媒体编码-Multimedia-Encoding"><a href="#7-1-2-多媒体编码-Multimedia-Encoding" class="headerlink" title="7.1.2 多媒体编码 (Multimedia Encoding)"></a>7.1.2 多媒体编码 (Multimedia Encoding)</h4><p>解决了“如何用二进制数字表示图片、声音、视频”的问题。</p>
<ul>
<li><strong>图片编码 (JPEG, PNG, GIF)</strong><ul>
<li><strong>编码</strong>：将图片的像素点、颜色等信息通过压缩算法转换成二进制文件。JPEG是有损压缩（适合照片），PNG是无损压缩（适合图标）。</li>
<li><strong>解码</strong>：图形软件（如浏览器）读取二进制文件，根据编码规则解压缩，还原出像素点阵，在屏幕上渲染出来。</li>
</ul>
</li>
<li><strong>音频编码 (MP3, AAC, WAV)</strong><ul>
<li><strong>编码</strong>：将模拟的声波信号进行采样、量化和压缩，转换成二进制文件。MP3是有损压缩，会去除人耳不敏感的声音数据。</li>
<li><strong>解码</strong>：播放器读取二进制文件，解压缩，通过数模转换（DAC）还原成模拟电信号，驱动扬声器发出声音。</li>
</ul>
</li>
<li><strong>视频编码 (H.264&#x2F;AVC, H.265&#x2F;HEVC, AV1)</strong><ul>
<li><strong>视频本质</strong>是一系列连续播放的图片（帧）加上同步的音频。</li>
<li><strong>编码</strong>：利用帧与帧之间的相似性（连续画面变化很小）进行<strong>极度压缩</strong>，只存储前后帧的差异部分。这是视频文件远比图片序列小的原因。</li>
<li><strong>解码</strong>：播放器（如VLC, 哔哩哔哩客户端）读取视频文件，解压缩，逐帧还原出图像，并与音频同步播放。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="7-1-3-传输编码-Transfer-Encoding"><a href="#7-1-3-传输编码-Transfer-Encoding" class="headerlink" title="7.1.3 传输编码 (Transfer Encoding)"></a>7.1.3 传输编码 (Transfer Encoding)</h4><p>为了解决在特定传输环境中（如电子邮件、URL）安全可靠地传递数据。</p>
<ul>
<li><strong>URL编码 (Percent-Encoding)</strong><ul>
<li><strong>问题</strong>：URL中不能直接使用一些特殊字符，如 <code>空格</code>, <code>&amp;</code>, <code>=</code>，因为它们有特殊含义。</li>
<li><strong>编码</strong>：将特殊字符转换为 <code>%</code> 后跟两位十六进制数的形式。<ul>
<li>例如，空格被编码为 <code>%20</code>。</li>
</ul>
</li>
<li><strong>解码</strong>：浏览器或服务器收到URL后，会将 <code>%20</code> 还原回空格。</li>
</ul>
</li>
<li><strong>Base64编码</strong><ul>
<li><strong>问题</strong>：电子邮件协议最初设计为只传输ASCII文本，无法直接传输二进制文件（如图片、附件）。</li>
<li><strong>编码</strong>：将二进制数据转换成由 <code>A-Z, a-z, 0-9, +, /</code> 组成的文本字符串。</li>
<li><strong>解码</strong>：将Base64字符串还原回原始的二进制数据。</li>
<li><strong>应用</strong>：Data URLs（在HTML&#x2F;CSS中嵌入图片）、电子邮件附件、在XML&#x2F;JSON中安全地传输二进制数据。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="7-1-4-加密与解密-Encryption-Decryption"><a href="#7-1-4-加密与解密-Encryption-Decryption" class="headerlink" title="7.1.4 加密与解密 (Encryption &amp; Decryption)"></a>7.1.4 加密与解密 (Encryption &amp; Decryption)</h4><p>一种以安全保密为目的的特殊编码。</p>
<ul>
<li><strong>编码（加密）</strong>：使用<strong>密钥</strong>和加密算法（如AES）将原始数据（明文）转换为不可读的乱码（密文）。</li>
<li><strong>解码（解密）</strong>：使用正确的<strong>密钥</strong>和解密算法将密文还原为明文。</li>
<li><strong>核心</strong>：没有密钥，即使知道编码规则也无法解码。</li>
</ul>
<hr>
<h3 id="7-2-InputStreamReader-OutPutStreamWriter"><a href="#7-2-InputStreamReader-OutPutStreamWriter" class="headerlink" title="7.2 InputStreamReader &amp; OutPutStreamWriter"></a>7.2 InputStreamReader &amp; OutPutStreamWriter</h3><h4 id="7-2-1-InputStreamReader"><a href="#7-2-1-InputStreamReader" class="headerlink" title="7.2.1 InputStreamReader"></a>7.2.1 InputStreamReader</h4><p><code>InputStreamReader</code> 是 <code>Reader</code> 的子类，它从底层的字节输入流读取字节，并使用指定的字符编码将其解码为字符。</p>
<h5 id="1-关键构造函数"><a href="#1-关键构造函数" class="headerlink" title="1. 关键构造函数"></a>1. 关键构造函数</h5><ul>
<li><code>InputStreamReader(InputStream in)</code><ul>
<li>创建一个使用<strong>平台默认字符集</strong>的 InputStreamReader。</li>
<li><strong>注意</strong>：依赖于系统默认编码，不利于跨平台，一般不推荐使用。</li>
<li><code>InputStreamReader isr = new InputStreamReader(System.in); // 从标准输入读取</code></li>
</ul>
</li>
<li><code>InputStreamReader(InputStream in, String charsetName)</code><ul>
<li>创建一个使用<strong>指定字符集</strong>的 InputStreamReader。</li>
<li><code>CharsetName</code> 可以是标准字符集名称，如 “UTF-8”, “GBK”, “ISO-8859-1” 等。</li>
<li><code>InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;file.txt&quot;), &quot;UTF-8&quot;);</code></li>
</ul>
</li>
<li><code>InputStreamReader(InputStream in, Charset cs)</code><ul>
<li>使用指定的 <code>Charset</code> 对象创建 InputStreamReader。这是更现代和推荐的方式。</li>
<li><code>InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;file.txt&quot;), StandardCharsets.UTF_8);</code></li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h5><p>当你调用 <code>isr.read()</code> 时，会发生以下步骤：</p>
<ol>
<li><code>InputStreamReader</code> 从其内部的 <code>InputStream</code>（例如 <code>FileInputStream</code>）中读取一个或多个字节。</li>
<li>这些字节根据创建 <code>InputStreamReader</code> 时指定的字符编码规则进行解码。</li>
<li>将解码后的结果返回为一个Unicode字符（<code>char</code>）。</li>
</ol>
<hr>
<h5 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h5><p>继承自 <code>Reader</code> 类：</p>
<ul>
<li><code>int read()</code>: 读取单个字符。</li>
<li><code>int read(char[] cbuf)</code>: 将字符读入数组。</li>
<li><code>int read(char[] cbuf, int off, int len)</code>: 将字符读入数组的某一部分。</li>
<li><code>void close()</code>: 关闭流。</li>
</ul>
<hr>
<h4 id="7-2-2-OutputStreamWriter"><a href="#7-2-2-OutputStreamWriter" class="headerlink" title="7.2.2 OutputStreamWriter"></a>7.2.2 OutputStreamWriter</h4><p><code>OutputStreamWriter</code> 是 <code>Writer</code> 的子类，它接收字符，使用指定的字符编码将其编码为字节，然后写入底层的字节输出流。</p>
<h5 id="1-关键构造函数-1"><a href="#1-关键构造函数-1" class="headerlink" title="1. 关键构造函数"></a>1. 关键构造函数</h5><ul>
<li><code>OutputStreamWriter(OutputStream out)</code><ul>
<li>创建一个使用<strong>平台默认字符集</strong>的 OutputStreamWriter。（不推荐）</li>
</ul>
</li>
<li><code>OutputStreamWriter(OutputStream out, String charsetName)</code><ul>
<li>创建一个使用<strong>指定字符集</strong>的 OutputStreamWriter。</li>
<li><code>OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;output.txt&quot;), &quot;GBK&quot;);</code></li>
</ul>
</li>
<li><code>OutputStreamWriter(OutputStream out, Charset cs)</code><ul>
<li>使用指定的 <code>Charset</code> 对象创建 OutputStreamWriter。</li>
<li><code>OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;output.txt&quot;), StandardCharsets.UTF_8);</code></li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-工作原理-1"><a href="#2-工作原理-1" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h5><p>当你调用 <code>osw.write(&#39;你&#39;)</code> 时，会发生以下步骤：</p>
<ol>
<li>字符 ‘你’（一个Unicode码点）被送入 <code>OutputStreamWriter</code>。</li>
<li><code>OutputStreamWriter</code> 根据创建时指定的字符编码规则（如UTF-8）将这个字符编码为一个或多个字节。</li>
<li>这些被编码后的字节被写入其内部的 <code>OutputStream</code>（例如 <code>FileOutputStream</code>），最终被写入文件或网络。</li>
</ol>
<hr>
<h5 id="3-常用方法-1"><a href="#3-常用方法-1" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h5><p>继承自 <code>Writer</code> 类：</p>
<ul>
<li><code>void write(int c)</code>: 写入单个字符。</li>
<li><code>void write(char[] cbuf)</code>: 写入字符数组。</li>
<li><code>void write(String str)</code>: 写入字符串。</li>
<li><code>void flush()</code>: 刷新流的缓冲，立即将缓冲区的数据写入目的地。</li>
<li><code>void close()</code>: 关闭流，关闭前会先刷新。</li>
</ul>
<hr>
<h2 id="8-序列流【存在安全风险，不推荐使用，有现代替代方案】"><a href="#8-序列流【存在安全风险，不推荐使用，有现代替代方案】" class="headerlink" title="8 序列流【存在安全风险，不推荐使用，有现代替代方案】"></a>8 序列流【存在安全风险，不推荐使用，有现代替代方案】</h2><h3 id="8-1-序列化"><a href="#8-1-序列化" class="headerlink" title="8.1 序列化"></a>8.1 序列化</h3><h4 id="8-1-1-概念"><a href="#8-1-1-概念" class="headerlink" title="8.1.1 概念"></a>8.1.1 概念</h4><p><strong>序列化（Serialization）</strong> 是指将一个对象的状态信息（即它的数据字段）转换为可以存储或传输的形式的过程。在 Java 中，这个“形式”通常是一个字节序列（byte stream）。</p>
<p><strong>反序列化（Deserialization）</strong> 则是相反的过程，它将从存储或传输中得到的字节序列重新构造成一个内存中的对象。</p>
<p>简单来说：</p>
<ul>
<li><strong>序列化：</strong> <code>Object</code> → <strong>字节流</strong> (可用于保存到文件、存入数据库、通过网络发送)</li>
<li><strong>反序列化：</strong> <strong>字节流</strong> → <code>Object</code></li>
</ul>
<hr>
<h4 id="8-1-2-Serializable-接口的核心角色"><a href="#8-1-2-Serializable-接口的核心角色" class="headerlink" title="8.1.2 Serializable 接口的核心角色"></a>8.1.2 <code>Serializable</code> 接口的核心角色</h4><p>Java 的序列化机制核心是一个标记接口（Marker Interface）—— <code>java.io.Serializable</code>。</p>
<ul>
<li><strong>标记接口（Marker Interface）</strong>：这种接口内部没有任何方法或字段。它仅仅像一个“标签”或“许可证”，用于告诉 Java 虚拟机（JVM）：“这个类的对象是可以被序列化的”。</li>
<li>如果一个类没有实现 <code>Serializable</code> 接口，尝试对其对象进行序列化将会抛出 <code>NotSerializableException</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="8-1-3-实现"><a href="#8-1-3-实现" class="headerlink" title="8.1.3 实现"></a>8.1.3 实现</h4><p> <strong>第一步：让目标类实现 <code>Serializable</code> 接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String password; <span class="comment">// 使用 transient 关键字，这个变量不会被序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法、getter、setter 等</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略 getter 和 setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步：使用 <code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializationDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>, <span class="string">&quot;secret123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化对象到文件 (序列化)</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;person.ser&quot;</span>);</span><br><span class="line">             <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut)) &#123;</span><br><span class="line"></span><br><span class="line">            out.writeObject(person); <span class="comment">// 关键方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Serialized data is saved in person.ser&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException i) &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从文件反序列化对象 (反序列化)</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">deserializedPerson</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;person.ser&quot;</span>);</span><br><span class="line">             <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn)) &#123;</span><br><span class="line"></span><br><span class="line">            deserializedPerson = (Person) in.readObject(); <span class="comment">// 关键方法</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException i) &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证反序列化后的对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Deserialized Person...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + deserializedPerson.getName()); <span class="comment">// 输出: Alice</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Age: &quot;</span> + deserializedPerson.getAge());   <span class="comment">// 输出: 30</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Password: &quot;</span> + deserializedPerson.getPassword()); <span class="comment">// 输出: null (因为被 transient 修饰)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="8-1-4-关键特性与深入概念"><a href="#8-1-4-关键特性与深入概念" class="headerlink" title="8.1.4 关键特性与深入概念"></a>8.1.4 关键特性与深入概念</h4><h5 id="1-serialVersionUID"><a href="#1-serialVersionUID" class="headerlink" title="1. serialVersionUID"></a>1. <code>serialVersionUID</code></h5><p><strong>概念</strong>：一个类的序列化版本号。它是一个 <code>private static final long</code> 常量。</p>
<p><strong>用途</strong>：JVM 使用这个 ID 来验证序列化的发送者和接收者是否加载了与序列化兼容的类。如果反序列化时类的 <code>serialVersionUID</code> 与序列化时的值不匹配，就会抛出 <code>InvalidClassException</code>。</p>
<p><strong>最佳实践</strong>：如果你不显式声明，JVM 会根据类的细节（类名、成员、方法等）自动生成一个。一旦类发生任何更改（比如增加一个无关紧要的方法），自动生成的 ID 就会改变，导致之前序列化的对象无法反序列化。</p>
<p><strong>声明：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; <span class="comment">// 可以是任意 long 值，通常从 1L 开始</span></span><br><span class="line">    <span class="comment">// ... 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-transient-关键字"><a href="#2-transient-关键字" class="headerlink" title="2. transient 关键字"></a>2. <code>transient</code> 关键字</h5><ul>
<li>用于修饰成员变量，表示该变量<strong>不应</strong>被序列化。</li>
<li>常用于存储敏感信息（如密码、密钥）或临时性、重建成本很低的数据（如线程池、文件句柄等）。</li>
<li>反序列化后，<code>transient</code> 变量的值会被设置为其类型的默认值（如对象为 <code>null</code>，<code>int</code> 为 <code>0</code>，<code>boolean</code> 为 <code>false</code>）。</li>
</ul>
<hr>
<h5 id="3-继承关系中的序列化"><a href="#3-继承关系中的序列化" class="headerlink" title="3. 继承关系中的序列化"></a>3. 继承关系中的序列化</h5><ul>
<li><strong>如果一个父类实现了 <code>Serializable</code>，其子类自动也是可序列化的。</strong></li>
<li>如果一个子类实现了 <code>Serializable</code>，但其父类没有：<ul>
<li>反序列化子类对象时，父类的<strong>无参构造方法</strong>会被自动调用，以初始化父类的字段。因此，父类必须有一个可访问的无参构造器，否则会抛出 <code>InvalidClassException</code>。</li>
<li>父类中定义的字段不会被序列化（因为它们不属于可序列化的类）。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-自定义序列化过程：writeObject-和-readObject"><a href="#4-自定义序列化过程：writeObject-和-readObject" class="headerlink" title="4. 自定义序列化过程：writeObject 和 readObject"></a>4. 自定义序列化过程：<code>writeObject</code> 和 <code>readObject</code></h5><p>如果你需要对序列化和反序列化的过程进行精确控制（例如，加密敏感数据、验证对象状态），可以在你的类中定义这两个私有方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 可以先对数据进行一些处理，例如加密密码字段（伪代码）</span></span><br><span class="line">    <span class="comment">// this.encryptedPassword = encrypt(this.password);</span></span><br><span class="line">    out.defaultWriteObject(); <span class="comment">// 执行默认的序列化机制</span></span><br><span class="line">    <span class="comment">// 还可以写入更多的自定义数据</span></span><br><span class="line">    <span class="comment">// out.writeInt(this.someExtraValue);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    in.defaultReadObject(); <span class="comment">// 执行默认的反序列化机制</span></span><br><span class="line">    <span class="comment">// 然后处理自定义的数据</span></span><br><span class="line">    <span class="comment">// this.someExtraValue = in.readInt();</span></span><br><span class="line">    <span class="comment">// 最后对数据进行后处理，例如解密密码字段（伪代码）</span></span><br><span class="line">    <span class="comment">// this.password = decrypt(this.encryptedPassword);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-特殊方法：readResolve-和-writeReplace"><a href="#5-特殊方法：readResolve-和-writeReplace" class="headerlink" title="5. 特殊方法：readResolve 和 writeReplace"></a>5. 特殊方法：<code>readResolve</code> 和 <code>writeReplace</code></h5><p>这两个方法允许你在序列化前后替换要写入或读取的对象，常用于实现单例模式，防止反序列化破坏单例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法在 readObject 之后被调用，返回的对象会替换掉反序列化创建的新对象</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE; <span class="comment">// 始终返回唯一的实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="6-优缺点"><a href="#6-优缺点" class="headerlink" title="6. 优缺点"></a>6. 优缺点</h5><p><strong>优点：</strong></p>
<ul>
<li><strong>极其简单易用</strong>：只需实现一个接口，JDK 就处理了所有复杂工作。</li>
<li><strong>自动处理复杂对象图</strong>：能够递归序列化整个对象引用网络（例如，一个对象包含另一个对象的引用，另一个对象又包含其他引用），不会出现循环引用的问题。</li>
</ul>
<p><strong>缺点和风险：</strong></p>
<ol>
<li><strong>安全问题</strong>：<ul>
<li>反序列化过程本质上是在“执行代码”，它会调用类的构造器和方法。恶意构造的字节流可以导致任意代码执行，这是一个非常严重的安全漏洞。</li>
<li>著名的 <code>Apache Commons Collections</code> 反序列化漏洞就源于此。</li>
</ul>
</li>
<li><strong>版本兼容性</strong>：<ul>
<li>虽然 <code>serialVersionUID</code> 可以解决一部分问题，但类的结构发生重大变化（如删除字段、更改字段类型）时，兼容性处理依然非常棘手。</li>
</ul>
</li>
<li><strong>性能</strong>：<ul>
<li>生成的字节流通常比较庞大，序列化和反序列化的过程也相对较慢。</li>
</ul>
</li>
<li><strong>跨语言能力差</strong>：<ul>
<li>Java 序列化是 Java 特有的，其他语言无法读取由 Java 序列化产生的字节流。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="7-替代方案"><a href="#7-替代方案" class="headerlink" title="7. 替代方案"></a>7. 替代方案</h5><p>由于上述缺点，尤其是在微服务和分布式架构中，Java 原生序列化已不再是首选。更流行的替代方案包括：</p>
<ul>
<li><strong>JSON</strong> (如 Jackson, Gson): 文本格式，人类可读，跨语言支持极好，是 Web API 和数据交换的事实标准。</li>
<li><strong>XML</strong>: 类似 JSON，但更冗长。</li>
<li><strong>Protocol Buffers (Protobuf)</strong> - Google: 二进制格式，高性能，跨语言，需要预定义模式（<code>.proto</code>文件），是微服务间通信的绝佳选择。</li>
<li><strong>Apache Avro</strong>: 二进制格式，同样需要模式，常用于大数据领域（如 Hadoop）。</li>
<li><strong>MessagePack</strong>: 类似于二进制的 JSON，比 JSON 更紧凑。</li>
</ul>
<hr>
<h3 id="8-2-ObjectOutPutStream-ObjectInPutStream"><a href="#8-2-ObjectOutPutStream-ObjectInPutStream" class="headerlink" title="8.2 ObjectOutPutStream &amp; ObjectInPutStream"></a>8.2 ObjectOutPutStream &amp; ObjectInPutStream</h3><h4 id="8-2-1-ObjectOutputStream-的序列化过程"><a href="#8-2-1-ObjectOutputStream-的序列化过程" class="headerlink" title="8.2.1 ObjectOutputStream 的序列化过程"></a>8.2.1 ObjectOutputStream 的序列化过程</h4><p>当你调用 <code>out.writeObject(someObject)</code> 时，会发生以下几步：</p>
<ol>
<li><strong>检查与验证</strong>：<ul>
<li>首先，它会检查 <code>someObject</code> 的类是否实现了 <code>Serializable</code> 接口。如果没有，立即抛出 <code>NotSerializableException</code>。</li>
<li>检查并获取该类的 <code>serialVersionUID</code>。如果类明确定义了它，就使用定义的值；否则，JVM 会根据类的结构自动计算生成一个。</li>
</ul>
</li>
<li><strong>处理对象图</strong>：<ul>
<li>序列化不仅仅是序列化 <code>someObject</code> 本身。它会递归地序列化 <code>someObject</code> 所引用的所有其他对象（除非引用被 <code>transient</code> 修饰或为 <code>null</code>），形成一个完整的字节流网络。这个过程可以处理复杂的循环引用。</li>
</ul>
</li>
<li><strong>写入字节流</strong>：<ul>
<li>将类的描述信息（包括类名、<code>serialVersionUID</code>）、字段名、字段类型等信息写入流中。</li>
<li>然后，按照类的定义，将非 <code>transient</code> 的实例字段的值逐个写入流中。如果字段是另一个对象，则递归执行 <code>writeObject</code>。</li>
</ul>
</li>
<li><strong>自定义序列化</strong>：<ul>
<li>如果被序列化的类定义了私有的 <code>writeObject(ObjectOutputStream out)</code> 方法，那么<strong>默认的序列化行为将被覆盖</strong>，转而执行这个自定义方法。开发者可以在此方法中精确控制要写入什么数据（例如，先对敏感数据进行加密再调用 <code>defaultWriteObject</code>）。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="8-2-2-ObjectInputStream-的反序列化过程"><a href="#8-2-2-ObjectInputStream-的反序列化过程" class="headerlink" title="8.2.2 ObjectInputStream 的反序列化过程"></a>8.2.2 ObjectInputStream 的反序列化过程</h4><p>当你调用 <code>in.readObject()</code> 时，会发生以下几步：</p>
<ol>
<li><strong>读取与验证</strong>：<ul>
<li>从流中读取类的描述信息（元数据）和 <code>serialVersionUID</code>。</li>
<li>将读取到的 <code>serialVersionUID</code> 与当前 JVM 环境中对应类的 <code>serialVersionUID</code> 进行比对。<strong>如果不匹配，将抛出 <code>InvalidClassException</code></strong>。这是保证序列化双方版本一致性的关键。</li>
</ul>
</li>
<li><strong>分配内存与重建对象</strong>：<ul>
<li>JVM 会根据从流中读取到的类信息，<strong>不通过类的构造方法</strong>，直接为该对象分配内存空间。这是反序列化与普通对象创建的关键区别。</li>
</ul>
</li>
<li><strong>填充字段</strong>：<ul>
<li>按照流中的顺序，将字段值逐一读取并填充到新分配的对象中。</li>
<li>如果字段是原始类型（如 <code>int</code>, <code>double</code>），直接填充其值。</li>
<li>如果字段是对象引用，则递归地执行 <code>readObject()</code> 来重建整个对象图，并恢复原始的引用关系。</li>
</ul>
</li>
<li><strong>最终处理与自定义反序列化</strong>：<ul>
<li>如果被反序列化的类定义了私有的 <code>readObject(ObjectInputStream in)</code> 方法，那么<strong>默认的反序列化行为将被覆盖</strong>，转而执行这个自定义方法。开发者可以在此方法中进行额外的初始化或数据转换（例如，对加密的数据进行解密）。</li>
<li>最后，如果类定义了 <code>readResolve()</code> 方法，则会调用它，并用其返回的对象替换掉刚刚反序列化创建的对象。这对于保护单例模式至关重要。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="9-打印流"><a href="#9-打印流" class="headerlink" title="9. 打印流"></a>9. 打印流</h2><h3 id="9-1-核心特点"><a href="#9-1-核心特点" class="headerlink" title="9.1 核心特点"></a>9.1 核心特点</h3><ol>
<li><strong>不会抛出 IOException</strong><ul>
<li>这是打印流与其它 <code>OutputStream</code> 或 <code>Writer</code> 最显著的区别。</li>
<li>它内部设置了错误标志位。你可以通过 <code>checkError()</code> 方法来检查是否发生了错误，而不是用 <code>try-catch</code> 来捕获异常。这极大地简化了代码编写。</li>
</ul>
</li>
<li><strong>自动刷新 (AutoFlush)</strong><ul>
<li>可以在创建打印流时通过构造函数的一个参数来启用自动刷新功能。</li>
<li>当启用后，调用 <code>println()</code>, <code>printf()</code>, 或 <code>format()</code> 方法时，会自动刷新输出缓冲区，确保数据立即被写出。这对于控制台输出特别有用。</li>
</ul>
</li>
<li><strong>丰富的输出方法</strong><ul>
<li>提供了大量重载的 <code>print()</code> 和 <code>println()</code> 方法，可以接受几乎所有基本数据类型（<code>int</code>, <code>boolean</code>, <code>double</code>…）和对象（<code>Object</code>）。</li>
<li>对于对象，它会自动调用该对象的 <code>toString()</code> 方法将其转换为字符串再输出。</li>
<li><code>println()</code> 方法在输出内容后还会附加一个平台相关的行分隔符（如 <code>\n</code> 或 <code>\r\n</code>）。</li>
</ul>
</li>
<li><strong>格式化输出</strong><ul>
<li>提供了 <code>printf()</code> 和 <code>format()</code> 方法（两者功能完全相同），支持使用格式字符串进行复杂的格式化输出，类似于 C 语言的 <code>printf</code> 函数。</li>
</ul>
</li>
</ol>
<h3 id="9-2-PrintStream（字节打印流）"><a href="#9-2-PrintStream（字节打印流）" class="headerlink" title="9.2 PrintStream（字节打印流）"></a>9.2 PrintStream（字节打印流）</h3><p><code>PrintStream</code> 继承自 <code>FilterOutputStream</code>，用于向另一个 <code>OutputStream</code>（字节输出流）装饰和增强功能。</p>
<h4 id="9-2-1-常见构造方法"><a href="#9-2-1-常见构造方法" class="headerlink" title="9.2.1 常见构造方法"></a>9.2.1 常见构造方法</h4><ul>
<li><code>PrintStream(OutputStream out)</code>: 创建一个新的打印流，不自动刷新。</li>
<li><code>PrintStream(OutputStream out, boolean autoFlush)</code>: 创建一个新的打印流，并可指定是否自动刷新。</li>
<li><code>PrintStream(String fileName)</code>: 创建一个新的打印流，指定文件名，不自动刷新。</li>
<li><code>PrintStream(File file)</code>: 创建一个新的打印流，指定文件对象，不自动刷新。</li>
<li><code>PrintStream(String fileName, String csn)</code>: 创建指定文件和字符集的打印流。</li>
</ul>
<hr>
<h4 id="9-2-2-重要方法"><a href="#9-2-2-重要方法" class="headerlink" title="9.2.2 重要方法"></a>9.2.2 重要方法</h4><p>除了从 <code>FilterOutputStream</code> 继承的 <code>write()</code> 方法，它主要提供了：</p>
<ul>
<li><code>print(各种数据类型)</code></li>
<li><code>println(各种数据类型)</code></li>
<li><code>printf(String format, Object... args)</code></li>
<li><code>format(String format, Object... args)</code></li>
<li><code>checkError()</code>: 刷新流并检查其错误状态。</li>
</ul>
<hr>
<h4 id="9-2-3-最著名的实例：System-out-和-System-err"><a href="#9-2-3-最著名的实例：System-out-和-System-err" class="headerlink" title="9.2.3 最著名的实例：System.out 和 System.err"></a>9.2.3 最著名的实例：<code>System.out</code> 和 <code>System.err</code></h4><p>Java 标准库中的 <code>System.out</code> 和 <code>System.err</code> 就是 <code>PrintStream</code> 对象。</p>
<ul>
<li><code>System.out</code>： 标准输出流，通常对应控制台。</li>
<li><code>System.err</code>： 标准错误输出流，通常也对应控制台，但用于输出错误信息（在某些IDE中会以红色显示）。</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 打印到控制台 (使用System.out)</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Hello, &quot;</span>); <span class="comment">// 不换行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;World!&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;The number is: &quot;</span> + number); <span class="comment">// 自动转换</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;Formatted: %05d %n&quot;</span>, number); <span class="comment">// 格式化输出</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 重定向输出到文件</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>);</span><br><span class="line">             <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(fos, <span class="literal">true</span>)) &#123; <span class="comment">// 启用自动刷新</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将标准输出重定向到文件</span></span><br><span class="line">            System.setOut(ps);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 现在所有System.out.println都会写入文件</span></span><br><span class="line">            System.out.println(<span class="string">&quot;This line goes to output.txt&quot;</span>);</span><br><span class="line">            System.out.printf(<span class="string">&quot;Pi is approximately %.2f&quot;</span>, Math.PI);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 检查错误</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">myStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(System.out);</span><br><span class="line">        myStream.println(<span class="string">&quot;Testing error.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (myStream.checkError()) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;An error occurred in the print stream!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="9-3-PrintWriter（字符打印流）"><a href="#9-3-PrintWriter（字符打印流）" class="headerlink" title="9.3 PrintWriter（字符打印流）"></a>9.3 PrintWriter（字符打印流）</h3><p><code>PrintWriter</code> 继承自 <code>Writer</code>，用于向另一个 <code>Writer</code> 或 <code>OutputStream</code>（字节流）装饰和增强功能。<strong>在现代 Java 开发中，更推荐使用 <code>PrintWriter</code>，因为它基于字符，能更好地处理文本和国际化。</strong></p>
<h4 id="9-3-1-常见构造方法"><a href="#9-3-1-常见构造方法" class="headerlink" title="9.3.1 常见构造方法"></a>9.3.1 常见构造方法</h4><ul>
<li><code>PrintWriter(Writer out)</code></li>
<li><code>PrintWriter(Writer out, boolean autoFlush)</code></li>
<li><code>PrintWriter(OutputStream out)</code></li>
<li><code>PrintWriter(OutputStream out, boolean autoFlush)</code></li>
<li><code>PrintWriter(String fileName)</code></li>
<li><code>PrintWriter(File file)</code></li>
</ul>
<hr>
<h4 id="9-3-2-重要方法"><a href="#9-3-2-重要方法" class="headerlink" title="9.3.2 重要方法"></a>9.3.2 重要方法</h4><p>方法与 <code>PrintStream</code> 几乎完全一样：</p>
<ul>
<li><code>print()</code></li>
<li><code>println()</code></li>
<li><code>printf()</code></li>
<li><code>format()</code></li>
<li><code>checkError()</code></li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintWriterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 使用PrintWriter包装FileWriter (字符流)</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;log.txt&quot;</span>);</span><br><span class="line">             <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(fw, <span class="literal">true</span>)) &#123; <span class="comment">// 启用自动刷新</span></span><br><span class="line"></span><br><span class="line">            pw.println(<span class="string">&quot;Application Log&quot;</span>);</span><br><span class="line">            pw.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">            pw.printf(<span class="string">&quot;Timestamp: %tc %n&quot;</span>, System.currentTimeMillis());</span><br><span class="line">            pw.print(<span class="string">&quot;Status: OK&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 直接包装OutputStream (字节流)</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(System.out, <span class="literal">true</span>)) &#123;</span><br><span class="line">            pw.println(<span class="string">&quot;This goes to the console via PrintWriter.&quot;</span>);</span><br><span class="line">            <span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">19.99</span>;</span><br><span class="line">            pw.printf(<span class="string">&quot;The price is $%.2f&quot;</span>, price);</span><br><span class="line">        &#125; <span class="comment">// 不需要catch IOException，因为PrintWriter不抛出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="10-其他重要IO流"><a href="#10-其他重要IO流" class="headerlink" title="10. 其他重要IO流"></a>10. 其他重要IO流</h2><h3 id="10-1-内存操作流-In-Memory-I-O"><a href="#10-1-内存操作流-In-Memory-I-O" class="headerlink" title="10.1 内存操作流 (In-Memory I&#x2F;O)"></a>10.1 内存操作流 (In-Memory I&#x2F;O)</h3><h4 id="10-1-1-ByteArrayInputStream-ByteArrayOutputStream-字节数组流"><a href="#10-1-1-ByteArrayInputStream-ByteArrayOutputStream-字节数组流" class="headerlink" title="10.1.1 ByteArrayInputStream &amp; ByteArrayOutputStream (字节数组流)"></a>10.1.1 <code>ByteArrayInputStream</code> &amp; <code>ByteArrayOutputStream</code> (字节数组流)</h4><ul>
<li><p><strong>概念</strong>:</p>
<ul>
<li><code>ByteArrayOutputStream</code>: 这是一个<strong>输出流</strong>，它将数据写入到一个内部的、可自动增长的<strong>字节数组 (<code>byte[]</code>)</strong> 中。可以把它想象成一个在内存中不断增长的字节缓冲区。</li>
<li><code>ByteArrayInputStream</code>: 这是一个<strong>输入流</strong>，它从一个<strong>已存在的字节数组 (<code>byte[]</code>)</strong> 中读取数据。</li>
</ul>
</li>
<li><p><strong>核心用法</strong>:</p>
<ol>
<li>使用 <code>ByteArrayOutputStream</code> 收集来自不同来源的字节数据。</li>
<li>调用 <code>toByteArray()</code> 方法，从 <code>ByteArrayOutputStream</code> 中获取最终的、完整的字节数组。</li>
<li>将这个字节数组传递给 <code>ByteArrayInputStream</code> 的构造函数。</li>
<li>像从文件中读取一样，从 <code>ByteArrayInputStream</code> 中读取数据。</li>
</ol>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用 ByteArrayOutputStream 写入数据到内存</span></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="keyword">try</span> (<span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(baos)) &#123;</span><br><span class="line">    <span class="comment">// 写入一些不同类型的数据</span></span><br><span class="line">    dos.writeUTF(<span class="string">&quot;Hello Memory IO&quot;</span>);</span><br><span class="line">    dos.writeInt(<span class="number">12345</span>);</span><br><span class="line">    dos.writeDouble(<span class="number">3.14159</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// 写入内存几乎不会发生IO异常，但语法上需要处理</span></span><br><span class="line">    e.printStackTrace(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 从 OutputStream 中获取完整的字节数组</span></span><br><span class="line"><span class="type">byte</span>[] data = baos.toByteArray();</span><br><span class="line">System.out.println(<span class="string">&quot;写入内存的字节数组长度: &quot;</span> + data.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用 ByteArrayInputStream 从内存中读取数据</span></span><br><span class="line"><span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(data);</span><br><span class="line"><span class="keyword">try</span> (<span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(bais)) &#123;</span><br><span class="line">    System.out.println(dis.readUTF());    <span class="comment">// 输出: Hello Memory IO</span></span><br><span class="line">    System.out.println(dis.readInt());     <span class="comment">// 输出: 12345</span></span><br><span class="line">    System.out.println(dis.readDouble());  <span class="comment">// 输出: 3.14159</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="10-1-2-StringReader-StringWriter-字符串流"><a href="#10-1-2-StringReader-StringWriter-字符串流" class="headerlink" title="10.1.2 StringReader &amp; StringWriter (字符串流)"></a>10.1.2 <code>StringReader</code> &amp; <code>StringWriter</code> (字符串流)</h4><ul>
<li><p><strong>概念</strong>:</p>
<ul>
<li>这是字节数组流的<strong>字符版本</strong>。它们的数据源和目的地是内存中的字符串。</li>
<li><code>StringWriter</code>: 将字符数据写入其内部的 <code>StringBuffer</code> 或 <code>StringBuilder</code>。</li>
<li><code>StringReader</code>: 从一个已存在的 <code>String</code> 对象中读取字符数据。</li>
</ul>
</li>
<li><p><strong>核心用法</strong>:</p>
<ul>
<li>与字节数组流类似，<code>StringWriter</code> 用于构建字符串，然后通过 <code>toString()</code> 获取结果。<code>StringReader</code> 则用于将一个现有字符串包装成一个 <code>Reader</code>，使其可以被需要 <code>Reader</code> 作为参数的API（如XML解析器、模板引擎）处理。</li>
</ul>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用 StringWriter 写入字符数据到内存</span></span><br><span class="line"><span class="type">StringWriter</span> <span class="variable">stringWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line"><span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(stringWriter)) &#123;</span><br><span class="line">    printWriter.println(<span class="string">&quot;This is line 1.&quot;</span>);</span><br><span class="line">    printWriter.printf(<span class="string">&quot;This is line %d with a value.&quot;</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 从 StringWriter 获取完整的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> stringWriter.toString();</span><br><span class="line">System.out.println(<span class="string">&quot;--- StringWriter Result ---&quot;</span>);</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用 StringReader 从字符串中读取</span></span><br><span class="line">System.out.println(<span class="string">&quot;--- Reading from StringReader ---&quot;</span>);</span><br><span class="line"><span class="type">StringReader</span> <span class="variable">stringReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringReader</span>(result);</span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(stringReader)) &#123;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Read line: &quot;</span> + line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="10-1-3-核心应用：面向内存的IO操作与数据转换"><a href="#10-1-3-核心应用：面向内存的IO操作与数据转换" class="headerlink" title="10.1.3 核心应用：面向内存的IO操作与数据转换"></a>10.1.3 核心应用：面向内存的IO操作与数据转换</h4><ul>
<li><strong>单元测试</strong>: 当需要测试一个处理 <code>InputStream</code> 的方法时，无需创建临时文件，直接使用 <code>ByteArrayInputStream</code> 或 <code>StringReader</code> 传入测试数据即可。</li>
<li><strong>数据格式转换</strong>: 将一个Java对象序列化为字节数组，以便通过网络发送或存入数据库的BLOB字段。<code>ObjectOutputStream</code> 可以直接写入 <code>ByteArrayOutputStream</code> 来实现这一点。</li>
<li><strong>临时缓存</strong>: 在多步骤的数据处理流程中，可以将一个步骤的输出写入内存流，作为下一步骤的输入，避免了磁盘I&#x2F;O的开销。</li>
<li><strong>动态生成文件内容</strong>: 在Web应用中，可以动态生成一个CSV或XML文件的内容到 <code>StringWriter</code> 或 <code>ByteArrayOutputStream</code>，然后将其作为HTTP响应直接发送给客户端，而无需在服务器上创建实体文件。</li>
</ul>
<hr>
<h3 id="10-2-管道流-Piped-I-O"><a href="#10-2-管道流-Piped-I-O" class="headerlink" title="10.2 管道流 (Piped I&#x2F;O)"></a>10.2 管道流 (Piped I&#x2F;O)</h3><h4 id="10-2-1-PipedInputStream-PipedOutputStream"><a href="#10-2-1-PipedInputStream-PipedOutputStream" class="headerlink" title="10.2.1 PipedInputStream &amp; PipedOutputStream"></a>10.2.1 <code>PipedInputStream</code> &amp; <code>PipedOutputStream</code></h4><ul>
<li><strong>概念</strong>:<ul>
<li>它们必须成对使用，一个 <code>PipedOutputStream</code> (写入端) 必须连接到一个 <code>PipedInputStream</code> (读取端)。</li>
<li>一个线程通过 <code>PipedOutputStream</code> 写入数据，另一个线程通过 <code>PipedInputStream</code> 读取这些数据。</li>
<li>内部有一个缓冲区。如果写入线程写得太快，缓冲区满了，写入线程会<strong>阻塞</strong>。如果读取线程读得太快，缓冲区空了，读取线程会<strong>阻塞</strong>。这种阻塞机制天然地实现了生产者-消费者模式的同步。</li>
</ul>
</li>
<li><strong>连接方式</strong>:<ol>
<li><code>PipedInputStream pipedIn = new PipedInputStream();</code><br><code>PipedOutputStream pipedOut = new PipedOutputStream(pipedIn);</code></li>
<li><code>PipedInputStream pipedIn = new PipedInputStream();</code><br><code>PipedOutputStream pipedOut = new PipedOutputStream();</code><br><code>pipedIn.connect(pipedOut); // 或者 pipedOut.connect(pipedIn);</code></li>
</ol>
</li>
</ul>
<hr>
<h4 id="10-2-2-核心应用：线程间通信"><a href="#10-2-2-核心应用：线程间通信" class="headerlink" title="10.2.2 核心应用：线程间通信"></a>10.2.2 核心应用：线程间通信</h4><p>这是管道流最主要也是几乎唯一的应用场景。</p>
<ul>
<li><p><strong>代码示例：生产者-消费者模型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipedStreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">PipedInputStream</span> <span class="variable">pipedIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedInputStream</span>();</span><br><span class="line">        <span class="comment">// 建议在构造时就连接，更安全</span></span><br><span class="line">        <span class="type">PipedOutputStream</span> <span class="variable">pipedOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PipedOutputStream</span>(pipedIn);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Message &quot;</span> + i;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Producing: &quot;</span> + message);</span><br><span class="line">                    pipedOut.write(message.getBytes());</span><br><span class="line">                    pipedOut.flush();</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    pipedOut.close(); <span class="comment">// 必须关闭，否则读取端会一直阻塞等待</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">int</span> len;</span><br><span class="line">                <span class="comment">// read()会阻塞，直到有数据或写入端关闭</span></span><br><span class="line">                <span class="keyword">while</span> ((len = pipedIn.read(buffer)) != -<span class="number">1</span>) &#123; </span><br><span class="line">                    <span class="type">String</span> <span class="variable">received</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Consuming: &quot;</span> + received);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer finished.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    pipedIn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="10-3-功能组合流"><a href="#10-3-功能组合流" class="headerlink" title="10.3 功能组合流"></a>10.3 功能组合流</h3><h4 id="10-3-1-SequenceInputStream-序列输入流"><a href="#10-3-1-SequenceInputStream-序列输入流" class="headerlink" title="10.3.1 SequenceInputStream (序列输入流)"></a>10.3.1 <code>SequenceInputStream</code> (序列输入流)</h4><ul>
<li><p><strong>概念</strong>:</p>
<ul>
<li><code>SequenceInputStream</code> 可以将<strong>两个或多个输入流（InputStream）逻辑上串联起来</strong>，使其表现得像一个单一的、连续的输入流。</li>
<li>当从 <code>SequenceInputStream</code> 读取时，它会先从第一个流读取，直到该流结束，然后无缝地切换到第二个流，以此类推，直到所有流都读取完毕。</li>
</ul>
</li>
<li><p><strong>核心应用：文件合并</strong></p>
<ul>
<li>当需要合并多个文件的内容进行处理，但又不想先将它们合并成一个大的物理文件时，<code>SequenceInputStream</code> 是完美的选择。例如，合并分块下载的文件，或者处理按日期分割的日志文件。</li>
</ul>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟两个文件内容</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(<span class="string">&quot;Hello, &quot;</span>.getBytes());</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(<span class="string">&quot;World!&quot;</span>.getBytes());</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(<span class="string">&quot; Welcome.&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 s1 和 s2 合并</span></span><br><span class="line"><span class="type">SequenceInputStream</span> <span class="variable">sis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SequenceInputStream</span>(s1, s2);</span><br><span class="line"><span class="comment">// 再将 s3 也合并进来</span></span><br><span class="line"><span class="type">SequenceInputStream</span> <span class="variable">finalSis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SequenceInputStream</span>(sis, s3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从合并后的流中读取</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> byteData;</span><br><span class="line">    <span class="keyword">while</span> ((byteData = finalSis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) byteData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出: Hello, World! Welcome.</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭SequenceInputStream会自动关闭其包含的所有流</span></span><br><span class="line">    finalSis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>SequenceInputStream</code> 还有一个接受 <code>Enumeration&lt;? extends InputStream&gt;</code> 的构造函数，可以合并任意数量的流。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="10-3-2-LineNumberReader-行号读取器"><a href="#10-3-2-LineNumberReader-行号读取器" class="headerlink" title="10.3.2 LineNumberReader (行号读取器)"></a>10.3.2 <code>LineNumberReader</code> (行号读取器)</h4><ul>
<li><p><strong>概念</strong>:</p>
<ul>
<li>这是一个装饰器流，继承自 <code>BufferedReader</code>，因此拥有缓冲功能。</li>
<li>它的核心特性是<strong>能够跟踪当前读取到的行号</strong>。</li>
</ul>
</li>
<li><p><strong>核心应用：文本解析与错误定位</strong></p>
<ul>
<li>在解析配置文件、源代码或其他格式化文本时非常有用。如果发现语法错误，可以立即通过 <code>getLineNumber()</code> 方法获取错误所在的行号，为用户提供精确的错误信息。</li>
</ul>
</li>
<li><p><strong>核心方法</strong>:</p>
<ul>
<li><code>int getLineNumber()</code>: 获取当前行号（从0开始计数）。</li>
<li><code>void setLineNumber(int lineNumber)</code>: 设置当前行号。</li>
<li><code>readLine()</code>: 读取一行，并使内部行号计数器加一。</li>
</ul>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;First line\nSecond line\nThird line&quot;</span>;</span><br><span class="line"><span class="type">StringReader</span> <span class="variable">stringReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringReader</span>(text);</span><br><span class="line"><span class="type">LineNumberReader</span> <span class="variable">lineNumberReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LineNumberReader</span>(stringReader);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = lineNumberReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// getLineNumber() 返回的是刚刚读完的行的行号</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;Line %d: %s%n&quot;</span>, lineNumberReader.getLineNumber(), line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lineNumberReader.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出:</span></span><br><span class="line"><span class="comment"> * Line 1: First line</span></span><br><span class="line"><span class="comment"> * Line 2: Second line</span></span><br><span class="line"><span class="comment"> * Line 3: Third line</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="10-4-流的选择"><a href="#10-4-流的选择" class="headerlink" title="10.4 流的选择"></a>10.4 流的选择</h3><pre><code class="highlight mermaid">graph TD
    A[开始选择IO流] --&gt; B&#123;处理什么类型数据?&#125;;

    B -- &quot;文本/字符数据&quot; --&gt; C[&quot;选择字符流&lt;br/&gt;Reader/Writer体系&quot;];
    B -- &quot;二进制数据&quot; --&gt; D[&quot;选择字节流&lt;br/&gt;InputStream/OutputStream&quot;];

    C --&gt; E&#123;数据来源/目的地?&#125;;
    E -- &quot;文件&quot; --&gt; E1[使用FileReader/FileWriter];
    E -- &quot;内存中的字符串&quot; --&gt; E2[使用StringReader/StringWriter];
    E -- &quot;网络/其他字节流&quot; --&gt; E3[&quot;使用InputStreamReader/&lt;br/&gt;OutputStreamWriter转换&quot;];

    D --&gt; F&#123;数据来源/目的地?&#125;;
    F -- &quot;文件&quot; --&gt; F1[&quot;使用FileInputStream/&lt;br/&gt;FileOutputStream&quot;];
    F -- &quot;内存中的字节数组&quot; --&gt; F2[&quot;使用ByteArrayInputStream/&lt;br/&gt;ByteArrayOutputStream&quot;];
    F -- &quot;线程间通信&quot; --&gt; F3[&quot;使用PipedInputStream/&lt;br/&gt;PipedOutputStream&quot;];

    subgraph 基础流选择
        E1 &amp; E2 &amp; E3 &amp; F1 &amp; F2 &amp; F3
    end

    E1 --&gt; G&#123;需要额外功能?&#125;;
    E2 --&gt; G;
    E3 --&gt; G;
    F1 --&gt; G;
    F2 --&gt; G;
    F3 --&gt; G;

    G -- &quot;需要高效读取&quot; --&gt; H1[&quot;+BufferedReader/&lt;br/&gt;BufferedWriter&quot;];
    G -- &quot;需要高效读取&quot; --&gt; H2[&quot;+BufferedInputStream/&lt;br/&gt;BufferedOutputStream&quot;];
    G -- &quot;需要读取基本数据类型&quot; --&gt; H3[&quot;+DataInputStream/&lt;br/&gt;DataOutputStream&quot;];
    G -- &quot;需要序列化对象&quot; --&gt; H4[&quot;使用ObjectInputStream/&lt;br/&gt;ObjectOutputStream&quot;];
    G -- &quot;需要格式化输出&quot; --&gt; H5[&quot;使用PrintWriter/&lt;br/&gt;PrintStream&quot;];
    G -- &quot;不需要额外功能&quot; --&gt; H6[直接使用基础流];

    subgraph &quot;功能流(装饰器)选择&quot;
        H1 &amp; H2 &amp; H3 &amp; H4 &amp; H5 &amp; H6
    end

    H1 --&gt; Z[完成选择];
    H2 --&gt; Z;
    H3 --&gt; Z;
    H4 --&gt; Z;
    H5 --&gt; Z;
    H6 --&gt; Z;</code></pre>

<hr>
<h4 id="10-4-1-根据数据类型选择"><a href="#10-4-1-根据数据类型选择" class="headerlink" title="10.4.1 根据数据类型选择"></a>10.4.1 根据数据类型选择</h4><ul>
<li><strong>字节数据</strong>（如图片、音频、视频、任何二进制文件）：<ul>
<li>使用字节流：<code>InputStream</code>&#x2F;<code>OutputStream</code>体系</li>
</ul>
</li>
<li><strong>文本数据</strong>：<ul>
<li>使用字符流：<code>Reader</code>&#x2F;<code>Writer</code>体系</li>
<li>注意编码问题，特别是多语言环境</li>
</ul>
</li>
</ul>
<hr>
<h4 id="10-4-2-根据数据来源-目的地选择"><a href="#10-4-2-根据数据来源-目的地选择" class="headerlink" title="10.4.2 根据数据来源&#x2F;目的地选择"></a>10.4.2 根据数据来源&#x2F;目的地选择</h4><ul>
<li><strong>文件</strong>：<ul>
<li>字节流：<code>FileInputStream</code>&#x2F;<code>FileOutputStream</code></li>
<li>字符流：<code>FileReader</code>&#x2F;<code>FileWriter</code></li>
</ul>
</li>
<li><strong>内存操作</strong>：<ul>
<li>字节数组：<code>ByteArrayInputStream</code>&#x2F;<code>ByteArrayOutputStream</code></li>
<li>字符数组：<code>CharArrayReader</code>&#x2F;<code>CharArrayWriter</code></li>
<li>字符串：<code>StringReader</code>&#x2F;<code>StringWriter</code></li>
</ul>
</li>
<li><strong>网络通信</strong>：<ul>
<li>通常使用字节流，如Socket获取的输入输出流</li>
</ul>
</li>
<li><strong>线程间通信</strong>：<ul>
<li>使用管道流：<code>PipedInputStream</code>&#x2F;<code>PipedOutputStream</code>或<code>PipedReader</code>&#x2F;<code>PipedWriter</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="10-4-3-根据功能需求选择"><a href="#10-4-3-根据功能需求选择" class="headerlink" title="10.4.3 根据功能需求选择"></a>10.4.3 根据功能需求选择</h4><ul>
<li><strong>需要缓冲提高性能</strong>：<ul>
<li>字节缓冲流：<code>BufferedInputStream</code>&#x2F;<code>BufferedOutputStream</code></li>
<li>字符缓冲流：<code>BufferedReader</code>&#x2F;<code>BufferedWriter</code></li>
<li>特别是对于文件操作和网络操作，几乎总是应该使用缓冲流</li>
</ul>
</li>
<li><strong>需要读写基本数据类型</strong>：<ul>
<li>使用数据流：<code>DataInputStream</code>&#x2F;<code>DataOutputStream</code></li>
</ul>
</li>
<li><strong>需要序列化对象</strong>：<ul>
<li>使用对象流：<code>ObjectInputStream</code>&#x2F;<code>ObjectOutputStream</code></li>
<li>注意：被序列化的类必须实现<code>Serializable</code>接口</li>
</ul>
</li>
<li><strong>需要格式化输出</strong>：<ul>
<li>使用打印流：<code>PrintStream</code>&#x2F;<code>PrintWriter</code></li>
<li><code>PrintWriter</code>更适用于字符输出，支持更多字符编码</li>
</ul>
</li>
<li><strong>需要将多个输入流合并</strong>：<ul>
<li>使用<code>SequenceInputStream</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="10-4-4-常见使用场景和建议"><a href="#10-4-4-常见使用场景和建议" class="headerlink" title="10.4.4 常见使用场景和建议"></a>10.4.4 常见使用场景和建议</h4><h5 id="1-读取文本文件（推荐方式）："><a href="#1-读取文本文件（推荐方式）：" class="headerlink" title="1. 读取文本文件（推荐方式）："></a>1. 读取文本文件（推荐方式）：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用缓冲字符流读取文本文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file.txt&quot;</span>))) &#123;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理每一行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-写入文本文件（推荐方式）："><a href="#2-写入文本文件（推荐方式）：" class="headerlink" title="2. 写入文本文件（推荐方式）："></a>2. 写入文本文件（推荐方式）：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用缓冲字符流写入文本文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;file.txt&quot;</span>))) &#123;</span><br><span class="line">    writer.write(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    writer.newLine(); <span class="comment">// 跨平台换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-复制二进制文件（推荐方式）："><a href="#3-复制二进制文件（推荐方式）：" class="headerlink" title="3. 复制二进制文件（推荐方式）："></a>3. 复制二进制文件（推荐方式）：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用缓冲字节流复制文件</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;source.jpg&quot;</span>));</span><br><span class="line">     <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dest.jpg&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">while</span> ((length = in.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        out.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-读取基本数据类型："><a href="#4-读取基本数据类型：" class="headerlink" title="4. 读取基本数据类型："></a>4. 读取基本数据类型：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用数据流读取基本数据类型</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.bin&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">    <span class="type">double</span> <span class="variable">doubleValue</span> <span class="operator">=</span> dis.readDouble();</span><br><span class="line">    <span class="type">String</span> <span class="variable">stringValue</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-序列化对象："><a href="#5-序列化对象：" class="headerlink" title="5. 序列化对象："></a>5. 序列化对象：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用对象流序列化和反序列化对象</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.dat&quot;</span>))) &#123;</span><br><span class="line">    oos.writeObject(myObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.dat&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) ois.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="10-4-5-性能考虑"><a href="#10-4-5-性能考虑" class="headerlink" title="10.4.5 性能考虑"></a>10.4.5 性能考虑</h4><ol>
<li><strong>总是使用缓冲流</strong>：对于文件IO和网络IO，缓冲流可以显著提高性能</li>
<li><strong>选择合适的缓冲区大小</strong>：默认缓冲区大小通常为8KB，对于大文件可以考虑使用更大的缓冲区</li>
<li><strong>及时关闭流</strong>：使用try-with-resources语句确保流被正确关闭</li>
<li><strong>考虑使用NIO</strong>：对于高性能需求，考虑使用Java NIO的Channel和Buffer类</li>
</ol>
<hr>
<h2 id="11-NIO"><a href="#11-NIO" class="headerlink" title="11. NIO"></a>11. NIO</h2><p>Java NIO 是自 Java 1.4 引入的一套新的 I&#x2F;O API，用于替代标准的 Java I&#x2F;O API（简称 BIO&#x2F;Blocking I&#x2F;O）。它的核心目标是<strong>提供高速、面向块的 I&#x2F;O 操作</strong>，以解决传统 I&#x2F;O 在管理大量并发连接时的性能瓶颈。</p>
<h3 id="11-1-核心思想"><a href="#11-1-核心思想" class="headerlink" title="11.1 核心思想"></a>11.1 核心思想</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Java BIO (Blocking I&#x2F;O)</th>
<th align="left">Java NIO (Non-blocking I&#x2F;O)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>工作方式</strong></td>
<td align="left"><strong>流导向 (Stream Oriented)</strong></td>
<td align="left"><strong>缓冲区导向 (Buffer Oriented)</strong></td>
</tr>
<tr>
<td align="left"><strong>阻塞性</strong></td>
<td align="left"><strong>阻塞 I&#x2F;O (Blocking I&#x2F;O)</strong></td>
<td align="left"><strong>非阻塞 I&#x2F;O (Non-blocking I&#x2F;O)</strong></td>
</tr>
<tr>
<td align="left"><strong>核心组件</strong></td>
<td align="left"><code>InputStream</code>, <code>OutputStream</code></td>
<td align="left"><code>Buffer</code>, <code>Channel</code>, <code>Selector</code></td>
</tr>
<tr>
<td align="left"><strong>处理连接</strong></td>
<td align="left">一个连接一个线程 (1:1)</td>
<td align="left">一个线程处理多个连接 (1:m)</td>
</tr>
<tr>
<td align="left"><strong>编程模型</strong></td>
<td align="left">简单直观</td>
<td align="left">相对复杂，需要事件循环</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">连接数较少且固定的架构</td>
<td align="left">连接数多且连接时间短的架构，如聊天服务器、推送系统</td>
</tr>
</tbody></table>
<h3 id="11-2-三大核心组件"><a href="#11-2-三大核心组件" class="headerlink" title="11.2 三大核心组件"></a>11.2 三大核心组件</h3><h4 id="11-2-1-Buffer-缓冲区"><a href="#11-2-1-Buffer-缓冲区" class="headerlink" title="11.2.1 Buffer (缓冲区)"></a>11.2.1 Buffer (缓冲区)</h4><p><strong>作用：</strong> 一个用于存储特定基本数据类型的容器。所有数据的读写都是直接与 Buffer 交互。</p>
<p><strong>本质：</strong> 本质上是一个内存块，但提供了更丰富的 API 来操作数据。</p>
<p><strong>核心属性：</strong></p>
<ul>
<li><strong>capacity (容量)：</strong> 缓冲区的总大小。一旦创建，<code>capacity</code> 就固定不变。</li>
<li><strong>position (位置)：</strong> 下一个要被<strong>读取</strong>或<strong>写入</strong>的元素的索引。<code>position</code> 会随着 <code>get()</code> 或 <code>put()</code> 操作而移动。</li>
<li><strong>limit (限制)：<strong>在</strong>读模式</strong>下，<code>limit</code> 表示最多能读取到哪里（即写入的数据终点）。在<strong>写模式</strong>下，<code>limit</code> 等于 <code>capacity</code>，表示最多可以写到哪里。<code>limit</code> 之后的数据是不可读写的。</li>
<li><strong>mark (标记)：</strong> 一个备忘位置。调用 <code>mark()</code> 会将 <code>mark</code> 设置为当前的 <code>position</code>。调用 <code>reset()</code> 会将 <code>position</code> 恢复到 <code>mark</code> 的位置。</li>
<li>这四个属性之间永远遵循这个不变式： <strong><code>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</code></strong></li>
</ul>
<p><strong>常用方法：</strong></p>
<ul>
<li><code>allocate(int capacity)</code>：分配一个新的缓冲区。</li>
<li><code>put(data)</code>: <strong>写入数据</strong>。将数据放入 <code>position</code> 指向的位置，然后 <code>position</code> 加一。</li>
<li><code>get()</code>: <strong>读取数据</strong>。从 <code>position</code> 指向的位置读取数据，然后 <code>position</code> 加一。</li>
<li><code>flip()</code>: <strong>翻转&#x2F;切换到读模式</strong>。这是从<strong>写模式切换到读模式</strong>的关键方法。它会执行以下操作：<ol>
<li><code>limit = position;</code> &#x2F;&#x2F; 将 <code>limit</code> 设置为当前 <code>position</code>，界定了可读数据的范围。</li>
<li><code>position = 0;</code> &#x2F;&#x2F; 将 <code>position</code> 重置为0，准备从头开始读取。</li>
<li><code>mark = -1;</code> &#x2F;&#x2F; 丢弃标记。</li>
</ol>
</li>
<li><code>clear()</code>: <strong>清空&#x2F;切换到写模式</strong>。这个方法并<strong>不会真正清除Buffer中的数据</strong>，它只是重置指针，准备让Buffer被重新写入。它执行以下操作：<ol>
<li><code>position = 0;</code> &#x2F;&#x2F; <code>position</code> 回到起点。</li>
<li><code>limit = capacity;</code> &#x2F;&#x2F; <code>limit</code> 回到最大容量，允许从头写满整个Buffer。</li>
<li><code>mark = -1;</code> &#x2F;&#x2F; 丢弃标记。</li>
</ol>
</li>
<li><code>rewind()</code>：重读。<code>position</code> 归 0，<code>limit</code> 不变。可以重新读取数据。</li>
<li><code>compact()</code>：压缩缓冲区。将未读的数据复制到缓冲区起始处，然后设置 <code>position</code> 到未读数据的下一个位置，<code>limit</code> 为 <code>capacity</code>。为<strong>继续写入</strong>做准备。</li>
</ul>
<p><strong>常见类型：</strong> <code>ByteBuffer</code>, <code>CharBuffer</code>, <code>IntBuffer</code> 等，其中最常用的是 <code>ByteBuffer</code>。</p>
<p><strong>示例：使用 ByteBuffer</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 分配一个容量为10的ByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;Initial:  pos=%d, limit=%d, cap=%d\n&quot;</span>, buffer.position(), buffer.limit(), buffer.capacity());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 写入数据 (put)</span></span><br><span class="line">buffer.put((<span class="type">byte</span>)<span class="string">&#x27;H&#x27;</span>).put((<span class="type">byte</span>)<span class="string">&#x27;e&#x27;</span>).put((<span class="type">byte</span>)<span class="string">&#x27;l&#x27;</span>).put((<span class="type">byte</span>)<span class="string">&#x27;l&#x27;</span>).put((<span class="type">byte</span>)<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;After put: pos=%d, limit=%d, cap=%d\n&quot;</span>, buffer.position(), buffer.limit(), buffer.capacity());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 切换到读模式 (flip)</span></span><br><span class="line">buffer.flip();</span><br><span class="line">System.out.printf(<span class="string">&quot;After flip: pos=%d, limit=%d, cap=%d\n&quot;</span>, buffer.position(), buffer.limit(), buffer.capacity());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 读取数据 (get)</span></span><br><span class="line">System.out.print(<span class="string">&quot;Reading: &quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">    System.out.print((<span class="type">char</span>)buffer.get());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.printf(<span class="string">&quot;After get: pos=%d, limit=%d, cap=%d\n&quot;</span>, buffer.position(), buffer.limit(), buffer.capacity());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 切换到写模式 (clear)</span></span><br><span class="line">buffer.clear();</span><br><span class="line">System.out.printf(<span class="string">&quot;After clear: pos=%d, limit=%d, cap=%d\n&quot;</span>, buffer.position(), buffer.limit(), buffer.capacity());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出:</span></span><br><span class="line"><span class="comment">Initial:  pos=0, limit=10, cap=10</span></span><br><span class="line"><span class="comment">After put: pos=5, limit=10, cap=10</span></span><br><span class="line"><span class="comment">After flip: pos=0, limit=5, cap=10</span></span><br><span class="line"><span class="comment">Reading: Hello</span></span><br><span class="line"><span class="comment">After get: pos=5, limit=5, cap=10</span></span><br><span class="line"><span class="comment">After clear: pos=0, limit=10, cap=10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="11-2-2-Channel-通道"><a href="#11-2-2-Channel-通道" class="headerlink" title="11.2.2 Channel (通道)"></a>11.2.2 Channel (通道)</h4><p><strong>作用：</strong> 代表了与一个能够执行I&#x2F;O操作的实体（如文件、套接字）之间的<strong>开放连接</strong>。它是数据传输的<strong>载体</strong>。与单向的Stream不同，Channel通常是<strong>双向的</strong>，可以同时进行读写操作。</p>
<p><strong>主要实现：</strong></p>
<ul>
<li><code>FileChannel</code>：用于文件读写。</li>
<li><code>DatagramChannel</code>：用于 UDP 通信。</li>
<li><code>SocketChannel</code>：用于 TCP 客户端。</li>
<li><code>ServerSocketChannel</code>：用于TCP网络服务器端，可以接受新的连接并为每个连接创建一个 <code>SocketChannel</code>。</li>
</ul>
<p><strong>重要特性：</strong></p>
<ul>
<li><strong>可以异步地读写</strong>。</li>
<li><strong>与Buffer交互</strong>: Channel的所有数据传输都通过Buffer进行。<code>read()</code> 方法将数据从Channel读入Buffer，<code>write()</code> 方法将数据从Buffer写入Channel。</li>
<li><strong>双向性</strong>: 大多数Channel实现（如 <code>SocketChannel</code>）既可以读也可以写，而Stream是严格单向的（<code>InputStream</code> 只能读，<code>OutputStream</code> 只能写）。</li>
<li><strong>可配置为非阻塞模式</strong>: 这是NIO与BIO最根本的区别。可以将Channel设置为非阻塞模式，在这种模式下，一个I&#x2F;O操作（如<code>read()</code>）会立即返回，无论是否真的读到了数据。</li>
<li><strong>支持“分散(Scatter)”和“聚集(Gather)”</strong>：<ul>
<li><strong>Scatter:</strong> 从一个 Channel 读取数据到多个 Buffer 中。</li>
<li><strong>Gather:</strong> 将多个 Buffer 的数据写入到一个 Channel 中。</li>
</ul>
</li>
</ul>
<p><strong>示例：使用 FileChannel 复制文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取源文件和目标文件的 Channel</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;source.txt&quot;</span>);</span><br><span class="line">     <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;dest.txt&quot;</span>);</span><br><span class="line">     <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> fis.getChannel();</span><br><span class="line">     <span class="type">FileChannel</span> <span class="variable">outChannel</span> <span class="operator">=</span> fos.getChannel()) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配缓冲区</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (inChannel.read(buffer) != -<span class="number">1</span>) &#123; <span class="comment">// 从 inChannel 读取到 buffer</span></span><br><span class="line">        buffer.flip(); <span class="comment">// 切换为读模式</span></span><br><span class="line">        outChannel.write(buffer); <span class="comment">// 从 buffer 写入到 outChannel</span></span><br><span class="line">        buffer.clear(); <span class="comment">// 清空缓冲区，准备下一次读</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-2-3-Selector-选择器"><a href="#11-2-3-Selector-选择器" class="headerlink" title="11.2.3 Selector (选择器)"></a>11.2.3 Selector (选择器)</h4><p><strong>作用：<strong>Selector 是NIO实现</strong>I&#x2F;O多路复用</strong>的核心。它允许<strong>单个线程监视多个Channel</strong>的状态（例如：是否可读、是否可写、是否已连接等）。这使得一个线程可以管理成百上千个网络连接，极大地减少了线程数量和上下文切换的开销。</p>
<p><strong>核心概念：</strong></p>
<ul>
<li><strong>事件 (SelectionKey)：</strong> <code>SelectionKey.OP_ACCEPT</code> (连接接受), <code>OP_CONNECT</code> (连接建立), <code>OP_READ</code> (读就绪), <code>OP_WRITE</code> (写就绪)。</li>
<li><strong>注册 (Register)：</strong> 将 Channel 注册到 Selector 上，并指定感兴趣的事件。</li>
<li><strong>选择 (Select)：</strong> Selector 会阻塞，直到有一个或多个注册的 Channel 上有你感兴趣的事件就绪。</li>
<li><strong>选择键集合 (Selected Keys)：</strong> 当 <code>select()</code> 方法返回后，可以通过 <code>selectedKeys()</code> 方法获取所有就绪的事件集合，然后进行迭代处理。</li>
</ul>
<p><strong>工作流程：</strong></p>
<ol>
<li><p><strong>创建Selector</strong>: <code>Selector selector = Selector.open();</code></p>
</li>
<li><p><strong>注册Channel</strong>: 将需要监视的Channel注册到Selector上，并指定你<strong>感兴趣的事件</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Channel必须是非阻塞的</span></span><br><span class="line">channel.configureBlocking(<span class="literal">false</span>); </span><br><span class="line"><span class="comment">// 2. 注册并指定感兴趣的事件 (e.g., OP_READ)</span></span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>感兴趣的事件类型 (<code>SelectionKey</code>常量):</strong><ul>
<li><code>OP_CONNECT</code>: 连接完成事件 (用于客户端)</li>
<li><code>OP_ACCEPT</code>: 接受新连接事件 (用于服务器端)</li>
<li><code>OP_READ</code>: 读就绪事件</li>
<li><code>OP_WRITE</code>: 写就绪事件</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>轮询就绪事件</strong>: 在一个循环中，调用 <code>selector.select()</code>。这个方法会<strong>阻塞</strong>，直到至少有一个注册的Channel上发生了你感兴趣的事件。</p>
</li>
<li><p><strong>处理就绪Channel</strong>: <code>select()</code> 方法返回后，通过 <code>selector.selectedKeys()</code> 获取所有就绪事件的 <code>SelectionKey</code> 集合。</p>
</li>
<li><p><strong>遍历并处理</strong>: 遍历 <code>SelectionKey</code> 集合，根据事件类型进行相应的处理（例如，如果是 <code>OP_ACCEPT</code>，就接受新连接；如果是 <code>OP_READ</code>，就从Channel读取数据）。</p>
</li>
<li><p><strong>移除Key</strong>: <strong>非常重要的一步！</strong> 处理完一个 <code>SelectionKey</code> 后，必须手动从 <code>selectedKeys</code> 集合中将其<strong>移除 (<code>iterator.remove()</code>)</strong>，否则Selector下次还会报告这个已处理的事件。</p>
</li>
</ol>
<p><strong>示例：一个简单的 NIO Server 骨架</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建 Selector</span></span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"><span class="comment">// 2. 创建 ServerSocketChannel 并设置为非阻塞</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverSocket</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">serverSocket.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">serverSocket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将 channel 注册到 selector，监听 ACCEPT 事件</span></span><br><span class="line">serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 4. 阻塞，直到有事件就绪</span></span><br><span class="line">    selector.select();</span><br><span class="line">    <span class="comment">// 5. 获取就绪的事件集合</span></span><br><span class="line">    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123; <span class="comment">// 处理新连接</span></span><br><span class="line">            <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">            client.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 将新连接的客户端 Channel 也注册到 Selector，监听读事件</span></span><br><span class="line">            client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端已连接: &quot;</span> + client.getRemoteAddress());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123; <span class="comment">// 处理读事件</span></span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> client.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123; <span class="comment">// 连接关闭</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                client.close();</span><br><span class="line">                System.out.println(<span class="string">&quot;客户端断开连接&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="comment">// 处理接收到的数据...</span></span><br><span class="line">                <span class="comment">// 例如，可以注册写事件来回显数据</span></span><br><span class="line">                client.register(selector, SelectionKey.OP_WRITE, buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123; <span class="comment">// 处理写事件</span></span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">            client.write(buffer);</span><br><span class="line">            <span class="keyword">if</span> (!buffer.hasRemaining()) &#123; <span class="comment">// 数据已写完</span></span><br><span class="line">                key.interestOps(SelectionKey.OP_READ); <span class="comment">// 改回监听读事件</span></span><br><span class="line">            &#125;</span><br><span class="line">            buffer.compact();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6. 非常重要：从集合中移除已处理的 key</span></span><br><span class="line">        iter.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-3-Paths-Files"><a href="#11-3-Paths-Files" class="headerlink" title="11.3 Paths &amp; Files"></a>11.3 Paths &amp; Files</h3><h4 id="11-3-1-Paths"><a href="#11-3-1-Paths" class="headerlink" title="11.3.1 Paths"></a>11.3.1 Paths</h4><p><code>Paths</code> 类是一个非常简单的工具类，它只包含静态方法，其核心作用就是用来获取 <code>Path</code> 接口的实例。</p>
<h5 id="1-Path接口"><a href="#1-Path接口" class="headerlink" title="1. Path接口"></a>1. Path接口</h5><p><code>Path</code> 接口是 <code>java.nio.file</code> 包的核心接口之一，它代表了一个文件系统路径。这个路径可以指向一个文件、一个目录，甚至可以不存在。它是 <code>java.io.File</code> 类的现代化替代品。</p>
<h5 id="2-核心方法：Paths-get"><a href="#2-核心方法：Paths-get" class="headerlink" title="2. 核心方法：Paths.get()"></a>2. 核心方法：<code>Paths.get()</code></h5><p>最常用的方法是 <code>Paths.get(String first, String... more)</code>。它接受一个或多个字符串，将它们连接起来构成一个路径字符串，然后将其转换为 <code>Path</code> 对象。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建绝对路径</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">absolutePath</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;C:\\Users\\test\\data.txt&quot;</span>); <span class="comment">// Windows</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建相对路径</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">relativePath</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;myDir&quot;</span>, <span class="string">&quot;data.txt&quot;</span>); <span class="comment">// 等价于 &quot;myDir/data.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用可变参数</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">complexPath</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;C:&quot;</span>, <span class="string">&quot;projects&quot;</span>, <span class="string">&quot;myapp&quot;</span>, <span class="string">&quot;src&quot;</span>, <span class="string">&quot;Main.java&quot;</span>);</span><br><span class="line">System.out.println(complexPath); <span class="comment">// 输出: C:\projects\myapp\src\Main.java (Windows)</span></span><br></pre></td></tr></table></figure>

<h5 id="3-Path-接口的常用方法"><a href="#3-Path-接口的常用方法" class="headerlink" title="3. Path 接口的常用方法"></a>3. Path 接口的常用方法</h5><p>获取到 <code>Path</code> 对象后，你可以对其进行各种解析和操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;/home/user/docs/letter.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取路径组成部分</span></span><br><span class="line">System.out.println(<span class="string">&quot;FileName: &quot;</span> + path.getFileName());   <span class="comment">// letter.txt</span></span><br><span class="line">System.out.println(<span class="string">&quot;Parent: &quot;</span> + path.getParent());       <span class="comment">// /home/user/docs</span></span><br><span class="line">System.out.println(<span class="string">&quot;Root: &quot;</span> + path.getRoot());           <span class="comment">// / (在Linux上)</span></span><br><span class="line">System.out.println(<span class="string">&quot;NameCount: &quot;</span> + path.getNameCount()); <span class="comment">// 3 (user, docs, letter.txt)</span></span><br><span class="line">System.out.println(<span class="string">&quot;getName(0): &quot;</span> + path.getName(<span class="number">0</span>));    <span class="comment">// user</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析路径</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">base</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;/home/user&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">resolved</span> <span class="operator">=</span> base.resolve(<span class="string">&quot;photos/vacation.jpg&quot;</span>); </span><br><span class="line"><span class="comment">// resolved 现在是 /home/user/photos/vacation.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">sibling</span> <span class="operator">=</span> path.resolveSibling(<span class="string">&quot;contract.pdf&quot;</span>); </span><br><span class="line"><span class="comment">// sibling 现在是 /home/user/docs/contract.pdf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造相对路径</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">from</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;/home/user&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">to</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;/home/user/docs/letter.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">relative</span> <span class="operator">=</span> from.relativize(to); </span><br><span class="line"><span class="comment">// relative 现在是 docs/letter.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径标准化（去除冗余的 . 和 ..）</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">messyPath</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;/home/./user/../docs/./file&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">cleanPath</span> <span class="operator">=</span> messyPath.normalize(); </span><br><span class="line"><span class="comment">// cleanPath 现在是 /docs/file</span></span><br></pre></td></tr></table></figure>

<h4 id="11-3-2-Files"><a href="#11-3-2-Files" class="headerlink" title="11.3.2 Files"></a>11.3.2 Files</h4><p><code>Files</code> 类是一个纯粹的工具类，提供了大量的静态方法来对 <code>Path</code> 对象所指向的文件或目录进行<strong>读取、写入、创建、删除、复制、移动、属性查询</strong>等操作。它的方法大多设计良好，错误时抛出 <code>IOException</code>。</p>
<h5 id="1-检查文件状态（常用作操作前提）"><a href="#1-检查文件状态（常用作操作前提）" class="headerlink" title="1. 检查文件状态（常用作操作前提）"></a>1. 检查文件状态（常用作操作前提）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查存在性</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> Files.exists(path);</span><br><span class="line"><span class="comment">// 检查是否不存在（逻辑更清晰）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">notExists</span> <span class="operator">=</span> Files.notExists(path);</span><br><span class="line"><span class="comment">// 检查是否可读/可写/可执行</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isReadable</span> <span class="operator">=</span> Files.isReadable(path);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isWritable</span> <span class="operator">=</span> Files.isWritable(path);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isExecutable</span> <span class="operator">=</span> Files.isExecutable(path);</span><br><span class="line"><span class="comment">// 检查是否是常规文件（不是目录、符号链接等）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFile</span> <span class="operator">=</span> Files.isRegularFile(path);</span><br><span class="line"><span class="comment">// 检查是否是目录</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isDirectory</span> <span class="operator">=</span> Files.isDirectory(path);</span><br><span class="line"><span class="comment">// 检查是否是符号链接</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isSymbolicLink</span> <span class="operator">=</span> Files.isSymbolicLink(path);</span><br></pre></td></tr></table></figure>

<h5 id="2-读写文件内容（非常方便）"><a href="#2-读写文件内容（非常方便）" class="headerlink" title="2. 读写文件内容（非常方便）"></a>2. 读写文件内容（非常方便）</h5><p><strong>读取所有行（小文件）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取所有行到一个List中</span></span><br><span class="line">List&lt;String&gt; allLines = Files.readAllLines(path, StandardCharsets.UTF_8);</span><br><span class="line"><span class="keyword">for</span> (String line : allLines) &#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取所有字节（如图片）</span></span><br><span class="line"><span class="type">byte</span>[] fileBytes = Files.readAllBytes(path);</span><br></pre></td></tr></table></figure>

<p><strong>写入内容：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接写入字符串（会覆盖原内容）</span></span><br><span class="line">List&lt;String&gt; lines = Arrays.asList(<span class="string">&quot;Line 1&quot;</span>, <span class="string">&quot;Line 2&quot;</span>, <span class="string">&quot;Line 3&quot;</span>);</span><br><span class="line">Files.write(path, lines, StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加模式写入</span></span><br><span class="line">Files.write(path, lines, StandardCharsets.UTF_8, StandardOpenOption.APPEND);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入字节</span></span><br><span class="line"><span class="type">byte</span>[] data = ...;</span><br><span class="line">Files.write(path, data);</span><br></pre></td></tr></table></figure>

<p><strong>使用 Stream API 处理大文件（推荐，避免内存溢出）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逐行读取（Stream会自动关闭）</span></span><br><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(path, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    lines.filter(line -&gt; line.contains(<span class="string">&quot;error&quot;</span>))</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历文件树</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">startDir</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;/path/to/start&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (Stream&lt;Path&gt; stream = Files.walk(startDir, <span class="number">10</span>)) &#123; <span class="comment">// 第二个参数是最大深度</span></span><br><span class="line">    stream.filter(Files::isRegularFile)</span><br><span class="line">          .filter(p -&gt; p.toString().endsWith(<span class="string">&quot;.java&quot;</span>))</span><br><span class="line">          .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-创建、复制、移动、删除"><a href="#3-创建、复制、移动、删除" class="headerlink" title="3. 创建、复制、移动、删除"></a>3. 创建、复制、移动、删除</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;source.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;backup.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">dir</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;newDir&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件（如果文件已存在会抛出 FileAlreadyExistsException）</span></span><br><span class="line">Files.createFile(target);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建目录（包括不存在的父目录）</span></span><br><span class="line">Files.createDirectories(dir); <span class="comment">// 类似 mkdir -p</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制文件</span></span><br><span class="line">Files.copy(source, target, </span><br><span class="line">          StandardCopyOption.REPLACE_EXISTING, <span class="comment">// 如果目标存在则覆盖</span></span><br><span class="line">          StandardCopyOption.COPY_ATTRIBUTES); <span class="comment">// 同时复制文件属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动/重命名文件</span></span><br><span class="line">Files.move(source, target, StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除文件（如果文件不存在会抛出 NoSuchFileException）</span></span><br><span class="line">Files.delete(target);</span><br><span class="line"><span class="comment">// 安全删除（文件不存在返回false，不会抛出异常）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">deleted</span> <span class="operator">=</span> Files.deleteIfExists(target);</span><br></pre></td></tr></table></figure>

<h5 id="4-获取和设置文件属性"><a href="#4-获取和设置文件属性" class="headerlink" title="4. 获取和设置文件属性"></a>4. 获取和设置文件属性</h5><p><code>Files</code> 类可以获取丰富的文件元数据（Metadata）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取基本属性</span></span><br><span class="line"><span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Files.size(path); <span class="comment">// 文件大小（字节）</span></span><br><span class="line"><span class="type">FileTime</span> <span class="variable">lastModifiedTime</span> <span class="operator">=</span> Files.getLastModifiedTime(path);</span><br><span class="line">Files.setLastModifiedTime(path, FileTime.from(Instant.now())); <span class="comment">// 设置修改时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件所有者</span></span><br><span class="line"><span class="type">UserPrincipal</span> <span class="variable">owner</span> <span class="operator">=</span> Files.getOwner(path);</span><br><span class="line">System.out.println(owner.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> Files.probeContentType(path);</span><br><span class="line">System.out.println(<span class="string">&quot;Content-Type: &quot;</span> + contentType); <span class="comment">// e.g., &quot;text/plain&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 BasicFileAttributes 获取所有基础属性（一次IO操作，效率高）</span></span><br><span class="line"><span class="type">BasicFileAttributes</span> <span class="variable">attrs</span> <span class="operator">=</span> Files.readAttributes(path, BasicFileAttributes.class);</span><br><span class="line">System.out.println(<span class="string">&quot;Creation time: &quot;</span> + attrs.creationTime());</span><br><span class="line">System.out.println(<span class="string">&quot;Is directory: &quot;</span> + attrs.isDirectory());</span><br><span class="line">System.out.println(<span class="string">&quot;Is symbolic link: &quot;</span> + attrs.isSymbolicLink());</span><br></pre></td></tr></table></figure>

<h3 id="11-4-总结与应用"><a href="#11-4-总结与应用" class="headerlink" title="11.4 总结与应用"></a>11.4 总结与应用</h3><h4 id="11-4-1-优劣势"><a href="#11-4-1-优劣势" class="headerlink" title="11.4.1 优劣势"></a>11.4.1 优劣势</h4><p><strong>优势：</strong></p>
<ol>
<li><strong>高性能：</strong> 单线程管理大量连接，极大减少了线程上下文切换的开销。</li>
<li><strong>资源节约：</strong> 避免了为每个连接创建一个线程的巨大资源消耗。</li>
<li><strong>非阻塞：</strong> I&#x2F;O 操作不会阻塞线程，允许线程做其他事情，提高了 CPU 利用率。</li>
</ol>
<p><strong>劣势：</strong></p>
<ol>
<li><strong>API 复杂：</strong> 编程模型比 BIO 复杂得多，需要对三大组件有深刻理解。</li>
<li><strong>调试困难：</strong> 异步和非阻塞的特性使得调试和问题排查更具挑战性。</li>
<li><strong>“空轮询” Bug：</strong> 在旧版本的 JDK 中，Selector 的 <code>select()</code> 方法可能在没有就绪事件时无故返回，导致 CPU 100%，不过此问题在 JDK 1.6 及之后版本已修复。</li>
</ol>
<h4 id="11-4-2-最佳实践"><a href="#11-4-2-最佳实践" class="headerlink" title="11.4.2 最佳实践"></a>11.4.2 最佳实践</h4><p>直接使用原生 NIO API 进行开发非常繁琐且容易出错。因此，在实践中，我们通常会使用基于 NIO 构建的<strong>高性能网络框架</strong>，如 <strong>Netty</strong> 或 <strong>Mina</strong>。这些框架对复杂的 NIO API 进行了极佳的封装，提供了简单易用的接口和强大的功能（如心跳检测、粘包拆包处理、编解码器等），极大地提升了开发效率和应用程序的健壮性。</p>
<hr>
<h2 id="12-AIO【未来】"><a href="#12-AIO【未来】" class="headerlink" title="12. AIO【未来】"></a>12. AIO【未来】</h2><h3 id="12-1-概念"><a href="#12-1-概念" class="headerlink" title="12.1 概念"></a>12.1 概念</h3><p><strong>AIO</strong>，全称为 <strong>Asynchronous I&#x2F;O</strong>（异步 I&#x2F;O），是在 Java 7 中引入的一种全新的 I&#x2F;O 模型。它的核心思想是 <strong>“订阅-通知”</strong> 模式。</p>
<p>与 NIO 的“非阻塞”和“就绪选择”不同，AIO 是真正的<strong>异步</strong>。这意味着：</p>
<ul>
<li><strong>NIO (Non-blocking I&#x2F;O):</strong> 你主动去问（轮询 Selector）“数据准备好了吗？”，如果准备好了，你自己再去读写（这个读写过程本身可能是阻塞的，但通常很快）。</li>
<li><strong>AIO (Asynchronous I&#x2F;O):</strong> 你发起一个 I&#x2F;O 操作（如 <code>read</code>），并提供一个“回调函数”（Callback）。然后你就可以立刻去做别的事情了。<strong>当操作系统真正完成了整个 I&#x2F;O 操作（数据已经从内核缓冲区复制到你的用户缓冲区）后，它会主动通知你</strong>，你的回调函数才会被调用。</li>
</ul>
<p><strong>一个经典的比喻：</strong></p>
<ul>
<li><strong>BIO (同步阻塞)：</strong> 你去餐馆点餐，<strong>一直站在柜台前等着</strong>，直到厨师做好饭后你才端着饭离开。期间你什么也干不了。</li>
<li><strong>NIO (同步非阻塞)：</strong> 你点完餐后，<strong>不停地回到柜台问</strong>：“好了吗？好了吗？”（轮询）。在问的间隙，你可以玩手机。直到某次问的时候，饭做好了，你才自己端走。</li>
<li><strong>AIO (异步非阻塞)：</strong> 你点完餐后，<strong>直接回座位玩手机</strong>。你<strong>不需要主动去问</strong>。厨师做好饭后，<strong>服务员会主动把饭送到你的桌子上</strong>（回调通知），然后你开始吃饭。</li>
</ul>
<hr>
<h3 id="12-2-核心组件"><a href="#12-2-核心组件" class="headerlink" title="12.2 核心组件"></a>12.2 核心组件</h3><p>Java AIO 的核心类主要在 <code>java.nio.channels</code> 包下，以 <code>Asynchronous</code> 开头。</p>
<ol>
<li><strong><code>AsynchronousChannel</code> (异步通道)</strong><br>这是一个标记接口，所有支持异步操作的通道都实现它。最重要的两个实现是：<ul>
<li><code>AsynchronousSocketChannel</code>：用于客户端 TCP 套接字。</li>
<li><code>AsynchronousServerSocketChannel</code>：用于服务端 TCP 套接字，监听接入的连接。</li>
<li><code>AsynchronousFileChannel</code>：用于异步文件操作。</li>
</ul>
</li>
<li><strong><code>CompletionHandler</code> (完成处理器)</strong><br>这是 AIO 的“回调函数”接口。当你发起一个异步操作时，需要传递一个 <code>CompletionHandler</code> 的实现。它有两个方法：<ul>
<li><code>completed(V result, A attachment)</code>：当 I&#x2F;O 操作<strong>成功完成</strong>时被调用。</li>
<li><code>failed(Throwable exc, A attachment)</code>：当 I&#x2F;O 操作<strong>失败</strong>时被调用。</li>
</ul>
</li>
<li><strong><code>Future</code> (未来结果)</strong><br>除了回调模式，AIO 也支持 <code>Future</code> 模式。当你发起一个异步操作时，它<strong>立即返回一个 <code>Future</code> 对象</strong>。你可以通过这个 <code>Future</code> 对象来检查操作是否完成 (<code>isDone()</code>)，或者<strong>阻塞地等待操作完成并获取结果</strong> (<code>get()</code>)。这为开发者提供了另一种处理异步操作的方式。</li>
</ol>
<h3 id="12-3-AIO工作模式"><a href="#12-3-AIO工作模式" class="headerlink" title="12.3 AIO工作模式"></a>12.3 AIO工作模式</h3><h4 id="12-3-1-回调模式-Callback-based-更“异步”"><a href="#12-3-1-回调模式-Callback-based-更“异步”" class="headerlink" title="12.3.1 回调模式 (Callback-based) - 更“异步”"></a>12.3.1 回调模式 (Callback-based) - 更“异步”</h4><p>使用 <code>CompletionHandler</code>。</p>
<p><strong>示例：一个简单的 AIO 服务器端 Accept 操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建异步服务端通道并绑定端口</span></span><br><span class="line"><span class="type">AsynchronousServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> AsynchronousServerSocketChannel.open()</span><br><span class="line">        .bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 发起一个异步 Accept 操作，等待客户端连接</span></span><br><span class="line"><span class="comment">//    第一个参数是附件（可为null），第二个是CompletionHandler</span></span><br><span class="line">server.accept(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Void&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 当有客户端成功连接时，此方法被系统回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel client, Void attachment)</span> &#123;</span><br><span class="line">        <span class="comment">// 非常重要：立即再次发起 accept，以接收下一个客户端连接</span></span><br><span class="line">        server.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理这个新连接，比如为其发起一个读操作</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发起一个异步读操作</span></span><br><span class="line">        client.read(buffer, buffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer bytesRead, ByteBuffer buffer)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123; client.close(); &#125; <span class="keyword">catch</span> (IOException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="comment">// 处理读取到的数据...</span></span><br><span class="line">                System.out.println(StandardCharsets.UTF_8.decode(buffer));</span><br><span class="line">                buffer.clear();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 继续发起下一次读操作，形成循环</span></span><br><span class="line">                client.read(buffer, buffer, <span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer buffer)</span> &#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">                <span class="keyword">try</span> &#123; client.close(); &#125; <span class="keyword">catch</span> (IOException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 如果 Accept 操作失败（如端口被占用），此方法被回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Void attachment)</span> &#123;</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 防止主线程退出，因为所有操作都是异步的</span></span><br><span class="line">System.in.read();</span><br></pre></td></tr></table></figure>

<h4 id="12-3-2-Future-模式-Future-based-更“可控”"><a href="#12-3-2-Future-模式-Future-based-更“可控”" class="headerlink" title="12.3.2 Future 模式 (Future-based) - 更“可控”"></a>12.3.2 Future 模式 (Future-based) - 更“可控”</h4><p>使用操作返回的 <code>Future</code> 对象来等待结果。</p>
<p><strong>示例：使用 Future 进行异步文件读取</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;largefile.bin&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (<span class="type">AsynchronousFileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> AsynchronousFileChannel.open(path, StandardOpenOption.READ)) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>); <span class="comment">// 1MB buffer</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 从文件开头读取</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起异步读操作，立即返回一个 Future</span></span><br><span class="line">    Future&lt;Integer&gt; operation = fileChannel.read(buffer, position);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在等待读操作完成的同时，主线程可以去做其他事情...</span></span><br><span class="line">    doSomethingElse();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果事情做完了，但读操作还没完，可以在这里阻塞等待，直到完成</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">bytesRead</span> <span class="operator">=</span> operation.get(); <span class="comment">// 这是一个阻塞调用</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Read &quot;</span> + bytesRead + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="comment">// ... 处理数据</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ExecutionException | InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-4-AIO-的现状与总结"><a href="#12-4-AIO-的现状与总结" class="headerlink" title="12.4 AIO 的现状与总结"></a>12.4 AIO 的现状与总结</h3><p><strong>优点：</strong></p>
<ul>
<li>理论性能上限非常高，是真正的异步。</li>
<li>对于文件 I&#x2F;O 操作，<code>AsynchronousFileChannel</code> 是一个不错的选择。</li>
</ul>
<p><strong>缺点与挑战：</strong></p>
<ol>
<li><strong>Linux 支持问题：</strong> 这是最大的硬伤。由于 Linux 内核层面对网络 AIO 的支持不完善，导致 Java AIO 在 Linux 下的网络性能甚至可能不如成熟的 NIO 框架（如 Netty）。</li>
<li><strong>编程复杂度极高：</strong> 嵌套的回调函数难以编写、阅读、调试和维护，容易陷入“回调地狱”。</li>
<li><strong>生态系统薄弱：</strong> 主流的高性能网络框架（如 <strong>Netty</strong>, <strong>gRPC</strong>）都基于 NIO 构建，因为它们需要跨平台的高性能。AIO 没有形成强大的生态系统。</li>
</ol>
<p><strong>实践建议：</strong></p>
<ul>
<li><strong>对于网络编程，几乎总是应该选择 NIO</strong>，并使用基于 NIO 的成熟框架（如 <strong>Netty</strong>）。Netty 在 NIO 之上已经做了极佳的封装和优化，其性能和易用性远超自己编写的 AIO 代码。</li>
<li><strong>只有在 Windows 平台下进行高性能网络服务端开发</strong>，且对 Windows 的 IOCP 非常熟悉时，才考虑直接使用 AIO。</li>
<li><strong>对于大文件的异步读写操作</strong>，可以考虑使用 <code>AsynchronousFileChannel</code>。</li>
</ul>
<hr>
<hr>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E5%9B%9B%E3%80%81%E9%9B%86%E5%90%88/" rel="prev" title="四、集合">
                  <i class="fa fa-angle-left"></i> 四、集合
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E5%85%AD%E3%80%81%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/" rel="next" title="六、常用工具类">
                  六、常用工具类 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
