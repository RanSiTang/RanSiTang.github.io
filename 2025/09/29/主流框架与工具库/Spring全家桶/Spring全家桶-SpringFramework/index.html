<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="前言：SpringFrameworkSpring Framework 是 Java 企业级应用开发领域最流行、最强大的轻量级开源框架，被视为 Java 开发的“事实标准”。 它的核心作用在于通过 控制反转 (IoC) 和 依赖注入 (DI) 机制，将对象的创建与依赖关系管理交给容器处理，从而实现代码组件的彻底解耦，让系统更易于维护和测试；同时，它利用 面向切面编程 (AOP) 将事务管理、日志记录">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring全家桶-SpringFramework">
<meta property="og:url" content="http://example.com/2025/09/29/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringFramework/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="前言：SpringFrameworkSpring Framework 是 Java 企业级应用开发领域最流行、最强大的轻量级开源框架，被视为 Java 开发的“事实标准”。 它的核心作用在于通过 控制反转 (IoC) 和 依赖注入 (DI) 机制，将对象的创建与依赖关系管理交给容器处理，从而实现代码组件的彻底解耦，让系统更易于维护和测试；同时，它利用 面向切面编程 (AOP) 将事务管理、日志记录">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-09-29T07:53:40.000Z">
<meta property="article:modified_time" content="2025-12-27T09:43:48.218Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/09/29/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringFramework/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/09/29/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringFramework/","path":"2025/09/29/主流框架与工具库/Spring全家桶/Spring全家桶-SpringFramework/","title":"Spring全家桶-SpringFramework"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Spring全家桶-SpringFramework | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80%EF%BC%9ASpringFramework"><span class="nav-text">前言：SpringFramework</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8"><span class="nav-text">一、核心容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5"><span class="nav-text">1. 核心设计理念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-Inversion-of-Control-IoC"><span class="nav-text">1.1 控制反转(Inversion of Control,IoC)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">1.1.1 核心概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC"><span class="nav-text">1.1.2 核心价值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-IoC%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%B8%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">1.2 IoC的两种主要实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE-Dependency-Lookup-DL"><span class="nav-text">1.2.1 依赖查找(Dependency Lookup,DL)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-Dependency-Injection-DI"><span class="nav-text">1.2.2 依赖注入(Dependency Injection,DI)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-DI-%E4%B8%8E-DL-%E7%9A%84%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="nav-text">1.2.3 DI 与 DL 的对比总结</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%AE%B9%E5%99%A8%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%90%AF%E5%8A%A8"><span class="nav-text">二、容器架构与启动</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Spring-IoC-%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-text">1. Spring IoC 容器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E8%90%BD%E5%9C%B0%EF%BC%9AIoC-%E6%80%9D%E6%83%B3%E7%9A%84%E2%80%9C%E5%AE%9E%E4%BD%93%E5%8C%96%E2%80%9D"><span class="nav-text">1.1 从理论到落地：IoC 思想的“实体化”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3"><span class="nav-text">1.2 核心职责</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="nav-text">1.3 容器的工作流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3%E4%BD%93%E7%B3%BB"><span class="nav-text">2. 核心接口体系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%A6%82%E8%A7%88"><span class="nav-text">2.1 概览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E4%BD%8E%E7%BA%A7%E5%AE%B9%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="nav-text">2.2 低级容器接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-BeanFactory%EF%BC%88%E9%A1%B6%E5%B1%82%E6%A0%B9%E6%8E%A5%E5%8F%A3%EF%BC%89"><span class="nav-text">2.2.1 BeanFactory（顶层根接口）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-ListableBeanFactory%EF%BC%88%E5%8F%AF%E5%88%97%E4%B8%BE%E8%83%BD%E5%8A%9B%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%89"><span class="nav-text">2.2.2 ListableBeanFactory（可列举能力的扩展）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-HierarchicalBeanFactory%EF%BC%88%E5%88%86%E5%B1%82%E8%83%BD%E5%8A%9B%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%89"><span class="nav-text">2.2.3 HierarchicalBeanFactory（分层能力的扩展）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-AutowireCapableBeanFactory%EF%BC%88%E5%A4%96%E9%83%A8%E9%9B%86%E6%88%90%E8%83%BD%E5%8A%9B%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%89"><span class="nav-text">2.2.4 AutowireCapableBeanFactory（外部集成能力的扩展）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-BeanDefinitionRegistry"><span class="nav-text">2.3 BeanDefinitionRegistry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E9%AB%98%E7%BA%A7%E5%AE%B9%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="nav-text">2.4 高级容器接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-ApplicationContext%EF%BC%88%E6%A0%B8%E5%BF%83%E9%97%A8%E9%9D%A2%EF%BC%89"><span class="nav-text">2.4.1 ApplicationContext（核心门面）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-ConfigurableApplicationContext%EF%BC%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%8E%A7%E5%88%B6%EF%BC%89"><span class="nav-text">2.4.2 ConfigurableApplicationContext（生命周期控制）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-text">1. 概述</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E6%A0%87%E5%87%86%E9%AA%A8%E6%9E%B6%E7%B1%BB%EF%BC%9AAbstractApplicationContext"><span class="nav-text">2.5 标准骨架类：AbstractApplicationContext</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1-%E5%AE%9A%E4%BD%8D"><span class="nav-text">2.5.1 定位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%EF%BC%9Arefresh-%E7%9A%84-12-%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="nav-text">2.5.2 核心流程：refresh() 的 12 个步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-3-%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B%E6%8B%86%E8%A7%A3"><span class="nav-text">2.5.3 详细流程拆解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-prepareRefresh-%E8%BF%9B%E5%9C%BA%E5%87%86%E5%A4%87"><span class="nav-text">1. prepareRefresh() - 进场准备</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-obtainFreshBeanFactory-%E6%90%9E%E5%AE%9A%E4%BB%93%E5%BA%93"><span class="nav-text">2. obtainFreshBeanFactory() - 搞定仓库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-prepareBeanFactory-beanFactory-%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E9%85%8D%E7%BD%AE"><span class="nav-text">3. prepareBeanFactory(beanFactory) - 基础设施配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-postProcessBeanFactory-beanFactory-%E5%AD%90%E7%B1%BB%E6%89%A9%E5%B1%95%E7%82%B9"><span class="nav-text">4. postProcessBeanFactory(beanFactory) - 子类扩展点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-invokeBeanFactoryPostProcessors-beanFactory-%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%89%AB%E6%8F%8F"><span class="nav-text">5. invokeBeanFactoryPostProcessors(beanFactory) - 【重要】解析配置与扫描</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-registerBeanPostProcessors-beanFactory-%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91%E6%8B%9B%E8%81%98%E8%B4%A8%E6%A3%80%E5%91%98"><span class="nav-text">6. registerBeanPostProcessors(beanFactory) - 【重要】招聘质检员</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-initMessageSource-%E5%9B%BD%E9%99%85%E5%8C%96"><span class="nav-text">7. initMessageSource() - 国际化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-initApplicationEventMulticaster-%E4%BA%8B%E4%BB%B6%E5%B9%BF%E6%92%AD%E5%99%A8"><span class="nav-text">8. initApplicationEventMulticaster() - 事件广播器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-onRefresh-%E5%AD%90%E7%B1%BB%E6%89%A9%E5%B1%95%E7%82%B9"><span class="nav-text">9. onRefresh() - 子类扩展点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-registerListeners-%E6%B3%A8%E5%86%8C%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-text">10. registerListeners() - 注册监听器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-finishBeanFactoryInitialization-beanFactory-%E3%80%90%E6%9C%80%E6%A0%B8%E5%BF%83%E3%80%91%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8D%95%E4%BE%8B"><span class="nav-text">11. finishBeanFactoryInitialization(beanFactory) - 【最核心】实例化单例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-finishRefresh-%E5%AE%8C%E5%B7%A5"><span class="nav-text">12. finishRefresh() - 完工</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E7%BB%88%E6%9E%81%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%9ADefaultListableBeanFactory"><span class="nav-text">2.6 终极实现类：DefaultListableBeanFactory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-%E6%80%BB%E7%BB%93"><span class="nav-text">2.7 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-ApplicationContext%E7%9A%84%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-text">3. ApplicationContext的核心实现类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-XML%E6%97%B6%E4%BB%A3"><span class="nav-text">3.1 XML时代</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-ClassPathXmlApplicationContext-%E4%BB%8E%E7%B1%BB%E8%B7%AF%E5%BE%84%E5%8A%A0%E8%BD%BDXML"><span class="nav-text">3.1.1  ClassPathXmlApplicationContext: 从类路径加载XML</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AE%9A%E4%BD%8D%E4%B8%8E%E8%81%8C%E8%B4%A3"><span class="nav-text">1. 定位与职责</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E8%B7%AF%E5%BE%84%EF%BC%9F"><span class="nav-text">2. 核心概念：什么是类路径？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">3. 代码示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-FileSystemXmlApplicationContext-%E4%BB%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8A%A0%E8%BD%BDXML"><span class="nav-text">3.1.2 FileSystemXmlApplicationContext: 从文件系统加载XML</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AE%9A%E4%BD%8D%E4%B8%8E%E8%81%8C%E8%B4%A3-1"><span class="nav-text">1. 定位与职责</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-ClassPath-vs-FileSystem"><span class="nav-text">2. ClassPath vs FileSystem</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="nav-text">3. 代码示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E7%8E%B0%E4%BB%A3%E6%A0%87%E5%87%86%EF%BC%9AAnnotationConfigApplicationContext"><span class="nav-text">3.2 现代标准：AnnotationConfigApplicationContext</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%A6%82%E8%BF%B0"><span class="nav-text">3.2.1 核心定位与概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="nav-text">3.2.2 继承体系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E6%A0%B8%E5%BF%83%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-text">3.2.3 核心成员变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%EF%BC%88%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%85%A5%E5%8F%A3%EF%BC%89"><span class="nav-text">3.2.4 构造函数深度解析（启动流程入口）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">1. 无参构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%EF%BC%89"><span class="nav-text">2. 有参构造函数（常见用法）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-5-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-text">3.2.5 核心方法源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-register-Class-componentClasses"><span class="nav-text">1. register(Class&lt;?&gt;... componentClasses)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-scan-String-basePackages"><span class="nav-text">2. scan(String... basePackages)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-6-%E4%B8%8E-refresh-%E7%9A%84%E8%81%94%E5%8A%A8%E6%9C%BA%E5%88%B6"><span class="nav-text">3.2.6 与 refresh() 的联动机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Web-%E7%8E%AF%E5%A2%83"><span class="nav-text">3.3 Web 环境</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3%EF%BC%9AWebApplicationContext"><span class="nav-text">3.3.1 核心接口：WebApplicationContext</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="nav-text">1. 接口定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-text">2. 三大特性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E5%AE%B9%E5%99%A8%E4%B8%8E-ServletContext-%E7%9A%84%E2%80%9C%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E2%80%9D"><span class="nav-text">3.3.2 容器与 ServletContext 的“双向绑定”</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Spring-%E5%BC%95%E7%94%A8-ServletContext"><span class="nav-text">1. Spring 引用 ServletContext</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-ServletContext-%E5%BC%95%E7%94%A8-Spring"><span class="nav-text">2. ServletContext 引用 Spring</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-WebApplicationContextUtils"><span class="nav-text">3. 工具类代码示例 (WebApplicationContextUtils)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-%E5%90%AF%E5%8A%A8%E9%A9%B1%E5%8A%A8%E5%99%A8%EF%BC%9AContextLoaderListener"><span class="nav-text">3.3.3 启动驱动器：ContextLoaderListener</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%81%8C%E8%B4%A3"><span class="nav-text">1. 职责</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%8E%9F%E7%90%86"><span class="nav-text">2. 启动流程原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B-web-xml"><span class="nav-text">3. 配置示例 (web.xml)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-Web-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%BA%95%E5%B1%82%E6%94%AF%E6%8C%81"><span class="nav-text">3.3.4 Web 作用域的底层支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-5-%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-text">3.3.5 常见实现类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="nav-text">4. 启动流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E9%9D%9EWeb%E7%8E%AF%E5%A2%83"><span class="nav-text">4.1 非Web环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E4%BC%A0%E7%BB%9FWeb%E7%8E%AF%E5%A2%83"><span class="nav-text">4.2 传统Web环境</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81Bean"><span class="nav-text">三、Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-Spring-Bean%EF%BC%9F"><span class="nav-text">1. 什么是 Spring Bean？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89"><span class="nav-text">1.1 基本定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Spring-Bean-%E4%B8%8E-POJO-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">1.2 Spring Bean 与 POJO 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9A%E4%BB%8E-POJO-%E5%88%B0-Bean-%E7%9A%84%E8%9C%95%E5%8F%98"><span class="nav-text">1.2.1 核心机制：从 POJO 到 Bean 的蜕变</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-Bean-%E7%9A%84%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7"><span class="nav-text">1.2.2 Bean 的关键特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E6%B7%B1%E5%BA%A6%E5%AF%B9%E6%AF%94%EF%BC%9ASpring-Bean-vs-POJO"><span class="nav-text">1.2.3 深度对比：Spring Bean vs POJO</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-BeanDefinition"><span class="nav-text">1.3 BeanDefinition</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-%E4%BB%80%E4%B9%88%E6%98%AF-BeanDefinition"><span class="nav-text">1.3.1 什么是 BeanDefinition</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-BeanDefinition-%E5%8C%85%E5%90%AB%E7%9A%84%E5%85%B3%E9%94%AE%E4%BF%A1%E6%81%AF"><span class="nav-text">1.3.2 BeanDefinition 包含的关键信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3-BeanDefinition-%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B-%E7%AE%80%E8%BF%B0"><span class="nav-text">1.3.3 BeanDefinition 的生成过程 (简述)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Bean-%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="nav-text">2. Bean 的声明与配置方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%9F%BA%E4%BA%8EXML%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-text">2.1 基于XML的配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E6%A0%B8%E5%BF%83%E6%A0%87%E7%AD%BE"><span class="nav-text">2.1.1 核心标签&lt;bean&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE"><span class="nav-text">1. 基本配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">2. 代码示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-XML%E6%94%AF%E6%8C%81%E7%9A%84DI"><span class="nav-text">2.1.2 XML支持的DI</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Setter%E6%B3%A8%E5%85%A5"><span class="nav-text">1. Setter注入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5"><span class="nav-text">2. 构造器注入</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">2.1.3 优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BC%98%E7%82%B9"><span class="nav-text">1. 优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%BC%BA%E7%82%B9"><span class="nav-text">2. 缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-text">2.2 基于注解的配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E7%BB%84%E4%BB%B6%E6%89%AB%E6%8F%8F"><span class="nav-text">2.2.1 组件扫描</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E5%90%AF%E7%94%A8%E7%BB%84%E4%BB%B6%E6%89%AB%E6%8F%8F"><span class="nav-text">2.2.2 启用组件扫描</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3-Component"><span class="nav-text">2.2.3 核心注解 @Component</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">2.2.4 优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BC%98%E7%82%B9-1"><span class="nav-text">1. 优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%BC%BA%E7%82%B9-1"><span class="nav-text">2. 缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%9F%BA%E4%BA%8EJavaConfig%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-text">2.3 基于JavaConfig的配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3"><span class="nav-text">2.3.1 核心注解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Configuration"><span class="nav-text">1. @Configuration</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Bean"><span class="nav-text">2. @Bean</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="nav-text">2.3.2 实际应用与示例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%85%8D%E7%BD%AE%E7%B1%BB%E6%9D%A5%E5%AE%9A%E4%B9%89Bean%E3%80%81"><span class="nav-text">1. 创建一个配置类来定义Bean、</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AABean"><span class="nav-text">2. 使用这个Bean</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">2.3.3 优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BC%98%E7%82%B9-2"><span class="nav-text">1. 优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%BC%BA%E7%82%B9-2"><span class="nav-text">2. 缺点</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-ComponentScan%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">3. @ComponentScan的工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-text">3.1 流程图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3"><span class="nav-text">3.2 步骤详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E8%A7%A6%E5%8F%91%E6%89%AB%E6%8F%8F"><span class="nav-text">3.2.1 触发扫描</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E7%A1%AE%E5%AE%9A%E6%89%AB%E6%8F%8F%E8%B5%B7%E7%82%B9"><span class="nav-text">3.2.2 确定扫描起点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E6%89%A7%E8%A1%8C%E7%B1%BB%E8%B7%AF%E5%BE%84%E6%89%AB%E6%8F%8F"><span class="nav-text">3.2.3 执行类路径扫描</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-%E7%AD%9B%E9%80%89%E5%80%99%E9%80%89%E7%BB%84%E4%BB%B6"><span class="nav-text">3.2.4 筛选候选组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-5-%E6%B3%A8%E5%86%8CBean%E5%AE%9A%E4%B9%89"><span class="nav-text">3.2.5 注册Bean定义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-text">4. 依赖注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Setter%E6%B3%A8%E5%85%A5"><span class="nav-text">4.1 Setter注入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%9C%BA%E6%99%AF"><span class="nav-text">4.1.1 定义与核心场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">4.1.2 工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">4.1.3 代码示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-4-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">4.1.4 优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BC%98%E7%82%B9-3"><span class="nav-text">1. 优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%BC%BA%E7%82%B9-3"><span class="nav-text">2. 缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%AD%97%E6%AE%B5%E6%B3%A8%E5%85%A5"><span class="nav-text">4.2 字段注入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E5%AE%9A%E4%B9%89"><span class="nav-text">4.2.1 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">4.2.2 工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">4.2.3 代码示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-4-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">4.2.4 优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BC%98%E7%82%B9-4"><span class="nav-text">1. 优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%BC%BA%E7%82%B9-4"><span class="nav-text">2. 缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-5-%E6%8E%A5%E5%8F%97%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-text">4.2.5 接受的场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5"><span class="nav-text">4.3 构造器注入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%9C%AC%E8%B4%A8"><span class="nav-text">4.3.1 定义与本质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">4.3.2 工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">4.3.3 代码示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-4-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">4.3.4 优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BC%98%E7%82%B9-5"><span class="nav-text">1. 优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%94%AF%E4%B8%80%E7%9A%84%E2%80%9C%E7%BC%BA%E7%82%B9%E2%80%9D%EF%BC%9A%E6%97%A0%E6%B3%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-text">2. 唯一的“缺点”：无法解决循环依赖</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-Autowired-Resource-Inject-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">4.4 @Autowired, @Resource, @Inject 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-Autowired"><span class="nav-text">4.4.1 @Autowired</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-Resource"><span class="nav-text">4.4.2 @Resource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-Inject"><span class="nav-text">4.4.3 @Inject</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-4-%E6%80%BB%E7%BB%93%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="nav-text">4.4.4 总结与核心区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-5-SpringBoot%E4%B8%AD%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%92%8C%E9%80%89%E6%8B%A9"><span class="nav-text">4.4.5 SpringBoot中的最佳实践和选择</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E8%A7%A3%E5%86%B3%E6%B3%A8%E5%85%A5%E6%AD%A7%E4%B9%89"><span class="nav-text">4.5 解决注入歧义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%A8%E5%85%A5%E6%AD%A7%E4%B9%89%EF%BC%9F"><span class="nav-text">4.5.1 什么是注入歧义？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-2-Primary-%E6%8C%87%E5%AE%9A%E2%80%9C%E9%A6%96%E9%80%89%E2%80%9DBean"><span class="nav-text">4.5.2 @Primary - 指定“首选”Bean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-3-Qualifier-%E6%8C%87%E5%AE%9A%E2%80%9C%E9%99%90%E5%AE%9A%E2%80%9DBean"><span class="nav-text">4.5.3 @Qualifier - 指定“限定”Bean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-4-%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">4.5.4 总结与最佳实践</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">5. Bean的生命周期与作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">5.1 Bean的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-text">5.1.1 流程图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3"><span class="nav-text">5.1.2 步骤详解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E9%9B%B6%EF%BC%9A%E5%85%83%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%90%88%E5%B9%B6"><span class="nav-text">阶段零：元数据加载与合并</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-text">阶段一：实例化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9A%E5%B1%9E%E6%80%A7%E5%A1%AB%E5%85%85-Population"><span class="nav-text">阶段二：属性填充 (Population)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96-Initialization"><span class="nav-text">阶段三：初始化 (Initialization)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E5%9B%9B%EF%BC%9A%E6%B3%A8%E5%86%8C%E5%AE%8C%E6%88%90-Registration"><span class="nav-text">阶段四：注册完成 (Registration)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%94%EF%BC%9A%E9%94%80%E6%AF%81-Destruction"><span class="nav-text">阶段五：销毁 (Destruction)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">5.1.3 代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">5.2 Bean的作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="nav-text">5.2.1 什么是作用域？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">5.2.2 如何使用作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE-Annotation-based-%E2%80%94%E2%80%94-%E6%9C%80%E5%B8%B8%E7%94%A8"><span class="nav-text">1. 基于注解配置 (Annotation-based) —— 最常用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%9F%BA%E4%BA%8E-Java-Config-%E9%85%8D%E7%BD%AE-Bean"><span class="nav-text">2. 基于 Java Config 配置 (@Bean)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3-%E6%A0%87%E5%87%86%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">5.2.3 标准作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-singleton-%E5%8D%95%E4%BE%8B-%E9%BB%98%E8%AE%A4%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">1.  singleton (单例) - 默认作用域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-prototype-%E5%8E%9F%E5%9E%8B-%E5%A4%9A%E4%BE%8B"><span class="nav-text">2. prototype (原型&#x2F;多例)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-4-Web%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E9%A2%9D%E5%A4%96%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">5.2.4 Web应用中的额外作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-request"><span class="nav-text">1. request</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-session"><span class="nav-text">2. session</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-application"><span class="nav-text">3. application</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-websocket"><span class="nav-text">4. websocket</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-5-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E4%B8%8E%E4%BB%A3%E7%90%86"><span class="nav-text">5.2.5 作用域依赖问题与代理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-text">5.3 循环依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-text">5.3.1 什么是循环依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9A%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98-Three-Level-Cache"><span class="nav-text">5.3.2 核心机制：三级缓存 (Three-Level Cache)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0-1"><span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-text">2. 流程图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3"><span class="nav-text">3. 步骤详解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%80%8C%E4%B8%8D%E6%98%AF%E4%BA%8C%E7%BA%A7%EF%BC%9F"><span class="nav-text">5.3.3 为什么需要三级缓存而不是二级？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-4-Spring%E6%97%A0%E6%B3%95%E8%A7%A3%E5%86%B3%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-text">5.3.4 Spring无法解决的循环依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-5-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">5.3.5 最佳实践</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B"><span class="nav-text">四、面向切面编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-AOP%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">1. AOP核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81AOP%EF%BC%9F"><span class="nav-text">1.1 为什么需要AOP？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-AOP%E6%A0%B8%E5%BF%83%E6%9C%AF%E8%AF%AD"><span class="nav-text">1.2 AOP核心术语</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-Aspect-%E5%88%87%E9%9D%A2"><span class="nav-text">1.2.1 Aspect (切面)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-Join-Point-%E8%BF%9E%E6%8E%A5%E7%82%B9"><span class="nav-text">1.2.2 Join Point (连接点)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-Pointcut-%E5%88%87%E7%82%B9"><span class="nav-text">1.2.3 Pointcut (切点)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4-Advice-%E9%80%9A%E7%9F%A5"><span class="nav-text">1.2.4 Advice (通知)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-5-Target-Object-%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1"><span class="nav-text">1.2.5 Target Object (目标对象)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-6-Proxy-%E4%BB%A3%E7%90%86"><span class="nav-text">1.2.6 Proxy (代理)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-7-Weaving-%E7%BB%87%E5%85%A5"><span class="nav-text">1.2.7 Weaving (织入)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="nav-text">1.3 关系图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Advice-%E9%80%9A%E7%9F%A5"><span class="nav-text">2. Advice(通知)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-text">2.1 准备工作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96"><span class="nav-text">2.1.1 添加依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1"><span class="nav-text">2.1.2 目标对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-%E5%88%87%E9%9D%A2%E5%92%8C%E5%88%87%E7%82%B9"><span class="nav-text">2.1.3 切面和切点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Advice%E7%9A%84%E4%BA%94%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="nav-text">2.2 Advice的五种类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-Before-%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5"><span class="nav-text">2.2.1 @Before (前置通知)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-AfterReturning-%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5-%E8%BF%94%E5%9B%9E%E9%80%9A%E7%9F%A5"><span class="nav-text">2.2.2 @AfterReturning (后置通知&#x2F;返回通知)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-AfterThrowing-%E5%BC%82%E5%B8%B8%E9%80%9A%E7%9F%A5"><span class="nav-text">2.2.3 @AfterThrowing (异常通知)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-After-%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5"><span class="nav-text">2.2.4 @After (最终通知)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-5-Around-%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5"><span class="nav-text">2.2.5 @Around (环绕通知)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-6-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%80%BB%E7%BB%93"><span class="nav-text">2.2.6 执行顺序总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E9%80%9A%E7%9F%A5%E9%A1%BA%E5%BA%8F"><span class="nav-text">2.3 通知顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E6%A0%B8%E5%BF%83%E7%90%86%E5%BF%B5"><span class="nav-text">2.3.1 核心理念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E5%85%B7%E4%BD%93%E6%83%85%E5%86%B5"><span class="nav-text">2.3.2 具体情况</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%8D%95%E4%B8%80%E5%88%87%E9%9D%A2%E5%86%85%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-text">1. 单一切面内的执行顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8C%E5%88%87%E9%9D%A2%E9%97%B4%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-text">2. 多个不同切面间的执行顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%90%8C%E4%B8%80%E5%88%87%E9%9D%A2%E5%86%85%E5%A4%9A%E4%B8%AA%E5%90%8C%E7%B1%BB%E5%9E%8B%E9%80%9A%E7%9F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-text">3. 同一切面内多个同类型通知的执行顺序</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Pointcut%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">3. Pointcut表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%A6%82%E8%BF%B0"><span class="nav-text">3.1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Pointcut-%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3"><span class="nav-text">3.2 @Pointcut 注解详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-text">3.2.1 基本语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E5%AE%83%EF%BC%9F"><span class="nav-text">3.2.2 为什么用它？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E5%8F%AF%E8%A7%81%E6%80%A7%E5%8E%9F%E5%88%99"><span class="nav-text">3.2.3 可见性原则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-execution"><span class="nav-text">3.2 execution</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%84"><span class="nav-text">3.2.1 语法解构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E6%A0%B8%E5%BF%83%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-text">3.2.2 核心通配符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E8%AF%AD%E6%B3%95%E5%88%86%E8%A7%A3%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="nav-text">3.2.3 语法分解与示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-%E5%B8%B8%E7%94%A8%E5%86%99%E6%B3%95%E9%80%9F%E6%9F%A5"><span class="nav-text">3.2.4 常用写法速查</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-within"><span class="nav-text">3.3 within</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-annotation"><span class="nav-text">3.4 @annotation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-within"><span class="nav-text">3.5 @within</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-bean"><span class="nav-text">3.6 bean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">3.7 最佳实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-%E6%80%BB%E7%BB%93"><span class="nav-text">3.8 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E8%BF%9E%E6%8E%A5%E7%82%B9"><span class="nav-text">4. 连接点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-JoinPoint"><span class="nav-text">4.1 JoinPoint</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D%E4%BF%A1%E6%81%AF-getSignature"><span class="nav-text">4.1.1 获取方法签名信息 getSignature()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0-getArgs"><span class="nav-text">4.1.2 获取方法参数 getArgs()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3-%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87%E5%92%8C%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="nav-text">4.1.3 获取目标和代理对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-4-%E5%85%B6%E4%BB%96%E9%9D%99%E6%80%81%E4%BF%A1%E6%81%AF"><span class="nav-text">4.1.4 其他静态信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-ProceedingJoinPoint-%E4%BB%85%E9%80%82%E7%94%A8%E4%BA%8E-Around%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5"><span class="nav-text">4.2 ProceedingJoinPoint (仅适用于@Around环绕通知)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-Object-proceed-%E5%92%8C-Object-proceed-Object-args"><span class="nav-text">4.2.1 Object proceed() 和 Object proceed(Object[] args)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">5. AOP实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-%E2%80%9C%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BC%AA%E8%A3%85%E8%80%85%E2%80%9D"><span class="nav-text">5.1 JDK动态代理 - “基于接口的伪装者”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-%E2%80%9C%E5%9F%BA%E4%BA%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A2%9E%E5%BC%BA%E8%80%85%E2%80%9D"><span class="nav-text">5.2 CGLIB动态代理 - “基于继承的增强者”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-Spring-Boot%E4%B8%AD%E7%9A%84%E9%80%89%E6%8B%A9%E4%B8%8E%E6%BC%94%E5%8F%98"><span class="nav-text">5.3 Spring Boot中的选择与演变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9ASpring-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E2%80%9C%E5%81%B7%E6%A2%81%E6%8D%A2%E6%9F%B1%E2%80%9D%EF%BC%9F"><span class="nav-text">5.4 核心机制：Spring 如何在启动时“偷梁换柱”？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E6%A0%B8%E5%BF%83%E5%9B%9E%E9%A1%BE%E8%A1%A8"><span class="nav-text">5.5 核心回顾表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-text">五、事务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%BD%E8%B1%A1"><span class="nav-text">1. 核心概念与抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="nav-text">1.1 什么是事务？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Spring-%E4%BA%8B%E5%8A%A1%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3"><span class="nav-text">1.2 Spring 事务三大核心接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-PlatformTransactionManager-%E5%B9%B3%E5%8F%B0%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-text">1.2.1 PlatformTransactionManager (平台事务管理器)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-TransactionDefinition-%E4%BA%8B%E5%8A%A1%E5%AE%9A%E4%B9%89%E4%BF%A1%E6%81%AF"><span class="nav-text">1.2.2 TransactionDefinition (事务定义信息)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-TransactionStatus-%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="nav-text">1.2.3 TransactionStatus (事务状态)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4-%E4%B8%89%E8%80%85%E5%8D%8F%E4%BD%9C%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="nav-text">1.2.4 三者协作关系图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-5-%E6%80%BB%E7%BB%93"><span class="nav-text">1.2.5 总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-text">2. 编程式事务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%A6%82%E8%BF%B0"><span class="nav-text">2.1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E4%BD%BF%E7%94%A8-PlatformTransactionManager-%E5%BA%95%E5%B1%82%E6%96%B9%E5%BC%8F"><span class="nav-text">2.2 使用 PlatformTransactionManager (底层方式)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E6%B5%81%E7%A8%8B%E6%AD%A5%E9%AA%A4"><span class="nav-text">2.2.1 流程步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">2.2.2 代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E4%BD%BF%E7%94%A8-TransactionTemplate-%E6%8E%A8%E8%8D%90%E6%96%B9%E5%BC%8F"><span class="nav-text">2.3 使用 TransactionTemplate (推荐方式)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6"><span class="nav-text">2.3.1 核心机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">2.3.2 代码示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-%E4%B8%A4%E7%A7%8D%E5%9B%9E%E8%B0%83%E6%96%B9%E5%BC%8F"><span class="nav-text">2.3.3 两种回调方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E6%80%BB%E7%BB%93"><span class="nav-text">2.4 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-text">3. 声明式事务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%A6%82%E8%BF%B0-1"><span class="nav-text">3.1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%90%AF%E7%94%A8%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-text">3.2 启用事务管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Transactional-%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3"><span class="nav-text">3.3 @Transactional 注解详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="nav-text">3.3.1 作用范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="nav-text">3.3.2 核心参数配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="nav-text">3.4 失效场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-%E8%87%AA%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98-Self-Invocation-%E2%80%94%E2%80%94-%E6%9C%80%E7%BB%8F%E5%85%B8%E7%9A%84%E5%A4%A7%E5%9D%91"><span class="nav-text">3.4.1 自调用问题 (Self-Invocation) —— 最经典的大坑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-%E5%BA%94%E7%94%A8%E5%9C%A8%E9%9D%9E-public-%E6%96%B9%E6%B3%95%E4%B8%8A"><span class="nav-text">3.4.2 应用在非 public 方法上</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%8C%B9%E9%85%8D-%E9%BB%98%E8%AE%A4%E5%9B%9E%E6%BB%9A%E7%AD%96%E7%95%A5"><span class="nav-text">3.4.3 异常类型不匹配 (默认回滚策略)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-4-%E5%BC%82%E5%B8%B8%E8%A2%AB-try-catch-%E6%8D%95%E8%8E%B7%E4%B8%94%E6%B2%A1%E6%9C%89%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA"><span class="nav-text">3.4.4 异常被 try-catch 捕获且没有重新抛出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-5-Bean-%E6%9C%AA%E8%A2%AB-Spring-%E7%AE%A1%E7%90%86"><span class="nav-text">3.4.5 Bean 未被 Spring 管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3"><span class="nav-text">4. 事务属性详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="nav-text">4.1 传播行为</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%EF%BC%9F"><span class="nav-text">4.1.1 什么是传播行为？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-%E6%94%AF%E6%8C%81%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1-%E6%9C%80%E5%B8%B8%E7%94%A8"><span class="nav-text">4.1.2 支持当前事务 (最常用)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-REQUIRED-%E9%BB%98%E8%AE%A4%E5%80%BC-%E2%98%85%E2%98%85%E2%98%85"><span class="nav-text">1. REQUIRED (默认值) ★★★</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-SUPPORTS"><span class="nav-text">2. SUPPORTS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-MANDATORY"><span class="nav-text">3. MANDATORY</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3-%E4%B8%8D%E6%94%AF%E6%8C%81%E5%BD%93%E5%89%8D%E4%BA%8B%E5%8A%A1-%E6%8C%82%E8%B5%B7%E4%B8%8E%E7%8B%AC%E7%AB%8B"><span class="nav-text">4.1.3 不支持当前事务 (挂起与独立)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-REQUIRES-NEW-%E2%98%85%E2%98%85%E2%98%85"><span class="nav-text">4. REQUIRES_NEW ★★★</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-NOT-SUPPORTED"><span class="nav-text">5. NOT_SUPPORTED</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-NEVER"><span class="nav-text">6. NEVER</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-4-%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1-%E7%89%B9%E6%AE%8A"><span class="nav-text">4.1.4 嵌套事务 (特殊)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-NESTED"><span class="nav-text">7. NESTED</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-5-%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E5%9B%BE%E8%A7%A3%E4%B8%8E%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="nav-text">4.1.5 传播行为图解与对比表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-text">4.2 隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9F"><span class="nav-text">4.2.1 为什么需要隔离级别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E2%80%9C%E7%BD%AA%E7%8A%B6%E2%80%9D-%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="nav-text">4.2.2 并发事务的三大“罪状” (并发问题)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%84%8F%E8%AF%BB-Dirty-Read"><span class="nav-text">1. 脏读 (Dirty Read)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-Non-repeatable-Read"><span class="nav-text">2. 不可重复读 (Non-repeatable Read)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%B9%BB%E8%AF%BB-Phantom-Read"><span class="nav-text">3. 幻读 (Phantom Read)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%A0%87%E5%87%86%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-text">4.2.3 数据库的四种标准隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-READ-UNCOMMITTED-%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4"><span class="nav-text">1. READ_UNCOMMITTED (读未提交)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-READ-COMMITTED-%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4"><span class="nav-text">2. READ_COMMITTED (读已提交)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-REPEATABLE-READ-%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="nav-text">3. REPEATABLE_READ (可重复读)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-SERIALIZABLE-%E4%B8%B2%E8%A1%8C%E5%8C%96"><span class="nav-text">4. SERIALIZABLE (串行化)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-4-Spring-%E4%B8%AD%E7%9A%84-DEFAULT-%E9%BB%98%E8%AE%A4"><span class="nav-text">4.2.4 Spring 中的 DEFAULT (默认)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-5-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%80%BB%E7%BB%93%E8%A1%A8"><span class="nav-text">4.2.5 隔离级别总结表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%9B%9E%E6%BB%9A%E8%A7%84%E5%88%99"><span class="nav-text">4.3 回滚规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E9%BB%98%E8%AE%A4%E5%9B%9E%E6%BB%9A%E7%AD%96%E7%95%A5"><span class="nav-text">4.3.1 默认回滚策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%9E%E6%BB%9A%E9%85%8D%E7%BD%AE"><span class="nav-text">4.3.2 自定义回滚配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-%E5%BC%82%E5%B8%B8%E5%90%8D%E7%A7%B0%E5%8C%B9%E9%85%8D"><span class="nav-text">4.3.3 异常名称匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-4-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%BB%BA%E8%AE%AE"><span class="nav-text">4.3.4 总结与建议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E5%8F%AA%E8%AF%BB%E4%B8%8E%E8%B6%85%E6%97%B6"><span class="nav-text">4.4 只读与超时</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7-readOnly"><span class="nav-text">4.4.1 只读属性 (readOnly)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-%E8%B6%85%E6%97%B6%E5%B1%9E%E6%80%A7-timeout"><span class="nav-text">4.4.2 超时属性 (timeout)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94"><span class="nav-text">4.4.3 总结对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93"><span class="nav-text">4.5 最佳实践总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="nav-text">5. 总结与对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E7%BC%96%E7%A8%8B%E5%BC%8F-vs-%E5%A3%B0%E6%98%8E%E5%BC%8F"><span class="nav-text">5.1 编程式 vs 声明式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-%E6%A0%B8%E5%BF%83%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="nav-text">5.1.1 核心对比表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-%E5%86%B3%E7%AD%96%E6%8C%87%E5%8D%97%EF%BC%9A%E6%88%91%E8%AF%A5%E7%94%A8%E5%93%AA%E4%B8%AA%EF%BC%9F"><span class="nav-text">5.1.2 决策指南：我该用哪个？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">5.2 最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-Service-%E5%B1%82%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8%E7%9A%84%E2%80%9C%E9%BB%84%E9%87%91%E6%B3%95%E5%88%99%E2%80%9D"><span class="nav-text">5.2.1 Service 层事务使用的“黄金法则”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-%E6%8B%92%E7%BB%9D%E2%80%9C%E9%95%BF%E4%BA%8B%E5%8A%A1%E2%80%9D-Long-Transaction"><span class="nav-text">5.2.2 拒绝“长事务” (Long Transaction)</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/29/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringFramework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Spring全家桶-SpringFramework | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring全家桶-SpringFramework
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-29 15:53:40" itemprop="dateCreated datePublished" datetime="2025-09-29T15:53:40+08:00">2025-09-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-27 17:43:48" itemprop="dateModified" datetime="2025-12-27T17:43:48+08:00">2025-12-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/" itemprop="url" rel="index"><span itemprop="name">Spring全家桶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="前言：SpringFramework"><a href="#前言：SpringFramework" class="headerlink" title="前言：SpringFramework"></a>前言：SpringFramework</h1><p><strong>Spring Framework</strong> 是 Java 企业级应用开发领域最流行、最强大的<strong>轻量级开源框架</strong>，被视为 Java 开发的“事实标准”。</p>
<p>它的<strong>核心作用</strong>在于通过 <strong>控制反转 (IoC)</strong> 和 <strong>依赖注入 (DI)</strong> 机制，将对象的创建与依赖关系管理交给容器处理，从而实现代码组件的彻底<strong>解耦</strong>，让系统更易于维护和测试；同时，它利用 <strong>面向切面编程 (AOP)</strong> 将事务管理、日志记录等通用非业务逻辑从核心业务代码中剥离，并提供了对数据库、Web 开发等各种第三方技术的“胶水”式集成和简化封装，旨在消除繁琐的样板代码，让开发者能更快速、高效地构建健壮的 Java 应用程序。</p>
<hr>
<hr>
<h1 id="一、核心容器"><a href="#一、核心容器" class="headerlink" title="一、核心容器"></a>一、核心容器</h1><h2 id="1-核心设计理念"><a href="#1-核心设计理念" class="headerlink" title="1. 核心设计理念"></a>1. 核心设计理念</h2><h3 id="1-1-控制反转-Inversion-of-Control-IoC"><a href="#1-1-控制反转-Inversion-of-Control-IoC" class="headerlink" title="1.1 控制反转(Inversion of Control,IoC)"></a>1.1 控制反转(Inversion of Control,IoC)</h3><h4 id="1-1-1-核心概念"><a href="#1-1-1-核心概念" class="headerlink" title="1.1.1 核心概念"></a>1.1.1 核心概念</h4><p>IoC 并不是 Spring 特有的，而是一种面向对象编程的<strong>设计原则</strong>（Design Principle）。</p>
<ul>
<li><p><strong>定义</strong>：IoC 是指将对象的<strong>创建</strong>、<strong>初始化</strong>、<strong>销毁</strong>以及<strong>对象间依赖关系的管理权</strong>，从程序代码移交给<strong>外部容器</strong>来接管。</p>
</li>
<li><p><strong>别名</strong>：好莱坞原则 (The Hollywood Principle) —— “Don’t call us, we’ll call you.”（别找我们要角色，有合适的我们会给你打电话）。在软件中意味着：别自己 <code>new</code> 对象，容器会把对象送到你手里。</p>
</li>
<li><p><strong>传统的程序设计</strong>：当对象 A 需要依赖对象 B 时，A 通常会在内部主动创建 B（例如 <code>B b = new B()</code>）。此时，<strong>A 既是使用者，也是创建者</strong>，A 控制了 B 的生命周期。</p>
</li>
<li><p><strong>IoC 的程序设计</strong>：对象 A 不再负责创建对象 B，而是由一个外部的“容器”来负责创建 B，并把 B 注入给 A。</p>
</li>
<li><p><strong>反转了什么？</strong></p>
<ul>
<li><strong>反转了资源的获取方式</strong>：从“主动索取”变成了“被动接受”。</li>
<li><strong>反转了控制权</strong>：对象的创建、初始化、销毁的控制权，从“应用程序代码”转移到了“外部容器&#x2F;框架”。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-2-核心价值"><a href="#1-1-2-核心价值" class="headerlink" title="1.1.2 核心价值"></a>1.1.2 核心价值</h4><ul>
<li><strong>解耦 (Decoupling)</strong>：<ul>
<li><strong>痛点</strong>：若 A 类直接 <code>new B()</code>，当 B 的实现类变成 C 时，必须修改 A 的源代码并重新编译。</li>
<li><strong>解决</strong>：A 只依赖 B 的接口，具体注入 B 还是 C 由配置决定，A 的代码无需改动。</li>
</ul>
</li>
<li><strong>简化对象管理</strong>：<ul>
<li><strong>痛点</strong>：在大型系统中，对象之间依赖关系错综复杂（如单例、多例、懒加载、销毁顺序），手动管理极易出错。</li>
<li><strong>解决</strong>：容器统一进行生命周期管理。</li>
</ul>
</li>
<li><strong>提升可测试性</strong>：<ul>
<li><strong>痛点</strong>：单元测试时，如果对象内部硬编码了依赖（如数据库连接），很难进行 Mock 测试。</li>
<li><strong>解决</strong>：通过 IoC，测试时可以轻松注入 Mock 对象。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-IoC的两种主要实现方式"><a href="#1-2-IoC的两种主要实现方式" class="headerlink" title="1.2 IoC的两种主要实现方式"></a>1.2 IoC的两种主要实现方式</h3><blockquote>
<p><strong>注意</strong>：IoC 是<strong>思想</strong>，DI 和 DL 是实现这个思想的<strong>具体手段</strong>。Spring 框架同时支持这两种方式，但主推 DI。</p>
</blockquote>
<h4 id="1-2-1-依赖查找-Dependency-Lookup-DL"><a href="#1-2-1-依赖查找-Dependency-Lookup-DL" class="headerlink" title="1.2.1 依赖查找(Dependency Lookup,DL)"></a>1.2.1 依赖查找(Dependency Lookup,DL)</h4><p><strong>定义：</strong></p>
<p>容器创建好对象后，应用程序代码<strong>主动调用</strong>容器提供的 API 接口，通过名称或类型去查找需要的资源。</p>
<p><strong>典型场景：</strong></p>
<ul>
<li><p><strong>JNDI (Java Naming and Directory Interface)</strong>：在旧时代的 EJB 或 JDBC 数据源查找中常见。</p>
</li>
<li><p><strong>Spring 的 <code>BeanFactory.getBean(&quot;name&quot;)</code></strong>：当你手动调用 <code>getBean</code> 方法时，就是在进行依赖查找。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码示例：代码强烈依赖了 Spring 的 ApplicationContext 接口</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="type">UserDao</span> <span class="variable">dao</span> <span class="operator">=</span> (UserDao) context.getBean(<span class="string">&quot;userDao&quot;</span>); <span class="comment">// 主动索取</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>两种查找模式：</strong></p>
<ul>
<li><strong>依赖拖拽 (Dependency Pull)</strong>：从容器中把需要的 Bean 拉出来（最常见，如 <code>ctx.getBean(...)</code>）。</li>
<li><strong>上下文依赖查找 (Contextualized DL)</strong>：在特定上下文中查找（如查找当前线程绑定的资源）。</li>
</ul>
<p><strong>优缺点：</strong></p>
<ul>
<li><strong>优点</strong>：在某些底层架构或无法使用注入的场景下（如静态工具类中需要获取 Bean），是唯一的解决方案。</li>
<li><strong>缺点</strong>：<ul>
<li><strong>强侵入性 (Intrusive)</strong>：业务代码必须依赖 Spring 的 API（如需要引入 <code>ApplicationContext</code> 接口）。</li>
<li><strong>代码耦合</strong>：业务逻辑与容器机制绑定，难以脱离 Spring 框架独立运行或测试。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-2-依赖注入-Dependency-Injection-DI"><a href="#1-2-2-依赖注入-Dependency-Injection-DI" class="headerlink" title="1.2.2 依赖注入(Dependency Injection,DI)"></a>1.2.2 依赖注入(Dependency Injection,DI)</h4><p><strong>定义</strong></p>
<p>组件不做任何主动查找，容器在运行期间，<strong>自动</strong>将依赖的对象“塞”到组件中。</p>
<p><strong>典型表现</strong>：</p>
<ul>
<li><strong>构造器注入</strong>：<code>public User(Service s) { this.s = s; }</code></li>
<li><strong>Setter 注入</strong>：<code>public void setService(Service s) { ... }</code></li>
<li><strong>注解注入</strong>：<code>@Autowired</code>, <code>@Resource</code></li>
</ul>
<p><strong>为什么 DI 是 Spring 的主流？</strong></p>
<p>Martin Fowler 在 2004 年的文章中提出，IoC 的具体实现应当主要由 DI 来完成。</p>
<ul>
<li><strong>零侵入性</strong>：代码中可以是纯粹的 POJO（Plain Old Java Object），不需要 <code>import org.springframework...</code>。</li>
<li><strong>符合单一职责原则</strong>：对象只负责业务逻辑，配置和组装交给专门的配置类。</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>非侵入式</strong>：业务代码中几乎不需要出现 Spring 的 API 类（是一个纯净的 POJO），代码整洁。</li>
<li><strong>易于测试</strong>：可以直接 <code>new</code> 对象并通过构造器传入 Mock 对象，无需启动容器。</li>
</ul>
</li>
<li><strong>缺点</strong>：在极端复杂的依赖链中，静态排查流程相对困难（因为对象是运行时动态组装的）。</li>
</ul>
<hr>
<h4 id="1-2-3-DI-与-DL-的对比总结"><a href="#1-2-3-DI-与-DL-的对比总结" class="headerlink" title="1.2.3 DI 与 DL 的对比总结"></a>1.2.3 DI 与 DL 的对比总结</h4><table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">依赖查找 (DL)</th>
<th align="left">依赖注入 (DI)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>主动性</strong></td>
<td align="left"><strong>主动</strong>：Bean 主动调用 <code>getBean()</code></td>
<td align="left"><strong>被动</strong>：Bean 被动等待容器赋值</td>
</tr>
<tr>
<td align="left"><strong>侵入性</strong></td>
<td align="left"><strong>高</strong>：业务代码依赖 Spring 核心接口</td>
<td align="left"><strong>低</strong>：业务代码通常仅依赖 Java 语言特性或标准注解</td>
</tr>
<tr>
<td align="left"><strong>代码依赖</strong></td>
<td align="left">依赖容器 API</td>
<td align="left">依赖具体对象或接口</td>
</tr>
<tr>
<td align="left"><strong>可读性</strong></td>
<td align="left">流程明确，但代码冗余</td>
<td align="left">简洁，但依赖关系隐藏在元数据&#x2F;注解中</td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td align="left">框架底层、遗留系统集成、工具类</td>
<td align="left"><strong>绝大多数业务开发场景 (99%)</strong></td>
</tr>
</tbody></table>
<hr>
<hr>
<h1 id="二、容器架构与启动"><a href="#二、容器架构与启动" class="headerlink" title="二、容器架构与启动"></a>二、容器架构与启动</h1><h2 id="1-Spring-IoC-容器概述"><a href="#1-Spring-IoC-容器概述" class="headerlink" title="1. Spring IoC 容器概述"></a>1. Spring IoC 容器概述</h2><h3 id="1-1-从理论到落地：IoC-思想的“实体化”"><a href="#1-1-从理论到落地：IoC-思想的“实体化”" class="headerlink" title="1.1 从理论到落地：IoC 思想的“实体化”"></a>1.1 从理论到落地：IoC 思想的“实体化”</h3><p>如果说第一章讲的 <strong>IoC (控制反转)</strong> 是一张建筑图纸，<strong>DI (依赖注入)</strong> 是具体的施工工艺，那么 <strong>Spring IoC 容器</strong> 就是那个负责统筹一切的 <strong>“施工队”或“超级工厂”</strong>。</p>
<ul>
<li><strong>定位</strong>：Spring IoC 容器是 Spring Framework 的核心引擎，是一个具体的<strong>软件程序</strong>。</li>
<li><strong>本质</strong>：它是一个管理 Java 对象（Bean）生命周期的环境。它将 IoC 的理论变成了代码层面的现实。</li>
</ul>
<hr>
<h3 id="1-2-核心职责"><a href="#1-2-核心职责" class="headerlink" title="1.2 核心职责"></a>1.2 核心职责</h3><p>Spring IoC 容器并非只是简单的“Map&lt;String, Object&gt;”，它承担了对象从出生到死亡的全过程管理。主要职责可以归纳为以下四点：</p>
<ul>
<li><strong>对象的实例化 (Instantiation)</strong><ul>
<li>容器读取配置元数据，利用反射（Reflection）机制，替开发者 <code>new</code> 出对象。</li>
</ul>
</li>
<li><strong>对象的装配&#x2F;注入 (Wiring&#x2F;DI)</strong><ul>
<li>这是容器最核心的工作。它负责解析对象之间的依赖关系（A 依赖 B），并将 B 准确地赋值给 A。</li>
<li>这就是“将分散的组件组装成协同工作的系统”的过程。</li>
</ul>
</li>
<li><strong>生命周期管理 (Lifecycle Management)</strong><ul>
<li>容器就像保姆，负责调用对象的初始化回调（如 <code>@PostConstruct</code>）和销毁回调（如 <code>@PreDestroy</code>）。</li>
<li>它确保对象在被使用前是“就绪状态”，在容器关闭前能“优雅退场”。</li>
</ul>
</li>
<li><strong>对象配置 (Configuration)</strong><ul>
<li>容器不仅管理依赖，还管理对象的属性值（如数据库连接 URL、超时时间等配置参数）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-容器的工作流"><a href="#1-3-容器的工作流" class="headerlink" title="1.3 容器的工作流"></a>1.3 容器的工作流</h3><p>Spring 容器的运行可以抽象为“输入 -&gt; 处理 -&gt; 输出”的三个阶段：</p>
<ul>
<li><strong>输入 (Inputs)</strong>：<ol>
<li><strong>POJOs (Plain Old Java Objects)</strong>：业务类（UserSerivce, OrderDao…）。</li>
<li><strong>配置元数据 (Configuration Metadata)</strong>：告诉容器如何创建和组装对象的指令（可以是 XML、注解或 Java 配置类）。</li>
</ol>
</li>
<li><strong>处理 (The Container)</strong>：<ul>
<li>容器读取元数据，生成 <code>BeanDefinition</code>（蓝图），然后根据蓝图进行实例化和依赖注入。</li>
</ul>
</li>
<li><strong>输出 (Output)</strong>：<ul>
<li>一个完全配置好的、可直接运行的系统（Fully configured system）。此时，应用程序可以直接从容器中获取对象并使用。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-核心接口体系"><a href="#2-核心接口体系" class="headerlink" title="2. 核心接口体系"></a>2. 核心接口体系</h2><h3 id="2-1-概览"><a href="#2-1-概览" class="headerlink" title="2.1 概览"></a>2.1 概览</h3><p>Spring IoC 容器并非只有一个具体的实现，而是通过一系列接口来定义的。分为两条主线：</p>
<ol>
<li><strong>低级容器（The Engine）</strong>：以 <code>BeanFactory</code> 为核心，关注 Bean 的创建、装配。</li>
<li><strong>高级容器（The Application）</strong>：以 <code>ApplicationContext</code> 为核心，关注企业级功能（国际化、事件、资源）。</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory (顶层接口)</span><br><span class="line">  ├── HierarchicalBeanFactory (父子容器能力)</span><br><span class="line">  │    └── ConfigurableBeanFactory (配置能力: Scope, Parent)</span><br><span class="line">  ├── ListableBeanFactory (迭代/枚举能力)</span><br><span class="line">  └── AutowireCapableBeanFactory (自动装配能力)</span><br><span class="line"></span><br><span class="line">ApplicationContext (高级门面接口)</span><br><span class="line">  ├── (继承) ListableBeanFactory, HierarchicalBeanFactory, ...</span><br><span class="line">  ├── (继承) MessageSource, ApplicationEventPublisher, ResourcePatternResolver</span><br><span class="line">  └── ConfigurableApplicationContext (生命周期管理: refresh, close)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-低级容器接口"><a href="#2-2-低级容器接口" class="headerlink" title="2.2 低级容器接口"></a>2.2 低级容器接口</h3><h4 id="2-2-1-BeanFactory（顶层根接口）"><a href="#2-2-1-BeanFactory（顶层根接口）" class="headerlink" title="2.2.1 BeanFactory（顶层根接口）"></a>2.2.1 <code>BeanFactory</code>（顶层根接口）</h4><ul>
<li><strong>定位</strong>：容器的<strong>最低标准</strong>。它是 Spring 的“心脏”，负责最基础的 Bean 检索。</li>
<li><strong>核心方法</strong>：<ul>
<li><code>getBean(String name)</code> &#x2F; <code>getBean(Class&lt;T&gt; type)</code>：获取实例（可能是单例，也可能是多例）。</li>
<li><code>containsBean(String name)</code>：检查是否存在。</li>
<li><code>isSingleton(String name)</code> &#x2F; <code>isPrototype(String name)</code>：查询 Scope。</li>
</ul>
</li>
<li><strong>设计哲学</strong>：<strong>懒加载（Lazy Loading）</strong>。通常情况下，只有当你调用 <code>getBean</code> 时，<code>BeanFactory</code> 才会去实例化 Bean。</li>
<li><strong>底层实现</strong>：它只是定义了行为，不负责存储 <code>BeanDefinition</code>。</li>
</ul>
<hr>
<h4 id="2-2-2-ListableBeanFactory（可列举能力的扩展）"><a href="#2-2-2-ListableBeanFactory（可列举能力的扩展）" class="headerlink" title="2.2.2 ListableBeanFactory（可列举能力的扩展）"></a>2.2.2 <code>ListableBeanFactory</code>（可列举能力的扩展）</h4><ul>
<li><p><strong>定位</strong>：允许容器<strong>枚举</strong>所有的 Bean。</p>
</li>
<li><p><strong>为什么需要它？</strong>：普通的 <code>BeanFactory</code> 只能通过名字一个个取。如果你想知道“容器里所有实现了 <code>PaymentService</code> 接口的 Bean 有哪些？”，基础 <code>BeanFactory</code> 做不到，必须用这个。</p>
</li>
<li><p><strong>核心方法</strong>：</p>
<ul>
<li><code>getBeanDefinitionNames()</code>：获取所有定义的名字。</li>
<li><code>getBeansOfType(Class&lt;T&gt; type)</code>：获取某种类型的所有 Bean 实例（Map形式返回）。</li>
</ul>
</li>
<li><p><strong>代码示例</strong>：**策略模式（Strategy Pattern）**的自动注入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spring 会利用 ListableBeanFactory 的能力，注入所有实现类</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, PaymentStrategy&gt; strategies; </span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-3-HierarchicalBeanFactory（分层能力的扩展）"><a href="#2-2-3-HierarchicalBeanFactory（分层能力的扩展）" class="headerlink" title="2.2.3 HierarchicalBeanFactory（分层能力的扩展）"></a>2.2.3 <code>HierarchicalBeanFactory</code>（分层能力的扩展）</h4><ul>
<li><strong>定位</strong>：支持<strong>父子容器</strong>架构。</li>
<li><strong>核心方法</strong>：<ul>
<li><code>getParentBeanFactory()</code>：获取父容器。</li>
<li><code>containsLocalBean(String name)</code>：只查当前容器，不查父容器。</li>
</ul>
</li>
<li><strong>底层规则</strong>：<strong>可见性机制</strong>——子容器可以看见父容器的 Bean，但父容器看不见子容器的 Bean。（经典应用：Spring MVC 的 Root Context vs Servlet Context）。</li>
</ul>
<hr>
<h4 id="2-2-4-AutowireCapableBeanFactory（外部集成能力的扩展）"><a href="#2-2-4-AutowireCapableBeanFactory（外部集成能力的扩展）" class="headerlink" title="2.2.4 AutowireCapableBeanFactory（外部集成能力的扩展）"></a>2.2.4 <code>AutowireCapableBeanFactory</code>（外部集成能力的扩展）</h4><ul>
<li><strong>定位</strong>：<strong>非常底层</strong>的接口，一般应用代码很少直接用，但框架集成极其重要。</li>
<li><strong>功能</strong>：它允许容器对<strong>非 Spring 管理的现有对象</strong>进行依赖注入。</li>
<li><strong>核心场景</strong>：<ul>
<li><strong>Filter &#x2F; Servlet</strong>：这些对象是由 Servlet 容器（如 Tomcat）创建的，不是 Spring 创建的。但我们希望在 Filter 里 <code>@Autowired</code> 一个 Service。</li>
<li><strong>第三方框架集成</strong>：比如 Struts2 的 Action 或者 Quartz 的 Job 实例。</li>
</ul>
</li>
<li><strong>核心方法</strong>：<ul>
<li><code>autowireBean(Object existingBean)</code>：把一个你自己 <code>new</code> 出来的对象扔进去，Spring 帮你把里面的 <code>@Autowired</code> 属性填好。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-BeanDefinitionRegistry"><a href="#2-3-BeanDefinitionRegistry" class="headerlink" title="2.3 BeanDefinitionRegistry"></a>2.3 <code>BeanDefinitionRegistry</code></h3><ul>
<li><strong>定位</strong>：<code>BeanFactory</code> 负责<strong>取</strong>（Get），<code>BeanDefinitionRegistry</code> 负责<strong>存</strong>（Register）。它是 <code>BeanDefinition</code> 的物理存储库。</li>
<li><strong>核心方法</strong>：<ul>
<li><code>registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</code></li>
<li><code>removeBeanDefinition(String beanName)</code></li>
<li><code>getBeanDefinition(String beanName)</code></li>
</ul>
</li>
<li><strong>底层关联</strong>：<code>DefaultListableBeanFactory</code> 既实现了 <code>BeanFactory</code> 接口，也实现了 <code>BeanDefinitionRegistry</code> 接口。所有的 <code>@Configuration</code> 解析、XML 解析，最终都是调用这个接口把<code>BeanDefinition</code>存进去。</li>
</ul>
<hr>
<h3 id="2-4-高级容器接口"><a href="#2-4-高级容器接口" class="headerlink" title="2.4 高级容器接口"></a>2.4 高级容器接口</h3><h4 id="2-4-1-ApplicationContext（核心门面）"><a href="#2-4-1-ApplicationContext（核心门面）" class="headerlink" title="2.4.1 ApplicationContext（核心门面）"></a>2.4.1 <code>ApplicationContext</code>（核心门面）</h4><ul>
<li><strong>定位</strong>：它是一个<strong>聚合接口</strong>（Interface Aggregation）。它不干活，它只是把各种能力组合起来提供给用户。</li>
<li><strong>组合能力</strong>：<ul>
<li><code>BeanFactory</code> 的所有能力（继承了 <code>Listable</code>, <code>Hierarchical</code> 等）。</li>
<li><code>MessageSource</code>：支持国际化（i18n）。</li>
<li><code>ApplicationEventPublisher</code>：支持事件发布&#x2F;监听机制。</li>
<li><code>ResourcePatternResolver</code>：支持解析 <code>classpath*:/*.xml</code> 等资源路径。</li>
<li><code>EnvironmentCapable</code>：支持读取 Environment（Profile + Properties）。</li>
</ul>
</li>
<li><strong>与 BeanFactory 的核心区别</strong>：<ul>
<li><strong>预加载（Pre-loading）</strong>：默认情况下，<code>ApplicationContext</code> 在启动时就会实例化所有 <strong>Singleton</strong> Bean（空间换时间，尽早发现配置错误）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-4-2-ConfigurableApplicationContext（生命周期控制）"><a href="#2-4-2-ConfigurableApplicationContext（生命周期控制）" class="headerlink" title="2.4.2 ConfigurableApplicationContext（生命周期控制）"></a>2.4.2 <code>ConfigurableApplicationContext</code>（生命周期控制）</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><ul>
<li><strong>定位</strong>：赋予使用者<strong>配置</strong>和<strong>控制生命周期</strong>的权力。<code>ApplicationContext</code> 主要是“读”接口，这个是“写&#x2F;控”接口。</li>
<li><strong>核心方法</strong>：<ul>
<li><strong><code>refresh()</code></strong>：<strong>灵魂方法</strong>。加载配置、解析 Bean、启动容器。</li>
<li><code>close()</code>：关闭容器，销毁 Bean。</li>
<li><code>registerShutdownHook()</code>：注册 JVM 关闭钩子。</li>
<li><code>addBeanFactoryPostProcessor(...)</code>：手动添加扩展点。</li>
</ul>
</li>
<li><strong>谁在用</strong>：<code>SpringApplication.run()</code> 或者 <code>main</code> 方法中通常持有的就是这个类型的引用。</li>
</ul>
<hr>
<h3 id="2-5-标准骨架类：AbstractApplicationContext"><a href="#2-5-标准骨架类：AbstractApplicationContext" class="headerlink" title="2.5 标准骨架类：AbstractApplicationContext"></a>2.5 标准骨架类：<code>AbstractApplicationContext</code></h3><h4 id="2-5-1-定位"><a href="#2-5-1-定位" class="headerlink" title="2.5.1 定位"></a>2.5.1 定位</h4><ul>
<li><strong>角色</strong>：它是 Spring 容器的<strong>基石</strong>，几乎所有具体的 <code>ApplicationContext</code> 实现类（无论是 XML、注解还是 Spring Boot）都继承自它。</li>
<li><strong>模式</strong>：**模板方法模式（Template Method Pattern）**的教科书级应用。它定义了容器启动的标准流程（骨架），而将具体的细节（如 Bean 是从 XML 读还是从注解读、Web 服务器怎么起）留给子类去实现。</li>
<li><strong>承上启下</strong>：它实现了 <code>ConfigurableApplicationContext</code> 接口的 <code>refresh()</code> 方法，并内部持有了 <code>DefaultListableBeanFactory</code> 来干活。</li>
</ul>
<hr>
<h4 id="2-5-2-核心流程：refresh-的-12-个步骤"><a href="#2-5-2-核心流程：refresh-的-12-个步骤" class="headerlink" title="2.5.2 核心流程：refresh() 的 12 个步骤"></a>2.5.2 核心流程：<code>refresh()</code> 的 12 个步骤</h4><p>这是 Spring 启动的“心脏”，几十年未变的标准化生产线：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// 1. 准备工作：记录时间、设置状态、校验必填的环境变量</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取内部的 BeanFactory：如果是 XML 模式，这里会解析 XML；如果是注解模式，这里仅返回工厂</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 准备工厂：配置类加载器、忽略 Aware 接口依赖、注册一些系统级 Bean</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4. (扩展点) 这里的空方法留给子类实现（如 Web 环境注册 ServletContextAware）</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 【关键】调用 BeanFactoryPostProcessor：</span></span><br><span class="line">            <span class="comment">// 解析 @Configuration、扫描 @Component、扫描 Mybatis Mapper 的核心步骤</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. 【关键】注册 BeanPostProcessor：</span></span><br><span class="line">            <span class="comment">// 只是把拦截器（如 AOP 代理生成器）找出来注册到工厂，此时还没开始干活</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7. 初始化国际化组件</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8. 初始化事件广播器</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 9. (扩展点) onRefresh：</span></span><br><span class="line">            <span class="comment">// Spring Boot 利用这个方法在这里启动内嵌的 Tomcat/Jetty</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 10. 注册事件监听器</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 11. 【核心】初始化所有剩余的非懒加载单例 Bean：</span></span><br><span class="line">            <span class="comment">// 99% 的 Bean（Controller/Service）在这里被实例化、注入、初始化</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 12. 完成刷新：清理缓存、发布 ContextRefreshedEvent 事件</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... catch / finally</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-5-3-详细流程拆解"><a href="#2-5-3-详细流程拆解" class="headerlink" title="2.5.3 详细流程拆解"></a>2.5.3 详细流程拆解</h4><h5 id="1-prepareRefresh-进场准备"><a href="#1-prepareRefresh-进场准备" class="headerlink" title="1. prepareRefresh() - 进场准备"></a>1. <code>prepareRefresh()</code> - 进场准备</h5><ul>
<li><strong>动作：</strong> 记录启动时间，设置容器状态为 <code>active</code>，初始化属性源（PropertySources）。</li>
<li><strong>细节：</strong> 比如检查环境变量中必须要有的参数是否存在。</li>
</ul>
<hr>
<h5 id="2-obtainFreshBeanFactory-搞定仓库"><a href="#2-obtainFreshBeanFactory-搞定仓库" class="headerlink" title="2. obtainFreshBeanFactory() - 搞定仓库"></a>2. <code>obtainFreshBeanFactory()</code> - 搞定仓库</h5><ul>
<li><strong>动作：</strong><ul>
<li>对于 XML 模式：读取 XML，解析成 <code>BeanDefinition</code>，放入 Map。</li>
<li>对于注解&#x2F;Boot 模式：仅仅是刷新并返回那个在构造函数里早就创建好的 <code>DefaultListableBeanFactory</code>。</li>
</ul>
</li>
<li><strong>产出：</strong> 一个具备了基础配置，但还没开始实例化 Bean 的 BeanFactory。</li>
</ul>
<hr>
<h5 id="3-prepareBeanFactory-beanFactory-基础设施配置"><a href="#3-prepareBeanFactory-beanFactory-基础设施配置" class="headerlink" title="3. prepareBeanFactory(beanFactory) - 基础设施配置"></a>3. <code>prepareBeanFactory(beanFactory)</code> - 基础设施配置</h5><ul>
<li><strong>动作：</strong> 给 BeanFactory 设置类加载器、表达式解析器。</li>
<li><strong>关键：</strong> 添加 ApplicationContextAwareProcessor（让 Bean 能感知到容器）。</li>
<li><strong>设置依赖忽略：</strong> 告诉 Factory，如果 Bean 想要注入 <code>ResourceLoader</code>、<code>ApplicationEventPublisher</code> 等接口，不要去自动装配（因为容器会通过 Aware 接口塞给它）。</li>
</ul>
<hr>
<h5 id="4-postProcessBeanFactory-beanFactory-子类扩展点"><a href="#4-postProcessBeanFactory-beanFactory-子类扩展点" class="headerlink" title="4. postProcessBeanFactory(beanFactory) - 子类扩展点"></a>4. <code>postProcessBeanFactory(beanFactory)</code> - 子类扩展点</h5><ul>
<li><strong>动作：</strong> 留给子类去实现的空方法。</li>
<li><strong>Web 环境：</strong> 会在这里注册 <code>ServletContextAwareProcessor</code>，并且注册 request&#x2F;session 作用域。</li>
</ul>
<hr>
<h5 id="5-invokeBeanFactoryPostProcessors-beanFactory-【重要】解析配置与扫描"><a href="#5-invokeBeanFactoryPostProcessors-beanFactory-【重要】解析配置与扫描" class="headerlink" title="5. invokeBeanFactoryPostProcessors(beanFactory) - 【重要】解析配置与扫描"></a>5. <code>invokeBeanFactoryPostProcessors(beanFactory)</code> - 【重要】解析配置与扫描</h5><ul>
<li><strong>比喻：</strong> 此时还没盖房子，是在<strong>审核和修改设计图纸</strong>。</li>
<li><strong>核心动作：</strong><ul>
<li>执行 <code>ConfigurationClassPostProcessor</code>。</li>
<li><strong>扫描（Scanning）：</strong> 扫描包路径，识别 <code>@Component</code>, <code>@Service</code>, <code>@Controller</code>。</li>
<li><strong>解析（Parsing）：</strong> 解析 <code>@Configuration</code>, <code>@Bean</code>, <code>@Import</code>。</li>
</ul>
</li>
<li><strong>结果：</strong> 所有的 Bean 信息都被转换成了 <code>BeanDefinition</code> 存入了 Map 中。此时容器知道了所有的类，但还没实例化它们。</li>
</ul>
<hr>
<h5 id="6-registerBeanPostProcessors-beanFactory-【重要】招聘质检员"><a href="#6-registerBeanPostProcessors-beanFactory-【重要】招聘质检员" class="headerlink" title="6. registerBeanPostProcessors(beanFactory) - 【重要】招聘质检员"></a>6. <code>registerBeanPostProcessors(beanFactory)</code> - 【重要】招聘质检员</h5><ul>
<li><strong>比喻：</strong> 招聘在生产线上干预产品创建的工人，但先不上岗，只是签合同（注册）。</li>
<li><strong>动作：</strong> 找出实现了 <code>BeanPostProcessor</code> 接口的 Bean（如处理 <code>@Autowired</code> 的 <code>AutowiredAnnotationBeanPostProcessor</code>，处理 AOP 的 <code>AnnotationAwareAspectJAutoProxyCreator</code>）。</li>
<li><strong>细节：</strong> 将它们实例化，并添加到 BeanFactory 的处理器列表中，供第 11 步使用。</li>
</ul>
<hr>
<h5 id="7-initMessageSource-国际化"><a href="#7-initMessageSource-国际化" class="headerlink" title="7. initMessageSource() - 国际化"></a>7. <code>initMessageSource()</code> - 国际化</h5><ul>
<li><strong>动作：</strong> 看容器里有没有名字叫 <code>messageSource</code> 的 Bean，用于支持 i18n。</li>
</ul>
<hr>
<h5 id="8-initApplicationEventMulticaster-事件广播器"><a href="#8-initApplicationEventMulticaster-事件广播器" class="headerlink" title="8. initApplicationEventMulticaster() - 事件广播器"></a>8. <code>initApplicationEventMulticaster()</code> - 事件广播器</h5><ul>
<li><strong>动作：</strong> 初始化 ApplicationEventMulticaster，用来发布事件。</li>
</ul>
<hr>
<h5 id="9-onRefresh-子类扩展点"><a href="#9-onRefresh-子类扩展点" class="headerlink" title="9. onRefresh() - 子类扩展点"></a>9. <code>onRefresh()</code> - 子类扩展点</h5><ul>
<li><strong>Spring Boot 核心：</strong> 默认是空方法，但 Spring Boot 的 Web 容器（<code>ServletWebServerApplicationContext</code>）在这里<strong>创建并启动嵌入式 Tomcat&#x2F;Jetty</strong>。</li>
</ul>
<hr>
<h5 id="10-registerListeners-注册监听器"><a href="#10-registerListeners-注册监听器" class="headerlink" title="10. registerListeners() - 注册监听器"></a>10. <code>registerListeners()</code> - 注册监听器</h5><ul>
<li><strong>动作：</strong> 将实现了 <code>ApplicationListener</code> 的 Bean 注册到广播器中。</li>
<li><strong>细节：</strong> 如果有早期事件，在这里广播。</li>
</ul>
<hr>
<h5 id="11-finishBeanFactoryInitialization-beanFactory-【最核心】实例化单例"><a href="#11-finishBeanFactoryInitialization-beanFactory-【最核心】实例化单例" class="headerlink" title="11. finishBeanFactoryInitialization(beanFactory) - 【最核心】实例化单例"></a>11. <code>finishBeanFactoryInitialization(beanFactory)</code> - 【最核心】实例化单例</h5><ul>
<li><strong>比喻：</strong> 按照图纸，正式开始<strong>批量造房子</strong>。</li>
<li><strong>动作：</strong> 遍历 BeanDefinition Map，调用 <code>getBean()</code>。</li>
<li><strong>流程：</strong> 实例化 -&gt; 属性填充（DI） -&gt; 初始化（Aware, PostProcessBefore, init-method, PostProcessAfter&#x2F;AOP）。</li>
<li><strong>范围：</strong> 处理所有 <strong>Singleton</strong> 且 <strong>非 Lazy</strong> 的 Bean。我们写的 99% 的 Bean 都在这里被创建。</li>
</ul>
<hr>
<h5 id="12-finishRefresh-完工"><a href="#12-finishRefresh-完工" class="headerlink" title="12. finishRefresh() - 完工"></a>12. <code>finishRefresh()</code> - 完工</h5><ul>
<li><strong>动作：</strong> 清理缓存，初始化 LifecycleProcessor，发布 <strong><code>ContextRefreshedEvent</code></strong> 事件（很多应用会在监听到这个事件后开始执行业务逻辑）。</li>
</ul>
<hr>
<h3 id="2-6-终极实现类：DefaultListableBeanFactory"><a href="#2-6-终极实现类：DefaultListableBeanFactory" class="headerlink" title="2.6 终极实现类：DefaultListableBeanFactory"></a>2.6 终极实现类：<code>DefaultListableBeanFactory</code></h3><ul>
<li><strong>地位</strong>：它是 Spring 容器的<strong>默认底层实现</strong>。</li>
<li><strong>关系</strong>：<ul>
<li><code>ApplicationContext</code> 内部通常<strong>持有一个</strong> <code>DefaultListableBeanFactory</code> 实例。</li>
<li>当我们在 <code>ApplicationContext</code> 上调用 <code>getBean()</code> 时，它实际上是**委托（Delegate）**给了内部的 <code>DefaultListableBeanFactory</code> 去干活。</li>
</ul>
</li>
<li><strong>集大成者</strong>：它实现了 <code>BeanDefinitionRegistry</code>、<code>ConfigurableListableBeanFactory</code>、<code>AutowireCapableBeanFactory</code> 等几乎所有底层接口。</li>
</ul>
<hr>
<h3 id="2-7-总结"><a href="#2-7-总结" class="headerlink" title="2.7 总结"></a>2.7 总结</h3><table>
<thead>
<tr>
<th align="left">接口</th>
<th align="left">关键职责</th>
<th align="left">实战&#x2F;源码场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>BeanFactory</strong></td>
<td align="left">最基本的容器，懒加载</td>
<td align="left">只有内存极受限的移动设备或 Applet 才直接用</td>
</tr>
<tr>
<td align="left"><strong>ListableBeanFactory</strong></td>
<td align="left">遍历、统计 Bean</td>
<td align="left"><code>@Autowired List&lt;Interface&gt;</code> 集合注入原理</td>
</tr>
<tr>
<td align="left"><strong>AutowireCapableBeanFactory</strong></td>
<td align="left">给现有对象注入依赖</td>
<td align="left">在 Filter、Interceptor 中手动注入 Bean</td>
</tr>
<tr>
<td align="left"><strong>BeanDefinitionRegistry</strong></td>
<td align="left">管理 Bean 的“图纸”</td>
<td align="left"><code>ClassPathBeanDefinitionScanner</code> 扫描后注册到这</td>
</tr>
<tr>
<td align="left"><strong>ApplicationContext</strong></td>
<td align="left">企业级功能聚合，预加载</td>
<td align="left">开发中最常用的接口</td>
</tr>
<tr>
<td align="left"><strong>ConfigurableApplicationContext</strong></td>
<td align="left">启动、刷新、关闭</td>
<td align="left"><code>SpringApplication.run</code> 的返回值</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-ApplicationContext的核心实现类"><a href="#3-ApplicationContext的核心实现类" class="headerlink" title="3. ApplicationContext的核心实现类"></a>3. ApplicationContext的核心实现类</h2><h3 id="3-1-XML时代"><a href="#3-1-XML时代" class="headerlink" title="3.1 XML时代"></a>3.1 XML时代</h3><p>现如今XML已经不再流行，但其有些设计思想被继承和发扬，在旧系统中仍发挥余温。</p>
<h4 id="3-1-1-ClassPathXmlApplicationContext-从类路径加载XML"><a href="#3-1-1-ClassPathXmlApplicationContext-从类路径加载XML" class="headerlink" title="3.1.1  ClassPathXmlApplicationContext: 从类路径加载XML"></a>3.1.1  <code>ClassPathXmlApplicationContext</code>: 从类路径加载XML</h4><h5 id="1-定位与职责"><a href="#1-定位与职责" class="headerlink" title="1. 定位与职责"></a>1. 定位与职责</h5><ul>
<li><strong>加载路径</strong>：从 Java 的 <strong>类路径 (Classpath)</strong> 加载配置文件。</li>
<li><strong>特点</strong>：<ul>
<li>这是 XML 时代最标准的启动方式。</li>
<li>路径通常写成 <code>classpath:applicationContext.xml</code>。</li>
<li>只要配置文件在 <code>src/main/resources</code> 下或打进 jar 包里，它都能找到。</li>
<li><strong>可移植性强</strong>：项目移动位置不影响启动。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-核心概念：什么是类路径？"><a href="#2-核心概念：什么是类路径？" class="headerlink" title="2. 核心概念：什么是类路径？"></a>2. 核心概念：什么是类路径？</h5><p>在 Java 中，类路径是一个**“资源搜索目录列表”**。</p>
<ul>
<li><strong>机制</strong>：当请求资源时，JVM 会按顺序在这些目录下查找。</li>
<li><strong>在典型的Maven&#x2F;Gradle项目中</strong>：<ul>
<li>源码 (<code>src/main/java</code>) 编译后的 <code>.class</code> 文件会被自动放入类路径。</li>
<li>资源目录 (<code>src/main/resources</code>) 下的所有文件（如 <code>application.xml</code>）都会被构建工具（Maven&#x2F;Gradle）自动复制到最终的类路径根目录下。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 容器启动时，自动读取 resources 目录下的 applicationContext.xml</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果配置被拆分到了多个XML文件中</span></span><br><span class="line"><span class="comment">// 方法一：传入一个字符串数组</span></span><br><span class="line">String[] configFiles = &#123;<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>&#125;;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(configFiles);</span><br><span class="line"><span class="comment">// 方法二：使用通配符（加载所有以 -context.xml 结尾的配置文件）</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath*:/META-INF/*-context.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-2-FileSystemXmlApplicationContext-从文件系统加载XML"><a href="#3-1-2-FileSystemXmlApplicationContext-从文件系统加载XML" class="headerlink" title="3.1.2 FileSystemXmlApplicationContext: 从文件系统加载XML"></a>3.1.2 <code>FileSystemXmlApplicationContext</code>: 从文件系统加载XML</h4><h5 id="1-定位与职责-1"><a href="#1-定位与职责-1" class="headerlink" title="1. 定位与职责"></a>1. 定位与职责</h5><ul>
<li><strong>加载路径</strong>：从操作系统的 <strong>文件系统 (File System)</strong> 加载。</li>
<li><strong>特点</strong>：<ul>
<li>需要指定绝对路径，例如 <code>D:/project/config/beans.xml</code> 或 <code>/etc/opt/app/beans.xml</code>。</li>
<li><strong>耦合度高</strong>：如果换台电脑或服务器，路径变了，程序就起不来了。</li>
<li><strong>用途</strong>：通常用于加载外部独立于 Jar 包之外的配置文件。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-ClassPath-vs-FileSystem"><a href="#2-ClassPath-vs-FileSystem" class="headerlink" title="2. ClassPath vs FileSystem"></a>2. ClassPath vs FileSystem</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">ClassPathXmlApplicationContext</th>
<th align="left">FileSystemXmlApplicationContext</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>加载源</strong></td>
<td align="left"><strong>类路径</strong></td>
<td align="left"><strong>文件系统</strong></td>
</tr>
<tr>
<td align="left"><strong>路径示例</strong></td>
<td align="left"><code>application.xml</code></td>
<td align="left"><code>/etc/config/app-config.xml</code> (绝对路径)<br><code>config/app.xml</code> (相对路径)</td>
</tr>
<tr>
<td align="left"><strong>可移植性</strong></td>
<td align="left"><strong>高</strong> (随 JAR 包移动，不依赖环境)</td>
<td align="left"><strong>低</strong> (依赖特定服务器的文件路径)</td>
</tr>
<tr>
<td align="left"><strong>典型用途</strong></td>
<td align="left">应用内部的标准配置</td>
<td align="left"><strong>外部化配置</strong> (不重新打包修改配置)</td>
</tr>
</tbody></table>
<hr>
<h5 id="3-代码示例-1"><a href="#3-代码示例-1" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一：使用相对路径加载</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;config/app-config.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//二：使用绝对路径加载</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;D:/projects/my-spring-app/config/app-config.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-2-现代标准：AnnotationConfigApplicationContext"><a href="#3-2-现代标准：AnnotationConfigApplicationContext" class="headerlink" title="3.2 现代标准：AnnotationConfigApplicationContext"></a>3.2 现代标准：AnnotationConfigApplicationContext</h3><h4 id="3-2-1-核心定位与概述"><a href="#3-2-1-核心定位与概述" class="headerlink" title="3.2.1 核心定位与概述"></a>3.2.1 核心定位与概述</h4><ul>
<li><strong>定位</strong>：它是 <strong>全注解驱动</strong> (Full Annotation Support) 的核心入口。它不需要任何 XML 文件，完全通过 Java 类来配置容器。</li>
<li><strong>地位</strong>：<ul>
<li>它是现代 Spring 应用的“启动器”。</li>
<li>在 Spring Boot 中，非 Web 环境默认使用此 Context；Web 环境使用其子类或变体。</li>
</ul>
</li>
<li><strong>对比</strong>：它是 <code>ClassPathXmlApplicationContext</code> 的现代替代者。不再解析 <code>applicationContext.xml</code>，而是解析 Java Config 类。</li>
</ul>
<hr>
<h4 id="3-2-2-继承体系"><a href="#3-2-2-继承体系" class="headerlink" title="3.2.2 继承体系"></a>3.2.2 继承体系</h4><ol>
<li><strong><code>GenericApplicationContext</code></strong>：<ul>
<li>父类。它持有一个 <code>DefaultListableBeanFactory</code> 实例且实现了<code>BeanDefinitionRegistry</code>。这说明 <code>AnnotationConfigApplicationContext</code> 本质上是一个包含 BeanFactory 的通用容器，且具备<strong>注册 Bean 定义</strong>的能力。</li>
</ul>
</li>
<li><strong><code>AnnotationConfigRegistry</code></strong> (接口)：<ul>
<li><strong>特有接口</strong>，定义了两个核心方法：<code>register()</code> 和 <code>scan()</code>。这是该类区别于其他 Context 的特征。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-2-3-核心成员变量"><a href="#3-2-3-核心成员变量" class="headerlink" title="3.2.3 核心成员变量"></a>3.2.3 核心成员变量</h4><p>该类内部有两个极其重要的组件，负责处理注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationConfigApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">GenericApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">AnnotationConfigRegistry</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 读取器：负责注册单个带注解的类（手动注册）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AnnotatedBeanDefinitionReader reader;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 扫描器：负责扫描类路径包（自动扫描）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassPathBeanDefinitionScanner scanner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-4-构造函数深度解析（启动流程入口）"><a href="#3-2-4-构造函数深度解析（启动流程入口）" class="headerlink" title="3.2.4 构造函数深度解析（启动流程入口）"></a>3.2.4 构造函数深度解析（启动流程入口）</h4><h5 id="1-无参构造函数"><a href="#1-无参构造函数" class="headerlink" title="1. 无参构造函数"></a>1. 无参构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 调用父类构造：初始化 DefaultListableBeanFactory</span></span><br><span class="line">    <span class="built_in">super</span>(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 初始化读取器</span></span><br><span class="line">    <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 初始化扫描器</span></span><br><span class="line">    <span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>深度解析：<code>AnnotatedBeanDefinitionReader</code> 做了什么？</strong></p>
<p>当 <code>new AnnotatedBeanDefinitionReader(this)</code> 被调用时，底层会执行 <code>AnnotationConfigUtils.registerAnnotationConfigProcessors(...)</code>。<strong>这是 Spring 能识别注解的根源。</strong></p>
<p>它会向容器中注册以下<strong>6大内置 BeanPostProcessor（BPP）</strong>：</p>
<p><strong>结论</strong>：即使你还没有注册任何自己的 Bean，调用无参构造后，容 器里已经躺着这几个 Spring 系统级的处理器了。</p>
<ol>
<li><strong><code>ConfigurationClassPostProcessor</code></strong> ：</li>
</ol>
<ul>
<li>处理 <code>@Configuration</code>, <code>@Bean</code>, <code>@Import</code>, <code>@ComponentScan</code>。</li>
</ul>
<ol start="2">
<li><strong><code>AutowiredAnnotationBeanPostProcessor</code></strong>：</li>
</ol>
<ul>
<li>处理 <code>@Autowired</code>, <code>@Value</code>, <code>@Inject</code>。</li>
</ul>
<ol start="3">
<li><strong><code>CommonAnnotationBeanPostProcessor</code></strong>：</li>
</ol>
<ul>
<li>处理 JSR-250 注解（<code>@Resource</code>, <code>@PostConstruct</code>, <code>@PreDestroy</code>）。</li>
</ul>
<ol start="4">
<li><strong><code>EventListenerMethodProcessor</code></strong>：</li>
</ol>
<ul>
<li>处理 <code>@EventListener</code>。</li>
</ul>
<ol start="5">
<li><strong><code>DefaultEventListenerFactory</code></strong>。</li>
<li><strong><code>PersistenceAnnotationBeanPostProcessor</code></strong> (仅在 JPA 环境下注册)。</li>
</ol>
</blockquote>
<hr>
<h5 id="2-有参构造函数（常见用法）"><a href="#2-有参构造函数（常见用法）" class="headerlink" title="2. 有参构造函数（常见用法）"></a>2. 有参构造函数（常见用法）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 调用无参构造，注册内置处理器</span></span><br><span class="line">    <span class="built_in">this</span>(); </span><br><span class="line">    <span class="comment">// 2. 注册传入的配置类</span></span><br><span class="line">    register(componentClasses); </span><br><span class="line">    <span class="comment">// 3. 刷新容器</span></span><br><span class="line">    refresh(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-5-核心方法源码解析"><a href="#3-2-5-核心方法源码解析" class="headerlink" title="3.2.5 核心方法源码解析"></a>3.2.5 核心方法源码解析</h4><h5 id="1-register-Class-componentClasses"><a href="#1-register-Class-componentClasses" class="headerlink" title="1. register(Class&lt;?&gt;... componentClasses)"></a>1. <code>register(Class&lt;?&gt;... componentClasses)</code></h5><p>该方法将我们传入的配置类（如 <code>AppConfig.class</code>）解析为 <code>BeanDefinition</code>。</p>
<p><strong>底层流程（AnnotatedBeanDefinitionReader.doRegisterBean）：</strong></p>
<ol>
<li><strong>包装</strong>：将 <code>Class</code> 包装成 <code>AnnotatedGenericBeanDefinition</code>。</li>
<li><strong>条件判断</strong>：检查是否有 <code>@Conditional</code> 注解，决定是否跳过注册。</li>
<li><strong>元数据解析</strong>：<ul>
<li>解析 <code>@Scope</code>（单例&#x2F;多例）。</li>
<li>解析Bean名称（默认类名首字母小写，或 <code>@Component(&quot;name&quot;)</code>）。</li>
<li>解析 <code>@Lazy</code>（懒加载）、<code>@Primary</code>（主选）、<code>@Role</code> 等通用注解。</li>
</ul>
</li>
<li><strong>注册</strong>：调用 <code>BeanDefinitionReaderUtils.registerBeanDefinition</code> 将定义存入 <code>BeanFactory</code> 的 <code>beanDefinitionMap</code> 中。</li>
</ol>
<hr>
<h5 id="2-scan-String-basePackages"><a href="#2-scan-String-basePackages" class="headerlink" title="2. scan(String... basePackages)"></a>2. <code>scan(String... basePackages)</code></h5><p>用于扫描指定包下的组件。</p>
<p><strong>底层流程（ClassPathBeanDefinitionScanner.doScan）：</strong></p>
<ol>
<li><strong>资源加载</strong>：根据包路径组装 ResourcePattern（如 <code>classpath*:com/my/app/**/*.class</code>）。</li>
<li><strong>元数据读取</strong>：利用 ASM 技术（<code>MetadataReader</code>）读取 <code>.class</code> 文件，不加载类本身（为了性能）。</li>
<li><strong>过滤器匹配</strong>：检查是否包含 <code>@Component</code>（及其衍生注解 <code>@Service</code>, <code>@Controller</code> 等）。</li>
<li><strong>定义生成</strong>：生成 <code>ScannedGenericBeanDefinition</code>。</li>
<li><strong>注册</strong>：存入 <code>BeanFactory</code>。</li>
</ol>
<hr>
<h4 id="3-2-6-与-refresh-的联动机制"><a href="#3-2-6-与-refresh-的联动机制" class="headerlink" title="3.2.6 与 refresh() 的联动机制"></a>3.2.6 与 <code>refresh()</code> 的联动机制</h4><p><code>AnnotationConfigApplicationContext</code> 自身没有重写 <code>refresh()</code>，使用的是父类 <code>AbstractApplicationContext</code> 的标准流程。</p>
<p><strong>关键连接点</strong>：</p>
<ul>
<li>在 <code>refresh()</code> 的 <code>invokeBeanFactoryPostProcessors</code> 阶段。</li>
<li>容器会找到在构造函数中注册的 <strong><code>ConfigurationClassPostProcessor</code></strong>。</li>
<li><strong>CCPP</strong> 会再次扫描。如果我们在 <code>register()</code> 阶段注册的类上有 <code>@ComponentScan</code> 或 <code>@Import</code>，CCPP 会在这里进行“二次扫描”和“深度解析”，将所有剩余的 Bean 定义加载进容器。</li>
</ul>
<hr>
<h3 id="3-3-Web-环境"><a href="#3-3-Web-环境" class="headerlink" title="3.3 Web 环境"></a>3.3 Web 环境</h3><h4 id="3-3-1-核心接口：WebApplicationContext"><a href="#3-3-1-核心接口：WebApplicationContext" class="headerlink" title="3.3.1 核心接口：WebApplicationContext"></a>3.3.1 核心接口：WebApplicationContext</h4><p>普通 <code>ApplicationContext</code> 无法感知 Web 环境（不知道什么是 Session，什么是 Request）。为此，Spring 扩展出了 <code>WebApplicationContext</code> 接口。</p>
<h5 id="1-接口定义"><a href="#1-接口定义" class="headerlink" title="1. 接口定义"></a>1. 接口定义</h5><p>它继承自 <code>ApplicationContext</code>，并增加了对 Web 资源的操作能力：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WebApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 【关键常量】</span></span><br><span class="line">    <span class="comment">// Spring 容器实例化后，会以此 Key 存储在 ServletContext 的 Attribute 中</span></span><br><span class="line">    <span class="comment">// 作用：让第三方工具或 Filter 能够通过 ServletContext 找到 Spring 容器</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</span> <span class="operator">=</span> WebApplicationContext.class.getName() + <span class="string">&quot;.ROOT&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【核心方法】</span></span><br><span class="line">    <span class="comment">// 获取标准的 Servlet API 对象：ServletContext</span></span><br><span class="line">    ServletContext <span class="title function_">getServletContext</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-三大特性"><a href="#2-三大特性" class="headerlink" title="2. 三大特性"></a>2. 三大特性</h5><ol>
<li><strong>环境感知</strong>：它能访问 ServletContext，从而读取 <code>web.xml</code> 中的参数或获取 Web 根路径下的资源。</li>
<li><strong>作用域扩展</strong>：它激活了 Web 特有的 Bean 作用域（<code>request</code>, <code>session</code>, <code>application</code>, <code>websocket</code>）。</li>
<li><strong>UI 绑定</strong>：通常与 Servlet 容器绑定，用于支持 Web 相关的 Bean（如 Controller, ViewResolver）。</li>
</ol>
<hr>
<h4 id="3-3-2-容器与-ServletContext-的“双向绑定”"><a href="#3-3-2-容器与-ServletContext-的“双向绑定”" class="headerlink" title="3.3.2 容器与 ServletContext 的“双向绑定”"></a>3.3.2 容器与 ServletContext 的“双向绑定”</h4><h5 id="1-Spring-引用-ServletContext"><a href="#1-Spring-引用-ServletContext" class="headerlink" title="1. Spring 引用 ServletContext"></a>1. Spring 引用 ServletContext</h5><ul>
<li><strong>动作</strong>：Spring 容器在启动时，会把 <code>ServletContext</code> 引用保存在内部。</li>
<li><strong>用途</strong>：Bean 实现了 <code>ServletContextAware</code> 接口后，可以获得该对象，用于读取 Web 资源路径（<code>context.getRealPath(&quot;/&quot;)</code>）。</li>
</ul>
<h5 id="2-ServletContext-引用-Spring"><a href="#2-ServletContext-引用-Spring" class="headerlink" title="2. ServletContext 引用 Spring"></a>2. ServletContext 引用 Spring</h5><ul>
<li><strong>动作</strong>：Spring 容器启动完成（Refresh）后，会把自己（<code>this</code>）存入 ServletContext 的全局属性列表（Attribute Map）中。</li>
<li><strong>Key</strong>：<code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code></li>
<li><strong>用途</strong>：这是在<strong>非 Spring 管理的类</strong>（如原生的 Servlet、Filter、Listener 或工具类）中获取 Spring Bean 的唯一官方途径。</li>
</ul>
<h5 id="3-工具类代码示例-WebApplicationContextUtils"><a href="#3-工具类代码示例-WebApplicationContextUtils" class="headerlink" title="3. 工具类代码示例 (WebApplicationContextUtils)"></a>3. 工具类代码示例 (WebApplicationContextUtils)</h5><p>Spring 提供了一个工具类来简化这个“查找”过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取 ServletContext</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 从 ServletContext 中“捞”出 Spring 容器</span></span><br><span class="line">        <span class="comment">// 底层原理：return sc.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</span></span><br><span class="line">        <span class="type">WebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> WebApplicationContextUtils.getWebApplicationContext(sc);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 此时就可以使用 getBean 了</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> ctx.getBean(UserService.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-3-3-启动驱动器：ContextLoaderListener"><a href="#3-3-3-启动驱动器：ContextLoaderListener" class="headerlink" title="3.3.3 启动驱动器：ContextLoaderListener"></a>3.3.3 启动驱动器：ContextLoaderListener</h4><p>在非 Spring Boot 的传统 Web 项目中，<code>ContextLoaderListener</code>负责将 Spring 容器启动。它属于 <code>spring-web</code> 包，不依赖 MVC。</p>
<h5 id="1-职责"><a href="#1-职责" class="headerlink" title="1. 职责"></a>1. 职责</h5><p>它是 Servlet 标准监听器 <code>ServletContextListener</code> 的实现类。</p>
<ul>
<li><strong>contextInitialized (启动时)</strong>：初始化 Spring <strong>Root</strong> 容器（通常加载 Service&#x2F;Dao）。</li>
<li><strong>contextDestroyed (关闭时)</strong>：关闭 Spring 容器，释放资源（如数据库连接池）。</li>
</ul>
<h5 id="2-启动流程原理"><a href="#2-启动流程原理" class="headerlink" title="2. 启动流程原理"></a>2. 启动流程原理</h5><ol>
<li>Tomcat 启动，读取 <code>web.xml</code>。</li>
<li>Tomcat 实例化 <code>ContextLoaderListener</code>。</li>
<li>触发 <code>contextInitialized(ServletContextEvent event)</code> 事件。</li>
<li><strong>创建容器</strong>：根据配置（XML或注解类）创建 <code>WebApplicationContext</code> 实例。</li>
<li><strong>容器刷新</strong>：调用 <code>wac.refresh()</code>，完成所有 Singleton Bean 的创建。</li>
<li><strong>回填</strong>：调用 <code>servletContext.setAttribute(key, wac)</code>，完成双向绑定。</li>
</ol>
<h5 id="3-配置示例-web-xml"><a href="#3-配置示例-web-xml" class="headerlink" title="3. 配置示例 (web.xml)"></a>3. 配置示例 (web.xml)</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 监听器配置：Web应用启动时，通知 Spring 干活 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 告诉 Spring 配置文件在哪里 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果不写，默认找 /WEB-INF/applicationContext.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-root.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-3-4-Web-作用域的底层支持"><a href="#3-3-4-Web-作用域的底层支持" class="headerlink" title="3.3.4 Web 作用域的底层支持"></a>3.3.4 Web 作用域的底层支持</h4><p>在 Spring Framework 笔记中，我们需要解释清楚：为什么在普通的 <code>main</code> 方法中，使用 <code>@Scope(&quot;request&quot;)</code> 会报错？</p>
<ul>
<li><strong>问题根源</strong>：Spring 的核心容器（BeanFactory）默认只有单例和原型作用域。它不知道“HTTP 请求”何时开始、何时结束，线程也没有绑定 Request 上下文。</li>
<li><strong>解决机制</strong>：需要将 HTTP 请求对象绑定到当前线程（ThreadLocal）。</li>
<li><strong>实现者</strong>：<ul>
<li><strong>在 Spring MVC 中</strong>：<code>DispatcherServlet</code> 自动处理了，它在请求进来时，通过 <code>RequestContextHolder</code> 绑定了属性。</li>
<li><strong>在非 Spring MVC (如 Struts2&#x2F;JSF) 中</strong>：需要在 <code>web.xml</code> 中配置额外的监听器 <code>RequestContextListener</code> 来手动触发绑定。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-3-5-常见实现类"><a href="#3-3-5-常见实现类" class="headerlink" title="3.3.5 常见实现类"></a>3.3.5 常见实现类</h4><ol>
<li><strong>XmlWebApplicationContext</strong><ul>
<li><strong>定位</strong>：传统老将。</li>
<li><strong>配置</strong>：基于 XML 文件路径。</li>
<li><strong>默认行为</strong>：若无配置，默认查找 <code>/WEB-INF/applicationContext.xml</code>。</li>
</ul>
</li>
<li><strong>AnnotationConfigWebApplicationContext</strong><ul>
<li><strong>定位</strong>：现代 WAR 包部署的标准。</li>
<li><strong>配置</strong>：接受 <code>@Configuration</code> 注解类或包扫描路径。</li>
<li><strong>场景</strong>：用于传统的 Web 服务器部署，但使用纯 Java 配置替代 XML。</li>
</ul>
</li>
<li><strong>AnnotationConfigServletWebServerApplicationContext</strong><ul>
<li><strong>定位</strong>：Spring Boot 的核心。</li>
<li><strong>特殊能力</strong>：它不仅仅是一个容器，它在启动时<strong>会自动创建并启动</strong>嵌入式的 Web 服务器（如 Tomcat）。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="4-启动流程"><a href="#4-启动流程" class="headerlink" title="4. 启动流程"></a>4. 启动流程</h2><h3 id="4-1-非Web环境"><a href="#4-1-非Web环境" class="headerlink" title="4.1 非Web环境"></a>4.1 非Web环境</h3><p><strong>代码入口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br></pre></td></tr></table></figure>

<p><strong>底层流程拆解：</strong></p>
<ol>
<li><strong>构造函数调用 (<code>public AnnotationConfigApplicationContext(Class&lt;?&gt;... componentClasses)</code>)</strong><ul>
<li>这是入口，它内部按顺序做了三件大事：</li>
</ul>
</li>
<li><strong>父类构造 &amp; 初始化读取器 (<code>this()</code>)</strong><ul>
<li>调用无参构造函数，首先初始化父类 <code>GenericApplicationContext</code>，创建内部的 <code>DefaultListableBeanFactory</code>。</li>
<li><strong>关键点：</strong> 初始化 <code>AnnotatedBeanDefinitionReader</code>。<ul>
<li>这个 Reader 在构造时，会调用 <code>AnnotationConfigUtils.registerAnnotationConfigProcessors</code>。</li>
<li><strong>埋下伏笔：</strong> 这里静悄悄地向容器中注册了 Spring 的基础设施 Bean，包括最重要的 <strong><code>ConfigurationClassPostProcessor</code></strong>。它是后续执行“扫描”动作的执行者。此时它只是被注册了 BeanDefinition，还没实例化。</li>
</ul>
</li>
</ul>
</li>
<li><strong>注册种子 Bean (<code>register(componentClasses)</code>)</strong><ul>
<li>将传入的配置类（例如 <code>AppConfig.class</code>）解析为 <code>BeanDefinition</code>。</li>
<li>将其注册到 BeanFactory 的 Map 中。</li>
<li><strong>此时容器里有什么？</strong> 只有几个内部基础设施 Bean 的定义 + 你的 <code>AppConfig</code> 的定义。此时还没有开始扫描 <code>AppConfig</code> 上面的 <code>@ComponentScan</code>。</li>
</ul>
</li>
<li><strong>手动触发刷新 (<code>refresh()</code>)</strong><ul>
<li>构造函数的最后一行调用 <code>refresh()</code>。</li>
<li>进入 <code>AbstractApplicationContext</code>。</li>
<li>执行 <code>prepareRefresh()</code>（设置时间、状态）。</li>
<li>执行 <code>obtainFreshBeanFactory()</code>（只是返回在第 2 步创建好的 BeanFactory）。</li>
<li>执行 <code>prepareBeanFactory()</code>（设置类加载器、忽略接口等）。</li>
</ul>
</li>
</ol>
<p><strong>到达终点：</strong> 此时 <code>refresh()</code> 执行到第 5 步 <code>invokeBeanFactoryPostProcessors</code>，准备叫醒 <code>ConfigurationClassPostProcessor</code> 去解析 <code>AppConfig</code> 并扫描其他 Bean。</p>
<hr>
<h3 id="4-2-传统Web环境"><a href="#4-2-传统Web环境" class="headerlink" title="4.2 传统Web环境"></a>4.2 传统Web环境</h3><p>这种模式是被动启动，依赖 Servlet 容器（如 Tomcat）。</p>
<p><strong>代码入口：</strong> Tomcat 启动 -&gt; 读取 <code>web.xml</code>。</p>
<p><strong>底层流程拆解：</strong></p>
<ol>
<li><strong>触发监听器 (<code>ContextLoaderListener.contextInitialized</code>)</strong><ul>
<li>Tomcat 启动时触发 Servlet 标准事件。</li>
<li><code>ContextLoaderListener</code> 继承自 <code>ContextLoader</code>，核心逻辑都在父类里。</li>
</ul>
</li>
<li><strong>初始化 Web 上下文 (<code>ContextLoader.initWebApplicationContext</code>)</strong><ul>
<li>这是核心引导方法。</li>
</ul>
</li>
<li><strong>确定容器类型 (<code>determineContextClass</code>)</strong><ul>
<li>检查 <code>web.xml</code> 中是否有 <code>contextClass</code> 参数。</li>
<li>如果没有，读取 <code>ContextLoader.properties</code> 文件，默认使用 <strong><code>XmlWebApplicationContext</code></strong>。</li>
</ul>
</li>
<li><strong>实例化容器 (<code>instantiateClass</code>)</strong><ul>
<li>通过反射 <code>BeanUtils.instantiateClass</code> 创建上下文对象。</li>
</ul>
</li>
<li><strong>准备容器配置 (<code>configureAndRefreshWebApplicationContext</code>)</strong><ul>
<li><strong>设置关联：</strong> 将 <code>ServletContext</code> 注入到 Spring 容器中。</li>
<li><strong>设置配置路径：</strong> 读取 <code>web.xml</code> 中的 <code>contextConfigLocation</code>（例如 <code>classpath:applicationContext.xml</code>），并将这个路径字符串塞给容器对象。<strong>注意：此时还没有解析 XML，只是存了个路径。</strong></li>
</ul>
</li>
<li><strong>触发刷新 (<code>wac.refresh()</code>)</strong><ul>
<li>调用 <code>AbstractApplicationContext.refresh()</code>。</li>
<li><strong>关键差异点：</strong> 在 <code>refresh()</code> 的第 2 步 <code>obtainFreshBeanFactory()</code> 中，子类 <code>AbstractRefreshableApplicationContext</code> 会调用 <code>loadBeanDefinitions()</code>。</li>
<li><strong>解析种子：</strong> 此时 <code>XmlBeanDefinitionReader</code> 登场，解析 <code>applicationContext.xml</code>。<ul>
<li>如果 XML 里写了 <code>&lt;context:component-scan&gt;</code>，这里会注册扫描器。</li>
<li>如果 XML 里全是 <code>&lt;bean&gt;</code> 标签，这里直接注册 BeanDefinition。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>到达终点：</strong> XML 解析完毕，BeanDefinition 进入 Map，准备进行后续的 PostProcessor 处理。</p>
<hr>
<hr>
<h1 id="三、Bean"><a href="#三、Bean" class="headerlink" title="三、Bean"></a>三、Bean</h1><h2 id="1-什么是-Spring-Bean？"><a href="#1-什么是-Spring-Bean？" class="headerlink" title="1. 什么是 Spring Bean？"></a>1. 什么是 Spring Bean？</h2><h3 id="1-1-基本定义"><a href="#1-1-基本定义" class="headerlink" title="1.1 基本定义"></a>1.1 基本定义</h3><ul>
<li><strong>官方定义</strong>：Spring Bean 是那些由 Spring IoC 容器<strong>实例化</strong>、<strong>组装（注入依赖）</strong>、<strong>管理</strong>的对象。</li>
<li><strong>本质</strong>：Bean 就是一个 Java 对象。</li>
<li><strong>核心区别</strong>：<ul>
<li>我们自己 <code>new</code> 出来的对象，叫原生对象（Raw Object）。</li>
<li>由 Spring 容器（<code>ApplicationContext</code>）管理的对象，叫 <strong>Spring Bean</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-Spring-Bean-与-POJO-的区别"><a href="#1-2-Spring-Bean-与-POJO-的区别" class="headerlink" title="1.2 Spring Bean 与 POJO 的区别"></a>1.2 Spring Bean 与 POJO 的区别</h3><h4 id="1-2-1-核心机制：从-POJO-到-Bean-的蜕变"><a href="#1-2-1-核心机制：从-POJO-到-Bean-的蜕变" class="headerlink" title="1.2.1 核心机制：从 POJO 到 Bean 的蜕变"></a>1.2.1 核心机制：从 POJO 到 Bean 的蜕变</h4><blockquote>
<p><strong>什么是 POJO</strong>：</p>
<ul>
<li>指简单的 Java 对象。它不继承任何 Spring 特定的类，也不实现任何 Spring 特定的接口。</li>
<li>好处：代码纯净，易于测试，解耦。</li>
</ul>
</blockquote>
<p>POJO 要转化为 Spring Bean，经历了一套严谨的<strong>定义与构建</strong>流程。</p>
<ol>
<li><strong>配置元数据（Configuration Metadata）</strong><br>容器需要依据“图纸”来创建 Bean。开发者通过以下三种方式提供元数据：<ul>
<li><strong>基于 XML 的配置</strong>：使用 <code>&lt;bean&gt;</code> 标签定义。</li>
<li><strong>基于注解的配置</strong>：使用 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code> 等构造型注解。</li>
<li><strong>基于 Java 类的配置</strong>：在 <code>@Configuration</code> 类中使用 <code>@Bean</code> 注解的方法。</li>
</ul>
</li>
<li><strong>BeanDefinition（Bean 定义信息）</strong><br>Spring 容器解析上述元数据后，会将其转化为内部的 <code>BeanDefinition</code> 对象。该对象描述了 Bean 的所有属性（类名、作用域、构造参数、依赖关系等）。</li>
<li><strong>实例化与管理</strong><br>容器根据 <code>BeanDefinition</code>，利用<strong>Java 反射机制</strong>创建实例，注入依赖，并执行初始化回调，最终将一个完全可用的 Bean 放入容器缓存池（对于单例而言）供应用使用。</li>
</ol>
<hr>
<h4 id="1-2-2-Bean-的关键特性"><a href="#1-2-2-Bean-的关键特性" class="headerlink" title="1.2.2 Bean 的关键特性"></a>1.2.2 Bean 的关键特性</h4><p>被 Spring 托管的 Bean 具备以下核心特征，这些特征将其与普通对象区分开来：</p>
<ol>
<li><strong>容器托管（Container-Managed）</strong><ul>
<li>Bean 的全生命周期（创建、初始化、使用、销毁）由容器统一调度，开发者只需关注业务逻辑，无需处理底层资源管理。</li>
</ul>
</li>
<li><strong>唯一标识（Identity）</strong><ul>
<li>每个 Bean 在容器中拥有唯一的 ID（或 Name）。这是容器索引和检索 Bean 的句柄。</li>
<li><em>注：使用注解配置时，默认 ID 为类名首字母小写（如 <code>UserService</code> -&gt; <code>userService</code>）。</em></li>
</ul>
</li>
<li><strong>依赖注入能力（DI-Capable）</strong><ul>
<li>Bean 不需要自行查找或创建它所依赖的对象。通过声明依赖（如字段注入、构造器注入），容器会在创建 Bean 时自动完成“装配”。</li>
</ul>
</li>
<li><strong>作用域策略（Scope Strategy）</strong><ul>
<li>Bean 的存在形式由 Scope 定义。最常见的是 <strong>Singleton</strong>（单例，容器内唯一）和 <strong>Prototype</strong>（原型，每次获取创建新实例），此外还支持 Web 环境下的 <code>request</code>、<code>session</code> 等作用域。</li>
</ul>
</li>
<li><strong>生命周期回调（Lifecycle Callbacks）</strong><ul>
<li>Bean 可以在初始化前后（<code>@PostConstruct</code>）或销毁前（<code>@PreDestroy</code>）执行特定的逻辑，这为资源加载和释放提供了标准钩子。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-2-3-深度对比：Spring-Bean-vs-POJO"><a href="#1-2-3-深度对比：Spring-Bean-vs-POJO" class="headerlink" title="1.2.3 深度对比：Spring Bean vs POJO"></a>1.2.3 深度对比：Spring Bean vs POJO</h4><table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">POJO</th>
<th align="left">Spring Bean</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>创建方式</strong></td>
<td align="left">显式调用构造函数 (<code>new User()</code>)</td>
<td align="left"><strong>隐式创建</strong>，由 IoC 容器基于反射机制完成</td>
</tr>
<tr>
<td align="left"><strong>依赖管理</strong></td>
<td align="left">开发者硬编码管理，耦合度高</td>
<td align="left"><strong>依赖注入 (DI)</strong>，由容器自动装配，松耦合</td>
</tr>
<tr>
<td align="left"><strong>生命周期</strong></td>
<td align="left">取决于作用域和 JVM 垃圾回收 (GC)</td>
<td align="left"><strong>容器精确控制</strong>，支持初始化与销毁的钩子函数</td>
</tr>
<tr>
<td align="left"><strong>配置灵活性</strong></td>
<td align="left">代码编译后难以修改属性</td>
<td align="left"><strong>元数据驱动</strong>，可通过配置文件或注解动态调整行为</td>
</tr>
<tr>
<td align="left"><strong>获取方式</strong></td>
<td align="left">直接变量引用</td>
<td align="left">通过 <code>ApplicationContext</code> 获取或 <code>@Autowired</code> 注入</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-3-BeanDefinition"><a href="#1-3-BeanDefinition" class="headerlink" title="1.3 BeanDefinition"></a>1.3 <code>BeanDefinition</code></h3><h4 id="1-3-1-什么是-BeanDefinition"><a href="#1-3-1-什么是-BeanDefinition" class="headerlink" title="1.3.1 什么是 BeanDefinition"></a>1.3.1 什么是 BeanDefinition</h4><ul>
<li><strong>概念</strong>：它是 Bean 的<strong>配置元数据接口</strong>。</li>
<li><strong>比喻</strong>：<ul>
<li>Java 类 (<code>User.class</code>) &#x3D; <strong>图纸</strong>。</li>
<li><code>BeanDefinition</code> &#x3D; <strong>施工方案</strong>（在图纸基础上，标注了是单例造还是多例造、要不要懒加载、初始化先干什么）。</li>
<li>Bean 实例 (<code>new User()</code>) &#x3D; <strong>建筑物</strong>。</li>
</ul>
</li>
<li><strong>源码地位</strong>：Spring 容器启动时，第一步就是将 XML 中的 <code>&lt;bean&gt;</code> 或注解 <code>@Component</code> 解析成 <code>BeanDefinition</code> 对象，存入 <code>BeanFactory</code> 的注册表中（通常是一个 <code>ConcurrentHashMap</code>）。</li>
</ul>
<hr>
<h4 id="1-3-2-BeanDefinition-包含的关键信息"><a href="#1-3-2-BeanDefinition-包含的关键信息" class="headerlink" title="1.3.2 BeanDefinition 包含的关键信息"></a>1.3.2 BeanDefinition 包含的关键信息</h4><ol>
<li><strong>BeanClassName</strong>：Bean 的全限定类名（容器通过反射 <code>Class.forName</code> 创建对象的基础）。</li>
<li><strong>Scope</strong>：作用域（Singleton &#x2F; Prototype 等）。</li>
<li><strong>LazyInit</strong>：是否懒加载（默认为 false）。</li>
<li><strong>PropertyValues</strong>：属性值（依赖注入的数据，对应 XML 中的 <code>&lt;property&gt;</code>）。</li>
<li><strong>ConstructorArgumentValues</strong>：构造器参数（对应 XML 中的 <code>&lt;constructor-arg&gt;</code>）。</li>
<li><strong>InitMethodName &#x2F; DestroyMethodName</strong>：初始化和销毁的方法名。</li>
<li><strong>ParentName</strong>：父 Bean 的名称（用于 Bean 配置的继承，较少用）。</li>
</ol>
<hr>
<h4 id="1-3-3-BeanDefinition-的生成过程-简述"><a href="#1-3-3-BeanDefinition-的生成过程-简述" class="headerlink" title="1.3.3 BeanDefinition 的生成过程 (简述)"></a>1.3.3 BeanDefinition 的生成过程 (简述)</h4><ol>
<li><strong>Reader&#x2F;Scanner</strong>：<code>XmlBeanDefinitionReader</code> 读取 XML，或 <code>ClassPathBeanDefinitionScanner</code> 扫描注解。</li>
<li><strong>Parsing</strong>：提取类信息、注解信息。</li>
<li><strong>Registration</strong>：封装成 <code>BeanDefinition</code> 对象，调用 <code>beanFactory.registerBeanDefinition(name, bd)</code> 注册。</li>
</ol>
<hr>
<h2 id="2-Bean-的声明与配置方式"><a href="#2-Bean-的声明与配置方式" class="headerlink" title="2. Bean 的声明与配置方式"></a>2. Bean 的声明与配置方式</h2><h3 id="2-1-基于XML的配置"><a href="#2-1-基于XML的配置" class="headerlink" title="2.1 基于XML的配置"></a>2.1 基于XML的配置</h3><p>XML配置是Spring框架诞生之初最原始、也是最经典的一种Bean声明方式。开发者通过编写一个或多个XML格式的配置文件，来向Spring IoC容器描述需要管理哪些Bean，以及这些Bean之间的依赖关系。</p>
<h4 id="2-1-1-核心标签"><a href="#2-1-1-核心标签" class="headerlink" title="2.1.1 核心标签&lt;bean&gt;"></a>2.1.1 核心标签<code>&lt;bean&gt;</code></h4><p>每一个<code>&lt;bean&gt;</code>标签都对应着容器中一个将被创建和管理的Bean实例。</p>
<h5 id="1-基本配置"><a href="#1-基本配置" class="headerlink" title="1. 基本配置"></a>1. 基本配置</h5><p>最简单的<code>&lt;bean&gt;</code>标签包含两个基本属性：</p>
<ul>
<li><code>id</code>：定义Bean的唯一标识符（Bean ID）。这个ID在整个IoC容器中必须是唯一的。我们可以通过这个ID从容器中获取Bean。</li>
<li><code>class</code>：指定该Bean实例对应的<strong>完整类名</strong>（包名+类名）。Spring容器会通过反射机制来实例化这个类。</li>
</ul>
<h5 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2. 代码示例"></a>2. 代码示例</h5><ul>
<li><p><strong>XML配置文件 (<code>beans.xml</code>)</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明一个HelloWorld类型的Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloWorld&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.HelloWorld&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 稍后会介绍如何在这里注入属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Java类 (<code>HelloWorld.java</code>)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Your Message : &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-1-2-XML支持的DI"><a href="#2-1-2-XML支持的DI" class="headerlink" title="2.1.2 XML支持的DI"></a>2.1.2 XML支持的DI</h4><p>XML配置支持两种主要的依赖注入方式：<strong>Setter注入</strong>和<strong>构造器注入</strong>。</p>
<h5 id="1-Setter注入"><a href="#1-Setter注入" class="headerlink" title="1. Setter注入"></a>1. Setter注入</h5><ul>
<li><strong>原理</strong>：IoC容器首先调用Bean的<strong>无参构造函数</strong>来创建实例，然后调用相应的<code>setXxx()</code>方法来注入依赖。</li>
<li><strong>XML标签</strong>：使用<code>&lt;property&gt;</code>子标签。<ul>
<li><code>name</code>：对应Java类中的<strong>属性名</strong>（实际上是对应<code>set</code>方法名，如<code>name=&quot;message&quot;</code>对应<code>setMessage()</code>方法）。</li>
<li><code>value</code>：用于注入<strong>基本类型</strong>（如<code>String</code>, <code>int</code>, <code>boolean</code>）和它们的包装类。</li>
<li><code>ref</code>：用于注入<strong>其他Bean的引用</strong>。它的值是另一个Bean的ID。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><p><strong>XML配置</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1. 先定义依赖的Bean: userDao --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserDaoImpl&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 定义需要被注入的Bean: userService --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用 &lt;property&gt; 进行Setter注入 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入一个字符串 (基本类型) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;DefaultUserService&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入另一个Bean的引用 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Java类 (<code>UserService.java</code> 和 <code>UserDao.java</code>)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserDao接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123; </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// UserDao实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;User saved to database.&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// UserService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须提供setter方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServiceName</span><span class="params">(String serviceName)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.serviceName = serviceName; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service Name: &quot;</span> + serviceName);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-构造器注入"><a href="#2-构造器注入" class="headerlink" title="2. 构造器注入"></a>2. 构造器注入</h5><ul>
<li><strong>原理</strong>：IoC容器在创建Bean实例时，直接调用其<strong>带有参数的构造函数</strong>，将依赖项作为构造函数的参数传入。</li>
<li><strong>XML标签</strong>：使用<code>&lt;constructor-arg&gt;</code>子标签。<ul>
<li><code>index</code>：指定参数在构造函数参数列表中的<strong>索引</strong>（从0开始）。</li>
<li><code>type</code>：指定参数的<strong>类型</strong>（如<code>java.lang.String</code>），用于避免歧义。</li>
<li><code>name</code>：指定参数的<strong>名称</strong>（需要Java 8+的编译器支持并开启 <code>-parameters</code> 选项）。</li>
<li><code>value</code>和<code>ref</code>属性与<code>&lt;property&gt;</code>标签中的作用相同。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><p><strong>XML配置</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserDaoImpl&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用 &lt;constructor-arg&gt; 进行构造器注入 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 方式一：按索引注入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ConstructorUserService&quot;</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 方式二：按类型注入 (如果类型不重复) --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;constructor-arg type=&quot;com.example.UserDao&quot; ref=&quot;userDao&quot; /&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;ConstructorUserService&quot; /&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Java类 (<code>UserService.java</code>)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 依赖可以是final的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDao userDao; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供带参数的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao userDao, String serviceName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">        <span class="built_in">this</span>.serviceName = serviceName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-1-3-优缺点"><a href="#2-1-3-优缺点" class="headerlink" title="2.1.3 优缺点"></a>2.1.3 优缺点</h4><h5 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h5><ul>
<li><strong>非侵入性</strong>：配置信息与Java源代码完全分离。Java类是纯粹的POJO，不需要依赖任何Spring的注解。</li>
<li><strong>配置集中化</strong>：所有的Bean定义和依赖关系都集中在XML文件中，对于理解整个应用的宏观结构非常有帮助，一目了然。</li>
<li><strong>易于修改</strong>：在不重新编译Java代码的情况下，可以通过修改XML文件来改变Bean的行为或替换其实现。</li>
</ul>
<hr>
<h5 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h5><ul>
<li><strong>繁琐和冗长</strong>：随着应用规模的增长，XML文件会变得异常庞大和复杂，难以维护。</li>
<li><strong>类型不安全</strong>：XML中配置的类名、属性名都是字符串。如果写错了，只有在运行时容器启动时才能发现，而不能在编译时检查。</li>
<li><strong>导航和重构困难</strong>：在IDE中，从XML配置跳转到对应的Java代码比较麻烦。对Java类进行重命名等操作时，IDE无法自动更新XML中的字符串引用。</li>
<li><strong>配置分散</strong>：虽然XML本身是集中的，但配置信息和它所配置的Java类是分离的，查找一个类的具体配置需要在XML文件中搜索，不如注解直观。</li>
</ul>
<hr>
<h3 id="2-2-基于注解的配置"><a href="#2-2-基于注解的配置" class="headerlink" title="2.2 基于注解的配置"></a>2.2 基于注解的配置</h3><p>随着Java 5引入注解，Spring框架提供了一种更为简洁、直观的Bean声明方式——<strong>基于注解的组件扫描</strong>。我们不再需要在XML中为每个Bean编写<code>&lt;bean&gt;</code>标签，而是直接在Java类上添加特定的注解，Spring容器会自动扫描并注册它们。</p>
<h4 id="2-2-1-组件扫描"><a href="#2-2-1-组件扫描" class="headerlink" title="2.2.1 组件扫描"></a>2.2.1 组件扫描</h4><ul>
<li><strong>机制</strong>：我们首先需要在一个配置类（XML或Java Config）中启用组件扫描，并指定一个或多个需要扫描的<strong>基础包（base package）</strong>。</li>
<li><strong>过程</strong>：Spring容器在启动时，会像雷达一样扫描这些基础包以及其所有子包下的所有类。如果发现某个类被特定的注解标记，Spring就会将这个类自动注册为一个Bean。</li>
</ul>
<hr>
<h4 id="2-2-2-启用组件扫描"><a href="#2-2-2-启用组件扫描" class="headerlink" title="2.2.2 启用组件扫描"></a>2.2.2 启用组件扫描</h4><ul>
<li><p><strong>在XML中启用</strong>：<br>使用<code>&lt;context:component-scan&gt;</code>标签。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;...</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">           https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 启用组件扫描，指定基础包为 &quot;com.example&quot; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.example&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在Java Config中启用（更推荐）</strong>：<br>使用<code>@ComponentScan</code>注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;)</span></span><br><span class="line"><span class="comment">// 如果不指定basePackages，默认扫描当前配置类所在的包及其子包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-3-核心注解-Component"><a href="#2-2-3-核心注解-Component" class="headerlink" title="2.2.3 核心注解 @Component"></a>2.2.3 核心注解 <code>@Component</code></h4><ul>
<li><strong>作用</strong>：<code>@Component</code> 是最基础、最通用的组件注解。它可以标记任何一个你希望交给Spring管理的类。</li>
<li><strong>Bean ID</strong>：默认情况下，被<code>@Component</code>标记的类的Bean ID是其<strong>类名的首字母小写形式</strong>。例如，类<code>MyCoolService</code>的默认Bean ID是<code>myCoolService</code>。</li>
<li><strong>自定义ID</strong>：你也可以手动指定Bean ID，例如 <code>@Component(&quot;coolService&quot;)</code>。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 将MyUtility注册为Bean，默认ID为 &quot;myUtility&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUtility</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Utility is doing something.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-4-优缺点"><a href="#2-2-4-优缺点" class="headerlink" title="2.2.4 优缺点"></a>2.2.4 优缺点</h4><h5 id="1-优点-1"><a href="#1-优点-1" class="headerlink" title="1. 优点"></a>1. 优点</h5><ul>
<li><strong>简洁直观</strong>：注解直接写在它所配置的Java类上，代码和配置高度内聚，易于理解和维护。</li>
<li><strong>开发效率高</strong>：只需在类上加一个注解，无需在XML中进行繁琐的配置。</li>
<li><strong>更好的IDE支持</strong>：IDE可以轻松地识别注解，提供更好的代码导航、自动补全和重构支持。</li>
</ul>
<hr>
<h5 id="2-缺点-1"><a href="#2-缺点-1" class="headerlink" title="2. 缺点"></a>2. 缺点</h5><ul>
<li><strong>侵入性</strong>：Java代码需要依赖Spring的注解API，与Spring框架产生了耦合。</li>
<li><strong>配置分散</strong>：配置信息分散在各个Java类中，不如XML那样能提供一个全局的、集中的配置视图。</li>
<li><strong>对第三方库不友好</strong>：如果你想将一个<strong>第三方库</strong>中的类（注册为Bean，你无法去修改它的源码来添加<code>@Component</code>注解。</li>
</ul>
<hr>
<h3 id="2-3-基于JavaConfig的配置"><a href="#2-3-基于JavaConfig的配置" class="headerlink" title="2.3 基于JavaConfig的配置"></a>2.3 基于JavaConfig的配置</h3><p>Java Config 是一种使用Java类和注解来定义Spring IoC容器中Bean及其依赖关系的方式。</p>
<h4 id="2-3-1-核心注解"><a href="#2-3-1-核心注解" class="headerlink" title="2.3.1 核心注解"></a>2.3.1 核心注解</h4><h5 id="1-Configuration"><a href="#1-Configuration" class="headerlink" title="1. @Configuration"></a>1. <code>@Configuration</code></h5><ul>
<li><strong>作用</strong>：标记在一个类上，表明这个类是一个<strong>配置类</strong>。Spring容器会处理这个类，并将其中的 <code>@Bean</code> 方法定义的Bean注册到 <code>ApplicationContext</code> 中。</li>
<li><strong>本质</strong>：一个带有 <code>@Configuration</code> 注解的类，其本身也会被Spring当作一个特殊的 <code>@Component</code> 来管理。你可以像注入其他Bean一样注入它。</li>
<li><strong>类比</strong>：可以把它看作是一个 <strong>XML配置文件</strong>（如 <code>applicationContext.xml</code>）。</li>
</ul>
<hr>
<h5 id="2-Bean"><a href="#2-Bean" class="headerlink" title="2. @Bean"></a>2. <code>@Bean</code></h5><ul>
<li><strong>作用</strong>：标记在一个方法上，并且这个方法必须位于一个 <code>@Configuration</code> 类中（或者带有 <code>@Component</code> 及其派生注解的类中，但推荐在 <code>@Configuration</code> 中使用）。</li>
<li><strong>功能</strong>：Spring会调用这个方法，并将方法的<strong>返回值</strong>注册为一个Bean。</li>
<li><strong>Bean的名称</strong>：默认情况下，Bean的名称就是<strong>方法名</strong>。你也可以通过 <code>@Bean(name = &quot;customName&quot;)</code> 或 <code>@Bean(&quot;customName&quot;)</code> 来指定一个不同的名字。</li>
<li><strong>类比</strong>：可以把它看作是XML配置中的一个 <strong><code>&lt;bean&gt;</code> 标签</strong>。</li>
</ul>
<hr>
<h4 id="2-3-2-实际应用与示例"><a href="#2-3-2-实际应用与示例" class="headerlink" title="2.3.2 实际应用与示例"></a>2.3.2 实际应用与示例</h4><p>假设我们需要在项目中使用一个第三方的邮件发送客户端，这个客户端类我们无法修改，不能在它上面加 <code>@Component</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个模拟的第三方库中的类，我们无法修改它的源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmtpMailSender</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmtpMailSender</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.host = host;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">        System.out.println(<span class="string">&quot;Initializing SmtpMailSender for host: &quot;</span> + host);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String to, String subject, String body)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending email to &quot;</span> + to);</span><br><span class="line">        System.out.println(<span class="string">&quot;Host: &quot;</span> + host + <span class="string">&quot;:&quot;</span> + port);</span><br><span class="line">        System.out.println(<span class="string">&quot;Subject: &quot;</span> + subject);</span><br><span class="line">        System.out.println(<span class="string">&quot;Body: &quot;</span> + body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-创建一个配置类来定义Bean、"><a href="#1-创建一个配置类来定义Bean、" class="headerlink" title="1. 创建一个配置类来定义Bean、"></a>1. 创建一个配置类来定义Bean、</h5><p>我们创建一个专门的配置类来管理邮件相关的Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 application.properties 文件中注入配置值</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mail.smtp.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mail.smtp.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 这个方法告诉Spring：调用我，然后把我返回的对象注册成一个Bean</span></span><br><span class="line">    <span class="keyword">public</span> SmtpMailSender <span class="title function_">smtpMailSender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里，我们可以使用任何Java代码来创建和配置这个对象</span></span><br><span class="line">        <span class="comment">// 这比XML灵活得多</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Creating SmtpMailSender bean...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SmtpMailSender</span>(host, port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><code>application.properties</code> 文件内容:</em></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mail.smtp.host</span>=<span class="string">smtp.example.com</span></span><br><span class="line"><span class="attr">mail.smtp.port</span>=<span class="string">587</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-使用这个Bean"><a href="#2-使用这个Bean" class="headerlink" title="2. 使用这个Bean"></a>2. 使用这个Bean</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmtpMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring会自动找到名为&quot;smtpMailSender&quot;的Bean并注入进来</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationService</span><span class="params">(SmtpMailSender mailSender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mailSender = mailSender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendWelcomeEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        mailSender.send(email, <span class="string">&quot;Welcome!&quot;</span>, <span class="string">&quot;Thanks for signing up.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-3-优缺点"><a href="#2-3-3-优缺点" class="headerlink" title="2.3.3 优缺点"></a>2.3.3 优缺点</h4><h5 id="1-优点-2"><a href="#1-优点-2" class="headerlink" title="1. 优点"></a>1. 优点</h5><ul>
<li><strong>类型安全与重构友好</strong>：由编译器检查错误（拼写错直接爆红），IDE重构（改名、查找引用）极其方便，告别XML的“魔法字符串”。</li>
<li><strong>灵活性极高</strong>：本质是Java代码，可以使用 <code>if/else</code>、<code>try/catch</code> 等逻辑动态控制Bean的创建。</li>
<li><strong>支持第三方库</strong>：这是<strong>核心优势</strong>。无法修改源码的第三方类（如 <code>DataSource</code>, <code>Gson</code>），必须通过 <code>@Bean</code> 手动组装。</li>
<li><strong>无侵入性</strong>：业务类不需要引入Spring注解，保持纯净。</li>
</ul>
<h5 id="2-缺点-2"><a href="#2-缺点-2" class="headerlink" title="2. 缺点"></a>2. 缺点</h5><ul>
<li><strong>代码繁琐</strong>：如果所有Bean都手写 <code>@Bean</code> 方法，代码量巨大，开发效率远低于“注解扫描”。</li>
<li><strong>修改需重新编译</strong>：配置写在代码里，改个参数必须重新编译打包（XML可以直接修改文件）。</li>
<li><strong>理解门槛</strong>：底层依赖CGLIB代理来保证单例，配置类内部的方法调用看似普通，实则被Spring拦截，新手容易混淆。</li>
</ul>
<hr>
<h2 id="3-ComponentScan的工作流程"><a href="#3-ComponentScan的工作流程" class="headerlink" title="3. @ComponentScan的工作流程"></a>3. <code>@ComponentScan</code>的工作流程</h2><h3 id="3-1-流程图"><a href="#3-1-流程图" class="headerlink" title="3.1 流程图"></a>3.1 流程图</h3><pre><code class="highlight mermaid">graph TD
    subgraph &quot; &quot;
        A[&quot;&lt;b&gt;第一步：触发扫描&lt;/b&gt;&lt;br/&gt;ApplicationContext初始化&lt;br/&gt;处理 @Configuration&quot;] --&gt; B;
        B[&quot;&lt;b&gt;第二步：确定扫描起点 &lt;br&gt;(Base Packages)&lt;/b&gt;&lt;br/&gt;&lt;i&gt;默认: @ComponentScan所在包&lt;br/&gt;显式: basePackages等&lt;/i&gt;&quot;] --&gt; C;
        C[&quot;&lt;b&gt;第三步：执行类路径扫描&lt;/b&gt;&lt;br/&gt;递归遍历包下的.class文件&lt;br/&gt;(使用ASM高效读取元数据)&quot;] --&gt; D;
        D&#123;&quot;&lt;b&gt;第四步：筛选候选组件&lt;/b&gt;&lt;br/&gt;类是否带有@Component等注解?&quot;&#125; -- 是 --&gt; E;
        D -- 否 --&gt; F[忽略此类, 继续扫描];
        E[&quot;&lt;b&gt;第五步:注册Bean定义&lt;/b&gt;&lt;br/&gt;为每个候选组件创建&lt;br&gt;BeanDefinition(蓝图)&lt;br/&gt;&lt;b&gt;注意：此时不创建实例&lt;/b&gt;&quot;] --&gt; G(BeanDefinitionRegistry&lt;br/&gt;注册并存储所有Bean定义);
    end
    %% --- 样式定义 ---
    style A fill:#f9f,stroke:#333,stroke-width:2px</code></pre>

<hr>
<h3 id="3-2-步骤详解"><a href="#3-2-步骤详解" class="headerlink" title="3.2 步骤详解"></a>3.2 步骤详解</h3><h4 id="3-2-1-触发扫描"><a href="#3-2-1-触发扫描" class="headerlink" title="3.2.1 触发扫描"></a>3.2.1 触发扫描</h4><ul>
<li>扫描是在<code>ApplicationContext</code>的初始化过程中被触发的。</li>
<li>当容器处理一个带有 <code>@Configuration</code> 注解的配置类时，**<code>ConfigurationClassPostProcessor</code>**调用 <code>ConfigurationClassParser</code> 解析配置类，当解析器遇到 <code>@ComponentScan</code> 注解时，会委托给 <code>ComponentScanAnnotationParser</code> 进行解析，最终创建并配置 <strong><code>ClassPathBeanDefinitionScanner</code></strong> 来执行真正的扫描动作。</li>
</ul>
<hr>
<h4 id="3-2-2-确定扫描起点"><a href="#3-2-2-确定扫描起点" class="headerlink" title="3.2.2 确定扫描起点"></a>3.2.2 确定扫描起点</h4><ul>
<li><code>@ComponentScan</code> 需要知道从哪里开始扫描。这个起始点被称为“基础包”（Base Packages）。</li>
<li><strong>默认行为</strong>：如果未指定包，Spring 内部是利用 <code>ClassUtils.getPackageName(declaringClass)</code> 来获取当前配置类的包名（即<strong>将类所在的包作为扫描的起点</strong>）。</li>
<li><strong>显式指定</strong>：你可以通过参数来精确控制扫描的范围：<ul>
<li><code>@ComponentScan(basePackages = &quot;com.example.anotherpackage&quot;)</code></li>
<li><code>@ComponentScan(basePackageClasses = SomeClass.class)</code> (更类型安全的方式，它会扫描<code>SomeClass</code>所在的包)</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-3-执行类路径扫描"><a href="#3-2-3-执行类路径扫描" class="headerlink" title="3.2.3 执行类路径扫描"></a>3.2.3 执行类路径扫描</h4><ul>
<li>确定了起点后，Spring的扫描器会开始工作。它会递归地遍历基础包及其所有子包下的<strong>类路径</strong>。</li>
<li>扫描器利用 <strong><code>ResourcePatternResolver</code></strong>（通常是 <code>PathMatchingResourcePatternResolver</code>）结合 <code>classpath*:</code> 前缀，将包路径转换为文件路径（例如 <code>classpath*:com/example/**/*.class</code>），从而获取所有的 <code>Resource</code> 对象。</li>
<li>这个过程并不是去读取<code>.java</code>源文件，而是去检查编译后的<code>.class</code>文件。</li>
<li>为了提高效率，Spring使用ASM的字节码操作库。具体的组件是 <strong><code>MetadataReaderFactory</code></strong> (通常是 <code>CachingMetadataReaderFactory</code>) 和 <strong><code>MetadataReader</code></strong>。它可以在不完全加载类到JVM的情况下，就能读取到类的元数据（比如类名、注解信息等），这比使用Java反射要快得多。</li>
</ul>
<hr>
<h4 id="3-2-4-筛选候选组件"><a href="#3-2-4-筛选候选组件" class="headerlink" title="3.2.4 筛选候选组件"></a>3.2.4 筛选候选组件</h4><ul>
<li>扫描器遍历读取到的 <code>.class</code> 元数据（Metadata），通过 <strong><code>TypeFilter</code></strong> 链条进行匹配。</li>
<li><strong>默认行为</strong>：使用 <code>AnnotationTypeFilter</code>，匹配所有标注了 <strong><code>@Component</code></strong> 及其<strong>衍生注解</strong>的类。</li>
<li><strong>排除与包含</strong>：检查 <code>@ComponentScan</code> 中配置的 <code>excludeFilters</code> 和 <code>includeFilters</code>。</li>
<li><strong>条件过滤</strong>：如果类上标注了 <strong><code>@Conditional</code></strong>，会在此阶段计算条件是否满足。若不满足，该类直接被丢弃，不会生成 BeanDefinition。</li>
<li><strong>类定义检查</strong>：候选类必须是<strong>独立类</strong>（Top-level class）或<strong>静态内部类</strong>，且通常要是<strong>具体类</strong>（非抽象、非接口）。</li>
</ul>
<hr>
<h4 id="3-2-5-注册Bean定义"><a href="#3-2-5-注册Bean定义" class="headerlink" title="3.2.5 注册Bean定义"></a>3.2.5 注册Bean定义</h4><ul>
<li>对于每一个筛选出来的候选组件，Spring并不会立即创建它的实例。</li>
<li>相反，它会为这个类创建一个**<code>BeanDefinition</code>**对象。此时创建的具体类型是 <strong><code>ScannedGenericBeanDefinition</code></strong></li>
<li>在注册之前，扫描器还会做三件大事：<ol>
<li><strong>Scope 解析</strong>：解析 <code>@Scope</code> 注解（单例还是多例），由 <code>ScopeMetadataResolver</code> 完成。</li>
<li><strong>BeanName 生成</strong>：生成 Bean 的 ID（通常是类名首字母小写），由 <code>BeanNameGenerator</code> 完成。</li>
<li><strong>默认值填充</strong>：处理 <code>@Lazy</code>, <code>@Primary</code>, <code>@DependsOn</code>, <code>@Description</code> 等通用注解，并将这些元数据填充到 BeanDefinition 中。</li>
</ol>
</li>
<li>然后，Spring将这个<code>BeanDefinition</code>注册到<code>BeanDefinitionRegistry</code>中。</li>
</ul>
<hr>
<h2 id="4-依赖注入"><a href="#4-依赖注入" class="headerlink" title="4. 依赖注入"></a>4. 依赖注入</h2><h3 id="4-1-Setter注入"><a href="#4-1-Setter注入" class="headerlink" title="4.1 Setter注入"></a>4.1 Setter注入</h3><h4 id="4-1-1-定义与核心场景"><a href="#4-1-1-定义与核心场景" class="headerlink" title="4.1.1 定义与核心场景"></a>4.1.1 定义与核心场景</h4><p>Setter注入是指 Spring 容器在实例化 Bean 之后，通过调用 Bean 的 <strong>Setter 方法</strong>（或任意名称的配置方法）来注入依赖项的方式。</p>
<ul>
<li><strong>核心特征</strong>：它将“对象的创建”与“依赖的注入”完全解耦。</li>
<li><strong>最佳适用场景</strong>：<strong>可选依赖 (Optional Dependencies)</strong>。即该依赖不是 Bean 正常工作所必须的，或者该依赖在默认情况下可以为空。</li>
</ul>
<hr>
<h4 id="4-1-2-工作原理"><a href="#4-1-2-工作原理" class="headerlink" title="4.1.2 工作原理"></a>4.1.2 工作原理</h4><p>Setter 注入发生在 Bean 生命周期的 <strong>属性填充阶段 (Populate Bean)</strong>。</p>
<ol>
<li><strong>阶段一：实例化 (Instantiation)</strong><ul>
<li>Spring 使用反射调用 Bean 的<strong>无参构造函数</strong>（或工厂方法）。</li>
<li><strong>状态</strong>：此时，对象已经在堆内存中产生，但它是一个“空壳”，所有字段（包括依赖项）都是 <code>null</code>。</li>
</ul>
</li>
<li><strong>阶段二：依赖解析与注入 (Population)</strong><ul>
<li>Spring 的后置处理器 <code>AutowiredAnnotationBeanPostProcessor</code> 扫描到类中带有 <code>@Autowired</code> 注解的 <strong>方法</strong>。</li>
<li>Spring 从容器中解析出参数对应的 Bean。</li>
<li>通过反射机制（<code>Method.invoke</code>），调用这个 Setter 方法，将解析出的 Bean 传入。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-1-3-代码示例"><a href="#4-1-3-代码示例" class="headerlink" title="4.1.3 代码示例"></a>4.1.3 代码示例</h4><p><strong>场景</strong>：<code>NotificationManager</code> 可以发送通知，但 <code>MessageService</code> 是可选的。如果不注入，就不发通知，但不影响程序启动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 必须提供无参构造函数（默认就有，但如果定义了有参构造需显式补上）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationManager</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1. NotificationManager 实例已创建 (依赖仍为 null)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将 @Autowired 放在 Setter 方法上</span></span><br><span class="line">    <span class="comment">// required = false 表示这是一个可选依赖，找不到 Bean 也不报错</span></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessageService</span><span class="params">(MessageService messageService)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2. 调用 Setter 方法注入 MessageService&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.messageService = messageService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendNotification</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 使用前必须进行判空，因为依赖可能不存在</span></span><br><span class="line">        <span class="keyword">if</span> (messageService != <span class="literal">null</span>) &#123;</span><br><span class="line">            messageService.sendMessage(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未配置消息服务，跳过发送。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-1-4-优缺点"><a href="#4-1-4-优缺点" class="headerlink" title="4.1.4 优缺点"></a>4.1.4 优缺点</h4><h5 id="1-优点-3"><a href="#1-优点-3" class="headerlink" title="1. 优点"></a>1. 优点</h5><ul>
<li><strong>支持可选依赖</strong>：配合 <code>@Autowired(required = false)</code>，可以优雅地处理非必须的组件。</li>
<li><strong>灵活性和可重配置性</strong>：对象创建后，理论上仍然可以通过调用setter方法来更换其依赖（虽然在单例Bean的生命周期中很少这样做）。</li>
<li><strong>解决部分循环依赖问题</strong></li>
</ul>
<hr>
<h5 id="2-缺点-3"><a href="#2-缺点-3" class="headerlink" title="2. 缺点"></a>2. 缺点</h5><ol>
<li><strong>空指针风险 (NPE)</strong>：<ul>
<li>对象被构造出来后，依赖可能还没注入（或者被设为 null）。如果在构造函数中或者在注入完成前调用了使用依赖的方法，会抛出 <code>NullPointerException</code>。</li>
</ul>
</li>
<li><strong>丧失不可变性 (Mutability)</strong>：<ul>
<li>为了提供 Setter 方法，字段不能声明为 <code>final</code>。这意味着在这个 Bean 的生命周期内，它的依赖可能会被修改（虽然极少这样做），这在多线程环境下可能带来隐患。</li>
</ul>
</li>
<li><strong>代码冗余</strong>：<ul>
<li>相比于字段注入，Setter 注入需要写大量的 <code>set</code> 方法，显得啰嗦（虽然可以用 Lombok 的 <code>@Setter(onMethod_=@Autowired)</code> 简化，但仍不直观）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-2-字段注入"><a href="#4-2-字段注入" class="headerlink" title="4.2 字段注入"></a>4.2 字段注入</h3><h4 id="4-2-1-定义"><a href="#4-2-1-定义" class="headerlink" title="4.2.1 定义"></a>4.2.1 定义</h4><p>字段注入是指直接在类的 <strong>成员变量（Field）</strong> 上标记 <code>@Autowired</code>（或 <code>@Resource</code>、<code>@Inject</code>）注解。Spring 容器会自动通过反射机制为这些字段赋值，无需编写任何 setter 方法或构造函数。</p>
<hr>
<h4 id="4-2-2-工作原理"><a href="#4-2-2-工作原理" class="headerlink" title="4.2.2 工作原理"></a>4.2.2 工作原理</h4><p>字段注入发生在 Bean 生命周期的 <strong>属性填充阶段 (Populate Bean)</strong>。</p>
<ol>
<li><strong>实例化 (Instantiation)</strong>：<ul>
<li>Spring 调用无参构造函数 <code>new NotificationManager()</code>。</li>
<li><strong>状态</strong>：此时对象已存在于堆内存，但 <code>@Autowired</code> 的字段全是 <code>null</code>。</li>
</ul>
</li>
<li><strong>后置处理 (Post-Processing)</strong>：<ul>
<li>Spring 的 <strong><code>AutowiredAnnotationBeanPostProcessor</code></strong>（这是处理 <code>@Autowired</code> 的核心组件）介入。</li>
<li>它通过反射扫描类中所有标记了注解的字段。</li>
</ul>
</li>
<li><strong>反射注入 (Reflection Set)</strong>：<ul>
<li>处理器调用 <code>field.setAccessible(true)</code> 绕过 Java 的 <code>private</code> 访问权限检查。</li>
<li>调用 <code>field.set(beanInstance, dependencyInstance)</code> 将依赖强行塞入字段。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-2-3-代码示例"><a href="#4-2-3-代码示例" class="headerlink" title="4.2.3 代码示例"></a>4.2.3 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Autowired直接放在字段上</span></span><br><span class="line">    <span class="comment">// Spring会通过反射直接为这个私有字段赋值</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只需要一个无参构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在构造函数执行时，messageService 绝对是 null!</span></span><br><span class="line">        System.out.println(<span class="string">&quot;NotificationManager constructor called. MessageService is: &quot;</span> + <span class="built_in">this</span>.messageService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendNotification</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 在Spring完成反射注入后，messageService才可用</span></span><br><span class="line">        <span class="keyword">if</span> (messageService == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 理论上在Spring管理的Bean中，这个分支不会被执行</span></span><br><span class="line">            System.err.println(<span class="string">&quot;Error: MessageService has not been injected!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        messageService.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-4-优缺点"><a href="#4-2-4-优缺点" class="headerlink" title="4.2.4 优缺点"></a>4.2.4 优缺点</h4><h5 id="1-优点-4"><a href="#1-优点-4" class="headerlink" title="1. 优点"></a>1. 优点</h5><ul>
<li><strong>极度简洁</strong>：没有构造函数模板代码，没有 Setter 方法。加个注解完事。</li>
<li><strong>偷懒神器</strong>：对于 demo 代码或只有一两个依赖的简单类，写起来确实快。</li>
<li><strong>解决循环依赖</strong></li>
</ul>
<hr>
<h5 id="2-缺点-4"><a href="#2-缺点-4" class="headerlink" title="2. 缺点"></a>2. 缺点</h5><ol>
<li><strong>NPE 风险与时序问题</strong><ul>
<li>在构造函数中无法使用依赖。如果你想在对象创建时做一些初始化逻辑（依赖于 <code>messageService</code>），你必须被迫使用 <code>@PostConstruct</code>，这又增加了对 Spring 生命周期的依赖。</li>
</ul>
</li>
<li><strong>无法实现不可变性 (Immutability)</strong><ul>
<li>字段注入要求字段必须是可变的（不能加 <code>final</code>）。</li>
<li>这意味着这个 Bean 在运行时可能被意外修改，且无法保证线程安全。</li>
</ul>
</li>
<li><strong>测试噩梦 (Testing Hell)</strong><ul>
<li>这是最直接的痛点。如果不启动 Spring 容器（即不使用重量级的 <code>@SpringBootTest</code>），你几乎无法对这个类进行单元测试。</li>
<li>你不能 <code>new NotificationManager()</code>，因为你没法给私有字段赋值。你被迫使用反射工具类（如 <code>ReflectionTestUtils</code>）来强行塞入 Mock 对象，代码非常丑陋。</li>
</ul>
</li>
<li><strong>掩盖设计异味 (Code Smell: SRP Violation)</strong><ul>
<li><strong>温水煮青蛙</strong>：因为加依赖太容易了（加一行注解而已），开发者容易在一个类里塞入 10 个、20 个依赖而不自知。</li>
<li>如果是构造器注入，当你写一个包含 15 个参数的构造函数时，你立刻就会意识到：“天哪，这个类做得太多了，违反了单一职责原则（SRP），需要重构！”。字段注入完美地掩盖了这个问题。</li>
</ul>
</li>
<li><strong>与容器强耦合</strong><ul>
<li>这个类脱离了 Spring 容器就是一个废品（字段永远是 null）。它不再是一个标准的 POJO。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-2-5-接受的场景"><a href="#4-2-5-接受的场景" class="headerlink" title="4.2.5 接受的场景"></a>4.2.5 接受的场景</h4><p>字段注入有一个被社区普遍接受的例外使用场景：<strong>在测试类中注入Mocks</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(MockitoExtension.class)</span> <span class="comment">// 启用Mockito扩展</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotificationManagerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span> <span class="comment">// 创建一个MessageService的模拟对象</span></span><br><span class="line">    <span class="keyword">private</span> MessageService mockMessageService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InjectMocks</span> <span class="comment">// 创建NotificationManager实例，并将上面@Mock标记的对象注入进去</span></span><br><span class="line">    <span class="keyword">private</span> NotificationManager notificationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSendNotification</span><span class="params">()</span> &#123;</span><br><span class="line">        notificationManager.sendNotification(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="comment">// ... 验证 mockMessageService 的行为 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，使用字段注入是为了减少测试代码的样板代码，是可以接受的，因为测试类本身不是应用程序的组件。</p>
<hr>
<h3 id="4-3-构造器注入"><a href="#4-3-构造器注入" class="headerlink" title="4.3 构造器注入"></a>4.3 构造器注入</h3><h4 id="4-3-1-定义与本质"><a href="#4-3-1-定义与本质" class="headerlink" title="4.3.1 定义与本质"></a>4.3.1 定义与本质</h4><p>构造器注入是指 Spring 容器在 <strong>实例化 Bean (Instantiation)</strong> 的同时，将依赖项作为参数传递给构造函数。</p>
<ul>
<li><strong>本质区别</strong>：与 Setter&#x2F;字段注入不同，构造器注入不区分“实例化”和“注入”两个阶段。<strong>实例化即注入</strong>。对象诞生的那一刻，就是它完整的时刻。</li>
</ul>
<hr>
<h4 id="4-3-2-工作原理"><a href="#4-3-2-工作原理" class="headerlink" title="4.3.2 工作原理"></a>4.3.2 工作原理</h4><p>这个过程发生在 <code>AbstractAutowireCapableBeanFactory.createBeanInstance</code> 方法中，核心由 <strong><code>ConstructorResolver</code></strong> 委托处理。</p>
<ol>
<li><strong>构造器推断 (Candidate Resolution)</strong>：<br>Spring 需要决定调用哪个构造函数。<ul>
<li><strong>场景 A（推荐）：单构造函数</strong>。<ul>
<li>Spring 4.3+ 优化：如果类中<strong>只有一个</strong>构造函数，Spring 会直接使用它，<strong>不需要</strong> <code>@Autowired</code> 注解。</li>
</ul>
</li>
<li><strong>场景 B：多构造函数</strong>。<ul>
<li>Spring 会寻找被 <code>@Autowired</code> 标记的构造函数。</li>
<li>如果没有标记，Spring 默认寻找<strong>无参构造函数</strong>。如果连无参构造都没有，且有多个有参构造，Spring 将抛出异常（因为它不知道该选哪个）。</li>
</ul>
</li>
<li><strong>底层细节</strong>：<code>SmartInstantiationAwareBeanPostProcessor</code> 会介入探测构造函数候选者（Candidates）。</li>
</ul>
</li>
<li><strong>依赖解析 (Dependency Resolution)</strong>：<ul>
<li>Spring 解析构造函数的参数类型（如 <code>MessageService.class</code>）。</li>
<li>Spring 到单例池（或其他 Scope 缓存）中查找匹配的 Bean。</li>
</ul>
</li>
<li><strong>对象创建 (Object Creation)</strong>：<ul>
<li>Spring 使用反射 (<code>Constructor.newInstance</code>) 或 CGLIB (<code>CglibSubclassingInstantiationStrategy</code>) 调用选定的构造函数，传入解析好的依赖对象。</li>
<li><strong>内存分配</strong>：此时，堆内存中分配了对象的空间，且 <code>final</code> 字段被初始化。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-3-3-代码示例"><a href="#4-3-3-代码示例" class="headerlink" title="4.3.3 代码示例"></a>4.3.3 代码示例</h4><p>我们结合 <strong>Lombok</strong> 来展示现代 Spring 开发中最优雅的写法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span> <span class="comment">// 1. Lombok 神器：自动生成包含所有 final 字段的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 声明为 final：保证不可变性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageService messageService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    Lombok 会在编译时自动生成如下代码，无需手写：</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public NotificationManager(MessageService messageService, UserService userService) &#123;</span></span><br><span class="line"><span class="comment">        this.messageService = messageService;</span></span><br><span class="line"><span class="comment">        this.userService = userService;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendNotification</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 安全调用：绝无 NPE 风险</span></span><br><span class="line">        messageService.send(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-4-优缺点"><a href="#4-3-4-优缺点" class="headerlink" title="4.3.4 优缺点"></a>4.3.4 优缺点</h4><h5 id="1-优点-5"><a href="#1-优点-5" class="headerlink" title="1. 优点"></a>1. 优点</h5><p>为什么 Spring 官方团队（包括 Juergen Hoeller 本人）强力推荐构造器注入？</p>
<ol>
<li><strong>保证“快速失败” (Fail-Fast)</strong><ul>
<li><strong>原理</strong>：如果依赖缺失（比如找不到 <code>MessageService</code> Bean），Spring 在<strong>启动阶段</strong>创建 Bean 时就会直接抛出异常（<code>UnsatisfiedDependencyException</code>），阻止应用启动。</li>
<li><strong>对比</strong>：Setter&#x2F;字段注入可能允许应用启动，直到运行时调用特定方法才抛出 NPE，造成线上故障。</li>
</ul>
</li>
<li><strong>不可变性与线程安全 (Immutability &amp; Thread Safety)</strong><ul>
<li><strong>JMM 视角</strong>：将字段声明为 <code>final</code> 并通过构造器初始化，利用了 Java 内存模型的 <strong>Final 域重排序规则</strong>。</li>
<li><strong>效果</strong>：它保证了当其他线程看到这个对象时，它的 <code>final</code> 字段一定是初始化好的。这天然地解决了多线程环境下的可见性问题。</li>
</ul>
</li>
<li><strong>完全的 POJO (Pure Old Java Object)</strong><ul>
<li>这个类不依赖 <code>@Autowired</code>，不依赖 Spring 的任何类库（注解除外）。</li>
<li><strong>单元测试优势</strong>：你可以直接 <code>new NotificationManager(new MockMessageService())</code>，无需启动笨重的 Spring 容器上下文。</li>
</ul>
</li>
<li><strong>强制的依赖契约</strong><ul>
<li>构造函数签名就是契约。它大声地告诉使用者：“想用我？必须给我这几个资源，少一个都不行！”</li>
</ul>
</li>
</ol>
<hr>
<h5 id="2-唯一的“缺点”：无法解决循环依赖"><a href="#2-唯一的“缺点”：无法解决循环依赖" class="headerlink" title="2. 唯一的“缺点”：无法解决循环依赖"></a>2. 唯一的“缺点”：无法解决循环依赖</h5><p><strong>但这通常被认为是一个优点</strong>！它在应用启动的早期就暴露了代码设计的坏味道（Bad Smell）。循环依赖通常意味着类的职责划分不清晰，应该通过重构来解决，而不是绕过它。</p>
<hr>
<h3 id="4-4-Autowired-Resource-Inject-的区别"><a href="#4-4-Autowired-Resource-Inject-的区别" class="headerlink" title="4.4 @Autowired, @Resource, @Inject 的区别"></a>4.4 <code>@Autowired</code>, <code>@Resource</code>, <code>@Inject</code> 的区别</h3><h4 id="4-4-1-Autowired"><a href="#4-4-1-Autowired" class="headerlink" title="4.4.1 @Autowired"></a>4.4.1 <code>@Autowired</code></h4><ul>
<li><strong>来源</strong>: <strong>Spring框架</strong> 自带的注解。它是Spring IoC中使用最广泛的注解。</li>
<li><strong>注入规则 (匹配策略)</strong>: <strong>默认按类型（byType）注入</strong>。<ol>
<li>首先，Spring容器会寻找一个与注入点类型完全匹配的Bean。</li>
<li>如果找到了<strong>唯一一个</strong>匹配的Bean，就直接注入。</li>
<li>如果找到了<strong>多个</strong>匹配的Bean，Spring会陷入困惑。此时，它会尝试将<strong>变量名</strong>（或字段名）作为Bean的ID（或name）进行二次匹配。如果有一个Bean的ID与变量名匹配，就注入那个。</li>
<li>如果二次匹配也失败了（比如没有Bean的ID匹配变量名），Spring就会抛出<code>NoUniqueBeanDefinitionException</code>异常。</li>
<li>为了解决上述的歧义性，<code>@Autowired</code> 通常与 <code>@Qualifier(&quot;beanName&quot;)</code> 注解配合使用，来明确指定要注入哪一个Bean。</li>
</ol>
</li>
<li><strong>关键属性</strong>:<ul>
<li><code>required = false</code>：允许注入的Bean不存在。如果设置为 <code>false</code> 且找不到匹配的Bean，Spring会注入 <code>null</code> 而不是抛出异常。</li>
</ul>
</li>
<li><strong>适用位置</strong>: 构造器、字段、Setter方法、以及任何自定义方法。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认按类型查找 MessageService</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当有多个 MessageService 实现时，使用 @Qualifier 指定</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;smsService&quot;)</span> <span class="comment">// 明确指定注入ID为 &quot;smsService&quot; 的Bean</span></span><br><span class="line">    <span class="keyword">private</span> MessageService specificMessageService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-4-2-Resource"><a href="#4-4-2-Resource" class="headerlink" title="4.4.2 @Resource"></a>4.4.2 <code>@Resource</code></h4><ul>
<li><p><strong>来源</strong>: <strong>Java EE 的 JSR-250 规范</strong>。它不属于Spring，而是Java的标准注解。Spring框架支持这个注解。</p>
</li>
<li><p><strong>注入规则 (匹配策略)</strong>: <strong>默认按名称（byName）注入</strong>。</p>
<ol>
<li>首先，它会寻找与**<code>name</code>属性**指定的名称匹配的Bean。</li>
<li>如果没有指定<code>name</code>属性，它会使用<strong>字段名或setter方法名</strong>（去掉<code>set</code>前缀并首字母小写）作为Bean的名称去查找。</li>
<li>如果按名称找不到匹配的Bean，它会<strong>回退（fallback）到按类型（byType）查找</strong>。</li>
<li>如果按类型查找到多个，它会抛出<code>NoUniqueBeanDefinitionException</code>。</li>
</ol>
</li>
<li><p><strong>关键属性</strong>:</p>
<ul>
<li><code>name = &quot;beanName&quot;</code>：直接指定要注入的Bean的名称。</li>
</ul>
</li>
<li><p><strong>适用位置</strong>: 字段、Setter方法。</p>
</li>
<li><p><strong>注意事项</strong>: 从 Java 9 开始，JSR-250 相关的库（<code>javax.annotation-api</code>）被标记为废弃，并在 Java 11 中被移除。如果你在现代的Java版本（9+）中使用 <code>@Resource</code>，你需要手动在 <code>pom.xml</code> 中添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 按名称 &quot;smsService&quot; 查找</span></span><br><span class="line">    <span class="meta">@Resource(name = &quot;smsService&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 未指定name，则按字段名 &quot;emailService&quot; 查找</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MessageService emailService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-4-3-Inject"><a href="#4-4-3-Inject" class="headerlink" title="4.4.3 @Inject"></a>4.4.3 <code>@Inject</code></h4><ul>
<li><p><strong>来源</strong>: <strong>Java 的 JSR-330 规范</strong> (CDI - Contexts and Dependency Injection)。它也是一个Java标准，旨在为所有框架提供统一的依赖注入API。</p>
</li>
<li><p><strong>注入规则 (匹配策略)</strong>: <strong>默认按类型（byType）注入</strong>。它的行为几乎和 <code>@Autowired</code> 完全一样。</p>
<ol>
<li>首先按类型查找。</li>
<li>如果找到多个，它需要配合 JSR-330 的 <code>@Named</code> 注解来指定名称，功能类似于Spring的 <code>@Qualifier</code>。</li>
</ol>
</li>
<li><p><strong>关键属性</strong>:</p>
<ul>
<li>它没有 <code>required</code> 属性。如果你想实现可选注入，需要使用Java 8的 <code>Optional&lt;T&gt;</code>。例如 <code>private Optional&lt;MessageService&gt; messageService;</code>。</li>
</ul>
</li>
<li><p><strong>适用位置</strong>: 构造器、字段、方法。</p>
</li>
<li><p><strong>注意事项</strong>: 要使用 <code>@Inject</code>，你需要添加 <code>javax.inject</code> 的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认按类型查找</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当有多个实现时，使用 @Named 指定</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="meta">@Named(&quot;smsService&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MessageService specificMessageService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-4-4-总结与核心区别"><a href="#4-4-4-总结与核心区别" class="headerlink" title="4.4.4 总结与核心区别"></a>4.4.4 总结与核心区别</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>@Autowired</code> (Spring)</th>
<th align="left"><code>@Resource</code> (JSR-250 &#x2F; Java EE)</th>
<th align="left"><code>@Inject</code> (JSR-330 &#x2F; CDI)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>来源</strong></td>
<td align="left">Spring 框架</td>
<td align="left">Java EE 规范</td>
<td align="left">Java CDI 规范</td>
</tr>
<tr>
<td align="left"><strong>默认匹配策略</strong></td>
<td align="left"><strong>按类型 (byType)</strong></td>
<td align="left"><strong>按名称 (byName)</strong></td>
<td align="left"><strong>按类型 (byType)</strong></td>
</tr>
<tr>
<td align="left"><strong>按名称注入方式</strong></td>
<td align="left"><code>@Qualifier(&quot;beanName&quot;)</code></td>
<td align="left"><code>name=&quot;beanName&quot;</code> 或 默认使用字段名</td>
<td align="left"><code>@Named(&quot;beanName&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong>处理可选依赖</strong></td>
<td align="left"><code>required = false</code></td>
<td align="left">不直接支持</td>
<td align="left">使用 <code>Optional&lt;T&gt;</code></td>
</tr>
<tr>
<td align="left"><strong>兼容性</strong></td>
<td align="left">仅 Spring 环境</td>
<td align="left">Spring 及其他 Java EE 容器</td>
<td align="left">Spring 及其他支持CDI的容器</td>
</tr>
<tr>
<td align="left"><strong>依赖</strong></td>
<td align="left">无需额外依赖 (Spring项目自带)</td>
<td align="left"><strong>需要 <code>jakarta.annotation-api</code> (Java 9+)</strong></td>
<td align="left"><strong>需要 <code>javax.inject</code></strong></td>
</tr>
</tbody></table>
<hr>
<h4 id="4-4-5-SpringBoot中的最佳实践和选择"><a href="#4-4-5-SpringBoot中的最佳实践和选择" class="headerlink" title="4.4.5 SpringBoot中的最佳实践和选择"></a>4.4.5 SpringBoot中的最佳实践和选择</h4><ol>
<li><strong>首选 <code>@Autowired</code></strong>：<br>在纯粹的Spring或SpringBoot项目中，<strong>始终优先使用 <code>@Autowired</code></strong>。因为：<ul>
<li>它是Spring的原生注解，与Spring生态（如 <code>@Qualifier</code>, <code>@Primary</code>, Spring Test等）的集成最好、功能最强大。</li>
<li>配合构造器注入，可以创建不可变对象，是目前公认的最佳实践。</li>
</ul>
</li>
<li><strong>什么时候考虑 <code>@Resource</code></strong>？<ul>
<li>当你非常明确地<strong>想通过Bean的名称来进行注入</strong>时，<code>@Resource</code> 的意图比 <code>@Autowired</code> + <code>@Qualifier</code> 更直接。</li>
<li>在一些需要同时兼容其他Java EE容器的老项目中，使用 <code>@Resource</code> 可以提供更好的移植性。但要注意新Java版本的依赖问题。</li>
</ul>
</li>
<li><strong>什么时候考虑 <code>@Inject</code></strong>？<ul>
<li>在现代SpringBoot项目中，几乎没有理由选择 <code>@Inject</code>。它的功能被 <code>@Autowired</code> 完全覆盖且更弱（没有 <code>required</code> 属性）。</li>
<li>它的设计初衷是编写可以脱离特定框架（如Spring, Guice）的、具有可移植性的库或组件。如果你在开发这样一个通用库，使用 <code>@Inject</code> 是一个不错的选择。但在开发应用程序时，坚持使用框架提供的原生工具通常更好。</li>
</ul>
</li>
</ol>
<p><strong>结论：</strong> 在实际的SpringBoot Web后端开发中，<strong>坚持使用 <code>@Autowired</code> 并配合构造器注入</strong>，这是最现代、最安全、最符合Spring设计理念的方式。</p>
<hr>
<h3 id="4-5-解决注入歧义"><a href="#4-5-解决注入歧义" class="headerlink" title="4.5 解决注入歧义"></a>4.5 解决注入歧义</h3><h4 id="4-5-1-什么是注入歧义？"><a href="#4-5-1-什么是注入歧义？" class="headerlink" title="4.5.1 什么是注入歧义？"></a>4.5.1 什么是注入歧义？</h4><p>假设我们有一个 <code>MessageService</code> 接口，以及两个不同的实现：一个通过邮件发送，一个通过短信发送。</p>
<p><strong>接口定义:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String recipient, String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两个实现:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;emailService&quot;)</span> <span class="comment">// 默认Bean name是 &quot;emailService&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String recipient, String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending EMAIL to &quot;</span> + recipient + <span class="string">&quot;: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(&quot;smsService&quot;)</span> <span class="comment">// 默认Bean name是 &quot;smsService&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String recipient, String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending SMS to &quot;</span> + recipient + <span class="string">&quot;: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，有一个 <code>NotificationManager</code> 需要使用 <code>MessageService</code>。如果我们像下面这样写，问题就出现了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题点!</span></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// Spring: &quot;我找到了两个 MessageService (EmailService 和 SmsService)，我该用哪个?!&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationManager</span><span class="params">(MessageService messageService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messageService = messageService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Spring应用启动时，它会尝试为 <code>NotificationManager</code> 的构造函数注入一个 <code>MessageService</code>。但容器里有两个符合条件的Bean，Spring无法做出决定，于是会抛出 <code>NoUniqueBeanDefinitionException</code> 异常，导致应用启动失败。</p>
<p>下面我们来看两种解决这个问题的方案。</p>
<hr>
<h4 id="4-5-2-Primary-指定“首选”Bean"><a href="#4-5-2-Primary-指定“首选”Bean" class="headerlink" title="4.5.2 @Primary - 指定“首选”Bean"></a>4.5.2 <code>@Primary</code> - 指定“首选”Bean</h4><p><code>@Primary</code> 注解的作用是告诉Spring：“当出现多个相同类型的候选Bean时，请<strong>优先选择</strong>被 <code>@Primary</code> 标记的这一个。”</p>
<ul>
<li><strong>特点</strong>: 这是一种<strong>提供方驱动</strong>的策略。Bean的定义者（提供方）决定了谁是默认选项。</li>
</ul>
<p><strong>如何使用:</strong></p>
<p>我们只需要在首选的实现类上添加 <code>@Primary</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;emailService&quot;)</span></span><br><span class="line"><span class="meta">@Primary</span> <span class="comment">// &lt;-- 在这里添加注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(&quot;smsService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，当 <code>NotificationManager</code> 请求注入 <code>MessageService</code> 时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationManager</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// Spring: &quot;哦，有两个选择，但EmailService被标记为@Primary，就用它了！&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationManager</span><span class="params">(MessageService messageService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messageService = messageService; <span class="comment">// 这里注入的将是 EmailService 的实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用可以正常启动，并且 <code>NotificationManager</code> 会默认使用 <code>EmailService</code>。</p>
<p><strong>适用场景</strong>:</p>
<p>当你有一个主要的、最常用的或默认的实现时，<code>@Primary</code> 是一个绝佳的选择。例如，系统中可能有多种支付方式，但“支付宝支付”是默认的首选方式。</p>
<hr>
<h4 id="4-5-3-Qualifier-指定“限定”Bean"><a href="#4-5-3-Qualifier-指定“限定”Bean" class="headerlink" title="4.5.3 @Qualifier - 指定“限定”Bean"></a>4.5.3 <code>@Qualifier</code> - 指定“限定”Bean</h4><p><code>@Qualifier</code> 注解的作用是告诉Spring：“我不要默认的，我<strong>明确地需要</strong>名为 <code>xxx</code> 的那一个Bean。”</p>
<ul>
<li><strong>特点</strong>: 这是一种<strong>消费方驱动</strong>的策略。依赖的注入点（消费方）明确指定它需要哪个具体的实现。</li>
</ul>
<p><strong>如何使用:</strong></p>
<p>在使用 <code>@Autowired</code> 的地方，同时使用 <code>@Qualifier</code> 注解，并传入你想要的Bean的名称（Bean Name）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个实现保持原样，不需要修改</span></span><br><span class="line"><span class="meta">@Service(&quot;emailService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(&quot;smsService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>现在，假设我们有两个不同的通知管理器，一个用于常规通知（用邮件），一个用于紧急通知（用短信）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegularNotificationManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 明确要求注入名为 &quot;emailService&quot; 的Bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RegularNotificationManager</span><span class="params">(<span class="meta">@Qualifier(&quot;emailService&quot;)</span> MessageService messageService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messageService = messageService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UrgentNotificationManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 明确要求注入名为 &quot;smsService&quot; 的Bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UrgentNotificationManager</span><span class="params">(<span class="meta">@Qualifier(&quot;smsService&quot;)</span> MessageService messageService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messageService = messageService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，每个消费者都可以根据自己的需求，精确地选择想要的实现，完全不受默认设置的影响。</p>
<p><strong>适用场景</strong>:</p>
<p>当选择哪个实现本身就是一种业务逻辑，不同的消费者需要不同的实现时，<code>@Qualifier</code> 是唯一的正确选择。它提供了更高的灵活性和精确性。</p>
<hr>
<h4 id="4-5-4-总结与最佳实践"><a href="#4-5-4-总结与最佳实践" class="headerlink" title="4.5.4 总结与最佳实践"></a>4.5.4 总结与最佳实践</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>@Primary</code></th>
<th align="left"><code>@Qualifier</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>决定方</strong></td>
<td align="left"><strong>Bean的提供者 (Provider-side)</strong></td>
<td align="left"><strong>Bean的消费者 (Consumer-side)</strong></td>
</tr>
<tr>
<td align="left"><strong>作用</strong></td>
<td align="left">设置一个全局的<strong>默认</strong>选项</td>
<td align="left">在注入点进行<strong>精确</strong>的选择</td>
</tr>
<tr>
<td align="left"><strong>灵活性</strong></td>
<td align="left">较低（一个类型只能有一个<code>@Primary</code>）</td>
<td align="left"><strong>非常高</strong>（每个注入点都可以独立选择）</td>
</tr>
<tr>
<td align="left"><strong>代码位置</strong></td>
<td align="left">标记在Bean的实现类上</td>
<td align="left">标记在注入点 (<code>@Autowired</code>旁边)</td>
</tr>
</tbody></table>
<p><strong>黄金法则：<code>@Qualifier</code> 的优先级高于 <code>@Primary</code>。</strong></p>
<p>这意味着，即使 <code>EmailService</code> 被标记为 <code>@Primary</code>，如果一个消费者使用 <code>@Qualifier(&quot;smsService&quot;)</code>，它仍然会得到 <code>SmsService</code>。<strong>精确指定永远胜过默认设置。</strong></p>
<p><strong>最佳实践建议：</strong></p>
<ol>
<li><strong>问自己一个问题</strong>：“在我的系统中，这个接口的实现是否有一个‘标准’或‘最常用’的版本？”<ul>
<li><strong>如果答案是肯定的</strong>，那么给那个实现加上 <code>@Primary</code>。这可以让80%的普通用例保持代码简洁，无需任何额外注解。</li>
<li><strong>如果答案是否定的</strong>，或者所有实现都同等重要，那么<strong>不要使用 <code>@Primary</code></strong>。强制每个消费者都使用 <code>@Qualifier</code> 来明确做出选择，这样可以避免错误的默认行为。</li>
</ul>
</li>
<li><strong>组合使用</strong>：将两者结合是最佳实践。<ul>
<li>为最常见的实现设置 <code>@Primary</code>。</li>
<li>对于那些需要特定非默认实现的特殊消费者，使用 <code>@Qualifier</code> 进行覆盖。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="5-Bean的生命周期与作用域"><a href="#5-Bean的生命周期与作用域" class="headerlink" title="5. Bean的生命周期与作用域"></a>5. Bean的生命周期与作用域</h2><h3 id="5-1-Bean的生命周期"><a href="#5-1-Bean的生命周期" class="headerlink" title="5.1 Bean的生命周期"></a>5.1 Bean的生命周期</h3><h4 id="5-1-1-流程图"><a href="#5-1-1-流程图" class="headerlink" title="5.1.1 流程图"></a>5.1.1 流程图</h4><pre><code class="highlight mermaid">graph TD
    %% --- 流程起点 ---
    A&#123;&quot;&lt;b&gt;1. 容器启动&lt;/b&gt;&lt;br/&gt;寻找Bean的定义信息&lt;br/&gt;(BeanDefinition)&quot;&#125; --&gt; B

    %% --- 创建阶段 ---
    subgraph &quot;Bean创建阶段&quot;
        direction TB
        B[&quot;&lt;b&gt;2. 【实例化】&lt;/b&gt;&lt;br/&gt;通过反射创建Bean的原始实例&lt;br/&gt;&lt;i&gt;(一个&#x27;裸&#x27;对象)&lt;/i&gt;&quot;] --&gt; C
        C[&quot;&lt;b&gt;3. 【属性填充】&lt;/b&gt;&lt;br/&gt;为Bean实例注入依赖 (DI)&lt;br/&gt;&lt;i&gt;如 @Autowired 标记的属性&lt;/i&gt;&quot;] --&gt; D
        
        D[&quot;&lt;b&gt;4. 【初始化】&lt;/b&gt;&lt;br/&gt;(执行一系列回调)&quot;]--&gt; D_sub
        
        subgraph D_sub[&quot;初始化子流程&quot;]
            direction TB
            D1[&quot;4.1 执行Aware接口的方法&lt;br/&gt;&lt;i&gt;(如BeanNameAware)&lt;/i&gt;&quot;]
            D2[&quot;4.2 执行BeanPostProcessor&lt;br/&gt;&lt;b&gt;前置&lt;/b&gt;处理方法&quot;]
            D3[&quot;4.3 执行Bean自身的初始化方法&lt;br/&gt;&lt;i&gt;(@PostConstruct, afterPropertiesSet)&lt;/i&gt;&quot;]
            D4[&quot;4.4 执行BeanPostProcessor&lt;br/&gt;&lt;b&gt;后置&lt;/b&gt;处理方法 (AOP代理在此发生)&quot;]
            
            D1 --&gt; D2 --&gt; D3 --&gt; D4
        end
        D_sub --&gt; E
    end

    %% --- 使用阶段 ---
    E(&lt;b&gt;5. Bean可用&lt;/b&gt;&lt;br/&gt;驻留在单例池中&lt;br/&gt;响应应用程序的调用) --&gt; F

    %% --- 销毁阶段 ---
    F&#123;&lt;b&gt;6. Spring容器关闭&lt;/b&gt;&#125; --&gt; G
    
    subgraph &quot;Bean销毁阶段 (Destruction Phase)&quot;
        direction TB
        G[&quot;&lt;b&gt;7. 【销毁】&lt;/b&gt;&lt;br/&gt;执行Bean的销毁回调方法&lt;br/&gt;&lt;i&gt;(如@PreDestroy, destroy-method)&lt;/i&gt;&quot;] --&gt; H
        H[&quot;&lt;b&gt;8. Bean被垃圾回收&lt;/b&gt;&lt;br/&gt;(由JVM管理)&quot;]
    end

    %% --- 样式定义 ---
    style A fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style F fill:#ffcdd2,stroke:#c62828,stroke-width:2px
    style B fill:#e3f2fd,stroke:#1565c0
    style C fill:#e3f2fd,stroke:#1565c0
    style D fill:#e3f2fd,stroke:#1565c0
    style E fill:#a5d6a7,stroke:#2e7d32,stroke-width:4px,stroke-dasharray: 5 5
    style G fill:#ffe0b2,stroke:#ef6c00
    style H fill:#ffe0b2,stroke:#ef6c00</code></pre>

<hr>
<h4 id="5-1-2-步骤详解"><a href="#5-1-2-步骤详解" class="headerlink" title="5.1.2 步骤详解"></a>5.1.2 步骤详解</h4><h5 id="阶段零：元数据加载与合并"><a href="#阶段零：元数据加载与合并" class="headerlink" title="阶段零：元数据加载与合并"></a>阶段零：元数据加载与合并</h5><p>在实例化之前，Spring 必须先“看懂”你要造什么对象。</p>
<ol>
<li><strong>BeanDefinition 查找</strong>：Spring 启动时，<code>BeanDefinitionRegistry</code> 中已经注册了 <code>MyBean</code> 的 <code>GenericBeanDefinition</code>（原始定义）。</li>
<li><strong>BeanDefinition 合并 (Merging)</strong>：<ul>
<li>Spring 不会直接使用原始定义，因为存在父子 Bean 继承的情况（XML常用，注解较少）。Spring 会将原始定义转换为 <strong><code>RootBeanDefinition</code></strong>。</li>
<li><strong>底层细节</strong>：如果 <code>MyBean</code> 有父 Bean，会覆盖父配置；如果没有，直接转换。后续流程操作的都是 <code>RootBeanDefinition</code>。</li>
</ul>
</li>
<li><strong>类加载</strong>：Spring 确保 <code>MyBean</code> 的 <code>Class</code> 对象已经被 JVM 加载。</li>
</ol>
<hr>
<h5 id="阶段一：实例化"><a href="#阶段一：实例化" class="headerlink" title="阶段一：实例化"></a>阶段一：实例化</h5><p>这是 <code>createBeanInstance()</code> 方法执行的阶段。</p>
<ol>
<li><strong>实例化前置处理</strong>：<ul>
<li>调用 <code>InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation</code>。这给了一个机会让用户返回一个代理对象直接替换掉原生的 Bean（通常用于特殊的中间件逻辑，很少用）。</li>
</ul>
</li>
<li><strong>推断构造方法 (Constructor Resolution)</strong>：<ul>
<li>Spring 需要决定用哪个构造器。</li>
<li><strong>底层细节</strong>：<code>SmartInstantiationAwareBeanPostProcessor</code> 会介入，检查是否有 <code>@Autowired</code> 标记的构造器。如果只有一个有参构造器，默认使用它；否则默认找无参构造器。</li>
</ul>
</li>
<li><strong>反射创建对象</strong>：<ul>
<li>通过 <code>CglibSubclassingInstantiationStrategy</code> 或反射，调用选定的构造器，在堆内存中开辟空间，生成<strong>原始对象包装器 (<code>BeanWrapper</code>)</strong>。</li>
<li><strong>此时</strong>：<code>MyBean</code> 仅仅是一个空壳，属性全为默认值。</li>
</ul>
</li>
<li><strong>【关键】解决循环依赖 (Early Reference)</strong>：<ul>
<li>如果 <code>MyBean</code> 是单例 (Singleton) 且允许循环依赖，Spring 会<strong>立刻</strong>将一个“ObjectFactory”放入 <strong>三级缓存 (<code>singletonFactories</code>)</strong> 中。</li>
<li><strong>底层细节</strong>：这个 <code>ObjectFactory</code> 里的逻辑是 <code>getEarlyBeanReference()</code>。如果后续发生循环依赖（例如 A 依赖 B，B 又依赖 A），A 会在这里提前生成代理对象（如果是 AOP bean），从而打破死锁。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="阶段二：属性填充-Population"><a href="#阶段二：属性填充-Population" class="headerlink" title="阶段二：属性填充 (Population)"></a>阶段二：属性填充 (Population)</h5><p>这是 <code>populateBean()</code> 方法执行的阶段。</p>
<ol>
<li><strong>实例化后置处理</strong>：<ul>
<li>调用 <code>InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation</code>。如果返回 <code>false</code>，则后续属性填充和初始化都会被跳过（这是一种中断机制）。</li>
</ul>
</li>
<li><strong>获取属性值</strong>：<ul>
<li>调用 <code>InstantiationAwareBeanPostProcessor.postProcessProperties</code>。</li>
<li><strong>底层细节</strong>：这是 <strong><code>AutowiredAnnotationBeanPostProcessor</code></strong> 工作的地方。它会解析 <code>@Autowired</code>、<code>@Value</code>、<code>@Inject</code>，利用反射直接修改字段的值（Field Injection）或调用 Setter 方法。</li>
<li>注意：这里是先处理注解注入，再处理 XML 定义的 <code>p-namespace</code> 属性注入。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="阶段三：初始化-Initialization"><a href="#阶段三：初始化-Initialization" class="headerlink" title="阶段三：初始化 (Initialization)"></a>阶段三：初始化 (Initialization)</h5><p>这是 <code>initializeBean()</code> 方法执行的阶段，也是 AOP 代理通常生成的时机。</p>
<ol>
<li><p><strong>执行 Aware 接口 (Aware Methods)</strong>：</p>
<p>如果<code>MyBean</code>实现了特定的<code>Aware</code>接口，Spring会调用它们。这些接口的目的是让Bean能“感知”到并获取到容器自身的资源。</p>
<ul>
<li><code>BeanNameAware</code> -&gt; <code>setBeanName()</code>: Bean可以获取到它在容器中的ID&#x2F;name。</li>
<li><code>BeanClassLoaderAware</code> -&gt; <code>setBeanClassLoader()</code>: Bean可以获取到加载它的类加载器。</li>
<li><code>BeanFactoryAware</code> -&gt; <code>setBeanFactory()</code>: <strong>最强大的<code>Aware</code>接口</strong>，Bean可以获取到创建它的<code>BeanFactory</code>，从而能够以编程方式与容器交互。</li>
<li><strong>注意</strong>：这些接口的调用是直接在代码里写死的（<code>instanceof</code> 判断），不依赖后置处理器。</li>
</ul>
</li>
<li><p><strong>初始化前置处理 (<code>BeanPostProcessor.postProcessBeforeInitialization</code>)</strong>：</p>
<ul>
<li>遍历容器中所有的 BPP。</li>
<li>这是一个<strong>全局的</strong>、<strong>容器级别</strong>的钩子。它允许你在<strong>任何Bean</strong>的自定义初始化方法执行<strong>之前</strong>，对这个Bean实例进行修改或包装。</li>
<li><strong>重要细节</strong>：<ul>
<li><strong><code>ApplicationContextAwareProcessor</code></strong>：在这里执行，帮 Bean 注入 <code>ApplicationContext</code>、<code>Environment</code> 等高级容器资源。</li>
<li><strong><code>InitDestroyAnnotationBeanPostProcessor</code></strong> (或 <code>CommonAnnotation...</code>)：在这里解析并执行 <strong><code>@PostConstruct</code></strong> 标记的方法。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>执行初始化方法 (Invoke Init Methods)</strong>：</p>
<ul>
<li>先检查 <code>InitializingBean.afterPropertiesSet()</code>。</li>
<li>再检查 XML 或 <code>@Bean(initMethod=...)</code> 指定的自定义初始化方法。</li>
</ul>
</li>
<li><p><strong>初始化后置处理 (<code>BeanPostProcessor.postProcessAfterInitialization</code>)</strong>：</p>
<ul>
<li>再次遍历容器中所有的 BPP。</li>
<li><strong>核心细节（AOP）</strong>：<strong><code>AbstractAutoProxyCreator</code></strong>（AOP 的核心 BPP） 在这里工作。如果 <code>MyBean</code> 需要被事务管理或切面拦截，它会将原始对象包装成一个 <strong>Proxy (JDK 动态代理或 CGLIB)</strong>，并返回这个代理对象。</li>
<li><strong>替换</strong>：如果这里返回了代理对象，那么最终放入容器的就是这个代理对象，而不是原始对象。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="阶段四：注册完成-Registration"><a href="#阶段四：注册完成-Registration" class="headerlink" title="阶段四：注册完成 (Registration)"></a>阶段四：注册完成 (Registration)</h5><ol>
<li><strong>放入一级缓存</strong>：<ul>
<li>经过上述步骤，Bean 已经完整了。Spring 将最终的对象（可能是代理）放入 <strong>一级缓存 (<code>singletonObjects</code>)</strong>。</li>
<li>同时，清除二配缓存和三级缓存中的相关数据。</li>
</ul>
</li>
<li><strong>SmartInitializingSingleton</strong>：<ul>
<li>当<strong>所有</strong>非懒加载的单例 Bean 都初始化完成后，容器会回调 <code>SmartInitializingSingleton.afterSingletonsInstantiated()</code>。这是监听“所有Bean都好了”的绝佳时机（例如 Quartz 调度任务的启动）。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="阶段五：销毁-Destruction"><a href="#阶段五：销毁-Destruction" class="headerlink" title="阶段五：销毁 (Destruction)"></a>阶段五：销毁 (Destruction)</h5><p>当容器关闭 (<code>ctx.close()</code>) 时触发。</p>
<ol>
<li><strong>销毁前置处理</strong>：<ul>
<li><code>DestructionAwareBeanPostProcessor</code> 介入。</li>
<li><strong>底层细节</strong>：<code>CommonAnnotationBeanPostProcessor</code> 再次登场，执行 <strong><code>@PreDestroy</code></strong> 方法。</li>
</ul>
</li>
<li><strong>执行销毁方法</strong>：<ul>
<li>调用 <code>DisposableBean.destroy()</code>。</li>
<li>调用自定义的 <code>destroy-method</code>。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-1-3-代码示例"><a href="#5-1-3-代码示例" class="headerlink" title="5.1.3 代码示例"></a>5.1.3 代码示例</h4><p>创建一个Bean，它经历了生命周期中的所有关键点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifeCycleDemoBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LifeCycleDemoBean</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1. 【实例化】执行构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设这是需要注入的依赖</span></span><br><span class="line">    <span class="comment">// Spring会在这里进行【属性填充】</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postConstruct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3. 【初始化】执行 @PostConstruct 注解的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4. 【初始化】执行 InitializingBean 的 afterPropertiesSet 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customInitMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;5. 【初始化】执行自定义的 init-method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeanPostProcessor 的 before/after 方法会穿插在2和6之间</span></span><br><span class="line">    <span class="comment">// ... Bean is now in use ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;7. 【销毁】执行 @PreDestroy 注解的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;8. 【销毁】执行 DisposableBean 的 destroy 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customDestroyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;9. 【销毁】执行自定义的 destroy-method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最佳实践：</strong></p>
<ul>
<li><strong>初始化</strong>：<strong>优先使用 <code>@PostConstruct</code></strong>。它代码侵入性小，是Java标准，更优雅。</li>
<li><strong>销毁</strong>：<strong>优先使用 <code>@PreDestroy</code></strong>。</li>
<li><strong>Aware接口</strong>：除非你真的需要与Spring容器底层进行交互，否则尽量避免使用，以保持业务代码的纯净。</li>
<li><strong><code>BeanPostProcessor</code></strong>：这是一个非常强大的高级工具，主要用于框架级别的开发，用来对一批Bean进行统一的增强处理，普通业务开发很少直接实现它。</li>
</ul>
<hr>
<h3 id="5-2-Bean的作用域"><a href="#5-2-Bean的作用域" class="headerlink" title="5.2 Bean的作用域"></a>5.2 Bean的作用域</h3><h4 id="5-2-1-什么是作用域？"><a href="#5-2-1-什么是作用域？" class="headerlink" title="5.2.1 什么是作用域？"></a>5.2.1 什么是作用域？</h4><p>从 Spring 容器的底层实现来看，<strong>Bean Definition（Bean定义）</strong> 和 <strong>Bean Instance（Bean实例）</strong> 是两个完全不同的概念。</p>
<ul>
<li><strong>Bean Definition</strong>：是类的“蓝图”或“模具”（存储在 <code>BeanDefinition</code> 对象中）。它描述了怎么创建这个对象（构造函数、属性值等）。</li>
<li><strong>Bean Instance</strong>：是根据蓝图生产出来的具体的 Java 对象（存储在堆内存中）。</li>
</ul>
<p><strong>作用域（Scope）本质上是一个策略接口</strong>，它决定了<strong>容器如何使用这个“模具”来生产对象</strong>：</p>
<ol>
<li><strong>控制生产频率</strong>：是用同一个模具只造<strong>一个</strong>对象（Singleton），还是每次都造<strong>新</strong>对象（Prototype）？</li>
<li><strong>控制存活时间</strong>：这个造出来的对象能活多久？是伴随应用生老病死（Singleton），还是请求结束就销毁（Request）？</li>
<li><strong>控制可见范围</strong>：谁能看到这个对象？是全应用共享，还是只有当前线程可见？</li>
</ol>
<hr>
<h4 id="5-2-2-如何使用作用域"><a href="#5-2-2-如何使用作用域" class="headerlink" title="5.2.2 如何使用作用域"></a>5.2.2 如何使用作用域</h4><p>在 Spring 中，配置作用域主要有以下几种方式，且涉及到<strong>深层的注入时机问题</strong>。</p>
<h5 id="1-基于注解配置-Annotation-based-——-最常用"><a href="#1-基于注解配置-Annotation-based-——-最常用" class="headerlink" title="1. 基于注解配置 (Annotation-based) —— 最常用"></a>1. 基于注解配置 (Annotation-based) —— 最常用</h5><p>在类上直接使用 <code>@Scope</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span> <span class="comment">// 显式声明（虽然默认就是singleton）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span> <span class="comment">// 声明为多例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncTask</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>常量使用</strong>：建议使用 Spring 提供的常量，防止拼写错误。</p>
<ul>
<li><code>ConfigurableBeanFactory.SCOPE_SINGLETON</code></li>
<li><code>ConfigurableBeanFactory.SCOPE_PROTOTYPE</code></li>
<li><code>WebApplicationContext.SCOPE_REQUEST</code></li>
<li><code>WebApplicationContext.SCOPE_SESSION</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-基于-Java-Config-配置-Bean"><a href="#2-基于-Java-Config-配置-Bean" class="headerlink" title="2. 基于 Java Config 配置 (@Bean)"></a>2. 基于 Java Config 配置 (<code>@Bean</code>)</h5><p>在配置类中，配合 <code>@Bean</code> 使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-2-3-标准作用域"><a href="#5-2-3-标准作用域" class="headerlink" title="5.2.3 标准作用域"></a>5.2.3 标准作用域</h4><p>这些作用域在任何 Spring 容器（包括非 Web 环境）中都可用。</p>
<h5 id="1-singleton-单例-默认作用域"><a href="#1-singleton-单例-默认作用域" class="headerlink" title="1.  singleton (单例) - 默认作用域"></a>1.  <code>singleton</code> (单例) - 默认作用域</h5><ul>
<li><p><strong>定义</strong>：在整个Spring IoC容器中，一个Bean定义<strong>只对应一个实例</strong>。</p>
</li>
<li><p><strong>底层实现</strong>：</p>
<ul>
<li>由 <code>DefaultSingletonBeanRegistry</code> 类管理。</li>
<li>核心是一个 <code>ConcurrentHashMap&lt;String, Object&gt; singletonObjects</code>（即所谓的“一级缓存”或“单例池”）。</li>
</ul>
</li>
<li><p><strong>行为机制</strong>：</p>
<ul>
<li><strong>创建时机</strong>：容器启动时，<code>refresh()</code> 方法中的 <code>finishBeanFactoryInitialization()</code> 阶段，会预先实例化所有非懒加载的单例 Bean。</li>
<li><strong>获取逻辑</strong>：<code>getBean()</code> -&gt; 检查 <code>singletonObjects</code> Map -&gt; 有则直接返回；无则创建并放入 Map。</li>
</ul>
</li>
<li><p><strong>线程安全警告</strong>：</p>
<ul>
<li>因为全应用共享同一个实例，<strong>Singleton Bean 必须是无状态的</strong>（Stateless）。</li>
<li><strong>严禁</strong>在单例 Bean 的成员变量中存储特定用户的数据（如 <code>UserContext</code>），否则会导致严重的线程安全问题（数据交叉）。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：绝大多数无状态的Bean。例如 <code>Service</code> 层对象、<code>Repository</code> 层对象、<code>Controller</code>、配置类等。这些对象不保存与特定请求或用户相关的状态，只提供方法和功能。</p>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="comment">// @Scope(&quot;singleton&quot;) // 这是默认值，所以通常不需要显式声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingletonService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MySingletonService</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MySingletonService instance created!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论你在多少个地方注入<code>MySingletonService</code>，它的构造函数在整个应用生命周期中只会被调用一次。</p>
</li>
</ul>
<hr>
<h5 id="2-prototype-原型-多例"><a href="#2-prototype-原型-多例" class="headerlink" title="2. prototype (原型&#x2F;多例)"></a>2. <code>prototype</code> (原型&#x2F;多例)</h5><ul>
<li><p><strong>定义</strong>：每次对该Bean进行请求（注入或通过<code>getBean()</code>方法获取）时，都会<strong>创建一个全新的实例</strong>。</p>
</li>
<li><p><strong>底层实现</strong>：</p>
<ul>
<li>Spring <strong>不会缓存</strong> Prototype Bean。</li>
<li>对应源码逻辑：在 <code>doGetBean</code> 方法中，如果是 prototype，直接调用 <code>createBean</code> 创建新对象，不走单例池逻辑。</li>
</ul>
</li>
<li><p><strong>关键差异</strong>：</p>
<ul>
<li><strong>生命周期截断</strong>：Spring 容器只负责 Bean 的 <strong>实例化、属性填充、初始化</strong>。一旦初始化完成并交给调用者，Spring <strong>彻底放手</strong>，不再追踪其生命周期。</li>
<li><strong>意味着</strong>：<strong><code>@PreDestroy</code> 或 <code>DisposableBean.destroy()</code> 方法永远不会被调用</strong>。开发者必须手动管理资源释放（例如手动关闭该 Bean 持有的数据库连接）。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：需要保存状态的Bean。例如，一个记录多步骤操作向导的当前状态的对象，或者一个用于构建复杂对象的Builder。每个用户或每个线程都需要一个独立的状态对象，不能共享。</p>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserActionTracker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; actions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserActionTracker</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;New UserActionTracker instance created: &quot;</span> + <span class="built_in">this</span>.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAction</span><span class="params">(String action)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.actions.add(action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次注入<code>UserActionTracker</code>，你都会得到一个全新的、拥有自己<code>actions</code>列表的对象。</p>
</li>
</ul>
<hr>
<h4 id="5-2-4-Web应用中的额外作用域"><a href="#5-2-4-Web应用中的额外作用域" class="headerlink" title="5.2.4 Web应用中的额外作用域"></a>5.2.4 Web应用中的额外作用域</h4><p>这些作用域只有在 <code>WebApplicationContext</code> 环境下才有效。</p>
<p><strong>底层原理：<code>ThreadLocal</code></strong></p>
<p>Spring 通过 <code>RequestContextListener</code> 或 <code>DispatcherServlet</code> 拦截每个 HTTP 请求，将当前的 <code>HttpServletRequest</code> 对象绑定到当前线程的 <code>ThreadLocal</code> 中（通过 <code>RequestContextHolder</code>）。Web 作用域的 Bean 实际上就是去这个 <code>ThreadLocal</code> 或者 <code>Session</code> 中存取数据。</p>
<h5 id="1-request"><a href="#1-request" class="headerlink" title="1. request"></a>1. <code>request</code></h5><ul>
<li><strong>定义</strong>：每个 HTTP 请求创建一个新实例。</li>
<li><strong>底层存储</strong>：Bean 被存储在 <code>ServletRequest</code> 的属性（Attribute）中。请求结束，Request 对象销毁，Bean 随之销毁。</li>
<li><strong>场景</strong>：API 请求的上下文对象（如记录当前请求的 TraceId）。</li>
</ul>
<h5 id="2-session"><a href="#2-session" class="headerlink" title="2. session"></a>2. <code>session</code></h5><ul>
<li><strong>定义</strong>：每个 HTTP Session 创建一个新实例。</li>
<li><strong>底层存储</strong>：Bean 被存储在 <code>HttpSession</code> 的属性中。</li>
<li><strong>场景</strong>：用户登录信息 (<code>UserSession</code>)、购物车。</li>
</ul>
<h5 id="3-application"><a href="#3-application" class="headerlink" title="3. application"></a>3. <code>application</code></h5><ul>
<li><strong>定义</strong>：整个 Web 应用共享一个实例。</li>
<li><strong>底层存储</strong>：Bean 被存储在 <code>ServletContext</code> 的属性中。</li>
<li><strong>与 Singleton 的区别</strong>：<ul>
<li><code>singleton</code> 作用域是针对 <strong>Spring 容器（ApplicationContext）</strong> 的，一个 Web 应用可以有多个 Spring 容器（父子容器）。</li>
<li><code>application</code> 作用域是针对 <strong>ServletContext</strong> 的，通常对应 Web 容器中的一个 Web App。</li>
</ul>
</li>
</ul>
<h5 id="4-websocket"><a href="#4-websocket" class="headerlink" title="4. websocket"></a>4. <code>websocket</code></h5><ul>
<li><strong>定义</strong>：对于每一个WebSocket会话，创建一个Bean实例。</li>
</ul>
<hr>
<h4 id="5-2-5-作用域依赖问题与代理"><a href="#5-2-5-作用域依赖问题与代理" class="headerlink" title="5.2.5 作用域依赖问题与代理"></a>5.2.5 作用域依赖问题与代理</h4><p><strong>问题场景</strong>：</p>
<p>假设一个 <code>Singleton</code> 的 <code>UserService</code>，它需要注入一个 <code>Session</code> 作用域的 <code>UserPreferences</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span> <span class="comment">// 默认为 Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserPreferences userPreferences; <span class="comment">// 这是一个 Session 作用域的 Bean</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 问题：UserService 只有在启动时创建一次。</span></span><br><span class="line">        <span class="comment">// 所以 userPreferences 属性也只会在启动时被注入一次！</span></span><br><span class="line">        <span class="comment">// 结果：所有用户都会共享同一个（启动时那个）用户的 Preferences，这是严重 Bug。</span></span><br><span class="line">        System.out.println(userPreferences.getTheme()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案：Scoped Proxy (作用域代理)</strong></p>
<p>Spring 提供了一种机制，不直接注入原始的 Bean，而是注入一个<strong>智能代理对象</strong>。</p>
<ul>
<li><p><strong>配置方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(value = &quot;session&quot;, proxyMode = ScopedProxyMode.TARGET_CLASS)</span> <span class="comment">// 开启代理模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserPreferences</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>或者在 Java Config 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(value = &quot;session&quot;, proxyMode = ScopedProxyMode.TARGET_CLASS)</span></span><br><span class="line"><span class="keyword">public</span> UserPreferences <span class="title function_">userPreferences</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>ScopedProxyMode.TARGET_CLASS</code></strong>：使用 CGLIB 基于类生成代理（推荐）。</li>
<li><strong><code>ScopedProxyMode.INTERFACES</code></strong>：使用 JDK 动态代理（要求 Bean 必须实现接口）。</li>
</ul>
</li>
<li><p><strong>底层执行流程</strong>：</p>
<ol>
<li>Spring 启动时，为 <code>UserPreferences</code> 生成一个 <strong>CGLIB 代理对象</strong>。</li>
<li>将这个<strong>代理对象</strong>注入给 <code>UserService</code>。</li>
<li>当 <code>UserService</code> 调用 <code>userPreferences.getData()</code> 时，实际上调用的是代理对象。</li>
<li>代理对象内部逻辑：<ul>
<li>获取当前请求的 <code>Session</code>。</li>
<li>从 <code>Session</code> 中取出属于当前用户的真实 <code>UserPreferences</code> 对象（如果没有就新建）。</li>
<li>调用真实对象的方法。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="5-3-循环依赖"><a href="#5-3-循环依赖" class="headerlink" title="5.3 循环依赖"></a>5.3 循环依赖</h3><h4 id="5-3-1-什么是循环依赖"><a href="#5-3-1-什么是循环依赖" class="headerlink" title="5.3.1 什么是循环依赖"></a>5.3.1 什么是循环依赖</h4><p>循环依赖，也叫循环引用，指的是两个或多个Bean之间相互持有对方的引用，形成一个闭环。最简单的形式是：<strong>A 依赖 B，同时 B 又依赖 A。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceB serviceB;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceA</span><span class="params">(ServiceB serviceB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serviceB = serviceB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceB</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceA serviceA;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceB</span><span class="params">(ServiceA serviceA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serviceA = serviceA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不加以干预，启动时会发生死锁或 <code>StackOverflowError</code>：创建 A 需要 B -&gt; 创建 B 需要 A -&gt; 创建 A 需要 B … 无限递归。</p>
<hr>
<h4 id="5-3-2-核心机制：三级缓存-Three-Level-Cache"><a href="#5-3-2-核心机制：三级缓存-Three-Level-Cache" class="headerlink" title="5.3.2 核心机制：三级缓存 (Three-Level Cache)"></a>5.3.2 核心机制：三级缓存 (Three-Level Cache)</h4><h5 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>Spring 通过<strong>三级缓存</strong>机制，在<strong>单例（singleton）作用域</strong>且使用 <strong>Setter&#x2F;字段注入</strong> 的情况下，完美解决了循环依赖。</p>
<p>在 <code>DefaultSingletonBeanRegistry</code> 类中，定义了这三个 Map：</p>
<ol>
<li><strong>一级缓存 (<code>singletonObjects</code>)</strong>：<strong>成品池</strong>。<ul>
<li><code>Map&lt;String, Object&gt;</code></li>
<li>存放<strong>经历了完整生命周期</strong>（实例化、属性填充、初始化）的单例 Bean。我们平时 <code>getBean</code> 拿到的就是这里面的对象。</li>
</ul>
</li>
<li><strong>二级缓存 (<code>earlySingletonObjects</code>)</strong>：<strong>半成品池</strong>。<ul>
<li><code>Map&lt;String, Object&gt;</code></li>
<li>存放<strong>早期暴露的 Bean 对象</strong>。这个对象已经被实例化，但属性还没有填充，初始化方法也没执行。</li>
<li>它的作用是：一旦 A 被放入这里，当 B 再需要 A 时，直接从这里拿，而不需要再去走创建流程。</li>
</ul>
</li>
<li><strong>三级缓存 (<code>singletonFactories</code>)</strong>：<strong>工厂池</strong>。<ul>
<li><code>Map&lt;String, ObjectFactory&lt;?&gt;&gt;</code></li>
<li>存放<strong>能够生成 Bean 的工厂（Lambda 表达式）</strong>。</li>
<li><strong>关键点</strong>：这里存的不是 Bean 对象本身，而是一个<strong>回调逻辑</strong>。当循环依赖发生时，Spring 会调用这个工厂的 <code>getObject()</code> 方法来获取（或生成）早期的 Bean 引用。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="2-流程图"><a href="#2-流程图" class="headerlink" title="2. 流程图"></a>2. 流程图</h5><p><strong>解决流程（A依赖B，B依赖A）</strong></p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant Client as 客户端
    participant Spring as Spring容器
    participant L1_Cache as 一级缓存 (singletonObjects)
    participant L2_Cache as 二级缓存 (earlySingletonObjects)
    participant L3_Cache as 三级缓存 (singletonFactories)
    participant A as ServiceA
    participant B as ServiceB

    title Spring 循环依赖解决流程 (三级缓存)

    Client-&gt;&gt;Spring: getBean(&quot;a&quot;)

    %% 1. 创建A
    Spring-&gt;&gt;L1_Cache: 检查 &quot;a&quot;
    L1_Cache--&gt;&gt;Spring: 未找到
    note over Spring: 开始创建A
    Spring-&gt;&gt;A: 1. 实例化 new ServiceA()
    A--&gt;&gt;Spring: a_instance (裸对象)
    Spring-&gt;&gt;L3_Cache: 2. put(&quot;a&quot;, aFactory)
    note right of L3_Cache: 放入A的工厂，暴露早期引用

    %% 2. 填充A的属性，发现依赖B
    note over Spring: 3. 填充A，发现依赖B
    Spring-&gt;&gt;Spring: getBean(&quot;b&quot;)

    %% 3. 创建B
    Spring-&gt;&gt;L1_Cache: 检查 &quot;b&quot;
    L1_Cache--&gt;&gt;Spring: 未找到
    note over Spring: 开始创建B
    Spring-&gt;&gt;B: 4. 实例化 new ServiceB()
    B--&gt;&gt;Spring: b_instance (裸对象)
    Spring-&gt;&gt;L3_Cache: 5. put(&quot;b&quot;, bFactory)

    %% 4. 填充B的属性，发现依赖A
    note over Spring: 6. 填充B，发现依赖A
    Spring-&gt;&gt;Spring: getBean(&quot;a&quot;)

    %% 5. 解决循环的关键点
    note over Spring: 再次获取A, 检查三级缓存
    Spring-&gt;&gt;L1_Cache: 检查 &quot;a&quot; -&gt; 未找到
    Spring-&gt;&gt;L2_Cache: 检查 &quot;a&quot; -&gt; 未找到
    Spring-&gt;&gt;L3_Cache: 检查 &quot;a&quot; -&gt; 找到aFactory!
    L3_Cache--&gt;&gt;Spring: 返回 aFactory
    
    note over Spring: 7. 执行aFactory, 获取早期引用
    Spring-&gt;&gt;L3_Cache: aFactory.getObject()
    L3_Cache--&gt;&gt;Spring: early_a_ref (A的早期引用)
    Spring-&gt;&gt;L2_Cache: 8. put(&quot;a&quot;, early_a_ref)
    Spring-&gt;&gt;L3_Cache: 9. remove(&quot;a&quot;)
    note right of L2_Cache: A的早期引用放入二级缓存，防止重复创建
    
    Spring-&gt;&gt;B: 10. 将early_a_ref注入B
    note left of B: B的属性填充完成

    %% 6. 完成B的创建
    note over Spring: 11. B初始化完成
    B--&gt;&gt;Spring: 完整的B实例
    Spring-&gt;&gt;L1_Cache: 12. put(&quot;b&quot;, b_instance)
    note right of L1_Cache: 完整的B放入一级缓存

    %% 7. 完成A的创建
    note over Spring: 13. 返回A的创建流程，注入B
    Spring-&gt;&gt;L1_Cache: getBean(&quot;b&quot;)
    L1_Cache--&gt;&gt;Spring: 返回完整的B实例
    Spring-&gt;&gt;A: 14. 将完整的B注入A
    note left of A: A的属性填充完成
    
    note over Spring: 15. A初始化完成
    A--&gt;&gt;Spring: 完整的A实例
    Spring-&gt;&gt;L1_Cache: 16. put(&quot;a&quot;, a_instance)
    note right of L1_Cache: 完整的A放入一级缓存

    Spring--&gt;&gt;Client: 返回完整的A实例</code></pre>

<hr>
<h5 id="3-步骤详解"><a href="#3-步骤详解" class="headerlink" title="3. 步骤详解"></a>3. 步骤详解</h5><ol>
<li><strong>创建A</strong>:<ul>
<li><code>getBean(&quot;a&quot;)</code>被调用。</li>
<li>Spring检查一级缓存，没有A。</li>
<li>Spring开始创建A。首先，通过构造函数<strong>实例化</strong>A，得到一个“裸”对象<code>a_instance</code>。</li>
<li><strong>关键一步</strong>：Spring不会立即填充A的属性。而是创建一个能获取<code>a_instance</code>的工厂（<code>ObjectFactory</code>），并将其放入<strong>三级缓存</strong>中：<code>singletonFactories.put(&quot;a&quot;, aFactory)</code>。</li>
</ul>
</li>
<li><strong>填充A的属性</strong>:<ul>
<li>Spring开始为<code>a_instance</code>注入依赖。它发现A需要B（<code>private ServiceB serviceB;</code>）。</li>
</ul>
</li>
<li><strong>创建B</strong>:<ul>
<li>Spring暂停A的创建，转而去<code>getBean(&quot;b&quot;)</code>。</li>
<li>和A一样，Spring实例化B，得到<code>b_instance</code>，然后将B的工厂放入<strong>三级缓存</strong>：<code>singletonFactories.put(&quot;b&quot;, bFactory)</code>。</li>
</ul>
</li>
<li><strong>填充B的属性</strong>:<ul>
<li>Spring为<code>b_instance</code>注入依赖。它发现B需要A。</li>
</ul>
</li>
<li><strong>解决循环的关键点</strong>:<ul>
<li>Spring暂停B的创建，转而去<code>getBean(&quot;a&quot;)</code>。</li>
<li>Spring再次检查缓存：<ul>
<li>一级缓存 (<code>singletonObjects</code>): 没有A。</li>
<li>二级缓存 (<code>earlySingletonObjects</code>): 也没有A。</li>
<li><strong>三级缓存 (<code>singletonFactories</code>): 找到了A的工厂 <code>aFactory</code>！</strong></li>
</ul>
</li>
<li>Spring立刻执行这个<code>aFactory</code>，得到一个A的<strong>早期引用</strong>（Early Reference），也就是那个刚实例化但还没装修的<code>a_instance</code>。</li>
<li>为了防止重复创建，Spring将这个早期引用放入<strong>二级缓存</strong> <code>earlySingletonObjects.put(&quot;a&quot;, early_a_ref)</code>，并从三级缓存中移除A的工厂。</li>
<li>这个A的早期引用被返回并注入到B的<code>serviceA</code>字段中。</li>
</ul>
</li>
<li><strong>完成B的创建</strong>:<ul>
<li>B成功获取了A的引用（虽然是早期的），B的属性填充完成。</li>
<li>B执行初始化方法，成为一个完整的Bean。</li>
<li>完整的B被放入<strong>一级缓存</strong> <code>singletonObjects.put(&quot;b&quot;, b_instance)</code>。</li>
</ul>
</li>
<li><strong>完成A的创建</strong>:<ul>
<li>执行流程回到第2步，<code>getBean(&quot;b&quot;)</code>现在可以直接从一级缓存中拿到完整的B实例。</li>
<li>完整的B被注入到A的<code>serviceB</code>字段中。</li>
<li>A的属性填充完成，执行初始化，成为一个完整的Bean。</li>
<li>完整的A被放入<strong>一级缓存</strong> <code>singletonObjects.put(&quot;a&quot;, a_instance)</code>。</li>
</ul>
</li>
</ol>
<p>至此，循环依赖被完美解决。两个Bean都持有了对方的完整实例。</p>
<hr>
<h4 id="5-3-3-为什么需要三级缓存而不是二级？"><a href="#5-3-3-为什么需要三级缓存而不是二级？" class="headerlink" title="5.3.3 为什么需要三级缓存而不是二级？"></a>5.3.3 为什么需要三级缓存而不是二级？</h4><p>这是很多人的盲区：<strong>“既然二级缓存就能存早期对象，为什么非要搞个三级缓存存工厂？”</strong></p>
<p>答案是：<strong>为了在解决循环依赖的同时，不破坏 AOP 代理的生命周期。</strong></p>
<ol>
<li><strong>正常的 AOP 流程</strong>：<ul>
<li>AOP 代理通常是在 <strong>初始化后</strong> (<code>postProcessAfterInitialization</code>) 创建的。</li>
<li>也就是说，Bean 应该是：实例化 -&gt; 填充属性 -&gt; 初始化 -&gt; <strong>创建代理</strong> -&gt; 放入单例池。</li>
</ul>
</li>
<li><strong>循环依赖的矛盾</strong>：<ul>
<li>如果是 A 依赖 B，B 依赖 A。当 B 需要 A 时，A 还没初始化完。</li>
<li>如果 B 拿到了 A 的原始对象，而 A 最后初始化完变成了代理对象，那么 <strong>B 持有的 A（原始）</strong> 和 <strong>容器里的 A（代理）</strong> 就不是同一个对象了！这会出大问题（比如事务失效）。</li>
</ul>
</li>
<li><strong>三级缓存的妙用</strong>：<ul>
<li><code>singletonFactories</code> 中存的是 <code>() -&gt; getEarlyBeanReference(beanName, mbd, bean)</code>。</li>
<li><strong>如果没有循环依赖</strong>：这个工厂永远不会被调用，A 按照正常流程在初始化后创建代理。</li>
<li><strong>如果有循环依赖</strong>（B 需要 A）：B 去三级缓存找 A。此时，工厂被触发！<code>getEarlyBeanReference</code> 会<strong>提前</strong>去判断 A 是否需要代理。<ul>
<li>如果需要，它就<strong>提前创建代理对象</strong>并返回。</li>
<li>如果不需要，就返回原始对象。</li>
</ul>
</li>
<li>这个返回的对象会被放入<strong>二级缓存</strong>。</li>
<li>当 A 最终完成初始化时，Spring 会检查：“我之前是不是因为循环依赖被提前创建过代理了？”如果是，就直接使用那个二级缓存里的代理，保证全局唯一。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-3-4-Spring无法解决的循环依赖"><a href="#5-3-4-Spring无法解决的循环依赖" class="headerlink" title="5.3.4 Spring无法解决的循环依赖"></a>5.3.4 Spring无法解决的循环依赖</h4><ol>
<li><strong>构造器注入 (Constructor Injection)</strong><ul>
<li><strong>原因</strong>：三级缓存生效的前提是 <code>createBeanInstance</code> (实例化) 必须先完成，对象要在堆上分配内存后才能暴露引用。构造器执行期间，对象还没产生，自然没法放入三级缓存。</li>
<li><strong>现象</strong>：启动报错 <code>BeanCurrentlyInCreationException</code>。</li>
</ul>
</li>
<li><strong>Prototype 作用域</strong><ul>
<li><strong>原因</strong>：Spring 不缓存 Prototype 的 Bean，也就没有三级缓存机制可用。</li>
<li><strong>现象</strong>：启动报错 <code>BeanCurrentlyInCreationException</code>。</li>
</ul>
</li>
<li><strong><code>@Async</code> 的特殊情况</strong><ul>
<li><code>@Async</code> 的代理是在非常靠后的阶段生成的，且往往也是通过 BPP 实现。如果使用了 <code>@Async</code> 且有循环依赖，经常会报 <code>BeanCurrentlyInCreationException</code>，因为 Spring 发现最终放入单例池的 Bean 和早期暴露给 B 的 Bean 不一致。建议尽量避免在循环依赖类中使用 <code>@Async</code>，或者配合 <code>@Lazy</code> 使用。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-3-5-最佳实践"><a href="#5-3-5-最佳实践" class="headerlink" title="5.3.5 最佳实践"></a>5.3.5 最佳实践</h4><p>尽管 Spring 提供了兜底机制，但循环依赖通常代表<strong>设计缺陷</strong>（高耦合）。</p>
<ol>
<li><strong>重构 (Refactor)</strong>：<strong>【上策】</strong><ul>
<li>寻找 A 和 B 共同依赖的逻辑，抽取成 C。</li>
<li>A -&gt; C, B -&gt; C。</li>
</ul>
</li>
<li><strong>使用 <code>@Lazy</code></strong>：<strong>【中策】</strong><ul>
<li><code>public ServiceA(@Lazy ServiceB serviceB)</code>。</li>
<li>原理：Spring 会注入一个临时的<strong>代理占位符</strong>给 A。等 A 启动完成，真正调用 B 的方法时，这个代理才去容器找真正的 B。这推迟了依赖解析的时机。</li>
</ul>
</li>
<li><strong>Setter&#x2F;字段注入</strong>：<strong>【下策】</strong><ul>
<li>利用 Spring 的三级缓存自动解决（前提是单例）。</li>
</ul>
</li>
</ol>
<hr>
<hr>
<h1 id="四、面向切面编程"><a href="#四、面向切面编程" class="headerlink" title="四、面向切面编程"></a>四、面向切面编程</h1><h2 id="1-AOP核心概念"><a href="#1-AOP核心概念" class="headerlink" title="1. AOP核心概念"></a>1. AOP核心概念</h2><h3 id="1-1-为什么需要AOP？"><a href="#1-1-为什么需要AOP？" class="headerlink" title="1.1 为什么需要AOP？"></a>1.1 为什么需要AOP？</h3><p>想象一下，我们有很多业务方法，比如<code>createUser()</code>, <code>updateOrder()</code>, <code>deleteProduct()</code>。现在，我们需要为这些方法统一添加一些功能，比如：</p>
<ul>
<li><strong>日志记录</strong>：在方法开始和结束时打印日志。</li>
<li><strong>事务管理</strong>：在方法开始时开启事务，结束时提交或回滚。</li>
<li><strong>权限校验</strong>：在方法执行前检查当前用户是否有权限。</li>
<li><strong>性能监控</strong>：记录每个方法的执行时间。</li>
</ul>
<p><strong>如果没有AOP，我们可能会这样做：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 权限校验</span></span><br><span class="line">        checkPermission(<span class="string">&quot;CREATE_USER&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 开启事务</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> transactionManager.begin();</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 核心业务逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Executing core logic: creating user &quot;</span> + user.getName());</span><br><span class="line">            userRepository.save(user);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 提交事务</span></span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 5. 回滚事务</span></span><br><span class="line">            tx.rollback();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 记录日志和性能</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">            System.out.println(<span class="string">&quot;Method createUser executed in &quot;</span> + duration + <span class="string">&quot;ms.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... updateOrder() 和 deleteProduct() 方法中也要重复1-6步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题显而易见：</strong></p>
<ul>
<li><strong>代码重复</strong>：日志、事务、权限代码在每个业务方法中都重复出现。</li>
<li><strong>业务逻辑混杂</strong>：核心的业务逻辑（<code>userRepository.save(user)</code>）被大量非业务的“样板代码”所包围，难以阅读和维护。</li>
</ul>
<p><strong>AOP的目标</strong>：就是将这些分散在各处的、与核心业务无关但又必不可少的通用功能（我们称之为<strong>横切关注点</strong>），从业务代码中<strong>抽离</strong>出来，形成独立的模块（<strong>切面</strong>），然后以一种非侵入的方式，在需要的时候动态地“织入”到业务代码中。</p>
<hr>
<h3 id="1-2-AOP核心术语"><a href="#1-2-AOP核心术语" class="headerlink" title="1.2 AOP核心术语"></a>1.2 AOP核心术语</h3><p>为了实现上述目标，AOP定义了一套专门的术语。你可以将这套术语看作是一套**“拦截与增强”的规则体系**。</p>
<h4 id="1-2-1-Aspect-切面"><a href="#1-2-1-Aspect-切面" class="headerlink" title="1.2.1 Aspect (切面)"></a>1.2.1 Aspect (切面)</h4><ul>
<li><strong>定义</strong>：<strong>切点</strong>和<strong>通知</strong>的集合。它是对跨越多个类的关注点（如日志管理）的模块化封装。</li>
<li><strong>通俗理解</strong>：<strong>“完整方案”</strong>。它是一个Java类，既包含了“代码逻辑”（通知），也包含了“执行规则”（切点）。它定义了要把什么逻辑应用到哪里去。</li>
<li><strong>在Spring中</strong>：使用 <code>@Aspect</code> 注解标记的类。</li>
</ul>
<hr>
<h4 id="1-2-2-Join-Point-连接点"><a href="#1-2-2-Join-Point-连接点" class="headerlink" title="1.2.2 Join Point (连接点)"></a>1.2.2 Join Point (连接点)</h4><ul>
<li><strong>定义</strong>：程序执行过程中可以应用切面的<strong>候选点</strong>。</li>
<li><strong>通俗理解</strong>：<strong>“所有可能的时机”</strong>。你的程序中有成百上千个方法，理论上每一个方法的执行前后都可以被拦截，这些位置统称为连接点。</li>
<li><strong>在Spring中</strong>：特指<strong>方法的执行</strong>。Spring AOP 仅支持方法级别的连接点。</li>
</ul>
<hr>
<h4 id="1-2-3-Pointcut-切点"><a href="#1-2-3-Pointcut-切点" class="headerlink" title="1.2.3 Pointcut (切点)"></a>1.2.3 Pointcut (切点)</h4><ul>
<li><strong>定义</strong>：匹配连接点的<strong>断言</strong>或<strong>表达式</strong>。</li>
<li><strong>通俗理解</strong>：<strong>“筛选条件”</strong>。连接点是所有可能的位置，而切点则是你写的一个规则（比如“所有Service类的所有方法”），用来从众多的连接点中筛选出你真正想要拦截的那一部分。</li>
<li><strong>在Spring中</strong>：通常使用 <code>execution(...)</code> 表达式定义，配合 <code>@Pointcut</code> 注解使用。</li>
</ul>
<hr>
<h4 id="1-2-4-Advice-通知"><a href="#1-2-4-Advice-通知" class="headerlink" title="1.2.4 Advice (通知)"></a>1.2.4 Advice (通知)</h4><ul>
<li><strong>定义</strong>：切面在特定的切点处执行的<strong>动作</strong>。</li>
<li><strong>通俗理解</strong>：<strong>“具体的增强逻辑”</strong>。切点锁定了位置，通知则定义了在这个位置要<strong>执行什么代码</strong>。</li>
<li><strong>在Spring中</strong>：表现为切面类中的方法，根据执行时机分为5种。</li>
</ul>
<hr>
<h4 id="1-2-5-Target-Object-目标对象"><a href="#1-2-5-Target-Object-目标对象" class="headerlink" title="1.2.5 Target Object (目标对象)"></a>1.2.5 Target Object (目标对象)</h4><ul>
<li><strong>定义</strong>：被一个或多个切面所通知的对象。</li>
<li><strong>通俗理解</strong>：<strong>“原始业务对象”</strong>。这是你原本写的、包含核心业务逻辑（如 <code>UserServiceImpl</code>）的类的实例。它本身并不知道自己被代理了，也不包含任何AOP的逻辑。</li>
<li><strong>在Spring中</strong>：容器中被代理的那个原始 Bean 实例。</li>
</ul>
<hr>
<h4 id="1-2-6-Proxy-代理"><a href="#1-2-6-Proxy-代理" class="headerlink" title="1.2.6 Proxy (代理)"></a>1.2.6 Proxy (代理)</h4><ul>
<li><strong>定义</strong>：AOP框架向目标对象应用通知之后创建的对象。</li>
<li><strong>通俗理解</strong>：<strong>“增强后的包装对象”</strong>。Spring 不会修改你的原始类文件，而是在内存中生成一个新的对象（代理对象）。这个代理对象“包裹”了目标对象，外部调用时，先经过代理对象执行AOP逻辑（通知），再由代理对象调用目标对象的原始逻辑。</li>
<li><strong>在Spring中</strong>：<ul>
<li>如果目标对象实现了接口，默认使用 <strong>JDK动态代理</strong>。</li>
<li>如果目标对象没有接口，使用 <strong>CGLIB代理</strong>（生成子类）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-7-Weaving-织入"><a href="#1-2-7-Weaving-织入" class="headerlink" title="1.2.7 Weaving (织入)"></a>1.2.7 Weaving (织入)</h4><ul>
<li><strong>定义</strong>：将切面与其他应用程序类型或对象连接起来，以创建代理对象的过程。</li>
<li><strong>通俗理解</strong>：<strong>“组装过程”</strong>。这是Spring将“切面逻辑”和“业务逻辑”融合在一起，动态生成“代理对象”的那个动作。</li>
<li><strong>在Spring中</strong>：织入发生在<strong>运行时</strong>。当Spring容器启动并初始化Bean时，会自动识别并完成织入。</li>
</ul>
<hr>
<h3 id="1-3-关系图"><a href="#1-3-关系图" class="headerlink" title="1.3 关系图"></a>1.3 关系图</h3><pre><code class="highlight mermaid">graph TD
    subgraph &quot;AOP Definition (定义阶段)&quot;
        Aspect[&quot;&lt;b&gt;Aspect (切面)&lt;/b&gt;&lt;br/&gt;@Aspect&lt;br/&gt;(完整方案: 规则+逻辑)&quot;]
        Pointcut[&quot;&lt;b&gt;Pointcut (切点)&lt;/b&gt;&lt;br/&gt;@Pointcut&lt;br/&gt;(筛选规则: &lt;b&gt;哪里&lt;/b&gt;需要增强?)&quot;]
        Advice[&quot;&lt;b&gt;Advice (通知)&lt;/b&gt;&lt;br/&gt;@Before, @Around...&lt;br/&gt;(增强逻辑: 具体要&lt;b&gt;做&lt;/b&gt;什么?)&quot;]
        
        Aspect -- &quot;包含&quot; --&gt; Pointcut
        Aspect -- &quot;包含&quot; --&gt; Advice
        Pointcut -. &quot;定位执行时机&quot; .-&gt; Advice
    end

    JoinPoints[&quot;&lt;b&gt;Join Points (连接点)&lt;/b&gt;&lt;br/&gt;(程序中所有方法的执行时机)&quot;]
    
    Pointcut -- &quot;从所有连接点中筛选&quot; --&gt; JoinPoints

    subgraph &quot;Weaving Result (运行时织入)&quot;
        %% 这是一个隐喻的过程，展示代理如何工作
        Client[&quot;&lt;b&gt;Client (外部调用者)&lt;/b&gt;&quot;]
        Proxy[&quot;&lt;b&gt;Proxy (代理对象)&lt;/b&gt;&lt;br/&gt;(增强后的包装对象)&quot;]
        Target[&quot;&lt;b&gt;Target Object (目标对象)&lt;/b&gt;&lt;br/&gt;(原始业务Bean)&quot;]

        Client -- &quot;调用&quot; --&gt; Proxy
        Proxy -- &quot;1. 执行增强逻辑&quot; --&gt; Advice
        Proxy -- &quot;2. 调用原始方法&quot; --&gt; Target
    end

    %% 样式定义
    style Aspect fill:#f9f,stroke:#333,stroke-width:2px
    style Pointcut fill:#ccf,stroke:#333,stroke-width:2px
    style Advice fill:#cfc,stroke:#333,stroke-width:2px
    style JoinPoints fill:#ff9,stroke:#333,stroke-width:2px,stroke-dasharray: 5 5
    style Proxy fill:#f96,stroke:#333,stroke-width:2px
    style Target fill:#fff,stroke:#333,stroke-width:2px</code></pre>

<hr>
<h2 id="2-Advice-通知"><a href="#2-Advice-通知" class="headerlink" title="2. Advice(通知)"></a>2. Advice(通知)</h2><h3 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h3><h4 id="2-1-1-添加依赖"><a href="#2-1-1-添加依赖" class="headerlink" title="2.1.1 添加依赖"></a>2.1.1 添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-目标对象"><a href="#2-1-2-目标对象" class="headerlink" title="2.1.2 目标对象"></a>2.1.2 目标对象</h4><p>我们将对这个<code>CalculatorService</code>的方法执行进行“通知”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/CalculatorService.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.aop.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CalculatorService</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// service/CalculatorServiceImpl.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.aop.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CalculatorService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--- 执行核心逻辑: add(&quot;</span> + a + <span class="string">&quot;, &quot;</span> + b + <span class="string">&quot;) ---&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--- 执行核心逻辑: divide(&quot;</span> + a + <span class="string">&quot;, &quot;</span> + b + <span class="string">&quot;) ---&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;除数不能为零&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-3-切面和切点"><a href="#2-1-3-切面和切点" class="headerlink" title="2.1.3 切面和切点"></a>2.1.3 切面和切点</h4><p>我们创建一个<code>LoggingAspect</code>，并定义一个通用的切点，指向<code>CalculatorService</code>中的所有方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aspect/LoggingAspect.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.aop.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个可重用的切点，匹配CalculatorService接口中的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.aop.service.CalculatorService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculatorServiceMethods</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来，我们将在这个类中添加五种不同类型的通知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-Advice的五种类型"><a href="#2-2-Advice的五种类型" class="headerlink" title="2.2 Advice的五种类型"></a>2.2 Advice的五种类型</h3><h4 id="2-2-1-Before-前置通知"><a href="#2-2-1-Before-前置通知" class="headerlink" title="2.2.1 @Before (前置通知)"></a>2.2.1 <code>@Before</code> (前置通知)</h4><ul>
<li><strong>执行时机</strong>：在连接点<strong>执行之前</strong>运行。</li>
<li><strong>特点</strong>：<ul>
<li>无法阻止目标方法的执行。</li>
<li>可以获取到目标方法的元数据（如方法名、参数），但无法改变参数。</li>
</ul>
</li>
<li><strong>适用场景</strong>：权限检查、参数日志记录、数据预处理。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 LoggingAspect.java 中添加</span></span><br><span class="line"><span class="meta">@Before(&quot;calculatorServiceMethods()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    System.out.println(<span class="string">&quot;[@Before] 方法 &quot;</span> + methodName + <span class="string">&quot; 即将执行，参数: &quot;</span> + Arrays.toString(args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当调用 <code>add(5, 3)</code> 时，输出:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[@Before] 方法 add 即将执行，参数: [5, 3]</span><br><span class="line">--- 执行核心逻辑: add(5, 3) ---</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-2-AfterReturning-后置通知-返回通知"><a href="#2-2-2-AfterReturning-后置通知-返回通知" class="headerlink" title="2.2.2 @AfterReturning (后置通知&#x2F;返回通知)"></a>2.2.2 <code>@AfterReturning</code> (后置通知&#x2F;返回通知)</h4><ul>
<li><strong>执行时机</strong>：在目标方法<strong>正常执行完毕</strong>（即没有抛出任何异常）并<strong>返回结果后</strong>运行。</li>
<li><strong>特点</strong>：<ul>
<li>可以获取到目标方法的返回值。</li>
<li>但无法改变返回值（虽然可以通过一些技巧包装，但不推荐）。</li>
</ul>
</li>
<li><strong>适用场景</strong>：对返回结果进行日志记录、对结果进行格式化或加密后再返回给某些审计系统。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 LoggingAspect.java 中添加</span></span><br><span class="line"><span class="comment">// `returning = &quot;result&quot;` 将目标方法的返回值绑定到通知方法的`result`参数上</span></span><br><span class="line"><span class="meta">@AfterReturning(pointcut = &quot;calculatorServiceMethods()&quot;, returning = &quot;result&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfterReturning</span><span class="params">(JoinPoint joinPoint, Object result)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;[@AfterReturning] 方法 &quot;</span> + methodName + <span class="string">&quot; 成功执行并返回: &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当调用 <code>add(5, 3)</code> 时，输出:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--- 执行核心逻辑: add(5, 3) ---</span><br><span class="line">[@AfterReturning] 方法 add 成功执行并返回: 8</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-3-AfterThrowing-异常通知"><a href="#2-2-3-AfterThrowing-异常通知" class="headerlink" title="2.2.3 @AfterThrowing (异常通知)"></a>2.2.3 <code>@AfterThrowing</code> (异常通知)</h4><ul>
<li><strong>执行时机</strong>：在目标方法执行过程中<strong>抛出异常后</strong>运行。</li>
<li><strong>特点</strong>：<ul>
<li>可以获取到抛出的异常对象。</li>
<li>可以用于统一的异常处理和日志记录。</li>
</ul>
</li>
<li><strong>适用场景</strong>：记录异常日志、发送错误告警（如邮件、短信）、触发事务回滚的特定逻辑。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 LoggingAspect.java 中添加</span></span><br><span class="line"><span class="comment">// `throwing = &quot;ex&quot;` 将抛出的异常绑定到通知方法的`ex`参数上</span></span><br><span class="line"><span class="meta">@AfterThrowing(pointcut = &quot;calculatorServiceMethods()&quot;, throwing = &quot;ex&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfterThrowing</span><span class="params">(JoinPoint joinPoint, Throwable ex)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    System.err.println(<span class="string">&quot;[@AfterThrowing] 方法 &quot;</span> + methodName + <span class="string">&quot; 抛出异常: &quot;</span> + ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当调用 <code>divide(10, 0)</code> 时，输出:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--- 执行核心逻辑: divide(10, 0) ---</span><br><span class="line">[@AfterThrowing] 方法 divide 抛出异常: 除数不能为零</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-4-After-最终通知"><a href="#2-2-4-After-最终通知" class="headerlink" title="2.2.4 @After (最终通知)"></a>2.2.4 <code>@After</code> (最终通知)</h4><ul>
<li><strong>执行时机</strong>：<strong>无论</strong>目标方法是正常返回还是抛出异常，它<strong>总会</strong>执行。类似于<code>try-catch-finally</code>中的<code>finally</code>块。</li>
<li><strong>特点</strong>：<ul>
<li>无法获取返回值或异常信息，因为它不知道方法是如何结束的。</li>
</ul>
</li>
<li><strong>适用场景</strong>：资源释放。例如，关闭文件句柄、释放数据库连接、清理临时数据等，这些操作无论成功失败都必须执行。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 LoggingAspect.java 中添加</span></span><br><span class="line"><span class="meta">@After(&quot;calculatorServiceMethods()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfter</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;[@After] 方法 &quot;</span> + methodName + <span class="string">&quot; 执行结束。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当调用 <code>add(5, 3)</code> (成功) 或 <code>divide(10, 0)</code> (失败) 时，这行日志都会被打印。</strong></p>
<hr>
<h4 id="2-2-5-Around-环绕通知"><a href="#2-2-5-Around-环绕通知" class="headerlink" title="2.2.5 @Around (环绕通知)"></a>2.2.5 <code>@Around</code> (环绕通知)</h4><ul>
<li><strong>执行时机</strong>：它完全<strong>包裹</strong>了目标方法的执行。</li>
<li><strong>特点</strong>：<ul>
<li><strong>最强大、最灵活</strong>的通知类型。</li>
<li>方法的第一个参数必须是 <code>ProceedingJoinPoint</code> 类型。</li>
<li>你可以决定是否调用 <code>pjp.proceed()</code> 来<strong>执行目标方法</strong>。不调用它，目标方法就相当于被“拦截”了。</li>
<li>你可以在 <code>pjp.proceed()</code> 调用前后添加自定义逻辑。</li>
<li>你可以获取、修改参数，甚至可以捕获异常并返回一个不同的结果。</li>
</ul>
</li>
<li><strong>适用场景</strong>：事务管理、性能监控（计算方法执行时间）、缓存、方法重试机制。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 LoggingAspect.java 中添加</span></span><br><span class="line"><span class="meta">@Around(&quot;calculatorServiceMethods()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">profile</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;[@Around] &gt;&gt; 进入方法: &quot;</span> + pjp.getSignature().getName());</span><br><span class="line"></span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用这行代码才会真正执行目标方法</span></span><br><span class="line">        result = pjp.proceed();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[@Around] !! 捕获到异常: &quot;</span> + t.getMessage());</span><br><span class="line">        <span class="comment">// 决定是否将异常继续向上抛出</span></span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;[@Around] &lt;&lt; 退出方法: &quot;</span> + pjp.getSignature().getName() + <span class="string">&quot;。 执行耗时: &quot;</span> + (endTime - startTime) + <span class="string">&quot;ms。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须返回目标方法的执行结果，否则调用方会得到null</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当调用 <code>add(5, 3)</code> 时，输出将展示完整的环绕过程。</strong></p>
<hr>
<h4 id="2-2-6-执行顺序总结"><a href="#2-2-6-执行顺序总结" class="headerlink" title="2.2.6 执行顺序总结"></a>2.2.6 执行顺序总结</h4><p>当一个方法同时被多种通知作用时，其执行顺序（以<code>@Around</code>为中心）如下：</p>
<ol>
<li><strong><code>@Around</code></strong> (前半部分)</li>
<li><strong><code>@Before</code></strong></li>
<li><strong>目标方法执行</strong><ul>
<li><strong>如果成功:</strong><ol start="4">
<li><strong><code>@Around</code></strong> (后半部分，<code>proceed()</code>返回后)</li>
<li><strong><code>@AfterReturning</code></strong></li>
<li><strong><code>@After</code></strong></li>
</ol>
</li>
<li><strong>如果抛出异常:</strong><ol start="4">
<li><strong><code>@Around</code></strong> (进入<code>catch</code>块)</li>
<li><strong><code>@AfterThrowing</code></strong></li>
<li><strong><code>@After</code></strong></li>
</ol>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-3-通知顺序"><a href="#2-3-通知顺序" class="headerlink" title="2.3 通知顺序"></a>2.3 通知顺序</h3><h4 id="2-3-1-核心理念"><a href="#2-3-1-核心理念" class="headerlink" title="2.3.1 核心理念"></a>2.3.1 核心理念</h4><p>在Spring AOP中，当多个通知（Advice）应用到同一个连接点（JoinPoint，通常是方法）时，它们的执行顺序遵循一套明确的规则。理解这套规则对于编写健壮、可预测的AOP代码至关重要。</p>
<p>核心思想是 <strong>“洋葱模型”</strong> 或 <strong>“同心圆模型”</strong>。优先级高的切面在最外层，它最先开始执行，也最后结束执行。</p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant Client as 调用方
    participant Aspect_A as &quot;Aspect A (@Order(1))&quot;
    participant Aspect_B as &quot;Aspect B (@Order(2))&quot;
    participant Target as 目标方法

    Client-&gt;&gt;Aspect_A: 调用方法
    activate Aspect_A
    Note right of Aspect_A: 1. Aspect A 前置逻辑执行
    Aspect_A-&gt;&gt;Aspect_B: chain.proceed()
    activate Aspect_B
    Note right of Aspect_B: 2. Aspect B 前置逻辑执行
    Aspect_B-&gt;&gt;Target: chain.proceed()
    activate Target
    Note over Target: 3. 目标方法核心逻辑执行
    Target--&gt;&gt;Aspect_B: 方法返回
    deactivate Target
    Note right of Aspect_B: 4. Aspect B 后置逻辑执行
    Aspect_B--&gt;&gt;Aspect_A: 返回
    deactivate Aspect_B
    Note right of Aspect_A: 5. Aspect A 后置逻辑执行
    Aspect_A--&gt;&gt;Client: 最终结果返回
    deactivate Aspect_A</code></pre>

<hr>
<h4 id="2-3-2-具体情况"><a href="#2-3-2-具体情况" class="headerlink" title="2.3.2 具体情况"></a>2.3.2 具体情况</h4><h5 id="1-单一切面内的执行顺序"><a href="#1-单一切面内的执行顺序" class="headerlink" title="1. 单一切面内的执行顺序"></a>1. 单一切面内的执行顺序</h5><p>当只有一个切面类，并且它的多个不同类型的通知都匹配了同一个方法时，执行顺序是固定的。</p>
<p><strong>目标方法正常执行（无异常）</strong></p>
<p>执行顺序如下：</p>
<ol>
<li><code>@Around</code> 环绕通知（<code>proceed()</code> 方法之前的部分）</li>
<li><code>@Before</code> 前置通知</li>
<li><strong>目标方法执行</strong></li>
<li><code>@Around</code> 环绕通知（<code>proceed()</code> 方法之后的部分）</li>
<li><code>@AfterReturning</code> 返回通知</li>
<li><code>@After</code> 后置通知</li>
</ol>
<p><strong>目标方法抛出异常</strong></p>
<p>执行顺序如下：</p>
<ol>
<li><code>@Around</code> 环绕通知（<code>proceed()</code> 方法之前的部分）</li>
<li><code>@Before</code> 前置通知</li>
<li><strong>目标方法执行，并抛出异常</strong></li>
<li><code>@AfterThrowing</code> 异常通知</li>
<li><code>@After</code> 后置通知</li>
<li><code>@Around</code> 环绕通知会捕获到异常（如果在<code>try-catch</code>块中），然后决定是处理还是继续向外抛出。</li>
</ol>
<hr>
<h5 id="2-多个不同切面间的执行顺序"><a href="#2-多个不同切面间的执行顺序" class="headerlink" title="2. 多个不同切面间的执行顺序"></a>2. 多个不同切面间的执行顺序</h5><p>这是最常见的场景。当多个切面类中的通知都匹配了同一个方法时，<strong>切面类的顺序</strong>决定了通知的执行顺序。</p>
<p><strong>规则：使用 <code>@Order(数字)</code> 或实现 <code>Ordered</code> 接口</strong></p>
<ol>
<li><strong><code>@Order(数字)</code> 注解</strong>：加在切面类上。</li>
<li><strong><code>Ordered</code> 接口</strong>：让切面类实现 <code>org.springframework.core.Ordered</code> 接口，并重写 <code>getOrder()</code> 方法。<ul>
<li><strong>数字越小，优先级越高</strong>。<code>@Order(1)</code> 的优先级高于 <code>@Order(10)</code>。</li>
<li>如果没有指定顺序，则执行顺序是 <strong>未定义的（Undefined）</strong>。<strong>绝对不要</strong>依赖默认的类名字母顺序，因为它不可靠。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="3-同一切面内多个同类型通知的执行顺序"><a href="#3-同一切面内多个同类型通知的执行顺序" class="headerlink" title="3. 同一切面内多个同类型通知的执行顺序"></a>3. 同一切面内多个同类型通知的执行顺序</h5><p>当<strong>同一个切面类</strong>中，有<strong>多个同类型的通知</strong>（例如，两个<code>@Before</code>）都匹配了同一个方法。</p>
<p><strong>规则：未定义（Undefined）</strong></p>
<p>Spring AOP规范没有定义在同一个切面内同类型通知的执行顺序。你<strong>不能依赖</strong>它们在代码文件中的书写顺序。</p>
<p><strong>最佳实践</strong></p>
<p>如果多个逻辑之间确实存在顺序依赖，请遵循以下两种方式之一：</p>
<ol>
<li><strong>合并为一个通知方法</strong>：将所有逻辑按顺序写在同一个<code>@Before</code>方法体内，这是最简单的方式。</li>
<li><strong>拆分到不同的切面类中</strong>：将每个逻辑块放入一个独立的切面类中，然后使用<code>@Order</code>来精确控制这些切面类的执行顺序。这种方式更符合“单一职责原则”，代码结构更清晰。</li>
</ol>
<hr>
<h2 id="3-Pointcut表达式"><a href="#3-Pointcut表达式" class="headerlink" title="3. Pointcut表达式"></a>3. Pointcut表达式</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><ul>
<li><strong>本质</strong>：AOP的<strong>查询语言</strong>。</li>
<li><strong>作用</strong>：告诉 Spring AOP 具体的<strong>连接点</strong>在哪里（筛选出需要被增强的方法）。</li>
<li><strong>组成</strong>：由一个或多个**切点指示符（Pointcut Designators, PCD）**组成，可以通过逻辑运算符 <code>&amp;&amp;</code> (与), <code>||</code> (或), <code>!</code> (非) 进行组合。</li>
</ul>
<hr>
<h3 id="3-2-Pointcut-注解详解"><a href="#3-2-Pointcut-注解详解" class="headerlink" title="3.2 @Pointcut 注解详解"></a>3.2 <code>@Pointcut</code> 注解详解</h3><p>如果说切点表达式是复杂的<strong>SQL查询语句</strong>，那么 <code>@Pointcut</code> 注解就是给这条SQL语句起了一个<strong>变量名</strong>。</p>
<h4 id="3-2-1-基本语法"><a href="#3-2-1-基本语法" class="headerlink" title="3.2.1 基本语法"></a>3.2.1 基本语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 注解与表达式</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.example.service..*.*(..))&quot;)</span></span><br><span class="line"><span class="comment">// 2. 方法签名 (作为切点ID)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">businessLayer</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>它由两部分组成：</p>
<ol>
<li><strong>表达式</strong>：定义在 <code>@Pointcut(&quot;...&quot;)</code> 中，即具体的筛选规则。</li>
<li><strong>签名</strong>：一个<strong>返回值为void</strong>且<strong>方法体为空</strong>的普通Java方法。<strong>方法名</strong>就是这个切点的ID。</li>
</ol>
<hr>
<h4 id="3-2-2-为什么用它？"><a href="#3-2-2-为什么用它？" class="headerlink" title="3.2.2 为什么用它？"></a>3.2.2 为什么用它？</h4><ol>
<li><strong>复用性 (DRY原则)</strong>：<br>如果不使用 <code>@Pointcut</code>，你可能需要在五个不同的通知（Advice）里复制粘贴同一个长长的 <code>execution(...)</code> 字符串。一旦规则变化，你需要修改五处。使用 <code>@Pointcut</code>，只需修改一处。</li>
<li><strong>可读性</strong>：<br><code>businessLayer()</code> 显然比 <code>execution(* com.example.service..*.*(..))</code> 更能让人一眼看懂代码的意图。</li>
</ol>
<hr>
<h4 id="3-2-3-可见性原则"><a href="#3-2-3-可见性原则" class="headerlink" title="3.2.3 可见性原则"></a>3.2.3 可见性原则</h4><p>切点方法的<strong>访问修饰符</strong>决定了它能被谁引用：</p>
<ul>
<li><strong><code>private</code></strong>：仅在<strong>当前切面类</strong>中可见。</li>
<li><strong><code>public</code></strong>：在<strong>任何地方</strong>都可见。<ul>
<li><em>引用方式</em>：其他类引用时需要使用全限定名，如 <code>com.example.aspects.SystemArchitecture.businessLayer()</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-2-execution"><a href="#3-2-execution" class="headerlink" title="3.2 execution"></a>3.2 <code>execution</code></h3><p>这是功能最强大、使用频率最高（90%）的指示符，用于精确匹配<strong>方法签名</strong>。</p>
<h4 id="3-2-1-语法解构"><a href="#3-2-1-语法解构" class="headerlink" title="3.2.1 语法解构"></a>3.2.1 语法解构</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution([修饰符] 返回类型 包名.类名.方法名(参数类型) [异常])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>[]</code> 表示该部分是可选的。</li>
</ul>
<hr>
<h4 id="3-2-2-核心通配符"><a href="#3-2-2-核心通配符" class="headerlink" title="3.2.2 核心通配符"></a>3.2.2 核心通配符</h4><ul>
<li><strong><code>*</code> (星号)</strong>：匹配<strong>任意</strong>字符（一个元素）。<ul>
<li>用于返回类型：匹配任意返回值。</li>
<li>用于包&#x2F;类&#x2F;方法名：匹配名称的全部或部分。</li>
</ul>
</li>
<li><strong><code>..</code> (双点)</strong>：匹配<strong>多个</strong>元素。<ul>
<li>用于包名：表示<strong>当前包及其所有子包</strong>。</li>
<li>用于参数：表示<strong>0个或多个任意类型</strong>的参数。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-3-语法分解与示例"><a href="#3-2-3-语法分解与示例" class="headerlink" title="3.2.3 语法分解与示例"></a>3.2.3 语法分解与示例</h4><ul>
<li><strong><code>修饰符</code> (可选)</strong>: 如<code>public</code>, <code>protected</code>, <code>private</code>。通常省略，表示匹配所有修饰符。<ul>
<li><code>execution(public * *(..))</code> - 匹配所有<code>public</code>方法。</li>
</ul>
</li>
<li><strong><code>返回类型</code> (必选)</strong>:<ul>
<li><code>*</code> - 匹配任意返回类型。</li>
<li><code>void</code> - 匹配返回类型为<code>void</code>的方法。</li>
<li><code>java.lang.String</code> - 匹配返回类型为<code>String</code>的方法。</li>
</ul>
</li>
<li><strong><code>包名.类名.方法名</code> (包名和类名可选)</strong>:<ul>
<li><strong>完整匹配</strong>: <code>com.example.service.UserService.createUser</code></li>
<li><strong>类内所有方法</strong>: <code>com.example.service.UserService.*</code></li>
<li><strong>包内所有类的所有方法</strong>: <code>com.example.service.*.*</code></li>
<li><strong>包及其子包下所有类的所有方法</strong>: <code>com.example.service..*.*</code> ( <strong><code>..</code></strong> 在这里至关重要！)</li>
<li><strong>方法名通配符</strong>: <code>*</code> (所有方法), <code>get*</code> (所有以get开头的方法), <code>*ById</code> (所有以ById结尾的方法)。</li>
</ul>
</li>
<li><strong><code>参数类型</code> (必选)</strong>:<ul>
<li><code>()</code> - 匹配无参方法。</li>
<li><code>(..)</code> - 匹配任意数量、任意类型的参数 (<strong>最常用</strong>)。</li>
<li><code>(*)</code> - 匹配只有一个参数的方法，类型不限。</li>
<li><code>(String)</code> - 匹配只有一个<code>String</code>类型参数的方法。</li>
<li><code>(String, ..)</code> - 匹配第一个参数是<code>String</code>，后面有任意数量、任意类型参数的方法。</li>
</ul>
</li>
<li><strong><code>异常</code> (可选)</strong>: <code>throws</code>子句，匹配抛出特定异常的方法。很少使用。</li>
</ul>
<hr>
<h4 id="3-2-4-常用写法速查"><a href="#3-2-4-常用写法速查" class="headerlink" title="3.2.4 常用写法速查"></a>3.2.4 常用写法速查</h4><table>
<thead>
<tr>
<th align="left">匹配范围</th>
<th align="left">表达式写法</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>指定方法</strong></td>
<td align="left"><code>execution(* com.demo.Svc.add(..))</code></td>
<td align="left">任意返回值，<code>Svc</code>类下的<code>add</code>方法，参数不限</td>
</tr>
<tr>
<td align="left"><strong>包下所有类</strong></td>
<td align="left"><code>execution(* com.demo.svc.*.*(..))</code></td>
<td align="left"><code>svc</code>包（<strong>不含子包</strong>）下所有类的所有方法</td>
</tr>
<tr>
<td align="left"><strong>包及子包</strong></td>
<td align="left"><code>execution(* com.demo.svc..*.*(..))</code></td>
<td align="left"><code>svc</code>包及其<strong>所有子包</strong>下所有类的所有方法</td>
</tr>
<tr>
<td align="left"><strong>特定前缀</strong></td>
<td align="left"><code>execution(* *..get*(..))</code></td>
<td align="left">任意包下，所有以<code>get</code>开头的方法</td>
</tr>
<tr>
<td align="left"><strong>特定参数</strong></td>
<td align="left"><code>execution(* *..find(String, ..))</code></td>
<td align="left">第一个参数必须是<code>String</code>，后续参数不限</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-3-within"><a href="#3-3-within" class="headerlink" title="3.3 within"></a>3.3 <code>within</code></h3><p>用于匹配<strong>指定类型（类&#x2F;接口）或包</strong>内的所有方法。</p>
<p>它的粒度比 <code>execution</code> 粗，不关心方法的具体名称或参数，只关心<strong>它属于哪个类</strong>。</p>
<ul>
<li><strong>语法</strong>：<ul>
<li><code>within(com.example.service.UserServiceImpl)</code>：仅匹配该特定类。</li>
<li><code>within(com.example.service.*)</code>：匹配包下所有类（不含子包）。</li>
<li><code>within(com.example.service..*)</code>：匹配包及其子包下所有类。</li>
</ul>
</li>
</ul>
<blockquote>
<p>“<em><strong>对比</strong>：<code>within</code> 像是粗略的“地理范围筛选”，而 <code>execution</code> 是精确的“户籍指纹筛选”。通常 <code>execution</code> 更常用。</em>“</p>
</blockquote>
<hr>
<h3 id="3-4-annotation"><a href="#3-4-annotation" class="headerlink" title="3.4 @annotation"></a>3.4 <code>@annotation</code></h3><p>这是现代Spring开发中最优雅的方式。它不匹配类名，而是匹配<strong>方法上的注解</strong>。</p>
<p><strong>场景</strong>：我不管你在哪个包，只要你的方法头上顶着 <code>@Loggable</code> 注解，我就拦截你。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Loggable &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 业务方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Loggable</span> <span class="comment">// &lt;--- 目标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 切点表达式</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@annotation(com.example.annotation.Loggable)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loggablePointcut</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-5-within"><a href="#3-5-within" class="headerlink" title="3.5 @within"></a>3.5 <code>@within</code></h3><ul>
<li><strong><code>@annotation</code></strong>：匹配<strong>方法级别</strong>的注解（Target是方法）。</li>
<li><strong><code>@within</code></strong>：匹配<strong>类级别</strong>的注解（Target是类）。</li>
</ul>
<p><strong>场景</strong>：只要一个类被标记了 <code>@Secured</code>，那么这个类里面的<strong>所有方法</strong>都会被拦截。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Secured</span> <span class="comment">// &lt;--- 类级别注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;&#125; <span class="comment">// 自动匹配</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;&#125; <span class="comment">// 自动匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切点表达式</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@within(com.example.annotation.Secured)&quot;)</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-6-bean"><a href="#3-6-bean" class="headerlink" title="3.6 bean"></a>3.6 <code>bean</code></h3><p>Spring 特有的指示符，直接根据 <strong>Bean ID (名称)</strong> 进行筛选。</p>
<ul>
<li><code>bean(&quot;userService&quot;)</code>：匹配 ID 为 <code>userService</code> 的 Bean。</li>
<li><code>bean(&quot;*Service&quot;)</code>：匹配所有 ID 以 <code>Service</code> 结尾的 Bean。</li>
</ul>
<hr>
<h3 id="3-7-最佳实践"><a href="#3-7-最佳实践" class="headerlink" title="3.7 最佳实践"></a>3.7 最佳实践</h3><p>不要编写又长又难懂的单行表达式。建议使用 <code>@Pointcut</code> 定义<strong>基础切点</strong>，然后像搭积木一样通过逻辑运算<strong>组合</strong>它们。</p>
<p><strong>示例</strong>：只拦截 <code>Service</code> 层中被标记为 <code>@Transactional</code> 的 <code>public</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionLogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 基础积木 ---</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 范围限定：Service包及其子包</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;within(com.example.service..*)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inServiceLayer</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 注解限定：带有@Transactional注解</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(org.springframework.transaction.annotation.Transactional)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isTransactional</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 权限限定：Public方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * *(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isPublic</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 组合使用 ---</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 语义清晰：在Service层 AND 是事务方法 AND 是Public方法</span></span><br><span class="line">    <span class="meta">@Before(&quot;inServiceLayer() &amp;&amp; isTransactional() &amp;&amp; isPublic()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logTransactionStart</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;事务开始...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-8-总结"><a href="#3-8-总结" class="headerlink" title="3.8 总结"></a>3.8 总结</h3><table>
<thead>
<tr>
<th align="left">指示符</th>
<th align="left">作用域</th>
<th align="left">典型用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>execution</code></strong></td>
<td align="left"><strong>方法签名</strong></td>
<td align="left"><strong>最通用</strong>，可精确控制修饰符、返回值、方法名、参数。</td>
</tr>
<tr>
<td align="left"><strong><code>@annotation</code></strong></td>
<td align="left"><strong>方法注解</strong></td>
<td align="left"><strong>最灵活</strong>，侵入性小，标记哪里拦截哪里。</td>
</tr>
<tr>
<td align="left"><code>within</code></td>
<td align="left">类&#x2F;包</td>
<td align="left">粗粒度筛选，通常用于限定层级（如“所有Controller层”）。</td>
</tr>
<tr>
<td align="left"><code>@within</code></td>
<td align="left">类注解</td>
<td align="left">当需要对整个类的所有方法统一处理时使用。</td>
</tr>
<tr>
<td align="left"><code>bean</code></td>
<td align="left">Bean名称</td>
<td align="left">处理特定命名的Bean，遗留系统或特定场景使用。</td>
</tr>
<tr>
<td align="left"><code>args</code></td>
<td align="left">参数类型</td>
<td align="left">用于运行时动态匹配参数类型（通常结合其他指示符使用）。</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-连接点"><a href="#4-连接点" class="headerlink" title="4. 连接点"></a>4. 连接点</h2><p>当我们定义一个通知（Advice）时，可以声明一个<code>org.aspectj.lang.JoinPoint</code>类型的参数，Spring容器会自动将与该切点匹配的连接点信息注入进来。通过这个对象，我们可以在运行时获取到大量关于方法执行的上下文信息。</p>
<h3 id="4-1-JoinPoint"><a href="#4-1-JoinPoint" class="headerlink" title="4.1 JoinPoint"></a>4.1 <code>JoinPoint</code></h3><h4 id="4-1-1-获取方法签名信息-getSignature"><a href="#4-1-1-获取方法签名信息-getSignature" class="headerlink" title="4.1.1 获取方法签名信息 getSignature()"></a>4.1.1 获取方法签名信息 <code>getSignature()</code></h4><p>这是最核心和最常用的方法，它返回一个<code>Signature</code>对象，包含了被拦截方法的详细信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br></pre></td></tr></table></figure>

<p><code>Signature</code>对象本身有很多有用的方法：</p>
<ul>
<li><p><strong><code>String getName()</code></strong>: 获取被拦截的方法名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName(); <span class="comment">// 例如：&quot;addUser&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>Class getDeclaringType()</code></strong>: 获取方法所属的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">declaringType</span> <span class="operator">=</span> signature.getDeclaringType(); <span class="comment">// 例如：class com.example.service.UserService</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>String getDeclaringTypeName()</code></strong>: 获取方法所属类的全限定名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">declaringTypeName</span> <span class="operator">=</span> signature.getDeclaringTypeName(); <span class="comment">// 例如：&quot;com.example.service.UserService&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>int getModifiers()</code></strong>: 获取方法的修饰符，返回的是一个代表修饰符的整数（例如 <code>public</code>, <code>static</code>）。可以使用 <code>java.lang.reflect.Modifier.toString()</code> 来转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> signature.getModifiers();</span><br><span class="line">System.out.println(Modifier.toString(modifiers)); <span class="comment">// 例如：&quot;public&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>String toShortString()</code></strong>: 返回一个简短的方法签名描述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">shortString</span> <span class="operator">=</span> signature.toShortString(); <span class="comment">// 例如：&quot;UserService.addUser(..)&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>String toLongString()</code></strong>: 返回一个详细的方法签名描述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">longString</span> <span class="operator">=</span> signature.toLongString(); <span class="comment">// 例如：&quot;public void com.example.service.UserService.addUser(com.example.model.User)&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-1-2-获取方法参数-getArgs"><a href="#4-1-2-获取方法参数-getArgs" class="headerlink" title="4.1.2 获取方法参数 getArgs()"></a>4.1.2 获取方法参数 <code>getArgs()</code></h4><p>获取传递给被拦截方法的参数数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object[] args = joinPoint.getArgs();</span><br><span class="line"><span class="comment">// 你可以遍历或直接访问参数</span></span><br><span class="line"><span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;参数: &quot;</span> + arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-1-3-获取目标和代理对象"><a href="#4-1-3-获取目标和代理对象" class="headerlink" title="4.1.3 获取目标和代理对象"></a>4.1.3 获取目标和代理对象</h4><ul>
<li><p><strong><code>Object getTarget()</code></strong>: 获取被代理的 <strong>目标对象</strong>（原始的Bean对象）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> joinPoint.getTarget(); <span class="comment">// 例如：UserServiceImpl 实例</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>Object getThis()</code></strong>: 获取 <strong>代理对象</strong> 本身。通常是CGLIB或JDK动态代理生成的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> joinPoint.getThis(); <span class="comment">// 例如：UserServiceImpl$$EnhancerBySpringCGLIB$$... 实例</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<code>getTarget()</code> 和 <code>getThis()</code> 返回的对象通常是不同的。<code>getTarget()</code> 是原始的业务逻辑类，而 <code>getThis()</code> 是Spring为了实现AOP而创建的代理类实例。</p>
</li>
</ul>
<hr>
<h4 id="4-1-4-其他静态信息"><a href="#4-1-4-其他静态信息" class="headerlink" title="4.1.4 其他静态信息"></a>4.1.4 其他静态信息</h4><ul>
<li><strong><code>StaticPart getStaticPart()</code></strong>: 提供对连接点的静态部分的访问，功能与 <code>getSignature()</code> 类似，但提供了更通用的Aspect静态信息。</li>
<li><strong><code>String getKind()</code></strong>: 获取连接点的类型。在Spring AOP中，这个值通常是 <code>method-execution</code>。</li>
</ul>
<hr>
<h3 id="4-2-ProceedingJoinPoint-仅适用于-Around环绕通知"><a href="#4-2-ProceedingJoinPoint-仅适用于-Around环绕通知" class="headerlink" title="4.2 ProceedingJoinPoint (仅适用于@Around环绕通知)"></a>4.2 <code>ProceedingJoinPoint</code> (仅适用于<code>@Around</code>环绕通知)</h3><p><code>ProceedingJoinPoint</code> 继承自 <code>JoinPoint</code>，因此它拥有上述所有方法。除此之外，它增加了一个至关重要的核心方法，用于控制目标方法的执行。</p>
<h4 id="4-2-1-Object-proceed-和-Object-proceed-Object-args"><a href="#4-2-1-Object-proceed-和-Object-proceed-Object-args" class="headerlink" title="4.2.1 Object proceed() 和 Object proceed(Object[] args)"></a>4.2.1 <code>Object proceed()</code> 和 <code>Object proceed(Object[] args)</code></h4><p>这是<code>ProceedingJoinPoint</code>的专属方法，也是<code>@Around</code>通知如此强大的原因。</p>
<ul>
<li><strong><code>Object proceed()</code></strong>: 执行目标方法。调用此方法会触发目标方法的执行。其返回值就是目标方法的返回值。</li>
<li><strong><code>Object proceed(Object[] args)</code></strong>: 执行目标方法，并使用新的参数数组替换原有的参数。这允许你在执行目标方法前修改传入的参数。</li>
</ul>
<p><strong>核心作用</strong>:</p>
<ol>
<li><strong>执行控制</strong>: 你可以决定是否调用<code>proceed()</code>方法。如果不调用，目标方法将永远不会被执行。</li>
<li><strong>参数修改</strong>: 在调用<code>proceed(newArgs)</code>之前，可以修改参数。</li>
<li><strong>返回值修改</strong>: <code>proceed()</code>方法调用结束后，可以获取到原始返回值，并对其进行修改或替换，然后返回一个新的值。</li>
<li><strong>异常处理</strong>: 可以使用 <code>try-catch</code> 块来捕获目标方法抛出的异常，并进行处理或包装后重新抛出。</li>
</ol>
<p>一个典型的<code>@Around</code>通知结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;环绕通知：方法 &quot;</span> + pjp.getSignature().getName() + <span class="string">&quot; 开始执行...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行目标方法</span></span><br><span class="line">        result = pjp.proceed(); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 甚至可以在这里修改返回值</span></span><br><span class="line">        <span class="comment">// if (result instanceof String) &#123;</span></span><br><span class="line">        <span class="comment">//     result = &quot;Modified: &quot; + result;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知：方法 &quot;</span> + pjp.getSignature().getName() + <span class="string">&quot; 发生异常...&quot;</span>);</span><br><span class="line">        <span class="comment">// 决定是否向上抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> throwable; </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知：方法 &quot;</span> + pjp.getSignature().getName() + <span class="string">&quot; 执行结束，耗时：&quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-AOP实现原理"><a href="#5-AOP实现原理" class="headerlink" title="5. AOP实现原理"></a>5. AOP实现原理</h2><p>在Java笔记的第三章中我们详细介绍过了JDK与CGLIB，这里重点关注它们在 Spring AOP 中的应用以及 Spring 如何在容器启动时完成增强。</p>
<h3 id="5-1-JDK动态代理-“基于接口的伪装者”"><a href="#5-1-JDK动态代理-“基于接口的伪装者”" class="headerlink" title="5.1 JDK动态代理 - “基于接口的伪装者”"></a>5.1 JDK动态代理 - “基于接口的伪装者”</h3><ul>
<li><strong>核心机制</strong>：<strong>实现共同的接口</strong>。</li>
<li><strong>工作方式</strong>：Spring创建一个代理类，这个代理类和你真正的业务类（目标类）<strong>实现了相同的接口</strong>。当客户端代码调用接口方法时，实际上调用的是代理对象的方法。代理对象内部的<code>InvocationHandler</code>会先执行切面逻辑（Advice），然后再通过<strong>反射</strong>调用你真正的业务对象的方法。</li>
<li><strong>限制</strong>：你的业务类<strong>必须实现一个接口</strong>。Spring AOP只会代理接口中定义的方法，业务类中自己特有的方法不会被代理。</li>
<li><strong>Spring中的默认行为</strong>：如果一个Bean实现了至少一个接口，Spring AOP<strong>默认</strong>会选用JDK动态代理。</li>
</ul>
<p><strong>一句话总结：客户端面向接口编程，得到的是一个接口的“冒牌”实现类，这个冒牌货在完成核心任务前后会加一些额外的动作。</strong></p>
<hr>
<h3 id="5-2-CGLIB动态代理-“基于继承的增强者”"><a href="#5-2-CGLIB动态代理-“基于继承的增强者”" class="headerlink" title="5.2 CGLIB动态代理 - “基于继承的增强者”"></a>5.2 CGLIB动态代理 - “基于继承的增强者”</h3><ul>
<li><strong>核心机制</strong>：<strong>创建子类</strong>。</li>
<li><strong>工作方式</strong>：Spring使用CGLIB库，在运行时动态地创建一个你业务类（目标类）的<strong>子类</strong>作为代理。这个子类会<strong>重写</strong>父类中所有非<code>final</code>的方法。当调用这些方法时，子类中的<code>MethodInterceptor</code>会先执行切面逻辑，然后再调用父类（即你真正的业务对象）的原始方法。</li>
<li><strong>限制</strong>：你的业务类<strong>不能是 <code>final</code> 的</strong>，被代理的方法也<strong>不能是 <code>final</code> 的</strong>，否则子类无法继承或重写。</li>
<li><strong>Spring中的默认行为</strong>：如果一个Bean<strong>没有实现任何接口</strong>，Spring AOP<strong>别无选择</strong>，只能使用CGLIB。</li>
</ul>
<p><strong>一句话总结：客户端得到的是一个业务类的“增强版”子类，这个子类在调用从父类继承来的方法时，会加入额外的切面逻辑。</strong></p>
<hr>
<h3 id="5-3-Spring-Boot中的选择与演变"><a href="#5-3-Spring-Boot中的选择与演变" class="headerlink" title="5.3 Spring Boot中的选择与演变"></a>5.3 Spring Boot中的选择与演变</h3><ul>
<li><strong>SpringBoot 2.x 及以后，默认倾向于使用CGLIB</strong>。<ul>
<li>在<code>spring-boot-starter-aop</code>中，默认配置 <code>spring.aop.proxy-target-class=true</code>。</li>
<li>这意味着，<strong>无论你的Bean是否实现了接口，SpringBoot都默认优先使用CGLIB来创建代理</strong>。</li>
</ul>
</li>
<li><strong>为什么会有这个变化？</strong><ol>
<li><strong>避免类型转换异常</strong>：CGLIB 代理是目标类的子类，既可以被当作接口使用，也可以被强转为具体类。而 JDK 代理只能转为接口，转为具体类会报错。</li>
<li><strong>方法内调用问题</strong>：虽然 AOP 仍然解决不了对象内部方法自调用的拦截问题，但 CGLIB 的表现相对更符合面向对象的直觉。</li>
<li><strong>性能差异忽略不计</strong>：在现代 JDK 版本中，两者的性能差距已微乎其微。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="5-4-核心机制：Spring-如何在启动时“偷梁换柱”？"><a href="#5-4-核心机制：Spring-如何在启动时“偷梁换柱”？" class="headerlink" title="5.4 核心机制：Spring 如何在启动时“偷梁换柱”？"></a>5.4 核心机制：Spring 如何在启动时“偷梁换柱”？</h3><p>你可能会好奇：<em>我在代码里写的是 <code>@Autowired UserServiceImpl</code>，为什么程序运行起来拿到的却是一个代理对象？</em></p>
<p>这归功于 Spring 的 <strong>BeanPostProcessor (Bean后置处理器)</strong> 机制。</p>
<p><strong>1. 关键组件：<code>AnnotationAwareAspectJAutoProxyCreator</code></strong></p>
<p>这是一个特殊的 Bean 后置处理器。在 Spring 容器启动时，它负责“监听”所有 Bean 的创建过程。</p>
<p><strong>2. 织入流程 (Weaving Process)</strong></p>
<p>当 Spring 容器初始化一个 Bean 时，大致经过以下步骤：</p>
<ol>
<li><strong>实例化 (Instantiation)</strong>：<br>Spring 根据 Bean 定义，使用 <code>new</code> 关键字或者构造器反射，创建出<strong>原始对象 (Target)</strong>。</li>
<li><strong>属性赋值 (Populate)</strong>：<br>Spring 为这个原始对象注入依赖（如 <code>@Autowired</code>）。</li>
<li><strong>初始化 (Initialization)</strong>：<br>执行初始化方法（如 <code>@PostConstruct</code>）。</li>
<li><strong>后置处理 (Post-Processing) —— AOP 发生的时刻！</strong><ul>
<li>在 Bean 初始化之后，<code>AutoProxyCreator</code> 介入。</li>
<li><strong>匹配检查</strong>：它会遍历所有定义的切面（Aspect），检查当前这个 Bean 的方法是否符合任何一个切点表达式（Pointcut）。</li>
<li><strong>创建代理</strong>：如果<strong>符合</strong>，Spring 就不会把原始对象放入容器，而是根据前文所述规则（JDK 或 CGLIB）创建一个<strong>代理对象 (Proxy)</strong>。这个代理对象内部持有了原始对象。</li>
<li><strong>替换返回</strong>：Spring 将这个<strong>代理对象</strong>返回给容器，放入单例池中。</li>
</ul>
</li>
</ol>
<p><strong>3. 最终结果</strong></p>
<p>容器中实际存储的、以及注入给其他组件的，都是这个<strong>代理对象</strong>。当你调用它的方法时，其实是代理对象在拦截并增强逻辑。</p>
<pre><code class="highlight mermaid">graph LR
    A[1.创建原始对象&lt;br/&gt;Raw Bean] --&gt; B[2.属性注入 &amp; 初始化]
    B --&gt; C&#123;3.后置处理器检查&lt;br/&gt;是否匹配切点?&#125;
    
    C -- 否 (No Match) --&gt; D[4a.返回原始对象]
    C -- 是 (Match) --&gt; E[4b.创建代理对象&lt;br/&gt;Proxy]
    E --&gt; F[5.放入Spring容器]
    D --&gt; F
    
    style E fill:#f96,stroke:#333</code></pre>

<hr>
<h3 id="5-5-核心回顾表"><a href="#5-5-核心回顾表" class="headerlink" title="5.5 核心回顾表"></a>5.5 核心回顾表</h3><table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left">JDK动态代理</th>
<th align="left">CGLIB动态代理</th>
<th align="left">Spring Boot默认</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心原理</strong></td>
<td align="left">实现接口</td>
<td align="left">继承父类</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><strong>目标要求</strong></td>
<td align="left">必须有接口</td>
<td align="left">不能是final类&#x2F;方法</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><strong>代理对象类型</strong></td>
<td align="left"><code>com.sun.proxy.$ProxyX</code></td>
<td align="left"><code>TargetClass$$EnhancerByCGLIB$$...</code></td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><strong>生效时机</strong></td>
<td align="left"><strong>Bean初始化后的后置处理阶段 (<code>postProcessAfterInitialization</code>)</strong></td>
<td align="left">&lt;- 同左</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><strong>Spring选择</strong></td>
<td align="left">目标<strong>有</strong>接口时默认使用</td>
<td align="left">目标<strong>无</strong>接口时使用</td>
<td align="left"><strong>优先使用CGLIB</strong></td>
</tr>
</tbody></table>
<hr>
<hr>
<h1 id="五、事务管理"><a href="#五、事务管理" class="headerlink" title="五、事务管理"></a>五、事务管理</h1><h2 id="1-核心概念与抽象"><a href="#1-核心概念与抽象" class="headerlink" title="1. 核心概念与抽象"></a>1. 核心概念与抽象</h2><p>在没有 Spring 之前，如果你从 JDBC 切换到 Hibernate，你的事务代码必须重写，因为两者的 API 完全不同。Spring 通过定义一组<strong>顶层接口</strong>，实现了“一次编写，到处运行”的事务管理。</p>
<h3 id="1-1-什么是事务？"><a href="#1-1-什么是事务？" class="headerlink" title="1.1 什么是事务？"></a>1.1 什么是事务？</h3><ul>
<li><strong>原生 JDBC 的痛苦</strong>：你需要管理 <code>Connection</code>，手动调用 <code>conn.setAutoCommit(false)</code>，<code>conn.commit()</code>，并且要把 <code>conn</code> 传递给 DAO 层，代码耦合度极高。</li>
<li><strong>技术差异</strong>：<ul>
<li>JDBC 用 <code>Connection</code> 管理事务。</li>
<li>Hibernate 用 <code>Session</code> 管理事务。</li>
<li>JPA 用 <code>EntityManager</code> 管理事务。</li>
</ul>
</li>
<li><strong>Spring 的策略</strong>：Spring 定义了一套<strong>通用的事务接口</strong>。你的业务代码只跟 Spring 的接口打交道，而 Spring 的接口负责去指挥底下具体的 JDBC 或 Hibernate。</li>
</ul>
<hr>
<h3 id="1-2-Spring-事务三大核心接口"><a href="#1-2-Spring-事务三大核心接口" class="headerlink" title="1.2 Spring 事务三大核心接口"></a>1.2 Spring 事务三大核心接口</h3><p>Spring 的事务管理体系主要依赖于三个核心接口。理清它们的关系，你就理解了 Spring 事务的本质。</p>
<h4 id="1-2-1-PlatformTransactionManager-平台事务管理器"><a href="#1-2-1-PlatformTransactionManager-平台事务管理器" class="headerlink" title="1.2.1 PlatformTransactionManager (平台事务管理器)"></a>1.2.1 <code>PlatformTransactionManager</code> (平台事务管理器)</h4><p><strong>地位</strong>：核心中的核心，事务的<strong>执行者</strong>。</p>
<p><strong>作用</strong>：它定义了事务操作的基本行为（获取、提交、回滚）。</p>
<p><strong>核心方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> &#123;</span><br><span class="line">    <span class="comment">// 根据定义信息（Definition），开启或获取一个事务，返回事务状态（Status）</span></span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(TransactionDefinition definition)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回滚事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>常见实现类</strong> (根据你使用的持久层技术选择)：</p>
<table>
<thead>
<tr>
<th align="left">实现类</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>DataSourceTransactionManager</code></strong></td>
<td align="left"><strong>最常用</strong>。适用于 <strong>JDBC</strong> (JdbcTemplate) 和 <strong>MyBatis</strong>。</td>
</tr>
<tr>
<td align="left"><code>JpaTransactionManager</code></td>
<td align="left">适用于 <strong>JPA</strong> (Hibernate) 框架。</td>
</tr>
<tr>
<td align="left"><code>HibernateTransactionManager</code></td>
<td align="left">适用于原生 Hibernate 框架。</td>
</tr>
<tr>
<td align="left"><code>JtaTransactionManager</code></td>
<td align="left">适用于分布式事务（跨数据库&#x2F;JTA规范）。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>配置提示</strong>：在 Spring Boot 中，引入 <code>spring-boot-starter-jdbc</code> 会自动配置 <code>DataSourceTransactionManager</code>；引入 <code>spring-boot-starter-data-jpa</code> 会自动配置 <code>JpaTransactionManager</code>。</p>
</blockquote>
<hr>
<h4 id="1-2-2-TransactionDefinition-事务定义信息"><a href="#1-2-2-TransactionDefinition-事务定义信息" class="headerlink" title="1.2.2 TransactionDefinition (事务定义信息)"></a>1.2.2 <code>TransactionDefinition</code> (事务定义信息)</h4><p><strong>地位</strong>：事务的<strong>配置图纸</strong>。</p>
<p><strong>作用</strong>：它描述了我们希望这个事务**“长什么样”**。</p>
<p>它主要包含了事务的五大属性（后续章节会详细展开）：</p>
<ol>
<li><strong>Isolation (隔离级别)</strong>：决定了一个事务可能受其他并发事务影响的程度（如：是否允许脏读）。</li>
<li><strong>Propagation (传播行为)</strong>：决定了当一个事务方法被另一个事务方法调用时，该如何处理（如：加入现有事务，还是开启新事务）。</li>
<li><strong>Timeout (超时时间)</strong>：事务运行的最长时间，超时则回滚。</li>
<li><strong>Read-Only (是否只读)</strong>：如果是只读事务，数据库可以做特定优化。</li>
<li><strong>Name (事务名称)</strong>：通常用于监控和日志。</li>
</ol>
<p><strong>一句话理解</strong>：<code>TransactionDefinition</code> 就是你写在 <code>@Transactional(...)</code> 注解括号里的那些参数。</p>
<hr>
<h4 id="1-2-3-TransactionStatus-事务状态"><a href="#1-2-3-TransactionStatus-事务状态" class="headerlink" title="1.2.3 TransactionStatus (事务状态)"></a>1.2.3 <code>TransactionStatus</code> (事务状态)</h4><p><strong>地位</strong>：事务的<strong>监控器&#x2F;存档</strong>。</p>
<p><strong>作用</strong>：它代表了事务运行过程中的<strong>当前状态</strong>。</p>
<p>当事务管理器开启一个事务后，会返回一个 <code>TransactionStatus</code> 对象。在这个事务的生命周期内，Spring 用它来记录和控制事务。</p>
<p><strong>核心方法</strong>：</p>
<ul>
<li><code>isNewTransaction()</code>: 当前是否是一个新的事务（还是加入到了已有事务中）。</li>
<li><code>hasSavepoint()</code>: 是否包含保存点（用于嵌套事务）。</li>
<li><strong><code>setRollbackOnly()</code></strong>: <strong>非常重要</strong>。将事务标记为“仅回滚”。一旦设置，即使后续代码没有抛出异常，事务最终提交时也会强制回滚。</li>
<li><code>isCompleted()</code>: 事务是否已结束。</li>
</ul>
<hr>
<h4 id="1-2-4-三者协作关系图"><a href="#1-2-4-三者协作关系图" class="headerlink" title="1.2.4 三者协作关系图"></a>1.2.4 三者协作关系图</h4><p>我们可以把这三个接口的关系理解为：</p>
<p><strong>“经理 (Manager) 拿着 图纸 (Definition) 去干活，干活的过程中生成了 进度单 (Status)。”</strong></p>
<pre><code class="highlight mermaid">graph TD
    User[&quot;用户代码&lt;br/&gt;(@Transactional 或 编程式)&quot;]
    
    subgraph &quot;Spring Transaction Abstraction&quot;
        Definition[&quot;&lt;b&gt;TransactionDefinition&lt;/b&gt;&lt;br/&gt;(配置: 隔离级别, 传播行为...)&quot;]
        Manager[&quot;&lt;b&gt;PlatformTransactionManager&lt;/b&gt;&lt;br/&gt;(执行者: DataSourceTM / JpaTM)&quot;]
        Status[&quot;&lt;b&gt;TransactionStatus&lt;/b&gt;&lt;br/&gt;(状态: 新事务? 仅回滚?)&quot;]
    end
    
    DB[(&quot;具体数据库&lt;br/&gt;(Connection / Session)&quot;)]

    User -- &quot;1.提供配置&quot; --&gt; Definition
    User -- &quot;2.请求开启事务&quot; --&gt; Manager
    Manager -- &quot;3.读取配置&quot; --&gt; Definition
    Manager -- &quot;4.操作底层连接&quot; --&gt; DB
    Manager -- &quot;5.生成/返回&quot; --&gt; Status
    
    note[User持有Status&lt;br/&gt;用于后续提交或回滚]
    User -.-&gt; Status

    style Manager fill:#f9f,stroke:#333
    style Definition fill:#ccf,stroke:#333
    style Status fill:#cfc,stroke:#333</code></pre>

<hr>
<h4 id="1-2-5-总结"><a href="#1-2-5-总结" class="headerlink" title="1.2.5 总结"></a>1.2.5 总结</h4><table>
<thead>
<tr>
<th align="left">接口名</th>
<th align="left">角色</th>
<th align="left">类比</th>
<th align="left">关键点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>PlatformTransactionManager</strong></td>
<td align="left"><strong>执行者</strong></td>
<td align="left">司机</td>
<td align="left">这是一个接口，根据使用 MyBatis 还是 JPA 选择不同的实现类。</td>
</tr>
<tr>
<td align="left"><strong>TransactionDefinition</strong></td>
<td align="left"><strong>规则&#x2F;配置</strong></td>
<td align="left">导航仪</td>
<td align="left">定义了怎么走（隔离级别、传播行为、超时）。</td>
</tr>
<tr>
<td align="left"><strong>TransactionStatus</strong></td>
<td align="left"><strong>状态&#x2F;存档</strong></td>
<td align="left">仪表盘</td>
<td align="left">记录当前开的是不是新车（新事务），有没有故障（RollbackOnly）。</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-编程式事务管理"><a href="#2-编程式事务管理" class="headerlink" title="2. 编程式事务管理"></a>2. 编程式事务管理</h2><blockquote>
<p><strong>“硬编码”方式</strong>：在代码中显式调用 <code>commit</code> 和 <code>rollback</code>。虽然繁琐，但粒度控制最细。</p>
</blockquote>
<h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><ul>
<li><strong>定义</strong>：在代码中显式调用 <code>beginTransaction</code>、<code>commit</code>、<code>rollback</code> 等方法来管理事务。</li>
<li><strong>特点</strong>：<strong>硬编码</strong>。事务管理代码与业务代码混杂在一起。</li>
<li><strong>适用场景</strong>：<ol>
<li><strong>控制粒度</strong>：<code>@Transactional</code> 只能加在方法上（或类上），这意味着整个方法都在事务中。如果你只想让方法中的<strong>某三行代码</strong>开启事务（为了减少数据库锁定时间），就需要用编程式事务。</li>
<li><strong>动态性</strong>：需要根据运行时的逻辑动态决定是否开启事务，或者动态指定事务管理器。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-2-使用-PlatformTransactionManager-底层方式"><a href="#2-2-使用-PlatformTransactionManager-底层方式" class="headerlink" title="2.2 使用 PlatformTransactionManager (底层方式)"></a>2.2 使用 <code>PlatformTransactionManager</code> (底层方式)</h3><p>这是最原始的方式，直接操作我们在第一章介绍的“核心执行者”。这种方式代码冗余度高，类似于使用原生 JDBC，<strong>不推荐日常使用</strong>，但了解它有助于理解原理。</p>
<h4 id="2-2-1-流程步骤"><a href="#2-2-1-流程步骤" class="headerlink" title="2.2.1 流程步骤"></a>2.2.1 流程步骤</h4><ol>
<li>注入事务管理器 (<code>PlatformTransactionManager</code>)。</li>
<li>创建事务定义 (<code>DefaultTransactionDefinition</code>)，设置隔离级别等。</li>
<li>获取事务状态 (<code>TransactionStatus</code>)，此时事务开启。</li>
<li>执行业务逻辑（放在 <code>try</code> 块中）。</li>
<li>成功则调用 <code>manager.commit(status)</code>。</li>
<li>失败则调用 <code>manager.rollback(status)</code>。</li>
</ol>
<h4 id="2-2-2-代码示例"><a href="#2-2-2-代码示例" class="headerlink" title="2.2.2 代码示例"></a>2.2.2 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager transactionManager; <span class="comment">// 注入事务管理器</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderDao orderDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 定义事务属性 (默认传播行为和隔离级别)</span></span><br><span class="line">        <span class="type">DefaultTransactionDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">        def.setName(<span class="string">&quot;CreateOrderTransaction&quot;</span>);</span><br><span class="line">        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 开启事务，获取事务状态</span></span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> transactionManager.getTransaction(def);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 执行业务逻辑</span></span><br><span class="line">            orderDao.save(order);</span><br><span class="line">            orderDao.updateStock(order.getProductId());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 提交事务</span></span><br><span class="line">            transactionManager.commit(status);</span><br><span class="line">            System.out.println(<span class="string">&quot;事务提交成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 5. 回滚事务</span></span><br><span class="line">            transactionManager.rollback(status);</span><br><span class="line">            System.out.println(<span class="string">&quot;发生异常，事务回滚&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> e; <span class="comment">// 继续抛出异常通知上层</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺点</strong>：</p>
<ul>
<li><strong>样板代码多</strong>：每个需要事务的方法都要写一遍 <code>try-catch-commit-rollback</code>。</li>
<li><strong>易错</strong>：如果在 commit 之前忘记捕获异常并 rollback，可能导致连接泄露或数据不一致。</li>
</ul>
<hr>
<h3 id="2-3-使用-TransactionTemplate-推荐方式"><a href="#2-3-使用-TransactionTemplate-推荐方式" class="headerlink" title="2.3 使用 TransactionTemplate (推荐方式)"></a>2.3 使用 <code>TransactionTemplate</code> (推荐方式)</h3><p>Spring 为了简化编程式事务，采用了<strong>模板方法模式</strong>（类似于 <code>JdbcTemplate</code>）。它封装了繁琐的开启、提交、回滚逻辑，你只需要把业务逻辑写在回调接口（Callback）里。</p>
<h4 id="2-3-1-核心机制"><a href="#2-3-1-核心机制" class="headerlink" title="2.3.1 核心机制"></a>2.3.1 核心机制</h4><ul>
<li><strong>自动提交&#x2F;回滚</strong>：如果回调方法正常执行，模板自动提交；如果回调方法抛出<strong>未捕获的异常</strong>，模板自动回滚。</li>
<li><strong>手动回滚</strong>：可以通过 <code>status.setRollbackOnly()</code> 手动触发回滚。</li>
</ul>
<hr>
<h4 id="2-3-2-代码示例"><a href="#2-3-2-代码示例" class="headerlink" title="2.3.2 代码示例"></a>2.3.2 代码示例</h4><p>首先，你需要注入 <code>TransactionTemplate</code>。在 Spring Boot 中，如果配置了事务管理器，通常可以直接注入，或者自行配置 Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransactionTemplate transactionTemplate; <span class="comment">// 注入模板</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderDao orderDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置一些属性（可选）</span></span><br><span class="line">        transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 execute 执行业务逻辑</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// --- 业务逻辑开始 ---</span></span><br><span class="line">                orderDao.save(order);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (order.getPrice() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 特殊情况：没有抛异常，但我想手动回滚</span></span><br><span class="line">                    status.setRollbackOnly();</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;价格错误，回滚&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                orderDao.updateStock(order.getProductId());</span><br><span class="line">                <span class="comment">// --- 业务逻辑结束 ---</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;订单创建成功&quot;</span>; <span class="comment">// 返回值</span></span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 如果捕获了异常，必须手动回滚，或者重新抛出</span></span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;发生异常，已处理并回滚&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;执行结果: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-3-两种回调方式"><a href="#2-3-3-两种回调方式" class="headerlink" title="2.3.3 两种回调方式"></a>2.3.3 两种回调方式</h4><ol>
<li><strong>有返回值</strong>：使用 <code>transactionTemplate.execute(TransactionCallback&lt;T&gt; action)</code>。</li>
<li><strong>无返回值</strong>：<ul>
<li>Spring 5.x+ 推荐使用 <code>executeWithoutResult(Consumer&lt;TransactionStatus&gt; action)</code>。</li>
<li>旧版本使用 <code>execute(new TransactionCallbackWithoutResult() { ... })</code>。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无返回值的 Lambda 写法 (Spring 5+)</span></span><br><span class="line">transactionTemplate.executeWithoutResult(status -&gt; &#123;</span><br><span class="line">    orderDao.save(order);</span><br><span class="line">    orderDao.updateStock(order.getProductId());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h3><table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left"><code>PlatformTransactionManager</code></th>
<th align="left"><code>TransactionTemplate</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>使用方式</strong></td>
<td align="left">手动调用 <code>getTransaction</code>, <code>commit</code>, <code>rollback</code></td>
<td align="left">将逻辑包裹在 <code>execute</code> 回调中</td>
</tr>
<tr>
<td align="left"><strong>异常处理</strong></td>
<td align="left">必须显式 <code>try-catch</code> 并在 <code>catch</code> 中回滚</td>
<td align="left">模板自动捕获异常并回滚</td>
</tr>
<tr>
<td align="left"><strong>代码量</strong></td>
<td align="left">多，样板代码重</td>
<td align="left">少，简洁</td>
</tr>
<tr>
<td align="left"><strong>推荐度</strong></td>
<td align="left">低 (除非在写框架底层代码)</td>
<td align="left"><strong>高</strong> (如果必须用编程式事务)</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>关键面试题&#x2F;实战点</strong>：</p>
<p>如果你在 <code>TransactionTemplate</code> 的回调方法内部 <code>try-catch</code> 住了异常，<strong>并且没有重新抛出，也没有调用 <code>status.setRollbackOnly()</code></strong>，Spring 会认为业务执行成功，从而<strong>提交事务</strong>！这是使用编程式事务最容易犯的错误。</p>
</blockquote>
<hr>
<h2 id="3-声明式事务管理"><a href="#3-声明式事务管理" class="headerlink" title="3. 声明式事务管理"></a>3. 声明式事务管理</h2><h3 id="3-1-概述-1"><a href="#3-1-概述-1" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><ul>
<li><strong>核心思想</strong>：将事务管理代码从业务代码中剥离出来，作为一种<strong>横切关注点 (Cross-cutting Concern)</strong>。</li>
<li><strong>实现原理</strong>：<strong>Spring AOP</strong>。<ul>
<li>当你给一个方法加上 <code>@Transactional</code> 注解时，Spring 不会直接运行你的类，而是运行它生成的<strong>代理对象 (Proxy)</strong>。</li>
<li>代理对象在调用你的目标方法<strong>之前</strong>，向数据库开启事务；在目标方法<strong>返回之后</strong>，根据运行情况提交或回滚事务。</li>
</ul>
</li>
<li><strong>优点</strong>：业务代码极其干净，没有任何 JDBC 或事务管理的代码痕迹。</li>
</ul>
<hr>
<h3 id="3-2-启用事务管理"><a href="#3-2-启用事务管理" class="headerlink" title="3.2 启用事务管理"></a>3.2 启用事务管理</h3><p>在现代 Spring Boot 项目中，启用非常简单：</p>
<ol>
<li><p><strong>引入依赖</strong>：<br>通常引入 <code>spring-boot-starter-jdbc</code> 或 <code>spring-boot-starter-data-jpa</code> 即可，它们内部包含了 <code>spring-tx</code> 模块。</p>
</li>
<li><p><strong>开启开关</strong>：<br>需要配置 <code>@EnableTransactionManagement</code> 注解。</p>
<blockquote>
<p><strong>注意</strong>：Spring Boot 的自动配置类 (<code>TransactionAutoConfiguration</code>) 默认已经加上了这个注解，所以通常<strong>不需要</strong>手动写它，直接用 <code>@Transactional</code> 即可。</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="3-3-Transactional-注解详解"><a href="#3-3-Transactional-注解详解" class="headerlink" title="3.3 @Transactional 注解详解"></a>3.3 <code>@Transactional</code> 注解详解</h3><p>这个注解是声明式事务的控制中心。</p>
<h4 id="3-3-1-作用范围"><a href="#3-3-1-作用范围" class="headerlink" title="3.3.1 作用范围"></a>3.3.1 作用范围</h4><ol>
<li><strong>方法级别 (推荐)</strong>：优先级最高。只针对该方法开启事务。</li>
<li><strong>类级别</strong>：相当于该类的<strong>所有 public 方法</strong>都加上了 <code>@Transactional</code>。</li>
<li><strong>接口级别 (不推荐)</strong>：虽然支持，但只有在使用 JDK 动态代理时才生效。如果使用了 CGLIB（Boot 默认），接口上的注解会被忽略。<strong>建议始终加在实现类上</strong>。</li>
</ol>
<hr>
<h4 id="3-3-2-核心参数配置"><a href="#3-3-2-核心参数配置" class="headerlink" title="3.3.2 核心参数配置"></a>3.3.2 核心参数配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">    transactionManager = &quot;txManager&quot;, // 指定事务管理器(多数据源时必填)</span></span><br><span class="line"><span class="meta">    propagation = Propagation.REQUIRED, // 传播行为(默认是REQUIRED)</span></span><br><span class="line"><span class="meta">    isolation = Isolation.DEFAULT,      // 隔离级别(默认跟随数据库)</span></span><br><span class="line"><span class="meta">    timeout = 30,                       // 超时时间(秒)</span></span><br><span class="line"><span class="meta">    readOnly = false,                   // 是否只读(默认false)</span></span><br><span class="line"><span class="meta">    rollbackFor = Exception.class       // ★★★ 遇到什么异常回滚</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>readOnly</code></strong>：如果你的方法全是查询，设置为 <code>true</code>。Spring 和数据库底层（如 MySQL 驱动）会进行性能优化（例如不加锁、不记录 Undo Log）。</li>
<li><strong><code>rollbackFor</code> (非常重要)</strong>：见下文 3.4.3。</li>
</ul>
<hr>
<h3 id="3-4-失效场景"><a href="#3-4-失效场景" class="headerlink" title="3.4 失效场景"></a>3.4 失效场景</h3><p>这p是开发者最容易踩坑的地方。Spring 事务看起来失效了，通常是因为违反了 AOP 的规则。</p>
<h4 id="3-4-1-自调用问题-Self-Invocation-——-最经典的大坑"><a href="#3-4-1-自调用问题-Self-Invocation-——-最经典的大坑" class="headerlink" title="3.4.1 自调用问题 (Self-Invocation) —— 最经典的大坑"></a>3.4.1 自调用问题 (Self-Invocation) —— <strong>最经典的大坑</strong></h4><p><strong>现象</strong>：</p>
<p>在同一个类中，一个<strong>没有</strong>事务的方法 A，调用了<strong>有</strong>事务的方法 B。此时外部调用 A，B 的事务会失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法 A：没有事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用内部方法 B</span></span><br><span class="line">        <span class="built_in">this</span>.methodB(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法 B：有事务</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：Spring AOP 的工作原理是<strong>代理</strong>。只有通过代理对象调用方法，事务拦截器才会生效。<br>而在 <code>methodA</code> 内部使用的是 <code>this.methodB()</code>，这里的 <code>this</code> 指的是<strong>目标对象本身</strong>，而不是代理对象。因此，代码直接跳过了代理的“增强逻辑”，直接执行了原始方法，导致事务失效。</p>
<p><strong>解决方法</strong>：</p>
<ol>
<li><strong>注入自己 (常用)</strong>：在类中注入 <code>UserService</code> 自身，通过注入的对象调用 <code>methodB</code>。</li>
<li><strong>AopContext (不推荐)</strong>：<code>((UserService)AopContext.currentProxy()).methodB()</code>。获取当前线程绑定的代理对象来调用。(需要开启 <code>expose-proxy=true</code>，代码侵入性较强)</li>
<li><strong>拆分</strong>：将 <code>methodB</code> 移到另一个 Service 类中（最符合单一职责原则）。</li>
</ol>
<hr>
<h4 id="3-4-2-应用在非-public-方法上"><a href="#3-4-2-应用在非-public-方法上" class="headerlink" title="3.4.2 应用在非 public 方法上"></a>3.4.2 应用在非 <code>public</code> 方法上</h4><ul>
<li><p><strong>现象</strong>：将 <code>@Transactional</code> 注解放在 <code>private</code>, <code>protected</code>, 或包可见（default）的方法上。</p>
</li>
<li><p><strong>原因</strong>：Spring AOP的实现原理是<strong>动态代理</strong>。无论是JDK动态代理还是CGLIB，它们都是通过创建一个代理类来<strong>重写（override）或实现</strong>目标方法，并在其中织入事务逻辑。</p>
<ul>
<li><code>private</code> 方法：无法被子类重写，也无法被外部的代理类调用。</li>
<li><code>protected</code> &#x2F; <code>default</code> 方法：虽然可以被子类重写，但Spring的代理机制为了保持一致性和减少复杂性，其AOP拦截器默认只为 <code>public</code> 方法创建代理。</li>
</ul>
</li>
<li><p><strong>结论</strong>：Spring AOP会<strong>静默地忽略</strong>非 <code>public</code> 方法上的 <code>@Transactional</code> 注解，事务不会生效，也不会有任何错误提示。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// &lt;-- 生效</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// &lt;-- 将被忽略，事务无效！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-4-3-异常类型不匹配-默认回滚策略"><a href="#3-4-3-异常类型不匹配-默认回滚策略" class="headerlink" title="3.4.3 异常类型不匹配 (默认回滚策略)"></a>3.4.3 异常类型不匹配 (默认回滚策略)</h4><ul>
<li><p><strong>现象</strong>：方法抛出了一个<strong>受检异常 (Checked Exception)</strong>，但事务没有回滚。</p>
</li>
<li><p><strong>原因</strong>：Spring 默认的策略是：<strong>只有抛出 <code>RuntimeException</code> (运行时异常) 或 <code>Error</code> 时才回滚</strong>。对于普通的 <code>Exception</code> 子类（如<code>IOException</code>, <code>SQLException</code>），Spring默认认为这是业务逻辑的一部分，Spring 默认<strong>不会回滚</strong>。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// &lt;-- 默认配置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        repository.save(data);</span><br><span class="line">        <span class="comment">// 抛出受检异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;File not found!&quot;</span>);</span><br><span class="line">        <span class="comment">// 事务将不会回滚，data 会被提交到数据库！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决方案</strong>：显式指定 <code>rollbackFor</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐做法：指定所有Exception都回滚</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-4-4-异常被-try-catch-捕获且没有重新抛出"><a href="#3-4-4-异常被-try-catch-捕获且没有重新抛出" class="headerlink" title="3.4.4 异常被 try-catch 捕获且没有重新抛出"></a>3.4.4 异常被 <code>try-catch</code> 捕获且没有重新抛出</h4><ul>
<li><p><strong>现象</strong>：在 <code>@Transactional</code> 方法内部，一个可能导致回滚的异常被 <code>try-catch</code> 块捕获了，但在 <code>catch</code> 块中没有将异常重新抛出。</p>
</li>
<li><p><strong>原因</strong>：Spring的事务管理器是通过<strong>捕获从业务方法中抛出的异常</strong>来决定是否回滚事务的。如果你在方法内部把异常“吃掉”（handle）了，那么对于事务拦截器来说，这个方法就是<strong>正常返回</strong>的。既然是正常返回，它自然就会选择<strong>提交事务</strong>。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        userDao.save(user);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// 异常被捕获处理了，没有往外抛</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决方法</strong>：</p>
<ol>
<li>在 <code>catch</code> 块中 <code>throw e;</code> 继续抛出。</li>
<li>在 <code>catch</code> 块中手动回滚：<code>TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</code>。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="3-4-5-Bean-未被-Spring-管理"><a href="#3-4-5-Bean-未被-Spring-管理" class="headerlink" title="3.4.5 Bean 未被 Spring 管理"></a>3.4.5 Bean 未被 Spring 管理</h4><p>如果你自己 <code>new UserService()</code> 出来去调用，Spring 容器根本不知道这个对象的存在，AOP 自然也无法对其生成代理，注解也就成了摆设。必须通过 <code>@Autowired</code> 或构造器注入获取 Bean。</p>
<hr>
<h2 id="4-事务属性详解"><a href="#4-事务属性详解" class="headerlink" title="4. 事务属性详解"></a>4. 事务属性详解</h2><h3 id="4-1-传播行为"><a href="#4-1-传播行为" class="headerlink" title="4.1 传播行为"></a>4.1 传播行为</h3><h4 id="4-1-1-什么是传播行为？"><a href="#4-1-1-什么是传播行为？" class="headerlink" title="4.1.1 什么是传播行为？"></a>4.1.1 什么是传播行为？</h4><ul>
<li><p><strong>定义</strong>：当一个事务方法 A 调用了另一个事务方法 B 时，这个方法 B 应该<strong>如何运行</strong>？</p>
<p>是加入 A 的事务？还是自己开一个新的？还是报错？这就是传播行为要解决的问题。</p>
</li>
<li><p><strong>关键点</strong>：传播行为是定义在<strong>被调用方 (方法 B)</strong> 上的规则，用来决定它在面对<strong>调用方 (方法 A)</strong> 时如何自处。</p>
</li>
</ul>
<p>Spring 在 <code>org.springframework.transaction.annotation.Propagation</code> 枚举中定义了 <strong>7 种</strong>传播行为。我们将它们分为三类来记忆。</p>
<hr>
<h4 id="4-1-2-支持当前事务-最常用"><a href="#4-1-2-支持当前事务-最常用" class="headerlink" title="4.1.2 支持当前事务 (最常用)"></a>4.1.2 支持当前事务 (最常用)</h4><p>这类行为的核心逻辑是：<strong>“如果你有事务，我就加入你；如果你没有，我看情况。”</strong></p>
<h5 id="1-REQUIRED-默认值-★★★"><a href="#1-REQUIRED-默认值-★★★" class="headerlink" title="1. REQUIRED (默认值) ★★★"></a>1. <code>REQUIRED</code> (默认值) ★★★</h5><blockquote>
<p><strong>口诀</strong>：有则加入，无则新建。</p>
</blockquote>
<ul>
<li><strong>场景</strong>：A 调用 B。</li>
<li><strong>行为</strong>：<ul>
<li>如果 A 有事务，B 就<strong>加入</strong>到 A 的事务中（此时 A 和 B 是同一个事务，共生共死）。</li>
<li>如果 A 没有事务，B 就自己<strong>新建</strong>一个事务。</li>
</ul>
</li>
<li><strong>结果</strong>：<ul>
<li>如果 B 异常回滚，A 也会回滚（因为是同一个事务）。</li>
<li>如果 A 异常回滚，B 也会回滚。</li>
</ul>
</li>
<li><strong>适用性</strong>：90% 的业务场景都用这个。这也是 <code>@Transactional</code> 的默认配置。</li>
</ul>
<hr>
<h5 id="2-SUPPORTS"><a href="#2-SUPPORTS" class="headerlink" title="2. SUPPORTS"></a>2. <code>SUPPORTS</code></h5><blockquote>
<p><strong>口诀</strong>：有就用，没有拉倒。</p>
</blockquote>
<ul>
<li><strong>行为</strong>：<ul>
<li>如果 A 有事务，B 就加入。</li>
<li>如果 A 没有事务，B 就以<strong>非事务</strong>方式运行。</li>
</ul>
</li>
<li><strong>适用性</strong>：通常用于纯查询方法。比如 <code>get*</code> 方法，如果外面有事务我就用（读一致性），外面没事务我也能查。</li>
</ul>
<hr>
<h5 id="3-MANDATORY"><a href="#3-MANDATORY" class="headerlink" title="3. MANDATORY"></a>3. <code>MANDATORY</code></h5><blockquote>
<p><strong>口诀</strong>：必须有，没有就哭（报错）。</p>
</blockquote>
<ul>
<li><strong>行为</strong>：<ul>
<li>如果 A 有事务，B 就加入。</li>
<li>如果 A 没有事务，B 直接抛出异常 (<code>IllegalTransactionStateException</code>)。</li>
</ul>
</li>
<li><strong>适用性</strong>：极少用。用于限制某些方法必须在事务环境中才能被调用。</li>
</ul>
<hr>
<h4 id="4-1-3-不支持当前事务-挂起与独立"><a href="#4-1-3-不支持当前事务-挂起与独立" class="headerlink" title="4.1.3 不支持当前事务 (挂起与独立)"></a>4.1.3 不支持当前事务 (挂起与独立)</h4><p>这类行为的核心逻辑是：<strong>“我不喜欢你的事务，我要自己玩，或者干脆不玩。”</strong></p>
<h5 id="4-REQUIRES-NEW-★★★"><a href="#4-REQUIRES-NEW-★★★" class="headerlink" title="4. REQUIRES_NEW ★★★"></a>4. <code>REQUIRES_NEW</code> ★★★</h5><blockquote>
<p><strong>口诀</strong>：不管有没有，我都自立门户。</p>
</blockquote>
<ul>
<li><strong>场景</strong>：A 调用 B。</li>
<li><strong>行为</strong>：<ul>
<li><strong>挂起 (Suspend)</strong> A 的事务（如果存在）。</li>
<li>B <strong>新建</strong>一个完全独立的事务。</li>
<li>B 执行完提交后，恢复 A 的事务。</li>
</ul>
</li>
<li><strong>结果 (关键区别)</strong>：<ul>
<li><strong>B 的回滚不影响 A</strong>（前提是 A 捕获了 B 的异常）。</li>
<li><strong>A 的回滚不影响 B</strong>（因为 B 已经提交了）。</li>
</ul>
</li>
<li><strong>适用性</strong>：<strong>非常重要</strong>。<ul>
<li><strong>日志记录</strong>：不管业务 A 成功还是失败，我都要把日志 B 存进数据库。</li>
<li><strong>发送验证码</strong>：生成验证码记录 B 必须独立提交，防止业务 A 后续报错导致验证码记录被回滚，用户收到了短信却没法登录。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="5-NOT-SUPPORTED"><a href="#5-NOT-SUPPORTED" class="headerlink" title="5. NOT_SUPPORTED"></a>5. <code>NOT_SUPPORTED</code></h5><blockquote>
<p><strong>口诀</strong>：我有洁癖，完全不用事务。</p>
</blockquote>
<ul>
<li><strong>行为</strong>：<ul>
<li><strong>挂起</strong> A 的事务（如果存在）。</li>
<li>B 以<strong>非事务</strong>方式运行。</li>
<li>B 运行完，恢复 A 的事务。</li>
</ul>
</li>
<li><strong>适用性</strong>：用于某些操作耗时非常长、且不需要事务的场景（如发送邮件、大规模IO操作），为了避免长时间占用数据库连接或锁，将其排除在事务之外。</li>
</ul>
<hr>
<h5 id="6-NEVER"><a href="#6-NEVER" class="headerlink" title="6. NEVER"></a>6. <code>NEVER</code></h5><blockquote>
<p><strong>口诀</strong>：必须没有，有就哭（报错）。</p>
</blockquote>
<ul>
<li><strong>行为</strong>：<ul>
<li>如果 A 有事务，B 直接抛出异常。</li>
<li>如果 A 没有事务，B 以非事务方式运行。</li>
</ul>
</li>
<li><strong>适用性</strong>：极少用。</li>
</ul>
<hr>
<h4 id="4-1-4-嵌套事务-特殊"><a href="#4-1-4-嵌套事务-特殊" class="headerlink" title="4.1.4 嵌套事务 (特殊)"></a>4.1.4 嵌套事务 (特殊)</h4><h5 id="7-NESTED"><a href="#7-NESTED" class="headerlink" title="7. NESTED"></a>7. <code>NESTED</code></h5><blockquote>
<p><strong>口诀</strong>：寄生事务，有存档点。</p>
</blockquote>
<ul>
<li><strong>行为</strong>：<ul>
<li>如果 A 有事务，B 在 A 的事务中创建一个<strong>保存点 (Savepoint)</strong>。</li>
<li>如果 A 没有事务，B 等同于 <code>REQUIRED</code>（新建事务）。</li>
</ul>
</li>
<li><strong>结果</strong>：<ul>
<li><strong>B 回滚</strong>：只会回滚到保存点，不会影响 A 之前的操作（前提是 A 捕获了 B 的异常）。</li>
<li><strong>A 回滚</strong>：A 是主事务，A 回滚会导致 B（寄生事务）也回滚。</li>
<li><strong>A 提交</strong>：只有等 A 提交了，B 的操作才算真正提交。</li>
</ul>
</li>
<li><strong>对比 <code>REQUIRES_NEW</code></strong>：<ul>
<li><code>REQUIRES_NEW</code> 是“兄弟分家”，B 提交了就是真提交了，A 后来死活与 B 无关。</li>
<li><code>NESTED</code> 是“父子关系”，B 只是暂存，要等爸爸 A 最终签字才算数。</li>
</ul>
</li>
<li><strong>适用性</strong>：较少用，且依赖于数据库驱动支持 Savepoint（MySQL 支持）。</li>
</ul>
<hr>
<h4 id="4-1-5-传播行为图解与对比表"><a href="#4-1-5-传播行为图解与对比表" class="headerlink" title="4.1.5 传播行为图解与对比表"></a>4.1.5 传播行为图解与对比表</h4><table>
<thead>
<tr>
<th align="left">传播属性</th>
<th align="left">如果当前有事务</th>
<th align="left">如果当前无事务</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>REQUIRED</code></strong></td>
<td align="left">加入</td>
<td align="left">新建</td>
<td align="left"><strong>默认值，最常用</strong></td>
</tr>
<tr>
<td align="left"><code>SUPPORTS</code></td>
<td align="left">加入</td>
<td align="left">非事务运行</td>
<td align="left">查询类方法常用</td>
</tr>
<tr>
<td align="left"><code>MANDATORY</code></td>
<td align="left">加入</td>
<td align="left"><strong>抛异常</strong></td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><strong><code>REQUIRES_NEW</code></strong></td>
<td align="left"><strong>挂起当前，新建</strong></td>
<td align="left">新建</td>
<td align="left"><strong>独立事务，互不影响</strong></td>
</tr>
<tr>
<td align="left"><code>NOT_SUPPORTED</code></td>
<td align="left"><strong>挂起当前，非事务</strong></td>
<td align="left">非事务运行</td>
<td align="left">排除长耗时非DB操作</td>
</tr>
<tr>
<td align="left"><code>NEVER</code></td>
<td align="left"><strong>抛异常</strong></td>
<td align="left">非事务运行</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><code>NESTED</code></td>
<td align="left"><strong>嵌套 (Savepoint)</strong></td>
<td align="left">新建</td>
<td align="left">子事务回滚不影响父，父回滚影响子</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-2-隔离级别"><a href="#4-2-隔离级别" class="headerlink" title="4.2 隔离级别"></a>4.2 隔离级别</h3><h4 id="4-2-1-为什么需要隔离级别？"><a href="#4-2-1-为什么需要隔离级别？" class="headerlink" title="4.2.1 为什么需要隔离级别？"></a>4.2.1 为什么需要隔离级别？</h4><p>在 Web 应用中，成千上万个事务可能在同一时刻访问同一个数据库表。如果没有隔离机制，就会出现“数据打架”的情况。</p>
<p>但是，<strong>隔离得越严实，效率就越低</strong>（锁加得越多）。<br><strong>隔离级别</strong>本质上就是我们在<strong>数据安全性 (Consistency)</strong> 和 <strong>并发性能 (Concurrency)</strong> 之间做的一个权衡 (Trade-off)。</p>
<hr>
<h4 id="4-2-2-并发事务的三大“罪状”-并发问题"><a href="#4-2-2-并发事务的三大“罪状”-并发问题" class="headerlink" title="4.2.2 并发事务的三大“罪状” (并发问题)"></a>4.2.2 并发事务的三大“罪状” (并发问题)</h4><p>在理解隔离级别之前，必须先搞清楚如果不隔离会发生什么。</p>
<h5 id="1-脏读-Dirty-Read"><a href="#1-脏读-Dirty-Read" class="headerlink" title="1. 脏读 (Dirty Read)"></a>1. 脏读 (Dirty Read)</h5><blockquote>
<p><strong>“读到了垃圾”</strong></p>
</blockquote>
<ul>
<li><strong>场景</strong>：事务 A 修改了一条数据（还没提交），事务 B 读到了这条被修改的数据。结果事务 A 回滚了，事务 B 读到的就是一条“根本不存在”的数据。</li>
<li><strong>后果</strong>：严重的数据错误（比如显示余额增加了，结果转账失败了）。</li>
</ul>
<hr>
<h5 id="2-不可重复读-Non-repeatable-Read"><a href="#2-不可重复读-Non-repeatable-Read" class="headerlink" title="2. 不可重复读 (Non-repeatable Read)"></a>2. 不可重复读 (Non-repeatable Read)</h5><blockquote>
<p><strong>“前后读取不一致”</strong></p>
</blockquote>
<ul>
<li><strong>场景</strong>：事务 A 读取余额为 100 元。此时事务 B 把余额改成了 50 元并提交。事务 A 再次读取同一个账户，发现变成了 50 元。</li>
<li><strong>侧重点</strong>：针对<strong>数据修改 (Update&#x2F;Delete)</strong>。同一个事务内，两次读取<strong>同一行</strong>数据，结果不一样。</li>
</ul>
<hr>
<h5 id="3-幻读-Phantom-Read"><a href="#3-幻读-Phantom-Read" class="headerlink" title="3. 幻读 (Phantom Read)"></a>3. 幻读 (Phantom Read)</h5><blockquote>
<p><strong>“见鬼了，数据变多了&#x2F;变少了”</strong></p>
</blockquote>
<ul>
<li><strong>场景</strong>：事务 A 统计表中有 3 条记录。此时事务 B 插入了一条新记录并提交。事务 A 再次统计，发现变成了 4 条。</li>
<li><strong>侧重点</strong>：针对<strong>数据新增 (Insert)</strong>。同一个事务内，两次查询<strong>同一个范围</strong>，结果集的行数不一样。</li>
</ul>
<hr>
<h4 id="4-2-3-数据库的四种标准隔离级别"><a href="#4-2-3-数据库的四种标准隔离级别" class="headerlink" title="4.2.3 数据库的四种标准隔离级别"></a>4.2.3 数据库的四种标准隔离级别</h4><p>SQL 标准定义了四个级别，Spring 完全对应支持。从上到下，隔离级别越来越高，性能越来越低。</p>
<h5 id="1-READ-UNCOMMITTED-读未提交"><a href="#1-READ-UNCOMMITTED-读未提交" class="headerlink" title="1. READ_UNCOMMITTED (读未提交)"></a>1. <code>READ_UNCOMMITTED</code> (读未提交)</h5><ul>
<li><strong>含义</strong>：允许读取别的事务还没提交的数据。</li>
<li><strong>表现</strong>：三大问题（脏读、不可重复读、幻读）<strong>全都会发生</strong>。</li>
<li><strong>评价</strong>：<strong>裸奔</strong>。性能最好，但极不安全，实际开发几乎不用。</li>
</ul>
<hr>
<h5 id="2-READ-COMMITTED-读已提交"><a href="#2-READ-COMMITTED-读已提交" class="headerlink" title="2. READ_COMMITTED (读已提交)"></a>2. <code>READ_COMMITTED</code> (读已提交)</h5><ul>
<li><strong>含义</strong>：只能读取别的事务<strong>已经提交</strong>的数据。</li>
<li><strong>表现</strong>：<ul>
<li><strong>解决了脏读</strong>（别人没提交我读不到）。</li>
<li>但可能发生不可重复读和幻读。</li>
</ul>
</li>
<li><strong>评价</strong>：<strong>大多数数据库的默认级别</strong>（如 Oracle, SQL Server, PostgreSQL）。</li>
</ul>
<hr>
<h5 id="3-REPEATABLE-READ-可重复读"><a href="#3-REPEATABLE-READ-可重复读" class="headerlink" title="3. REPEATABLE_READ (可重复读)"></a>3. <code>REPEATABLE_READ</code> (可重复读)</h5><ul>
<li><strong>含义</strong>：保证在同一个事务中，多次读取同一条数据的结果是一样的（即使别人改了并提交了，我也假装没看见）。</li>
<li><strong>表现</strong>：<ul>
<li><strong>解决了脏读、不可重复读</strong>。</li>
<li>理论上会发生幻读（但 MySQL InnoDB 引擎通过 MVCC 和间隙锁机制，在这个级别下也基本解决了幻读）。</li>
</ul>
</li>
<li><strong>评价</strong>：<strong>MySQL 的默认级别</strong>。</li>
</ul>
<hr>
<h5 id="4-SERIALIZABLE-串行化"><a href="#4-SERIALIZABLE-串行化" class="headerlink" title="4. SERIALIZABLE (串行化)"></a>4. <code>SERIALIZABLE</code> (串行化)</h5><ul>
<li><strong>含义</strong>：强制事务<strong>排队执行</strong>。</li>
<li><strong>表现</strong>：所有问题都不存在。</li>
<li><strong>评价</strong>：<strong>最慢</strong>。就像是把多车道高速公路变成了单行道。除非对数据一致性要求极高（如银行核心系统），否则不建议使用。</li>
</ul>
<hr>
<h4 id="4-2-4-Spring-中的-DEFAULT-默认"><a href="#4-2-4-Spring-中的-DEFAULT-默认" class="headerlink" title="4.2.4 Spring 中的 DEFAULT (默认)"></a>4.2.4 Spring 中的 <code>DEFAULT</code> (默认)</h4><p>在 <code>@Transactional</code> 中，隔离级别的默认值是 <code>Isolation.DEFAULT</code>。</p>
<ul>
<li><strong>含义</strong>：Spring 不做主张，<strong>使用底层数据库配置的默认隔离级别</strong>。</li>
<li><strong>具体表现</strong>：<ul>
<li>如果你用 MySQL，默认就是 <code>REPEATABLE_READ</code>。</li>
<li>如果你用 Oracle&#x2F;SQL Server，默认就是 <code>READ_COMMITTED</code>。</li>
</ul>
</li>
</ul>
<p><strong>配置示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动指定为 读已提交</span></span><br><span class="line"><span class="meta">@Transactional(isolation = Isolation.READ_COMMITTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logic</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-5-隔离级别总结表"><a href="#4-2-5-隔离级别总结表" class="headerlink" title="4.2.5 隔离级别总结表"></a>4.2.5 隔离级别总结表</h4><table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="center">脏读 (Dirty Read)</th>
<th align="center">不可重复读 (Non-Repeatable)</th>
<th align="center">幻读 (Phantom)</th>
<th align="left">性能</th>
<th align="left">数据库默认</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>READ_UNCOMMITTED</strong></td>
<td align="center">× (会发生)</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="left">极高</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><strong>READ_COMMITTED</strong></td>
<td align="center"><strong>√ (解决)</strong></td>
<td align="center">×</td>
<td align="center">×</td>
<td align="left">高</td>
<td align="left"><strong>Oracle&#x2F;SQL Server</strong></td>
</tr>
<tr>
<td align="left"><strong>REPEATABLE_READ</strong></td>
<td align="center">√</td>
<td align="center"><strong>√ (解决)</strong></td>
<td align="center">× (MySQL除外)</td>
<td align="left">中</td>
<td align="left"><strong>MySQL</strong></td>
</tr>
<tr>
<td align="left"><strong>SERIALIZABLE</strong></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"><strong>√ (解决)</strong></td>
<td align="left">极低</td>
<td align="left">-</td>
</tr>
</tbody></table>
<p><strong>最佳实践与建议：</strong></p>
<ol>
<li><strong>使用数据库的默认隔离级别</strong>：在绝大多数情况下，直接使用你的数据库（如MySQL的<code>REPEATABLE_READ</code>，Oracle的<code>READ_COMMITTED</code>）的默认隔离级别就足够了。这些默认设置是数据库厂商在性能和一致性之间做出的最佳平衡。</li>
<li><strong>非必要不修改</strong>：不要轻易在代码中通过 <code>@Transactional</code> 去修改隔离级别，除非你非常清楚你正在解决什么特定的并发问题，并且愿意承担由此带来的性能影响。</li>
<li><strong>理解你的数据库</strong>：了解你所使用的数据库在特定隔离级别下的具体实现机制（例如，了解MySQL的MVCC和Next-Key Lock）比死记硬背SQL标准更重要。</li>
<li><strong>优先使用乐观锁&#x2F;悲观锁</strong>：对于并发写操作非常频繁的“热点数据”，与其提升整个事务的隔离级别，不如使用更细粒度的<strong>乐观锁</strong>（如版本号字段）或<strong>悲观锁</strong>（如<code>SELECT ... FOR UPDATE</code>）来解决并发冲突，这样对性能的影响更小。</li>
</ol>
<hr>
<h3 id="4-3-回滚规则"><a href="#4-3-回滚规则" class="headerlink" title="4.3 回滚规则"></a>4.3 回滚规则</h3><h4 id="4-3-1-默认回滚策略"><a href="#4-3-1-默认回滚策略" class="headerlink" title="4.3.1 默认回滚策略"></a>4.3.1 默认回滚策略</h4><p>Spring 的声明式事务默认<strong>只在抛出“未检查异常 (Unchecked Exception)”时回滚</strong>。</p>
<p>这是什么意思？在 Java 中，异常分为两大类：</p>
<ol>
<li><strong>Unchecked Exception (非受检异常)</strong>：<ul>
<li>包括 <code>RuntimeException</code> 及其子类（如 <code>NullPointerException</code>, <code>ArithmeticException</code>, <code>IllegalArgumentException</code>）。</li>
<li>以及 <code>Error</code> 及其子类（如 <code>OutOfMemoryError</code>）。</li>
<li><strong>Spring 默认行为：回滚 (Rollback)</strong>。</li>
</ul>
</li>
<li><strong>Checked Exception (受检异常)</strong>：<ul>
<li>继承自 <code>Exception</code> 但不属于 <code>RuntimeException</code> 的异常。</li>
<li>例如：<code>IOException</code>, <code>SQLException</code>, <code>FileNotFoundException</code>，以及用户自定义的业务异常（如 <code>BusinessException extends Exception</code>）。</li>
<li><strong>Spring 默认行为：提交 (Commit)！不回滚！</strong></li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>为什么这样设计？</strong></p>
<p>Spring 沿用了 EJB 的设计理念：</p>
<ul>
<li><strong>RuntimeException</strong> 通常代表<strong>代码写错了</strong>（如空指针）或<strong>系统故障</strong>，这是不可恢复的错误，必须回滚。</li>
<li><strong>Checked Exception</strong> 通常代表<strong>业务逻辑的一种分支</strong>（如“余额不足”或“文件未找到”），Spring 认为这是程序预期的业务结果，应该由开发者决定是否提交，所以默认不回滚。</li>
</ul>
</blockquote>
<hr>
<h4 id="4-3-2-自定义回滚配置"><a href="#4-3-2-自定义回滚配置" class="headerlink" title="4.3.2 自定义回滚配置"></a>4.3.2 自定义回滚配置</h4><p>为了避免上述问题，我们通常需要修改回滚规则。</p>
<p><strong>1. <code>rollbackFor</code> (指定哪些异常要回滚)</strong></p>
<p>这是最常用的配置。</p>
<ul>
<li><p><strong>最佳实践</strong>：为了安全起见，通常指定所有异常都回滚。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只要抛出异常，不管是 Checked 还是 Unchecked，统统回滚</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>指定特定业务异常</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有余额不足时才回滚，其他受检异常不回滚</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = InsufficientBalanceException.class)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2. <code>noRollbackFor</code> (指定哪些异常不回滚)</strong></p>
<p>某些特殊场景下，即使报错了，我们也不希望回滚之前的数据。</p>
<ul>
<li><p><strong>场景</strong>：<br>记录审计日志。即使日志记录抛出了异常（比如日志表满了），也不应该影响主业务的提交。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(noRollbackFor = LogException.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">businessLogic</span><span class="params">()</span> &#123;</span><br><span class="line">    dataDao.save(data); <span class="comment">// 这步操作不会因为下面抛 LogException 而回滚</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LogException</span>(<span class="string">&quot;日志记录失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-3-3-异常名称匹配"><a href="#4-3-3-异常名称匹配" class="headerlink" title="4.3.3 异常名称匹配"></a>4.3.3 异常名称匹配</h4><p>除了指定 <code>Class</code> 对象，Spring 还允许直接指定异常类的<strong>全限定名字符串</strong>（主要用于极其罕见的场景，比如该异常类在当前模块不可见）。</p>
<ul>
<li><code>rollbackForClassName = &quot;com.example.MyException&quot;</code></li>
<li><code>noRollbackForClassName = &quot;java.io.IOException&quot;</code></li>
</ul>
<p>这种用法在现代开发中非常少见，通常忽略。</p>
<hr>
<h4 id="4-3-4-总结与建议"><a href="#4-3-4-总结与建议" class="headerlink" title="4.3.4 总结与建议"></a>4.3.4 总结与建议</h4><table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left">默认行为</th>
<th align="left">存在风险</th>
<th align="left">建议做法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Default</strong></td>
<td align="left">仅 <code>RuntimeException</code> 和 <code>Error</code> 回滚</td>
<td align="left">忽略了 <code>Checked Exception</code> (如 <code>IOException</code>)，导致数据提交</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><strong><code>rollbackFor</code></strong></td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left"><strong>始终加上 <code>@Transactional(rollbackFor = Exception.class)</code></strong></td>
</tr>
<tr>
<td align="left"><strong><code>noRollbackFor</code></strong></td>
<td align="left">-</td>
<td align="left">可能导致数据不一致</td>
<td align="left">仅在特定业务场景（如审计、非关键步骤）谨慎使用</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>一句话铁律</strong>：</p>
<p>只要你加 <code>@Transactional</code>，请顺手把 <code>(rollbackFor = Exception.class)</code> 也加上，除非你非常清楚自己在做什么。</p>
</blockquote>
<hr>
<h3 id="4-4-只读与超时"><a href="#4-4-只读与超时" class="headerlink" title="4.4 只读与超时"></a>4.4 只读与超时</h3><h4 id="4-4-1-只读属性-readOnly"><a href="#4-4-1-只读属性-readOnly" class="headerlink" title="4.4.1 只读属性 (readOnly)"></a>4.4.1 只读属性 (<code>readOnly</code>)</h4><p><strong>定义</strong>：</p>
<p>这是一个布尔值标记，默认为 <code>false</code>。</p>
<p>如果你把它设置为 <code>true</code>，就相当于你向 Spring 和数据库发出了一声**“声明”**：“我这个事务里只会有查询操作，不会有修改、插入或删除。”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getAllUsers</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么要设置它？（核心好处）</strong></p>
<p>很多人觉得：“我只要代码里不写 update 语句不就行了吗？为什么要显式配置？”</p>
<p>其实，配置 <code>readOnly=true</code> 能带来显著的<strong>性能优化</strong>，尤其是当你使用 JPA&#x2F;Hibernate 时：</p>
<ol>
<li><strong>Hibernate&#x2F;JPA 优化 (最显著)</strong>：<ul>
<li>Spring 会将 Hibernate 的 Session 刷新模式设置为 <code>FlushMode.MANUAL</code>。</li>
<li>这意味着 Hibernate <strong>不再进行“脏检查” (Dirty Checking)</strong>。通常 Hibernate 会对比对象现在的状态和快照来决定是否更新数据库，禁用这个过程能大幅节省内存和 CPU。</li>
</ul>
</li>
<li><strong>数据库层面的优化</strong>：<ul>
<li>某些数据库（如 MySQL 5.6+ 的 InnoDB）对只读事务有特殊优化（不分配事务 ID，减少锁竞争）。</li>
<li>某些数据库（如 SQL Server）可能会应用快照隔离，避免查询被写锁阻塞。</li>
</ul>
</li>
<li><strong>代码安全</strong>：<ul>
<li>如果你的代码在 <code>readOnly=true</code> 的事务中不小心执行了写操作，某些数据库驱动或 ORM 框架会直接抛出异常，阻止数据修改。</li>
</ul>
</li>
</ol>
<p><strong>最佳实践</strong>：</p>
<ul>
<li>对于纯查询的 Service 方法（如 <code>get</code>, <code>list</code>, <code>find</code> 开头的方法），<strong>请务必加上 <code>readOnly = true</code></strong>。</li>
</ul>
<hr>
<h4 id="4-4-2-超时属性-timeout"><a href="#4-4-2-超时属性-timeout" class="headerlink" title="4.4.2 超时属性 (timeout)"></a>4.4.2 超时属性 (<code>timeout</code>)</h4><p><strong>定义</strong>：</p>
<p>定义一个事务允许执行的<strong>最长时间</strong>（单位：<strong>秒</strong>）。</p>
<p>默认值为 <code>-1</code>，表示使用底层数据库的默认超时时间（通常是无限等待，直到天荒地老）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果方法执行超过 3 秒还没结束，就强制回滚</span></span><br><span class="line"><span class="meta">@Transactional(timeout = 3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complexCalculation</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作原理</strong>：</p>
<p>Spring 并不是在代码里启动一个定时炸弹。它的实现逻辑如下：</p>
<ol>
<li>记录事务开始时间。</li>
<li>在每次执行 SQL 语句（创建 <code>Statement</code>）之前，计算“现在”距离“截止时间”还剩多久。</li>
<li>调用 JDBC 的 <code>statement.setQueryTimeout(剩余秒数)</code>。</li>
<li>如果时间已超，或者 SQL 执行超时，抛出 <strong><code>TransactionTimedOutException</code></strong> 并回滚。</li>
</ol>
<p><strong>为什么需要它？</strong></p>
<ol>
<li><strong>防止死锁僵持</strong>：如果一个事务死锁了，或者等待锁的时间太长，设置超时可以让它快速失败，释放资源，避免拖垮整个数据库连接池。</li>
<li><strong>避免慢查询拖死系统</strong>：对于某些复杂的报表统计或大数据量处理，设置超时能防止一条烂 SQL 占着连接不放。</li>
</ol>
<p><strong>注意事项</strong>：</p>
<ul>
<li><code>timeout</code> 只有在<strong>新开启</strong>一个事务时才有效。如果当前方法是加入（<code>REQUIRED</code>）到了现有的事务中，那么它配置的 <code>timeout</code> 会被忽略，以主事务的配置为准。</li>
</ul>
<hr>
<h4 id="4-4-3-总结对比"><a href="#4-4-3-总结对比" class="headerlink" title="4.4.3 总结对比"></a>4.4.3 总结对比</h4><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">默认值</th>
<th align="left">作用</th>
<th align="left">核心价值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>readOnly</code></strong></td>
<td align="left"><code>false</code></td>
<td align="left">声明事务为只读</td>
<td align="left"><strong>性能优化</strong> (特别是 JPA&#x2F;Hibernate)，防止误写</td>
</tr>
<tr>
<td align="left"><strong><code>timeout</code></strong></td>
<td align="left"><code>-1</code> (无限制)</td>
<td align="left">限制最大执行秒数</td>
<td align="left"><strong>系统保护</strong>，防止慢事务耗尽数据库连接池</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-5-最佳实践总结"><a href="#4-5-最佳实践总结" class="headerlink" title="4.5 最佳实践总结"></a>4.5 最佳实践总结</h3><p>学完了所有属性，这里总结一份**“事务配置黄金法则”**：</p>
<ol>
<li><strong>Service 层加注解</strong>：始终在 Service 实现类（而非接口）上使用 <code>@Transactional</code>。</li>
<li><strong>读写分离配置</strong>：<ul>
<li>在<strong>类级别</strong>加上 <code>@Transactional(readOnly = true)</code>，作为默认配置（兜底）。</li>
<li>在<strong>增删改方法</strong>上单独加上 <code>@Transactional(readOnly = false, rollbackFor = Exception.class)</code>。</li>
</ul>
</li>
<li><strong>必须处理回滚</strong>：永远记住默认只回滚 RuntimeException，务必显式配置 <code>rollbackFor = Exception.class</code>。</li>
<li><strong>避免大事务</strong>：<ul>
<li>不要把耗时的无关操作（如调用第三方 HTTP 接口、文件 IO）放在事务方法里。</li>
<li>如果必须有，请使用编程式事务控制粒度，或者修改传播行为 (<code>NOT_SUPPORTED</code>)。</li>
</ul>
</li>
</ol>
<p><strong>实战模版代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = true)</span> <span class="comment">// 1. 类级别默认为只读，优化查询性能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用类级别的 readOnly = true</span></span><br><span class="line">        <span class="keyword">return</span> userDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 2. 写操作覆盖配置，并指定回滚规则</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false, rollbackFor = Exception.class)</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userDao.update(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 3. 复杂耗时操作，设置超时时间防止卡死</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false, timeout = 5, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complexJob</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-总结与对比"><a href="#5-总结与对比" class="headerlink" title="5. 总结与对比"></a>5. 总结与对比</h2><h3 id="5-1-编程式-vs-声明式"><a href="#5-1-编程式-vs-声明式" class="headerlink" title="5.1 编程式 vs 声明式"></a>5.1 编程式 vs 声明式</h3><p>Spring 提供了两种截然不同的方式来管理事务。理解它们的优缺点，才能在关键时刻做出正确的架构选择。</p>
<h4 id="5-1-1-核心对比表"><a href="#5-1-1-核心对比表" class="headerlink" title="5.1.1 核心对比表"></a>5.1.1 核心对比表</h4><table>
<thead>
<tr>
<th align="left">对比维度</th>
<th align="left">编程式事务 (Programmatic)</th>
<th align="left">声明式事务 (Declarative)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>实现方式</strong></td>
<td align="left"><code>TransactionTemplate</code> &#x2F; <code>TransactionManager</code></td>
<td align="left"><code>@Transactional</code> 注解 &#x2F; XML AOP</td>
</tr>
<tr>
<td align="left"><strong>侵入性</strong></td>
<td align="left"><strong>强</strong> (业务代码中混入事务逻辑)</td>
<td align="left"><strong>弱</strong> (彻底解耦，业务代码纯净)</td>
</tr>
<tr>
<td align="left"><strong>控制粒度</strong></td>
<td align="left"><strong>极细</strong> (可以精确到代码块&#x2F;几行代码)</td>
<td align="left"><strong>粗</strong> (只能以“方法”为单位)</td>
</tr>
<tr>
<td align="left"><strong>配置难度</strong></td>
<td align="left">较繁琐 (需手动捕获异常)</td>
<td align="left"><strong>极简</strong> (加个注解就行)</td>
</tr>
<tr>
<td align="left"><strong>灵活性</strong></td>
<td align="left">高 (可运行时动态决定是否开启)</td>
<td align="left">低 (编译期或启动期已定死)</td>
</tr>
<tr>
<td align="left"><strong>推荐指数</strong></td>
<td align="left">★ (仅用于特殊性能优化)</td>
<td align="left"><strong>★★★★★ (日常开发标准)</strong></td>
</tr>
</tbody></table>
<h4 id="5-1-2-决策指南：我该用哪个？"><a href="#5-1-2-决策指南：我该用哪个？" class="headerlink" title="5.1.2 决策指南：我该用哪个？"></a>5.1.2 决策指南：我该用哪个？</h4><ul>
<li><strong>99% 的场景</strong>：请毫不犹豫地选择 <strong>声明式事务 (<code>@Transactional</code>)</strong>。它清晰、简单、易维护。</li>
<li><strong>1% 的场景</strong>：选择 <strong>编程式事务</strong>。<ul>
<li><em>场景 A</em>：你需要在一个大方法中，只对其中<strong>极小的一段代码</strong>（比如更新库存）开启事务，以减少数据库锁持有的时间。</li>
<li><em>场景 B</em>：你需要根据复杂的业务逻辑（变量值）动态决定使用哪个事务管理器，或者是否需要事务。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-2-最佳实践"><a href="#5-2-最佳实践" class="headerlink" title="5.2 最佳实践"></a>5.2 最佳实践</h3><p>写出“能跑”的事务代码很容易，写出“高性能、高可靠”的事务代码需要遵循以下原则。</p>
<h4 id="5-2-1-Service-层事务使用的“黄金法则”"><a href="#5-2-1-Service-层事务使用的“黄金法则”" class="headerlink" title="5.2.1 Service 层事务使用的“黄金法则”"></a>5.2.1 Service 层事务使用的“黄金法则”</h4><ol>
<li><strong>位置法则</strong>：事务注解应该加在 <strong>Service 层</strong>（业务逻辑层），而不是 DAO 层（太细，无法组合原子操作）或 Controller 层（太粗，且包含 HTTP 请求处理）。</li>
<li><strong>兜底法则</strong>：在类级别配置只读，在方法级别覆盖写操作。</li>
<li><strong>异常法则</strong>：永远记得处理 Checked Exception。</li>
</ol>
<p><strong>标准代码模版</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="comment">// 【规则1】类级别设置只读：默认所有方法只读，优化性能，防止误写</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = true)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderDao orderDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【规则2】查询方法直接继承类级别配置，无需额外注解</span></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">getOrder</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orderDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【规则3】写入方法单独覆盖配置</span></span><br><span class="line">    <span class="comment">// 【规则4】务必指定 rollbackFor = Exception.class，防止受检异常造成部分提交</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false, rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        orderDao.save(order);</span><br><span class="line">        <span class="comment">// ... 其他写操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-2-2-拒绝“长事务”-Long-Transaction"><a href="#5-2-2-拒绝“长事务”-Long-Transaction" class="headerlink" title="5.2.2 拒绝“长事务” (Long Transaction)"></a>5.2.2 拒绝“长事务” (Long Transaction)</h4><p><strong>什么是长事务？</strong></p>
<p>事务执行时间过长（比如超过 1 秒甚至更久）。</p>
<p><strong>危害</strong>：</p>
<ol>
<li><strong>数据库连接耗尽</strong>：事务不提交，数据库连接（Connection）就被一直占用。高并发下，连接池瞬间被抽干，导致系统瘫痪。</li>
<li><strong>锁定资源</strong>：长时间持有数据库锁，导致其他试图更新同一数据的事务阻塞或死锁。</li>
<li><strong>Undo Log 膨胀</strong>：数据库需要记录大量的回滚日志，影响性能。</li>
</ol>
<p><strong>常见病灶与治疗方案</strong>：</p>
<p><strong>病灶 1：在事务中进行远程调用 (HTTP&#x2F;RPC)</strong></p>
<p>这是最常见的性能杀手。你在事务里调用了一个第三方支付接口，对方响应需要 3 秒，那你的数据库连接就被白白占用了 3 秒。</p>
<ul>
<li><p><strong>错误写法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    userDao.updateBalance(); <span class="comment">// 锁定数据库</span></span><br><span class="line">    httpService.callPayment(); <span class="comment">// 远程调用耗时 3秒 (数据库连接一直被占着)</span></span><br><span class="line">    orderDao.saveOrder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>正确写法 (剥离事务)</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不加事务，或者做成编程式事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 先做远程调用 (非事务)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">paySuccess</span> <span class="operator">=</span> httpService.callPayment(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 只有涉及数据库操作时，才开启事务</span></span><br><span class="line">    <span class="keyword">if</span> (paySuccess) &#123;</span><br><span class="line">        applicationContext.getBean(OrderService.class).saveOrderData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveOrderData</span><span class="params">()</span> &#123;</span><br><span class="line">    userDao.updateBalance();</span><br><span class="line">    orderDao.saveOrder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>病灶 2：在事务中处理大量文件&#x2F;计算</strong></p>
<p>例如：读取 Excel、解析、然后插入数据库。解析过程非常慢，不应该包含在事务中。</p>
<ul>
<li><strong>策略</strong>：先解析（非事务），解析成 Java 对象集合后，再一次性批量插入（开启事务）。</li>
</ul>
<p><strong>总结一句话</strong>：<strong>事务的范围越小越好。只把“必须同生共死”的数据库操作放入事务，其他操作通通踢出去。</strong></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/ORM%E6%A1%86%E6%9E%B6/" rel="prev" title="ORM框架">
                  <i class="fa fa-angle-left"></i> ORM框架
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringBoot/" rel="next" title="Spring全家桶-SpringBoot">
                  Spring全家桶-SpringBoot <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
