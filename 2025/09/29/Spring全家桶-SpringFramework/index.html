<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="前言：Spring生态系统1. Spring是什么？Spring 是一个开源的、轻量级的Java应用程序开发框架，其最初目标是为了简化传统 Java EE（企业级应用）的开发。 可以从三个层面理解它：  从思想层面：Spring 是一个**“管理对象”的容器**。它基于两大核心思想： 控制反转 (IoC - Inversion of Control)：将对象的创建权和依赖关系的管理权从代码中移交给">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring全家桶-SpringFramework">
<meta property="og:url" content="http://example.com/2025/09/29/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringFramework/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="前言：Spring生态系统1. Spring是什么？Spring 是一个开源的、轻量级的Java应用程序开发框架，其最初目标是为了简化传统 Java EE（企业级应用）的开发。 可以从三个层面理解它：  从思想层面：Spring 是一个**“管理对象”的容器**。它基于两大核心思想： 控制反转 (IoC - Inversion of Control)：将对象的创建权和依赖关系的管理权从代码中移交给">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-09-29T07:53:40.000Z">
<meta property="article:modified_time" content="2025-10-05T06:23:58.198Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/09/29/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringFramework/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/09/29/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringFramework/","path":"2025/09/29/Spring全家桶-SpringFramework/","title":"Spring全家桶-SpringFramework"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Spring全家桶-SpringFramework | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80%EF%BC%9ASpring%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.</span> <span class="nav-text">前言：Spring生态系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Spring%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">1. Spring是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Spring%E5%85%A8%E5%AE%B6%E6%A1%B6"><span class="nav-number">1.2.</span> <span class="nav-text">2. Spring全家桶</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81SpringFramework-%E6%A0%B8%E5%BF%83"><span class="nav-number">2.</span> <span class="nav-text">一、SpringFramework 核心</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8-IoC-DI"><span class="nav-number">2.1.</span> <span class="nav-text">1. 核心容器 (IoC &amp; DI)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-IoC"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.1 控制反转(IoC)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9D%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E2%80%9D%EF%BC%9F"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">1.1.1 什么是”控制反转”？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-IoC%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">1.1.2 IoC实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-Dependency-Injection-DI"><span class="nav-number">2.1.1.2.1.</span> <span class="nav-text">1. 依赖注入 (Dependency Injection - DI)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BE%9D%E8%B5%96%E6%9F%A5%E6%89%BE-Dependency-Lookup-DL"><span class="nav-number">2.1.1.2.2.</span> <span class="nav-text">2. 依赖查找 (Dependency Lookup - DL)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-DI-%E4%B8%8E-DL-%E7%9A%84%E5%AF%B9%E6%AF%94%E4%B8%8E%E6%80%BB%E7%BB%93"><span class="nav-number">2.1.1.2.3.</span> <span class="nav-text">3. DI 与 DL 的对比与总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Spring-IoC%E5%AE%B9%E5%99%A8"><span class="nav-number">2.1.2.</span> <span class="nav-text">1.2 Spring IoC容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E5%AE%B9%E5%99%A8%E7%9A%84%E8%81%8C%E8%B4%A3"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">1.2.1 容器的职责</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Bean%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%A3%85%E9%85%8D-Bean-Creation-and-Wiring"><span class="nav-number">2.1.2.1.1.</span> <span class="nav-text">1. Bean的创建与装配 (Bean Creation and Wiring)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%AE%A1%E7%90%86-Bean-Lifecycle-Man-agement"><span class="nav-number">2.1.2.1.2.</span> <span class="nav-text">2. Bean生命周期的管理 (Bean Lifecycle Man                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            agement)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E9%85%8D%E7%BD%AE%E7%9A%84%E9%9B%86%E4%B8%AD%E7%AE%A1%E7%90%86-Centralized-Configuration"><span class="nav-number">2.1.2.1.3.</span> <span class="nav-text">3. 配置的集中管理 (Centralized Configuration)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%8F%90%E4%BE%9B%E9%AB%98%E7%BA%A7%E6%9C%8D%E5%8A%A1%E4%B8%8E%E9%9B%86%E6%88%90-Providing-Advanced-Services"><span class="nav-number">2.1.2.1.4.</span> <span class="nav-text">4. 提供高级服务与集成 (Providing Advanced Services)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E4%B8%A4%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">1.2.2 两大核心接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-BeanFactory-IoC%E5%AE%B9%E5%99%A8%E7%9A%84%E2%80%9C%E5%BF%83%E8%84%8F%E2%80%9D"><span class="nav-number">2.1.2.2.1.</span> <span class="nav-text">1. BeanFactory - IoC容器的“心脏”</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-ApplicationContext-%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%A4%87%E7%9A%84%E2%80%9C%E4%BC%81%E4%B8%9A%E7%BA%A7%E2%80%9D%E5%AE%B9%E5%99%A8"><span class="nav-number">2.1.2.2.2.</span> <span class="nav-text">2. ApplicationContext - 功能完备的“企业级”容器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="nav-number">2.1.2.2.3.</span> <span class="nav-text">3. 总结与对比</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-ApplicationContext-%E7%9A%84%E5%85%B3%E9%94%AE%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">1.2.3 ApplicationContext 的关键实现类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-ClassPathXmlApplicationContext-%E4%BB%8E%E7%B1%BB%E8%B7%AF%E5%BE%84%E5%8A%A0%E8%BD%BDXML"><span class="nav-number">2.1.2.3.1.</span> <span class="nav-text">1. ClassPathXmlApplicationContext: 从类路径加载XML</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%81%8C%E8%B4%A3"><span class="nav-number">2.1.2.3.1.1.</span> <span class="nav-text">a). 定义与职责</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E7%B1%BB%E8%B7%AF%E5%BE%84-Classpath-%E2%80%9D%EF%BC%9F"><span class="nav-number">2.1.2.3.1.2.</span> <span class="nav-text">b). 关键概念：什么是“类路径 (Classpath)”？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.1.2.3.1.3.</span> <span class="nav-text">c). 使用示例</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#d-%E5%8A%A0%E8%BD%BD%E5%A4%9A%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">2.1.2.3.1.4.</span> <span class="nav-text">d). 加载多个配置文件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#e-%E6%80%BB%E7%BB%93"><span class="nav-number">2.1.2.3.1.5.</span> <span class="nav-text">e). 总结</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-FileSystemXmlApplicationContext-%E4%BB%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8A%A0%E8%BD%BDXML"><span class="nav-number">2.1.2.3.2.</span> <span class="nav-text">2. FileSystemXmlApplicationContext: 从文件系统加载XML</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%81%8C%E8%B4%A3-1"><span class="nav-number">2.1.2.3.2.1.</span> <span class="nav-text">a). 定义与职责</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%B7%AF%E5%BE%84-vs-%E7%B1%BB%E8%B7%AF%E5%BE%84"><span class="nav-number">2.1.2.3.2.2.</span> <span class="nav-text">b). 关键概念：文件系统路径 vs 类路径</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">2.1.2.3.2.3.</span> <span class="nav-text">c). 使用示例</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#d-ClassPathXmlApplicationContext-vs-FileSystemXmlApplicationContext"><span class="nav-number">2.1.2.3.2.4.</span> <span class="nav-text">d). ClassPathXmlApplicationContext vs FileSystemXmlApplicationContext</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#e-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.1.2.3.2.5.</span> <span class="nav-text">e). 适用场景</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-AnnotationConfigApplicationContext-%E4%BB%8EJava%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="nav-number">2.1.2.3.3.</span> <span class="nav-text">3. AnnotationConfigApplicationContext: 从Java配置类加载</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%81%8C%E8%B4%A3-2"><span class="nav-number">2.1.2.3.3.1.</span> <span class="nav-text">a). 定义与职责</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E5%85%B3%E9%94%AE%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.1.2.3.3.2.</span> <span class="nav-text">b). 关键注解</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">2.1.2.3.3.3.</span> <span class="nav-text">c). 使用示例</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#d-%E7%BB%93%E5%90%88%E7%BB%84%E4%BB%B6%E6%89%AB%E6%8F%8F-ComponentScan"><span class="nav-number">2.1.2.3.3.4.</span> <span class="nav-text">d). 结合组件扫描 (@ComponentScan)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#e-Java%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%AF%B9%E4%BA%8EXML%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">2.1.2.3.3.5.</span> <span class="nav-text">e). Java配置相对于XML的优势</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-WebApplicationContext-Web%E5%BA%94%E7%94%A8%E4%B8%93%E5%B1%9E%EF%BC%8C%E4%B8%8EServletContext%E9%9B%86%E6%88%90"><span class="nav-number">2.1.2.3.4.</span> <span class="nav-text">4. WebApplicationContext: Web应用专属，与ServletContext集成</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%A0%B8%E5%BF%83%E8%A7%92%E8%89%B2"><span class="nav-number">2.1.2.3.4.1.</span> <span class="nav-text">a). 定义与核心角色</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E4%B8%8EServletContext%E7%9A%84%E9%9B%86%E6%88%90%E5%85%B3%E7%B3%BB"><span class="nav-number">2.1.2.3.4.2.</span> <span class="nav-text">b). 与ServletContext的集成关系</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F-%E4%BC%A0%E7%BB%9FWeb%E5%BA%94%E7%94%A8"><span class="nav-number">2.1.2.3.4.3.</span> <span class="nav-text">c). 生命周期与创建方式 (传统Web应用)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#d-%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8%E7%BB%93%E6%9E%84-Parent-Child-Container-Structure"><span class="nav-number">2.1.2.3.4.4.</span> <span class="nav-text">d). 父子容器结构 (Parent-Child Container Structure)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#e-%E5%9C%A8Spring-Boot%E4%B8%AD%E7%9A%84%E6%BC%94%E5%8F%98"><span class="nav-number">2.1.2.3.4.5.</span> <span class="nav-text">e). 在Spring Boot中的演变</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Bean"><span class="nav-number">2.1.3.</span> <span class="nav-text">1.3 Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-%E4%BB%80%E4%B9%88%E6%98%AFBean%EF%BC%9F"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">1.3.1 什么是Bean？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.3.1.1.</span> <span class="nav-text">1. 核心定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BB%8E%E5%AF%B9%E8%B1%A1-Object-%E5%88%B0Bean%E7%9A%84%E8%BD%AC%E5%8F%98"><span class="nav-number">2.1.3.1.2.</span> <span class="nav-text">2. 从对象(Object)到Bean的转变</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Bean%E7%9A%84%E5%85%B3%E9%94%AE%E7%89%B9%E5%BE%81"><span class="nav-number">2.1.3.1.3.</span> <span class="nav-text">3. Bean的关键特征</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%80%BB%E7%BB%93"><span class="nav-number">2.1.3.1.4.</span> <span class="nav-text">4. 总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-%E5%A3%B0%E6%98%8EBean%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%BB%E6%B5%81%E6%96%B9%E5%BC%8F"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">1.3.2 声明Bean的三种主流方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-XML%E9%85%8D%E7%BD%AE"><span class="nav-number">2.1.3.2.1.</span> <span class="nav-text">1. XML配置</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E6%A0%B8%E5%BF%83%E6%A0%87%E7%AD%BE%EF%BC%9A"><span class="nav-number">2.1.3.2.1.1.</span> <span class="nav-text">a). 核心标签：&lt;bean&gt;</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-DI-in-XML"><span class="nav-number">2.1.3.2.1.2.</span> <span class="nav-text">b). 依赖注入 (DI) in XML</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF"><span class="nav-number">2.1.3.2.1.3.</span> <span class="nav-text">c). 优势与劣势</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8-Component-Service-Repository-Controller"><span class="nav-number">2.1.3.2.2.</span> <span class="nav-text">2. 注解驱动 (@Component, @Service, @Repository, @Controller)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%89%AB%E6%8F%8F-Component-Scanning"><span class="nav-number">2.1.3.2.2.1.</span> <span class="nav-text">a). 核心思想：组件扫描 (Component Scanning)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E5%90%AF%E7%94%A8%E7%BB%84%E4%BB%B6%E6%89%AB%E6%8F%8F"><span class="nav-number">2.1.3.2.2.2.</span> <span class="nav-text">b). 启用组件扫描</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%EF%BC%9A-Component-%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.1.3.2.2.3.</span> <span class="nav-text">c). 核心注解：@Component 及其衍生注解</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#d-%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF"><span class="nav-number">2.1.3.2.2.4.</span> <span class="nav-text">d). 优势与劣势</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Java-Config-Configuration-Bean"><span class="nav-number">2.1.3.2.3.</span> <span class="nav-text">3. Java Config (@Configuration, @Bean)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E4%BB%80%E4%B9%88%E6%98%AFJava-Config%EF%BC%9F"><span class="nav-number">2.1.3.2.3.1.</span> <span class="nav-text">a). 什么是Java Config？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.1.3.2.3.2.</span> <span class="nav-text">b). 核心注解详解</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-SpringBoot%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.1.3.2.3.3.</span> <span class="nav-text">c). SpringBoot中的实际应用与示例</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#d-Java-Config-%E4%B8%8E-ComponentScan-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.1.3.2.3.4.</span> <span class="nav-text">d). Java Config 与 @ComponentScan 的关系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3-%E7%BB%84%E4%BB%B6%E6%89%AB%E6%8F%8F-ComponentScan-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">1.3.3 组件扫描(@ComponentScan)的工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E7%9B%AE%E6%A0%87"><span class="nav-number">2.1.3.3.1.</span> <span class="nav-text">1. 核心目标</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.1.3.3.2.</span> <span class="nav-text">2. 工作流程详解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E7%A4%BA%E4%BE%8B%E4%B8%8E%E6%80%BB%E7%BB%93"><span class="nav-number">2.1.3.3.3.</span> <span class="nav-text">3. 示例与总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-DI"><span class="nav-number">2.1.4.</span> <span class="nav-text">1.4 依赖注入(DI)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-Setter%E6%B3%A8%E5%85%A5"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">1.4.1 Setter注入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.4.1.1.</span> <span class="nav-text">1. 定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.4.1.2.</span> <span class="nav-text">2. 工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.1.4.1.3.</span> <span class="nav-text">3. 代码示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E4%BC%98%E7%82%B9"><span class="nav-number">2.1.4.1.4.</span> <span class="nav-text">4. 优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E7%BC%BA%E7%82%B9%EF%BC%88%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%83%E4%B8%8D%E5%86%8D%E6%98%AF%E9%A6%96%E9%80%89%EF%BC%89"><span class="nav-number">2.1.4.1.5.</span> <span class="nav-text">5. 缺点（以及为什么它不再是首选）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-2-%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5-%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">1.4.2 构造器注入 (官方推荐)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89-1"><span class="nav-number">2.1.4.2.1.</span> <span class="nav-text">1. 定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1"><span class="nav-number">2.1.4.2.2.</span> <span class="nav-text">2. 工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">2.1.4.2.3.</span> <span class="nav-text">3. 代码示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E4%BC%98%E7%82%B9-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90%EF%BC%9F"><span class="nav-number">2.1.4.2.4.</span> <span class="nav-text">4. 优点 (为什么官方推荐？)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E7%BC%BA%E7%82%B9-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.1.4.2.5.</span> <span class="nav-text">5. 缺点&#x2F;注意事项</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-3-%E5%AD%97%E6%AE%B5%E6%B3%A8%E5%85%A5-%E7%AE%80%E6%B4%81%E4%BD%86%E4%B8%8D%E6%8E%A8%E8%8D%90"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">1.4.3 字段注入 (简洁但不推荐)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89-2"><span class="nav-number">2.1.4.3.1.</span> <span class="nav-text">1. 定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-2"><span class="nav-number">2.1.4.3.2.</span> <span class="nav-text">2. 工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">2.1.4.3.3.</span> <span class="nav-text">3. 代码示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E4%BC%98%E7%82%B9%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BA%BA%E4%BB%AC%E4%BC%9A%E7%94%A8%E5%AE%83%EF%BC%9F%EF%BC%89"><span class="nav-number">2.1.4.3.4.</span> <span class="nav-text">4. 优点（为什么人们会用它？）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E7%BC%BA%E7%82%B9%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%98%E6%96%B9%E5%92%8C%E7%A4%BE%E5%8C%BA%E5%BC%BA%E7%83%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%9F%EF%BC%89"><span class="nav-number">2.1.4.3.5.</span> <span class="nav-text">5. 缺点（为什么官方和社区强烈不推荐？）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%8E%A5%E5%8F%97%E7%9A%84%E4%BE%8B%E5%A4%96%E5%9C%BA%E6%99%AF"><span class="nav-number">2.1.4.3.6.</span> <span class="nav-text">6. 一个可以接受的例外场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9C%80%E7%BB%88%E5%AF%B9%E6%AF%94"><span class="nav-number">2.1.4.3.7.</span> <span class="nav-text">总结与最终对比</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-4-Autowired-Resource-Inject-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.4.4.</span> <span class="nav-text">1.4.4 @Autowired, @Resource, @Inject 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Autowired"><span class="nav-number">2.1.4.4.1.</span> <span class="nav-text">1. @Autowired</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Resource"><span class="nav-number">2.1.4.4.2.</span> <span class="nav-text">2. @Resource</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Inject"><span class="nav-number">2.1.4.4.3.</span> <span class="nav-text">3. @Inject</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%80%BB%E7%BB%93%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB%EF%BC%88%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%EF%BC%89"><span class="nav-number">2.1.4.4.4.</span> <span class="nav-text">3. 总结与核心区别（面试高频）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-SpringBoot%E4%B8%AD%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%92%8C%E9%80%89%E6%8B%A9"><span class="nav-number">2.1.4.4.5.</span> <span class="nav-text">4. SpringBoot中的最佳实践和选择</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-5-%E8%A7%A3%E5%86%B3%E6%B3%A8%E5%85%A5%E6%AD%A7%E4%B9%89-Primary-%E4%B8%8E-Qualifier"><span class="nav-number">2.1.4.5.</span> <span class="nav-text">1.4.5 解决注入歧义(@Primary 与 @Qualifier)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%A8%E5%85%A5%E6%AD%A7%E4%B9%89%EF%BC%9F"><span class="nav-number">2.1.4.5.1.</span> <span class="nav-text">1. 问题场景：什么是注入歧义？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%80-Primary-%E6%8C%87%E5%AE%9A%E2%80%9C%E9%A6%96%E9%80%89%E2%80%9DBean"><span class="nav-number">2.1.4.5.2.</span> <span class="nav-text">2. 解决方案一: @Primary - 指定“首选”Bean</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BA%8C-Qualifier-%E6%8C%87%E5%AE%9A%E2%80%9C%E9%99%90%E5%AE%9A%E2%80%9DBean"><span class="nav-number">2.1.4.5.3.</span> <span class="nav-text">3. 解决方案二: @Qualifier - 指定“限定”Bean</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-Primary-vs-Qualifier-%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">2.1.4.5.4.</span> <span class="nav-text">4. @Primary vs. @Qualifier - 总结与最佳实践</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">2.1.5.</span> <span class="nav-text">1.5  Bean的生命周期与作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-Bean%E7%9A%84%E5%AE%8C%E6%95%B4%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">1.5.1 Bean的完整生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%88%E7%AE%80%E5%8C%96%E7%89%88%EF%BC%89"><span class="nav-number">2.1.5.1.1.</span> <span class="nav-text">1. 整体流程图（简化版）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4%E5%88%86%E8%A7%A3"><span class="nav-number">2.1.5.1.2.</span> <span class="nav-text">2. 详细步骤分解</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%8C%96-Instantiation"><span class="nav-number">2.1.5.1.2.1.</span> <span class="nav-text">阶段一：实例化 (Instantiation)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9A%E5%B1%9E%E6%80%A7%E5%A1%AB%E5%85%85-Population"><span class="nav-number">2.1.5.1.2.2.</span> <span class="nav-text">阶段二：属性填充 (Population)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96-Initialization-%E8%BF%99%E6%98%AF%E6%9C%80%E5%A4%8D%E6%9D%82%E4%B9%9F%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E9%98%B6%E6%AE%B5"><span class="nav-number">2.1.5.1.2.3.</span> <span class="nav-text">阶段三：初始化 (Initialization) - 这是最复杂也最重要的阶段</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E5%9B%9B%EF%BC%9ABean%E5%8F%AF%E7%94%A8-In-Use"><span class="nav-number">2.1.5.1.2.4.</span> <span class="nav-text">阶段四：Bean可用 (In Use)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%94%EF%BC%9A%E9%94%80%E6%AF%81-Destruction"><span class="nav-number">2.1.5.1.2.5.</span> <span class="nav-text">阶段五：销毁 (Destruction)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E7%BB%BC%E5%90%88%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.1.5.1.3.</span> <span class="nav-text">3. 综合代码示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-2-BeanPostProcessor-%E4%B8%8E-BeanFactoryPostProcessor"><span class="nav-number">2.1.5.2.</span> <span class="nav-text">1.5.2 BeanPostProcessor 与 BeanFactoryPostProcessor</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB%E4%B8%80%E8%A7%88"><span class="nav-number">2.1.5.2.1.</span> <span class="nav-text">1. 核心区别一览</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-analogy-%E6%B1%BD%E8%BD%A6%E5%88%B6%E9%80%A0%E5%8E%82%E7%9A%84%E6%AF%94%E5%96%BB"><span class="nav-number">2.1.5.2.2.</span> <span class="nav-text">2. analogy: 汽车制造厂的比喻</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-BeanFactoryPostProcessor"><span class="nav-number">2.1.5.2.3.</span> <span class="nav-text">3. 深入解析 BeanFactoryPostProcessor</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E5%AE%83%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="nav-number">2.1.5.2.3.1.</span> <span class="nav-text">a). 它是做什么的？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E5%AE%83%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="nav-number">2.1.5.2.3.2.</span> <span class="nav-text">b). 它是怎么工作的？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-%E5%AE%9E%E9%99%85%E7%9A%84Spring%E5%86%85%E9%83%A8%E7%94%A8%E4%BE%8B"><span class="nav-number">2.1.5.2.3.3.</span> <span class="nav-text">c). 实际的Spring内部用例</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#d-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.1.5.2.3.4.</span> <span class="nav-text">d). 自定义示例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-BeanPostProcessor"><span class="nav-number">2.1.5.2.4.</span> <span class="nav-text">4. 深入解析 BeanPostProcessor</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E5%AE%83%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F-1"><span class="nav-number">2.1.5.2.4.1.</span> <span class="nav-text">a). 它是做什么的？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E5%AE%83%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F-1"><span class="nav-number">2.1.5.2.4.2.</span> <span class="nav-text">b). 它是怎么工作的？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-%E5%AE%9E%E9%99%85%E7%9A%84Spring%E5%86%85%E9%83%A8%E7%94%A8%E4%BE%8B-1"><span class="nav-number">2.1.5.2.4.3.</span> <span class="nav-text">c). 实际的Spring内部用例</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#d-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">2.1.5.2.4.4.</span> <span class="nav-text">d). 自定义示例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%80%BB%E7%BB%93"><span class="nav-number">2.1.5.2.5.</span> <span class="nav-text">5. 总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E9%94%80%E6%AF%81%E5%9B%9E%E8%B0%83"><span class="nav-number">2.1.5.3.</span> <span class="nav-text">1.5.3 初始化与销毁回调</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%BF%99%E4%BA%9B%E5%9B%9E%E8%B0%83%EF%BC%9F"><span class="nav-number">2.1.5.3.1.</span> <span class="nav-text">1. 为什么需要这些回调？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9B%9E%E8%B0%83-Initialization-Callbacks"><span class="nav-number">2.1.5.3.2.</span> <span class="nav-text">2. 初始化回调 (Initialization Callbacks)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E4%BD%BF%E7%94%A8-JSR-250-%E7%9A%84-PostConstruct-%E6%B3%A8%E8%A7%A3-%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90"><span class="nav-number">2.1.5.3.2.1.</span> <span class="nav-text">a). 使用 JSR-250 的 @PostConstruct 注解 (官方推荐)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E5%AE%9E%E7%8E%B0-InitializingBean-%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.1.5.3.2.2.</span> <span class="nav-text">b). 实现 InitializingBean 接口</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-%E4%BD%BF%E7%94%A8-Bean-%E7%9A%84-initMethod-%E5%B1%9E%E6%80%A7"><span class="nav-number">2.1.5.3.2.3.</span> <span class="nav-text">c). 使用 @Bean 的 initMethod 属性</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E9%94%80%E6%AF%81%E5%9B%9E%E8%B0%83-Destruction-Callbacks"><span class="nav-number">2.1.5.3.3.</span> <span class="nav-text">3. 销毁回调 (Destruction Callbacks)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E4%BD%BF%E7%94%A8-JSR-250-%E7%9A%84-PreDestroy-%E6%B3%A8%E8%A7%A3-%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90"><span class="nav-number">2.1.5.3.3.1.</span> <span class="nav-text">a). 使用 JSR-250 的 @PreDestroy 注解 (官方推荐)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E5%AE%9E%E7%8E%B0-DisposableBean-%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.1.5.3.3.2.</span> <span class="nav-text">b). 实现 DisposableBean 接口</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-%E4%BD%BF%E7%94%A8-Bean-%E7%9A%84-destroyMethod-%E5%B1%9E%E6%80%A7"><span class="nav-number">2.1.5.3.3.3.</span> <span class="nav-text">c). 使用 @Bean 的 destroyMethod 属性</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.1.5.3.4.</span> <span class="nav-text">4. 执行顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">2.1.5.3.5.</span> <span class="nav-text">5. 总结与最佳实践</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-4-Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">2.1.5.4.</span> <span class="nav-text">1.5.4 Bean的作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="nav-number">2.1.5.4.1.</span> <span class="nav-text">1. 什么是Bean的作用域？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Spring%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">2.1.5.4.2.</span> <span class="nav-text">2. Spring的核心作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-singleton-%E5%8D%95%E4%BE%8B-%E9%BB%98%E8%AE%A4%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">2.1.5.4.2.1.</span> <span class="nav-text">a). singleton (单例) - 默认作用域</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-prototype-%E5%8E%9F%E5%9E%8B-%E5%A4%9A%E4%BE%8B"><span class="nav-number">2.1.5.4.2.2.</span> <span class="nav-text">b). prototype (原型&#x2F;多例)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Web%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E9%A2%9D%E5%A4%96%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">2.1.5.4.3.</span> <span class="nav-text">3. Web应用中的额外作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-request"><span class="nav-number">2.1.5.4.3.1.</span> <span class="nav-text">a). request</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-session"><span class="nav-number">2.1.5.4.3.2.</span> <span class="nav-text">b). session</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-application"><span class="nav-number">2.1.5.4.3.3.</span> <span class="nav-text">c). application</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#d-websocket-%E8%BE%83%E6%96%B0"><span class="nav-number">2.1.5.4.3.4.</span> <span class="nav-text">d). websocket (较新)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A3%E7%90%86-Scoped-Proxies-%E8%A7%A3%E5%86%B3%E6%B3%A8%E5%85%A5%E9%9A%BE%E9%A2%98"><span class="nav-number">2.1.5.4.4.</span> <span class="nav-text">4. 作用域代理 (Scoped Proxies) - 解决注入难题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%80%BB%E7%BB%93-1"><span class="nav-number">2.1.5.4.5.</span> <span class="nav-text">5. 总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-5-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-number">2.1.5.5.</span> <span class="nav-text">1.5.5 循环依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%9F"><span class="nav-number">2.1.5.5.1.</span> <span class="nav-text">1. 什么是循环依赖？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Spring%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F-%E4%BB%85%E9%99%90Setter-%E5%AD%97%E6%AE%B5%E6%B3%A8%E5%85%A5"><span class="nav-number">2.1.5.5.2.</span> <span class="nav-text">2. Spring是如何解决的？(仅限Setter&#x2F;字段注入)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%80%8C%E4%B8%8D%E6%98%AF%E4%BA%8C%E7%BA%A7%EF%BC%9F"><span class="nav-number">2.1.5.5.3.</span> <span class="nav-text">3. 为什么需要三级缓存而不是二级？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-Spring%E6%97%A0%E6%B3%95%E8%A7%A3%E5%86%B3%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-number">2.1.5.5.4.</span> <span class="nav-text">4. Spring无法解决的循环依赖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9A%E9%81%BF%E5%85%8D%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-number">2.1.5.5.5.</span> <span class="nav-text">5. 最佳实践：避免循环依赖</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">2. 面向切面编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-AOP%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.1 AOP核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81AOP%EF%BC%9F%EF%BC%88The-%E2%80%9CWhy%E2%80%9D%EF%BC%89"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">2.1.1 为什么需要AOP？（The “Why”）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-AOP%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%AF%E8%AF%AD%EF%BC%88The-%E2%80%9CWhat%E2%80%9D-and-%E2%80%9CHow%E2%80%9D%EF%BC%89"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">2.1.2 AOP的核心术语（The “What” and “How”）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Aspect-%E5%88%87%E9%9D%A2"><span class="nav-number">2.2.1.2.1.</span> <span class="nav-text">1. Aspect (切面)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Join-Point-%E8%BF%9E%E6%8E%A5%E7%82%B9"><span class="nav-number">2.2.1.2.2.</span> <span class="nav-text">2. Join Point (连接点)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Pointcut-%E5%88%87%E7%82%B9"><span class="nav-number">2.2.1.2.3.</span> <span class="nav-text">3. Pointcut (切点)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-Advice-%E9%80%9A%E7%9F%A5"><span class="nav-number">2.2.1.2.4.</span> <span class="nav-text">4. Advice (通知)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-Target-Object-%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.2.1.2.5.</span> <span class="nav-text">5. Target Object (目标对象)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-Proxy-%E4%BB%A3%E7%90%86"><span class="nav-number">2.2.1.2.6.</span> <span class="nav-text">6. Proxy (代理)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-Weaving-%E7%BB%87%E5%85%A5"><span class="nav-number">2.2.1.2.7.</span> <span class="nav-text">7. Weaving (织入)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">2.1.3 总结与关系图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Advice%E7%9A%84%E4%BA%94%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2 Advice的五种类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">2.2.1 准备工作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%88%91%E4%BB%AC%E7%9A%84%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.2.2.1.1.</span> <span class="nav-text">1. 我们的目标对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%88%91%E4%BB%AC%E7%9A%84%E5%88%87%E9%9D%A2%E5%92%8C%E5%88%87%E7%82%B9"><span class="nav-number">2.2.2.1.2.</span> <span class="nav-text">2. 我们的切面和切点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-Advice%E7%9A%84%E4%BA%94%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">2.2.2 Advice的五种类型详解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Before-%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5"><span class="nav-number">2.2.2.2.1.</span> <span class="nav-text">1. @Before (前置通知)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-AfterReturning-%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5-%E8%BF%94%E5%9B%9E%E9%80%9A%E7%9F%A5"><span class="nav-number">2.2.2.2.2.</span> <span class="nav-text">2. @AfterReturning (后置通知&#x2F;返回通知)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-AfterThrowing-%E5%BC%82%E5%B8%B8%E9%80%9A%E7%9F%A5"><span class="nav-number">2.2.2.2.3.</span> <span class="nav-text">3. @AfterThrowing (异常通知)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-After-%E6%9C%80%E7%BB%88%E9%80%9A%E7%9F%A5"><span class="nav-number">2.2.2.2.4.</span> <span class="nav-text">4. @After (最终通知)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-Around-%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5"><span class="nav-number">2.2.2.2.5.</span> <span class="nav-text">5. @Around (环绕通知)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%80%BB%E7%BB%93"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">执行顺序总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Pointcut%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.3 Pointcut表达式语法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-execution-%E6%9C%80%E5%B8%B8%E7%94%A8%E3%80%81%E6%9C%80%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">1. execution - 最常用、最强大的指示符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-within-%E5%8C%B9%E9%85%8D%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E5%86%85%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">2. within - 匹配指定类型内的所有方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-annotation-%E5%8C%B9%E9%85%8D%E5%B8%A6%E6%9C%89%E6%8C%87%E5%AE%9A%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">3. @annotation - 匹配带有指定注解的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-within-%E5%8C%B9%E9%85%8D%E5%B8%A6%E6%9C%89%E6%8C%87%E5%AE%9A%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.3.4.</span> <span class="nav-text">4. @within - 匹配带有指定注解的类中的所有方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-bean-%E5%8C%B9%E9%85%8D%E6%8C%87%E5%AE%9A%E5%90%8D%E7%A7%B0%E7%9A%84Spring-Bean"><span class="nav-number">2.2.3.5.</span> <span class="nav-text">5. bean - 匹配指定名称的Spring Bean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">2.2.3.6.</span> <span class="nav-text">6. 组合使用与最佳实践</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E8%A1%A8"><span class="nav-number">2.2.3.7.</span> <span class="nav-text">总结表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-AOP%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-vs-CGLIB"><span class="nav-number">2.2.4.</span> <span class="nav-text">2.4 AOP的实现原理 (JDK动态代理 vs CGLIB)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-%E2%80%9C%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BC%AA%E8%A3%85%E8%80%85%E2%80%9D"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">2.4.1 JDK动态代理 - “基于接口的伪装者”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-%E2%80%9C%E5%9F%BA%E4%BA%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A2%9E%E5%BC%BA%E8%80%85%E2%80%9D"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">2.4.2 CGLIB动态代理 - “基于继承的增强者”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-Spring-Boot%E4%B8%AD%E7%9A%84%E9%80%89%E6%8B%A9%E4%B8%8E%E6%BC%94%E5%8F%98"><span class="nav-number">2.2.4.3.</span> <span class="nav-text">2.4.3 Spring Boot中的选择与演变</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-4-%E6%A0%B8%E5%BF%83%E5%9B%9E%E9%A1%BE%E8%A1%A8"><span class="nav-number">2.2.4.4.</span> <span class="nav-text">2.4.4 核心回顾表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-number">2.3.</span> <span class="nav-text">3. 事务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">2.3.1.</span> <span class="nav-text">3.1 声明式事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7"><span class="nav-number">2.3.2.</span> <span class="nav-text">3.2 事务的核心属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">3.2.1 传播行为</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.2.1.1.</span> <span class="nav-text">1. 核心问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%94%AF%E6%8C%81%E5%9E%8B%EF%BC%88%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA%EF%BC%89"><span class="nav-number">2.3.2.1.2.</span> <span class="nav-text">2. 支持型（默认行为）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-Propagation-REQUIRED-%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">2.3.2.1.2.1.</span> <span class="nav-text">a). Propagation.REQUIRED (默认值)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-Propagation-SUPPORTS"><span class="nav-number">2.3.2.1.2.2.</span> <span class="nav-text">b). Propagation.SUPPORTS</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-Propagation-MANDATORY"><span class="nav-number">2.3.2.1.2.3.</span> <span class="nav-text">c). Propagation.MANDATORY</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E7%8B%AC%E7%AB%8B%E5%9E%8B"><span class="nav-number">2.3.2.1.3.</span> <span class="nav-text">3. 独立型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-Propagation-REQUIRES-NEW"><span class="nav-number">2.3.2.1.3.1.</span> <span class="nav-text">a). Propagation.REQUIRES_NEW</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-Propagation-NOT-SUPPORTED"><span class="nav-number">2.3.2.1.3.2.</span> <span class="nav-text">b). Propagation.NOT_SUPPORTED</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-Propagation-NEVER"><span class="nav-number">2.3.2.1.3.3.</span> <span class="nav-text">c). Propagation.NEVER</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%B5%8C%E5%A5%97%E5%9E%8B"><span class="nav-number">2.3.2.1.4.</span> <span class="nav-text">4. 嵌套型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-Propagation-NESTED"><span class="nav-number">2.3.2.1.4.1.</span> <span class="nav-text">a). Propagation.NESTED</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%80%BB%E7%BB%93%E8%A1%A8"><span class="nav-number">2.3.2.1.5.</span> <span class="nav-text">5. 总结表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">3.2.2 隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98-1"><span class="nav-number">2.3.2.2.1.</span> <span class="nav-text">1. 核心问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.2.2.2.</span> <span class="nav-text">2. 并发事务带来的三大问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E8%84%8F%E8%AF%BB-Dirty-Read"><span class="nav-number">2.3.2.2.2.1.</span> <span class="nav-text">a). 脏读 (Dirty Read)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-Non-Repeatable-Read"><span class="nav-number">2.3.2.2.2.2.</span> <span class="nav-text">b). 不可重复读 (Non-Repeatable Read)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-%E5%B9%BB%E8%AF%BB-Phantom-Read"><span class="nav-number">2.3.2.2.2.3.</span> <span class="nav-text">c). 幻读 (Phantom Read)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%9B%9B%E7%A7%8D%E6%A0%87%E5%87%86%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">2.3.2.2.3.</span> <span class="nav-text">3. 四种标准隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-Isolation-READ-UNCOMMITTED-%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4"><span class="nav-number">2.3.2.2.3.1.</span> <span class="nav-text">a).Isolation.READ_UNCOMMITTED (读未提交)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-Isolation-READ-COMMITTED-%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4"><span class="nav-number">2.3.2.2.3.2.</span> <span class="nav-text">b). Isolation.READ_COMMITTED (读已提交)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-Isolation-REPEATABLE-READ-%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="nav-number">2.3.2.2.3.3.</span> <span class="nav-text">c). Isolation.REPEATABLE_READ (可重复读)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#d-Isolation-SERIALIZABLE-%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96"><span class="nav-number">2.3.2.2.3.4.</span> <span class="nav-text">d). Isolation.SERIALIZABLE (可串行化)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%80%BB%E7%BB%93%E4%B8%8E%E9%80%89%E6%8B%A9"><span class="nav-number">2.3.2.2.4.</span> <span class="nav-text">4. 总结与选择</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E5%85%B6%E4%BB%96%E5%B1%9E%E6%80%A7"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">3.2.3 其他属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-readOnly-%E5%8F%AA%E8%AF%BB"><span class="nav-number">2.3.2.3.1.</span> <span class="nav-text">1. readOnly (只读)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-timeout-%E8%B6%85%E6%97%B6"><span class="nav-number">2.3.2.3.2.</span> <span class="nav-text">2. timeout (超时)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%9B%9E%E6%BB%9A%E8%A7%84%E5%88%99-rollbackFor-noRollbackFor"><span class="nav-number">2.3.2.3.3.</span> <span class="nav-text">3. 回滚规则 (rollbackFor, noRollbackFor)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-rollbackFor-%E5%92%8C-rollbackForClassName"><span class="nav-number">2.3.2.3.3.1.</span> <span class="nav-text">a) rollbackFor 和 rollbackForClassName</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-noRollbackFor-%E5%92%8C-noRollbackForClassName"><span class="nav-number">2.3.2.3.3.2.</span> <span class="nav-text">b) noRollbackFor 和 noRollbackForClassName</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%80%BB%E7%BB%93%E8%A1%A8"><span class="nav-number">2.3.2.3.4.</span> <span class="nav-text">4. 总结表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Transactional-%E5%A4%B1%E6%95%88%E7%9A%84%E7%BB%8F%E5%85%B8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.3.3.</span> <span class="nav-text">3.3 @Transactional 失效的经典场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E5%BA%94%E7%94%A8%E5%9C%A8%E9%9D%9E-public-%E6%96%B9%E6%B3%95%E4%B8%8A"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">3.3.1 应用在非 public 方法上</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8%EF%BC%88%E2%80%9C%E8%87%AA%E8%B0%83%E7%94%A8%E2%80%9D%E9%97%AE%E9%A2%98%EF%BC%89"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">3.3.2 方法内部调用（“自调用”问题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-%E5%BC%82%E5%B8%B8%E8%A2%AB-try-catch-%E6%8D%95%E8%8E%B7%E4%B8%94%E6%B2%A1%E6%9C%89%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">3.3.3 异常被 try-catch 捕获且没有重新抛出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%9B%9E%E6%BB%9A%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE-rollbackFor"><span class="nav-number">2.3.3.4.</span> <span class="nav-text">3.3.4 不正确的回滚规则配置 (rollbackFor)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-5-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E%E4%B8%8D%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1"><span class="nav-number">2.3.3.5.</span> <span class="nav-text">3.3.5 数据库引擎不支持事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-6-%E6%80%BB%E7%BB%93%E8%A1%A8"><span class="nav-number">2.3.3.6.</span> <span class="nav-text">3.3.6 总结表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1-vs-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">2.3.4.</span> <span class="nav-text">3.4 编程式事务 vs 声明式事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E5%AF%B9%E6%AF%94"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">3.4.1 核心思想对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">3.4.2 编程式事务的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8-TransactionTemplate-%E6%8E%A8%E8%8D%90%E7%9A%84%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%96%B9%E5%BC%8F"><span class="nav-number">2.3.4.2.1.</span> <span class="nav-text">1. 使用 TransactionTemplate (推荐的编程式方式)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-PlatformTransactionManager-%E6%9B%B4%E5%BA%95%E5%B1%82"><span class="nav-number">2.3.4.2.2.</span> <span class="nav-text">2. 直接使用 PlatformTransactionManager (更底层)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-%E5%85%A8%E9%9D%A2%E6%AF%94%E8%BE%83"><span class="nav-number">2.3.4.3.</span> <span class="nav-text">3.4.3 全面比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-4-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="nav-number">2.3.4.4.</span> <span class="nav-text">3.4.4 什么时候应该考虑使用编程式事务？</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/29/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringFramework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Spring全家桶-SpringFramework | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring全家桶-SpringFramework
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-29 15:53:40" itemprop="dateCreated datePublished" datetime="2025-09-29T15:53:40+08:00">2025-09-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-05 14:23:58" itemprop="dateModified" datetime="2025-10-05T14:23:58+08:00">2025-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="前言：Spring生态系统"><a href="#前言：Spring生态系统" class="headerlink" title="前言：Spring生态系统"></a>前言：Spring生态系统</h1><h2 id="1-Spring是什么？"><a href="#1-Spring是什么？" class="headerlink" title="1. Spring是什么？"></a>1. Spring是什么？</h2><p>Spring 是一个<strong>开源的、轻量级的Java应用程序开发框架</strong>，其最初目标是为了简化传统 Java EE（企业级应用）的开发。</p>
<p>可以从三个层面理解它：</p>
<ol>
<li><strong>从思想层面</strong>：Spring 是一个**“管理对象”的容器**。它基于两大核心思想：<ul>
<li><strong>控制反转 (IoC - Inversion of Control)</strong>：将对象的创建权和依赖关系的管理权从代码中移交给了Spring容器，极大地降低了代码的耦合度。</li>
<li><strong>面向切面编程 (AOP - Aspect-Oriented Programming)</strong>：将日志、事务、安全等“横切关注点”从主业务逻辑中分离出来，提高了代码的模块化程度和可维护性。</li>
</ul>
</li>
<li><strong>从功能层面</strong>：Spring 提供了一整套**“一站式”的企业级应用解决方案**。它不仅仅是一个IoC容器，还无缝整合了Web开发（Spring MVC&#x2F;WebFlux）、数据访问（Spring Data）、事务管理、安全控制（Spring Security）等众多优秀的技术，让开发者无需重复“造轮子”。</li>
<li><strong>从生态层面</strong>：Spring 已经发展成为一个庞大而繁荣的<strong>生态系统 (Ecosystem)</strong>。以 Spring Framework 为基石，衍生出了 Spring Boot（简化开发）、Spring Cloud（微服务治理）等一系列项目，共同构成了现代Java开发的事实标准。</li>
</ol>
<p><strong>总之，Spring 的使命是：让Java开发更简单、更高效、更健壮。</strong></p>
<hr>
<h2 id="2-Spring全家桶"><a href="#2-Spring全家桶" class="headerlink" title="2. Spring全家桶"></a>2. Spring全家桶</h2><p>Spring 全家桶（Ecosystem）指的是围绕 Spring Framework 核心构建的一系列项目，它们协同工作，覆盖了现代应用开发的方方面面。</p>
<ul>
<li><strong>核心 - Spring Framework</strong>:<ul>
<li>是整个生态的基石。提供了最核心的功能，如 IoC容器、AOP、事务管理、数据访问等。其他所有项目都构建于此之上。</li>
</ul>
</li>
<li><strong>主要项目 - Spring Boot &amp; Spring Cloud</strong>:<ul>
<li><strong>Spring Boot</strong>：<strong>“脚手架”和“助推器”</strong>。它极大地简化了Spring应用的初始搭建和开发过程，遵循“约定优于配置”的原则，实现了开箱即用。<strong>我们现在开发Spring应用，基本都是通过Spring Boot来启动。</strong></li>
<li><strong>Spring Cloud</strong>：<strong>“微服务工具箱”</strong>。基于Spring Boot，它提供了一整套用于构建分布式系统（微服务架构）的解决方案，如服务发现、配置中心、API网关、熔断器等。</li>
</ul>
</li>
<li><strong>专项解决方案 - Spring Data, Spring Security 等</strong>:<ul>
<li><strong>Spring Data</strong>: <strong>“数据访问利器”</strong>。它的目标是简化数据访问层的开发，无论是关系型数据库 (JPA)、NoSQL数据库 (Redis, MongoDB) 还是搜索引擎 (Elasticsearch)，它都提供了一致的、基于 Repository 的编程模型。</li>
<li><strong>Spring Security</strong>: <strong>“安全护卫”</strong>。为Spring应用提供强大且可定制的认证（Authentication）和授权（Authorization）功能。</li>
<li><strong>Spring MVC &#x2F; WebFlux</strong>: Spring Framework 内置的Web框架，分别是同步阻塞和异步非阻塞模型的代表，是构建Web应用的基石。</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h1 id="一、SpringFramework-核心"><a href="#一、SpringFramework-核心" class="headerlink" title="一、SpringFramework 核心"></a>一、SpringFramework 核心</h1><h2 id="1-核心容器-IoC-DI"><a href="#1-核心容器-IoC-DI" class="headerlink" title="1. 核心容器 (IoC &amp; DI)"></a>1. 核心容器 (IoC &amp; DI)</h2><h3 id="1-1-控制反转-IoC"><a href="#1-1-控制反转-IoC" class="headerlink" title="1.1 控制反转(IoC)"></a>1.1 控制反转(IoC)</h3><p>IoC（Inversion of Control），即“控制反转”，是Spring框架的基石。它是一种重要的面向对象编程的设计原则，<strong>其核心思想是将传统上由程序代码直接操控的对象创建、依赖关系管理的权力，交（反转）给一个专门的第三方容器来控制。</strong></p>
<h4 id="1-1-1-什么是”控制反转”？"><a href="#1-1-1-什么是”控制反转”？" class="headerlink" title="1.1.1 什么是”控制反转”？"></a>1.1.1 什么是”控制反转”？</h4><ul>
<li><p><strong>传统控制方式（正向控制）：</strong> 假设 <code>UserService</code> 需要使用 <code>UserDao</code> 来操作数据库。在传统模式下，<code>UserService</code> 内部会主动创建或获取 <code>UserDao</code> 的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// UserService 主动创建 UserDao，控制权在自己手中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        userDao.save(user);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>UserService</code> 牢牢地控制着对 <code>UserDao</code> 的依赖。如果 <code>UserDao</code> 的实现类发生变化（例如从 <code>UserDaoImpl</code> 变成 <code>UserDaoMyBatisImpl</code>），我们就必须修改 <code>UserService</code> 的源代码。这导致了组件之间的高度耦合。</p>
</li>
<li><p><strong>控制反转 (IoC)：</strong> 在IoC模式下，<code>UserService</code> 不再主动创建 <code>UserDao</code>。它只需要声明“我需要一个<code>UserDao</code>”，而不再关心这个 <code>UserDao</code> 是如何被创建、它具体是哪个实现类。这个创建和“给予”的过程由Spring IoC容器来完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// UserService 不再主动创建，而是等待外部“注入”</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring容器会通过这个方法将UserDao实例“塞”进来</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        userDao.save(user); <span class="comment">// 直接使用，无需关心其来源</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>控制权从 <code>UserService</code> 手中被反转到了Spring容器手中</strong>，<code>UserService</code> 从一个主动的“索取者”变成了被动的“接收者”。</p>
</li>
</ul>
<hr>
<h4 id="1-1-2-IoC实现方式"><a href="#1-1-2-IoC实现方式" class="headerlink" title="1.1.2 IoC实现方式"></a>1.1.2 IoC实现方式</h4><p>控制反转（IoC）是一种设计思想，而不是一种具体的技术。要实现这种思想，业界主要有两种主流的方式：<strong>依赖注入（Dependency Injection, DI）和 依赖查找（Dependency Lookup, DL）</strong>。Spring框架主要使用<strong>依赖注入</strong>来实现其IoC容器。</p>
<h5 id="1-依赖注入-Dependency-Injection-DI"><a href="#1-依赖注入-Dependency-Injection-DI" class="headerlink" title="1. 依赖注入 (Dependency Injection - DI)"></a>1. 依赖注入 (Dependency Injection - DI)</h5><p>这是最常用、也是Spring推荐的实现方式。</p>
<ul>
<li><p><strong>核心思想</strong>：容器<strong>主动地</strong>将一个对象所依赖的其他对象（依赖项）“注入”到该对象中。对象本身是<strong>被动</strong>的，它只负责接收，不关心依赖从哪里来，如何创建。</p>
</li>
<li><p><strong>比喻</strong>：就像你点外卖。你（<code>UserService</code>）只需要告诉平台“我需要一份宫保鸡丁”（<code>UserDao</code>），然后在家等着就行。外卖小哥（Spring容器）会把做好的宫保鸡丁送到你手上。你是一个被动的接收者。</p>
</li>
<li><p><strong>实现形式</strong>：Spring支持三种主要的注入形式，这将在后续章节详细介绍：</p>
<ul>
<li><strong>构造器注入</strong>：通过类的构造函数传入依赖。</li>
<li><strong>Setter注入</strong>：通过<code>setXxx()</code>方法传入依赖。</li>
<li><strong>字段注入</strong>：直接在成员变量上使用注解（如<code>@Autowired</code>）注入。</li>
</ul>
</li>
<li><p><strong>代码体现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 依赖项，等待容器来填充</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 形式一：构造器注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 形式二：Setter注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...业务方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>UserService</code> 并没有自己去创建<code>UserDao</code>，而是被动地等待Spring容器将一个<code>UserDao</code>的实例通过构造函数或setter方法传递进来。</p>
</li>
</ul>
<hr>
<h5 id="2-依赖查找-Dependency-Lookup-DL"><a href="#2-依赖查找-Dependency-Lookup-DL" class="headerlink" title="2. 依赖查找 (Dependency Lookup - DL)"></a>2. 依赖查找 (Dependency Lookup - DL)</h5><p>这种方式相对不常用，但在某些特定场景下有用。</p>
<ul>
<li><p><strong>核心思想</strong>：容器不主动注入，而是对象在需要时，<strong>主动地</strong>向容器“查找”并获取它所需要的依赖项。对象是<strong>主动</strong>的，它需要知道容器的存在，并向容器发出请求。</p>
</li>
<li><p><strong>比喻</strong>：就像你自己去餐厅吃饭。你（<code>UserService</code>）需要知道餐厅（Spring容器）的地址，然后主动走进去，跟服务员说“给我来一份宫保鸡丁”（<code>UserDao</code>）。你是一个主动的索取者。</p>
</li>
<li><p><strong>实现形式</strong>：通常通过调用容器提供的API来完成，例如在Spring中调用<code>ApplicationContext</code>的<code>getBean()</code>方法。</p>
</li>
<li><p><strong>代码体现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 主动向Spring容器请求UserDao实例</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> ...; <span class="comment">// 需要先获取到容器的引用 </span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> context.getBean(UserDao.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        userDao.save(user);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="3-DI-与-DL-的对比与总结"><a href="#3-DI-与-DL-的对比与总结" class="headerlink" title="3. DI 与 DL 的对比与总结"></a>3. DI 与 DL 的对比与总结</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">依赖注入 (DI)</th>
<th align="left">依赖查找 (DL)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>角色</strong></td>
<td align="left">组件是被动接收者 (Passive)</td>
<td align="left">组件是主动索取者 (Active)</td>
</tr>
<tr>
<td align="left"><strong>耦合度</strong></td>
<td align="left"><strong>低</strong>。业务代码不依赖于任何容器API，对容器无感知。</td>
<td align="left"><strong>高</strong>。业务代码必须依赖容器API（如<code>ApplicationContext</code>）。</td>
</tr>
<tr>
<td align="left"><strong>代码侵入性</strong></td>
<td align="left"><strong>低</strong>。代码更简洁，是普通的POJO（Plain Old Java Object）。</td>
<td align="left"><strong>高</strong>。容器API侵入到业务代码中。</td>
</tr>
<tr>
<td align="left"><strong>推荐程度</strong></td>
<td align="left"><strong>强烈推荐</strong>。这是Spring的核心和精髓。</td>
<td align="left"><strong>不推荐</strong>。仅在无法使用DI的特殊场景下（如静态工具类）考虑。</td>
</tr>
</tbody></table>
<p><strong>结论</strong>：</p>
<p>Spring框架之所以强大和流行，很大程度上是因为它极力推崇并完美实现了<strong>依赖注入（DI）</strong>。DI是实现IoC思想的最佳实践，它让我们的代码与框架解耦，变得更加清晰、灵活且易于单元测试。</p>
<hr>
<h3 id="1-2-Spring-IoC容器"><a href="#1-2-Spring-IoC容器" class="headerlink" title="1.2 Spring IoC容器"></a>1.2 Spring IoC容器</h3><h4 id="1-2-1-容器的职责"><a href="#1-2-1-容器的职责" class="headerlink" title="1.2.1 容器的职责"></a>1.2.1 容器的职责</h4><p>Spring IoC 容器是整个 Spring 框架的心脏。它的 核心职责可以概括为：<strong>统一管理应用中所有对象（Bean）的创建、配置、组装和生命周期</strong>。</p>
<h5 id="1-Bean的创建与装配-Bean-Creation-and-Wiring"><a href="#1-Bean的创建与装配-Bean-Creation-and-Wiring" class="headerlink" title="1. Bean的创建与装配 (Bean Creation and Wiring)"></a>1. Bean的创建与装配 (Bean Creation and Wiring)</h5><ul>
<li><strong>创建 (Instantiation)</strong>：这是容器最基础的职责。开发者不再需要在代码中使用 <code>new</code> 关键字来创建对象，而是通过配置文件（XML）、注解（<code>@Component</code>）或Java配置（<code>@Bean</code>），告诉容器“需要创建哪些类的对象”。容器会负责在适当的时机实例化这些对象。</li>
<li><strong>装配 (Wiring&#x2F;Assembly)</strong>：也称为<strong>依赖注入 (DI)</strong>。当容器创建好一个Bean（如<code>UserService</code>）后，它会分析这个Bean依赖的其他Bean（如<code>UserDao</code>）。然后，容器会自动从自己管理的一堆Bean中找到匹配的<code>UserDao</code>实例，并将其“注入”到<code>UserService</code>中。这个过程解决了对象之间复杂的依赖关系，实现了“解耦”。</li>
</ul>
<hr>
<h5 id="2-Bean生命周期的管理-Bean-Lifecycle-Man-agement"><a href="#2-Bean生命周期的管理-Bean-Lifecycle-Man-agement" class="headerlink" title="2. Bean生命周期的管理 (Bean Lifecycle Man                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            agement)"></a>2. Bean生命周期的管理 (Bean Lifecycle Man                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            agement)</h5><p>容器的管理贯穿了一个Bean从诞生到销毁的全过程，是一个“管家式”服务。</p>
<ul>
<li><strong>实例化 (Instantiation)</strong>：通过反射创建Bean的实例。</li>
<li><strong>属性填充 (Populate Properties)</strong>：进行依赖注入，将Bean依赖的其他Bean或属性值设置进去。</li>
<li><strong>初始化 (Initialization)</strong>：在Bean准备就绪、可以被使用之前，执行一些自定义的初始化操作。例如，调用<code>@PostConstruct</code>注解的方法，或者执行<code>InitializingBean</code>接口的方法。</li>
<li><strong>使用 (In Use)</strong>：将初始化完成的Bean放入容器的“单例池”中，等待应用程序随时调用。</li>
<li><strong>销毁 (Destruction)</strong>：当容器关闭时，或者Bean不再需要时，执行一些清理工作。例如，调用<code>@PreDestroy</code>注解的方法，释放资源、关闭连接等。</li>
</ul>
<hr>
<h5 id="3-配置的集中管理-Centralized-Configuration"><a href="#3-配置的集中管理-Centralized-Configuration" class="headerlink" title="3. 配置的集中管理 (Centralized Configuration)"></a>3. 配置的集中管理 (Centralized Configuration)</h5><p>容器提供了一个统一的配置入口。无论是早期的XML文件，还是现在主流的Java Config和注解，所有关于Bean的定义和它们之间关系的配置都由容器统一解析和管理。这使得应用的结构一目了然，修改配置也变得非常方便，而不需要深入到业务代码中。</p>
<hr>
<h5 id="4-提供高级服务与集成-Providing-Advanced-Services"><a href="#4-提供高级服务与集成-Providing-Advanced-Services" class="headerlink" title="4. 提供高级服务与集成 (Providing Advanced Services)"></a>4. 提供高级服务与集成 (Providing Advanced Services)</h5><p>除了上述核心职责，<code>ApplicationContext</code>作为高级容器，还集成了许多企业级功能，将它们以非侵入的方式提供给Bean使用。</p>
<ul>
<li><strong>集成AOP</strong>：自动为符合切点（Pointcut）的Bean创建代理对象，实现面向切面编程，如声明式事务、日志记录等。</li>
<li><strong>事件发布&#x2F;监听 (Event Publishing)</strong>：支持应用内的组件通过事件进行解耦通信。</li>
<li><strong>国际化支持 (i18n)</strong>：提供处理多语言消息的机制。</li>
<li><strong>统一的资源访问</strong>：提供强大的<code>Resource</code>接口，可以透明地访问来自文件系统、类路径、URL等不同来源的资源。</li>
</ul>
<p><strong>总结来说，Spring IoC容器的根本目标是“让开发者专注于业务逻辑”。</strong> 它接管了所有与对象管理相关的繁琐、重复的底层工作，从而大大降低了应用的复杂性和组件间的耦合度，提升了代码的可维护性、可测试性和可扩展性。</p>
<hr>
<h4 id="1-2-2-两大核心接口"><a href="#1-2-2-两大核心接口" class="headerlink" title="1.2.2 两大核心接口"></a>1.2.2 两大核心接口</h4><p>Spring IoC 容器并非只有一个具体的实现，而是通过一系列接口来定义的。其中，<code>BeanFactory</code> 和 <code>ApplicationContext</code> 是两个最核心、最顶层的接口，它们共同构成了Spring容器的骨架。</p>
<h5 id="1-BeanFactory-IoC容器的“心脏”"><a href="#1-BeanFactory-IoC容器的“心脏”" class="headerlink" title="1. BeanFactory - IoC容器的“心脏”"></a>1. <code>BeanFactory</code> - IoC容器的“心脏”</h5><p><code>BeanFactory</code> 是Spring容器最基础、最核心的接口，它定义了IoC容器的基本行为规范。</p>
<ul>
<li><strong>定位</strong>：一个纯粹的 <strong>Bean 工厂</strong>。负责生产和管理Bean。</li>
<li><strong>核心功能</strong>：提供了访问Bean容器的根接口，其最核心的方法就是 <code>getBean(String name)</code>，用于获取容器中指定名称的Bean实例。</li>
<li><strong>核心特点：延迟加载 (Lazy Loading)</strong><ul>
<li>默认情况下，<code>BeanFactory</code> 在容器启动时并不会立即创建所有的Bean实例。</li>
<li>只有当第一次通过 <code>getBean()</code> 方法请求某个Bean时，<code>BeanFactory</code> 才会真正地去创建、初始化并返回该Bean的实例。</li>
<li><strong>优点</strong>：启动速度快，节省内存，特别是在资源受限的环境中（例如早期的Applet应用）。</li>
<li><strong>缺点</strong>：如果被请求的Bean存在配置错误（如类找不到、依赖缺失），这个错误只有在运行时第一次获取该Bean时才会被发现，而不是在应用启动时。这可能会导致应用运行一段时间后突然因配置问题而崩溃。</li>
</ul>
</li>
<li><strong>使用场景</strong>：由于其功能相对基础，<code>BeanFactory</code> 如今已<strong>很少被直接使用</strong>。学习它，主要是为了理解Spring IoC容器的底层工作原理。</li>
</ul>
<hr>
<h5 id="2-ApplicationContext-功能完备的“企业级”容器"><a href="#2-ApplicationContext-功能完备的“企业级”容器" class="headerlink" title="2. ApplicationContext - 功能完备的“企业级”容器"></a>2. <code>ApplicationContext</code> - 功能完备的“企业级”容器</h5><p><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的一个<strong>子接口</strong>，也是我们实际开发中<strong>最常使用的容器接口</strong>。</p>
<ul>
<li><strong>定位</strong>：一个<strong>全能型的应用上下文</strong>。它继承了 <code>BeanFactory</code> 的所有功能，因此它也是一个Bean工厂。但在此基础上，它增加了大量面向企业级应用的高级特性。</li>
<li><strong>核心特点：即时加载 (Eager Loading)</strong><ul>
<li>与<code>BeanFactory</code>相反，<code>ApplicationContext</code> 在容器<strong>启动时</strong>，会一次性地创建并初始化所有<strong>单例（Singleton）作用域</strong>的Bean。</li>
<li><strong>优点</strong>：<strong>Fail-Fast（快速失败）机制</strong>。如果在配置中有任何错误（比如<code>@Autowired</code>的依赖找不到，Bean的类名写错等），应用在启动阶段就会立即抛出异常并失败，而不是等到运行时才暴露问题。这对于开发和部署阶段排查错误至关重要。</li>
<li><strong>缺点</strong>：相对于<code>BeanFactory</code>，启动时间会稍长，占用内存会稍多。但在现代服务器硬件条件下，这点开销通常可以忽略不计。</li>
</ul>
</li>
<li><strong>增强功能</strong>：除了<code>BeanFactory</code>的基本功能外，<code>ApplicationContext</code>还提供了以下强大的企业级服务：<ul>
<li><strong>AOP集成</strong>：与Spring AOP框架深度集成，能够自动发现切面（Aspect）并为Bean创建代理。</li>
<li><strong>事件发布与监听 (ApplicationEventPublisher)</strong>：支持基于观察者模式的应用内事件通知机制，实现组件间的解耦通信。</li>
<li><strong>国际化支持 (MessageSource)</strong>：提供处理多语言消息资源的能力，轻松实现应用的国际化（i18n）。</li>
<li><strong>统一的资源加载 (ResourceLoader)</strong>：提供强大的资源访问能力，可以透明地从类路径 (<code>classpath:</code>)、文件系统 (<code>file:</code>)、URL等位置加载资源。</li>
<li><strong>自动注册 <code>BeanPostProcessor</code></strong>：会自动扫描并注册容器中定义的<code>BeanPostProcessor</code>和<code>BeanFactoryPostProcessor</code>，而<code>BeanFactory</code>需要手动注册。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-总结与对比"><a href="#3-总结与对比" class="headerlink" title="3. 总结与对比"></a>3. 总结与对比</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>BeanFactory</code> (基础容器)</th>
<th align="left"><code>ApplicationContext</code> (高级容器)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>继承关系</strong></td>
<td align="left">IoC容器的顶层接口</td>
<td align="left"><code>BeanFactory</code>的子接口</td>
</tr>
<tr>
<td align="left"><strong>加载策略</strong></td>
<td align="left"><strong>延迟加载 (Lazy Loading)</strong> - 按需创建Bean</td>
<td align="left"><strong>即时加载 (Eager Loading)</strong> - 启动时创建所有单例Bean</td>
</tr>
<tr>
<td align="left"><strong>功能丰富度</strong></td>
<td align="left">基础，仅提供核心的Bean管理功能</td>
<td align="left"><strong>强大</strong>，继承并扩展了BeanFactory，提供AOP、事件、国际化等高级服务</td>
</tr>
<tr>
<td align="left"><strong>错误暴露</strong></td>
<td align="left">运行时，第一次<code>getBean()</code>时才暴露配置错误</td>
<td align="left"><strong>启动时</strong>，通过Fail-Fast机制提前暴露配置错误</td>
</tr>
<tr>
<td align="left"><strong>使用场景</strong></td>
<td align="left">几乎不再直接使用，主要用于理解底层原理</td>
<td align="left"><strong>99%的开发场景</strong>，是事实上的标准Spring容器</td>
</tr>
</tbody></table>
<p><strong>总结：<code>ApplicationContext</code> &#x3D; <code>BeanFactory</code> + 更多企业级服务。在任何现代Spring应用中，我们都应该优先且默认使用 <code>ApplicationContext</code>。</strong></p>
<hr>
<h4 id="1-2-3-ApplicationContext-的关键实现类"><a href="#1-2-3-ApplicationContext-的关键实现类" class="headerlink" title="1.2.3 ApplicationContext 的关键实现类"></a>1.2.3 <code>ApplicationContext</code> 的关键实现类</h4><h5 id="1-ClassPathXmlApplicationContext-从类路径加载XML"><a href="#1-ClassPathXmlApplicationContext-从类路径加载XML" class="headerlink" title="1. ClassPathXmlApplicationContext: 从类路径加载XML"></a>1. <code>ClassPathXmlApplicationContext</code>: 从类路径加载XML</h5><h6 id="a-定义与职责"><a href="#a-定义与职责" class="headerlink" title="a). 定义与职责"></a>a). 定义与职责</h6><p><code>ClassPathXmlApplicationContext</code> 是 <code>ApplicationContext</code> 接口的一个核心实现类。它的主要职责是<strong>从应用程序的类路径（Classpath）中查找并加载一个或多个XML配置文件，然后根据这些文件中的定义来创建和初始化Spring IoC容器</strong>。</p>
<p>这是在Spring早期，以及许多遗留项目中，最常用的一种容器启动方式。</p>
<hr>
<h6 id="b-关键概念：什么是“类路径-Classpath-”？"><a href="#b-关键概念：什么是“类路径-Classpath-”？" class="headerlink" title="b). 关键概念：什么是“类路径 (Classpath)”？"></a>b). 关键概念：什么是“类路径 (Classpath)”？</h6><p>在Java世界中，“类路径”是一个至关重要的概念。它告诉Java虚拟机（JVM）和类似Spring的框架，去哪里查找<code>.class</code>文件和其他资源文件（如<code>.xml</code>, <code>.properties</code>）。</p>
<ul>
<li><strong>简单理解</strong>：你可以把类路径想象成一个**“资源搜索目录列表”**。当你请求一个资源时，系统会按顺序在这些目录中查找。</li>
<li><strong>在典型的Maven&#x2F;Gradle项目中</strong>：<ul>
<li><code>src/main/java</code> 目录下的Java源码编译后生成的 <code>.class</code> 文件会被自动放入类路径。</li>
<li><code>src/main/resources</code> 目录是<strong>专门用来存放资源文件</strong>的地方。放置在这里的所有文件（如 <code>applicationContext.xml</code>）都会被构建工具（Maven&#x2F;Gradle）自动复制到最终的类路径根目录下。</li>
</ul>
</li>
</ul>
<p><strong>因此，当我们说“从类路径加载”时，通常意味着将XML配置文件放在 <code>src/main/resources</code> 目录下。</strong></p>
<hr>
<h6 id="c-使用示例"><a href="#c-使用示例" class="headerlink" title="c). 使用示例"></a>c). 使用示例</h6><p>让我们通过一个完整的、简单的例子来理解它的工作流程。</p>
<p><strong>步骤 1: 创建项目结构 (以Maven为例)</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">my-spring-app</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── example</span><br><span class="line">        │           ├── UserService.java</span><br><span class="line">        │           └── MainApp.java</span><br><span class="line">        └── resources</span><br><span class="line">            └── applicationContext.xml</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 定义一个简单的Bean (<code>UserService.java</code>)</strong></p>
<p>这是一个普通的Java类，我们将把它交给Spring管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, this is UserService managed by Spring!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3: 创建Spring XML配置文件 (<code>applicationContext.xml</code>)</strong></p>
<p>这个文件放在 <code>src/main/resources</code> 目录下。它告诉Spring容器需要创建哪些Bean。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        定义一个Bean。</span></span><br><span class="line"><span class="comment">        id: Bean的唯一标识符，类似于变量名。</span></span><br><span class="line"><span class="comment">        class: Bean的完整类路径。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这里可以配置属性注入等 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 4: 创建启动类 (<code>MainApp.java</code>)</strong></p>
<p>这是程序的入口，我们在这里创建并启动Spring容器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建ApplicationContext实例</span></span><br><span class="line">        <span class="comment">//    构造函数参数是XML配置文件在类路径下的名称</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Spring container started successfully.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 从容器中获取Bean</span></span><br><span class="line">        <span class="comment">//    通过在XML中定义的id (&quot;userService&quot;)来获取</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 也可以通过类型来获取，如果该类型只有一个Bean实例的话</span></span><br><span class="line">        <span class="comment">// UserService userService = context.getBean(UserService.class);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 使用Bean</span></span><br><span class="line">        userService.sayHello();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 关闭容器 (可选，但在非Web应用中最好手动关闭以释放资源)</span></span><br><span class="line">        ((ClassPathXmlApplicationContext) context).close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Spring container started successfully.</span><br><span class="line">Hello, this is UserService managed by Spring!</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="d-加载多个配置文件"><a href="#d-加载多个配置文件" class="headerlink" title="d). 加载多个配置文件"></a>d). 加载多个配置文件</h6><p>如果配置被拆分到了多个XML文件中，可以在构造函数中传入一个字符串数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有两个配置文件：services.xml 和 daos.xml</span></span><br><span class="line">String[] configFiles = &#123;<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>&#125;;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(configFiles);</span><br></pre></td></tr></table></figure>

<p>或者使用通配符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载所有以 -context.xml 结尾的配置文件</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath*:/META-INF/*-context.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="e-总结"><a href="#e-总结" class="headerlink" title="e). 总结"></a>e). 总结</h6><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>加载源</strong></td>
<td align="left"><strong>类路径 (Classpath)</strong></td>
</tr>
<tr>
<td align="left"><strong>配置文件</strong></td>
<td align="left">XML格式</td>
</tr>
<tr>
<td align="left"><strong>典型位置</strong></td>
<td align="left"><code>src/main/resources</code> 目录</td>
</tr>
<tr>
<td align="left"><strong>核心用法</strong></td>
<td align="left"><code>new ClassPathXmlApplicationContext(&quot;config.xml&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">1. 学习和理解Spring基于XML的配置方式。<br>2. 维护使用XML配置的遗留项目。<br>3. 在某些单元测试场景中快速加载特定配置。</td>
</tr>
<tr>
<td align="left"><strong>现代替代</strong></td>
<td align="left">在新的Spring Boot项目中，几乎完全被 <strong><code>AnnotationConfigApplicationContext</code></strong> (基于Java类配置) 和<strong>自动配置</strong>所取代。</td>
</tr>
</tbody></table>
<hr>
<h5 id="2-FileSystemXmlApplicationContext-从文件系统加载XML"><a href="#2-FileSystemXmlApplicationContext-从文件系统加载XML" class="headerlink" title="2. FileSystemXmlApplicationContext: 从文件系统加载XML"></a>2. <code>FileSystemXmlApplicationContext</code>: 从文件系统加载XML</h5><h6 id="a-定义与职责-1"><a href="#a-定义与职责-1" class="headerlink" title="a). 定义与职责"></a>a). 定义与职责</h6><p><code>FileSystemXmlApplicationContext</code> 同样是 <code>ApplicationContext</code> 接口的一个重要实现类。与 <code>ClassPathXmlApplicationContext</code> 不同，它的职责是<strong>从操作系统的文件系统中加载一个或多个XML配置文件</strong>。</p>
<p>这意味着它加载的配置文件路径是<strong>相对于文件系统的绝对路径或相对路径</strong>，而不是相对于项目的类路径。</p>
<hr>
<h6 id="b-关键概念：文件系统路径-vs-类路径"><a href="#b-关键概念：文件系统路径-vs-类路径" class="headerlink" title="b). 关键概念：文件系统路径 vs 类路径"></a>b). 关键概念：文件系统路径 vs 类路径</h6><ul>
<li><strong>类路径 (Classpath)</strong>：是一个<strong>抽象</strong>的、相对于项目构建结果的位置。当你的应用被打包成一个JAR或WAR文件后，类路径的资源就在这个包的内部。因此，它是<strong>可移植的</strong>，不依赖于应用部署在哪个具体的服务器目录下。</li>
<li><strong>文件系统路径 (File System Path)</strong>：是一个<strong>具体</strong>的、物理磁盘上的位置。这个路径是<strong>硬编码</strong>的，依赖于应用部署的环境。</li>
</ul>
<hr>
<h6 id="c-使用示例-1"><a href="#c-使用示例-1" class="headerlink" title="c). 使用示例"></a>c). 使用示例</h6><p>这个例子将演示如何将配置文件放在项目外部，并通过文件系统路径加载它。</p>
<p><strong>步骤 1: 创建项目与配置文件结构</strong></p>
<p>注意，这次我们将 <code>app-config.xml</code> 放在了项目根目录下的一个 <code>config</code> 文件夹中，它<strong>不在 <code>src/main/resources</code></strong>，因此不属于类路径。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">my-spring-app</span><br><span class="line">├── config</span><br><span class="line">│   └── app-config.xml  &lt;-- 配置文件在这里！</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        └── java</span><br><span class="line">            └── com</span><br><span class="line">                └── example</span><br><span class="line">                    ├── UserService.java</span><br><span class="line">                    └── MainApp.java</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 定义Bean和XML配置 (与上例相同)</strong></p>
<p><code>UserService.java</code> 和 <code>app-config.xml</code> 的内容可以和 <code>ClassPathXmlApplicationContext</code> 示例中的完全一样。</p>
<p><code>app-config.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 3: 创建启动类 (<code>MainApp.java</code>)</strong></p>
<p>这是关键区别所在。我们将使用 <code>FileSystemXmlApplicationContext</code> 来加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 演示一：使用相对路径加载</span></span><br><span class="line">        <span class="comment">// 这个路径是相对于项目根目录（即应用的当前工作目录）</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;config/app-config.xml&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Container 1 (relative path) started successfully.&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service1</span> <span class="operator">=</span> context1.getBean(UserService.class);</span><br><span class="line">        service1.sayHello();</span><br><span class="line">        ((FileSystemXmlApplicationContext) context1).close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n----------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 演示二：使用绝对路径加载</span></span><br><span class="line">        <span class="comment">// 注意：这种方式可移植性很差，因为路径是硬编码的</span></span><br><span class="line">        <span class="comment">// 请将下面的路径替换为你自己项目中 app-config.xml 的实际绝对路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">absolutePath</span> <span class="operator">=</span> <span class="string">&quot;D:/projects/my-spring-app/config/app-config.xml&quot;</span>; <span class="comment">// 示例路径</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(absolutePath);</span><br><span class="line">        System.out.println(<span class="string">&quot;Container 2 (absolute path) started successfully.&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service2</span> <span class="operator">=</span> context2.getBean(UserService.class);</span><br><span class="line">        service2.sayHello();</span><br><span class="line">        ((FileSystemXmlApplicationContext) context2).close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Container 1 (relative path) started successfully.</span><br><span class="line">Hello, this is UserService managed by Spring!</span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line"></span><br><span class="line">Container 2 (absolute path) started successfully.</span><br><span class="line">Hello, this is UserService managed by Spring!</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="d-ClassPathXmlApplicationContext-vs-FileSystemXmlApplicationContext"><a href="#d-ClassPathXmlApplicationContext-vs-FileSystemXmlApplicationContext" class="headerlink" title="d). ClassPathXmlApplicationContext vs FileSystemXmlApplicationContext"></a>d). <code>ClassPathXmlApplicationContext</code> vs <code>FileSystemXmlApplicationContext</code></h6><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>ClassPathXmlApplicationContext</code></th>
<th align="left"><code>FileSystemXmlApplicationContext</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>加载源</strong></td>
<td align="left"><strong>类路径 (Classpath)</strong></td>
<td align="left"><strong>文件系统 (File System)</strong></td>
</tr>
<tr>
<td align="left"><strong>路径类型</strong></td>
<td align="left">抽象路径，如 <code>beans.xml</code></td>
<td align="left">具体的物理路径，如 <code>C:/config/beans.xml</code> 或 <code>config/beans.xml</code></td>
</tr>
<tr>
<td align="left"><strong>可移植性</strong></td>
<td align="left"><strong>高</strong>。配置文件打包在应用内部，随应用部署到任何地方。</td>
<td align="left"><strong>低</strong>。路径通常是硬编码的，换个环境可能就需要修改代码或配置。</td>
</tr>
<tr>
<td align="left"><strong>典型用途</strong></td>
<td align="left">将配置作为应用程序<strong>内部资源</strong>的一部分。</td>
<td align="left">将配置作为<strong>外部资源</strong>，独立于应用程序包进行管理。</td>
</tr>
</tbody></table>
<hr>
<h6 id="e-适用场景"><a href="#e-适用场景" class="headerlink" title="e). 适用场景"></a>e). 适用场景</h6><p>虽然在现代Spring Boot应用中不常用，但 <code>FileSystemXmlApplicationContext</code> 在某些特定场景下非常有用：</p>
<ol>
<li><strong>外部化配置</strong>：最核心的用途。允许将配置文件放在应用程序包（JAR&#x2F;WAR）的外部。这样，运维人员可以在<strong>不重新打包和部署应用</strong>的情况下，直接修改外部的XML配置文件来改变应用的行为（例如修改数据库连接池参数）。</li>
<li><strong>多应用共享配置</strong>：可以将一些公共的配置文件放在服务器的某个共享目录下，多个不同的应用实例都从这个位置加载公共配置。</li>
<li><strong>测试场景</strong>：在进行集成测试时，可以方便地从一个特定的、固定的文件系统位置加载一套专为测试准备的配置文件。</li>
</ol>
<hr>
<h5 id="3-AnnotationConfigApplicationContext-从Java配置类加载"><a href="#3-AnnotationConfigApplicationContext-从Java配置类加载" class="headerlink" title="3. AnnotationConfigApplicationContext: 从Java配置类加载"></a>3. <code>AnnotationConfigApplicationContext</code>: 从Java配置类加载</h5><h6 id="a-定义与职责-2"><a href="#a-定义与职责-2" class="headerlink" title="a). 定义与职责"></a>a). 定义与职责</h6><p><code>AnnotationConfigApplicationContext</code> 是 Spring 框架进入 “去XML化” 时代的核心。其职责是<strong>从一个或多个使用注解的Java类（通常称为配置类, Configuration Class）中加载Bean的定义，从而构建和初始化IoC容器</strong>。</p>
<p>这种方式完全摒弃了XML文件，允许开发者使用<strong>纯Java代码</strong>来完成所有的Spring配置，是当前Spring Boot和现代Spring应用开发的事实标准。</p>
<hr>
<h6 id="b-关键注解"><a href="#b-关键注解" class="headerlink" title="b). 关键注解"></a>b). 关键注解</h6><p>要使用 <code>AnnotationConfigApplicationContext</code>，我们必须先了解两个核心注解：</p>
<ul>
<li><strong><code>@Configuration</code></strong>:<ul>
<li><strong>作用</strong>：标记在一个类上，向Spring声明这个类是一个<strong>配置类</strong>。它的角色等同于一个XML配置文件。</li>
<li><strong>本质</strong>：<code>@Configuration</code> 本身也被 <code>@Component</code> 注解，所以配置类也会被Spring当作一个特殊的Bean进行管理。</li>
<li><strong>特点</strong>：Spring会对 <code>@Configuration</code> 类进行CGLIB代理增强，以保证通过方法调用获取Bean时，能够正确处理Bean的作用域（如单例）。</li>
</ul>
</li>
<li><strong><code>@Bean</code></strong>:<ul>
<li><strong>作用</strong>：标记在一个<strong>方法</strong>上，这个方法必须定义在<code>@Configuration</code>类中。</li>
<li><strong>职责</strong>：Spring容器会<strong>调用这个方法</strong>，并将方法的<strong>返回值</strong>注册为一个Bean。</li>
<li><strong>命名</strong>：默认情况下，Bean的ID就是<strong>方法名</strong>。你也可以通过 <code>@Bean(name = &quot;customName&quot;)</code> 或 <code>@Bean(&quot;customName&quot;)</code> 来指定一个自定义的ID。</li>
</ul>
</li>
</ul>
<hr>
<h6 id="c-使用示例-2"><a href="#c-使用示例-2" class="headerlink" title="c). 使用示例"></a>c). 使用示例</h6><p>让我们用纯Java的方式重构之前的 <code>UserService</code> 示例。</p>
<p><strong>步骤 1: 项目结构 (无XML文件)</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">my-spring-app</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        └── java</span><br><span class="line">            └── com</span><br><span class="line">                └── example</span><br><span class="line">                    ├── config</span><br><span class="line">                    │   └── AppConfig.java    &lt;-- 这是我们的Java配置类</span><br><span class="line">                    ├── service</span><br><span class="line">                    │   └── UserService.java</span><br><span class="line">                    └── MainApp.java</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 定义Bean (<code>UserService.java</code>)</strong></p>
<p>这仍然是一个简单的POJO，无需任何改动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, this is UserService configured via Java Config!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3: 创建Java配置类 (<code>AppConfig.java</code>)</strong></p>
<p>这是替代 <code>applicationContext.xml</code> 的核心文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 使用 @Configuration 注解，表明这是一个配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 使用 @Bean 注解，声明一个Bean</span></span><br><span class="line">    <span class="comment">//    方法名 &quot;userService&quot; 将成为这个Bean的ID</span></span><br><span class="line">    <span class="comment">//    方法的返回值 new UserService() 将成为Bean的实例</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 4: 创建启动类 (<code>MainApp.java</code>)</strong></p>
<p>在这里，我们使用 <code>AnnotationConfigApplicationContext</code> 来启动容器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.config.AppConfig;</span><br><span class="line"><span class="keyword">import</span> com.example.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 AnnotationConfigApplicationContext 实例</span></span><br><span class="line">        <span class="comment">//    构造函数参数是我们的配置类 AppConfig.class</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Spring container started successfully using Java Config.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 从容器中获取Bean</span></span><br><span class="line">        <span class="comment">//    可以通过方法名（Bean ID）获取</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userServiceById</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userServiceById.sayHello();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//    更推荐通过类型获取，因为这样更安全</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userServiceByType</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        userServiceByType.sayHello();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 关闭容器</span></span><br><span class="line">        ((AnnotationConfigApplicationContext) context).close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spring container started successfully using Java Config.</span><br><span class="line">Hello, this is UserService configured via Java Config!</span><br><span class="line">Hello, this is UserService configured via Java Config!</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="d-结合组件扫描-ComponentScan"><a href="#d-结合组件扫描-ComponentScan" class="headerlink" title="d). 结合组件扫描 (@ComponentScan)"></a>d). 结合组件扫描 (<code>@ComponentScan</code>)</h6><p>除了使用<code>@Bean</code>方法手动定义每一个Bean，更常见的做法是结合<strong>组件扫描</strong>。</p>
<ul>
<li><p><strong>修改 <code>UserService</code></strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component; <span class="comment">// 引入注解</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 将UserService标记为一个组件，让Spring自动发现它</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修改 <code>AppConfig</code></strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 告诉Spring去扫描 &quot;com.example.service&quot; 包下的所有组件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example.service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 因为UserService已经通过@Component被自动扫描了，</span></span><br><span class="line">    <span class="comment">// 所以这里的 @Bean 方法就不再需要了！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>启动代码<code>MainApp.java</code>无需任何改变，运行结果完全相同。这种**<code>@Configuration</code> + <code>@ComponentScan</code>** 的组合是现代Spring应用配置的基石。</p>
<hr>
<h6 id="e-Java配置相对于XML的优势"><a href="#e-Java配置相对于XML的优势" class="headerlink" title="e). Java配置相对于XML的优势"></a>e). Java配置相对于XML的优势</h6><ol>
<li><strong>类型安全 (Type-Safe)</strong>：所有的配置都是Java代码。如果你在<code>class=&quot;com.example.UserService123&quot;</code>中写错了类名，XML配置在运行时才会报错；而Java配置 <code>new UserService123()</code> 在<strong>编译时</strong>就会被编译器发现错误。</li>
<li><strong>更好的IDE支持和重构</strong>：当你想重命名一个类或方法时，IDE的重构工具可以自动更新所有的Java引用。而重构XML中的字符串值则非常困难和易错。</li>
<li><strong>灵活性和编程能力</strong>：你可以在<code>@Bean</code>方法中使用任何Java逻辑（如<code>if-else</code>、循环、调用其他方法）来动态地、有条件地创建和配置Bean，这是静态的XML无法比拟的。</li>
<li><strong>更简洁、更内聚</strong>：配置和代码都在同一个语言环境中，导航和理解都更加方便。</li>
</ol>
<p><strong>总结</strong>：<code>AnnotationConfigApplicationContext</code> 和与之配套的Java配置方式，是Spring发展的必然趋势。它提供了比XML更安全、更灵活、更强大的配置能力，是所有新Spring项目的不二之选。</p>
<hr>
<h5 id="4-WebApplicationContext-Web应用专属，与ServletContext集成"><a href="#4-WebApplicationContext-Web应用专属，与ServletContext集成" class="headerlink" title="4. WebApplicationContext: Web应用专属，与ServletContext集成"></a>4. <code>WebApplicationContext</code>: Web应用专属，与<code>ServletContext</code>集成</h5><h6 id="a-定义与核心角色"><a href="#a-定义与核心角色" class="headerlink" title="a). 定义与核心角色"></a>a). 定义与核心角色</h6><p><code>WebApplicationContext</code> 是一个专为Web应用程序设计的 <code>ApplicationContext</code> 子接口。在 <code>ApplicationContext</code> 基础上添加了一些Web环境特有的能力。</p>
<p>它的<strong>核心角色</strong>是：<strong>充当Spring IoC容器与底层Servlet容器（如Tomcat, Jetty）之间的桥梁</strong>。</p>
<p>与前面三种 <code>ApplicationContext</code> 不同，它的生命周期不再由 <code>main</code> 方法中的代码来控制，而是<strong>与Web应用的生命周期绑定</strong>。当Web应用启动时，它被创建；当Web应用停止时，它被销毁。</p>
<hr>
<h6 id="b-与ServletContext的集成关系"><a href="#b-与ServletContext的集成关系" class="headerlink" title="b). 与ServletContext的集成关系"></a>b). 与<code>ServletContext</code>的集成关系</h6><p>要理解 <code>WebApplicationContext</code>，必须先理解 <strong><code>ServletContext</code></strong>。</p>
<ul>
<li><strong><code>ServletContext</code> 是什么？</strong><ul>
<li><code>ServletContext</code> 是Java Servlet规范中定义的<strong>四大域对象</strong>之一。</li>
<li>可以把它理解为<strong>整个Web应用的全局上下文（Global Context）</strong> 或 <strong>“全局管家”</strong>。</li>
<li>当Web服务器（如Tomcat）启动一个Web应用时，它会为这个应用创建一个<strong>唯一的 <code>ServletContext</code> 实例</strong>。</li>
<li>这个实例在整个应用的生命周期内都存在，所有Servlet、Filter、Listener都可以共享它内部的数据。</li>
</ul>
</li>
<li><strong>如何集成？</strong><ul>
<li>Spring的巧妙之处在于，它将创建好的 <code>WebApplicationContext</code> 实例作为一个**属性（Attribute）**存储到这个全局的 <code>ServletContext</code> 中。</li>
<li>这样一来，<code>WebApplicationContext</code> 就成为了 <code>ServletContext</code> 的一部分，任何能访问到 <code>ServletContext</code> 的组件，理论上都能间接地访问到Spring容器。</li>
<li>存储时使用的默认键（Key）是 <code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>。</li>
</ul>
</li>
</ul>
<hr>
<h6 id="c-生命周期与创建方式-传统Web应用"><a href="#c-生命周期与创建方式-传统Web应用" class="headerlink" title="c). 生命周期与创建方式 (传统Web应用)"></a>c). 生命周期与创建方式 (传统Web应用)</h6><p>在没有Spring Boot的传统Web应用中，<code>WebApplicationContext</code> 的创建通常依赖于 <code>web.xml</code> 文件中的配置。这个过程涉及两个关键组件：</p>
<p><strong>A. <code>ContextLoaderListener</code> (上下文加载监听器)</strong></p>
<ul>
<li><strong>作用</strong>：它是一个实现了 <code>ServletContextListener</code> 接口的监听器。它会监听Web应用的<strong>启动</strong>和<strong>销毁</strong>事件。</li>
<li><strong>创建时机</strong>：当Tomcat等服务器启动你的Web应用时，<code>ContextLoaderListener</code> 会被触发。</li>
<li><strong>动作</strong>：它会读取 <code>web.xml</code> 中指定的配置文件（默认为 <code>/WEB-INF/applicationContext.xml</code>），然后<strong>创建并初始化一个 <code>WebApplicationContext</code> 实例</strong>，并将其存入 <code>ServletContext</code>。这个Context被称为 <strong>“根上下文” (Root WebApplicationContext)</strong>。</li>
</ul>
<p><strong>B. <code>DispatcherServlet</code> (前端控制器)</strong></p>
<ul>
<li><strong>作用</strong>：这是Spring MVC的核心。所有进入应用的Web请求都会先经过它。</li>
<li><strong>创建时机</strong>：当 <code>DispatcherServlet</code> 被第一次初始化时。</li>
<li><strong>动作</strong>：<code>DispatcherServlet</code> 也会创建<strong>自己的 <code>WebApplicationContext</code></strong>，并读取它自己的配置文件（默认为 <code>/WEB-INF/[servlet-name]-servlet.xml</code>）。这个Context被称为 <strong>“Servlet上下文”</strong>。</li>
</ul>
<hr>
<h6 id="d-父子容器结构-Parent-Child-Container-Structure"><a href="#d-父子容器结构-Parent-Child-Container-Structure" class="headerlink" title="d). 父子容器结构 (Parent-Child Container Structure)"></a>d). 父子容器结构 (Parent-Child Container Structure)</h6><p>这是 <code>WebApplicationContext</code> 最核心、最重要的一个概念。</p>
<ul>
<li><strong>根上下文 (Parent Context)</strong>：<ul>
<li>由 <code>ContextLoaderListener</code> 创建。</li>
<li>通常用于存放<strong>业务层</strong>和<strong>数据访问层</strong>的Bean，如 <code>Service</code>, <code>Repository</code>, <code>DataSource</code>, 事务管理器等。</li>
<li>它是<strong>全局共享</strong>的，整个Web应用只有一个。</li>
</ul>
</li>
<li><strong>Servlet上下文 (Child Context)</strong>：<ul>
<li>由 <code>DispatcherServlet</code> 创建。</li>
<li>通常用于存放<strong>Web层</strong>的Bean，如 <code>@Controller</code>, <code>HandlerMapping</code>, <code>ViewResolver</code> 等。</li>
<li>它可以有多个（如果配置了多个 <code>DispatcherServlet</code>）。</li>
</ul>
</li>
<li><strong>关系与规则</strong>：<ul>
<li>Servlet上下文（子容器）将根上下文（父容器）作为自己的“父级”。</li>
<li><strong>可见性规则</strong>：<strong>子容器可以访问父容器中的Bean，但父容器无法访问子容器中的Bean。</strong></li>
<li><strong>为什么这样设计？</strong> 这是一种优秀的分层设计。Web层的Controller需要调用业务层的Service，所以子容器必须能访问父容器。反之，业务层的Service不应该依赖于Web层的任何具体实现（如Controller），保证了业务逻辑的独立性和可重用性。</li>
</ul>
</li>
</ul>
<p><strong><code>web.xml</code> 配置示例：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1. 配置 ContextLoaderListener 来创建根上下文 (Parent) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定根上下文的配置文件位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 配置 DispatcherServlet 来创建其自己的上下文 (Child) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定Servlet上下文的配置文件位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/dispatcher-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h6 id="e-在Spring-Boot中的演变"><a href="#e-在Spring-Boot中的演变" class="headerlink" title="e). 在Spring Boot中的演变"></a>e). 在Spring Boot中的演变</h6><p>Spring Boot 极大地简化了这个过程：</p>
<ol>
<li><strong>无需 <code>web.xml</code></strong>：Spring Boot通过内嵌的Servlet容器（如Tomcat）和自动配置，完全消除了 <code>web.xml</code>。</li>
<li><strong>自动注册</strong>：<code>ContextLoaderListener</code> 和 <code>DispatcherServlet</code> 会被Spring Boot自动检测并注册到Servlet容器中。</li>
<li><strong>简化为单一上下文</strong>：在大多数标准的Spring Boot Web应用中，<strong>不再有明显的父子容器划分</strong>。Spring Boot会创建一个<strong>单一的、统一的 <code>AnnotationConfigServletWebServerApplicationContext</code></strong>，这个上下文同时承担了根上下文和Servlet上下文的角色。所有的Bean（<code>@Service</code>, <code>@Controller</code>等）都注册在这个统一的容器中，大大简化了开发者的心智模型。</li>
</ol>
<p><strong>总结</strong>：<code>WebApplicationContext</code> 是Spring与Web世界集成的基石。理解它在传统Web应用中的<strong>父子容器结构</strong>，有助于我们深入理解Spring MVC的分层设计思想。而了解它在Spring Boot中的<strong>演变和简化</strong>，则能帮助我们更好地利用现代框架进行高效开发。</p>
<hr>
<h3 id="1-3-Bean"><a href="#1-3-Bean" class="headerlink" title="1.3 Bean"></a>1.3 Bean</h3><h4 id="1-3-1-什么是Bean？"><a href="#1-3-1-什么是Bean？" class="headerlink" title="1.3.1 什么是Bean？"></a>1.3.1 什么是Bean？</h4><h5 id="1-核心定义"><a href="#1-核心定义" class="headerlink" title="1. 核心定义"></a>1. 核心定义</h5><p>在Spring框架中，一个<strong>Bean</strong>本质上就是一个<strong>由Spring IoC容器负责实例化、配置、组装和管理生命周期的Java对象</strong>。</p>
<p>换句话说，任何一个普通的Java对象（POJO - Plain Old Java Object），一旦它的创建和管理权被交给了Spring容器，我们就不再称它为简单的“对象”，而是称之为Spring的“Bean”。</p>
<hr>
<h5 id="2-从对象-Object-到Bean的转变"><a href="#2-从对象-Object-到Bean的转变" class="headerlink" title="2. 从对象(Object)到Bean的转变"></a>2. 从对象(Object)到Bean的转变</h5><p>一个普通的Java对象要成为一个Spring Bean，需要经历一个“注册”的过程。</p>
<p>这个“注册”的方式，就是我们接下来要学习的三种声明方式：</p>
<ol>
<li><strong>XML配置</strong>：在<code>&lt;bean&gt;</code>标签中定义。</li>
<li><strong>注解</strong>：在类上添加<code>@Component</code>, <code>@Service</code>, <code>@Repository</code>等注解。</li>
<li><strong>Java Config</strong>：在<code>@Configuration</code>类中使用<code>@Bean</code>方法。</li>
</ol>
<p>一旦Spring容器知道了这个声明，它就会在其生命周期的适当阶段，通过<strong>反射机制</strong>来创建该类的实例，并将其纳入自己的管理体系中，此时，这个对象就正式成为了一个Bean。</p>
<hr>
<h5 id="3-Bean的关键特征"><a href="#3-Bean的关键特征" class="headerlink" title="3. Bean的关键特征"></a>3. Bean的关键特征</h5><p>一个被Spring管理的Bean具有以下几个显著特征：</p>
<ol>
<li><strong>由容器管理 (Container-Managed)</strong>：<ul>
<li>Bean的生老病死（创建、初始化、销毁）完全由IoC容器掌控，开发者无需关心这些细节。</li>
</ul>
</li>
<li><strong>通过配置元数据定义 (Defined by Configuration Metadata)</strong>：<ul>
<li>容器需要一份“蓝图”或“说明书”来了解要创建哪些Bean、它们是什么类型、它们之间有什么依赖关系。这份“说明书”就是XML文件、注解或Java Config。</li>
</ul>
</li>
<li><strong>拥有唯一标识符 (ID&#x2F;Name)</strong>：<ul>
<li>在容器中，每个Bean都有一个或多个唯一的名称（通常称为Bean ID或Bean Name）。我们可以通过这个名称从容器中精确地获取到对应的Bean实例。</li>
<li>默认情况下，如果使用注解，Bean的ID是类名的首字母小写形式（如<code>UserServiceImpl</code>的ID是<code>userServiceImpl</code>）。</li>
</ul>
</li>
<li><strong>拥有作用域 (Scope)</strong>：<ul>
<li>容器可以控制一个Bean是以<strong>单例</strong>（Singleton，整个应用只有一个实例）、<strong>原型</strong>（Prototype，每次请求都创建一个新实例）还是其他作用域（如<code>request</code>、<code>session</code>）存在。</li>
</ul>
</li>
<li><strong>可参与依赖注入 (DI-Capable)</strong>：<ul>
<li>Bean可以声明自己的依赖项（比如<code>UserService</code>依赖<code>UserDao</code>），容器会自动将这些依赖项注入进来，完成Bean之间的“组装”。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">传统对象 (Traditional Object)</th>
<th align="left">Spring Bean</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>创建控制权</strong></td>
<td align="left">在开发者手中，使用 <code>new</code> 关键字。</td>
<td align="left">在Spring容器手中，根据配置元数据创建。</td>
</tr>
<tr>
<td align="left"><strong>依赖管理</strong></td>
<td align="left">开发者手动创建并设置依赖关系。</td>
<td align="left">Spring容器自动注入依赖。</td>
</tr>
<tr>
<td align="left"><strong>生命周期</strong></td>
<td align="left">由JVM的垃圾回收机制决定。</td>
<td align="left">由Spring容器精确管理（初始化、销毁回调）。</td>
</tr>
<tr>
<td align="left"><strong>如何获取</strong></td>
<td align="left">直接通过变量引用。</td>
<td align="left">通过 <code>context.getBean()</code> 或 <code>@Autowired</code> 从容器获取。</td>
</tr>
</tbody></table>
<hr>
<h4 id="1-3-2-声明Bean的三种主流方式"><a href="#1-3-2-声明Bean的三种主流方式" class="headerlink" title="1.3.2 声明Bean的三种主流方式"></a>1.3.2 声明Bean的三种主流方式</h4><h5 id="1-XML配置"><a href="#1-XML配置" class="headerlink" title="1. XML配置"></a>1. XML配置</h5><p>XML配置是Spring框架诞生之初最原始、也是最经典的一种Bean声明方式。开发者通过编写一个或多个XML格式的配置文件，来向Spring IoC容器描述需要管理哪些Bean，以及这些Bean之间的依赖关系。</p>
<h6 id="a-核心标签："><a href="#a-核心标签：" class="headerlink" title="a). 核心标签：&lt;bean&gt;"></a>a). 核心标签：<code>&lt;bean&gt;</code></h6><p>XML配置的核心就是<code>&lt;bean&gt;</code>标签。每一个<code>&lt;bean&gt;</code>标签都对应着容器中一个将被创建和管理的Bean实例。</p>
<p><strong>基本配置</strong></p>
<p>最简单的<code>&lt;bean&gt;</code>标签包含两个基本属性：</p>
<ul>
<li><code>id</code>：定义Bean的唯一标识符（Bean ID）。这个ID在整个IoC容器中必须是唯一的。我们可以通过这个ID从容器中获取Bean。</li>
<li><code>class</code>：指定该Bean实例对应的<strong>完整类名</strong>（包名+类名）。Spring容器会通过反射机制来实例化这个类。</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><p><strong>Java类 (<code>HelloWorld.java</code>)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Your Message : &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>XML配置文件 (<code>beans.xml</code>)</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明一个HelloWorld类型的Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloWorld&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.HelloWorld&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 稍后会介绍如何在这里注入属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="b-依赖注入-DI-in-XML"><a href="#b-依赖注入-DI-in-XML" class="headerlink" title="b). 依赖注入 (DI) in XML"></a>b). 依赖注入 (DI) in XML</h6><p>XML配置支持两种主要的依赖注入方式：<strong>Setter注入</strong>和<strong>构造器注入</strong>。</p>
<p><strong>Setter注入 (Property Injection)</strong></p>
<ul>
<li><strong>原理</strong>：IoC容器首先调用Bean的<strong>无参构造函数</strong>来创建实例，然后调用相应的<code>setXxx()</code>方法来注入依赖。</li>
<li><strong>XML标签</strong>：使用<code>&lt;property&gt;</code>子标签。<ul>
<li><code>name</code>：对应Java类中的<strong>属性名</strong>（实际上是对应<code>set</code>方法名，如<code>name=&quot;message&quot;</code>对应<code>setMessage()</code>方法）。</li>
<li><code>value</code>：用于注入<strong>基本类型</strong>（如<code>String</code>, <code>int</code>, <code>boolean</code>）和它们的包装类。</li>
<li><code>ref</code>：用于注入<strong>其他Bean的引用</strong>。它的值是另一个Bean的ID。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><p><strong>Java类 (<code>UserService.java</code> 和 <code>UserDao.java</code>)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserDao接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123; <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>; &#125;</span><br><span class="line"><span class="comment">// UserDao实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;User saved to database.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须提供setter方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123; <span class="built_in">this</span>.userDao = userDao; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServiceName</span><span class="params">(String serviceName)</span> &#123; <span class="built_in">this</span>.serviceName = serviceName; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service Name: &quot;</span> + serviceName);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>XML配置</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1. 先定义依赖的Bean: userDao --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserDaoImpl&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 定义需要被注入的Bean: userService --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用 &lt;property&gt; 进行Setter注入 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入一个字符串 (基本类型) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;DefaultUserService&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入另一个Bean的引用 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>构造器注入 (Constructor Injection)</strong></p>
<ul>
<li><strong>原理</strong>：IoC容器在创建Bean实例时，直接调用其<strong>带有参数的构造函数</strong>，将依赖项作为构造函数的参数传入。</li>
<li><strong>XML标签</strong>：使用<code>&lt;constructor-arg&gt;</code>子标签。<ul>
<li><code>index</code>：指定参数在构造函数参数列表中的<strong>索引</strong>（从0开始）。</li>
<li><code>type</code>：指定参数的<strong>类型</strong>（如<code>java.lang.String</code>），用于避免歧义。</li>
<li><code>name</code>：指定参数的<strong>名称</strong>（需要Java 8+的编译器支持并开启 <code>-parameters</code> 选项）。</li>
<li><code>value</code>和<code>ref</code>属性与<code>&lt;property&gt;</code>标签中的作用相同。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><p><strong>Java类 (<code>UserService.java</code>)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDao userDao; <span class="comment">// 依赖可以是final的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供带参数的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao userDao, String serviceName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">        <span class="built_in">this</span>.serviceName = serviceName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>XML配置</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserDaoImpl&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用 &lt;constructor-arg&gt; 进行构造器注入 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 方式一：按索引注入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ConstructorUserService&quot;</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 方式二：按类型注入 (如果类型不重复) --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;constructor-arg type=&quot;com.example.UserDao&quot; ref=&quot;userDao&quot; /&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;ConstructorUserService&quot; /&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="c-优势与劣势"><a href="#c-优势与劣势" class="headerlink" title="c). 优势与劣势"></a>c). 优势与劣势</h6><p><strong><code>a. 优势</code></strong></p>
<ol>
<li><strong>非侵入性</strong>：配置信息与Java源代码完全分离。Java类是纯粹的POJO，不需要依赖任何Spring的注解。</li>
<li><strong>配置集中化</strong>：所有的Bean定义和依赖关系都集中在XML文件中，对于理解整个应用的宏观结构非常有帮助，一目了然。</li>
<li><strong>易于修改</strong>：在不重新编译Java代码的情况下，可以通过修改XML文件来改变Bean的行为或替换其实现。</li>
</ol>
<p><strong><code>b. 劣势</code></strong></p>
<ol>
<li><strong>繁琐和冗长</strong>：随着应用规模的增长，XML文件会变得异常庞大和复杂，难以维护。</li>
<li><strong>类型不安全</strong>：XML中配置的类名、属性名都是字符串。如果写错了，只有在运行时容器启动时才能发现，而不能在编译时检查。</li>
<li><strong>导航和重构困难</strong>：在IDE中，从XML配置跳转到对应的Java代码比较麻烦。对Java类进行重命名等操作时，IDE无法自动更新XML中的字符串引用。</li>
<li><strong>配置分散</strong>：虽然XML本身是集中的，但配置信息和它所配置的Java类是分离的，查找一个类的具体配置需要在XML文件中搜索，不如注解直观。</li>
</ol>
<hr>
<h5 id="2-注解驱动-Component-Service-Repository-Controller"><a href="#2-注解驱动-Component-Service-Repository-Controller" class="headerlink" title="2. 注解驱动 (@Component, @Service, @Repository, @Controller)"></a>2. 注解驱动 (<code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code>)</h5><p>随着Java 5引入注解（Annotation），Spring框架也迅速跟进，提供了一种更为简洁、直观的Bean声明方式——<strong>基于注解的组件扫描（Component Scanning）</strong>。开发者不再需要在XML中为每个Bean编写<code>&lt;bean&gt;</code>标签，而是直接在Java类上添加特定的注解，Spring容器会自动扫描并注册它们。</p>
<h6 id="a-核心思想：组件扫描-Component-Scanning"><a href="#a-核心思想：组件扫描-Component-Scanning" class="headerlink" title="a). 核心思想：组件扫描 (Component Scanning)"></a>a). 核心思想：组件扫描 (Component Scanning)</h6><ul>
<li><strong>机制</strong>：我们首先需要在一个配置类（XML或Java Config）中启用组件扫描，并指定一个或多个需要扫描的<strong>基础包（base package）</strong>。</li>
<li><strong>过程</strong>：Spring容器在启动时，会像雷达一样扫描这些基础包以及其所有子包下的所有类。如果发现某个类被特定的注解（如<code>@Component</code>）标记，Spring就会将这个类自动注册为一个Bean。</li>
</ul>
<hr>
<h6 id="b-启用组件扫描"><a href="#b-启用组件扫描" class="headerlink" title="b). 启用组件扫描"></a>b). 启用组件扫描</h6><ul>
<li><p><strong>在XML中启用</strong>：<br>使用<code>&lt;context:component-scan&gt;</code>标签。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;...</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">           https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 启用组件扫描，指定基础包为 &quot;com.example&quot; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.example&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在Java Config中启用（更推荐）</strong>：<br>使用<code>@ComponentScan</code>注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;)</span></span><br><span class="line"><span class="comment">// 如果不指定basePackages，默认扫描当前配置类所在的包及其子包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="c-核心注解：-Component-及其衍生注解"><a href="#c-核心注解：-Component-及其衍生注解" class="headerlink" title="c). 核心注解：@Component 及其衍生注解"></a>c). 核心注解：<code>@Component</code> 及其衍生注解</h6><p><strong><code>a. @Component - 通用组件注解</code></strong></p>
<ul>
<li><strong>作用</strong>：<code>@Component</code> 是最基础、最通用的组件注解。它可以标记任何一个你希望交给Spring管理的类。</li>
<li><strong>Bean ID</strong>：默认情况下，被<code>@Component</code>标记的类的Bean ID是其<strong>类名的首字母小写形式</strong>。例如，类<code>MyCoolService</code>的默认Bean ID是<code>myCoolService</code>。</li>
<li><strong>自定义ID</strong>：你也可以手动指定Bean ID，例如 <code>@Component(&quot;coolService&quot;)</code>。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 将MyUtility注册为Bean，默认ID为 &quot;myUtility&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUtility</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Utility is doing something.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>b. 衍生注解 (Stereotype Annotations)</code></strong></p>
<p>Spring为了更好地在架构层面<strong>区分不同分层的组件</strong>，并为它们附加一些特定功能，提供了三个<code>@Component</code>的衍生注解。它们在功能上与<code>@Component</code>完全等价（都能被扫描并注册为Bean），但<strong>在语义上有所区别</strong>。</p>
<p><strong><code>@Service</code></strong></p>
<ul>
<li><strong>语义</strong>：用于标记<strong>业务逻辑层 (Service Layer)</strong> 的组件。</li>
<li><strong>用途</strong>：通常用在实现业务逻辑的类上，如 <code>UserService</code>, <code>OrderService</code>。使用<code>@Service</code>能更清晰地表明这个类的职责。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span> <span class="comment">// 表明这是业务逻辑层组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Registering a new user...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>@Repository</code></strong></p>
<ul>
<li><strong>语义</strong>：用于标记<strong>数据访问层 (Data Access Layer &#x2F; Persistence Layer)</strong> 的组件。</li>
<li><strong>用途</strong>：通常用在直接与数据库交互的DAO（Data Access Object）类上，如 <code>UserDao</code>, <code>ProductRepository</code>。</li>
<li><strong>附加功能</strong>：除了标记组件外，<code>@Repository</code>还能<strong>将特定于数据访问技术的异常（如JDBC的<code>SQLException</code>）统一转译为Spring的数据访问异常体系（<code>DataAccessException</code>）</strong>。这使得上层业务代码可以从底层的具体持久化技术中解耦，无需处理特定的数据库异常。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span> <span class="comment">// 表明这是数据访问层组件，并开启异常转译</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 假设这里有JDBC代码，如果抛出SQLException</span></span><br><span class="line">        <span class="comment">// Spring会将其捕获并包装成一个非检查型异常抛出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Saving user to the database.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>@Controller</code> &#x2F; <code>@RestController</code></strong></p>
<ul>
<li><strong>语义</strong>：用于标记<strong>表现层 (Presentation Layer)</strong> 的组件，通常是<strong>Web层的控制器</strong>。</li>
<li><strong>用途</strong>：在Spring MVC或Spring WebFlux项目中，用于处理HTTP请求的控制器类。</li>
<li><strong><code>@RestController</code></strong>：是<code>@Controller</code>和<code>@ResponseBody</code>的组合注解，专门用于构建RESTful API，它表示该控制器所有方法的返回值都将直接作为响应体（通常是JSON格式）返回，而不是去解析视图。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span> <span class="comment">// 表明这是Web层的REST控制器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;List of users&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么要有衍生注解？</strong></p>
<table>
<thead>
<tr>
<th align="left">注解</th>
<th align="left">目标分层</th>
<th align="left">主要职责</th>
<th align="left">附加功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>@Component</code></strong></td>
<td align="left">(通用)</td>
<td align="left">任何希望被Spring管理的组件</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><strong><code>@Service</code></strong></td>
<td align="left"><strong>业务层</strong></td>
<td align="left">封装核心业务逻辑</td>
<td align="left">无 (纯语义)</td>
</tr>
<tr>
<td align="left"><strong><code>@Repository</code></strong></td>
<td align="left"><strong>数据访问层</strong></td>
<td align="left">数据库增删改查、数据持久化</td>
<td align="left"><strong>异常转译</strong></td>
</tr>
<tr>
<td align="left"><strong><code>@Controller</code></strong></td>
<td align="left"><strong>表现层</strong></td>
<td align="left">接收HTTP请求，返回视图或模型数据</td>
<td align="left">(与Spring MVC集成)</td>
</tr>
</tbody></table>
<p>使用这些语义化的注解，而不是到处都用<code>@Component</code>，是一种<strong>最佳实践</strong>。它能让你的代码<strong>自解释 (self-documenting)</strong>，使得其他开发者（或未来的你）能通过注解一眼就看出这个类的架构职责。</p>
<hr>
<h6 id="d-优势与劣势"><a href="#d-优势与劣势" class="headerlink" title="d). 优势与劣势"></a>d). 优势与劣势</h6><p><strong><code>a. 优势</code></strong></p>
<ol>
<li><strong>简洁直观</strong>：配置信息（注解）直接写在它所配置的Java类上，代码和配置高度内聚，易于理解和维护。</li>
<li><strong>开发效率高</strong>：只需在类上加一个注解，无需在XML中进行繁琐的配置。</li>
<li><strong>更好的IDE支持</strong>：IDE可以轻松地识别注解，提供更好的代码导航、自动补全和重构支持。</li>
</ol>
<p><strong><code>b. 劣势</code></strong></p>
<ol>
<li><strong>侵入性</strong>：Java代码需要依赖Spring的注解API（如<code>org.springframework.stereotype.Component</code>），与Spring框架产生了耦合。</li>
<li><strong>配置分散</strong>：配置信息分散在各个Java类中，不如XML那样能提供一个全局的、集中的配置视图。</li>
<li><strong>对第三方库不友好</strong>：如果你想将一个<strong>第三方库</strong>中的类（你没有它的源码）注册为Bean，你无法去修改它的源码来添加<code>@Component</code>注解。这种场景下，XML配置或Java Config是更好的选择。</li>
</ol>
<p><strong>总结</strong></p>
<p>注解驱动是目前Spring应用开发中最主流、最高效的配置方式。它通过<strong>组件扫描</strong>和<strong>语义化的分层注解</strong>，极大地简化了Bean的声明过程。虽然它有一定的侵入性，但在大多数业务开发场景中，其带来的开发便利性远远超过了这点小小的代价。</p>
<hr>
<h5 id="3-Java-Config-Configuration-Bean"><a href="#3-Java-Config-Configuration-Bean" class="headerlink" title="3. Java Config (@Configuration, @Bean)"></a>3. Java Config (<code>@Configuration</code>, <code>@Bean</code>)</h5><h6 id="a-什么是Java-Config？"><a href="#a-什么是Java-Config？" class="headerlink" title="a). 什么是Java Config？"></a>a). 什么是Java Config？</h6><p>Java Config 是一种使用Java类和注解来定义Spring IoC容器中Bean及其依赖关系的方式。它的核心就是 <code>@Configuration</code> 和 <code>@Bean</code> 这两个注解。</p>
<p>这种方式的巨大优势在于：</p>
<ul>
<li><strong>类型安全 (Type-Safe)</strong>：所有的配置都是Java代码，编译器可以检查你的配置是否存在语法错误、方法名错误等问题。而在XML中，这些错误只能在运行时才能发现。</li>
<li><strong>重构友好 (Refactoring-Friendly)</strong>：如果你要重命名一个类或方法，IDE的重构工具可以自动更新所有引用它的Java Config，而XML配置则需要手动查找和修改。</li>
<li><strong>灵活性和编程能力</strong>：你可以在 <code>@Bean</code> 方法中使用任何Java代码（if&#x2F;else、循环、调用其他方法）来动态地、有条件地创建和配置Bean。</li>
</ul>
<hr>
<h6 id="b-核心注解详解"><a href="#b-核心注解详解" class="headerlink" title="b). 核心注解详解"></a>b). 核心注解详解</h6><p><strong>a) <code>@Configuration</code></strong></p>
<ul>
<li><strong>作用</strong>：标记在一个类上，表明这个类是一个<strong>配置类</strong>。Spring容器会处理这个类，并将其中的 <code>@Bean</code> 方法定义的Bean注册到 <code>ApplicationContext</code> 中。</li>
<li><strong>本质</strong>：一个带有 <code>@Configuration</code> 注解的类，其本身也会被Spring当作一个特殊的 <code>@Component</code> 来管理。你可以像注入其他Bean一样注入它。</li>
<li><strong>类比</strong>：可以把它看作是一个 <strong>XML配置文件</strong>（如 <code>applicationContext.xml</code>）。</li>
</ul>
<p><strong>b) <code>@Bean</code></strong></p>
<ul>
<li><strong>作用</strong>：标记在一个方法上，并且这个方法必须位于一个 <code>@Configuration</code> 类中（或者带有 <code>@Component</code> 及其派生注解的类中，但推荐在 <code>@Configuration</code> 中使用）。</li>
<li><strong>功能</strong>：Spring会调用这个方法，并将方法的<strong>返回值</strong>注册为一个Bean。</li>
<li><strong>Bean的名称</strong>：默认情况下，Bean的名称就是<strong>方法名</strong>。你也可以通过 <code>@Bean(name = &quot;customName&quot;)</code> 或 <code>@Bean(&quot;customName&quot;)</code> 来指定一个不同的名字。</li>
<li><strong>类比</strong>：可以把它看作是XML配置中的一个 <strong><code>&lt;bean&gt;</code> 标签</strong>。</li>
</ul>
<hr>
<h6 id="c-SpringBoot中的实际应用与示例"><a href="#c-SpringBoot中的实际应用与示例" class="headerlink" title="c). SpringBoot中的实际应用与示例"></a>c). SpringBoot中的实际应用与示例</h6><p>在SpringBoot中，<code>@SpringBootApplication</code> 这个注解本身就是一个组合注解，它包含了 <code>@Configuration</code>。这意味着你的主启动类（例如 <code>MyApplication.java</code>）本身就是一个配置类！</p>
<p>让我们通过一个实际的例子来理解。假设我们需要在项目中使用一个第三方的邮件发送客户端，这个客户端类我们无法修改，不能在它上面加 <code>@Component</code> 注解。这时，<code>@Bean</code> 就派上用场了。</p>
<p><strong>第一步：定义一个需要被管理的类 (假设这是第三方库提供的)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个模拟的第三方库中的类，我们无法修改它的源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmtpMailSender</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmtpMailSender</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.host = host;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">        System.out.println(<span class="string">&quot;Initializing SmtpMailSender for host: &quot;</span> + host);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String to, String subject, String body)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending email to &quot;</span> + to);</span><br><span class="line">        System.out.println(<span class="string">&quot;Host: &quot;</span> + host + <span class="string">&quot;:&quot;</span> + port);</span><br><span class="line">        System.out.println(<span class="string">&quot;Subject: &quot;</span> + subject);</span><br><span class="line">        System.out.println(<span class="string">&quot;Body: &quot;</span> + body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步：创建一个配置类来定义Bean</strong></p>
<p>我们创建一个专门的配置类来管理邮件相关的Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 application.properties 文件中注入配置值</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mail.smtp.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mail.smtp.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 这个方法告诉Spring：调用我，然后把我返回的对象注册成一个Bean</span></span><br><span class="line">    <span class="keyword">public</span> SmtpMailSender <span class="title function_">smtpMailSender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里，我们可以使用任何Java代码来创建和配置这个对象</span></span><br><span class="line">        <span class="comment">// 这比XML灵活得多</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Creating SmtpMailSender bean...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SmtpMailSender</span>(host, port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><code>application.properties</code> 文件内容:</em></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mail.smtp.host</span>=<span class="string">smtp.example.com</span></span><br><span class="line"><span class="attr">mail.smtp.port</span>=<span class="string">587</span></span><br></pre></td></tr></table></figure>

<p><strong>第三步：在业务代码中使用这个Bean</strong></p>
<p>现在，<code>SmtpMailSender</code> 已经被注册到了 <code>ApplicationContext</code> 中，我们可以在任何需要的地方通过依赖注入来使用它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmtpMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring会自动找到名为&quot;smtpMailSender&quot;的Bean并注入进来</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationService</span><span class="params">(SmtpMailSender mailSender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mailSender = mailSender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendWelcomeEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        mailSender.send(email, <span class="string">&quot;Welcome!&quot;</span>, <span class="string">&quot;Thanks for signing up.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h6 id="d-Java-Config-与-ComponentScan-的关系"><a href="#d-Java-Config-与-ComponentScan-的关系" class="headerlink" title="d). Java Config 与 @ComponentScan 的关系"></a>d). <code>Java Config</code> 与 <code>@ComponentScan</code> 的关系</h6><p>现在我们把所有知识点串起来：</p>
<ol>
<li><strong>启动过程</strong>：当你运行 <code>SpringApplication.run()</code> 时，SpringBoot创建了 <code>AnnotationConfigServletWebServerApplicationContext</code>。</li>
<li><strong>寻找配置源</strong>：这个 <code>ApplicationContext</code> 需要知道去哪里加载Bean的定义。它会把你的主启动类（带有 <code>@SpringBootApplication</code>）作为一个主要的配置源。</li>
<li><strong>处理配置类</strong>：<ul>
<li>因为 <code>@SpringBootApplication</code> 包含了 <code>@ComponentScan</code>，所以<code>Context</code>会扫描主类所在的包及其子包，寻找所有被 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@RestController</code> 等注解标记的类，并将它们自动注册为Bean（这是<strong>隐式Bean定义</strong>）。</li>
<li>因为 <code>@SpringBootApplication</code> 包含了 <code>@Configuration</code>，所以<code>Context</code>会处理主启动类，以及扫描到的其他 <code>@Configuration</code> 类（比如我们上面写的 <code>MailConfig</code>）。它会查找这些类中所有被 <code>@Bean</code> 注解标记的方法，执行它们，并将返回值注册为Bean（这是<strong>显式Bean定义</strong>）。</li>
</ul>
</li>
</ol>
<p><strong>总结：</strong></p>
<p>在实际的SpringBoot Web后端开发中，<code>ApplicationContext</code> (即 <code>AnnotationConfigServletWebServerApplicationContext</code>) 就是通过这两种方式结合来构建完整的Bean集合的：</p>
<ul>
<li><strong>组件扫描 (<code>@ComponentScan</code>)</strong>：用于自动发现和注册你自己编写的业务组件。</li>
<li><strong>Java配置 (<code>@Configuration</code> + <code>@Bean</code>)</strong>：用于显式地、集中地定义那些需要复杂初始化逻辑的、或者来自第三方库的Bean。</li>
</ul>
<p>这两者共同构成了 <code>AnnotationConfig...</code> 上下文的配置基础，为你提供了一个强大、灵活且类型安全的IoC容器。</p>
<hr>
<h4 id="1-3-3-组件扫描-ComponentScan-的工作原理"><a href="#1-3-3-组件扫描-ComponentScan-的工作原理" class="headerlink" title="1.3.3 组件扫描(@ComponentScan)的工作原理"></a>1.3.3 组件扫描(<code>@ComponentScan</code>)的工作原理</h4><h5 id="1-核心目标"><a href="#1-核心目标" class="headerlink" title="1. 核心目标"></a>1. 核心目标</h5><p><code>@ComponentScan</code> 的核心目标是：<strong>自动化地发现和注册Bean</strong>。</p>
<p>在没有组件扫描之前，你需要为每一个想让Spring管理的类，在XML文件中写一个对应的<code>&lt;bean&gt;</code>标签，或者在Java配置类中写一个<code>@Bean</code>方法。当项目规模变大时，这种手动注册的方式会变得极其繁琐和容易出错。</p>
<p><code>@ComponentScan</code>解决了这个问题，它告诉Spring：“请到我指定的这些地方去寻找带有特定注解的类，然后自动把它们注册成Bean。”</p>
<hr>
<h5 id="2-工作流程详解"><a href="#2-工作流程详解" class="headerlink" title="2. 工作流程详解"></a>2. 工作流程详解</h5><p>组件扫描的整个过程可以分解为以下几个步骤：</p>
<p><strong>第一步：触发扫描</strong></p>
<ul>
<li>扫描是在Spring容器（<code>ApplicationContext</code>）的初始化过程中被触发的。</li>
<li>当容器处理一个带有 <code>@Configuration</code> 注解的配置类时，它会检查这个类上是否存在 <code>@ComponentScan</code> 注解。</li>
<li>在SpringBoot中，<code>@SpringBootApplication</code> 注解已经包含了 <code>@ComponentScan</code>，所以主启动类就是扫描的触发点。</li>
</ul>
<p><strong>第二步：确定扫描起点（Base Packages）</strong></p>
<ul>
<li><code>@ComponentScan</code> 需要知道从哪里开始扫描。这个起始点被称为“基础包”（Base Packages）。</li>
<li><strong>默认行为（SpringBoot中）</strong>：如果没有明确指定基础包，Spring会把<strong>声明<code>@ComponentScan</code>注解的那个类所在的包</strong>作为扫描的起点。<ul>
<li>这就是为什么SpringBoot推荐你把主启动类放在项目的根包下（例如 <code>com.example.myapp</code>），这样它就能自动扫描到 <code>com.example.myapp.controller</code>、<code>com.example.myapp.service</code> 等所有子包中的组件。</li>
</ul>
</li>
<li><strong>显式指定</strong>：你可以通过参数来精确控制扫描的范围：<ul>
<li><code>@ComponentScan(basePackages = &quot;com.example.anotherpackage&quot;)</code></li>
<li><code>@ComponentScan(basePackageClasses = SomeClass.class)</code> (更类型安全的方式，它会扫描<code>SomeClass</code>所在的包)</li>
</ul>
</li>
</ul>
<p><strong>第三步：执行类路径扫描</strong></p>
<ul>
<li>确定了起点后，Spring的扫描器会开始工作。它会递归地遍历基础包及其所有子包下的<strong>类路径（classpath）</strong>。</li>
<li>这个过程并不是去读取<code>.java</code>源文件，而是去检查编译后的<code>.class</code>文件。</li>
<li>为了提高效率，Spring使用了一种名为ASM的字节码操作库。它可以在不完全加载类到JVM的情况下，就能读取到类的元数据（比如类名、注解信息等），这比使用Java反射要快得多。</li>
</ul>
<p><strong>第四步：筛选候选组件</strong></p>
<ul>
<li><p>扫描器在遍历<code>.class</code>文件时，会检查每个类是否带有特定的**“构造型注解”（Stereotype Annotations）**。</p>
</li>
<li><p>最核心的构造型注解是 <code>@Component</code>。</p>
</li>
<li><p>其他常见的注解，如 <code>@Service</code>、<code>@Repository</code>、<code>@RestController</code>、<code>@Configuration</code>，它们本身都是被 <code>@Component</code> <strong>元注解</strong>（meta-annotated）的。这意味着，一个类只要被这些注解中的任何一个标记，就会被扫描器视为一个候选的Bean组件。</p>
<ul>
<li><p>例如，<code>@Service</code>注解的源码是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// &lt;-- 关键在于这里！</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>第五步：注册Bean定义（BeanDefinition）</strong></p>
<ul>
<li>对于每一个筛选出来的候选组件，Spring并不会立即创建它的实例。</li>
<li>相反，它会为这个类创建一个**<code>BeanDefinition</code>**对象。</li>
<li><code>BeanDefinition</code> 就像是创建Bean的“蓝图”或“配方”，它包含了所有关于这个Bean的元信息，例如：<ul>
<li>Bean的类名 (<code>com.example.myapp.service.MyService</code>)</li>
<li>Bean的作用域（默认为<code>singleton</code>）</li>
<li>是否是懒加载</li>
<li>依赖关系等</li>
</ul>
</li>
<li>然后，Spring将这个<code>BeanDefinition</code>注册到容器内部的一个名为<code>BeanDefinitionRegistry</code>的注册表中。</li>
</ul>
<p><strong>第六步：实例化Bean</strong></p>
<ul>
<li>在容器初始化后续阶段，Spring会遍历<code>BeanDefinitionRegistry</code>中所有的<code>BeanDefinition</code>。</li>
<li>根据这些“蓝图”，Spring的<code>BeanFactory</code>才会真正地去创建Bean的实例、处理依赖注入（<code>@Autowired</code>）、执行初始化回调方法等，最终将一个完整的、可用的Bean放入到单例池（Singleton Cache）中，供应用程序使用。</li>
</ul>
<hr>
<h5 id="3-示例与总结"><a href="#3-示例与总结" class="headerlink" title="3. 示例与总结"></a>3. 示例与总结</h5><p><strong>项目结构:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">com.example.myapp</span><br><span class="line">├── MyApplication.java       // 主启动类，位于根包</span><br><span class="line">├── controller</span><br><span class="line">│   └── UserController.java  // @RestController</span><br><span class="line">├── service</span><br><span class="line">│   └── UserService.java     // @Service</span><br><span class="line">└── repository</span><br><span class="line">    └── UserRepository.java  // @Repository</span><br></pre></td></tr></table></figure>

<p><strong>工作流程演示:</strong></p>
<ol>
<li>运行 <code>MyApplication</code>，SpringBoot启动 <code>AnnotationConfigServletWebServerApplicationContext</code>。</li>
<li><code>Context</code> 发现 <code>MyApplication</code> 上有 <code>@SpringBootApplication</code>，其中包含了 <code>@ComponentScan</code>。</li>
<li>由于没有指定<code>basePackages</code>，扫描起点被确定为 <code>com.example.myapp</code>。</li>
<li>扫描器开始递归扫描 <code>com.example.myapp</code> 及其子包 <code>controller</code>, <code>service</code>, <code>repository</code>。</li>
<li>它发现了：<ul>
<li><code>UserController</code> 带有 <code>@RestController</code> (其元注解是 <code>@Component</code>)</li>
<li><code>UserService</code> 带有 <code>@Service</code> (其元注解是 <code>@Component</code>)</li>
<li><code>UserRepository</code> 带有 <code>@Repository</code> (其元注解是 <code>@Component</code>)</li>
</ul>
</li>
<li>Spring为这三个类分别创建了<code>BeanDefinition</code>，并注册到容器中。</li>
<li>随后，Spring根据这些<code>BeanDefinition</code>实例化<code>UserController</code>, <code>UserService</code>, <code>UserRepository</code>，并处理它们之间的依赖注入关系。</li>
</ol>
<hr>
<h3 id="1-4-依赖注入-DI"><a href="#1-4-依赖注入-DI" class="headerlink" title="1.4 依赖注入(DI)"></a>1.4 依赖注入(DI)</h3><h4 id="1-4-1-Setter注入"><a href="#1-4-1-Setter注入" class="headerlink" title="1.4.1 Setter注入"></a>1.4.1 Setter注入</h4><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h5><p>Setter注入是Spring IoC容器通过调用Bean的<strong>setter方法</strong>来将依赖项注入到该Bean中的一种方式。为了让Spring能够执行Setter注入，类中必须为对应的依赖提供一个 <code>public</code> 的setter方法。</p>
<hr>
<h5 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h5><ol>
<li><strong>实例化Bean</strong>：Spring容器首先通过调用Bean的<strong>无参构造函数</strong>来创建该Bean的实例。在这一步，被注入的依赖字段是 <code>null</code>。</li>
<li><strong>调用Setter方法</strong>：创建实例后，Spring容器会查找被<code>@Autowired</code>注解标记的setter方法（或者被标记的字段对应的setter方法）。</li>
<li><strong>注入依赖</strong>：Spring从容器中找到所需类型的Bean（依赖项），然后调用setter方法，将该依赖项作为参数传入，从而完成注入。</li>
</ol>
<hr>
<h5 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><p>让我们沿用之前的例子，有一个<code>MessageService</code>和需要它的<code>NotificationManager</code>。</p>
<p><strong>第一步：定义接口和实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 注册为一个Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending email with message: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步：使用Setter注入</strong></p>
<p>在<code>NotificationManager</code>中，我们定义一个setter方法来接收<code>MessageService</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在无参构造函数执行时，messageService 仍然是 null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;NotificationManager constructor called. MessageService is: &quot;</span> + <span class="built_in">this</span>.messageService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring容器会找到这个setter方法并调用它来注入MessageService的实例</span></span><br><span class="line">    <span class="comment">// @Autowired可以放在方法上</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessageService</span><span class="params">(MessageService messageService)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Setter injection: Injecting MessageService into NotificationManager.&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.messageService = messageService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendNotification</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 在setter被调用后，messageService才可用</span></span><br><span class="line">        <span class="keyword">if</span> (messageService == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Error: MessageService has not been injected!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        messageService.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> <code>@Autowired</code>注解可以直接放在setter方法上。更常见的做法是将其放在字段上，Spring在注入时会尝试寻找并使用对应的setter方法（如果存在）。如果不存在setter方法，Spring会通过反射直接设置私有字段的值（这其实是字段注入）。但从概念上讲，为字段提供setter方法并让Spring使用它，就是标准的Setter注入。</p>
<hr>
<h5 id="4-优点"><a href="#4-优点" class="headerlink" title="4. 优点"></a>4. 优点</h5><ul>
<li><strong>可选依赖（Optional Dependencies）</strong>：这是Setter注入最主要的适用场景。如果一个依赖不是必需的，那么使用Setter注入就非常合适。即使容器中没有找到对应的Bean，对象本身仍然可以被创建，只是与该依赖相关的功能将不可用。</li>
<li><strong>灵活性和可重配置性</strong>：对象创建后，理论上仍然可以通过调用setter方法来更换其依赖（虽然在单例Bean的生命周期中很少这样做）。</li>
<li><strong>解决部分循环依赖问题</strong>：在某些情况下，Setter注入可以解决构造器注入无法解决的循环依赖问题（例如A依赖B，B又依赖A）。因为对象A可以先被构造出来（依赖B此时为null），然后再注入B。当构造B时，因为A的实例已经存在（虽然未完全初始化），所以可以注入到B中。<strong>但循环依赖通常是代码设计不良的信号</strong>。</li>
</ul>
<hr>
<h5 id="5-缺点（以及为什么它不再是首选）"><a href="#5-缺点（以及为什么它不再是首选）" class="headerlink" title="5. 缺点（以及为什么它不再是首选）"></a>5. 缺点（以及为什么它不再是首选）</h5><ul>
<li><strong>对象状态不完整</strong>：Bean在构造函数执行完毕后，其依赖项可能仍然是<code>null</code>。它不是一个“开箱即用”的完整对象。只有在所有setter方法都被调用后，这个对象才处于完全可用的状态。这可能导致在初始化过程中出现<code>NullPointerException</code>。</li>
<li><strong>可变性（Mutability）</strong>：由于提供了<code>public</code>的setter方法，这个类的依赖关系可以在外部被改变，破坏了对象的不变性。在多线程环境中，这可能会引入不确定性。</li>
<li><strong>隐藏依赖关系</strong>：类的使用者无法通过构造函数清晰地看到这个类需要哪些<strong>必要</strong>的依赖。一个只有无参构造函数的类看起来似乎不依赖任何东西，但实际上它可能无法在没有setter注入的情况下正常工作。</li>
</ul>
<hr>
<h4 id="1-4-2-构造器注入-官方推荐"><a href="#1-4-2-构造器注入-官方推荐" class="headerlink" title="1.4.2 构造器注入 (官方推荐)"></a>1.4.2 构造器注入 (官方推荐)</h4><h5 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. 定义</h5><p>构造器注入是Spring IoC容器通过调用Bean的<strong>构造函数</strong>，并将依赖项作为构造函数<strong>参数</strong>传入，来完成依赖注入的方式。这是实现依赖注入最清晰、最安全的方法。</p>
<hr>
<h5 id="2-工作原理-1"><a href="#2-工作原理-1" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h5><ol>
<li><strong>识别构造函数</strong>：当Spring容器需要创建一个Bean的实例时（例如<code>NotificationManager</code>），它会检查这个类的构造函数。<ul>
<li><strong>如果只有一个构造函数</strong>：从Spring 4.3开始，Spring会自动使用这个构造函数进行注入，你<strong>甚至不需要</strong>在上面添加<code>@Autowired</code>注解。这是最简洁、最推荐的方式。</li>
<li><strong>如果有多个构造函数</strong>：Spring会不知道使用哪一个。在这种情况下，你<strong>必须</strong>在你想让Spring使用的那个构造函数上明确地添加<code>@Autowired</code>注解。</li>
</ul>
</li>
<li><strong>解析依赖项</strong>：Spring会分析所选构造函数的参数列表（例如，它看到需要一个<code>MessageService</code>类型的Bean）。</li>
<li><strong>获取依赖Bean</strong>：Spring会去自己的容器中查找一个匹配类型的Bean（例如，它找到了我们之前定义的<code>EmailService</code>实例）。</li>
<li><strong>调用构造函数并实例化</strong>：Spring调用该构造函数，并将找到的依赖Bean作为参数传入，从而创建<code>NotificationManager</code>的实例。</li>
</ol>
<p>关键在于，<strong>对象在被创建的那一刻，其所有必需的依赖就已经被完全设置好了</strong>。</p>
<hr>
<h5 id="3-代码示例-1"><a href="#3-代码示例-1" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><p>我们继续使用<code>NotificationManager</code>的例子，这次改用构造器注入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 final 关键字声明依赖，这是一个非常好的实践！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring会自动调用这个构造函数</span></span><br><span class="line">    <span class="comment">// @Autowired 在只有一个构造函数时是可选的</span></span><br><span class="line">    <span class="comment">// public NotificationManager(@Qualifier(&quot;emailService&quot;) MessageService messageService) &#123; // 如果有多个实现，可以使用@Qualifier指定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationManager</span><span class="params">(MessageService messageService)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Constructor injection: Injecting MessageService into NotificationManager.&quot;</span>);</span><br><span class="line">        <span class="comment">// 在构造函数执行时，依赖就已经可用了</span></span><br><span class="line">        <span class="built_in">this</span>.messageService = messageService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendNotification</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">// messageService 保证不为 null，因为构造函数强制要求它</span></span><br><span class="line">        messageService.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-优点-为什么官方推荐？"><a href="#4-优点-为什么官方推荐？" class="headerlink" title="4. 优点 (为什么官方推荐？)"></a>4. 优点 (为什么官方推荐？)</h5><p>构造器注入之所以成为首选，是因为它具有Setter注入无法比拟的巨大优势：</p>
<ol>
<li><p><strong>依赖的不可变性 (Dependency Immutability)</strong></p>
<ul>
<li>你可以将依赖字段声明为 <code>final</code>（如示例所示）。</li>
<li><code>final</code> 字段必须在构造函数中被初始化，并且之后不能再被修改。</li>
<li>这使得你的Bean成为一个<strong>不可变对象</strong>（至少其依赖关系是不可变的），这在多线程环境中更安全，也使得代码的行为更加可预测和稳定。</li>
</ul>
</li>
<li><p><strong>保证对象状态的完整性 (Guaranteed Object Integrity)</strong></p>
<ul>
<li>对象一旦被创建，就处于一个完全初始化、可用的状态。</li>
<li>你永远不会遇到一个已经被构造出来、但其必需的依赖还是 <code>null</code> 的情况。这从根本上杜绝了在后续方法调用中出现<code>NullPointerException</code>的风险。</li>
</ul>
</li>
<li><p><strong>明确的依赖关系 (Clear Dependency Declaration)</strong></p>
<ul>
<li>类的构造函数签名就像一份“契约”，清晰地声明了“要创建我这个类的实例，你<strong>必须</strong>提供这些依赖”。</li>
<li>这使得代码的可读性大大提高。任何开发者看到这个类，都能立刻明白它的核心依赖是什么，而不需要去寻找散落在各处的setter方法。</li>
</ul>
</li>
<li><p><strong>易于单元测试 (Easier Unit Testing)</strong></p>
<ul>
<li>使用构造器注入的类，在进行单元测试时非常方便。你不需要启动整个Spring容器。</li>
<li>你可以直接使用 <code>new</code> 关键字来实例化你的类，并传入一个模拟（Mock）的依赖对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在JUnit测试中</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSendNotification</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个模拟的依赖</span></span><br><span class="line">    <span class="type">MessageService</span> <span class="variable">mockService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockMessageService</span>(); <span class="comment">// 或者使用Mockito.mock(MessageService.class)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 直接使用new关键字创建被测试对象，完全脱离Spring</span></span><br><span class="line">    <span class="type">NotificationManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotificationManager</span>(mockService);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 执行测试</span></span><br><span class="line">    manager.sendNotification(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 验证模拟对象的行为</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="5-缺点-注意事项"><a href="#5-缺点-注意事项" class="headerlink" title="5. 缺点&#x2F;注意事项"></a>5. 缺点&#x2F;注意事项</h5><ul>
<li><p><strong>循环依赖问题 (Circular Dependency Problem)</strong></p>
<ul>
<li>如果类A通过构造器依赖类B，同时类B也通过构造器依赖类A，Spring在启动时会抛出<code>BeanCurrentlyInCreationException</code>异常，因为无法解决这个“先有鸡还是先有蛋”的问题。</li>
<li><strong>但这通常被认为是一个优点</strong>！它在应用启动的早期就暴露了代码设计的坏味道（Bad Smell）。循环依赖通常意味着类的职责划分不清晰，应该通过重构来解决，而不是绕过它。</li>
</ul>
</li>
<li><p><strong>代码冗长 (Verbosity)</strong></p>
<ul>
<li>如果一个类有大量的依赖，构造函数会变得很长。</li>
<li>但这同样也是一个代码设计的警告信号，可能表示该类承担了过多的责任（违反了单一职责原则）。</li>
<li>在实践中，可以使用<strong>Lombok</strong>项目的<code>@RequiredArgsConstructor</code>注解来自动生成构造函数，从而完全消除这种冗长的代码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span> <span class="comment">// Lombok注解：为所有final字段生成一个构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageService messageService;</span><br><span class="line">    <span class="comment">// 构造函数代码被自动生成了，非常简洁！</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendNotification</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        messageService.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-4-3-字段注入-简洁但不推荐"><a href="#1-4-3-字段注入-简洁但不推荐" class="headerlink" title="1.4.3 字段注入 (简洁但不推荐)"></a>1.4.3 字段注入 (简洁但不推荐)</h4><h5 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1. 定义"></a>1. 定义</h5><p>字段注入是通过将 <code>@Autowired</code> 注解直接标记在类的<strong>成员字段</strong>上，来让Spring容器注入依赖的方式。它不需要任何构造函数或setter方法。</p>
<hr>
<h5 id="2-工作原理-2"><a href="#2-工作原理-2" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h5><ol>
<li><strong>实例化Bean</strong>：Spring容器首先通过调用Bean的<strong>无参构造函数</strong>来创建实例。在这一刻，所有被 <code>@Autowired</code> 标记的字段都还是 <code>null</code>。</li>
<li><strong>使用反射进行注入</strong>：在对象实例化之后，Spring容器会使用<strong>Java的反射（Reflection）API</strong>来直接设置这些字段的值。它会强行访问这些字段（即使它们是 <code>private</code> 的），并将从容器中找到的依赖Bean赋值给它们。</li>
</ol>
<p>这个过程完全绕过了类的公共方法（构造函数和setter），直接在“幕后”完成了依赖的设置。</p>
<hr>
<h5 id="3-代码示例-2"><a href="#3-代码示例-2" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><p>这是看起来最简洁的一种写法，也因此在很多早期教程和项目中非常流行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Autowired直接放在字段上</span></span><br><span class="line">    <span class="comment">// Spring会通过反射直接为这个私有字段赋值</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只需要一个无参构造函数（如果没有其他构造函数，默认就有一个）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在构造函数执行时，messageService 绝对是 null!</span></span><br><span class="line">        System.out.println(<span class="string">&quot;NotificationManager constructor called. MessageService is: &quot;</span> + <span class="built_in">this</span>.messageService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendNotification</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 在Spring完成反射注入后，messageService才可用</span></span><br><span class="line">        <span class="keyword">if</span> (messageService == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 理论上在Spring管理的Bean中，这个分支不会被执行</span></span><br><span class="line">            System.err.println(<span class="string">&quot;Error: MessageService has not been injected!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        messageService.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出日志会显示：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NotificationManager constructor called. MessageService is: null</span><br><span class="line">Sending email with message: Your notification</span><br></pre></td></tr></table></figure>

<p>这清晰地证明了注入发生在构造函数执行<strong>之后</strong>。</p>
<hr>
<h5 id="4-优点（为什么人们会用它？）"><a href="#4-优点（为什么人们会用它？）" class="headerlink" title="4. 优点（为什么人们会用它？）"></a>4. 优点（为什么人们会用它？）</h5><ul>
<li><strong>极其简洁</strong>：代码量最少。只需要加一个注解和一行字段声明，不需要写任何构造函数或setter方法，看起来非常“干净”。</li>
</ul>
<p>这就是它唯一的优点，但这个优点带来的代价远大于它的便利性。</p>
<hr>
<h5 id="5-缺点（为什么官方和社区强烈不推荐？）"><a href="#5-缺点（为什么官方和社区强烈不推荐？）" class="headerlink" title="5. 缺点（为什么官方和社区强烈不推荐？）"></a>5. 缺点（为什么官方和社区强烈不推荐？）</h5><ol>
<li><p><strong>隐藏依赖关系 (Hidden Dependencies)</strong></p>
<ul>
<li>类的依赖关系被隐藏在了实现细节中。你无法通过查看类的公共接口（构造函数）来知道它需要什么才能工作。你必须阅读整个类的源码才能找到所有 <code>@Autowired</code> 字段。</li>
</ul>
</li>
<li><p><strong>极大地增加了单元测试的难度 (Difficulty in Unit Testing)</strong></p>
<ul>
<li>这是最致命的缺点。由于这个类依赖于Spring的反射注入，你无法在单元测试中简单地用 <code>new</code>的实例并提供模拟依赖。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在单元测试中，这样做会失败！</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSendNotification_Fails</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">NotificationManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotificationManager</span>();</span><br><span class="line">    <span class="comment">// 运行到下面这行时，manager.messageService 是 null，会抛出 NullPointerException</span></span><br><span class="line">    manager.sendNotification(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为了测试它，你不得不使用更复杂的方法：<ul>
<li><strong>A) 使用反射来手动设置私有字段</strong>：这非常繁琐且容易出错。</li>
<li><strong>B) 启动一个完整的Spring测试容器</strong>（例如使用 <code>@SpringBootTest</code>）：这会大大减慢测试速度，使其更像是集成测试，而不是轻量级的单元测试。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>无法创建不可变对象 (Immutability is Impossible)</strong></p>
<ul>
<li>因为依赖是在对象构造之后才注入的，所以你<strong>无法将依赖字段声明为 <code>final</code></strong>。</li>
<li>这意味着你的Bean本质上是可变的，失去了 <code>final</code> 关键字带来的所有好处（如线程安全、代码可预测性等）。</li>
</ul>
</li>
<li><p><strong>与依赖注入容器强耦合 (Tight Coupling to DI Container)</strong></p>
<ul>
<li>这个类只有在Spring容器的环境下才能被正确地实例化和使用。它无法脱离Spring作为一个独立的、普通的Java对象（POJO）来使用。而使用构造器注入的类则完全可以。</li>
</ul>
</li>
<li><p><strong>可能助长坏习惯 (Encourages Bad Practices)</strong></p>
<ul>
<li>因为添加一个新依赖非常简单（只需加一行 <code>@Autowired</code> 字段），开发者可能会不知不觉地给一个类添加过多的依赖（例如10个、15个）。</li>
<li>如果使用构造器注入，一个有15个参数的构造函数会立刻发出强烈的“警告信号”，表明这个类职责过多，需要重构。字段注入则完美地隐藏了这个问题。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="6-一个可以接受的例外场景"><a href="#6-一个可以接受的例外场景" class="headerlink" title="6. 一个可以接受的例外场景"></a>6. 一个可以接受的例外场景</h5><p>字段注入有一个被社区普遍接受的例外使用场景：<strong>在测试类中注入Mocks</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.extension.ExtendWith;</span><br><span class="line"><span class="keyword">import</span> org.mockito.InjectMocks;</span><br><span class="line"><span class="keyword">import</span> org.mockito.Mock;</span><br><span class="line"><span class="keyword">import</span> org.mockito.junit.jupiter.MockitoExtension;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExtendWith(MockitoExtension.class)</span> <span class="comment">// 启用Mockito扩展</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotificationManagerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span> <span class="comment">// 创建一个MessageService的模拟对象</span></span><br><span class="line">    <span class="keyword">private</span> MessageService mockMessageService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InjectMocks</span> <span class="comment">// 创建NotificationManager实例，并将上面@Mock标记的对象注入进去</span></span><br><span class="line">    <span class="keyword">private</span> NotificationManager notificationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSendNotification</span><span class="params">()</span> &#123;</span><br><span class="line">        notificationManager.sendNotification(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="comment">// ... 验证 mockMessageService 的行为 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，使用字段注入是为了减少测试代码的样板代码，是可以接受的，因为测试类本身不是应用程序的组件。</p>
<hr>
<h5 id="总结与最终对比"><a href="#总结与最终对比" class="headerlink" title="总结与最终对比"></a>总结与最终对比</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">构造器注入 (Constructor Injection)</th>
<th align="left">Setter注入 (Setter Injection)</th>
<th align="left">字段注入 (Field Injection)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>推荐度</strong></td>
<td align="left"><strong>官方首选</strong></td>
<td align="left">用于可选依赖</td>
<td align="left"><strong>强烈不推荐</strong></td>
</tr>
<tr>
<td align="left"><strong>依赖类型</strong></td>
<td align="left">强制性、必需的依赖</td>
<td align="left">可选的、非必需的依赖</td>
<td align="left">任何依赖 (不区分)</td>
</tr>
<tr>
<td align="left"><strong>不可变性</strong></td>
<td align="left"><strong>支持 (通过 <code>final</code>)</strong></td>
<td align="left">不支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left"><strong>对象状态</strong></td>
<td align="left"><strong>创建即完整可用</strong></td>
<td align="left">创建后可能不完整</td>
<td align="left">创建后不完整</td>
</tr>
<tr>
<td align="left"><strong>依赖声明</strong></td>
<td align="left"><strong>清晰，在构造函数中</strong></td>
<td align="left">较隐蔽，在setter方法中</td>
<td align="left"><strong>非常隐蔽，在私有字段中</strong></td>
</tr>
<tr>
<td align="left"><strong>单元测试</strong></td>
<td align="left"><strong>非常容易 (POJO友好)</strong></td>
<td align="left">较麻烦 (需手动调用setter)</td>
<td align="left"><strong>非常困难 (需反射或容器)</strong></td>
</tr>
<tr>
<td align="left"><strong>循环依赖</strong></td>
<td align="left"><strong>启动时失败 (暴露问题)</strong></td>
<td align="left">可以解决 (但不推荐)</td>
<td align="left">可以解决 (但不推荐)</td>
</tr>
<tr>
<td align="left"><strong>代码简洁度</strong></td>
<td align="left">较冗长 (可用Lombok解决)</td>
<td align="left">冗长</td>
<td align="left"><strong>非常简洁</strong></td>
</tr>
</tbody></table>
<p><strong>最终建议：在你的所有应用组件（<code>@Service</code>, <code>@Component</code>, <code>@Controller</code>等）中，坚持使用构造器注入。</strong></p>
<hr>
<h4 id="1-4-4-Autowired-Resource-Inject-的区别"><a href="#1-4-4-Autowired-Resource-Inject-的区别" class="headerlink" title="1.4.4 @Autowired, @Resource, @Inject 的区别"></a>1.4.4 <code>@Autowired</code>, <code>@Resource</code>, <code>@Inject</code> 的区别</h4><h5 id="1-Autowired"><a href="#1-Autowired" class="headerlink" title="1. @Autowired"></a>1. <code>@Autowired</code></h5><ul>
<li><strong>来源</strong>: <strong>Spring框架</strong> 自带的注解。它是Spring IoC中使用最广泛的注解。</li>
<li><strong>注入规则 (匹配策略)</strong>: <strong>默认按类型（byType）注入</strong>。<ol>
<li>首先，Spring容器会寻找一个与注入点类型完全匹配的Bean。</li>
<li>如果找到了<strong>唯一一个</strong>匹配的Bean，就直接注入。</li>
<li>如果找到了<strong>多个</strong>匹配的Bean，Spring会陷入困惑。此时，它会尝试将<strong>变量名</strong>（或字段名）作为Bean的ID（或name）进行二次匹配。如果有一个Bean的ID与变量名匹配，就注入那个。</li>
<li>如果二次匹配也失败了（比如没有Bean的ID匹配变量名），Spring就会抛出<code>NoUniqueBeanDefinitionException</code>异常。</li>
<li>为了解决上述的歧义性，<code>@Autowired</code> 通常与 <code>@Qualifier(&quot;beanName&quot;)</code> 注解配合使用，来明确指定要注入哪一个Bean。</li>
</ol>
</li>
<li><strong>关键属性</strong>:<ul>
<li><code>required = false</code>：允许注入的Bean不存在。如果设置为 <code>false</code> 且找不到匹配的Bean，Spring会注入 <code>null</code> 而不是抛出异常。</li>
</ul>
</li>
<li><strong>适用位置</strong>: 构造器、字段、Setter方法、以及任何自定义方法。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认按类型查找 MessageService</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当有多个 MessageService 实现时，使用 @Qualifier 指定</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;smsService&quot;)</span> <span class="comment">// 明确指定注入ID为 &quot;smsService&quot; 的Bean</span></span><br><span class="line">    <span class="keyword">private</span> MessageService specificMessageService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-Resource"><a href="#2-Resource" class="headerlink" title="2. @Resource"></a>2. <code>@Resource</code></h5><ul>
<li><p><strong>来源</strong>: <strong>Java EE 的 JSR-250 规范</strong>。它不属于Spring，而是Java的标准注解。Spring框架支持这个注解。</p>
</li>
<li><p><strong>注入规则 (匹配策略)</strong>: <strong>默认按名称（byName）注入</strong>。</p>
<ol>
<li>首先，它会寻找与**<code>name</code>属性**指定的名称匹配的Bean。</li>
<li>如果没有指定<code>name</code>属性，它会使用<strong>字段名或setter方法名</strong>（去掉<code>set</code>前缀并首字母小写）作为Bean的名称去查找。</li>
<li>如果按名称找不到匹配的Bean，它会<strong>回退（fallback）到按类型（byType）查找</strong>。</li>
<li>如果按类型查找到多个，它会抛出<code>NoUniqueBeanDefinitionException</code>。</li>
</ol>
</li>
<li><p><strong>关键属性</strong>:</p>
<ul>
<li><code>name = &quot;beanName&quot;</code>：直接指定要注入的Bean的名称。</li>
</ul>
</li>
<li><p><strong>适用位置</strong>: 字段、Setter方法。</p>
</li>
<li><p><strong>注意事项</strong>: 从 Java 9 开始，JSR-250 相关的库（<code>javax.annotation-api</code>）被标记为废弃，并在 Java 11 中被移除。如果你在现代的Java版本（9+）中使用 <code>@Resource</code>，你需要手动在 <code>pom.xml</code> 中添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 按名称 &quot;smsService&quot; 查找</span></span><br><span class="line">    <span class="meta">@Resource(name = &quot;smsService&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 未指定name，则按字段名 &quot;emailService&quot; 查找</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MessageService emailService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-Inject"><a href="#3-Inject" class="headerlink" title="3. @Inject"></a>3. <code>@Inject</code></h5><ul>
<li><p><strong>来源</strong>: <strong>Java 的 JSR-330 规范</strong> (CDI - Contexts and Dependency Injection)。它也是一个Java标准，旨在为所有框架提供统一的依赖注入API。</p>
</li>
<li><p><strong>注入规则 (匹配策略)</strong>: <strong>默认按类型（byType）注入</strong>。它的行为几乎和 <code>@Autowired</code> 完全一样。</p>
<ol>
<li>首先按类型查找。</li>
<li>如果找到多个，它需要配合 JSR-330 的 <code>@Named</code> 注解来指定名称，功能类似于Spring的 <code>@Qualifier</code>。</li>
</ol>
</li>
<li><p><strong>关键属性</strong>:</p>
<ul>
<li>它没有 <code>required</code> 属性。如果你想实现可选注入，需要使用Java 8的 <code>Optional&lt;T&gt;</code>。例如 <code>private Optional&lt;MessageService&gt; messageService;</code>。</li>
</ul>
</li>
<li><p><strong>适用位置</strong>: 构造器、字段、方法。</p>
</li>
<li><p><strong>注意事项</strong>: 要使用 <code>@Inject</code>，你需要添加 <code>javax.inject</code> 的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.inject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.inject.Named;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认按类型查找</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当有多个实现时，使用 @Named 指定</span></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="meta">@Named(&quot;smsService&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MessageService specificMessageService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-总结与核心区别（面试高频）"><a href="#3-总结与核心区别（面试高频）" class="headerlink" title="3. 总结与核心区别（面试高频）"></a>3. 总结与核心区别（面试高频）</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>@Autowired</code> (Spring)</th>
<th align="left"><code>@Resource</code> (JSR-250 &#x2F; Java EE)</th>
<th align="left"><code>@Inject</code> (JSR-330 &#x2F; CDI)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>来源</strong></td>
<td align="left">Spring 框架</td>
<td align="left">Java EE 规范</td>
<td align="left">Java CDI 规范</td>
</tr>
<tr>
<td align="left"><strong>默认匹配策略</strong></td>
<td align="left"><strong>按类型 (byType)</strong></td>
<td align="left"><strong>按名称 (byName)</strong></td>
<td align="left"><strong>按类型 (byType)</strong></td>
</tr>
<tr>
<td align="left"><strong>按名称注入方式</strong></td>
<td align="left"><code>@Qualifier(&quot;beanName&quot;)</code></td>
<td align="left"><code>name=&quot;beanName&quot;</code> 或 默认使用字段名</td>
<td align="left"><code>@Named(&quot;beanName&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong>处理可选依赖</strong></td>
<td align="left"><code>required = false</code></td>
<td align="left">不直接支持</td>
<td align="left">使用 <code>Optional&lt;T&gt;</code></td>
</tr>
<tr>
<td align="left"><strong>兼容性</strong></td>
<td align="left">仅 Spring 环境</td>
<td align="left">Spring 及其他 Java EE 容器</td>
<td align="left">Spring 及其他支持CDI的容器</td>
</tr>
<tr>
<td align="left"><strong>依赖</strong></td>
<td align="left">无需额外依赖 (Spring项目自带)</td>
<td align="left"><strong>需要 <code>jakarta.annotation-api</code> (Java 9+)</strong></td>
<td align="left"><strong>需要 <code>javax.inject</code></strong></td>
</tr>
</tbody></table>
<hr>
<h5 id="4-SpringBoot中的最佳实践和选择"><a href="#4-SpringBoot中的最佳实践和选择" class="headerlink" title="4. SpringBoot中的最佳实践和选择"></a>4. SpringBoot中的最佳实践和选择</h5><ol>
<li><strong>首选 <code>@Autowired</code></strong>：<br>在纯粹的Spring或SpringBoot项目中，<strong>始终优先使用 <code>@Autowired</code></strong>。因为：<ul>
<li>它是Spring的原生注解，与Spring生态（如 <code>@Qualifier</code>, <code>@Primary</code>, Spring Test等）的集成最好、功能最强大。</li>
<li>配合构造器注入，可以创建不可变对象，是目前公认的最佳实践。</li>
</ul>
</li>
<li><strong>什么时候考虑 <code>@Resource</code></strong>？<ul>
<li>当你非常明确地<strong>想通过Bean的名称来进行注入</strong>时，<code>@Resource</code> 的意图比 <code>@Autowired</code> + <code>@Qualifier</code> 更直接。</li>
<li>在一些需要同时兼容其他Java EE容器的老项目中，使用 <code>@Resource</code> 可以提供更好的移植性。但要注意新Java版本的依赖问题。</li>
</ul>
</li>
<li><strong>什么时候考虑 <code>@Inject</code></strong>？<ul>
<li>在现代SpringBoot项目中，几乎没有理由选择 <code>@Inject</code>。它的功能被 <code>@Autowired</code> 完全覆盖且更弱（没有 <code>required</code> 属性）。</li>
<li>它的设计初衷是编写可以脱离特定框架（如Spring, Guice）的、具有可移植性的库或组件。如果你在开发这样一个通用库，使用 <code>@Inject</code> 是一个不错的选择。但在开发应用程序时，坚持使用框架提供的原生工具通常更好。</li>
</ul>
</li>
</ol>
<p><strong>结论：</strong> 在实际的SpringBoot Web后端开发中，<strong>坚持使用 <code>@Autowired</code> 并配合构造器注入</strong>，这是最现代、最安全、最符合Spring设计理念的方式。</p>
<hr>
<h4 id="1-4-5-解决注入歧义-Primary-与-Qualifier"><a href="#1-4-5-解决注入歧义-Primary-与-Qualifier" class="headerlink" title="1.4.5 解决注入歧义(@Primary 与 @Qualifier)"></a>1.4.5 解决注入歧义(<code>@Primary</code> 与 <code>@Qualifier</code>)</h4><h5 id="1-问题场景：什么是注入歧义？"><a href="#1-问题场景：什么是注入歧义？" class="headerlink" title="1. 问题场景：什么是注入歧义？"></a>1. 问题场景：什么是注入歧义？</h5><p>假设我们有一个 <code>MessageService</code> 接口，以及两个不同的实现：一个通过邮件发送，一个通过短信发送。</p>
<p><strong>接口定义:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String recipient, String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两个实现:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;emailService&quot;)</span> <span class="comment">// 默认Bean name是 &quot;emailService&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String recipient, String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending EMAIL to &quot;</span> + recipient + <span class="string">&quot;: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(&quot;smsService&quot;)</span> <span class="comment">// 默认Bean name是 &quot;smsService&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String recipient, String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending SMS to &quot;</span> + recipient + <span class="string">&quot;: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，有一个 <code>NotificationManager</code> 需要使用 <code>MessageService</code>。如果我们像下面这样写，问题就出现了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题点!</span></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// Spring: &quot;我找到了两个 MessageService (EmailService 和 SmsService)，我该用哪个?!&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationManager</span><span class="params">(MessageService messageService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messageService = messageService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Spring应用启动时，它会尝试为 <code>NotificationManager</code> 的构造函数注入一个 <code>MessageService</code>。但容器里有两个符合条件的Bean，Spring无法做出决定，于是会抛出 <code>NoUniqueBeanDefinitionException</code> 异常，导致应用启动失败。</p>
<p>下面我们来看两种解决这个问题的方案。</p>
<hr>
<h5 id="2-解决方案一-Primary-指定“首选”Bean"><a href="#2-解决方案一-Primary-指定“首选”Bean" class="headerlink" title="2. 解决方案一: @Primary - 指定“首选”Bean"></a>2. 解决方案一: <code>@Primary</code> - 指定“首选”Bean</h5><p><code>@Primary</code> 注解的作用是告诉Spring：“当出现多个相同类型的候选Bean时，请<strong>优先选择</strong>被 <code>@Primary</code> 标记的这一个。”</p>
<ul>
<li><strong>特点</strong>: 这是一种<strong>提供方驱动</strong>的策略。Bean的定义者（提供方）决定了谁是默认选项。</li>
</ul>
<p><strong>如何使用:</strong></p>
<p>我们只需要在首选的实现类上添加 <code>@Primary</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;emailService&quot;)</span></span><br><span class="line"><span class="meta">@Primary</span> <span class="comment">// &lt;-- 在这里添加注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(&quot;smsService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，当 <code>NotificationManager</code> 请求注入 <code>MessageService</code> 时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationManager</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// Spring: &quot;哦，有两个选择，但EmailService被标记为@Primary，就用它了！&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationManager</span><span class="params">(MessageService messageService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messageService = messageService; <span class="comment">// 这里注入的将是 EmailService 的实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用可以正常启动，并且 <code>NotificationManager</code> 会默认使用 <code>EmailService</code>。</p>
<p><strong>适用场景</strong>:</p>
<p>当你有一个主要的、最常用的或默认的实现时，<code>@Primary</code> 是一个绝佳的选择。例如，系统中可能有多种支付方式，但“支付宝支付”是默认的首选方式。</p>
<hr>
<h5 id="3-解决方案二-Qualifier-指定“限定”Bean"><a href="#3-解决方案二-Qualifier-指定“限定”Bean" class="headerlink" title="3. 解决方案二: @Qualifier - 指定“限定”Bean"></a>3. 解决方案二: <code>@Qualifier</code> - 指定“限定”Bean</h5><p><code>@Qualifier</code> 注解的作用是告诉Spring：“我不要默认的，我<strong>明确地需要</strong>名为 <code>xxx</code> 的那一个Bean。”</p>
<ul>
<li><strong>特点</strong>: 这是一种<strong>消费方驱动</strong>的策略。依赖的注入点（消费方）明确指定它需要哪个具体的实现。</li>
</ul>
<p><strong>如何使用:</strong></p>
<p>在使用 <code>@Autowired</code> 的地方，同时使用 <code>@Qualifier</code> 注解，并传入你想要的Bean的名称（Bean Name）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个实现保持原样，不需要修改</span></span><br><span class="line"><span class="meta">@Service(&quot;emailService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(&quot;smsService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsService</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>现在，假设我们有两个不同的通知管理器，一个用于常规通知（用邮件），一个用于紧急通知（用短信）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegularNotificationManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 明确要求注入名为 &quot;emailService&quot; 的Bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RegularNotificationManager</span><span class="params">(<span class="meta">@Qualifier(&quot;emailService&quot;)</span> MessageService messageService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messageService = messageService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UrgentNotificationManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 明确要求注入名为 &quot;smsService&quot; 的Bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UrgentNotificationManager</span><span class="params">(<span class="meta">@Qualifier(&quot;smsService&quot;)</span> MessageService messageService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messageService = messageService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，每个消费者都可以根据自己的需求，精确地选择想要的实现，完全不受默认设置的影响。</p>
<p><strong>适用场景</strong>:</p>
<p>当选择哪个实现本身就是一种业务逻辑，不同的消费者需要不同的实现时，<code>@Qualifier</code> 是唯一的正确选择。它提供了更高的灵活性和精确性。</p>
<hr>
<h5 id="4-Primary-vs-Qualifier-总结与最佳实践"><a href="#4-Primary-vs-Qualifier-总结与最佳实践" class="headerlink" title="4. @Primary vs. @Qualifier - 总结与最佳实践"></a>4. <code>@Primary</code> vs. <code>@Qualifier</code> - 总结与最佳实践</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>@Primary</code></th>
<th align="left"><code>@Qualifier</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>决定方</strong></td>
<td align="left"><strong>Bean的提供者 (Provider-side)</strong></td>
<td align="left"><strong>Bean的消费者 (Consumer-side)</strong></td>
</tr>
<tr>
<td align="left"><strong>作用</strong></td>
<td align="left">设置一个全局的<strong>默认</strong>选项</td>
<td align="left">在注入点进行<strong>精确</strong>的选择</td>
</tr>
<tr>
<td align="left"><strong>灵活性</strong></td>
<td align="left">较低（一个类型只能有一个<code>@Primary</code>）</td>
<td align="left"><strong>非常高</strong>（每个注入点都可以独立选择）</td>
</tr>
<tr>
<td align="left"><strong>代码位置</strong></td>
<td align="left">标记在Bean的实现类上</td>
<td align="left">标记在注入点 (<code>@Autowired</code>旁边)</td>
</tr>
</tbody></table>
<p><strong>黄金法则：<code>@Qualifier</code> 的优先级高于 <code>@Primary</code>。</strong></p>
<p>这意味着，即使 <code>EmailService</code> 被标记为 <code>@Primary</code>，如果一个消费者使用 <code>@Qualifier(&quot;smsService&quot;)</code>，它仍然会得到 <code>SmsService</code>。<strong>精确指定永远胜过默认设置。</strong></p>
<p><strong>最佳实践建议：</strong></p>
<ol>
<li><strong>问自己一个问题</strong>：“在我的系统中，这个接口的实现是否有一个‘标准’或‘最常用’的版本？”<ul>
<li><strong>如果答案是肯定的</strong>，那么给那个实现加上 <code>@Primary</code>。这可以让80%的普通用例保持代码简洁，无需任何额外注解。</li>
<li><strong>如果答案是否定的</strong>，或者所有实现都同等重要，那么<strong>不要使用 <code>@Primary</code></strong>。强制每个消费者都使用 <code>@Qualifier</code> 来明确做出选择，这样可以避免错误的默认行为。</li>
</ul>
</li>
<li><strong>组合使用</strong>：将两者结合是最佳实践。<ul>
<li>为最常见的实现设置 <code>@Primary</code>。</li>
<li>对于那些需要特定非默认实现的特殊消费者，使用 <code>@Qualifier</code> 进行覆盖。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-5-Bean的生命周期与作用域"><a href="#1-5-Bean的生命周期与作用域" class="headerlink" title="1.5  Bean的生命周期与作用域"></a>1.5  Bean的生命周期与作用域</h3><h4 id="1-5-1-Bean的完整生命周期"><a href="#1-5-1-Bean的完整生命周期" class="headerlink" title="1.5.1 Bean的完整生命周期"></a>1.5.1 Bean的完整生命周期</h4><p>Bean的生命周期是指一个Bean从被Spring容器创建（实例化），到最终被销毁的整个过程。我们可以将其划分为四个主要阶段：<strong>实例化、属性填充、初始化、销毁</strong>。其中，“初始化”阶段本身又包含了一系列复杂的步骤。</p>
<h5 id="1-整体流程图（简化版）"><a href="#1-整体流程图（简化版）" class="headerlink" title="1. 整体流程图（简化版）"></a>1. 整体流程图（简化版）</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1. Spring容器启动，寻找Bean的定义信息(BeanDefinition)</span><br><span class="line">   ↓</span><br><span class="line">2. 【实例化】根据BeanDefinition，通过反射创建Bean的原始实例 (一个&quot;裸&quot;对象)</span><br><span class="line">   ↓</span><br><span class="line">3. 【属性填充】为Bean实例注入依赖 (DI)，如@Autowired标记的属性</span><br><span class="line">   ↓</span><br><span class="line">4. 【初始化】执行一系列回调，使Bean达到&quot;可用&quot;状态</span><br><span class="line">   ├── 4.1 执行Aware接口的方法 (如BeanNameAware, BeanFactoryAware)</span><br><span class="line">   ├── 4.2 执行BeanPostProcessor的前置处理方法 (postProcessBeforeInitialization)</span><br><span class="line">   ├── 4.3 执行Bean自身的初始化方法 (如@PostConstruct, afterPropertiesSet, init-method)</span><br><span class="line">   ├── 4.4 执行BeanPostProcessor的后置处理方法 (postProcessAfterInitialization)</span><br><span class="line">   ↓</span><br><span class="line">5. Bean处于&quot;可用&quot;状态，驻留在单例池中，响应应用程序的调用</span><br><span class="line">   ↓</span><br><span class="line">6. Spring容器关闭</span><br><span class="line">   ↓</span><br><span class="line">7. 【销毁】执行Bean的销毁回调方法 (如@PreDestroy, destroy, destroy-method)</span><br><span class="line">   ↓</span><br><span class="line">8. Bean被垃圾回收</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-详细步骤分解"><a href="#2-详细步骤分解" class="headerlink" title="2. 详细步骤分解"></a>2. 详细步骤分解</h5><p>下面我们用一个贯穿始终的例子 <code>MyBean</code> 来详细拆解每一步。</p>
<h6 id="阶段一：实例化-Instantiation"><a href="#阶段一：实例化-Instantiation" class="headerlink" title="阶段一：实例化 (Instantiation)"></a>阶段一：实例化 (Instantiation)</h6><ol>
<li><strong>容器查找BeanDefinition</strong>：Spring容器从配置源（如 <code>@Component</code> 扫描、<code>@Configuration</code> 类）中读取到<code>MyBean</code>的定义信息，即<code>BeanDefinition</code>。这就像是创建Bean的“蓝图”。</li>
<li><strong>创建实例</strong>：容器通过Java反射调用<code>MyBean</code>的构造函数，创建一个<strong>原始的对象实例</strong>。<ul>
<li><strong>此时</strong>：对象刚刚被创建，内存已经分配，但其所有依赖项（如被<code>@Autowired</code>标记的字段）都还是<code>null</code>。它只是一个“空的”外壳。</li>
</ul>
</li>
</ol>
<h6 id="阶段二：属性填充-Population"><a href="#阶段二：属性填充-Population" class="headerlink" title="阶段二：属性填充 (Population)"></a>阶段二：属性填充 (Population)</h6><ol>
<li><strong>依赖注入 (DI)</strong>：Spring容器检查<code>MyBean</code>中需要注入的依赖（通过<code>@Autowired</code>, <code>@Resource</code>等注解）。它会从容器中找到这些依赖的Bean，并通过反射（字段注入）或调用setter方法（Setter注入）将它们设置到<code>MyBean</code>的实例中。<ul>
<li><strong>此时</strong>：<code>MyBean</code>的依赖字段已经被赋值，但这个Bean可能还需要执行一些自定义的初始化逻辑后才能真正投入使用。</li>
</ul>
</li>
</ol>
<h6 id="阶段三：初始化-Initialization-这是最复杂也最重要的阶段"><a href="#阶段三：初始化-Initialization-这是最复杂也最重要的阶段" class="headerlink" title="阶段三：初始化 (Initialization) - 这是最复杂也最重要的阶段"></a>阶段三：初始化 (Initialization) - 这是最复杂也最重要的阶段</h6><p>这个阶段提供了一系列回调钩子，让你可以在Bean完全可用之前执行自定义逻辑。<strong>以下步骤严格按顺序执行</strong>。</p>
<ol>
<li><strong>调用Aware接口的方法</strong>：如果<code>MyBean</code>实现了特定的<code>Aware</code>接口，Spring会调用它们。这些接口的目的是让Bean能“感知”到并获取到容器自身的资源。<ul>
<li><code>BeanNameAware</code> -&gt; <code>setBeanName()</code>: Bean可以获取到它在容器中的ID&#x2F;name。</li>
<li><code>BeanClassLoaderAware</code> -&gt; <code>setBeanClassLoader()</code>: Bean可以获取到加载它的类加载器。</li>
<li><code>BeanFactoryAware</code> -&gt; <code>setBeanFactory()</code>: <strong>最强大的<code>Aware</code>接口</strong>，Bean可以获取到创建它的<code>BeanFactory</code>，从而能够以编程方式与容器交互。</li>
</ul>
</li>
<li><strong><code>BeanPostProcessor</code>前置处理</strong>：Spring会遍历容器中所有的<code>BeanPostProcessor</code>实现，并调用它们的 <code>postProcessBeforeInitialization()</code> 方法。<ul>
<li>这是一个<strong>全局的</strong>、<strong>容器级别</strong>的钩子。它允许你在<strong>任何Bean</strong>的自定义初始化方法执行<strong>之前</strong>，对这个Bean实例进行修改或包装。</li>
<li>例如，Spring的很多AOP功能和代理对象的创建就是在这个阶段附近完成的。</li>
</ul>
</li>
<li><strong>执行Bean自身的初始化方法</strong>：这是我们开发者最常用来编写自定义初始化逻辑的地方。Spring会按照以下顺序检查并执行：<ul>
<li><strong>① <code>@PostConstruct</code> 注解的方法</strong>：这是JSR-250规范定义的注解，是<strong>现代Spring应用中的首选</strong>，因为它与框架解耦。</li>
<li><strong>② <code>InitializingBean</code>接口的<code>afterPropertiesSet()</code>方法</strong>：这是Spring框架自己的接口。如果<code>MyBean</code>实现了这个接口，该方法会被调用。</li>
<li><strong>③ 自定义的<code>init-method</code></strong>：如果你在<code>@Bean(initMethod = &quot;customInit&quot;)</code>中指定了初始化方法，该方法会被调用。</li>
</ul>
</li>
<li><strong><code>BeanPostProcessor</code>后置处理</strong>：Spring再次遍历容器中所有的<code>BeanPostProcessor</code>，并调用它们的 <code>postProcessAfterInitialization()</code> 方法。<ul>
<li>这也是一个全局钩子。它允许你在Bean完成所有初始化之后，再次对其进行处理。</li>
<li><strong>Spring的AOP代理（例如为<code>@Transactional</code>方法创建代理）主要就是在这里完成的</strong>。<code>postProcessAfterInitialization</code>会返回一个Bean实例，这个返回的实例可能是原始Bean，也可能是一个被代理包装过的对象。<strong>最终放入单例池并供后续使用的是这个返回的对象</strong>。</li>
</ul>
</li>
</ol>
<h6 id="阶段四：Bean可用-In-Use"><a href="#阶段四：Bean可用-In-Use" class="headerlink" title="阶段四：Bean可用 (In Use)"></a>阶段四：Bean可用 (In Use)</h6><ol>
<li><strong>完成初始化</strong>：经过了上述所有初始化步骤后，Bean被认为是完全准备就绪的。</li>
<li><strong>放入单例池</strong>：Spring将这个最终处理完成的Bean实例放入单例缓存池（Singleton Cache）中。</li>
<li><strong>提供使用</strong>：当其他Bean需要注入这个<code>MyBean</code>时，Spring会直接从单例池中获取并提供给它们。Bean现在开始处理业务逻辑，进入其生命周期中最长的阶段。</li>
</ol>
<h6 id="阶段五：销毁-Destruction"><a href="#阶段五：销毁-Destruction" class="headerlink" title="阶段五：销毁 (Destruction)"></a>阶段五：销毁 (Destruction)</h6><p>这个阶段只在容器关闭时发生，并且<strong>只对<code>singleton</code>作用域的Bean有效</strong>。对于<code>prototype</code>作用域的Bean，容器创建后就不再管理其生命周期。</p>
<ol>
<li><strong>容器关闭</strong>：当<code>ApplicationContext</code>被关闭时（例如应用正常停止），Spring会触发Bean的销毁流程。</li>
<li><strong>执行Bean自身的销毁方法</strong>：与初始化类似，Spring会按照以下顺序检查并执行销毁回调：<ul>
<li><strong>① <code>@PreDestroy</code> 注解的方法</strong>：JSR-250规范，<strong>首选的销毁回调方式</strong>。</li>
<li><strong>② <code>DisposableBean</code>接口的<code>destroy()</code>方法</strong>：Spring框架自己的接口。</li>
<li><strong>③ 自定义的<code>destroy-method</code></strong>：在<code>@Bean(destroyMethod = &quot;customDestroy&quot;)</code>中指定的方法。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="3-综合代码示例"><a href="#3-综合代码示例" class="headerlink" title="3. 综合代码示例"></a>3. 综合代码示例</h5><p>创建一个Bean，它经历了生命周期中的所有关键点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifeCycleDemoBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LifeCycleDemoBean</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1. 【实例化】执行构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设这是需要注入的依赖</span></span><br><span class="line">    <span class="comment">// Spring会在这里进行【属性填充】</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postConstruct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3. 【初始化】执行 @PostConstruct 注解的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4. 【初始化】执行 InitializingBean 的 afterPropertiesSet 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customInitMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;5. 【初始化】执行自定义的 init-method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeanPostProcessor 的 before/after 方法会穿插在2和6之间</span></span><br><span class="line">    <span class="comment">// ... Bean is now in use ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;7. 【销毁】执行 @PreDestroy 注解的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;8. 【销毁】执行 DisposableBean 的 destroy 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customDestroyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;9. 【销毁】执行自定义的 destroy-method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>(为了演示<code>init-method</code>，你需要在<code>@Configuration</code>类中使用<code>@Bean</code>来定义它)</em></p>
<p><strong>总结与最佳实践：</strong></p>
<ul>
<li><strong>初始化</strong>：<strong>优先使用 <code>@PostConstruct</code></strong>。它代码侵入性小，是Java标准，更优雅。</li>
<li><strong>销毁</strong>：<strong>优先使用 <code>@PreDestroy</code></strong>。</li>
<li><strong>Aware接口</strong>：除非你真的需要与Spring容器底层进行交互，否则尽量避免使用，以保持业务代码的纯净。</li>
<li><strong><code>BeanPostProcessor</code></strong>：这是一个非常强大的高级工具，主要用于框架级别的开发，用来对一批Bean进行统一的增强处理，普通业务开发很少直接实现它。</li>
</ul>
<hr>
<h4 id="1-5-2-BeanPostProcessor-与-BeanFactoryPostProcessor"><a href="#1-5-2-BeanPostProcessor-与-BeanFactoryPostProcessor" class="headerlink" title="1.5.2 BeanPostProcessor 与 BeanFactoryPostProcessor"></a>1.5.2 <code>BeanPostProcessor</code> 与 <code>BeanFactoryPostProcessor</code></h4><h5 id="1-核心区别一览"><a href="#1-核心区别一览" class="headerlink" title="1. 核心区别一览"></a>1. 核心区别一览</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>BeanFactoryPostProcessor</code> (工厂后处理器)</th>
<th align="left"><code>BeanPostProcessor</code> (Bean后处理器)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>操作对象</strong></td>
<td align="left"><strong><code>BeanDefinition</code></strong> (Bean的定义&#x2F;蓝图)</td>
<td align="left"><strong>Bean 实例</strong> (已经<code>new</code>出来的对象)</td>
</tr>
<tr>
<td align="left"><strong>执行时机</strong></td>
<td align="left"><strong>非常早</strong>。在所有<code>BeanDefinition</code>加载完成之后，<strong>但在任何Bean实例化之前</strong>。</td>
<td align="left"><strong>较晚</strong>。在每个Bean<strong>实例化和依赖注入之后</strong>，但在其初始化方法前后。</td>
</tr>
<tr>
<td align="left"><strong>作用范围</strong></td>
<td align="left"><strong>容器级别</strong>。一次性对整个<code>BeanFactory</code>的配置元数据进行修改。</td>
<td align="left"><strong>Bean级别</strong>。对容器中<strong>每一个</strong>符合条件的Bean实例进行单独处理。</td>
</tr>
<tr>
<td align="left"><strong>核心目的</strong></td>
<td align="left">修改或增强Bean的<strong>定义信息</strong>。比如，修改Bean的作用域、替换Bean的类、添加属性等。</td>
<td align="left">修改或增强Bean的<strong>实例本身</strong>。比如，为Bean实例创建一个代理对象(AOP)、修改实例的属性值等。</td>
</tr>
<tr>
<td align="left"><strong>关键方法</strong></td>
<td align="left"><code>postProcessBeanFactory(ConfigurableListableBeanFactory factory)</code></td>
<td align="left"><code>postProcessBeforeInitialization(Object bean, String beanName)</code><br><code>postProcessAfterInitialization(Object bean, String beanName)</code></td>
</tr>
</tbody></table>
<hr>
<h5 id="2-analogy-汽车制造厂的比喻"><a href="#2-analogy-汽车制造厂的比喻" class="headerlink" title="2. analogy: 汽车制造厂的比喻"></a>2. analogy: 汽车制造厂的比喻</h5><p>为了更好地理解，我们把Spring容器比作一个汽车制造厂：</p>
<ul>
<li><strong><code>BeanDefinition</code></strong> 是 <strong>汽车的设计蓝图</strong>。它描述了汽车的型号、需要什么引擎、什么轮胎等。</li>
<li><strong><code>Bean</code> 实例</strong> 是 <strong>已经从流水线上生产出来的具体汽车</strong>。</li>
<li><strong><code>BeanFactoryPostProcessor</code></strong> 是 <strong>总设计师</strong>。在工厂开始生产任何汽车<strong>之前</strong>，他可以审查所有的设计蓝图，并说：“不行，所有‘标准版’型号的蓝图，都把引擎从V4改成V6！” 他修改的是<strong>蓝图</strong>。</li>
<li><strong><code>BeanPostProcessor</code></strong> 是 <strong>流水线上的质检&#x2F;改装工</strong>。每当一辆汽车<strong>生产出来之后</strong>，他都会对<strong>这辆车</strong>进行检查和处理。他可能会说：“这辆车需要加装一个尾翼”，或者“给这辆车喷上一层特殊的保护膜（创建代理）”。他处理的是<strong>具体的汽车实例</strong>。</li>
</ul>
<hr>
<h5 id="3-深入解析-BeanFactoryPostProcessor"><a href="#3-深入解析-BeanFactoryPostProcessor" class="headerlink" title="3. 深入解析 BeanFactoryPostProcessor"></a>3. 深入解析 <code>BeanFactoryPostProcessor</code></h5><h6 id="a-它是做什么的？"><a href="#a-它是做什么的？" class="headerlink" title="a). 它是做什么的？"></a>a). 它是做什么的？</h6><p>它允许你在Spring容器读取了所有的Bean定义信息（<code>BeanDefinition</code>）之后，但在容器根据这些定义去实例化任何Bean之前，对这些定义信息进行修改。</p>
<h6 id="b-它是怎么工作的？"><a href="#b-它是怎么工作的？" class="headerlink" title="b). 它是怎么工作的？"></a>b). 它是怎么工作的？</h6><ol>
<li>Spring容器启动，扫描并加载所有的配置（XML, <code>@Configuration</code>等）。</li>
<li>容器将这些配置信息解析成一个个的<code>BeanDefinition</code>对象，并把它们注册到一个<code>BeanDefinitionRegistry</code>中。</li>
<li>此时，容器会查找并执行所有实现了<code>BeanFactoryPostProcessor</code>接口的Bean。</li>
<li>在<code>postProcessBeanFactory</code>方法中，你可以通过传入的<code>ConfigurableListableBeanFactory</code>参数，获取到所有的<code>BeanDefinition</code>，然后对它们进行修改。</li>
</ol>
<h6 id="c-实际的Spring内部用例"><a href="#c-实际的Spring内部用例" class="headerlink" title="c). 实际的Spring内部用例"></a>c). 实际的Spring内部用例</h6><ul>
<li><strong>属性占位符替换</strong>：<code>PropertySourcesPlaceholderConfigurer</code>就是一个<code>BeanFactoryPostProcessor</code>。它的作用就是在Bean实例化之前，扫描所有<code>BeanDefinition</code>，找到像 <code>${db.url}</code> 这样的占位符，并用配置文件中的实际值去替换它们。</li>
<li><strong><code>@Configuration</code>类的处理</strong>：Spring通过一个内部的<code>ConfigurationClassPostProcessor</code>来处理<code>@Configuration</code>注解的类，解析其中的<code>@Bean</code>, <code>@ComponentScan</code>, <code>@Import</code>等注解，并注册更多的<code>BeanDefinition</code>到容器中。</li>
</ul>
<h6 id="d-自定义示例"><a href="#d-自定义示例" class="headerlink" title="d). 自定义示例"></a>d). 自定义示例</h6><p>假设你想把容器中所有<code>UserRepository</code>的Bean都强制改为<code>prototype</code>作用域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing BeanFactoryPostProcessor...&quot;</span>);</span><br><span class="line">        String[] beanNames = beanFactory.getBeanNamesForType(UserRepository.class);</span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">definition</span> <span class="operator">=</span> beanFactory.getBeanDefinition(beanName);</span><br><span class="line">            <span class="comment">// 修改Bean的定义信息：将作用域改为prototype</span></span><br><span class="line">            definition.setScope(BeanDefinition.SCOPE_PROTOTYPE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-深入解析-BeanPostProcessor"><a href="#4-深入解析-BeanPostProcessor" class="headerlink" title="4. 深入解析 BeanPostProcessor"></a>4. 深入解析 <code>BeanPostProcessor</code></h5><h6 id="a-它是做什么的？-1"><a href="#a-它是做什么的？-1" class="headerlink" title="a). 它是做什么的？"></a>a). 它是做什么的？</h6><p>它允许你在Spring容器实例化、配置和初始化一个Bean之后，以及在它的自定义初始化回调（如<code>@PostConstruct</code>）之前和之后，添加你自己的处理逻辑。</p>
<h6 id="b-它是怎么工作的？-1"><a href="#b-它是怎么工作的？-1" class="headerlink" title="b). 它是怎么工作的？"></a>b). 它是怎么工作的？</h6><p>对于容器中<strong>每一个</strong>正在被创建的Bean，它的初始化过程都会经过容器中<strong>所有</strong><code>BeanPostProcessor</code>的“加工”。</p>
<ul>
<li><code>postProcessBeforeInitialization</code>: 在Bean的<code>@PostConstruct</code>或<code>init-method</code>执行<strong>前</strong>调用。</li>
<li><code>postProcessAfterInitialization</code>: 在Bean的<code>@PostConstruct</code>或<code>init-method</code>执行<strong>后</strong>调用。<strong>这个方法返回的对象将是最终被使用的Bean实例</strong>，它可能是一个代理。</li>
</ul>
<h6 id="c-实际的Spring内部用例-1"><a href="#c-实际的Spring内部用例-1" class="headerlink" title="c). 实际的Spring内部用例"></a>c). 实际的Spring内部用例</h6><ul>
<li><strong>AOP代理创建</strong>：<code>AnnotationAwareAspectJAutoProxyCreator</code>就是一个关键的<code>BeanPostProcessor</code>。在<code>postProcessAfterInitialization</code>阶段，它会检查Bean的类或方法上是否有切面注解（如<code>@Transactional</code>）。如果有，它不会返回原始的Bean实例，而是返回一个围绕原始Bean创建的<strong>代理对象</strong>。这就是为什么AOP能够生效。</li>
<li><strong><code>@Autowired</code>等注解的处理</strong>：<code>AutowiredAnnotationBeanPostProcessor</code>负责处理<code>@Autowired</code>注解，完成属性填充。</li>
<li><strong><code>@PostConstruct</code>和<code>@PreDestroy</code>的处理</strong>：<code>CommonAnnotationBeanPostProcessor</code>负责识别和执行这两个注解标记的方法。</li>
</ul>
<h6 id="d-自定义示例-1"><a href="#d-自定义示例-1" class="headerlink" title="d). 自定义示例"></a>d). 自定义示例</h6><p>假设你想在每个Bean初始化后打印它的类名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 在初始化前不做任何事，直接返回原始bean</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; of type [&quot;</span> + bean.getClass().getName() + <span class="string">&quot;] has been initialized.&quot;</span>);</span><br><span class="line">        <span class="comment">// 在初始化后，返回处理过的bean（这里我们没处理，直接返回）</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h5><ul>
<li>如果你想干预<strong>Bean的创建过程</strong>，对<strong>Bean实例本身</strong>进行操作（例如创建代理），请使用 <code>BeanPostProcessor</code>。</li>
<li>如果你想干预<strong>Spring容器的启动过程</strong>，对<strong>Bean的配置元数据</strong>（即<code>BeanDefinition</code>）进行操作，请使用 <code>BeanFactoryPostProcessor</code>。</li>
</ul>
<p>在日常业务开发中，你几乎不会去实现这两个接口。它们是典型的“框架级”扩展点，主要用于Spring自身或第三方库的开发者，用来实现一些底层的、通用的功能。但理解它们，是真正掌握Spring IoC容器工作原理的钥匙。</p>
<hr>
<h4 id="1-5-3-初始化与销毁回调"><a href="#1-5-3-初始化与销毁回调" class="headerlink" title="1.5.3 初始化与销毁回调"></a>1.5.3 初始化与销毁回调</h4><h5 id="1-为什么需要这些回调？"><a href="#1-为什么需要这些回调？" class="headerlink" title="1. 为什么需要这些回调？"></a>1. 为什么需要这些回调？</h5><p>一个Bean在被创建并注入所有依赖后，往往还不能立即投入使用。它可能需要：</p>
<ul>
<li><strong>初始化资源</strong>：建立数据库连接、打开网络套接字、加载缓存数据。</li>
<li><strong>预处理数据</strong>：对某些配置属性进行计算或验证。</li>
<li><strong>启动后台任务</strong>：启动一个定时器或一个后台线程。</li>
</ul>
<p>同样，当应用程序关闭，Bean被销毁时，它需要一个机会来：</p>
<ul>
<li><strong>释放资源</strong>：关闭数据库连接、断开网络连接、将缓存数据写回磁盘。</li>
<li><strong>优雅地停止</strong>：通知后台线程停止工作，等待其完成。</li>
</ul>
<p>Spring提供了三种主要的方式来实现这些初始化和销毁逻辑。</p>
<hr>
<h5 id="2-初始化回调-Initialization-Callbacks"><a href="#2-初始化回调-Initialization-Callbacks" class="headerlink" title="2. 初始化回调 (Initialization Callbacks)"></a>2. 初始化回调 (Initialization Callbacks)</h5><p>初始化回调发生在Bean的<strong>实例化</strong>和<strong>属性填充</strong>完成之后。Spring确保在调用这些方法时，所有的依赖都已经注入完毕。</p>
<h6 id="a-使用-JSR-250-的-PostConstruct-注解-官方推荐"><a href="#a-使用-JSR-250-的-PostConstruct-注解-官方推荐" class="headerlink" title="a). 使用 JSR-250 的 @PostConstruct 注解 (官方推荐)"></a>a). 使用 JSR-250 的 <code>@PostConstruct</code> 注解 (官方推荐)</h6><ul>
<li><strong>来源</strong>：Java EE 的标准规范 (JSR-250)。</li>
<li><strong>方式</strong>：在一个无参数、返回值为 <code>void</code> 的 <code>public</code> 方法上添加此注解。</li>
<li><strong>优点</strong>：<ul>
<li><strong>标准规范</strong>：与Spring框架解耦，代码更具可移植性。</li>
<li><strong>非侵入式</strong>：不需要实现任何接口，代码更简洁。</li>
</ul>
</li>
<li><strong>缺点</strong>：无明显缺点，是现代Spring应用的首选。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConnector</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Database connection established.&quot;</span>);</span><br><span class="line">        <span class="comment">// 在这里执行连接数据库、加载初始数据等逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeQuery</span><span class="params">(String query)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing: &quot;</span> + query);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="b-实现-InitializingBean-接口"><a href="#b-实现-InitializingBean-接口" class="headerlink" title="b). 实现 InitializingBean 接口"></a>b). 实现 <code>InitializingBean</code> 接口</h6><ul>
<li><strong>来源</strong>：Spring框架自身的接口。</li>
<li><strong>方式</strong>：让Bean类实现 <code>InitializingBean</code> 接口，并重写 <code>afterPropertiesSet()</code> 方法。</li>
<li><strong>优点</strong>：意图非常明确，实现了接口就代表有初始化逻辑。</li>
<li><strong>缺点</strong>：<ul>
<li><strong>与Spring框架强耦合</strong>：你的业务代码中引入了Spring的API (<code>org.springframework.beans.factory.InitializingBean</code>)，降低了代码的可移植性。</li>
</ul>
</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheManager</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cache is being populated...&quot;</span>);</span><br><span class="line">        <span class="comment">// 在这里执行加载缓存的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="c-使用-Bean-的-initMethod-属性"><a href="#c-使用-Bean-的-initMethod-属性" class="headerlink" title="c). 使用 @Bean 的 initMethod 属性"></a>c). 使用 <code>@Bean</code> 的 <code>initMethod</code> 属性</h6><ul>
<li><strong>来源</strong>：源自XML配置时代的 <code>&lt;bean init-method=&quot;...&quot;&gt;</code>，现在适用于Java Config。</li>
<li><strong>方式</strong>：在 <code>@Configuration</code> 类的 <code>@Bean</code> 注解中，指定一个方法名作为初始化方法。</li>
<li><strong>优点</strong>：<ul>
<li><strong>对于第三方库的Bean非常有用</strong>：当你使用的类来自一个你无法修改源码的jar包时，这是唯一可以为其指定初始化逻辑的方式。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>初始化逻辑与Bean的定义分离，不够直观。</li>
<li>使用“魔术字符串”（方法名），没有编译时检查，容易写错。</li>
</ul>
</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设这是第三方库的类，我们无法修改它</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThirdPartyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Third party client is starting up.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;startup&quot;)</span> <span class="comment">// &lt;-- 指定初始化方法</span></span><br><span class="line">    <span class="keyword">public</span> ThirdPartyClient <span class="title function_">thirdPartyClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThirdPartyClient</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-销毁回调-Destruction-Callbacks"><a href="#3-销毁回调-Destruction-Callbacks" class="headerlink" title="3. 销毁回调 (Destruction Callbacks)"></a>3. 销毁回调 (Destruction Callbacks)</h5><p>销毁回调在Spring容器关闭时被触发。<strong>注意：这只对 <code>singleton</code> 作用域的Bean有效</strong>。对于<code>prototype</code>作用域的Bean，Spring创建后就不再负责其销毁。</p>
<h6 id="a-使用-JSR-250-的-PreDestroy-注解-官方推荐"><a href="#a-使用-JSR-250-的-PreDestroy-注解-官方推荐" class="headerlink" title="a). 使用 JSR-250 的 @PreDestroy 注解 (官方推荐)"></a>a). 使用 JSR-250 的 <code>@PreDestroy</code> 注解 (官方推荐)</h6><ul>
<li><strong>来源</strong>：Java EE 的标准规范 (JSR-250)。</li>
<li><strong>方式</strong>：在一个无参数、返回值为 <code>void</code> 的 <code>public</code> 方法上添加此注解。</li>
<li><strong>优点</strong>：与 <code>@PostConstruct</code> 一样，标准、解耦、简洁。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 续写上面的 DatabaseConnector</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConnector</span> &#123;</span><br><span class="line">    <span class="comment">// ... @PostConstruct ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">disconnect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Database connection is being closed.&quot;</span>);</span><br><span class="line">        <span class="comment">// 在这里执行关闭连接、释放资源的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="b-实现-DisposableBean-接口"><a href="#b-实现-DisposableBean-接口" class="headerlink" title="b). 实现 DisposableBean 接口"></a>b). 实现 <code>DisposableBean</code> 接口</h6><ul>
<li><strong>来源</strong>：Spring框架自身的接口。</li>
<li><strong>方式</strong>：让Bean类实现 <code>DisposableBean</code> 接口，并重写 <code>destroy()</code> 方法。</li>
<li><strong>缺点</strong>：与 <code>InitializingBean</code> 一样，会与Spring框架强耦合。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 续写上面的 CacheManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheManager</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, DisposableBean &#123;</span><br><span class="line">    <span class="comment">// ... afterPropertiesSet ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cache is being cleared and written to disk...&quot;</span>);</span><br><span class="line">        <span class="comment">// 在这里执行清理缓存、持久化数据的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="c-使用-Bean-的-destroyMethod-属性"><a href="#c-使用-Bean-的-destroyMethod-属性" class="headerlink" title="c). 使用 @Bean 的 destroyMethod 属性"></a>c). 使用 <code>@Bean</code> 的 <code>destroyMethod</code> 属性</h6><ul>
<li><strong>来源</strong>：XML配置时代的 <code>&lt;bean destroy-method=&quot;...&quot;&gt;</code>。</li>
<li><strong>方式</strong>：在 <code>@Bean</code> 注解中指定销毁方法名。</li>
<li><strong>优点</strong>：同样，是为无法修改源码的第三方Bean指定清理逻辑的最佳方式。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续写上面的 ThirdPartyClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThirdPartyClient</span> &#123;</span><br><span class="line">    <span class="comment">// ... startup ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Third party client is shutting down.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;startup&quot;, destroyMethod = &quot;shutdown&quot;)</span> <span class="comment">// &lt;-- 指定销毁方法</span></span><br><span class="line">    <span class="keyword">public</span> ThirdPartyClient <span class="title function_">thirdPartyClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThirdPartyClient</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>对于<code>close</code>或<code>shutdown</code>等常见方法名，Spring可以自动推断，甚至无需显式指定<code>destroyMethod</code>。</em></p>
<hr>
<h5 id="4-执行顺序"><a href="#4-执行顺序" class="headerlink" title="4. 执行顺序"></a>4. 执行顺序</h5><p>如果一个Bean同时使用了多种回调方式，Spring会按照固定的顺序执行它们：</p>
<ul>
<li><strong>初始化顺序</strong>:<ol>
<li><code>@PostConstruct</code> 注解的方法</li>
<li><code>InitializingBean</code> 的 <code>afterPropertiesSet()</code> 方法</li>
<li>自定义的 <code>init-method</code></li>
</ol>
</li>
<li><strong>销毁顺序</strong>:<ol>
<li><code>@PreDestroy</code> 注解的方法</li>
<li><code>DisposableBean</code> 的 <code>destroy()</code> 方法</li>
<li>自定义的 <code>destroy-method</code></li>
</ol>
</li>
</ul>
<hr>
<h5 id="5-总结与最佳实践"><a href="#5-总结与最佳实践" class="headerlink" title="5. 总结与最佳实践"></a>5. 总结与最佳实践</h5><table>
<thead>
<tr>
<th align="left">回调类型</th>
<th align="left">方式</th>
<th align="left">推荐度</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>初始化</strong></td>
<td align="left"><strong><code>@PostConstruct</code></strong></td>
<td align="left">⭐⭐⭐⭐⭐ <strong>(首选)</strong></td>
<td align="left">所有自定义Bean的初始化逻辑。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>InitializingBean</code></td>
<td align="left">⭐⭐</td>
<td align="left">遗留代码或特定框架集成。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>initMethod</code></td>
<td align="left">⭐⭐⭐</td>
<td align="left"><strong>为无法修改源码的第三方Bean配置初始化</strong>。</td>
</tr>
<tr>
<td align="left"><strong>销毁</strong></td>
<td align="left"><strong><code>@PreDestroy</code></strong></td>
<td align="left">⭐⭐⭐⭐⭐ <strong>(首选)</strong></td>
<td align="left">所有自定义Bean的销毁逻辑。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>DisposableBean</code></td>
<td align="left">⭐⭐</td>
<td align="left">遗留代码。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>destroyMethod</code></td>
<td align="left">⭐⭐⭐</td>
<td align="left"><strong>为无法修改源码的第三方Bean配置销毁</strong>。</td>
</tr>
</tbody></table>
<p><strong>核心建议</strong>：在日常开发中，<strong>始终坚持使用 <code>@PostConstruct</code> 和 <code>@PreDestroy</code></strong>。它们是现代、标准、非侵入式的方式，能让你的代码更干净、更专业。只有在需要管理第三方库中对象的生命周期时，才去使用 <code>@Bean</code> 的 <code>initMethod</code> 和 <code>destroyMethod</code> 属性。</p>
<hr>
<h4 id="1-5-4-Bean的作用域"><a href="#1-5-4-Bean的作用域" class="headerlink" title="1.5.4 Bean的作用域"></a>1.5.4 Bean的作用域</h4><h5 id="1-什么是Bean的作用域？"><a href="#1-什么是Bean的作用域？" class="headerlink" title="1. 什么是Bean的作用域？"></a>1. 什么是Bean的作用域？</h5><p>Bean的作用域定义了<strong>从一个Bean定义（Bean Definition）创建多少个实例</strong>，以及这些<strong>实例的生命周期和可见范围</strong>。</p>
<p>在SpringBoot中，可以使用 <code>@Scope</code> 注解来为一个Bean指定其作用域。</p>
<hr>
<h5 id="2-Spring的核心作用域"><a href="#2-Spring的核心作用域" class="headerlink" title="2. Spring的核心作用域"></a>2. Spring的核心作用域</h5><h6 id="a-singleton-单例-默认作用域"><a href="#a-singleton-单例-默认作用域" class="headerlink" title="a). singleton (单例) - 默认作用域"></a>a). <code>singleton</code> (单例) - 默认作用域</h6><ul>
<li><p><strong>定义</strong>：在整个Spring IoC容器中，一个Bean定义<strong>只对应一个实例</strong>。</p>
</li>
<li><p><strong>行为</strong>：</p>
<ul>
<li>容器启动时，就会创建该Bean的实例（非懒加载情况下）。</li>
<li>这个唯一的实例会被存储在一个缓存中（单例池）。</li>
<li>之后任何对该Bean的请求或注入，都会返回这个<strong>共享的、唯一的实例</strong>。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：绝大多数无状态的Bean。例如 <code>Service</code> 层对象、<code>Repository</code> 层对象、<code>Controller</code>、配置类等。这些对象不保存与特定请求或用户相关的状态，只提供方法和功能。</p>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="comment">// @Scope(&quot;singleton&quot;) // 这是默认值，所以通常不需要显式声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingletonService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MySingletonService</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MySingletonService instance created!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论你在多少个地方注入<code>MySingletonService</code>，它的构造函数在整个应用生命周期中只会被调用一次。</p>
</li>
</ul>
<h6 id="b-prototype-原型-多例"><a href="#b-prototype-原型-多例" class="headerlink" title="b). prototype (原型&#x2F;多例)"></a>b). <code>prototype</code> (原型&#x2F;多例)</h6><ul>
<li><p><strong>定义</strong>：每次对该Bean进行请求（注入或通过<code>getBean()</code>方法获取）时，都会<strong>创建一个全新的实例</strong>。</p>
</li>
<li><p><strong>行为</strong>：</p>
<ul>
<li>Spring容器负责创建、配置和初始化一个新的<code>prototype</code> Bean实例。</li>
<li>但是，一旦将实例交给客户端代码后，<strong>Spring就不再管理该实例的完整生命周期了</strong>。Spring不会为<code>prototype</code> Bean调用其销毁回调方法（如<code>@PreDestroy</code>）。客户端代码需要自己负责清理<code>prototype</code> Bean所持有的昂贵资源。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：需要保存状态的Bean。例如，一个记录多步骤操作向导的当前状态的对象，或者一个用于构建复杂对象的Builder。每个用户或每个线程都需要一个独立的状态对象，不能共享。</p>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserActionTracker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; actions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserActionTracker</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;New UserActionTracker instance created: &quot;</span> + <span class="built_in">this</span>.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAction</span><span class="params">(String action)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.actions.add(action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次注入<code>UserActionTracker</code>，你都会得到一个全新的、拥有自己<code>actions</code>列表的对象。</p>
</li>
</ul>
<hr>
<h5 id="3-Web应用中的额外作用域"><a href="#3-Web应用中的额外作用域" class="headerlink" title="3. Web应用中的额外作用域"></a>3. Web应用中的额外作用域</h5><p>在Web环境中（即当你的<code>ApplicationContext</code>是<code>WebApplicationContext</code>时），Spring提供了几个额外的作用域，它们的生命周期与Web请求紧密相关。</p>
<h6 id="a-request"><a href="#a-request" class="headerlink" title="a). request"></a>a). <code>request</code></h6><ul>
<li><strong>定义</strong>：对于<strong>每一次HTTP请求</strong>，都会创建一个全新的Bean实例。</li>
<li><strong>生命周期</strong>：Bean实例的生命周期从HTTP请求开始到该请求结束（响应发送回客户端）为止。</li>
<li><strong>适用场景</strong>：存放与单次请求相关的信息。例如，将请求参数封装成一个对象、存放用户的IP地址、为当前请求建立的数据库连接等。</li>
</ul>
<h6 id="b-session"><a href="#b-session" class="headerlink" title="b). session"></a>b). <code>session</code></h6><ul>
<li><strong>定义</strong>：对于<strong>每一个HTTP Session</strong>，会创建一个全新的Bean实例。</li>
<li><strong>生命周期</strong>：Bean实例的生命周期与用户的Session相同。只要Session不失效，该实例就一直存在。</li>
<li><strong>适用场景</strong>：存放与特定用户会话相关的信息。最经典的例子就是<strong>购物车</strong>、用户的<strong>登录状态</strong>信息。</li>
</ul>
<h6 id="c-application"><a href="#c-application" class="headerlink" title="c). application"></a>c). <code>application</code></h6><ul>
<li><strong>定义</strong>：对于整个Web应用（<code>ServletContext</code>），只创建一个Bean实例。</li>
<li><strong>生命周期</strong>：从<code>ServletContext</code>被创建（应用启动）到它被销毁（应用关闭）。</li>
<li><strong>适用场景</strong>：存放应用级别的全局共享数据。例如，网站访问量计数器、应用范围内的缓存、共享的配置信息。它的行为非常类似<code>singleton</code>，但它的生命周期是绑定到<code>ServletContext</code>的。</li>
</ul>
<h6 id="d-websocket-较新"><a href="#d-websocket-较新" class="headerlink" title="d). websocket (较新)"></a>d). <code>websocket</code> (较新)</h6><ul>
<li><strong>定义</strong>：对于每一个WebSocket会话，创建一个Bean实例。</li>
</ul>
<hr>
<h5 id="4-作用域代理-Scoped-Proxies-解决注入难题"><a href="#4-作用域代理-Scoped-Proxies-解决注入难题" class="headerlink" title="4. 作用域代理 (Scoped Proxies) - 解决注入难题"></a>4. 作用域代理 (Scoped Proxies) - 解决注入难题</h5><p><strong>问题</strong>：如果一个<code>singleton</code> Bean（在应用启动时创建）需要注入一个<code>request</code>作用域的Bean（在每次请求时创建），会发生什么？</p>
<p>Spring在启动时为<code>singleton</code> Bean注入依赖时，<code>request</code>作用域的Bean还不存在！</p>
<p><strong>解决方案</strong>：使用<strong>作用域代理</strong>。</p>
<p>当你为一个短生命周期的Bean（如<code>request</code>, <code>session</code>）声明作用域代理时，Spring注入到长生命周期Bean（如<code>singleton</code>）中的不再是这个Bean的实例本身，而是一个<strong>代理对象</strong>。</p>
<ul>
<li><strong>工作原理</strong>：<ol>
<li><code>singleton</code> Bean持有的是这个<strong>代理</strong>。</li>
<li>当<code>singleton</code> Bean的方法调用这个代理的方法时，代理会“聪明地”从当前作用域（例如，当前的HTTP请求）中查找<strong>真正的Bean实例</strong>。</li>
<li>然后，代理将方法调用<strong>委托</strong>给这个真正的实例。</li>
</ol>
</li>
</ul>
<p>这样就完美地解决了生命周期不匹配的问题。</p>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个Request作用域的Bean，用于存储当前登录用户的信息</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(value = &quot;request&quot;, proxyMode = ScopedProxyMode.TARGET_CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentUser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// getters and setters...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个Singleton作用域的Service，它需要获取当前用户</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入的实际上是一个代理对象，而不是真正的CurrentUser实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CurrentUser currentUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(CurrentUser currentUser)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentUser = currentUser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 当调用此方法时，代理会找到当前HTTP请求对应的CurrentUser实例</span></span><br><span class="line">        <span class="comment">// 并从中获取用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> currentUser.getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating order for user: &quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>proxyMode = ScopedProxyMode.TARGET_CLASS</code> 告诉Spring使用CGLIB创建一个基于类的代理。这是SpringBoot中的常见用法。</li>
</ul>
<hr>
<h5 id="5-总结-1"><a href="#5-总结-1" class="headerlink" title="5. 总结"></a>5. 总结</h5><table>
<thead>
<tr>
<th align="left">作用域</th>
<th align="left">描述</th>
<th align="left">实例数量</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>singleton</code></strong></td>
<td align="left">(默认) 每个容器一个实例</td>
<td align="left"><strong>1</strong></td>
<td align="left">无状态的Service, Repository, Controller</td>
</tr>
<tr>
<td align="left"><strong><code>prototype</code></strong></td>
<td align="left">每次请求创建一个新实例</td>
<td align="left"><strong>N</strong></td>
<td align="left">有状态的对象，如Builder模式</td>
</tr>
<tr>
<td align="left"><strong><code>request</code></strong></td>
<td align="left">每次HTTP请求一个实例</td>
<td align="left">每个请求1个</td>
<td align="left">请求级别的数据，如请求参数对象</td>
</tr>
<tr>
<td align="left"><strong><code>session</code></strong></td>
<td align="left">每个用户会话一个实例</td>
<td align="left">每个Session 1个</td>
<td align="left">用户级别的数据，如购物车、登录信息</td>
</tr>
<tr>
<td align="left"><strong><code>application</code></strong></td>
<td align="left">每个Web应用一个实例</td>
<td align="left"><strong>1</strong> (Web范围)</td>
<td align="left">应用级别的全局数据，如网站计数器</td>
</tr>
</tbody></table>
<hr>
<h4 id="1-5-5-循环依赖"><a href="#1-5-5-循环依赖" class="headerlink" title="1.5.5 循环依赖"></a>1.5.5 循环依赖</h4><h5 id="1-什么是循环依赖？"><a href="#1-什么是循环依赖？" class="headerlink" title="1. 什么是循环依赖？"></a>1. 什么是循环依赖？</h5><p>循环依赖，也叫循环引用，指的是两个或多个Bean之间相互持有对方的引用，形成一个闭环。最简单的形式是：</p>
<ul>
<li><strong>A 依赖 B，同时 B 又依赖 A。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceB serviceB;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceA</span><span class="params">(ServiceB serviceB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serviceB = serviceB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceB</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceA serviceA;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceB</span><span class="params">(ServiceA serviceA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serviceA = serviceA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Spring试图创建<code>ServiceA</code>时，它发现需要<code>ServiceB</code>。于是它暂停创建<code>ServiceA</code>，转而去创建<code>ServiceB</code>。在创建<code>ServiceB</code>时，它又发现需要<code>ServiceA</code>。此时，<code>ServiceA</code>还没有创建完成，这就形成了一个无法解决的死锁，就像一个“先有鸡还是先有蛋”的问题。</p>
<hr>
<h5 id="2-Spring是如何解决的？-仅限Setter-字段注入"><a href="#2-Spring是如何解决的？-仅限Setter-字段注入" class="headerlink" title="2. Spring是如何解决的？(仅限Setter&#x2F;字段注入)"></a>2. Spring是如何解决的？(仅限Setter&#x2F;字段注入)</h5><p>Spring设计了一套非常巧妙的机制来解决<strong>单例（singleton）作用域</strong>下，通过<strong>Setter或字段注入</strong>产生的循环依赖。这个机制的核心是<strong>三级缓存</strong>。</p>
<p>让我们把Bean的创建过程想象成盖房子：</p>
<ul>
<li><strong>一级缓存 (<code>singletonObjects</code>)</strong>: <strong>成品房仓库</strong>。存放已经完全创建好、可以随时入住的房子（Bean实例）。<code>Map&lt;String, Object&gt;</code></li>
<li><strong>二级缓存 (<code>earlySingletonObjects</code>)</strong>: <strong>半成品房仓库</strong>。存放刚刚建好框架、但还没装修的房子（已经实例化但未填充属性的Bean）。关键在于，你已经可以拿到这栋房子的<strong>地址</strong>（早期引用）了。<code>Map&lt;String, Object&gt;</code></li>
<li><strong>三级缓存 (<code>singletonFactories</code>)</strong>: <strong>房屋设计图&#x2F;施工队仓库</strong>。存放能建造半成品房的“工厂对象”（<code>ObjectFactory</code>）。当你需要一栋房子的地址时，施工队会告诉你：“虽然房子没盖完，但我可以先给你一个地址的‘期房合同’（早期引用）”。<code>Map&lt;String, ObjectFactory&lt;?&gt;&gt;</code></li>
</ul>
<p><strong>解决流程（A依赖B，B依赖A）</strong></p>
<ol>
<li><strong>创建A</strong>:<ul>
<li><code>getBean(&quot;a&quot;)</code>被调用。</li>
<li>Spring检查一级缓存，没有A。</li>
<li>Spring开始创建A。首先，通过构造函数<strong>实例化</strong>A，得到一个“裸”对象<code>a_instance</code>。</li>
<li><strong>关键一步</strong>：Spring不会立即填充A的属性。而是创建一个能获取<code>a_instance</code>的工厂（<code>ObjectFactory</code>），并将其放入<strong>三级缓存</strong>中：<code>singletonFactories.put(&quot;a&quot;, aFactory)</code>。</li>
</ul>
</li>
<li><strong>填充A的属性</strong>:<ul>
<li>Spring开始为<code>a_instance</code>注入依赖。它发现A需要B（<code>private ServiceB serviceB;</code>）。</li>
</ul>
</li>
<li><strong>创建B</strong>:<ul>
<li>Spring暂停A的创建，转而去<code>getBean(&quot;b&quot;)</code>。</li>
<li>和A一样，Spring实例化B，得到<code>b_instance</code>，然后将B的工厂放入<strong>三级缓存</strong>：<code>singletonFactories.put(&quot;b&quot;, bFactory)</code>。</li>
</ul>
</li>
<li><strong>填充B的属性</strong>:<ul>
<li>Spring为<code>b_instance</code>注入依赖。它发现B需要A。</li>
</ul>
</li>
<li><strong>解决循环的关键点</strong>:<ul>
<li>Spring暂停B的创建，转而去<code>getBean(&quot;a&quot;)</code>。</li>
<li>Spring再次检查缓存：<ul>
<li>一级缓存 (<code>singletonObjects</code>): 没有A。</li>
<li>二级缓存 (<code>earlySingletonObjects</code>): 也没有A。</li>
<li><strong>三级缓存 (<code>singletonFactories</code>): 找到了A的工厂 <code>aFactory</code>！</strong></li>
</ul>
</li>
<li>Spring立刻执行这个<code>aFactory</code>，得到一个A的<strong>早期引用</strong>（Early Reference），也就是那个刚实例化但还没装修的<code>a_instance</code>。</li>
<li>为了防止重复创建，Spring将这个早期引用放入<strong>二级缓存</strong> <code>earlySingletonObjects.put(&quot;a&quot;, early_a_ref)</code>，并从三级缓存中移除A的工厂。</li>
<li>这个A的早期引用被返回并注入到B的<code>serviceA</code>字段中。</li>
</ul>
</li>
<li><strong>完成B的创建</strong>:<ul>
<li>B成功获取了A的引用（虽然是早期的），B的属性填充完成。</li>
<li>B执行初始化方法，成为一个完整的Bean。</li>
<li>完整的B被放入<strong>一级缓存</strong> <code>singletonObjects.put(&quot;b&quot;, b_instance)</code>。</li>
</ul>
</li>
<li><strong>完成A的创建</strong>:<ul>
<li>执行流程回到第2步，<code>getBean(&quot;b&quot;)</code>现在可以直接从一级缓存中拿到完整的B实例。</li>
<li>完整的B被注入到A的<code>serviceB</code>字段中。</li>
<li>A的属性填充完成，执行初始化，成为一个完整的Bean。</li>
<li>完整的A被放入<strong>一级缓存</strong> <code>singletonObjects.put(&quot;a&quot;, a_instance)</code>。</li>
</ul>
</li>
</ol>
<p>至此，循环依赖被完美解决。两个Bean都持有了对方的完整实例。</p>
<hr>
<h5 id="3-为什么需要三级缓存而不是二级？"><a href="#3-为什么需要三级缓存而不是二级？" class="headerlink" title="3. 为什么需要三级缓存而不是二级？"></a>3. 为什么需要三级缓存而不是二级？</h5><p>“既然二级缓存就能存放早期引用，为什么还需要三级缓存？”</p>
<p>答案是：<strong>为了支持AOP代理</strong>。</p>
<p>如果Bean A需要被AOP代理，那么注入到B中的不能是原始的A实例，而应该是A的代理对象。创建代理对象的时机通常是在Bean初始化完成之后（通过<code>BeanPostProcessor</code>）。</p>
<p>但是，在循环依赖的场景下，B需要提前引用A，此时A还没有完成初始化。三级缓存的<code>ObjectFactory</code>就解决了这个问题：<code>aFactory</code>被执行时，它可以检查A是否需要被代理，如果需要，就返回代理对象；如果不需要，就返回原始对象。这样，无论是否需要代理，B都能拿到正确的引用。二级缓存只存放结果，而三级缓存存放的是“可以创建结果的工厂”，这提供了更高的灵活性。</p>
<hr>
<h5 id="4-Spring无法解决的循环依赖"><a href="#4-Spring无法解决的循环依赖" class="headerlink" title="4. Spring无法解决的循环依赖"></a>4. Spring无法解决的循环依赖</h5><ol>
<li><strong>构造器注入的循环依赖</strong><ul>
<li>构造器注入要求在<code>new</code>一个对象时，其所有依赖项必须是已完成的实例。这形成了一个无法打破的死锁。Spring无法通过“提前暴露引用”来解决，所以它会直接在启动时抛出<code>BeanCurrentlyInCreationException</code>。</li>
<li><strong>这也是官方推荐使用构造器注入的另一个原因</strong>：它能迫使你在编码阶段就发现并解决不良的循环依赖设计。</li>
</ul>
</li>
<li><strong><code>prototype</code>作用域的循环依赖</strong><ul>
<li>因为<code>prototype</code> Bean每次请求都会创建一个新的实例，Spring不会对它们进行缓存。没有了缓存机制，自然也就无法通过三级缓存来解决循环依赖。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="5-最佳实践：避免循环依赖"><a href="#5-最佳实践：避免循环依赖" class="headerlink" title="5. 最佳实践：避免循环依赖"></a>5. 最佳实践：避免循环依赖</h5><p>虽然Spring能够解决部分循环依赖，但在软件设计中，<strong>循环依赖通常被认为是一种“坏味道”（Bad Smell）</strong>，它暗示着类的职责划分可能不清晰，耦合度过高。</p>
<p><strong>如何解决？</strong></p>
<ol>
<li><p><strong>重构代码</strong>：这是最好的方法。</p>
<ul>
<li><strong>提取新类</strong>：找出A和B共同依赖的逻辑或数据，将其提取到一个新的类C中。然后让A和B都依赖C，从而打破A和B之间的直接循环。</li>
<li><strong>重新分配职责</strong>：重新审视A和B的职责，可能B的某个功能实际上属于A，或者反之。调整后，依赖关系可能就变成单向的了。</li>
</ul>
</li>
<li><p><strong>使用 <code>@Lazy</code> 注解</strong> (作为最后的手段)</p>
<ul>
<li>可以在其中一个注入点（构造器参数或字段）上添加 <code>@Lazy</code> 注解。</li>
<li>这会告诉Spring：“不要立即注入这个Bean，而是注入一个它的代理。等到我第一次真正调用这个Bean的方法时，再去容器里查找并加载它。”</li>
<li>这推迟了其中一个Bean的加载，从而在启动时打破了循环。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceB serviceB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在B的注入点使用@Lazy</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceA</span><span class="params">(<span class="meta">@Lazy</span> ServiceB serviceB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serviceB = serviceB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>总结：</strong> 了解Spring如何处理循环依赖，有助于你深入理解其IoC容器的底层原理。但在实际开发中，你的首要目标应该是<strong>通过优秀的设计来避免循环依赖的产生</strong>。</p>
<hr>
<h2 id="2-面向切面编程"><a href="#2-面向切面编程" class="headerlink" title="2. 面向切面编程"></a>2. 面向切面编程</h2><h3 id="2-1-AOP核心概念"><a href="#2-1-AOP核心概念" class="headerlink" title="2.1 AOP核心概念"></a>2.1 AOP核心概念</h3><h4 id="2-1-1-为什么需要AOP？（The-“Why”）"><a href="#2-1-1-为什么需要AOP？（The-“Why”）" class="headerlink" title="2.1.1 为什么需要AOP？（The “Why”）"></a>2.1.1 为什么需要AOP？（The “Why”）</h4><p>想象一下，我们有很多业务方法，比如<code>createUser()</code>, <code>updateOrder()</code>, <code>deleteProduct()</code>。现在，我们需要为这些方法统一添加一些功能，比如：</p>
<ul>
<li><strong>日志记录</strong>：在方法开始和结束时打印日志。</li>
<li><strong>事务管理</strong>：在方法开始时开启事务，结束时提交或回滚。</li>
<li><strong>权限校验</strong>：在方法执行前检查当前用户是否有权限。</li>
<li><strong>性能监控</strong>：记录每个方法的执行时间。</li>
</ul>
<p><strong>如果没有AOP，我们可能会这样做：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 权限校验</span></span><br><span class="line">        checkPermission(<span class="string">&quot;CREATE_USER&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 开启事务</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> transactionManager.begin();</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 核心业务逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Executing core logic: creating user &quot;</span> + user.getName());</span><br><span class="line">            userRepository.save(user);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 提交事务</span></span><br><span class="line">            tx.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 5. 回滚事务</span></span><br><span class="line">            tx.rollback();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 记录日志和性能</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">            System.out.println(<span class="string">&quot;Method createUser executed in &quot;</span> + duration + <span class="string">&quot;ms.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... updateOrder() 和 deleteProduct() 方法中也要重复1-6步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题显而易见：</strong></p>
<ul>
<li><strong>代码重复</strong>：日志、事务、权限代码在每个业务方法中都重复出现。</li>
<li><strong>业务逻辑混杂</strong>：核心的业务逻辑（<code>userRepository.save(user)</code>）被大量非业务的“样板代码”所包围，难以阅读和维护。</li>
</ul>
<p><strong>AOP的目标</strong>：就是将这些分散在各处的、与核心业务无关但又必不可少的通用功能（我们称之为<strong>横切关注点</strong>），从业务代码中<strong>抽离</strong>出来，形成独立的模块（<strong>切面</strong>），然后以一种非侵入的方式，在需要的时候动态地“织入”到业务代码中。</p>
<hr>
<h4 id="2-1-2-AOP的核心术语（The-“What”-and-“How”）"><a href="#2-1-2-AOP的核心术语（The-“What”-and-“How”）" class="headerlink" title="2.1.2 AOP的核心术语（The “What” and “How”）"></a>2.1.2 AOP的核心术语（The “What” and “How”）</h4><p>为了实现上述目标，AOP定义了一套专门的术语。理解这些术语是掌握AOP的关键。</p>
<p>让我们用一个<strong>剧院表演</strong>的类比来理解：</p>
<ul>
<li><strong>剧本 (核心业务)</strong>：演员按照剧本表演，这是核心内容。</li>
<li><strong>灯光&#x2F;音效 (横切关注点)</strong>：灯光师和音效师的工作（打光、播放背景音乐）会穿插在整个表演中，但它不是剧本的核心。</li>
</ul>
<hr>
<h5 id="1-Aspect-切面"><a href="#1-Aspect-切面" class="headerlink" title="1. Aspect (切面)"></a>1. Aspect (切面)</h5><ul>
<li><strong>定义</strong>：一个封装了<strong>横切关注点</strong>的模块。它告诉程序<strong>做什么</strong>（通知）以及<strong>在哪里做</strong>（切点）。</li>
<li><strong>类比</strong>：<strong>灯光&#x2F;音效团队</strong>。这个团队负责所有与灯光和音效相关的工作。</li>
<li><strong>在Spring中</strong>：一个带有 <code>@Aspect</code> 注解的Java类。</li>
</ul>
<hr>
<h5 id="2-Join-Point-连接点"><a href="#2-Join-Point-连接点" class="headerlink" title="2. Join Point (连接点)"></a>2. Join Point (连接点)</h5><ul>
<li><strong>定义</strong>：程序执行过程中的一个<strong>特定时机点</strong>，可以被切面织入。</li>
<li><strong>类比</strong>：剧本中的<strong>每一句台词、每一个动作</strong>。这些都是灯光师可以决定“打光”的潜在时机。</li>
<li><strong>在Spring中</strong>：<strong>只能是方法的执行</strong>。例如，<code>OrderService.createOrder()</code> 方法的执行就是一个连接点。</li>
</ul>
<hr>
<h5 id="3-Pointcut-切点"><a href="#3-Pointcut-切点" class="headerlink" title="3. Pointcut (切点)"></a>3. Pointcut (切点)</h5><ul>
<li><strong>定义</strong>：一个<strong>表达式</strong>，用于<strong>筛选</strong>出一批符合条件的连接点。切面只会对这些被选中的连接点起作用。</li>
<li><strong>类比</strong>：灯光师的<strong>指令</strong>：“在<strong>第二幕</strong>中，<strong>主角说的所有台词</strong>处，都要打上追光灯。” 这条指令精确地筛选出了需要打光的时机点。</li>
<li><strong>在Spring中</strong>：一个使用特定语法（如 <code>execution(* com.example.service.*.*(..))</code>）定义的表达式，通常与 <code>@Pointcut</code> 注解关联。</li>
</ul>
<hr>
<h5 id="4-Advice-通知"><a href="#4-Advice-通知" class="headerlink" title="4. Advice (通知)"></a>4. Advice (通知)</h5><ul>
<li><strong>定义</strong>：切面在特定的切点上要<strong>执行的具体动作</strong>。</li>
<li><strong>类比</strong>：灯光师的具体操作，比如“<strong>打开追光灯</strong>”、“<strong>将灯光调暗</strong>”。</li>
<li><strong>在Spring中</strong>：切面类中带有特殊注解的方法。共有5种类型的通知：<ol>
<li><strong><code>@Before</code> (前置通知)</strong>：在连接点（目标方法）执行<strong>之前</strong>执行。</li>
<li><strong><code>@AfterReturning</code> (后置通知)</strong>：在连接点<strong>正常执行完毕</strong>（没有抛出异常）后执行。</li>
<li><strong><code>@AfterThrowing</code> (异常通知)</strong>：在连接点执行过程中<strong>抛出异常</strong>后执行。</li>
<li><strong><code>@After</code> (最终通知)</strong>：<strong>无论</strong>连接点是正常结束还是异常退出，<strong>都会</strong>执行（类似于<code>finally</code>块）。</li>
<li><strong><code>@Around</code> (环绕通知)</strong>：<strong>最强大</strong>的通知。它完全包裹了连接点，可以在连接点执行<strong>前后</strong>都进行操作，甚至可以决定是否执行连接点。</li>
</ol>
</li>
</ul>
<hr>
<h5 id="5-Target-Object-目标对象"><a href="#5-Target-Object-目标对象" class="headerlink" title="5. Target Object (目标对象)"></a>5. Target Object (目标对象)</h5><ul>
<li><strong>定义</strong>：被一个或多个切面“通知”的对象。也就是包含我们核心业务逻辑的那个对象。</li>
<li><strong>类比</strong>：正在舞台上表演的<strong>演员</strong>。</li>
<li><strong>在Spring中</strong>：原始的业务Bean，例如<code>UserServiceImpl</code>的实例。</li>
</ul>
<hr>
<h5 id="6-Proxy-代理"><a href="#6-Proxy-代理" class="headerlink" title="6. Proxy (代理)"></a>6. Proxy (代理)</h5><ul>
<li><strong>定义</strong>：Spring AOP的实现机制。Spring不会直接修改你的业务代码，而是在运行时创建一个<strong>代理对象</strong>。这个代理对象包含了原始目标对象的所有方法，并在方法的特定位置（由切点决定）嵌入了通知的逻辑。</li>
<li><strong>类比</strong>：演员的<strong>替身</strong>。观众（客户端代码）看到的和互动的其实是这个替身，替身在表演核心动作（调用原始演员的方法）前后，会自己加上一些额外的动作（执行通知）。</li>
<li><strong>在Spring中</strong>：默认使用CGLIB（针对类）或JDK动态代理（针对接口）来创建。</li>
</ul>
<hr>
<h5 id="7-Weaving-织入"><a href="#7-Weaving-织入" class="headerlink" title="7. Weaving (织入)"></a>7. Weaving (织入)</h5><ul>
<li><strong>定义</strong>：将切面应用到目标对象，从而创建出代理对象的这个<strong>过程</strong>。</li>
<li><strong>类比</strong>：在表演开始前，导演告诉灯光师和演员如何配合的整个<strong>彩排和准备过程</strong>。</li>
<li><strong>在Spring中</strong>：织入发生在<strong>运行时</strong>，当Spring容器为目标Bean创建代理实例的时候。</li>
</ul>
<hr>
<h4 id="2-1-3-总结与关系图"><a href="#2-1-3-总结与关系图" class="headerlink" title="2.1.3 总结与关系图"></a>2.1.3 总结与关系图</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">                  +-----------------+</span><br><span class="line">                  |     Aspect      | (切面: 灯光团队)</span><br><span class="line">                  |    @Aspect      |</span><br><span class="line">                  +-------+---------+</span><br><span class="line">                          |</span><br><span class="line">      +-------------------+-------------------+</span><br><span class="line">      |                                       |</span><br><span class="line">+-----v-----+      (在哪里做?)      +---------v-------+</span><br><span class="line">| Pointcut  |---------------------&gt;|      Advice     | (通知: 打开灯)</span><br><span class="line">|(切点: 指令)|                      |  (具体要做什么?)  | @Before, @Around...</span><br><span class="line">+-----------+                      +-----------------+</span><br><span class="line">      |</span><br><span class="line">      | Selects (筛选)</span><br><span class="line">      |</span><br><span class="line">+-----v---------------------------------------+</span><br><span class="line">|                 Join Points                 | (连接点: 剧本里的每个动作)</span><br><span class="line">|   (程序执行过程中的所有可能时机，如方法调用)      |</span><br><span class="line">+---------------------------------------------+</span><br><span class="line"></span><br><span class="line">      Weaving (织入过程)</span><br><span class="line">+--------------+   Creates   +--------------+   Delegates to   +----------------+</span><br><span class="line">| Spring IoC   |-----------&gt;|    Proxy     |----------------&gt;| Target Object  |</span><br><span class="line">| (容器)       |             | (代理: 替身)   |                  | (目标对象: 演员) |</span><br><span class="line">+--------------+             +--------------+                  +----------------+</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-Advice的五种类型"><a href="#2-2-Advice的五种类型" class="headerlink" title="2.2 Advice的五种类型"></a>2.2 Advice的五种类型</h3><h4 id="2-2-1-准备工作"><a href="#2-2-1-准备工作" class="headerlink" title="2.2.1 准备工作"></a>2.2.1 准备工作</h4><h5 id="1-我们的目标对象"><a href="#1-我们的目标对象" class="headerlink" title="1. 我们的目标对象"></a>1. 我们的目标对象</h5><p>我们将对这个<code>CalculatorService</code>的方法执行进行“通知”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/CalculatorService.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.aop.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CalculatorService</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// service/CalculatorServiceImpl.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.aop.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CalculatorService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--- Executing core logic: add(&quot;</span> + a + <span class="string">&quot;, &quot;</span> + b + <span class="string">&quot;) ---&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--- Executing core logic: divide(&quot;</span> + a + <span class="string">&quot;, &quot;</span> + b + <span class="string">&quot;) ---&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Divisor cannot be zero&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-我们的切面和切点"><a href="#2-我们的切面和切点" class="headerlink" title="2. 我们的切面和切点"></a>2. 我们的切面和切点</h5><p>我们创建一个<code>LoggingAspect</code>，并定义一个通用的切点，指向<code>CalculatorService</code>中的所有方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aspect/LoggingAspect.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.aop.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个可重用的切点，匹配CalculatorService接口中的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.aop.service.CalculatorService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculatorServiceMethods</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来，我们将在这个类中添加五种不同类型的通知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>请确保你的SpringBoot应用开启了AOP支持（<code>spring-boot-starter-aop</code>依赖）。</em></p>
<hr>
<h4 id="2-2-2-Advice的五种类型详解"><a href="#2-2-2-Advice的五种类型详解" class="headerlink" title="2.2.2 Advice的五种类型详解"></a>2.2.2 Advice的五种类型详解</h4><h5 id="1-Before-前置通知"><a href="#1-Before-前置通知" class="headerlink" title="1. @Before (前置通知)"></a>1. <code>@Before</code> (前置通知)</h5><ul>
<li><strong>执行时机</strong>：在目标方法（连接点）<strong>执行之前</strong>运行。</li>
<li><strong>特点</strong>：<ul>
<li>无法阻止目标方法的执行。</li>
<li>可以获取到目标方法的元数据（如方法名、参数），但无法改变参数。</li>
</ul>
</li>
<li><strong>适用场景</strong>：权限检查、参数日志记录、数据预处理。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 LoggingAspect.java 中添加</span></span><br><span class="line"><span class="meta">@Before(&quot;calculatorServiceMethods()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    System.out.println(<span class="string">&quot;[@Before] Method &quot;</span> + methodName + <span class="string">&quot; is about to execute with arguments: &quot;</span> + Arrays.toString(args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当调用 <code>add(5, 3)</code> 时，输出:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[@Before] Method add is about to execute with arguments: [5, 3]</span><br><span class="line">--- Executing core logic: add(5, 3) ---</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-AfterReturning-后置通知-返回通知"><a href="#2-AfterReturning-后置通知-返回通知" class="headerlink" title="2. @AfterReturning (后置通知&#x2F;返回通知)"></a>2. <code>@AfterReturning</code> (后置通知&#x2F;返回通知)</h5><ul>
<li><strong>执行时机</strong>：在目标方法<strong>正常执行完毕</strong>（即没有抛出任何异常）并<strong>返回结果后</strong>运行。</li>
<li><strong>特点</strong>：<ul>
<li>可以获取到目标方法的返回值。</li>
<li>但无法改变返回值（虽然可以通过一些技巧包装，但不推荐）。</li>
</ul>
</li>
<li><strong>适用场景</strong>：对返回结果进行日志记录、对结果进行格式化或加密后再返回给某些审计系统。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 LoggingAspect.java 中添加</span></span><br><span class="line"><span class="comment">// `returning = &quot;result&quot;` 将目标方法的返回值绑定到通知方法的`result`参数上</span></span><br><span class="line"><span class="meta">@AfterReturning(pointcut = &quot;calculatorServiceMethods()&quot;, returning = &quot;result&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfterReturning</span><span class="params">(JoinPoint joinPoint, Object result)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;[@AfterReturning] Method &quot;</span> + methodName + <span class="string">&quot; executed successfully and returned: &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当调用 <code>add(5, 3)</code> 时，输出:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--- Executing core logic: add(5, 3) ---</span><br><span class="line">[@AfterReturning] Method add executed successfully and returned: 8</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-AfterThrowing-异常通知"><a href="#3-AfterThrowing-异常通知" class="headerlink" title="3. @AfterThrowing (异常通知)"></a>3. <code>@AfterThrowing</code> (异常通知)</h5><ul>
<li><strong>执行时机</strong>：在目标方法执行过程中<strong>抛出异常后</strong>运行。</li>
<li><strong>特点</strong>：<ul>
<li>可以获取到抛出的异常对象。</li>
<li>可以用于统一的异常处理和日志记录。</li>
</ul>
</li>
<li><strong>适用场景</strong>：记录异常日志、发送错误告警（如邮件、短信）、触发事务回滚的特定逻辑。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 LoggingAspect.java 中添加</span></span><br><span class="line"><span class="comment">// `throwing = &quot;ex&quot;` 将抛出的异常绑定到通知方法的`ex`参数上</span></span><br><span class="line"><span class="meta">@AfterThrowing(pointcut = &quot;calculatorServiceMethods()&quot;, throwing = &quot;ex&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfterThrowing</span><span class="params">(JoinPoint joinPoint, Throwable ex)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    System.err.println(<span class="string">&quot;[@AfterThrowing] Exception in method &quot;</span> + methodName + <span class="string">&quot;: &quot;</span> + ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当调用 <code>divide(10, 0)</code> 时，输出:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--- Executing core logic: divide(10, 0) ---</span><br><span class="line">[@AfterThrowing] Exception in method divide: Divisor cannot be zero</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-After-最终通知"><a href="#4-After-最终通知" class="headerlink" title="4. @After (最终通知)"></a>4. <code>@After</code> (最终通知)</h5><ul>
<li><strong>执行时机</strong>：<strong>无论</strong>目标方法是正常返回还是抛出异常，它<strong>总会</strong>执行。类似于<code>try-catch-finally</code>中的<code>finally</code>块。</li>
<li><strong>特点</strong>：<ul>
<li>无法获取返回值或异常信息，因为它不知道方法是如何结束的。</li>
</ul>
</li>
<li><strong>适用场景</strong>：资源释放。例如，关闭文件句柄、释放数据库连接、清理临时数据等，这些操作无论成功失败都必须执行。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 LoggingAspect.java 中添加</span></span><br><span class="line"><span class="meta">@After(&quot;calculatorServiceMethods()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfter</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;[@After] Method &quot;</span> + methodName + <span class="string">&quot; has finished execution.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当调用 <code>add(5, 3)</code> (成功) 或 <code>divide(10, 0)</code> (失败) 时，这行日志都会被打印。</strong></p>
<hr>
<h5 id="5-Around-环绕通知"><a href="#5-Around-环绕通知" class="headerlink" title="5. @Around (环绕通知)"></a>5. <code>@Around</code> (环绕通知)</h5><ul>
<li><strong>执行时机</strong>：它完全<strong>包裹</strong>了目标方法的执行。</li>
<li><strong>特点</strong>：<ul>
<li><strong>最强大、最灵活</strong>的通知类型。</li>
<li>方法的第一个参数必须是 <code>ProceedingJoinPoint</code> 类型。</li>
<li>你可以决定是否调用 <code>pjp.proceed()</code> 来<strong>执行目标方法</strong>。不调用它，目标方法就相当于被“拦截”了。</li>
<li>你可以在 <code>pjp.proceed()</code> 调用前后添加自定义逻辑。</li>
<li>你可以获取、修改参数，甚至可以捕获异常并返回一个不同的结果。</li>
</ul>
</li>
<li><strong>适用场景</strong>：事务管理、性能监控（计算方法执行时间）、缓存、方法重试机制。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 LoggingAspect.java 中添加</span></span><br><span class="line"><span class="meta">@Around(&quot;calculatorServiceMethods()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">profile</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;[@Around] &gt;&gt; Entering method: &quot;</span> + pjp.getSignature().getName());</span><br><span class="line"></span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用这行代码才会真正执行目标方法</span></span><br><span class="line">        result = pjp.proceed();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[@Around] !! Exception caught: &quot;</span> + t.getMessage());</span><br><span class="line">        <span class="comment">// 决定是否将异常继续向上抛出</span></span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;[@Around] &lt;&lt; Exiting method: &quot;</span> + pjp.getSignature().getName() + <span class="string">&quot;. Execution time: &quot;</span> + (endTime - startTime) + <span class="string">&quot;ms.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须返回目标方法的执行结果，否则调用方会得到null</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当调用 <code>add(5, 3)</code> 时，输出将展示完整的环绕过程。</strong></p>
<hr>
<h4 id="执行顺序总结"><a href="#执行顺序总结" class="headerlink" title="执行顺序总结"></a>执行顺序总结</h4><p>当一个方法同时被多种通知作用时，其执行顺序（以<code>@Around</code>为中心）如下：</p>
<ol>
<li><strong><code>@Around</code></strong> (前半部分)</li>
<li><strong><code>@Before</code></strong></li>
<li><strong>目标方法执行</strong><ul>
<li><strong>如果成功:</strong><ol start="4">
<li><strong><code>@Around</code></strong> (后半部分，<code>proceed()</code>返回后)</li>
<li><strong><code>@AfterReturning</code></strong></li>
<li><strong><code>@After</code></strong></li>
</ol>
</li>
<li><strong>如果抛出异常:</strong><ol start="4">
<li><strong><code>@Around</code></strong> (进入<code>catch</code>块)</li>
<li><strong><code>@AfterThrowing</code></strong></li>
<li><strong><code>@After</code></strong></li>
</ol>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-3-Pointcut表达式语法详解"><a href="#2-3-Pointcut表达式语法详解" class="headerlink" title="2.3 Pointcut表达式语法详解"></a>2.3 Pointcut表达式语法详解</h3><p>Pointcut表达式本质上是一种<strong>查询语言</strong>，用于定位和筛选程序中的<strong>连接点（Join Points）</strong>。在Spring AOP中，连接点就是方法的执行。</p>
<p>Pointcut表达式由一个或多个**切点指示符（Pointcut Designators, PCD）**组成，可以通过逻辑运算符 <code>&amp;&amp;</code> (and), <code>||</code> (or), <code>!</code> (not) 进行组合。</p>
<h4 id="1-execution-最常用、最强大的指示符"><a href="#1-execution-最常用、最强大的指示符" class="headerlink" title="1. execution - 最常用、最强大的指示符"></a>1. <code>execution</code> - 最常用、最强大的指示符</h4><p><code>execution</code> 用于匹配方法的签名（返回类型、方法名、参数等）。这是你90%的情况下会用到的指示符。</p>
<p><strong>完整语法:</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(修饰符? 返回类型 包名.类名.方法名(参数类型) 异常?)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>?</code> 表示该部分是可选的。</li>
<li><code>*</code> 是一个通配符，可以匹配任意字符（除.<code> </code>外）。</li>
<li><code>..</code> 是一个通配符，在不同位置有不同含义：<ul>
<li>在包名中：表示当前包及其所有子包。</li>
<li>在参数列表中：表示任意数量、任意类型的参数。</li>
</ul>
</li>
</ul>
<p><strong>语法分解与示例:</strong></p>
<ul>
<li><strong><code>修饰符</code> (可选)</strong>: 如<code>public</code>, <code>protected</code>, <code>private</code>。通常省略，表示匹配所有修饰符。<ul>
<li><code>execution(public * *(..))</code> - 匹配所有<code>public</code>方法。</li>
</ul>
</li>
<li><strong><code>返回类型</code> (必选)</strong>:<ul>
<li><code>*</code> - 匹配任意返回类型。</li>
<li><code>void</code> - 匹配返回类型为<code>void</code>的方法。</li>
<li><code>java.lang.String</code> - 匹配返回类型为<code>String</code>的方法。</li>
<li><code>execution(* com.example.service.UserService.*(..))</code> - 匹配<code>UserService</code>中任意返回类型的方法。</li>
</ul>
</li>
<li><strong><code>包名.类名.方法名</code> (包名和类名可选)</strong>:<ul>
<li><strong>完整匹配</strong>: <code>com.example.service.UserService.createUser</code></li>
<li><strong>类内所有方法</strong>: <code>com.example.service.UserService.*</code></li>
<li><strong>包内所有类的所有方法</strong>: <code>com.example.service.*.*</code></li>
<li><strong>包及其子包下所有类的所有方法</strong>: <code>com.example.service..*.*</code> ( <strong><code>..</code></strong> 在这里至关重要！)</li>
<li><strong>方法名通配符</strong>: <code>*</code> (所有方法), <code>get*</code> (所有以get开头的方法), <code>*ById</code> (所有以ById结尾的方法)。</li>
</ul>
</li>
<li><strong><code>参数类型</code> (必选)</strong>:<ul>
<li><code>()</code> - 匹配无参方法。</li>
<li><code>(..)</code> - 匹配任意数量、任意类型的参数 (<strong>最常用</strong>)。</li>
<li><code>(*)</code> - 匹配只有一个参数的方法，类型不限。</li>
<li><code>(String)</code> - 匹配只有一个<code>String</code>类型参数的方法。</li>
<li><code>(String, ..)</code> - 匹配第一个参数是<code>String</code>，后面有任意数量、任意类型参数的方法。</li>
</ul>
</li>
<li><strong><code>异常</code> (可选)</strong>: <code>throws</code>子句，匹配抛出特定异常的方法。很少使用。</li>
</ul>
<p><strong>实战组合示例:</strong></p>
<ul>
<li><strong>匹配 <code>UserService</code> 接口中的所有方法</strong>:<br><code>execution(* com.example.service.UserService.*(..))</code></li>
<li><strong>匹配 <code>service</code> 包及其所有子包下，所有类的所有方法</strong>:<br><code>execution(* com.example.service..*.*(..))</code></li>
<li><strong>匹配所有以 <code>Repository</code> 结尾的类中的所有方法</strong>:<br><code>execution(* com.example..*Repository.*(..))</code></li>
<li><strong>匹配任何返回 <code>String</code> 类型，并且以 <code>find</code> 开头的方法</strong>:<br><code>execution(String com.example..*.find*(..))</code></li>
</ul>
<hr>
<h4 id="2-within-匹配指定类型内的所有方法"><a href="#2-within-匹配指定类型内的所有方法" class="headerlink" title="2. within - 匹配指定类型内的所有方法"></a>2. <code>within</code> - 匹配指定类型内的所有方法</h4><p><code>within</code> 用于限定连接点必须在某个指定的类或包内。它比 <code>execution</code> 粒度更粗，不关心方法的具体签名。</p>
<ul>
<li><code>within(com.example.service.UserServiceImpl)</code> - 匹配 <code>UserServiceImpl</code> 类中的所有方法。</li>
<li><code>within(com.example.service.*)</code> - 匹配 <code>com.example.service</code> 包下所有类中的所有方法（<strong>不含子包</strong>）。</li>
<li><code>within(com.example.service..*)</code> - 匹配 <code>com.example.service</code> 包及其所有子包下所有类中的所有方法。</li>
</ul>
<p><strong><code>within</code> vs. <code>execution</code></strong>:</p>
<ul>
<li><code>within(com.example.service..*)</code> 与 <code>execution(* com.example.service..*.*(..))</code> 看起来相似，但 <code>execution</code> 更强大，可以进一步限制返回类型、方法名等。通常优先使用<code>execution</code>。</li>
</ul>
<hr>
<h4 id="3-annotation-匹配带有指定注解的方法"><a href="#3-annotation-匹配带有指定注解的方法" class="headerlink" title="3. @annotation - 匹配带有指定注解的方法"></a>3. <code>@annotation</code> - 匹配带有指定注解的方法</h4><p>这个指示符用于匹配那些<strong>方法本身</strong>被特定注解标记的连接点。</p>
<p><strong>场景</strong>：创建一个自定义注解 <code>@Loggable</code>，希望所有被此注解标记的方法都能被AOP记录日志。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Loggable &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务方法</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Loggable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">importantOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切点表达式</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@annotation(com.example.aop.annotation.Loggable)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loggableMethods</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-within-匹配带有指定注解的类中的所有方法"><a href="#4-within-匹配带有指定注解的类中的所有方法" class="headerlink" title="4. @within - 匹配带有指定注解的类中的所有方法"></a>4. <code>@within</code> - 匹配带有指定注解的类中的所有方法</h4><p><code>@within</code> 与 <code>@annotation</code> 的区别在于，它匹配的是<strong>类级别</strong>的注解。如果一个类被某个注解标记，那么这个类中的<strong>所有方法</strong>（连接点）都会被匹配。</p>
<p><strong>场景</strong>：创建一个注解 <code>@Secured</code>，希望所有被标记为<code>@Secured</code>的类中的所有方法都执行权限检查。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Secured &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务类</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Secured</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resetPassword</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切点表达式</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@within(com.example.aop.annotation.Secured)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">securedClassMethods</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这样，<code>deleteUser()</code> 和 <code>resetPassword()</code> 都会被匹配。</li>
</ul>
<hr>
<h4 id="5-bean-匹配指定名称的Spring-Bean"><a href="#5-bean-匹配指定名称的Spring-Bean" class="headerlink" title="5. bean - 匹配指定名称的Spring Bean"></a>5. <code>bean</code> - 匹配指定名称的Spring Bean</h4><p>这是Spring AOP特有的指示符，用于根据Bean在容器中的ID&#x2F;name来匹配。</p>
<ul>
<li><code>bean(&quot;userServiceImpl&quot;)</code> - 匹配ID为 <code>userServiceImpl</code> 的Bean中的所有方法。</li>
<li><code>bean(&quot;*Service&quot;)</code> - 匹配所有ID以 <code>Service</code> 结尾的Bean中的所有方法。</li>
</ul>
<hr>
<h4 id="6-组合使用与最佳实践"><a href="#6-组合使用与最佳实践" class="headerlink" title="6. 组合使用与最佳实践"></a>6. 组合使用与最佳实践</h4><p>为了代码的可读性和可维护性，强烈建议使用 <code>@Pointcut</code> 定义可重用的切点，然后通过逻辑运算符组合它们。</p>
<p><strong>示例：</strong></p>
<p>假设我们要为一个所有 <code>service</code> 包下，被 <code>@Transactional</code> 注解标记的 <code>public</code> 方法记录性能日志。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PerformanceAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 定义一个切点，匹配service包及其子包</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;within(com.example.service..*)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inServiceLayer</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 定义一个切点，匹配被@Transactional注解的方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(org.springframework.transaction.annotation.Transactional)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transactionalMethods</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 定义一个切点，匹配所有public方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * *(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethods</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 组合以上切点</span></span><br><span class="line">    <span class="meta">@Around(&quot;publicMethods() &amp;&amp; inServiceLayer() &amp;&amp; transactionalMethods()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">profile</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// ... 性能监控逻辑 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式比写一个超长的<code>@Around(&quot;execution(public * com.example.service..*.*(..)) &amp;&amp; @annotation(...)&quot;)</code>要清晰得多，并且每个切点都可以被其他通知复用。</p>
<hr>
<h4 id="总结表"><a href="#总结表" class="headerlink" title="总结表"></a>总结表</h4><table>
<thead>
<tr>
<th align="left">指示符</th>
<th align="left">作用</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>execution</code></strong></td>
<td align="left"><strong>匹配方法签名（最常用）</strong></td>
<td align="left"><code>execution(* com.example..*.*(..))</code></td>
</tr>
<tr>
<td align="left"><code>within</code></td>
<td align="left">匹配指定类型或包内的所有方法</td>
<td align="left"><code>within(com.example.service..*)</code></td>
</tr>
<tr>
<td align="left"><strong><code>@annotation</code></strong></td>
<td align="left"><strong>匹配被特定注解标记的方法</strong></td>
<td align="left"><code>@annotation(com.example.Loggable)</code></td>
</tr>
<tr>
<td align="left"><code>@within</code></td>
<td align="left">匹配被特定注解标记的类中的所有方法</td>
<td align="left"><code>@within(com.example.Secured)</code></td>
</tr>
<tr>
<td align="left"><code>bean</code></td>
<td align="left">匹配特定名称的Spring Bean</td>
<td align="left"><code>bean(*ServiceImpl)</code></td>
</tr>
<tr>
<td align="left"><code>args</code></td>
<td align="left">匹配参数类型为指定类型的连接点</td>
<td align="left"><code>args(String, ..)</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="2-4-AOP的实现原理-JDK动态代理-vs-CGLIB"><a href="#2-4-AOP的实现原理-JDK动态代理-vs-CGLIB" class="headerlink" title="2.4 AOP的实现原理 (JDK动态代理 vs CGLIB)"></a>2.4 AOP的实现原理 (JDK动态代理 vs CGLIB)</h3><p>在Java笔记中的第三章4.8.3中我们详细介绍过了JDK与CGLIB，这里简单回顾一下</p>
<h4 id="2-4-1-JDK动态代理-“基于接口的伪装者”"><a href="#2-4-1-JDK动态代理-“基于接口的伪装者”" class="headerlink" title="2.4.1 JDK动态代理 - “基于接口的伪装者”"></a>2.4.1 JDK动态代理 - “基于接口的伪装者”</h4><ul>
<li><strong>核心机制</strong>：<strong>实现共同的接口</strong>。</li>
<li><strong>工作方式</strong>：Spring创建一个代理类，这个代理类和你真正的业务类（目标类）<strong>实现了相同的接口</strong>。当客户端代码调用接口方法时，实际上调用的是代理对象的方法。代理对象内部的<code>InvocationHandler</code>会先执行切面逻辑（Advice），然后再通过<strong>反射</strong>调用你真正的业务对象的方法。</li>
<li><strong>限制</strong>：你的业务类<strong>必须实现一个接口</strong>。Spring AOP只会代理接口中定义的方法，业务类中自己特有的方法不会被代理。</li>
<li><strong>Spring中的默认行为</strong>：如果一个Bean实现了至少一个接口，Spring AOP<strong>默认</strong>会选用JDK动态代理。</li>
</ul>
<p><strong>一句话总结：客户端面向接口编程，得到的是一个接口的“冒牌”实现类，这个冒牌货在完成核心任务前后会加一些额外的动作。</strong></p>
<hr>
<h4 id="2-4-2-CGLIB动态代理-“基于继承的增强者”"><a href="#2-4-2-CGLIB动态代理-“基于继承的增强者”" class="headerlink" title="2.4.2 CGLIB动态代理 - “基于继承的增强者”"></a>2.4.2 CGLIB动态代理 - “基于继承的增强者”</h4><ul>
<li><strong>核心机制</strong>：<strong>创建子类</strong>。</li>
<li><strong>工作方式</strong>：Spring使用CGLIB库，在运行时动态地创建一个你业务类（目标类）的<strong>子类</strong>作为代理。这个子类会<strong>重写</strong>父类中所有非<code>final</code>的方法。当调用这些方法时，子类中的<code>MethodInterceptor</code>会先执行切面逻辑，然后再调用父类（即你真正的业务对象）的原始方法。</li>
<li><strong>限制</strong>：你的业务类<strong>不能是 <code>final</code> 的</strong>，被代理的方法也<strong>不能是 <code>final</code> 的</strong>，否则子类无法继承或重写。</li>
<li><strong>Spring中的默认行为</strong>：如果一个Bean<strong>没有实现任何接口</strong>，Spring AOP<strong>别无选择</strong>，只能使用CGLIB。</li>
</ul>
<p><strong>一句话总结：客户端得到的是一个业务类的“增强版”子类，这个子类在调用从父类继承来的方法时，会加入额外的切面逻辑。</strong></p>
<hr>
<h4 id="2-4-3-Spring-Boot中的选择与演变"><a href="#2-4-3-Spring-Boot中的选择与演变" class="headerlink" title="2.4.3 Spring Boot中的选择与演变"></a>2.4.3 Spring Boot中的选择与演变</h4><ul>
<li><strong>SpringBoot 2.x 及以后，默认倾向于使用CGLIB</strong>。<ul>
<li>在<code>spring-boot-starter-aop</code>中，默认配置 <code>spring.aop.proxy-target-class=true</code>。</li>
<li>这意味着，<strong>无论你的Bean是否实现了接口，SpringBoot都默认优先使用CGLIB来创建代理</strong>。</li>
</ul>
</li>
<li><strong>为什么会有这个变化？</strong><ol>
<li><strong>解决了类型转换问题</strong>：如果使用JDK代理，从容器中获取的代理对象不能被强制转换为其具体的实现类类型（只能转换为接口类型），有时会引发<code>ClassCastException</code>。而CGLIB代理是目标类的子类，不存在这个问题。</li>
<li><strong>代理类内调用问题</strong>：可以更好地处理在同一个类中的方法相互调用时，AOP可能失效的情况（虽然这个问题根源更复杂，但CGLIB在某些场景下表现更直观）。</li>
<li><strong>性能差异已忽略不计</strong>：如你的笔记所说，现代JDK中两者的性能差异已经微乎其微。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="2-4-4-核心回顾表"><a href="#2-4-4-核心回顾表" class="headerlink" title="2.4.4 核心回顾表"></a>2.4.4 核心回顾表</h4><table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left">JDK动态代理</th>
<th align="left">CGLIB动态代理</th>
<th align="left">Spring Boot默认</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心原理</strong></td>
<td align="left">实现接口</td>
<td align="left">继承父类</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><strong>目标要求</strong></td>
<td align="left">必须有接口</td>
<td align="left">不能是final类&#x2F;方法</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><strong>代理对象类型</strong></td>
<td align="left"><code>com.sun.proxy.$ProxyX</code></td>
<td align="left"><code>TargetClass$$EnhancerByCGLIB$$...</code></td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><strong>Spring选择</strong></td>
<td align="left">目标<strong>有</strong>接口时默认使用</td>
<td align="left">目标<strong>无</strong>接口时使用</td>
<td align="left"><strong>优先使用CGLIB</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="3-事务管理"><a href="#3-事务管理" class="headerlink" title="3. 事务管理"></a>3. 事务管理</h2><h3 id="3-1-声明式事务"><a href="#3-1-声明式事务" class="headerlink" title="3.1 声明式事务"></a>3.1 声明式事务</h3><p>旨在<strong>将事务管理代码从业务逻辑中彻底分离出去</strong>。开发者只需通过一个简单的<strong>注解</strong>来“声明”某个方法需要事务，而具体的事务管理工作全部交给Spring框架在“幕后”完成。</p>
<p>这正是AOP思想的体现：<strong>事务管理</strong>就是一个典型的<strong>横切关注点</strong>。</p>
<p><strong><code>@Transactional</code> 注解：声明式事务的核心</strong></p>
<p><code>@Transactional</code> 是Spring提供的核心注解，用于声明事务。当它被应用到一个<strong>public方法</strong>上时，Spring AOP就会为这个方法（或者整个类）创建一个代理，自动地在方法执行前后添加事务管理逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegistrationService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProfileRepository profileRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// &lt;-- 只需这一个注解！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(User user, Profile profile)</span> &#123;</span><br><span class="line">        <span class="comment">// --- 纯粹的业务逻辑 ---</span></span><br><span class="line">        userRepository.save(user);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果这里发生异常，整个事务会自动回滚</span></span><br><span class="line">        <span class="keyword">if</span> (profile.getBio().contains(<span class="string">&quot;error&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Simulated error during profile creation!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        profileRepository.save(profile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>工作原理（AOP的应用）</strong></p>
<ol>
<li>Spring容器在启动时，发现<code>UserRegistrationService</code>的<code>registerUser</code>方法上带有<code>@Transactional</code>注解。</li>
<li>Spring AOP会为<code>UserRegistrationService</code>创建一个<strong>代理对象</strong>。</li>
<li>当外部代码调用<code>registerUser</code>方法时，实际上调用的是这个<strong>代理对象</strong>的同名方法。</li>
<li>代理对象的方法内部逻辑大致如下：<ul>
<li><strong>方法执行前</strong>：开启事务 (<code>BEGIN TRANSACTION</code>)。</li>
<li><strong>调用原始的业务方法</strong>：即你写的<code>userRepository.save(user)</code>等代码。</li>
<li><strong>方法执行后</strong>：<ul>
<li>如果业务方法<strong>正常执行完毕</strong>（没有抛出异常），则<strong>提交事务</strong> (<code>COMMIT</code>)。</li>
<li>如果业务方法<strong>抛出了<code>RuntimeException</code>或<code>Error</code></strong>，则<strong>回滚事务</strong> (<code>ROLLBACK</code>)。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-2-事务的核心属性"><a href="#3-2-事务的核心属性" class="headerlink" title="3.2 事务的核心属性"></a>3.2 <strong>事务的核心属性</strong></h3><h4 id="3-2-1-传播行为"><a href="#3-2-1-传播行为" class="headerlink" title="3.2.1 传播行为"></a>3.2.1 传播行为</h4><h5 id="1-核心问题"><a href="#1-核心问题" class="headerlink" title="1. 核心问题"></a>1. 核心问题</h5><p>事务传播行为要回答的核心问题是：</p>
<blockquote>
<p>当一个已经处于事务上下文中的方法（我们称之为<strong>外部方法</strong>），去调用另一个也配置了事务的方法（我们称之为<strong>内部方法</strong>）时，内部方法的事务应该如何表现？是加入外部方法的现有事务，还是自己创建一个新的事务？</p>
</blockquote>
<p>这个行为定义了事务边界如何跨越多个方法调用进行“传播”。</p>
<p>在 <code>@Transactional</code> 注解中，通过 <code>propagation</code> 属性来设置，其值是 <code>Propagation</code> 枚举。</p>
<p>这七种行为可以分为三类：<strong>支持型</strong>、<strong>独立型</strong>和<strong>嵌套型</strong>。</p>
<hr>
<h5 id="2-支持型（默认行为）"><a href="#2-支持型（默认行为）" class="headerlink" title="2. 支持型（默认行为）"></a>2. 支持型（默认行为）</h5><p>这类行为倾向于加入已存在的事务。</p>
<h6 id="a-Propagation-REQUIRED-默认值"><a href="#a-Propagation-REQUIRED-默认值" class="headerlink" title="a). Propagation.REQUIRED (默认值)"></a>a). <code>Propagation.REQUIRED</code> (默认值)</h6><ul>
<li><strong>含义</strong>：<strong>需要事务</strong>。</li>
<li><strong>规则</strong>：<ul>
<li>如果当前已经存在一个事务（外部方法带来了事务），那么内部方法就<strong>加入</strong>这个已存在的事务。它们在同一个事务中运行，要么一起成功提交，要么一起失败回滚。</li>
<li>如果当前不存在事务，那么就为内部方法<strong>创建一个新的事务</strong>。</li>
</ul>
</li>
<li><strong>比喻</strong>：一个团队成员接到任务。如果团队（外部事务）已经在开会讨论这个任务，他就加入会议一起讨论。如果没人开会，他就自己发起一个会议来解决。</li>
<li><strong>适用场景</strong>：<strong>绝大多数（超过95%）的业务场景</strong>。它是最常用、最合理的默认行为。例如，一个<code>updateOrder</code>方法调用<code>decreaseStock</code>和<code>updateUserBalance</code>，这三个操作必须在同一个事务中。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StockService stockService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span> <span class="comment">// 默认，可省略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ... 创建订单操作 ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用stockService的方法，它会加入createOrder的事务</span></span><br><span class="line">        stockService.decreaseStock(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span> <span class="comment">// 默认</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decreaseStock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ... 扣减库存操作 ...</span></span><br><span class="line">        <span class="comment">// 如果这里失败，整个createOrder事务都会回滚</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="b-Propagation-SUPPORTS"><a href="#b-Propagation-SUPPORTS" class="headerlink" title="b). Propagation.SUPPORTS"></a>b). <code>Propagation.SUPPORTS</code></h6><ul>
<li><strong>含义</strong>：<strong>支持事务</strong>。</li>
<li><strong>规则</strong>：<ul>
<li>如果当前存在事务，则<strong>加入</strong>该事务。</li>
<li>如果当前没有事务，则以<strong>非事务</strong>的方式继续运行。</li>
</ul>
</li>
<li><strong>比喻</strong>：一个顾问。如果别人在开会，他可以加入并提供建议。如果没人开会，他也就自己干自己的活，不主动组织会议。</li>
<li><strong>适用场景</strong>：通常用于那些<strong>不关心事务</strong>，但如果能运行在事务中也无妨的方法，比如一些<strong>只读的查询</strong>操作。</li>
</ul>
<h6 id="c-Propagation-MANDATORY"><a href="#c-Propagation-MANDATORY" class="headerlink" title="c). Propagation.MANDATORY"></a>c). <code>Propagation.MANDATORY</code></h6><ul>
<li><strong>含义</strong>：<strong>强制需要事务</strong>。</li>
<li><strong>规则</strong>：<ul>
<li>如果当前存在事务，则<strong>加入</strong>该事务。</li>
<li>如果当前没有事务，则<strong>抛出异常</strong> (<code>IllegalTransactionStateException</code>)。</li>
</ul>
</li>
<li><strong>比喻</strong>：一个专职的会议记录员。他只在会议中工作，如果把他叫到一个没有会议的地方，他会拒绝工作并抱怨。</li>
<li><strong>适用场景</strong>：很少使用。用于那些必须在特定事务上下文中执行的工具类或辅助方法，以确保它们不会被错误地在事务外部调用。</li>
</ul>
<hr>
<h5 id="3-独立型"><a href="#3-独立型" class="headerlink" title="3. 独立型"></a>3. 独立型</h5><p>这类行为总是试图独立于外部事务运行。</p>
<h6 id="a-Propagation-REQUIRES-NEW"><a href="#a-Propagation-REQUIRES-NEW" class="headerlink" title="a). Propagation.REQUIRES_NEW"></a>a). <code>Propagation.REQUIRES_NEW</code></h6><ul>
<li><strong>含义</strong>：<strong>需要新事务</strong>。</li>
<li><strong>规则</strong>：<ul>
<li>无论当前是否存在事务，它<strong>总是创建一个全新的、独立的事务</strong>。</li>
<li>如果当前存在事务（外部事务），则会将外部事务<strong>挂起 (suspend)</strong>，直到这个新事务完成（提交或回滚）。新事务完成后，再恢复外部事务。</li>
</ul>
</li>
<li><strong>比喻</strong>：一个需要绝对保密和独立决策的“秘密会议”。即使外部正在进行一个大会议，这个方法也会暂停外部会议，自己开一个完全独立的小会。小会的结果（成功或失败）<strong>不会直接影响</strong>外部大会议的最终决策。</li>
<li><strong>适用场景</strong>：<ul>
<li><strong>日志记录</strong>：你可能希望记录操作日志的这个动作<strong>必须成功</strong>，即使主业务操作最终失败回滚。例如，记录一次“尝试支付”的日志，无论支付成功与否，这条日志都应该被保存。</li>
<li><strong>独立的审计或消息发送</strong>：确保某些与主业务逻辑解耦的操作能够独立提交。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogService logService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processPayment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ... 核心支付逻辑，可能会失败 ...</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Payment failed!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论支付成功与否，都尝试记录日志</span></span><br><span class="line">            <span class="comment">// logService.logAttempt() 会开启一个新事务，独立于processPayment的事务</span></span><br><span class="line">            logService.logAttempt(<span class="string">&quot;some_payment_info&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogService</span> &#123;</span><br><span class="line">    <span class="comment">// 即使processPayment事务回滚了，这个新事务也会独立提交</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAttempt</span><span class="params">(String info)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 将日志信息写入数据库 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="b-Propagation-NOT-SUPPORTED"><a href="#b-Propagation-NOT-SUPPORTED" class="headerlink" title="b). Propagation.NOT_SUPPORTED"></a>b). <code>Propagation.NOT_SUPPORTED</code></h6><ul>
<li><strong>含义</strong>：<strong>不支持事务</strong>。</li>
<li><strong>规则</strong>：<ul>
<li>总是以<strong>非事务</strong>的方式运行。</li>
<li>如果当前存在事务，则将外部事务<strong>挂起</strong>。</li>
</ul>
</li>
<li><strong>比喻</strong>：一个需要“绝对安静”环境工作的人。如果外部在开会，他会要求会议暂停，等他干完活再继续。</li>
<li><strong>适用场景</strong>：当一个方法内部有大量的、长时间运行的、且不需要事务的非DB操作时（例如，调用外部API、进行复杂计算），可以用来临时跳出事务，避免长时间占用数据库连接。</li>
</ul>
<h6 id="c-Propagation-NEVER"><a href="#c-Propagation-NEVER" class="headerlink" title="c). Propagation.NEVER"></a>c). <code>Propagation.NEVER</code></h6><ul>
<li><strong>含义</strong>：<strong>绝不需要事务</strong>。</li>
<li><strong>规则</strong>：<ul>
<li>总是以<strong>非事务</strong>的方式运行。</li>
<li>如果当前存在事务，则<strong>抛出异常</strong>。</li>
</ul>
</li>
<li><strong>比喻</strong>：一个极度反感会议的人。如果发现自己被拉进了一个会议，会立刻发火离场。</li>
<li><strong>适用场景</strong>：非常罕见。用于确保某些方法绝对不会在事务中被调用。</li>
</ul>
<hr>
<h5 id="4-嵌套型"><a href="#4-嵌套型" class="headerlink" title="4. 嵌套型"></a>4. 嵌套型</h5><h6 id="a-Propagation-NESTED"><a href="#a-Propagation-NESTED" class="headerlink" title="a). Propagation.NESTED"></a>a). <code>Propagation.NESTED</code></h6><ul>
<li><strong>含义</strong>：<strong>嵌套事务</strong>。</li>
<li><strong>规则</strong>：<ul>
<li>如果当前存在事务，则创建一个<strong>嵌套事务</strong>，它“嵌套”在外部事务中。</li>
<li>如果当前没有事务，则行为与 <code>REQUIRED</code> 相同（创建一个新事务）。</li>
</ul>
</li>
<li><strong>嵌套事务的特点 (Savepoint)</strong>：<ul>
<li>嵌套事务是外部事务的一个<strong>子事务</strong>。</li>
<li>它有自己独立的<strong>保存点 (Savepoint)</strong>。</li>
<li><strong>内部（嵌套）事务的回滚不会影响外部事务</strong>。外部事务可以捕获内部事务的异常并继续执行。</li>
<li><strong>外部事务的回滚一定会导致所有嵌套事务的回滚</strong>。</li>
</ul>
</li>
<li><strong>比喻</strong>：在一个大型项目会议（外部事务）中，针对某个技术难题，大家决定开一个“技术攻关小组会”（嵌套事务）。<ul>
<li>如果小组会失败了（内部回滚），主持人可以决定“这个问题我们先放下”，然后大会议继续讨论其他议题。</li>
<li>但如果整个项目会议决定取消（外部回滚），那么小组会的所有结论自然也作废了。</li>
</ul>
</li>
<li><strong><code>NESTED</code> vs. <code>REQUIRES_NEW</code></strong><ul>
<li><code>REQUIRES_NEW</code> 创建的是一个<strong>完全独立</strong>的事务，使用独立的数据库连接。</li>
<li><code>NESTED</code> 创建的是一个<strong>依赖于外部事务</strong>的子事务，共享同一个数据库连接。</li>
</ul>
</li>
<li><strong>注意事项</strong>：并非所有数据库或JDBC驱动都支持嵌套事务（Savepoint）。需要数据库提供支持。</li>
</ul>
<hr>
<h5 id="5-总结表"><a href="#5-总结表" class="headerlink" title="5. 总结表"></a>5. 总结表</h5><table>
<thead>
<tr>
<th align="left">传播行为</th>
<th align="left">当前有事务</th>
<th align="left">当前无事务</th>
<th align="left">主要应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>REQUIRED</code></strong></td>
<td align="left"><strong>加入事务</strong></td>
<td align="left"><strong>创建新事务</strong></td>
<td align="left"><strong>绝大多数业务场景（默认）</strong></td>
</tr>
<tr>
<td align="left"><code>SUPPORTS</code></td>
<td align="left">加入事务</td>
<td align="left">非事务运行</td>
<td align="left">不关心事务的查询等</td>
</tr>
<tr>
<td align="left"><code>MANDATORY</code></td>
<td align="left">加入事务</td>
<td align="left">抛出异常</td>
<td align="left">必须在事务中运行的工具方法</td>
</tr>
<tr>
<td align="left"><strong><code>REQUIRES_NEW</code></strong></td>
<td align="left"><strong>挂起当前，创建新事务</strong></td>
<td align="left"><strong>创建新事务</strong></td>
<td align="left"><strong>日志、审计等需要独立提交的场景</strong></td>
</tr>
<tr>
<td align="left"><code>NOT_SUPPORTED</code></td>
<td align="left">挂起当前，非事务运行</td>
<td align="left">非事务运行</td>
<td align="left">跳出事务执行非DB耗时操作</td>
</tr>
<tr>
<td align="left"><code>NEVER</code></td>
<td align="left">抛出异常</td>
<td align="left">非事务运行</td>
<td align="left">确保方法不在事务中运行</td>
</tr>
<tr>
<td align="left"><strong><code>NESTED</code></strong></td>
<td align="left"><strong>创建嵌套事务(Savepoint)</strong></td>
<td align="left"><strong>创建新事务</strong></td>
<td align="left">需要部分回滚的复杂业务场景</td>
</tr>
</tbody></table>
<hr>
<h4 id="3-2-2-隔离级别"><a href="#3-2-2-隔离级别" class="headerlink" title="3.2.2 隔离级别"></a>3.2.2 隔离级别</h4><h5 id="1-核心问题-1"><a href="#1-核心问题-1" class="headerlink" title="1. 核心问题"></a>1. 核心问题</h5><p>隔离级别要回答的核心问题是：</p>
<blockquote>
<p>在数据库系统<strong>并发</strong>运行时，一个事务中的操作对其他并发执行的事务的<strong>可见性</strong>有多高？或者说，一个事务应该在多大程度上与其他事务<strong>隔离</strong>开来？</p>
</blockquote>
<p>隔离级别本质上是在<strong>数据一致性</strong>和<strong>系统并发性能</strong>之间做出的一个权衡。</p>
<ul>
<li><strong>隔离级别越高</strong>：数据一致性越好，越能避免并发问题，但系统并发性能越差（因为需要更多的锁定机制）。</li>
<li><strong>隔离级别越低</strong>：系统并发性能越好，但可能引发各种数据不一致的问题。</li>
</ul>
<hr>
<h5 id="2-并发事务带来的三大问题"><a href="#2-并发事务带来的三大问题" class="headerlink" title="2. 并发事务带来的三大问题"></a>2. 并发事务带来的三大问题</h5><p>在讨论隔离级别之前，我们必须先理解如果没有隔离或隔离不当，会发生哪些问题。</p>
<h6 id="a-脏读-Dirty-Read"><a href="#a-脏读-Dirty-Read" class="headerlink" title="a). 脏读 (Dirty Read)"></a>a). 脏读 (Dirty Read)</h6><ul>
<li><strong>定义</strong>：一个事务（T1）读取到了另一个事务（T2）<strong>尚未提交</strong>的修改数据。如果T2最终<strong>回滚</strong>了，那么T1读取到的就是“脏”的、无效的数据。</li>
<li><strong>例子</strong>：<ol>
<li>T1 开始。</li>
<li>T2 开始，将某商品库存从 10 修改为 9。</li>
<li>T1 读取库存，得到 9。</li>
<li>T2 回滚（例如，因为用户支付失败）。库存恢复为 10。</li>
<li>T1 拿着错误的库存 9 进行了后续操作。</li>
</ol>
</li>
</ul>
<h6 id="b-不可重复读-Non-Repeatable-Read"><a href="#b-不可重复读-Non-Repeatable-Read" class="headerlink" title="b). 不可重复读 (Non-Repeatable Read)"></a>b). 不可重复读 (Non-Repeatable Read)</h6><ul>
<li><strong>定义</strong>：在一个事务（T1）内，<strong>两次读取同一行数据</strong>，但得到的结果却不一样。这是因为在两次读取之间，另一个事务（T2）<strong>提交了对这行数据的修改</strong>。</li>
<li><strong>重点</strong>：问题出在<strong>同一行数据</strong>的**修改（UPDATE）**上。</li>
<li><strong>例子</strong>：<ol>
<li>T1 开始，读取商品A的价格为 100 元。</li>
<li>T2 开始，将商品A的价格修改为 120 元，并<strong>提交</strong>。</li>
<li>T1 <strong>在同一个事务内</strong>再次读取商品A的价格，发现价格变成了 120 元。</li>
<li>T1 发现自己事务内的数据“不翼而飞”地变了，导致后续计算可能出错。</li>
</ol>
</li>
</ul>
<h6 id="c-幻读-Phantom-Read"><a href="#c-幻读-Phantom-Read" class="headerlink" title="c). 幻读 (Phantom Read)"></a>c). 幻读 (Phantom Read)</h6><ul>
<li><strong>定义</strong>：在一个事务（T1）内，<strong>两次执行相同的范围查询</strong>，但第二次查询返回了<strong>更多的行</strong>。这是因为在两次查询之间，另一个事务（T2）<strong>插入了新的、符合该范围查询条件的行</strong>，并<strong>提交</strong>了。</li>
<li><strong>重点</strong>：问题出在<strong>一批数据</strong>的**新增（INSERT）或删除（DELETE）**上。看起来就像出现了“幻影”行。</li>
<li><strong>例子</strong>：<ol>
<li>T1 开始，查询所有年龄小于 30 岁的员工，得到 10 条记录。</li>
<li>T2 开始，插入一个 25 岁的新员工，并<strong>提交</strong>。</li>
<li>T1 <strong>在同一个事务内</strong>再次执行相同的查询（<code>SELECT * FROM employees WHERE age &lt; 30</code>），发现结果变成了 11 条记录。</li>
<li>T1 感到困惑，为什么会多出来一个“幻影”员工。</li>
</ol>
</li>
</ul>
<hr>
<h5 id="3-四种标准隔离级别"><a href="#3-四种标准隔离级别" class="headerlink" title="3. 四种标准隔离级别"></a>3. 四种标准隔离级别</h5><p>为了解决上述问题，SQL标准定义了四种隔离级别。在Spring中，可以通过 <code>@Transactional(isolation = Isolation.XXX)</code> 来设置。</p>
<h6 id="a-Isolation-READ-UNCOMMITTED-读未提交"><a href="#a-Isolation-READ-UNCOMMITTED-读未提交" class="headerlink" title="a).Isolation.READ_UNCOMMITTED (读未提交)"></a>a).<code>Isolation.READ_UNCOMMITTED</code> (读未提交)</h6><ul>
<li><strong>隔离级别最低</strong>。</li>
<li><strong>行为</strong>：允许一个事务读取到另一个事务<strong>未提交</strong>的数据。</li>
<li><strong>解决的问题</strong>：无。</li>
<li><strong>引发的问题</strong>：<strong>脏读、不可重复读、幻读</strong>都可能发生。</li>
<li><strong>适用场景</strong>：几乎从不使用。只在对数据一致性要求极低，但对性能要求极高的场景下（如某些报表的近似统计）才可能考虑。</li>
</ul>
<h6 id="b-Isolation-READ-COMMITTED-读已提交"><a href="#b-Isolation-READ-COMMITTED-读已提交" class="headerlink" title="b). Isolation.READ_COMMITTED (读已提交)"></a>b). <code>Isolation.READ_COMMITTED</code> (读已提交)</h6><ul>
<li><strong>大多数数据库的默认隔离级别</strong> (如 Oracle, SQL Server, PostgreSQL)。</li>
<li><strong>行为</strong>：一个事务只能读取到其他事务<strong>已经提交</strong>的数据。</li>
<li><strong>解决的问题</strong>：<strong>避免了脏读</strong>。</li>
<li><strong>引发的问题</strong>：<strong>不可重复读、幻读</strong>仍然可能发生。</li>
<li><strong>实现原理</strong>：通常通过“读锁”或MVCC（多版本并发控制）实现。</li>
</ul>
<h6 id="c-Isolation-REPEATABLE-READ-可重复读"><a href="#c-Isolation-REPEATABLE-READ-可重复读" class="headerlink" title="c). Isolation.REPEATABLE_READ (可重复读)"></a>c). <code>Isolation.REPEATABLE_READ</code> (可重复读)</h6><ul>
<li><strong>MySQL InnoDB 引擎的默认隔离级别</strong>。</li>
<li><strong>行为</strong>：在一个事务开始时，它能看到的数据版本就被“固定”下来了。在该事务内，无论其他事务如何修改并提交数据，它多次读取同一行数据的结果都是一致的。</li>
<li><strong>解决的问题</strong>：<strong>避免了脏读、不可重复读</strong>。</li>
<li><strong>引发的问题</strong>：标准的<code>REPEATABLE_READ</code>级别仍然可能发生<strong>幻读</strong>。<ul>
<li><strong>但注意</strong>：MySQL的InnoDB引擎通过<strong>MVCC + Next-Key Locking</strong>技术，在<code>REPEATABLE_READ</code>级别下<strong>基本解决了幻读问题</strong>，使其表现得更像<code>SERIALIZABLE</code>。</li>
</ul>
</li>
<li><strong>实现原理</strong>：MVCC。</li>
</ul>
<h6 id="d-Isolation-SERIALIZABLE-可串行化"><a href="#d-Isolation-SERIALIZABLE-可串行化" class="headerlink" title="d). Isolation.SERIALIZABLE (可串行化)"></a>d). <code>Isolation.SERIALIZABLE</code> (可串行化)</h6><ul>
<li><strong>隔离级别最高</strong>。</li>
<li><strong>行为</strong>：强制事务串行执行。一个事务在操作某一批数据时，会完全锁定这些数据，其他事务必须等待其结束后才能访问。</li>
<li><strong>解决的问题</strong>：<strong>避免了脏读、不可重复读、幻读</strong>。</li>
<li><strong>引发的问题</strong>：<strong>并发性能极差</strong>。容易导致大量的超时和锁竞争。</li>
<li><strong>适用场景</strong>：只在对数据一致性要求极高，且并发量不大的场景下使用，例如银行的转账操作，但即使是银行，也通常通过其他机制（如行级锁、乐观锁）来避免使用此级别。</li>
</ul>
<hr>
<h5 id="4-总结与选择"><a href="#4-总结与选择" class="headerlink" title="4. 总结与选择"></a>4. 总结与选择</h5><table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="center">脏读 (Dirty Read)</th>
<th align="center">不可重复读 (Non-Repeatable Read)</th>
<th align="center">幻读 (Phantom Read)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>READ_UNCOMMITTED</code></td>
<td align="center">允许</td>
<td align="center">允许</td>
<td align="center">允许</td>
</tr>
<tr>
<td align="left"><code>READ_COMMITTED</code></td>
<td align="center"><strong>禁止</strong></td>
<td align="center">允许</td>
<td align="center">允许</td>
</tr>
<tr>
<td align="left"><code>REPEATABLE_READ</code></td>
<td align="center"><strong>禁止</strong></td>
<td align="center"><strong>禁止</strong></td>
<td align="center">允许 (MySQL基本禁止)</td>
</tr>
<tr>
<td align="left"><code>SERIALIZABLE</code></td>
<td align="center"><strong>禁止</strong></td>
<td align="center"><strong>禁止</strong></td>
<td align="center"><strong>禁止</strong></td>
</tr>
</tbody></table>
<p><strong>最佳实践与建议：</strong></p>
<ol>
<li><strong>使用数据库的默认隔离级别</strong>：在绝大多数情况下，直接使用你的数据库（如MySQL的<code>REPEATABLE_READ</code>，Oracle的<code>READ_COMMITTED</code>）的默认隔离级别就足够了。这些默认设置是数据库厂商在性能和一致性之间做出的最佳平衡。</li>
<li><strong>非必要不修改</strong>：不要轻易在代码中通过 <code>@Transactional</code> 去修改隔离级别，除非你非常清楚你正在解决什么特定的并发问题，并且愿意承担由此带来的性能影响。</li>
<li><strong>理解你的数据库</strong>：了解你所使用的数据库在特定隔离级别下的具体实现机制（例如，了解MySQL的MVCC和Next-Key Lock）比死记硬背SQL标准更重要。</li>
<li><strong>优先使用乐观锁&#x2F;悲观锁</strong>：对于并发写操作非常频繁的“热点数据”，与其提升整个事务的隔离级别，不如使用更细粒度的<strong>乐观锁</strong>（如版本号字段）或<strong>悲观锁</strong>（如<code>SELECT ... FOR UPDATE</code>）来解决并发冲突，这样对性能的影响更小。</li>
</ol>
<hr>
<h4 id="3-2-3-其他属性"><a href="#3-2-3-其他属性" class="headerlink" title="3.2.3 其他属性"></a>3.2.3 其他属性</h4><h5 id="1-readOnly-只读"><a href="#1-readOnly-只读" class="headerlink" title="1. readOnly (只读)"></a>1. <code>readOnly</code> (只读)</h5><ul>
<li><p><strong>属性定义</strong>: <code>boolean readOnly()</code></p>
</li>
<li><p><strong>默认值</strong>: <code>false</code></p>
</li>
<li><p><strong>核心作用</strong>: 这是一个<strong>性能优化提示</strong>。当你将一个事务标记为 <code>readOnly = true</code> 时，你是在告诉Spring和底层数据库：“这个事务中的所有操作都<strong>不会</strong>修改任何数据（只有SELECT查询）。”</p>
</li>
<li><p><strong>带来的好处</strong>:</p>
<ol>
<li><strong>数据库层面的优化</strong>: 某些数据库（如MySQL InnoDB）可以根据这个只读提示进行优化。例如，它可能不必为这个事务维护回滚所需的undo log，从而减少开销。</li>
<li><strong>避免不必要的脏检查</strong>: 在使用JPA&#x2F;Hibernate等ORM框架时，将事务设为只读可以避免框架进行不必要的“脏数据检查”（Dirty Checking），从而提升性能。</li>
<li><strong>代码可读性</strong>: 它清晰地向其他开发者表明，这个方法是一个查询方法，不应该包含任何写操作。</li>
</ol>
</li>
<li><p><strong>注意事项</strong>:</p>
<ul>
<li>这只是一个“提示”，不是强制约束。如果你在一个标记为<code>readOnly = true</code>的事务中执行了写操作（INSERT, UPDATE, DELETE），其行为取决于具体的数据库和事务管理器。有些可能会直接报错，有些可能会忽略这个提示。因此，它不能替代真正的权限控制。</li>
</ul>
</li>
<li><p><strong>最佳实践</strong>: <strong>强烈建议为所有只进行查询操作的Service方法添加 <code>@Transactional(readOnly = true)</code>。</strong></p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductRepository productRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询方法，标记为只读以优化性能</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">findProductById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> productRepository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作方法，使用默认的 readOnly = false</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">(String name, BigDecimal price)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">newProduct</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>(name, price);</span><br><span class="line">        <span class="keyword">return</span> productRepository.save(newProduct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-timeout-超时"><a href="#2-timeout-超时" class="headerlink" title="2. timeout (超时)"></a>2. <code>timeout</code> (超时)</h5><ul>
<li><p><strong>属性定义</strong>: <code>int timeout()</code></p>
</li>
<li><p><strong>默认值</strong>: <code>-1</code> (表示使用底层事务系统的默认超时时间，通常意味着永不超时)</p>
</li>
<li><p><strong>核心作用</strong>: 设置事务允许执行的<strong>最大时长（秒）</strong>。如果事务在指定的时间内没有完成（提交或回滚），事务管理器将<strong>强制回滚</strong>该事务，并抛出<code>TransactionTimedOutException</code>。</p>
</li>
<li><p><strong>为什么需要它</strong>:</p>
<ul>
<li><strong>防止资源耗尽</strong>: 作为一个<strong>安全阀</strong>，它可以防止一个有问题的事务（例如，一个执行了死循环查询或遭遇死锁的事务）长时间占用数据库连接和锁资源，从而拖垮整个系统。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li>对于那些可能涉及复杂计算、大量数据处理或调用外部慢速服务的事务，设置一个合理的超时时间是一种很好的保护措施。</li>
</ul>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReportGenerationService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个报表生成可能非常耗时，我们设置一个30秒的超时上限</span></span><br><span class="line">    <span class="meta">@Transactional(timeout = 30)</span></span><br><span class="line">    <span class="keyword">public</span> Report <span class="title function_">generateMonthlyReport</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ... 复杂的、可能耗时很长的数据库查询和计算 ...</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟一个长时间操作</span></span><br><span class="line">            Thread.sleep(<span class="number">35000</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果执行到这里超过30秒，事务早已被回滚</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Report</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="3-回滚规则-rollbackFor-noRollbackFor"><a href="#3-回滚规则-rollbackFor-noRollbackFor" class="headerlink" title="3. 回滚规则 (rollbackFor, noRollbackFor)"></a>3. 回滚规则 (<code>rollbackFor</code>, <code>noRollbackFor</code>)</h5><p>这是<code>@Transactional</code>中一个非常重要且容易出错的配置，因为它定义了<strong>什么样的异常会触发事务回滚</strong>。</p>
<ul>
<li><strong>Spring的默认回滚行为</strong>:<ul>
<li>当方法抛出 <strong><code>RuntimeException</code></strong> (非受检异常) 或 <strong><code>Error</code></strong> 时，<strong>默认回滚</strong>事务。</li>
<li>当方法抛出 <strong><code>Exception</code></strong> (受检异常，即必须<code>try-catch</code>或<code>throws</code>的异常) 时，<strong>默认不回滚</strong>事务。</li>
</ul>
</li>
<li><strong>为什么有这个默认行为</strong>:<ul>
<li>这是一种设计哲学。Spring认为<code>RuntimeException</code>通常代表了程序中的意外错误（bug），状态很可能已经不一致，回滚是保证数据安全的唯一方式。而受检<code>Exception</code>通常代表了可预期的、业务逻辑上的一种情况（如“余额不足异常”），在这种情况下，开发者可能希望即使有异常，之前的某些操作也依然被提交。</li>
</ul>
</li>
</ul>
<h6 id="a-rollbackFor-和-rollbackForClassName"><a href="#a-rollbackFor-和-rollbackForClassName" class="headerlink" title="a) rollbackFor 和 rollbackForClassName"></a>a) <code>rollbackFor</code> 和 <code>rollbackForClassName</code></h6><ul>
<li><p><strong>核心作用</strong>: 告诉Spring，除了默认的<code>RuntimeException</code>和<code>Error</code>，当遇到<strong>指定的异常类型时，也应该回滚</strong>事务。</p>
</li>
<li><p><strong>适用场景</strong>: 最常见的场景就是当你自定义了一个受检异常，并希望它能触发回滚。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义一个受检异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsufficientStockException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InsufficientStockException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="comment">// 默认情况下，抛出 InsufficientStockException 不会回滚</span></span><br><span class="line">    <span class="comment">// 我们用 rollbackFor 来改变这个行为</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = InsufficientStockException.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">(Long productId, <span class="type">int</span> quantity)</span> <span class="keyword">throws</span> InsufficientStockException &#123;</span><br><span class="line">        <span class="comment">// 1. 减少库存</span></span><br><span class="line">        stockService.decreaseStock(productId, quantity); <span class="comment">// 这个方法可能会抛出 InsufficientStockException</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 创建订单记录</span></span><br><span class="line">        orderRepository.create(...);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 decreaseStock 抛出异常，因为配置了 rollbackFor，</span></span><br><span class="line">        <span class="comment">// 即使它是受检异常，整个事务也会回滚。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="b-noRollbackFor-和-noRollbackForClassName"><a href="#b-noRollbackFor-和-noRollbackForClassName" class="headerlink" title="b) noRollbackFor 和 noRollbackForClassName"></a>b) <code>noRollbackFor</code> 和 <code>noRollbackForClassName</code></h6><ul>
<li><p><strong>核心作用</strong>: 告诉Spring，当遇到<strong>指定的异常类型时，不应该回滚</strong>事务，即使它是默认会回滚的<code>RuntimeException</code>。</p>
</li>
<li><p><strong>适用场景</strong>: 比较少见。用于某些特殊的业务场景，即某个非关键性操作的失败不应该影响主流程的提交。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 假设 RecordNotFoundException 是一个 RuntimeException</span></span><br><span class="line">    <span class="comment">// 我们希望即使更新积分失败，用户创建操作也应该成功</span></span><br><span class="line">    <span class="meta">@Transactional(noRollbackFor = RecordNotFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUserAndAddBonusPoints</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建用户（关键操作）</span></span><br><span class="line">        userRepository.save(user);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 为推荐人增加积分（非关键操作）</span></span><br><span class="line">            <span class="comment">// 这个方法如果找不到推荐人，可能会抛出 RecordNotFoundException</span></span><br><span class="line">            pointsService.addPointsForReferrer(user.getReferrerId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RecordNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获异常，记录日志，但不希望它回滚上面的 userRepository.save(user)</span></span><br><span class="line">            log.warn(<span class="string">&quot;Referrer not found, bonus points not added. But user creation is successful.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="4-总结表"><a href="#4-总结表" class="headerlink" title="4. 总结表"></a>4. 总结表</h5><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">默认值</th>
<th align="left">主要用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>readOnly</code></strong></td>
<td align="left"><code>false</code></td>
<td align="left"><strong>性能优化</strong>。标记只读查询，建议所有查询方法都使用。</td>
</tr>
<tr>
<td align="left"><strong><code>timeout</code></strong></td>
<td align="left"><code>-1</code></td>
<td align="left"><strong>安全保护</strong>。防止事务长时间运行，耗尽系统资源。</td>
</tr>
<tr>
<td align="left"><strong><code>rollbackFor</code></strong></td>
<td align="left"><code>{}</code></td>
<td align="left"><strong>改变默认回滚规则</strong>。添加需要触发回滚的异常类型（通常是受检异常）。</td>
</tr>
<tr>
<td align="left"><strong><code>noRollbackFor</code></strong></td>
<td align="left"><code>{}</code></td>
<td align="left"><strong>改变默认回滚规则</strong>。添加即使发生也不触发回滚的异常类型（通常是运行时异常）。</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-3-Transactional-失效的经典场景"><a href="#3-3-Transactional-失效的经典场景" class="headerlink" title="3.3 @Transactional 失效的经典场景"></a>3.3 <code>@Transactional</code> 失效的经典场景</h3><h4 id="3-3-1-应用在非-public-方法上"><a href="#3-3-1-应用在非-public-方法上" class="headerlink" title="3.3.1 应用在非 public 方法上"></a>3.3.1 应用在非 <code>public</code> 方法上</h4><ul>
<li><p><strong>现象</strong>：将 <code>@Transactional</code> 注解放在 <code>private</code>, <code>protected</code>, 或包可见（default）的方法上。</p>
</li>
<li><p><strong>原因</strong>：Spring AOP的实现原理是<strong>动态代理</strong>。无论是JDK动态代理还是CGLIB，它们都是通过创建一个代理类来<strong>重写（override）或实现</strong>目标方法，并在其中织入事务逻辑。</p>
<ul>
<li><code>private</code> 方法：无法被子类重写，也无法被外部的代理类调用。</li>
<li><code>protected</code> &#x2F; <code>default</code> 方法：虽然可以被子类重写，但Spring的代理机制为了保持一致性和减少复杂性，其AOP拦截器默认只为 <code>public</code> 方法创建代理。</li>
</ul>
</li>
<li><p><strong>结论</strong>：Spring AOP会<strong>静默地忽略</strong>非 <code>public</code> 方法上的 <code>@Transactional</code> 注解，事务不会生效，也不会有任何错误提示。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// &lt;-- 生效</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// &lt;-- 将被忽略，事务无效！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-3-2-方法内部调用（“自调用”问题）"><a href="#3-3-2-方法内部调用（“自调用”问题）" class="headerlink" title="3.3.2 方法内部调用（“自调用”问题）"></a>3.3.2 方法内部调用（“自调用”问题）</h4><ul>
<li><p><strong>现象</strong>：在同一个类中，一个没有 <code>@Transactional</code> 注解的方法 <code>a()</code>，调用了本类中另一个带有 <code>@Transactional</code> 注解的方法 <code>b()</code>。</p>
</li>
<li><p><strong>原因</strong>：<strong>这是最常见、最隐蔽的失效场景</strong>。当外部代码调用 <code>a()</code> 方法时，它通过的是Spring的代理对象。但在 <code>a()</code> 方法内部，当执行 <code>this.b()</code> 或直接 <code>b()</code> 时，这里的 <code>this</code> 指向的是<strong>原始的目标对象实例</strong>，而不是代理对象。因此，<code>b()</code> 方法的调用是<strong>直接的内部方法调用</strong>，完全绕过了代理对象，AOP拦截器自然也就没有机会介入来开启事务。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123; <span class="comment">// 外部调用这个方法</span></span><br><span class="line">        <span class="comment">// ...一些准备工作...</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">this</span>.placeOrder(); <span class="comment">// &lt;-- 问题所在！这里是内部调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// &lt;-- 这个事务不会生效</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...数据库操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决方案</strong>：</p>
<ol>
<li><p><strong>推荐：将事务方法移到另一个Bean中</strong>。让 <code>OrderService</code> 注入一个新的 <code>OrderPlacementService</code>，然后调用 <code>orderPlacementService.placeOrder()</code>。</p>
</li>
<li><p><strong>在同一个类中解决</strong>：注入自己。在 <code>OrderService</code> 中注入 <code>OrderService</code> 自身的一个代理实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService selfProxy; <span class="comment">// 注入自身的代理对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        selfProxy.placeOrder(); <span class="comment">// 通过代理对象调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(这种方法需要配置 <code>spring.main.allow-circular-references=true</code> 并在注入点上使用 <code>@Lazy</code>)</p>
</li>
<li><p><strong>使用 <code>AopContext.currentProxy()</code></strong>：获取当前线程绑定的代理对象来调用。<br><em>(需要开启 <code>expose-proxy=true</code>，代码侵入性较强)</em></p>
</li>
</ol>
</li>
</ul>
<hr>
<h4 id="3-3-3-异常被-try-catch-捕获且没有重新抛出"><a href="#3-3-3-异常被-try-catch-捕获且没有重新抛出" class="headerlink" title="3.3.3 异常被 try-catch 捕获且没有重新抛出"></a>3.3.3 异常被 <code>try-catch</code> 捕获且没有重新抛出</h4><ul>
<li><p><strong>现象</strong>：在 <code>@Transactional</code> 方法内部，一个可能导致回滚的异常被 <code>try-catch</code> 块捕获了，但在 <code>catch</code> 块中没有将异常重新抛出。</p>
</li>
<li><p><strong>原因</strong>：Spring的事务管理器是通过<strong>捕获从业务方法中抛出的异常</strong>来决定是否回滚事务的。如果你在方法内部把异常“吃掉”（handle）了，那么对于事务拦截器来说，这个方法就是<strong>正常返回</strong>的。既然是正常返回，它自然就会选择<strong>提交事务</strong>。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            repository.save(data1);</span><br><span class="line">            <span class="comment">// 假设这里抛出了一个 RuntimeException</span></span><br><span class="line">            <span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Something went wrong!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            repository.save(data2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// 异常被捕获了，没有继续向上抛出</span></span><br><span class="line">            log.error(<span class="string">&quot;An error occurred but we handled it.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 方法正常结束，事务将被提交！data1 的保存不会被回滚。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决方案</strong>：</p>
<ul>
<li><p>在 <code>catch</code> 块中，如果你希望触发回滚，必须将异常重新抛出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;Error occurred, rolling back.&quot;</span>, e);</span><br><span class="line">    <span class="keyword">throw</span> e; <span class="comment">// 或者 throw new MyBusinessException(e);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者，在 <code>catch</code> 块中手动设置事务为回滚状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(这种方式耦合度较高，不推荐)</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-3-4-不正确的回滚规则配置-rollbackFor"><a href="#3-3-4-不正确的回滚规则配置-rollbackFor" class="headerlink" title="3.3.4 不正确的回滚规则配置 (rollbackFor)"></a>3.3.4 不正确的回滚规则配置 (<code>rollbackFor</code>)</h4><ul>
<li><p><strong>现象</strong>：方法抛出了一个<strong>受检异常 (Checked Exception)</strong>，但事务没有回滚。</p>
</li>
<li><p><strong>原因</strong>：如前所述，Spring<strong>默认只对 <code>RuntimeException</code> 和 <code>Error</code> 进行回滚</strong>。对于普通的 <code>Exception</code> 子类（如<code>IOException</code>, <code>SQLException</code>），Spring默认认为这是业务逻辑的一部分，不应该自动回滚。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">// &lt;-- 默认配置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        repository.save(data);</span><br><span class="line">        <span class="comment">// 抛出受检异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;File not found!&quot;</span>);</span><br><span class="line">        <span class="comment">// 事务将不会回滚，data 会被提交到数据库！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解决方案</strong>：</p>
<ul>
<li>在 <code>@Transactional</code> 注解中明确使用 <code>rollbackFor</code> 属性，指定该受检异常也需要触发回滚。</li>
<li><code>@Transactional(rollbackFor = IOException.class)</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-3-5-数据库引擎不支持事务"><a href="#3-3-5-数据库引擎不支持事务" class="headerlink" title="3.3.5 数据库引擎不支持事务"></a>3.3.5 数据库引擎不支持事务</h4><ul>
<li><strong>现象</strong>：所有配置都正确，但事务就是不回滚。</li>
<li><strong>原因</strong>：你可能使用了不支持事务的数据库存储引擎。最典型的例子就是<strong>MySQL的MyISAM引擎</strong>。MyISAM引擎本身没有事务的概念，所有操作都是立即生效的，自然也就无所谓回滚。</li>
<li><strong>解决方案</strong>：<ul>
<li>检查你的数据库表结构，确保使用的存储引擎是支持事务的，如 <strong>InnoDB</strong> (MySQL的默认引擎)。</li>
<li><code>SHOW TABLE STATUS LIKE &#39;your_table_name&#39;;</code> 查看 <code>Engine</code> 列。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-3-6-总结表"><a href="#3-3-6-总结表" class="headerlink" title="3.3.6 总结表"></a>3.3.6 总结表</h4><table>
<thead>
<tr>
<th align="left">失效场景</th>
<th align="left">根本原因</th>
<th align="left">解决方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1. 非<code>public</code>方法</strong></td>
<td align="left">Spring AOP代理机制限制</td>
<td align="left">始终将<code>@Transactional</code>用在<code>public</code>方法上。</td>
</tr>
<tr>
<td align="left"><strong>2. 方法内部调用</strong></td>
<td align="left"><code>this</code>关键字调用绕过了代理对象</td>
<td align="left">将事务方法移到新Bean中；或注入自身代理。</td>
</tr>
<tr>
<td align="left"><strong>3. 异常被捕获</strong></td>
<td align="left">异常没有传播到代理层，被视为正常返回</td>
<td align="left">在<code>catch</code>块中重新抛出异常；或手动设置回滚。</td>
</tr>
<tr>
<td align="left"><strong>4. 回滚规则错误</strong></td>
<td align="left">默认不回滚受检异常(<code>Exception</code>)</td>
<td align="left">使用<code>rollbackFor</code>属性指定需要回滚的异常类型。</td>
</tr>
<tr>
<td align="left"><strong>5. 数据库引擎</strong></td>
<td align="left">底层存储引擎不支持事务</td>
<td align="left">确保使用支持事务的引擎，如MySQL的InnoDB。</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-4-编程式事务-vs-声明式事务"><a href="#3-4-编程式事务-vs-声明式事务" class="headerlink" title="3.4 编程式事务 vs 声明式事务"></a>3.4 编程式事务 vs 声明式事务</h3><h4 id="3-4-1-核心思想对比"><a href="#3-4-1-核心思想对比" class="headerlink" title="3.4.1 核心思想对比"></a>3.4.1 核心思想对比</h4><ul>
<li><strong>声明式事务 (Declarative Transaction Management)</strong><ul>
<li><strong>思想</strong>: <strong>“配置”而非“编码”</strong>。将事务管理视为一种<strong>横切关注点</strong>，通过AOP技术，将其从业务代码中完全分离。</li>
<li><strong>实现</strong>: 开发者使用注解（<code>@Transactional</code>）或XML配置来“声明”事务的边界和属性。Spring框架在运行时动态地创建代理，将事务逻辑织入到业务方法周围。</li>
<li><strong>开发者视角</strong>: 几乎感觉不到事务管理代码的存在，只需专注于业务逻辑。</li>
</ul>
</li>
<li><strong>编程式事务 (Programmatic Transaction Management)</strong><ul>
<li><strong>思想</strong>: <strong>“编码”而非“配置”</strong>。将事务管理作为业务逻辑的一部分，通过编写明确的代码来手动控制事务的生命周期。</li>
<li><strong>实现</strong>: Spring提供了一套API（主要是<code>TransactionTemplate</code>或<code>PlatformTransactionManager</code>），开发者在代码中直接调用这些API来开启、提交或回滚事务。</li>
<li><strong>开发者视角</strong>: 需要显式地编写事务控制代码，与业务逻辑混合在一起。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-4-2-编程式事务的实现方式"><a href="#3-4-2-编程式事务的实现方式" class="headerlink" title="3.4.2 编程式事务的实现方式"></a>3.4.2 编程式事务的实现方式</h4><p>Spring主要提供了两种编程式事务的实现方式。</p>
<h5 id="1-使用-TransactionTemplate-推荐的编程式方式"><a href="#1-使用-TransactionTemplate-推荐的编程式方式" class="headerlink" title="1. 使用 TransactionTemplate (推荐的编程式方式)"></a>1. 使用 <code>TransactionTemplate</code> (推荐的编程式方式)</h5><p><code>TransactionTemplate</code> 是Spring对编程式事务的封装，它使用了<strong>模板方法设计模式</strong>，简化了事务管理的样板代码。</p>
<ul>
<li><p><strong>工作方式</strong>: 你需要提供一个 <code>TransactionCallback</code> 的实现，在这个回调中编写你的业务逻辑。<code>TransactionTemplate</code> 会自动处理事务的开启、提交和异常时的回滚。</p>
</li>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProgrammaticService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 或者直接注入 TransactionTemplate</span></span><br><span class="line">    <span class="comment">// @Autowired</span></span><br><span class="line">    <span class="comment">// private TransactionTemplate transactionTemplate;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performComplexOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TransactionTemplate</span> <span class="variable">transactionTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionTemplate</span>(transactionManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// execute方法会自动处理事务</span></span><br><span class="line">        transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// --- 你的业务逻辑在这里 ---</span></span><br><span class="line">                repository.save(data1);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// ... 更多复杂的逻辑 ...</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在这个回调中，你不需要手动commit</span></span><br><span class="line">                <span class="comment">// 如果没有异常抛出，模板会自动提交</span></span><br><span class="line">                repository.save(data2);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果需要手动回滚，可以这样做</span></span><br><span class="line">                <span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">                    status.setRollbackOnly();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 抛出异常，模板会自动回滚</span></span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Operation failed&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 如果有返回值，在这里返回</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-直接使用-PlatformTransactionManager-更底层"><a href="#2-直接使用-PlatformTransactionManager-更底层" class="headerlink" title="2. 直接使用 PlatformTransactionManager (更底层)"></a>2. 直接使用 <code>PlatformTransactionManager</code> (更底层)</h5><p>这是最原始、最灵活的方式，你需要手动管理事务的每一个步骤。</p>
<ul>
<li><p><strong>代码示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLowLevelService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 定义事务属性</span></span><br><span class="line">        <span class="type">DefaultTransactionDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">        <span class="comment">// def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 开启事务</span></span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> transactionManager.getTransaction(def);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// --- 业务逻辑 ---</span></span><br><span class="line">            repository.save(data1);</span><br><span class="line">            repository.save(data2);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 手动提交</span></span><br><span class="line">            transactionManager.commit(status);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 4. 手动回滚</span></span><br><span class="line">            transactionManager.rollback(status);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Operation failed&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这种方式与原始的JDBC事务管理非常相似，只是API换成了Spring的。</p>
</li>
</ul>
<hr>
<h4 id="3-4-3-全面比较"><a href="#3-4-3-全面比较" class="headerlink" title="3.4.3 全面比较"></a>3.4.3 全面比较</h4><table>
<thead>
<tr>
<th align="left">对比维度</th>
<th align="left">声明式事务 (<code>@Transactional</code>)</th>
<th align="left">编程式事务 (<code>TransactionTemplate</code>)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>代码侵入性</strong></td>
<td align="left"><strong>极低</strong>。业务代码非常纯净，与事务逻辑完全解耦。</td>
<td align="left"><strong>较高</strong>。事务控制代码与业务逻辑紧密耦合在一起。</td>
</tr>
<tr>
<td align="left"><strong>开发效率</strong></td>
<td align="left"><strong>极高</strong>。只需一个注解即可，简单明了。</td>
<td align="left"><strong>较低</strong>。需要编写更多的样板代码。</td>
</tr>
<tr>
<td align="left"><strong>可维护性</strong></td>
<td align="left"><strong>高</strong>。事务规则集中在注解中，易于查看和修改。</td>
<td align="left"><strong>低</strong>。事务逻辑分散在代码各处，难以统一管理。</td>
</tr>
<tr>
<td align="left"><strong>粒度控制</strong></td>
<td align="left"><strong>方法级别</strong>。事务边界只能定义在整个方法的开始和结束。</td>
<td align="left"><strong>代码块级别</strong>。可以非常精细地控制事务的边界，甚至可以在一个方法内开启多个不同的事务。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left"><strong>绝大多数（99%）的业务场景</strong>。</td>
<td align="left"><strong>极少数需要精细控制事务边界的复杂场景</strong>。</td>
</tr>
<tr>
<td align="left"><strong>学习成本</strong></td>
<td align="left"><strong>低</strong>。只需理解注解和其属性即可。</td>
<td align="left"><strong>较高</strong>。需要熟悉<code>TransactionTemplate</code>或<code>PlatformTransactionManager</code>的API。</td>
</tr>
</tbody></table>
<hr>
<h4 id="3-4-4-什么时候应该考虑使用编程式事务？"><a href="#3-4-4-什么时候应该考虑使用编程式事务？" class="headerlink" title="3.4.4 什么时候应该考虑使用编程式事务？"></a>3.4.4 什么时候应该考虑使用编程式事务？</h4><p>尽管声明式事务如此优秀，但在一些极端情况下，编程式事务依然有其用武之地：</p>
<ol>
<li><strong>超细粒度的事务控制</strong>：<ul>
<li>当你需要在一个非常长的方法中，只对其中一小段代码块应用事务时。如果为整个方法开启事务，可能会导致数据库连接被长时间占用。</li>
<li><strong>示例</strong>：一个方法需要先从一个事务中读取配置数据，然后进行大量的、与数据库无关的计算（可能耗时几秒），最后再开启另一个新事务将计算结果写入数据库。</li>
</ul>
</li>
<li><strong>一个方法内涉及多个不同事务</strong>：<ul>
<li>当你需要在一个方法内，先执行一个事务并提交，然后根据其结果，再决定是否执行另一个完全独立的事务。这种场景用声明式事务很难实现。</li>
</ul>
</li>
<li><strong>动态决定事务属性</strong>：<ul>
<li>在运行时，根据不同的业务参数动态地决定事务的传播行为、隔离级别或超时时间。</li>
</ul>
</li>
</ol>
<p><strong>一个综合示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processBatch</span><span class="params">(List&lt;Item&gt; items)</span> &#123;</span><br><span class="line">    <span class="comment">// 步骤1：在一个只读事务中，加载所有需要的配置</span></span><br><span class="line">    <span class="type">TransactionTemplate</span> <span class="variable">readOnlyTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionTemplate</span>(transactionManager);</span><br><span class="line">    readOnlyTemplate.setReadOnly(<span class="literal">true</span>);</span><br><span class="line">    Map&lt;String, Config&gt; configs = readOnlyTemplate.execute(status -&gt; loadConfigs());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤2：大量的非DB计算</span></span><br><span class="line">    List&lt;Result&gt; results = performHeavyComputations(items, configs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤3：为每个结果开启一个独立的、需要新事务的写操作</span></span><br><span class="line">    <span class="type">TransactionTemplate</span> <span class="variable">requiresNewTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionTemplate</span>(transactionManager);</span><br><span class="line">    requiresNewTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Result result : results) &#123;</span><br><span class="line">        requiresNewTemplate.execute(status -&gt; &#123;</span><br><span class="line">            saveResult(result);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>这个复杂的场景，如果用声明式事务，会非常难以甚至无法实现。</em></p>
<p><strong>总结</strong></p>
<ul>
<li><strong>声明式事务</strong>是<strong>战略性</strong>工具，它定义了业务单元的宏观事务边界，是构建企业级应用的首选和标准。</li>
<li><strong>编程式事务</strong>是<strong>战术性</strong>工具，它提供了对事务的微观控制能力，是在特定、复杂的场景下解决声明式事务无法覆盖问题的“瑞士军刀”。</li>
</ul>
<p><strong>最佳实践</strong>：</p>
<p><strong>始终优先使用声明式事务。</strong> 只有当你明确遇到了声明式事务无法解决的细粒度控制问题时，才考虑在局部使用编程式事务作为补充。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/09/24/ORM%E6%A1%86%E6%9E%B6/" rel="prev" title="ORM框架">
                  <i class="fa fa-angle-left"></i> ORM框架
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/10/05/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringBoot/" rel="next" title="Spring全家桶-SpringBoot">
                  Spring全家桶-SpringBoot <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
