<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="一、JDBC 入门1. JDBC 概述1.1 定义JDBC 的全称是 Java™ Database Connectivity（Java 数据库连接）。 从本质上讲，JDBC 是由 Sun Microsystems (现为 Oracle) 定义的一套 标准的 Java API (应用程序编程接口)。这套 API 由一系列的接口（Interfaces）和类（Classes）组成，它们位于 java.s">
<meta property="og:type" content="article">
<meta property="og:title" content="JDBC">
<meta property="og:url" content="http://example.com/2025/09/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/JDBC/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="一、JDBC 入门1. JDBC 概述1.1 定义JDBC 的全称是 Java™ Database Connectivity（Java 数据库连接）。 从本质上讲，JDBC 是由 Sun Microsystems (现为 Oracle) 定义的一套 标准的 Java API (应用程序编程接口)。这套 API 由一系列的接口（Interfaces）和类（Classes）组成，它们位于 java.s">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-09-22T05:29:15.000Z">
<meta property="article:modified_time" content="2025-10-18T06:10:25.951Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/09/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/JDBC/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/09/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/JDBC/","path":"2025/09/22/数据库与持久化/JDBC/","title":"JDBC"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JDBC | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81JDBC-%E5%85%A5%E9%97%A8"><span class="nav-text">一、JDBC 入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-JDBC-%E6%A6%82%E8%BF%B0"><span class="nav-text">1. JDBC 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%AE%9A%E4%B9%89"><span class="nav-text">1.1 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-JDBC-%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E4%BC%98%E5%8A%BF"><span class="nav-text">1.2 JDBC 的作用与优势</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-JDBC-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">**1.3 JDBC 体系结构 **</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%A9%B1%E5%8A%A8%EF%BC%88Driver%EF%BC%89"><span class="nav-text">2. 驱动（Driver）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E9%A9%B1%E5%8A%A8%E7%9A%84%E8%A7%92%E8%89%B2%EF%BC%9A%E8%BF%9E%E6%8E%A5-API-%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%A1%A5%E6%A2%81"><span class="nav-text">2.1 驱动的角色：连接 API 与数据库的桥梁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-JDBC-%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="nav-text">2.2 JDBC 驱动的四种类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%A9%B1%E5%8A%A8%EF%BC%9A%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%B3%A8%E5%86%8C"><span class="nav-text">2.3 如何使用驱动：加载与注册</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="nav-text">3. 开发环境准备</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-%E5%AF%BC%E5%85%A5-JDBC-%E9%A9%B1%E5%8A%A8"><span class="nav-text">3.1 导入 JDBC 驱动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5-URL-%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3"><span class="nav-text">3.2 数据库连接 URL 格式详解</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%AC%AC%E4%B8%80%E4%B8%AA-JDBC-%E7%A8%8B%E5%BA%8F"><span class="nav-text">4. 第一个 JDBC 程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-Prerequisites"><span class="nav-text">4.1 准备工作 (Prerequisites)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-text">4.2 示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-JDBC-%E6%A0%B8%E5%BF%83%E5%85%AD%E5%A4%A7%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3"><span class="nav-text">4.3 JDBC 核心六大步骤详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="nav-text">4.4 运行结果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%9F%BA%E7%A1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">5. 基础异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E7%90%86%E8%A7%A3-SQLException"><span class="nav-text">5.1 理解 SQLException</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%E4%B8%8E-finally"><span class="nav-text">5.2 资源释放的重要性与 finally</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E7%8E%B0%E4%BB%A3%E5%8C%96%E7%9A%84%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%EF%BC%9Atry-with-resources-%E9%A2%84%E5%91%8A"><span class="nav-text">5.3 现代化的资源管理：try-with-resources (预告)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81JDBC-%E6%A0%B8%E5%BF%83-API-%E8%AF%A6%E8%A7%A3"><span class="nav-text">二、JDBC 核心 API 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-DriverManager"><span class="nav-text">1. DriverManager</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3"><span class="nav-text">1.1 核心职责</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%85%B3%E9%94%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-text">1.2 关键方法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-static-Connection-getConnection-String-url"><span class="nav-text">1.2.1 static Connection getConnection(String url)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-static-Connection-getConnection-String-url-String-user-String-password"><span class="nav-text">1.2.2 static Connection getConnection(String url, String user, String password)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-static-Connection-getConnection-String-url-java-util-Properties-info"><span class="nav-text">1.2.3 static Connection getConnection(String url, java.util.Properties info)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4-static-void-registerDriver-java-sql-Driver-driver"><span class="nav-text">1.2.4 static void registerDriver(java.sql.Driver driver)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E9%A9%B1%E5%8A%A8%E6%B3%A8%E5%86%8C%E6%9C%BA%E5%88%B6%E7%9A%84%E6%BC%94%E8%BF%9B%EF%BC%9A%E4%BB%8E-Class-forName-%E5%88%B0-SPI"><span class="nav-text">1.3 驱动注册机制的演进：从 Class.forName() 到 SPI</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F-JDBC-3-0-%E5%8F%8A%E4%BB%A5%E5%89%8D-Class-forName"><span class="nav-text">1.3.1 传统方式 (JDBC 3.0 及以前): Class.forName()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-%E7%8E%B0%E4%BB%A3%E6%96%B9%E5%BC%8F-JDBC-4-0-%E5%8F%8A%E4%BB%A5%E5%90%8E-SPI-Service-Provider-Interface"><span class="nav-text">1.3.2 现代方式 (JDBC 4.0 及以后): SPI (Service Provider Interface)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-DriverManager-vs-DataSource-%E7%8E%B0%E4%BB%A3%E5%AE%9E%E8%B7%B5"><span class="nav-text">1.4 DriverManager vs. DataSource (现代实践)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Connection"><span class="nav-text">2. Connection</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3"><span class="nav-text">2.1 核心职责</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%85%B3%E9%94%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3-%E6%8C%89%E5%8A%9F%E8%83%BD%E5%88%86%E7%BB%84"><span class="nav-text">2.2 关键方法详解 - 按功能分组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-SQL-%E6%89%A7%E8%A1%8C%E5%87%86%E5%A4%87"><span class="nav-text">2.2.1 SQL 执行准备</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Statement-createStatement"><span class="nav-text">1. Statement createStatement()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-PreparedStatement-prepareStatement-String-sql"><span class="nav-text">2. PreparedStatement prepareStatement(String sql)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-CallableStatement-prepareCall-String-sql"><span class="nav-text">3. CallableStatement prepareCall(String sql)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="nav-text">2.2.2 事务控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E4%B8%8E%E7%8A%B6%E6%80%81"><span class="nav-text">2.2.3 连接管理与状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-text">2.2.4 获取数据库元数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">2.3 生命周期与最佳实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-SQL-%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="nav-text">3. SQL 执行器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Statement-%E5%9F%BA%E6%9C%AC%E7%9A%84-SQL-%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="nav-text">3.1 Statement(基本的 SQL 执行器)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-PreparedStatement-%E6%8E%A8%E8%8D%90%E7%9A%84-SQL-%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="nav-text">3.2 PreparedStatement(推荐的 SQL 执行器)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-CallableStatement%EF%BC%9A%E4%B8%93%E4%B8%9A%E7%9A%84%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="nav-text">3.3 CallableStatement：专业的存储过程执行器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94"><span class="nav-text">3.4 总结对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-ResultSet"><span class="nav-text">4. ResultSet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9A%E8%A1%8C%E5%85%89%E6%A0%87-Cursor"><span class="nav-text">4.1 核心概念：行光标 (Cursor)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-text">4.2 核心方法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E7%A7%BB%E5%8A%A8%E5%85%89%E6%A0%87%E4%B8%8E%E9%81%8D%E5%8E%86"><span class="nav-text">4.2.1 移动光标与遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE-getXXX"><span class="nav-text">4.2.2 获取数据 (getXXX)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="nav-text">4.2.3 资源管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-ResultSet-%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%80%A7-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="nav-text">4.3 ResultSet 的类型与并发性 (高级特性)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-resultSetType-%E6%BB%9A%E5%8A%A8%E6%80%A7"><span class="nav-text">4.3.1 resultSetType (滚动性)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-resultSetConcurrency-%E5%B9%B6%E5%8F%91%E6%80%A7-%E5%8F%AF%E6%9B%B4%E6%96%B0%E6%80%A7"><span class="nav-text">4.3.2 resultSetConcurrency (并发性&#x2F;可更新性)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E5%A4%84%E7%90%86-NULL-%E5%80%BC"><span class="nav-text">4.4 处理 NULL 值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-MetaData-API"><span class="nav-text">5. MetaData API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-ResultSetMetaData"><span class="nav-text">5.1 ResultSetMetaData</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-DatabaseMetaData"><span class="nav-text">5.2 DatabaseMetaData</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E5%AE%9E%E6%88%98%EF%BC%88CRUD-Batch%EF%BC%89"><span class="nav-text">三、数据库操作实战（CRUD &amp; Batch）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C"><span class="nav-text">1. 查询操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%A0%B8%E5%BF%83%E6%AD%A5%E9%AA%A4"><span class="nav-text">1.1 核心步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%AE%9E%E6%88%98%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">1.2 实战代码示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E6%9F%A5%E8%AF%A2%E5%8D%95%E4%B8%AA%E8%AE%B0%E5%BD%95-%E6%8C%89-ID-%E6%9F%A5%E8%AF%A2"><span class="nav-text">1.2.1 查询单个记录 (按 ID 查询)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E6%9F%A5%E8%AF%A2%E5%A4%9A%E4%B8%AA%E8%AE%B0%E5%BD%95-%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E7%94%A8%E6%88%B7"><span class="nav-text">1.2.2 查询多个记录 (查询所有用户)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E5%B0%86%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84%E4%B8%BA-Java-%E5%AF%B9%E8%B1%A1-ORM-%E5%9F%BA%E7%A1%80"><span class="nav-text">1.2.3 将查询结果映射为 Java 对象 (ORM 基础)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">1.3 最佳实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%93%8D%E4%BD%9C"><span class="nav-text">2. 增删改操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%EF%BC%9Aint-executeUpdate"><span class="nav-text">2.1 核心方法：int executeUpdate()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-INSERT"><span class="nav-text">2.2 插入操作 (INSERT)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C-UPDATE"><span class="nav-text">2.3 更新操作 (UPDATE)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-DELETE"><span class="nav-text">2.4 删除操作 (DELETE)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">2.5 最佳实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C"><span class="nav-text">3. 批量操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="nav-text">3.1 核心方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%AE%9E%E6%88%98%E7%A4%BA%E4%BE%8B"><span class="nav-text">3.2 实战示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">3.3 最佳实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%EF%BC%88Transaction%EF%BC%89"><span class="nav-text">4. 事务处理（Transaction）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%BC%80%E5%85%B3"><span class="nav-text">4.1 事务的开关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%BB%88%E7%82%B9"><span class="nav-text">4.2 事务的终点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E4%BA%8B%E5%8A%A1%E4%BB%A3%E7%A0%81"><span class="nav-text">4.3 事务代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5"><span class="nav-text">四、企业级开发实践</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-text">1. 连接池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%A6%82%E8%BF%B0"><span class="nav-text">1.1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%A7%A3%E5%86%B3%E7%9A%84%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98"><span class="nav-text">1.2 解决的核心问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">1.3 工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="nav-text">1.4 核心配置参数解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E4%B8%BB%E6%B5%81%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BB%8B%E7%BB%8D"><span class="nav-text">1.5 主流连接池介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-Druid-%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">1.6 Druid 连接池配置与使用示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-%E8%BF%9E%E6%8E%A5%E6%B3%84%E6%BC%8F"><span class="nav-text">1.7 连接泄漏</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-DAO-Data-Access-Object-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">2. DAO (Data Access Object) 设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-DAO%E7%AE%80%E4%BB%8B%E4%B8%8E%E4%BC%98%E5%8A%BF"><span class="nav-text">2.1 DAO简介与优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">2.1.1 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-%E4%BC%98%E5%8A%BF"><span class="nav-text">2.1.2 优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-DAO-%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-text">2.2 DAO 模式的组成部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%AE%9E%E6%88%98"><span class="nav-text">2.3 实战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E7%AE%80%E5%8C%96"><span class="nav-text">2.4 使用反射简化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-text">五、高级主题与性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2"><span class="nav-text">1. 高级查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E5%AE%9E%E7%8E%B0-Pagination"><span class="nav-text">1.1 分页查询实现 (Pagination)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%88%86%E9%A1%B5%EF%BC%9F"><span class="nav-text">1.1.1 为什么需要分页？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E5%88%86%E9%A1%B5%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%EF%BC%9A"><span class="nav-text">1.1.2 分页的两个核心参数：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-%E5%A6%82%E4%BD%95%E7%94%A8-SQL-%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%EF%BC%9F"><span class="nav-text">1.1.3 如何用 SQL 实现分页？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-4-JDBC-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98-%E4%BB%A5-MySQL-%E4%B8%BA%E4%BE%8B"><span class="nav-text">1.1.4 JDBC 代码实战 (以 MySQL 为例)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%8A%A8%E6%80%81-SQL-%E6%9E%84%E5%BB%BA%E6%8A%80%E5%B7%A7"><span class="nav-text">1.2 动态 SQL 构建技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81-SQL%EF%BC%9F"><span class="nav-text">1.2.1 什么是动态 SQL？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E5%8D%B1%E9%99%A9%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="nav-text">1.2.2 危险的实现方式：字符串拼接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9APreparedStatement-%E6%9D%A1%E4%BB%B6%E6%8B%BC%E6%8E%A5"><span class="nav-text">1.2.3 安全的实现方式：PreparedStatement + 条件拼接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="nav-text">2. 性能优化建议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-text">2.1 使用数据库连接池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E4%BC%98%E5%85%88%E5%B9%B6%E5%A4%8D%E7%94%A8-PreparedStatement"><span class="nav-text">2.2 优先并复用 PreparedStatement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E4%BD%BF%E7%94%A8%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%A4%84%E7%90%86%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE"><span class="nav-text">2.3 使用批量操作处理大量数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E9%AB%98%E6%95%88%E5%A4%84%E7%90%86-ResultSet"><span class="nav-text">2.4 高效处理 ResultSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E4%BC%98%E5%8C%96"><span class="nav-text">2.5 事务管理优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E6%AD%A3%E7%A1%AE%E5%85%B3%E9%97%AD%E8%B5%84%E6%BA%90"><span class="nav-text">2.6 正确关闭资源</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">六、故障排查与最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">1. 常见问题与解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E8%BF%9E%E6%8E%A5%E5%BC%82%E5%B8%B8-ClassNotFoundException-SQLException"><span class="nav-text">1.1 连接异常: ClassNotFoundException &#x2F; SQLException</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-java-lang-ClassNotFoundException-com-mysql-cj-jdbc-Driver"><span class="nav-text">1.1.1 java.lang.ClassNotFoundException: com.mysql.cj.jdbc.Driver</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-java-sql-SQLException-No-suitable-driver-found-for-jdbc-mysql"><span class="nav-text">1.1.2 java.sql.SQLException: No suitable driver found for jdbc:mysql:&#x2F;&#x2F;...</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-java-sql-SQLException-Access-denied-for-user-root-localhost"><span class="nav-text">1.1.3 java.sql.SQLException: Access denied for user &#39;root&#39;@&#39;localhost&#39;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98"><span class="nav-text">1.2 中文乱码问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E8%B5%84%E6%BA%90%E6%B3%84%E9%9C%B2-Resource-Leak-%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA-OutOfMemoryError"><span class="nav-text">1.3 资源泄露 (Resource Leak) 与内存溢出 (OutOfMemoryError)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-text">2. 单元测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%BA-DAO-%E5%B1%82%E7%BC%96%E5%86%99%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-text">2.1 为什么需要为 DAO 层编写单元测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%A6%82%E4%BD%95%E9%9A%94%E7%A6%BB%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BE%9D%E8%B5%96%EF%BC%9F"><span class="nav-text">2.2 如何隔离对数据库的依赖？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%AE%9E%E6%88%98-1"><span class="nav-text">2.3 实战</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%97%A5%E5%BF%97%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="nav-text">3. 日志与调试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%97%A5%E5%BF%97%EF%BC%9F"><span class="nav-text">3.1 为什么需要日志？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%9C%A8-JDBC-%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%97%A5%E5%BF%97"><span class="nav-text">3.2 在 JDBC 代码中添加日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E4%BD%BF%E7%94%A8%E4%B8%93%E4%B8%9A%E7%9A%84-JDBC-%E6%97%A5%E5%BF%97%E4%BB%A3%E7%90%86-%E6%8B%A6%E6%88%AA%E5%99%A8-%E6%9B%B4%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">3.3 使用专业的 JDBC 日志代理&#x2F;拦截器 (更强大的方式)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-text">3.4 调试技巧</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/JDBC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JDBC | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JDBC
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-22 13:29:15" itemprop="dateCreated datePublished" datetime="2025-09-22T13:29:15+08:00">2025-09-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-18 14:10:25" itemprop="dateModified" datetime="2025-10-18T14:10:25+08:00">2025-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">数据库与持久化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="一、JDBC-入门"><a href="#一、JDBC-入门" class="headerlink" title="一、JDBC 入门"></a>一、JDBC 入门</h1><h2 id="1-JDBC-概述"><a href="#1-JDBC-概述" class="headerlink" title="1. JDBC 概述"></a>1. JDBC 概述</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><strong>JDBC</strong> 的全称是 <strong>Java™ Database Connectivity</strong>（Java 数据库连接）。</p>
<p>从本质上讲，JDBC 是由 Sun Microsystems (现为 Oracle) 定义的一套 <strong>标准的 Java API (应用程序编程接口)</strong>。这套 API 由一系列的接口（Interfaces）和类（Classes）组成，它们位于 <code>java.sql</code> 和 <code>javax.sql</code> 包中。</p>
<p><strong>核心思想：</strong> JDBC 的目标是为 Java 程序员提供一种 <strong>统一的、与具体数据库无关的</strong> 方式来访问和操作数据库。</p>
<hr>
<h3 id="1-2-JDBC-的作用与优势"><a href="#1-2-JDBC-的作用与优势" class="headerlink" title="1.2 JDBC 的作用与优势"></a>1.2 JDBC 的作用与优势</h3><p>JDBC 的主要作用是充当 <strong>Java 应用程序</strong> 和 <strong>数据库</strong> 之间的桥梁。它的存在带来了诸多优势：</p>
<ol>
<li><strong>数据库无关性 (Database Independence)</strong><br>这是 JDBC 最核心的优势。你的 Java 代码是面向 JDBC 接口编写的，而不是面向某个特定的数据库。这意味着，如果项目需要从 MySQL 数据库迁移到 Oracle 数据库，理论上你只需要更换数据库驱动 JAR 包和修改数据库连接信息，而业务逻辑代码几乎不需要改动。这大大提高了代码的<strong>可移植性</strong>和<strong>灵活性</strong>，避免了“厂商锁定”。</li>
<li><strong>标准统一 (Standardization)</strong><br>JDBC 是 Java SE 平台的核心组成部分。所有主流的数据库厂商（Oracle, Microsoft, IBM, MySQL 等）都遵循 JDBC 规范，并提供相应的数据库驱动程序。这使得开发者可以用一套统一的、熟悉的方式来操作各种关系型数据库，降低了学习成本。</li>
<li><strong>简单易用 (Simplicity)</strong><br>JDBC API 设计得相对直观。对于常见的数据库操作（CRUD），其基本步骤清晰明了：<ul>
<li>加载驱动</li>
<li>建立连接</li>
<li>创建执行对象</li>
<li>执行 SQL 语句</li>
<li>处理结果集</li>
<li>释放资源</li>
</ul>
</li>
<li><strong>功能强大 (Powerful Features)</strong><br>除了基本的查询和更新，JDBC 还提供了丰富的高级功能，以满足复杂应用的需求，例如：<ul>
<li><strong>事务管理</strong>：支持手动提交、回滚和保存点，保证数据的一致性。</li>
<li><strong>批处理</strong>：可以一次性向数据库发送多条 SQL 语句，显著提升性能。</li>
<li><strong>调用存储过程</strong>：能够执行数据库中预先定义好的复杂逻辑。</li>
<li><strong>元数据处理</strong>：可以获取关于数据库、表、列等的详细信息。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="1-3-JDBC-体系结构"><a href="#1-3-JDBC-体系结构" class="headerlink" title="**1.3 JDBC 体系结构 **"></a>**1.3 JDBC 体系结构 **</h5><p>JDBC 的体系结构是分层的，主要包含四个核心组件，它们协同工作，完成从 Java 应用到数据库的通信。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------+</span><br><span class="line">|     Java 应用程序          |  &lt;-- 开发者编写的业务代码</span><br><span class="line">+---------------------------+</span><br><span class="line">             |</span><br><span class="line">             | (调用)</span><br><span class="line">             V</span><br><span class="line">+---------------------------+</span><br><span class="line">|        JDBC API           |  &lt;-- Java 提供的标准接口 (Connection, Statement, etc.)</span><br><span class="line">+---------------------------+</span><br><span class="line">             |</span><br><span class="line">             | (委托)</span><br><span class="line">             V</span><br><span class="line">+---------------------------+</span><br><span class="line">|      JDBC 驱动管理器       |   &lt;-- DriverManager, 负责管理和选择驱动</span><br><span class="line">+---------------------------+</span><br><span class="line">             |</span><br><span class="line">             | (使用)</span><br><span class="line">             V</span><br><span class="line">+---------------------------+  +---------------------------+  +---------------------------+</span><br><span class="line">|        MySQL 驱动          |  |       Oracle 驱动         |  |      PostgreSQL 驱动       |  &lt;-- 各数据库厂商实现的具体逻辑</span><br><span class="line">+---------------------------+  +---------------------------+  +---------------------------+</span><br><span class="line">             |                              |                              |</span><br><span class="line">             | (通信)                        | (通信)                       | (通信)</span><br><span class="line">             V                              V                              V</span><br><span class="line">+---------------------------+  +---------------------------+  +---------------------------+</span><br><span class="line">|        MySQL 数据库        |  |       Oracle 数据库        |  |      PostgreSQL 数据库     |</span><br><span class="line">+---------------------------+  +---------------------------+  +---------------------------+</span><br></pre></td></tr></table></figure>

<p><strong>四个核心组件的角色：</strong></p>
<ol>
<li><strong>Java 应用程序 (Java Application)</strong><br>这是最顶层，即我们编写的业务代码。我们的代码通过调用 JDBC API 来执行数据库操作，而无需关心底层是如何实现的。</li>
<li><strong>JDBC API</strong><br>这是 Java 平台提供的一套标准接口和类，是程序员直接交互的层面。它定义了“能做什么”，例如 <code>Connection</code> 接口定义了如何建立连接、提交事务，<code>Statement</code> 接口定义了如何执行 SQL。但它不关心“如何做”。</li>
<li><strong>JDBC 驱动管理器 (Driver Manager)</strong><br><code>DriverManager</code> 是一个工厂类，扮演着“交通警察”的角色。它的主要职责是：<ul>
<li><strong>管理驱动</strong>：跟踪所有已注册的 JDBC 驱动。</li>
<li><strong>选择驱动</strong>：当应用程序请求建立连接时 (<code>DriverManager.getConnection(url, ...)</code>), 它会根据传入的数据库 URL (<code>jdbc:mysql://...</code>) 格式，智能地选择一个合适的驱动来处理这个请求。</li>
</ul>
</li>
<li><strong>JDBC 驱动 (JDBC Driver)</strong><br>这是体系结构中最关键的部分，由数据库厂商提供。驱动是 <strong>JDBC 接口的具体实现</strong>。例如，MySQL 提供的 <code>mysql-connector-java.jar</code> 就是一个 JDBC 驱动。它内部包含了将标准的 JDBC API 调用转换为 MySQL 数据库原生通信协议的代码。正是因为有了它，<code>DriverManager</code> 才能真正连接到数据库并执行操作。</li>
</ol>
<p>**工作流程总结：**应用程序想连接数据库 -&gt; 调用 <code>DriverManager.getConnection()</code> -&gt; <code>DriverManager</code> 找到能处理该 URL 的特定驱动（如 MySQL 驱动） -&gt; 该驱动与真实的 MySQL 数据库建立网络连接 -&gt; 驱动创建一个实现了 <code>Connection</code> 接口的实例对象并返回给应用程序 -&gt; 应用程序通过这个 <code>Connection</code> 对象执行 SQL，所有调用都会被该驱动“翻译”并发送给数据库。</p>
<hr>
<h2 id="2-驱动（Driver）"><a href="#2-驱动（Driver）" class="headerlink" title="2. 驱动（Driver）"></a>2. 驱动（Driver）</h2><h3 id="2-1-驱动的角色：连接-API-与数据库的桥梁"><a href="#2-1-驱动的角色：连接-API-与数据库的桥梁" class="headerlink" title="2.1 驱动的角色：连接 API 与数据库的桥梁"></a><strong>2.1 驱动的角色：连接 API 与数据库的桥梁</strong></h3><p>一个 <strong>JDBC 驱动</strong> 本质上是一个实现了 <code>java.sql.Driver</code> 接口的 Java 类库（通常以 <code>.jar</code> 文件形式提供）。它由数据库厂商（如 Oracle, MySQL）或第三方组织开发，并专门为某一种数据库服务。</p>
<p><strong>其核心职责包括：</strong></p>
<ol>
<li><strong>连接管理</strong>：接收来自 <code>DriverManager</code> 的请求，使用特定数据库的协议和认证方式，与数据库服务器建立一个网络连接。</li>
<li><strong>指令翻译</strong>：将 Java 代码中标准的 SQL 语句（如 <code>SELECT * FROM users</code>）和 JDBC API 调用（如 <code>statement.executeQuery()</code>）转换成数据库服务器能够执行的底层命令。</li>
<li><strong>数据转换</strong>：将从数据库返回的数据（通常是二进制格式的表格数据）解析并转换为 Java 中对应的数据类型（如 <code>String</code>, <code>int</code>, <code>Date</code>）和对象（如 <code>ResultSet</code>）。</li>
<li><strong>异常映射</strong>：将数据库返回的特定错误码或异常信息，包装成标准的 <code>java.sql.SQLException</code> 及其子类，供 Java 应用程序捕获和处理。</li>
</ol>
<hr>
<h3 id="2-2-JDBC-驱动的四种类型"><a href="#2-2-JDBC-驱动的四种类型" class="headerlink" title="2.2 JDBC 驱动的四种类型"></a><strong>2.2 JDBC 驱动的四种类型</strong></h3><p>根据其实现方式和架构，JDBC 规范定义了四种类型的驱动。了解它们的演进有助于理解为什么现代开发几乎只使用一种类型。</p>
<p><strong>类型 1：JDBC-ODBC 桥 (JDBC-ODBC Bridge)</strong></p>
<ul>
<li><strong>架构</strong>: <code>Java App -&gt; JDBC API -&gt; JDBC-ODBC Bridge Driver -&gt; ODBC Driver -&gt; Database</code></li>
<li><strong>原理</strong>: 这是最早期的驱动类型。它将 JDBC 调用转换为对 <strong>ODBC (Open Database Connectivity)</strong> API 的调用。ODBC 是一个主要用于 C&#x2F;C++ 语言的数据库访问标准。这意味着，客户端机器上必须安装并配置好特定数据库的 ODBC 驱动。</li>
<li><strong>优点</strong>: 早期可以快速连接到任何支持 ODBC 的数据库。</li>
<li><strong>缺点</strong>:<ul>
<li><strong>性能差</strong>: 调用链条长，涉及 JDBC 到 ODBC 的转换，效率低下。</li>
<li><strong>依赖平台</strong>: 依赖于本地的 ODBC 驱动，降低了 Java 的“一次编写，到处运行”的跨平台特性。</li>
<li><strong>部署复杂</strong>: 需要在每台客户端机器上安装和配置 ODBC 驱动。</li>
</ul>
</li>
<li><strong>现状</strong>: <strong>已废弃</strong>。从 Java 8 开始，Oracle 已将 JDBC-ODBC 桥从 JDK 中移除。它仅具有历史意义。</li>
</ul>
<p><strong>类型 2：本地 API 驱动 (Native-API Driver)</strong></p>
<ul>
<li><strong>架构</strong>: <code>Java App -&gt; JDBC API -&gt; Native-API Driver -&gt; Vendor&#39;s Native Client Library -&gt; Database</code></li>
<li><strong>原理</strong>: 这种驱动部分由 Java 编写，部分由本地代码（C&#x2F;C++）编写。它通过调用数据库厂商提供的本地客户端库（如 Oracle 的 OCI - Oracle Call Interface）来与数据库通信。</li>
<li><strong>优点</strong>: 相比类型 1，性能有显著提升，因为它绕过了 ODBC。</li>
<li><strong>缺点</strong>:<ul>
<li><strong>非纯 Java</strong>: 含有本地代码，丧失了完全的平台无关性。</li>
<li><strong>部署复杂</strong>: 同样需要在客户端机器上安装数据库厂商的本地客户端库。</li>
<li><strong>厂商绑定</strong>: 驱动与特定的客户端库版本紧密耦合。</li>
</ul>
</li>
<li><strong>现状</strong>: 很少使用，通常只在某些特定环境或需要利用本地库特有功能的场景下使用。</li>
</ul>
<p><strong>类型 3：网络协议驱动 (Network-Protocol Driver)</strong></p>
<ul>
<li><strong>架构</strong>: <code>Java App -&gt; JDBC API -&gt; Net-Protocol Driver -&gt; Middleware Server -&gt; Database</code></li>
<li><strong>原理</strong>: 这是一个纯 Java 驱动，它不直接与数据库通信，而是通过一个<strong>中间件服务器 (Middleware)</strong>。应用程序通过网络向中间件发送与数据库无关的请求，中间件再将这些请求翻译成特定数据库的协议并转发给数据库。</li>
<li><strong>优点</strong>:<ul>
<li><strong>纯 Java</strong>: 客户端非常轻量，不需要安装任何本地库。</li>
<li><strong>灵活性高</strong>: 中间件可以提供额外的服务，如负载均衡、连接池、缓存和安全认证。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>架构复杂</strong>: 引入了额外的中间件层，增加了配置、管理和维护的成本。</li>
<li><strong>性能瓶颈</strong>: 中间件可能成为系统的单点故障或性能瓶颈。</li>
<li><strong>通常是商业产品</strong>，需要额外付费。</li>
</ul>
</li>
<li><strong>现状</strong>: 在复杂的企业级分布式计算环境中有一些应用，但对于大多数项目而言不是首选。</li>
</ul>
<p><strong>类型 4：原生协议驱动 (Native-Protocol Driver &#x2F; Thin Driver)</strong></p>
<ul>
<li><strong>架构</strong>: <code>Java App -&gt; JDBC API -&gt; Native-Protocol Driver -&gt; Database</code></li>
<li><strong>原理</strong>: 这是<strong>纯 Java</strong>实现的驱动。它直接将 JDBC 调用转换为数据库厂商所使用的原生网络通信协议。驱动本身就“知道”如何直接与数据库服务器的监听端口进行对话。</li>
<li><strong>优点</strong>:<ul>
<li><strong>纯 Java</strong>: 实现了完全的平台无关性，真正做到“一次编写，到处运行”。</li>
<li><strong>部署简单</strong>: 只需要将一个 <code>.jar</code> 文件添加到项目的 classpath 中即可，无需任何客户端安装。</li>
<li><strong>性能最佳</strong>: 调用路径最短，直接与数据库通信，没有额外的转换或中间层。</li>
<li><strong>易于管理</strong>: 无需维护客户端软件。</li>
</ul>
</li>
<li><strong>现状</strong>: <strong>现代 Java 开发的绝对主流和行业标准</strong>。几乎所有主流数据库（MySQL, Oracle, PostgreSQL, SQL Server 等）都提供 Type 4 驱动。我们通常称之为“瘦客户端驱动 (Thin Driver)”。</li>
</ul>
<p><strong>总结对比表</strong></p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">实现方式</th>
<th align="left">平台依赖</th>
<th align="left">部署</th>
<th align="left">性能</th>
<th align="left">当前状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Type 1</strong></td>
<td align="left">JDBC-ODBC 桥</td>
<td align="left">依赖 ODBC</td>
<td align="left">复杂</td>
<td align="left">差</td>
<td align="left"><strong>已废弃</strong></td>
</tr>
<tr>
<td align="left"><strong>Type 2</strong></td>
<td align="left">Java + 本地库</td>
<td align="left">依赖本地库</td>
<td align="left">复杂</td>
<td align="left">较好</td>
<td align="left">很少使用</td>
</tr>
<tr>
<td align="left"><strong>Type 3</strong></td>
<td align="left">纯 Java (通过中间件)</td>
<td align="left">无</td>
<td align="left">中等 (需配置中间件)</td>
<td align="left">取决于中间件</td>
<td align="left">特定场景使用</td>
</tr>
<tr>
<td align="left"><strong>Type 4</strong></td>
<td align="left"><strong>纯 Java (直接通信)</strong></td>
<td align="left"><strong>无</strong></td>
<td align="left"><strong>简单 (只需 JAR)</strong></td>
<td align="left"><strong>最佳</strong></td>
<td align="left"><strong>行业标准</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="2-3-如何使用驱动：加载与注册"><a href="#2-3-如何使用驱动：加载与注册" class="headerlink" title="2.3 如何使用驱动：加载与注册"></a><strong>2.3 如何使用驱动：加载与注册</strong></h3><p>在早期的 JDBC（4.0 以前）中，我们需要手动加载驱动类到 JVM 中。</p>
<p><strong>传统方式 (JDBC 4.0 之前): <code>Class.forName()</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 手动加载 MySQL 驱动类</span></span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>); <span class="comment">// 对于 MySQL 5.x</span></span><br><span class="line">    <span class="comment">// Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); // 对于 MySQL 8.x</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这行代码利用 Java 的反射机制，将驱动类的 <code>.class</code> 文件加载到内存中。该驱动类的静态代码块（<code>static { ... }</code>）会自动执行，在这个代码块里，驱动实例会调用 <code>DriverManager.registerDriver(new Driver())</code> 将自己注册到 <code>DriverManager</code> 中。</p>
<p><strong>现代方式 (JDBC 4.0 及以后): 自动注册 (SPI机制)</strong></p>
<p>从 JDBC 4.0 开始，驱动的加载过程实现了自动化，我们<strong>不再需要</strong>显式调用 <code>Class.forName()</code>。</p>
<p>这是通过 <strong>SPI (Service Provider Interface)</strong> 机制实现的。符合 JDBC 4.0 规范的驱动 JAR 包中，会包含一个 <code>META-INF/services/java.sql.Driver</code> 文件。这个文件的内容就是驱动主类的全限定名，例如：<code>com.mysql.cj.jdbc.Driver</code>，当我们的应用程序启动时，<code>DriverManager</code> 会自动扫描 classpath，找到所有符合这个规范的 JAR 包，读取这个文件，并自动加载和注册其中指定的驱动类。</p>
<p><strong>因此，在现代开发中，只需要确保数据库驱动的 JAR 包在你的项目依赖中（例如通过 Maven 或 Gradle 添加），连接过程就会自动完成，无需任何手动加载代码。</strong></p>
<hr>
<h2 id="3-开发环境准备"><a href="#3-开发环境准备" class="headerlink" title="3. 开发环境准备"></a>3. 开发环境准备</h2><h5 id="3-1-导入-JDBC-驱动"><a href="#3-1-导入-JDBC-驱动" class="headerlink" title="3.1 导入 JDBC 驱动"></a><strong>3.1 导入 JDBC 驱动</strong></h5><p>要让 Java 程序使用 JDBC 驱动，必须将驱动的 JAR 文件添加到项目的 <strong>Classpath</strong> (类路径) 中。Classpath 是 JVM 用来搜索类和资源的路径集合。</p>
<p>目前主流的导入方式有两种：使用构建工具（推荐）和手动导入。</p>
<p><strong>方式一：使用构建工具 (Maven &#x2F; Gradle) - 推荐</strong></p>
<p>在企业开发中，所有项目都是使用 Maven 或 Gradle 等构建工具来管理项目依赖。你只需要在项目的构建配置文件中（<code>pom.xml</code> for Maven, <code>build.gradle</code> for Gradle）添加相应的依赖项即可。</p>
<p><strong>示例：</strong></p>
<ol>
<li><p><strong>MySQL 驱动 (<code>mysql-connector-j</code>)</strong></p>
<ul>
<li><p><strong>Maven (<code>pom.xml</code>):</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 使用你需要的版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Gradle (<code>build.gradle</code>):</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.mysql:mysql-connector-j:8.0.33&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Oracle 驱动 (<code>ojdbc</code>)</strong></p>
<ul>
<li><p>Oracle 的驱动可能不在公共的 Maven 中央仓库，但通常可以从 Oracle 自己的仓库或可信的第三方仓库获取。</p>
</li>
<li><p><strong>Maven (<code>pom.xml</code>):</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.oracle.database.jdbc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ojdbc11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> <span class="comment">&lt;!-- ojdbc11 对应 JDK 11+, ojdbc8 对应 JDK 8+ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>21.9.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Gradle (<code>build.gradle</code>):</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.oracle.database.jdbc:ojdbc11:21.9.0.0&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>PostgreSQL 驱动</strong></p>
<ul>
<li><p><strong>Maven (<code>pom.xml</code>):</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.postgresql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>postgresql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>42.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Gradle (<code>build.gradle</code>):</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.postgresql:postgresql:42.6.0&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>方式二：手动导入 JAR 包</strong></p>
<p>如果你未使用构建工具（例如在学习阶段或简单的桌面应用中），可以手动下载驱动 JAR 文件并添加到项目中。</p>
<ol>
<li><strong>下载驱动</strong>:<ul>
<li><strong>MySQL</strong>: 前往 <a target="_blank" rel="noopener" href="https://dev.mysql.com/downloads/connector/j/">MySQL Community Downloads</a> 页面，选择 “Platform Independent”，下载 ZIP 或 TAR.GZ 压缩包，解压后找到 <code>mysql-connector-j-x.x.x.jar</code>。</li>
<li><strong>Oracle</strong>: 前往 <a target="_blank" rel="noopener" href="https://www.oracle.com/database/technologies/jdbc-ucp-19c-downloads.html">Oracle JDBC Driver Downloads</a> 页面下载对应版本的 <code>ojdbcX.jar</code>。</li>
<li><strong>PostgreSQL</strong>: 前往 <a target="_blank" rel="noopener" href="https://jdbc.postgresql.org/download/">PostgreSQL JDBC Driver Downloads</a> 页面下载 JAR 文件。</li>
</ul>
</li>
<li><strong>添加到项目</strong>:<ul>
<li>在你的项目根目录下创建一个 <code>lib</code> (或 <code>libs</code>) 文件夹。</li>
<li>将下载好的 JAR 文件复制到这个 <code>lib</code> 文件夹中。</li>
<li>在你的 IDE (如 IntelliJ IDEA) 中，将这个 JAR 文件添加到项目的构建路径中。<ul>
<li><strong>IntelliJ IDEA</strong>: 右键点击 JAR 文件 -&gt; <code>Add as Library...</code> -&gt; 选择模块并确认。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="3-2-数据库连接-URL-格式详解"><a href="#3-2-数据库连接-URL-格式详解" class="headerlink" title="3.2 数据库连接 URL 格式详解"></a><strong>3.2 数据库连接 URL 格式详解</strong></h5><p>数据库连接 URL 是一个特殊格式的字符串，它为 <code>DriverManager</code> 提供了连接数据库所需的所有信息。它就像一个数据库的“地址”。</p>
<p><strong>通用格式:</strong><code>jdbc:&lt;subprotocol&gt;://&lt;hostname&gt;:&lt;port&gt;/&lt;databaseName&gt;?&lt;property1&gt;=&lt;value1&gt;&amp;&lt;property2&gt;=&lt;value2&gt;</code></p>
<ul>
<li><strong><code>jdbc:</code></strong>: JDBC URL 的标准前缀，固定不变。</li>
<li><strong><code>&lt;subprotocol&gt;</code></strong>: 子协议，用于标识特定的数据库类型，例如 <code>mysql</code>, <code>oracle</code>, <code>postgresql</code>。<code>DriverManager</code> 就是根据这个来选择正确的驱动。</li>
<li><strong><code>&lt;hostname&gt;</code></strong>: 数据库服务器的主机名或 IP 地址。如果是本地数据库，通常使用 <code>localhost</code> 或 <code>127.0.0.1</code>。</li>
<li><strong><code>&lt;port&gt;</code></strong>: 数据库服务器监听连接的端口号。每种数据库都有一个默认端口。</li>
<li><strong><code>&lt;databaseName&gt;</code></strong>: 要连接的具体数据库、模式或服务名。</li>
<li><strong><code>?&lt;properties&gt;</code></strong>: 可选参数，用于提供额外的连接配置，以 <code>key=value</code> 形式给出，多个参数用 <code>&amp;</code> 分隔。</li>
</ul>
<p><strong>常见数据库 URL 示例与详解:</strong></p>
<ol>
<li><p><strong>MySQL</strong></p>
<ul>
<li><p><strong>默认端口</strong>: <code>3306</code></p>
</li>
<li><p><strong>基本格式</strong>: <code>jdbc:mysql://&lt;hostname&gt;:&lt;port&gt;/&lt;databaseName&gt;</code></p>
</li>
<li><p><strong>示例</strong>:<code>jdbc:mysql://localhost:3306/my_db</code></p>
</li>
<li><p><strong>带有推荐参数的完整示例 (MySQL 8.x):</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://localhost:3306/my_db?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf8</span><br></pre></td></tr></table></figure>

<ul>
<li><code>useSSL=false</code>: 在开发环境中通常关闭 SSL 连接以避免警告。</li>
<li><code>serverTimezone=UTC</code>: <strong>非常重要！</strong> 建议显式设置时区，以避免因服务器、客户端、JVM 时区不一致导致的 <code>java.sql.SQLException: The server time zone ... is not recognized</code> 错误。也可以设置为 <code>Asia/Shanghai</code>。</li>
<li><code>characterEncoding=utf8</code>: 确保在数据传输过程中正确处理中文字符，防止乱码。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Oracle</strong></p>
<ul>
<li><strong>默认端口</strong>: <code>1521</code></li>
<li>Oracle 的连接方式主要有两种：SID 和 Service Name。</li>
<li><strong>a) SID (System Identifier) 格式 (旧式&#x2F;简单环境):</strong><ul>
<li><strong>格式</strong>: <code>jdbc:oracle:thin:@&lt;hostname&gt;:&lt;port&gt;:&lt;SID&gt;</code></li>
<li><strong>示例</strong>: <code>jdbc:oracle:thin:@localhost:1521:XE</code> (XE 是 Oracle Express Edition 的默认 SID)</li>
</ul>
</li>
<li><strong>b) Service Name 格式 (推荐&#x2F;RAC环境):</strong><ul>
<li><strong>格式</strong>: <code>jdbc:oracle:thin:@//&lt;hostname&gt;:&lt;port&gt;/&lt;serviceName&gt;</code></li>
<li><strong>注意</strong>: 主机名前有两个斜杠 <code>//</code>，并且 SID 的分隔符 <code>:</code> 变成了 <code>/</code>。</li>
<li><strong>示例</strong>: <code>jdbc:oracle:thin:@//localhost:1521/orclpdb</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>PostgreSQL</strong></p>
<ul>
<li><strong>默认端口</strong>: <code>5432</code></li>
<li><strong>基本格式</strong>: <code>jdbc:postgresql://&lt;hostname&gt;:&lt;port&gt;/&lt;databaseName&gt;</code></li>
<li><strong>示例</strong>:<br><code>jdbc:postgresql://localhost:5432/my_postgres_db</code></li>
<li><strong>带模式(schema)的示例</strong>:<br><code>jdbc:postgresql://localhost:5432/my_postgres_db?currentSchema=public</code></li>
</ul>
</li>
</ol>
<hr>
<h2 id="4-第一个-JDBC-程序"><a href="#4-第一个-JDBC-程序" class="headerlink" title="4. 第一个 JDBC 程序"></a>4. 第一个 JDBC 程序</h2><h3 id="4-1-准备工作-Prerequisites"><a href="#4-1-准备工作-Prerequisites" class="headerlink" title="4.1 准备工作 (Prerequisites)"></a>4.1 准备工作 (Prerequisites)</h3><p>在运行代码之前，请确保你已经完成了以下准备：</p>
<ol>
<li><p><strong>数据库和表已创建</strong>：</p>
<ul>
<li><p>在你的 MySQL 数据库中，创建一个名为 <code>my_db</code> 的数据库。</p>
</li>
<li><p>在该数据库中，执行以下 SQL 语句创建 <code>users</code> 表并插入一些示例数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> users (name, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;alice@example.com&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;bob@example.com&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;charlie@example.com&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>JDBC 驱动已导入</strong>：</p>
<ul>
<li>确保 MySQL 的 JDBC 驱动 JAR 包（例如 <code>mysql-connector-j-8.0.33.jar</code>）已经按照上一节的方法添加到了你的项目类路径 (Classpath) 中。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-2-示例代码"><a href="#4-2-示例代码" class="headerlink" title="4.2 示例代码"></a>4.2 示例代码</h3><p>下面是一个完整的 Java 类，它演示了 JDBC 的基本操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcHelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 定义数据库连接参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dbUrl</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/my_db?serverTimezone=UTC&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dbUser</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>; <span class="comment">// 替换为你的数据库用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dbPassword</span> <span class="operator">=</span> <span class="string">&quot;your_password&quot;</span>; <span class="comment">// 替换为你的数据库密码</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 加载并注册驱动 (在JDBC 4.0+中，此步骤通常是自动的，可以省略)</span></span><br><span class="line">            <span class="comment">// Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 获取数据库连接 (Connection)</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Connecting to database...&quot;</span>);</span><br><span class="line">            connection = DriverManager.getConnection(dbUrl, dbUser, dbPassword);</span><br><span class="line">            System.out.println(<span class="string">&quot;Connection successful!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 创建执行 SQL 的对象 (Statement)</span></span><br><span class="line">            statement = connection.createStatement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 执行 SQL 查询，并获取结果集 (ResultSet)</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, email FROM users&quot;</span>;</span><br><span class="line">            resultSet = statement.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. 遍历结果集，处理数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Users in database:&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">                <span class="comment">// 根据列名或列索引(从1开始)获取数据</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;email&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 打印结果</span></span><br><span class="line">                System.out.println(<span class="string">&quot;ID: &quot;</span> + id + <span class="string">&quot;, Name: &quot;</span> + name + <span class="string">&quot;, Email: &quot;</span> + email);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace(); <span class="comment">// 打印详细的异常信息</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7. 释放资源 (至关重要！)</span></span><br><span class="line">            <span class="comment">// 按照 &quot;后开先关&quot; 的原则，依次关闭</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Closing resources...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (resultSet != <span class="literal">null</span>) &#123;</span><br><span class="line">                    resultSet.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (statement != <span class="literal">null</span>) &#123;</span><br><span class="line">                    statement.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Resources closed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-JDBC-核心六大步骤详解"><a href="#4-3-JDBC-核心六大步骤详解" class="headerlink" title="4.3 JDBC 核心六大步骤详解"></a><strong>4.3 JDBC 核心六大步骤详解</strong></h3><p>上面的代码清晰地展示了使用 JDBC 的标准流程，可以总结为以下六个步骤：</p>
<p><strong>第 1 步：定义连接参数</strong></p>
<p>这是准备工作，我们将 URL、用户名和密码存储在变量中，便于管理和修改。</p>
<p><strong>第 2 步：加载并注册驱动</strong> (可选)</p>
<p><code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</code></p>
<ul>
<li><strong>作用</strong>: 告诉 JVM 加载这个驱动类。</li>
<li><strong>现状</strong>: 在现代 JDBC 4.0+ 规范下，由于 SPI 自动注册机制，<code>DriverManager</code> 能自动发现并加载 classpath 中的驱动。因此，<strong>这行代码通常可以省略</strong>。</li>
</ul>
<p><strong>第 3 步：获取数据库连接</strong></p>
<p><code>connection = DriverManager.getConnection(dbUrl, dbUser, dbPassword);</code></p>
<ul>
<li><strong>核心</strong>: 这是 JDBC 的入口点。</li>
<li><code>DriverManager</code> 类会根据 <code>dbUrl</code> (<code>jdbc:mysql://...</code>) 找到已注册的 MySQL 驱动。</li>
<li>然后委托该驱动与数据库服务器建立一个网络连接。</li>
<li>如果连接成功，它会返回一个 <code>Connection</code> 对象。这个对象代表了你的 Java 程序与数据库之间的一个活动会话。如果失败（如密码错误、数据库未启动），则会抛出 <code>SQLException</code>。</li>
</ul>
<p><strong>第 4 步：创建执行 SQL 的对象</strong></p>
<p><code>statement = connection.createStatement();</code></p>
<ul>
<li><strong>作用</strong>: <code>Connection</code> 对象本身不能直接执行 SQL。你需要通过它创建一个 “SQL 运载工具”，即 <code>Statement</code> 对象。</li>
<li><code>Statement</code> 对象用于发送简单的、不带参数的 SQL 语句到数据库。</li>
</ul>
<p><strong>第 5 步：执行 SQL 并获取结果集</strong></p>
<p><code>resultSet = statement.executeQuery(sql);</code></p>
<ul>
<li><strong><code>executeQuery(String sql)</code></strong>: 这个方法专门用于执行 <strong>查询语句 (SELECT)</strong>。</li>
<li><strong><code>ResultSet</code> 对象</strong>: 如果查询成功，会返回一个 <code>ResultSet</code> 对象。你可以把 <code>ResultSet</code> 想象成一个指向查询结果数据表格的 <strong>“行指针”或“游标”</strong>。初始时，这个指针位于第一行数据之前。</li>
</ul>
<p><strong>第 6 步：遍历结果集，处理数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">    <span class="comment">// ... 获取数据 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>resultSet.next()</code></strong>: 这是一个非常重要的方法。它有两个作用：<ol>
<li>尝试将指针移动到下一行。</li>
<li>如果下一行存在数据，则返回 <code>true</code>；如果已经没有更多行（到达数据末尾），则返回 <code>false</code>。</li>
</ol>
</li>
<li><code>while</code> 循环完美地利用了这个特性来遍历所有查询结果。</li>
<li><strong><code>resultSet.getXXX(&quot;columnName&quot;)</code> 或 <code>resultSet.getXXX(columnIndex)</code></strong>: 在循环内部，我们使用 <code>get</code> 系列方法从当前行中提取数据。<ul>
<li><code>getInt(&quot;id&quot;)</code>: 获取名为 <code>id</code> 的列的 <code>int</code> 类型值。</li>
<li><code>getString(&quot;name&quot;)</code>: 获取名为 <code>name</code> 的列的 <code>String</code> 类型值。</li>
<li>使用列名更具可读性，使用列索引（从 1 开始，不是 0！）在某些情况下性能稍好。</li>
</ul>
</li>
</ul>
<p><strong>第 7 步 (在 <code>finally</code> 块中)：释放资源</strong></p>
<ul>
<li><strong>为什么至关重要</strong>: <code>Connection</code>, <code>Statement</code>, <code>ResultSet</code> 都是非常宝贵的资源，它们占用了数据库连接和内存。<strong>如果不显式关闭它们，会导致资源泄露</strong>。当大量连接不被释放时，最终会耗尽数据库的连接数，导致整个应用无法连接数据库。</li>
<li><strong>为什么在 <code>finally</code> 块中</strong>: <code>finally</code> 块确保了无论 <code>try</code> 块中的代码是否发生异常，资源关闭的逻辑 <strong>总会被执行</strong>。</li>
<li><strong>关闭顺序</strong>: 遵循 <strong>“后开先关”</strong> 的原则：<code>ResultSet</code> -&gt; <code>Statement</code> -&gt; <code>Connection</code>。因为 <code>Statement</code> 依赖 <code>Connection</code>，<code>ResultSet</code> 依赖 <code>Statement</code>。</li>
</ul>
<hr>
<h3 id="4-4-运行结果"><a href="#4-4-运行结果" class="headerlink" title="4.4 运行结果"></a><strong>4.4 运行结果</strong></h3><p>如果你正确配置了所有内容，运行上述 <code>main</code> 方法后，你将在控制台看到类似以下的输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connecting to database...</span><br><span class="line">Connection successful!</span><br><span class="line">Users in database:</span><br><span class="line">ID: 1, Name: Alice, Email: alice@example.com</span><br><span class="line">ID: 2, Name: Bob, Email: bob@example.com</span><br><span class="line">ID: 3, Name: Charlie, Email: charlie@example.com</span><br><span class="line">Closing resources...</span><br><span class="line">Resources closed.</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-基础异常处理"><a href="#5-基础异常处理" class="headerlink" title="5. 基础异常处理"></a>5. 基础异常处理</h2><h3 id="5-1-理解-SQLException"><a href="#5-1-理解-SQLException" class="headerlink" title="5.1 理解 SQLException"></a><strong>5.1 理解 <code>SQLException</code></strong></h3><p><code>SQLException</code> 是 JDBC API 中所有数据库访问错误的 <strong>根异常</strong>。它是一个 <strong>受检异常 (Checked Exception)</strong>，这意味着 Java 编译器会强制你必须在代码中处理它（通过 <code>try-catch</code> 捕获或 <code>throws</code> 声明抛出）。</p>
<p><strong><code>SQLException</code> 何时会抛出？</strong></p>
<p>几乎在 JDBC 的每一个环节都可能遇到 <code>SQLException</code>，常见原因包括：</p>
<ul>
<li><strong>连接阶段 (<code>DriverManager.getConnection</code>)</strong>:<ul>
<li>数据库 URL 格式错误。</li>
<li>用户名或密码不正确。</li>
<li>数据库服务器未运行或网络不通。</li>
<li>驱动程序未找到（虽然更常见的是 <code>ClassNotFoundException</code>，但某些驱动实现可能包装成 <code>SQLException</code>）。</li>
</ul>
</li>
<li><strong>执行 SQL 阶段 (<code>statement.execute...</code>)</strong>:<ul>
<li>SQL 语法错误。</li>
<li>查询的表或列不存在。</li>
<li>违反数据库约束（如插入重复的主键、外键约束失败）。</li>
<li>权限不足，用户无权执行该操作。</li>
</ul>
</li>
<li><strong>处理结果阶段 (<code>resultSet.get...</code>)</strong>:<ul>
<li>尝试获取不存在的列名。</li>
<li>数据类型不匹配（如尝试用 <code>getInt</code> 获取一个字符串类型的值）。</li>
</ul>
</li>
<li><strong>其他</strong>:<ul>
<li>数据库连接超时或被服务器中断。</li>
</ul>
</li>
</ul>
<p><strong>从 <code>SQLException</code> 中获取有用的调试信息</strong></p>
<p>当捕获到 <code>SQLException</code> 时，它不仅仅是一个简单的错误信号，还包含了诊断信息，帮助我们快速定位问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;Database Error!&quot;</span>);</span><br><span class="line">    <span class="comment">// 1. 获取详细的错误信息 (给开发者看)</span></span><br><span class="line">    System.err.println(<span class="string">&quot;Message: &quot;</span> + e.getMessage());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取数据库厂商特定的错误码 (非常有用！)</span></span><br><span class="line">    System.err.println(<span class="string">&quot;Error Code: &quot;</span> + e.getErrorCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取标准的 SQLState 码 (5位字符，跨数据库)</span></span><br><span class="line">    System.err.println(<span class="string">&quot;SQLState: &quot;</span> + e.getSQLState());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 打印完整的堆栈跟踪信息</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>getMessage()</code></strong>: 返回一个描述错误的字符串，通常是数据库直接返回的错误信息，例如 “Table ‘my_db.non_existent_table’ doesn’t exist”。</li>
<li><strong><code>getErrorCode()</code></strong>: 返回一个特定于数据库厂商的整数错误代码。例如，MySQL 的 <code>1064</code> 表示语法错误，<code>1045</code> 表示访问被拒绝。你可以根据这个代码去查阅对应数据库的官方文档，找到最精确的错误原因。</li>
<li><strong><code>getSQLState()</code></strong>: 返回一个遵循 X&#x2F;Open 或 SQL:2003 标准的 5 位字符串代码。它的通用性更强，但通常不如 <code>ErrorCode</code> 直观。</li>
</ul>
<hr>
<h3 id="5-2-资源释放的重要性与-finally"><a href="#5-2-资源释放的重要性与-finally" class="headerlink" title="5.2 资源释放的重要性与 finally"></a><strong>5.2 资源释放的重要性与 <code>finally</code></strong></h3><p><strong>1. 为什么必须释放资源？—— 资源泄露的危害</strong></p>
<p>在 JDBC 中，<code>Connection</code>, <code>Statement</code>, 和 <code>ResultSet</code> 对象不仅是 Java 对象，它们还代表着底层的、有限的物理资源：</p>
<ul>
<li><strong><code>Connection</code></strong>: 代表一个与数据库服务器的真实网络连接。数据库能支持的并发连接数是有限的。</li>
<li><strong><code>Statement</code></strong>: 在数据库服务器端可能会占用游标 (cursor) 和内存。</li>
<li><strong><code>ResultSet</code></strong>: 可能会在数据库端或内存中缓存大量的查询结果数据。</li>
</ul>
<p><strong>资源泄露 (Resource Leak)</strong> 指的是程序在使用完这些资源后，没有调用它们的 <code>close()</code> 方法将其归还。</p>
<p><strong>2. 为什么选择 <code>finally</code> 块？—— 保证执行</strong></p>
<p><code>finally</code> 块的特性是：<strong>无论 <code>try</code> 块中的代码是正常执行完毕，还是中途因为异常而跳出，<code>finally</code> 块中的代码都保证会被执行。</strong></p>
<p>这完美地契合了资源释放的需求。我们不能把 <code>close()</code> 方法放在 <code>try</code> 块的末尾，因为一旦 <code>try</code> 块中发生异常，后面的 <code>close()</code> 代码就永远不会被执行，从而导致资源泄露。</p>
<p><strong>3. 传统的、健壮的 <code>finally</code> 写法</strong></p>
<p>在 “HelloWorld” 示例中，我们看到了一个基本的 <code>finally</code> 块。但一个更健壮的写法需要考虑 <code>close()</code> 方法本身也可能抛出 <code>SQLException</code>，并且要处理对象为 <code>null</code> 的情况（如果在 <code>try</code> 块早期就发生异常，某些对象可能还未被实例化）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 关闭 ResultSet</span></span><br><span class="line">    <span class="keyword">if</span> (resultSet != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resultSet.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace(); <span class="comment">// 记录日志</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 关闭 Statement</span></span><br><span class="line">    <span class="keyword">if</span> (statement != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            statement.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace(); <span class="comment">// 记录日志</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 关闭 Connection</span></span><br><span class="line">    <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace(); <span class="comment">// 记录日志</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种层层嵌套的写法虽然代码冗长，但它确保了：</p>
<ul>
<li><strong>空指针安全</strong>：在调用 <code>close()</code> 前检查对象是否为 <code>null</code>。</li>
<li><strong>关闭独立性</strong>：一个资源的关闭失败，不会影响其他资源的关闭尝试。</li>
</ul>
<hr>
<h3 id="5-3-现代化的资源管理：try-with-resources-预告"><a href="#5-3-现代化的资源管理：try-with-resources-预告" class="headerlink" title="5.3 现代化的资源管理：try-with-resources (预告)"></a><strong>5.3 现代化的资源管理：<code>try-with-resources</code> (预告)</strong></h3><p>传统的 <code>finally</code> 写法非常繁琐且容易出错。幸运的是，从 <strong>Java 7</strong> 开始，引入了一种更优雅、更安全的语法糖—— <strong><code>try-with-resources</code></strong> 语句。</p>
<p>它能自动管理实现了 <code>AutoCloseable</code> 接口（<code>Connection</code>, <code>Statement</code>, <code>ResultSet</code> 都实现了该接口）的资源。</p>
<p><strong>对比一下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 try-with-resources (推荐)</span></span><br><span class="line"><span class="comment">// 将需要关闭的资源在 try() 的括号内声明</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(URL, USER, PASS);</span><br><span class="line">     <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">     <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(SQL)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接在这里使用 conn, stmt, rs</span></span><br><span class="line">    <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">        <span class="comment">// ... process data ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无需 finally 块！</span></span><br><span class="line"><span class="comment">// 在 try 块结束时，rs, stmt, conn 会被自动、安全地关闭，顺序也是正确的。</span></span><br></pre></td></tr></table></figure>

<p>我们将在后续的 <strong>“六、高级主题与性能优化”</strong> 章节中详细讲解并推荐全面使用 <code>try-with-resources</code>，因为它极大地简化了代码，并从根本上避免了资源泄露的风险。目前，你只需要了解它的存在，并理解它解决了传统 <code>finally</code> 块的痛点。</p>
<hr>
<hr>
<h1 id="二、JDBC-核心-API-详解"><a href="#二、JDBC-核心-API-详解" class="headerlink" title="二、JDBC 核心 API 详解"></a>二、JDBC 核心 API 详解</h1><h2 id="1-DriverManager"><a href="#1-DriverManager" class="headerlink" title="1. DriverManager"></a>1. DriverManager</h2><p><code>DriverManager</code> 是位于 <code>java.sql</code> 包下的一个<strong>核心类</strong>。它的主要职责是<strong>管理</strong>一组 JDBC 驱动程序，并作为应用程序获取数据库连接的<strong>工厂</strong>。</p>
<h3 id="1-1-核心职责"><a href="#1-1-核心职责" class="headerlink" title="1.1 核心职责"></a><strong>1.1 核心职责</strong></h3><ol>
<li><strong>管理驱动程序 (Managing Drivers)</strong><ul>
<li><code>DriverManager</code> 维护着一个已注册的 <code>Driver</code> 列表。当 JVM 启动时，它会通过 SPI 机制自动发现并加载 classpath 中所有可用的 JDBC 驱动，并将它们注册到这个列表中。</li>
<li>它也提供了手动注册 (<code>registerDriver</code>) 和注销 (<code>deregisterDriver</code>) 驱动的方法，但在现代 JDBC 编程中已很少直接使用。</li>
</ul>
</li>
<li><strong>建立数据库连接 (Establishing Connections)</strong><ul>
<li>这是 <code>DriverManager</code> 最常用也是最重要的功能。它提供了一系列重载的静态方法 <code>getConnection()</code>，应用程序通过调用这些方法来获取一个 <code>Connection</code> 对象。</li>
<li><code>DriverManager</code> 会遍历其内部已注册的驱动列表，依次询问每个驱动：“你能处理这个 URL 吗？”。第一个成功建立连接并返回 <code>Connection</code> 对象的驱动将被选中。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-2-关键方法详解"><a href="#1-2-关键方法详解" class="headerlink" title="1.2 关键方法详解"></a><strong>1.2 关键方法详解</strong></h3><p><code>DriverManager</code> 的所有方法都是静态的，这意味着你不需要创建它的实例，直接通过类名 <code>DriverManager.methodName()</code> 调用即可。</p>
<h4 id="1-2-1-static-Connection-getConnection-String-url"><a href="#1-2-1-static-Connection-getConnection-String-url" class="headerlink" title="1.2.1 static Connection getConnection(String url)"></a>1.2.1 <code>static Connection getConnection(String url)</code></h4><ul>
<li>这是最简单的形式，只接收一个数据库连接 URL。</li>
<li>这种形式通常用于 URL 中已经包含了所有认证信息，或者用于那些不需要用户名&#x2F;密码的数据库（如嵌入式数据库 H2 的某些模式）。</li>
<li><strong>不推荐</strong>在 URL 中硬编码密码，因为存在安全风险。</li>
<li><strong>示例</strong>: <code>DriverManager.getConnection(&quot;jdbc:h2:mem:testdb&quot;);</code></li>
</ul>
<hr>
<h4 id="1-2-2-static-Connection-getConnection-String-url-String-user-String-password"><a href="#1-2-2-static-Connection-getConnection-String-url-String-user-String-password" class="headerlink" title="1.2.2 static Connection getConnection(String url, String user, String password)"></a>1.2.2 <code>static Connection getConnection(String url, String user, String password)</code></h4><ul>
<li><p><strong>这是最常用、最推荐的方法</strong>。</p>
</li>
<li><p>它将连接 URL、数据库用户名和密码作为独立的参数传入。这比将认证信息写在 URL 中更清晰、更安全。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/my_db?serverTimezone=UTC&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>; </span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;your_password&quot;</span>; </span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-2-3-static-Connection-getConnection-String-url-java-util-Properties-info"><a href="#1-2-3-static-Connection-getConnection-String-url-java-util-Properties-info" class="headerlink" title="1.2.3 static Connection getConnection(String url, java.util.Properties info)"></a>1.2.3 <code>static Connection getConnection(String url, java.util.Properties info)</code></h4><ul>
<li><p>这是一个更灵活的版本，允许你将用户名、密码以及其他任意连接属性（如 <code>characterEncoding</code>）都放入一个 <code>Properties</code> 对象中。</p>
</li>
<li><p>当需要配置大量连接参数时，这种方式能让代码更整洁。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/my_db&quot;</span>;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;your_password&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;serverTimezone&quot;</span>, <span class="string">&quot;UTC&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;autoReconnect&quot;</span>, <span class="string">&quot;true&quot;</span>); </span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, props);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-2-4-static-void-registerDriver-java-sql-Driver-driver"><a href="#1-2-4-static-void-registerDriver-java-sql-Driver-driver" class="headerlink" title="1.2.4 static void registerDriver(java.sql.Driver driver)"></a>1.2.4 <code>static void registerDriver(java.sql.Driver driver)</code></h4><ul>
<li>用于手动向 <code>DriverManager</code> 注册一个驱动实例。</li>
<li>在 <code>Class.forName()</code> 的时代，驱动类的静态代码块会调用这个方法来完成自我注册。</li>
<li><strong>现代开发中基本无需手动调用</strong>。</li>
</ul>
<hr>
<h3 id="1-3-驱动注册机制的演进：从-Class-forName-到-SPI"><a href="#1-3-驱动注册机制的演进：从-Class-forName-到-SPI" class="headerlink" title="1.3 驱动注册机制的演进：从 Class.forName() 到 SPI"></a><strong>1.3 驱动注册机制的演进：从 <code>Class.forName()</code> 到 SPI</strong></h3><p>理解 <code>DriverManager</code> 如何“发现”驱动是理解 JDBC 工作原理的关键。</p>
<h4 id="1-3-1-传统方式-JDBC-3-0-及以前-Class-forName"><a href="#1-3-1-传统方式-JDBC-3-0-及以前-Class-forName" class="headerlink" title="1.3.1 传统方式 (JDBC 3.0 及以前): Class.forName()"></a>1.3.1 传统方式 (JDBC 3.0 及以前): <code>Class.forName()</code></h4><p>在早期，开发者必须在代码中显式加载驱动类：<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></p>
<p>这行代码背后发生了什么？</p>
<ul>
<li><p><strong>第1步: 类加载</strong><br>Java 的反射机制会找到并加载 <code>com.mysql.jdbc.Driver</code> 这个类的字节码（<code>.class</code> 文件）到 JVM 内存中。</p>
</li>
<li><p><strong>第2步: 执行静态代码块</strong><br>类在首次被加载时，其内部的静态代码块 (<code>static { ... }</code>) 会被自动执行。MySQL 驱动的源码中，这个静态块看起来类似这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In com.mysql.jdbc.Driver class</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建驱动实例并向 DriverManager 注册自己</span></span><br><span class="line">        java.sql.DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，<code>Class.forName()</code> 的真正目的是<strong>触发驱动的自我注册过程</strong>。</p>
</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>代码与具体的驱动类名硬耦合。如果更换数据库（比如从 MySQL 换到 PostgreSQL），就必须修改 Java 源代码。</li>
<li>增加了模板代码。</li>
</ul>
<hr>
<h4 id="1-3-2-现代方式-JDBC-4-0-及以后-SPI-Service-Provider-Interface"><a href="#1-3-2-现代方式-JDBC-4-0-及以后-SPI-Service-Provider-Interface" class="headerlink" title="1.3.2 现代方式 (JDBC 4.0 及以后): SPI (Service Provider Interface)"></a>1.3.2 现代方式 (JDBC 4.0 及以后): SPI (Service Provider Interface)</h4><p>从 Java 6 (JDBC 4.0) 开始，引入了 <strong>SPI 服务发现机制</strong>，使得驱动加载完全自动化。</p>
<p><strong>工作原理</strong>:</p>
<ul>
<li>符合 JDBC 4.0 规范的驱动 JAR 包，在其 <code>META-INF/services/</code> 目录下会包含一个名为 <code>java.sql.Driver</code> 的文本文件。</li>
<li>这个文件的内容就是该驱动实现 <code>java.sql.Driver</code> 接口的那个类的<strong>全限定名</strong>。例如，MySQL 8.x 驱动的这个文件内容是：<code>com.mysql.cj.jdbc.Driver</code></li>
<li>当应用程序启动时，<code>DriverManager</code> 会自动扫描 classpath，查找所有 JAR 包中的 <code>META-INF/services/java.sql.Driver</code> 文件。</li>
<li>它会读取文件中的类名，并使用 <code>Class.forName()</code> 在后台自动加载并实例化这些驱动类，从而完成注册。</li>
</ul>
<p><strong>优点</strong>:</p>
<ul>
<li><strong>解耦</strong>: Java 代码不再依赖任何具体的驱动类名，实现了真正的“即插即用”。</li>
<li><strong>简化</strong>: 无需再编写 <code>Class.forName()</code> 这行样板代码。</li>
</ul>
<hr>
<h3 id="1-4-DriverManager-vs-DataSource-现代实践"><a href="#1-4-DriverManager-vs-DataSource-现代实践" class="headerlink" title="1.4 DriverManager vs. DataSource (现代实践)"></a><strong>1.4 <code>DriverManager</code> vs. <code>DataSource</code> (现代实践)</strong></h3><p>尽管 <code>DriverManager</code> 是学习 JDBC 的起点，但在现代企业级应用和生产环境中，我们<strong>更推荐使用 <code>DataSource</code> 接口</strong>来获取连接。<code>DataSource</code> 是在 JDBC 2.0 中引入的，它提供了比 <code>DriverManager</code> 更强大和灵活的功能：</p>
<ul>
<li><strong>更好的抽象</strong>: <code>DataSource</code> 将连接的获取方式与应用程序代码分离。连接的细节（URL, user, password 等）可以在外部配置（如配置文件、JNDI），而不是硬编码在代码中。</li>
<li><strong>连接池支持</strong>: <code>DataSource</code> 是实现数据库连接池（Connection Pooling）的标准方式。连接池可以极大地提升应用程序性能和资源利用率。</li>
<li><strong>分布式事务支持</strong>: <code>DataSource</code> 也是参与 JTA (Java Transaction API) 分布式事务的基础。</li>
</ul>
<p><strong>结论</strong>:<code>DriverManager</code> 非常适合用于简单的应用程序、快速测试和教学演示。但对于任何严肃的、需要高性能和可维护性的项目，都应该转向使用 <code>DataSource</code>（通常由连接池库如 HikariCP, Druid 提供实现）。我们将在后续章节详细介绍连接池和 <code>DataSource</code>。</p>
<hr>
<h2 id="2-Connection"><a href="#2-Connection" class="headerlink" title="2. Connection"></a>2. Connection</h2><p>一旦通过 <code>DriverManager</code> 或 <code>DataSource</code> 成功获取一个 <code>Connection</code> 对象，你就拥有了一个与特定数据库建立的<strong>活动会话 (Session)</strong>。</p>
<h3 id="2-1-核心职责"><a href="#2-1-核心职责" class="headerlink" title="2.1 核心职责"></a>2.1 核心职责</h3><p><code>Connection</code> 对象是 JDBC 编程的中心枢纽，主要承担三大职责：</p>
<ol>
<li><strong>创建 Statement 对象</strong>：它是创建 <code>Statement</code>、<code>PreparedStatement</code> 和 <code>CallableStatement</code> 对象的工厂。这些 Statement 对象是真正用来执行 SQL 语句的工具。</li>
<li><strong>管理事务 (Transaction Management)</strong>：控制事务的边界，包括开启事务、提交事务或回滚事务，确保一组数据库操作的原子性。</li>
<li><strong>获取数据库元数据 (Metadata)</strong>：提供访问关于数据库本身信息的能力，例如数据库产品名称、版本、支持的功能、表结构等。</li>
</ol>
<hr>
<h3 id="2-2-关键方法详解-按功能分组"><a href="#2-2-关键方法详解-按功能分组" class="headerlink" title="2.2 关键方法详解 - 按功能分组"></a>2.2 关键方法详解 - 按功能分组</h3><h4 id="2-2-1-SQL-执行准备"><a href="#2-2-1-SQL-执行准备" class="headerlink" title="2.2.1 SQL 执行准备"></a>2.2.1 SQL 执行准备</h4><p><code>Connection</code> 本身不执行 SQL，而是创建用于执行 SQL 的对象。</p>
<h5 id="1-Statement-createStatement"><a href="#1-Statement-createStatement" class="headerlink" title="1. Statement createStatement()"></a>1. <code>Statement createStatement()</code></h5><ul>
<li>创建一个 <code>Statement</code> 对象，用于发送<strong>简单的、静态的 SQL 语句</strong>。</li>
<li><strong>适用场景</strong>: 执行没有参数的、一次性的 SQL 语句。</li>
<li><strong>缺点</strong>: 存在 SQL 注入风险，性能相对较低（每次执行都需要数据库重新解析 SQL）。</li>
<li><strong>示例</strong>: <code>Statement stmt = connection.createStatement();</code></li>
</ul>
<hr>
<h5 id="2-PreparedStatement-prepareStatement-String-sql"><a href="#2-PreparedStatement-prepareStatement-String-sql" class="headerlink" title="2. PreparedStatement prepareStatement(String sql)"></a>2. <code>PreparedStatement prepareStatement(String sql)</code></h5><ul>
<li><strong>JDBC 中最常用、最重要的 Statement 类型</strong>。</li>
<li>创建一个 <code>PreparedStatement</code> 对象，用于执行<strong>带参数的、预编译的 SQL 语句</strong>。SQL 语句中的参数用占位符 <code>?</code> 表示。</li>
<li><strong>核心优势</strong>:<ul>
<li><strong>防止 SQL 注入</strong>: 它将 SQL 结构和参数数据分开处理，从根本上杜绝了 SQL 注入攻击。</li>
<li><strong>性能更高</strong>: SQL 语句只需在数据库端编译一次，后续可以带着不同的参数高效地执行多次。</li>
</ul>
</li>
<li><strong>示例</strong>: <code>PreparedStatement pstmt = connection.prepareStatement(&quot;SELECT * FROM users WHERE id = ?&quot;);</code></li>
</ul>
<hr>
<h5 id="3-CallableStatement-prepareCall-String-sql"><a href="#3-CallableStatement-prepareCall-String-sql" class="headerlink" title="3. CallableStatement prepareCall(String sql)"></a>3. <code>CallableStatement prepareCall(String sql)</code></h5><ul>
<li>创建一个 <code>CallableStatement</code> 对象，用于<strong>调用数据库中的存储过程</strong>。</li>
<li><strong>适用场景</strong>: 当业务逻辑封装在数据库的存储过程中时使用。</li>
<li><strong>示例</strong>: <code>CallableStatement cstmt = connection.prepareCall(&quot;{call get_user_by_id(?)}&quot;);</code></li>
</ul>
<hr>
<h4 id="2-2-2-事务控制"><a href="#2-2-2-事务控制" class="headerlink" title="2.2.2 事务控制"></a>2.2.2 事务控制</h4><p>事务是一组必须“要么全部成功，要么全部失败”的数据库操作单元。银行转账是解释事务最经典的例子。</p>
<ol>
<li><strong><code>void setAutoCommit(boolean autoCommit)</code></strong><ul>
<li><strong>这是事务管理的核心开关</strong>。</li>
<li>默认情况下，JDBC 的连接处于 <strong>自动提交模式 (<code>autoCommit = true</code>)</strong>。这意味着你执行的每一条 SQL 语句都会被立即视为一个独立的事务并自动提交给数据库，永久生效。</li>
<li>要手动管理事务，必须在执行任何 SQL 之前调用 <code>connection.setAutoCommit(false);</code>，这会开启一个新事务。</li>
</ul>
</li>
<li><strong><code>void commit()</code></strong><ul>
<li>在手动事务模式下（<code>autoCommit = false</code>），调用此方法会将<strong>当前事务中所有已执行的 SQL 操作永久保存</strong>到数据库中。</li>
<li>如果操作成功，一个新的事务会立即开始。</li>
</ul>
</li>
<li><strong><code>void rollback()</code></strong><ul>
<li>在手动事务模式下，调用此方法会<strong>撤销当前事务中所有已执行的 SQL 操作</strong>，使数据库恢复到事务开始之前的状态。</li>
<li>这通常在 <code>catch</code> 块中调用，当事务中的任何一步发生错误时，用以保证数据的一致性。</li>
</ul>
</li>
</ol>
<p><strong>事务实战示例：银行转账</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferMoney</span><span class="params">(<span class="type">int</span> fromAccountId, <span class="type">int</span> toAccountId, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">debitStmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">creditStmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = DriverManager.getConnection(URL, USER, PASS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 关闭自动提交，开启事务</span></span><br><span class="line">        conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. A 账户扣钱</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">debitSql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE accounts SET balance = balance - ? WHERE id = ?&quot;</span>;</span><br><span class="line">        debitStmt = conn.prepareStatement(debitSql);</span><br><span class="line">        debitStmt.setDouble(<span class="number">1</span>, amount);</span><br><span class="line">        debitStmt.setInt(<span class="number">2</span>, fromAccountId);</span><br><span class="line">        debitStmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟一个意外（例如，系统崩溃）</span></span><br><span class="line">        <span class="comment">// if (true) &#123; throw new SQLException(&quot;Simulated system failure!&quot;); &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. B 账户加钱</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">creditSql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE accounts SET balance = balance + ? WHERE id = ?&quot;</span>;</span><br><span class="line">        creditStmt = conn.prepareStatement(creditSql);</span><br><span class="line">        creditStmt.setDouble(<span class="number">1</span>, amount);</span><br><span class="line">        creditStmt.setInt(<span class="number">2</span>, toAccountId);</span><br><span class="line">        creditStmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 所有操作成功，提交事务</span></span><br><span class="line">        conn.commit();</span><br><span class="line">        System.out.println(<span class="string">&quot;Transfer successful!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Transfer failed. Rolling back transaction...&quot;</span>);</span><br><span class="line">        <span class="comment">// 5. 发生任何异常，回滚事务</span></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.rollback();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 6. 最终都要关闭资源，并恢复自动提交模式（如果连接被池化复用）</span></span><br><span class="line">        <span class="comment">// ... close statements and connection ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-3-连接管理与状态"><a href="#2-2-3-连接管理与状态" class="headerlink" title="2.2.3 连接管理与状态"></a>2.2.3 连接管理与状态</h4><ol>
<li><strong><code>void close()</code></strong><ul>
<li><strong>极其重要的方法</strong>。调用它会立即释放此 <code>Connection</code> 对象占用的数据库和 JDBC 资源。</li>
<li><strong>必须在 <code>finally</code> 块或 <code>try-with-resources</code> 语句中调用</strong>，以确保连接无论如何都会被关闭，防止资源泄露。</li>
</ul>
</li>
<li><strong><code>boolean isClosed()</code></strong><ul>
<li>检查连接是否已经被关闭。</li>
</ul>
</li>
<li><strong><code>boolean isValid(int timeout)</code></strong><ul>
<li>一个更可靠的检查连接是否仍然有效的方法。它会尝试与数据库进行一次简短的通信来确认连接是否存活。比 <code>!isClosed()</code> 更可靠，后者只表示你是否调用了 <code>close()</code> 方法。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-2-4-获取数据库元数据"><a href="#2-2-4-获取数据库元数据" class="headerlink" title="2.2.4 获取数据库元数据"></a>2.2.4 获取数据库元数据</h4><p><strong><code>DatabaseMetaData getMetaData()</code></strong></p>
<ul>
<li>返回一个 <code>DatabaseMetaData</code> 对象，该对象封装了关于整个数据库的综合信息。</li>
<li>你可以用它来动态地发现数据库的能力，例如：<ul>
<li>获取数据库产品名称和版本 (<code>getDatabaseProductName()</code>, <code>getDatabaseProductVersion()</code>)。</li>
<li>获取当前连接的用户名 (<code>getUserName()</code>)。</li>
<li>检查数据库是否支持事务、批量更新等特性。</li>
<li>获取数据库中的所有表、视图、存储过程等信息。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-生命周期与最佳实践"><a href="#2-3-生命周期与最佳实践" class="headerlink" title="2.3 生命周期与最佳实践"></a>2.3 生命周期与最佳实践</h3><ul>
<li><strong>生命周期</strong>: <code>Connection</code> 的生命周期应该是<strong>短暂的</strong>。遵循“尽早获取，尽快释放”的原则。在一个业务操作开始时获取连接，操作结束后立即在 <code>finally</code> 块中关闭它。</li>
<li><strong>线程安全</strong>: <code>Connection</code> 对象<strong>不是线程安全的</strong>。在多线程环境（如 Web 应用）中，绝不能在多个线程之间共享同一个 <code>Connection</code> 对象。正确的做法是为每个线程（或每个请求）分配一个独立的连接。连接池技术就是为此而生。</li>
<li><strong>现代用法</strong>: 强烈推荐使用 <strong><code>try-with-resources</code></strong> 语句来管理 <code>Connection</code>，它能自动、安全地为你关闭连接。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐的现代写法</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(URL, USER, PASS)) &#123;</span><br><span class="line">    <span class="comment">// 在这里使用 conn 对象</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// conn 会在此处被自动关闭，无需 finally 块</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-SQL-执行器"><a href="#3-SQL-执行器" class="headerlink" title="3. SQL 执行器"></a>3. SQL 执行器</h2><h3 id="3-1-Statement-基本的-SQL-执行器"><a href="#3-1-Statement-基本的-SQL-执行器" class="headerlink" title="3.1 Statement(基本的 SQL 执行器)"></a>3.1 <code>Statement</code>(基本的 SQL 执行器)</h3><p><code>Statement</code> 是最基础的 SQL 执行接口。它用于执行<strong>静态的、不含参数的 SQL 语句</strong>。</p>
<ul>
<li><p><strong>创建方式</strong>: <code>Statement stmt = connection.createStatement();</code></p>
</li>
<li><p><strong>核心方法</strong>:</p>
<ul>
<li><strong><code>ResultSet executeQuery(String sql)</code></strong>:<ul>
<li><strong>用途</strong>: 专门用于执行 <strong><code>SELECT</code> 查询语句</strong>。</li>
<li><strong>返回值</strong>: 返回一个 <code>ResultSet</code> 对象，其中包含了查询结果。</li>
</ul>
</li>
<li><strong><code>int executeUpdate(String sql)</code></strong>:<ul>
<li><strong>用途</strong>: 用于执行 <strong><code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code></strong> 等数据操作语句（DML），以及 <code>CREATE TABLE</code>、<code>DROP TABLE</code> 等数据定义语句（DDL）。</li>
<li><strong>返回值</strong>: 返回一个 <code>int</code> 值，表示<strong>受影响的行数</strong>。对于 DDL 语句，通常返回 0。</li>
</ul>
</li>
<li><strong><code>boolean execute(String sql)</code></strong>:<ul>
<li><strong>用途</strong>: 一个通用的执行方法，可以执行任何类型的 SQL 语句。</li>
<li><strong>返回值</strong>:<ul>
<li>返回 <code>true</code>：如果执行的第一个结果是 <code>ResultSet</code>（即执行了查询语句）。</li>
<li>返回 <code>false</code>：如果执行的第一个结果是更新计数或没有结果（即 DML 或 DDL）。</li>
</ul>
</li>
<li><strong>后续操作</strong>: 调用 <code>execute()</code> 后，你需要通过 <code>getResultSet()</code> 来获取查询结果，或者通过 <code>getUpdateCount()</code> 来获取受影响的行数。这个方法在你不确定将要执行的 SQL 类型时有用，但通常我们更倾向于使用明确的 <code>executeQuery</code> 或 <code>executeUpdate</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ...; <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name FROM users WHERE id = 1&quot;</span>;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line">    <span class="comment">// ... process rs ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>主要缺点</strong>:</p>
<ol>
<li><p><strong>存在严重的 SQL 注入风险 (SQL Injection)</strong>:<br><code>Statement</code> 通过字符串拼接来构建 SQL，如果 SQL 中包含用户输入的内容，恶意用户可以构造特殊的输入来篡改原始 SQL 的逻辑，从而执行未授权的操作。<br><strong>危险示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">userInputName</span> <span class="operator">=</span> <span class="string">&quot;&#x27; or &#x27;1&#x27;=&#x27;1&quot;</span>; <span class="comment">// 恶意输入</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE name = &#x27;&quot;</span> + userInputName + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="comment">// 拼接后的 SQL 变为:</span></span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;&#x27; or &#x27;1&#x27;=&#x27;1&#x27;</span></span><br><span class="line"><span class="comment">// 这将绕过认证，查询出所有用户！</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>性能较差</strong>:<br>每次执行 <code>statement.executeQuery(sql)</code>，数据库都需要对传入的完整 SQL 字符串进行<strong>解析、编译和生成执行计划</strong>。如果一个 SQL 语句需要被反复执行（只是条件不同），这种重复的编译过程会浪费大量数据库资源。</p>
</li>
</ol>
</li>
</ul>
<p><strong>结论</strong>：由于安全和性能问题，<strong><code>Statement</code> 在现代开发中应极力避免使用</strong>，尤其是在处理任何包含外部输入的 SQL 时。它只适用于执行完全硬编码、无变量的 SQL。</p>
<hr>
<h3 id="3-2-PreparedStatement-推荐的-SQL-执行器"><a href="#3-2-PreparedStatement-推荐的-SQL-执行器" class="headerlink" title="3.2 PreparedStatement(推荐的 SQL 执行器)"></a>3.2 <code>PreparedStatement</code>(推荐的 SQL 执行器)</h3><p><code>PreparedStatement</code> 继承自 <code>Statement</code>，是 JDBC 的主力军，<strong>强烈推荐在所有场景下优先使用</strong>。它代表一个<strong>预编译</strong>的 SQL 语句。</p>
<ul>
<li><p><strong>创建方式</strong>: <code>PreparedStatement pstmt = connection.prepareStatement(&quot;SELECT * FROM users WHERE id = ? AND name = ?&quot;);</code></p>
<ul>
<li>SQL 语句在创建时就被发送到数据库进行预编译。</li>
<li>变量部分使用占位符 <code>?</code> 来代替。</li>
</ul>
</li>
<li><p><strong>核心流程</strong>:</p>
<ol>
<li><strong>创建时预编译</strong>: <code>connection.prepareStatement(sql)</code> 将 SQL 模板发送给数据库。数据库对这个不含具体值的 SQL 结构进行解析、编译，并缓存执行计划。</li>
<li><strong>设置参数</strong>: 使用 <code>setXXX(int parameterIndex, value)</code> 方法为占位符 <code>?</code> 绑定具体的值。<strong>注意：参数索引 <code>parameterIndex</code> 从 1 开始！</strong><ul>
<li><code>pstmt.setInt(1, 101);</code> &#x2F;&#x2F; 设置第一个 ? 的值为 101</li>
<li><code>pstmt.setString(2, &quot;Alice&quot;);</code> &#x2F;&#x2F; 设置第二个 ? 的值为 “Alice”</li>
</ul>
</li>
<li><strong>执行</strong>: 调用<strong>不带 SQL 参数</strong>的执行方法。<ul>
<li><code>ResultSet rs = pstmt.executeQuery();</code></li>
<li><code>int affectedRows = pstmt.executeUpdate();</code></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>核心优势</strong>:</p>
<ol>
<li><strong>从根本上防止 SQL 注入</strong>:<br><code>PreparedStatement</code> 将 SQL 的<strong>结构</strong>和<strong>数据</strong>完全分离。当你调用 <code>setString()</code> 等方法时，驱动会将数据作为纯粹的参数传递给数据库，数据库绝不会将这些参数值作为 SQL 指令来解析。即使恶意用户输入 <code>&quot;&#39; or &#39;1&#39;=&#39;1&quot;</code>，数据库也只会把它当作一个普通的字符串去查找一个名字就叫 <code>&quot;&#39; or &#39;1&#39;=&#39;1&quot;</code> 的用户，而不会改变查询的逻辑。</li>
<li><strong>性能显著提升</strong>:<br>由于 SQL 语句只在创建时编译一次，之后每次执行时，数据库只需将新的参数代入已缓存的执行计划中即可，省去了反复解析和编译的开销。这对于需要<strong>批量或重复执行</strong>的 SQL 操作（如循环插入数据）性能提升尤为明显。</li>
<li><strong>代码可读性和可维护性更好</strong>:<br>将 SQL 语句和参数设置分开，使得代码逻辑更清晰，避免了繁琐且容易出错的字符串拼接。</li>
</ol>
</li>
<li><p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO users (name, email) VALUES (?, ?)&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ...; <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line">    pstmt.setString(<span class="number">1</span>, <span class="string">&quot;David&quot;</span>);</span><br><span class="line">    pstmt.setString(<span class="number">2</span>, <span class="string">&quot;david@example.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">affectedRows</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br><span class="line">    System.out.println(<span class="string">&quot;Inserted &quot;</span> + affectedRows + <span class="string">&quot; row(s).&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-3-CallableStatement：专业的存储过程执行器"><a href="#3-3-CallableStatement：专业的存储过程执行器" class="headerlink" title="3.3 CallableStatement：专业的存储过程执行器"></a>3.3 <code>CallableStatement</code>：专业的存储过程执行器</h3><p><code>CallableStatement</code> 继承自 <code>PreparedStatement</code>，专门用于<strong>调用数据库中的存储过程和函数</strong>。</p>
<ul>
<li><p><strong>创建方式</strong>: <code>CallableStatement cstmt = connection.prepareCall(&quot;{call procedure_name(?, ?)}&quot;);</code></p>
<ul>
<li>使用标准的 JDBC 调用语法 <code>{call ...}</code>。</li>
</ul>
</li>
<li><p><strong>核心特性</strong>:</p>
<ul>
<li><strong>支持 IN 参数</strong>: 与 <code>PreparedStatement</code> 一样，通过 <code>setXXX()</code> 方法设置输入参数。</li>
<li><strong>支持 OUT 参数</strong>: 可以接收存储过程的输出参数。你需要先用 <code>registerOutParameter(int parameterIndex, int sqlType)</code> 方法注册输出参数的类型，执行完毕后再用 <code>getXXX(int parameterIndex)</code> 方法获取其值。</li>
<li><strong>支持 INOUT 参数</strong>: 既是输入也是输出的参数。</li>
</ul>
</li>
<li><p><strong>示例</strong>:<br>假设数据库中有一个存储过程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> get_user_name_by_id (<span class="keyword">IN</span> user_id <span class="type">INT</span>, <span class="keyword">OUT</span> user_name <span class="type">VARCHAR</span>(<span class="number">50</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> name <span class="keyword">INTO</span> user_name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> user_id;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>Java 调用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;&#123;call get_user_name_by_id(?, ?)&#125;&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ...; <span class="type">CallableStatement</span> <span class="variable">cstmt</span> <span class="operator">=</span> conn.prepareCall(sql)) &#123;</span><br><span class="line">    <span class="comment">// 设置 IN 参数</span></span><br><span class="line">    cstmt.setInt(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 OUT 参数，指定其 SQL 类型</span></span><br><span class="line">    cstmt.registerOutParameter(<span class="number">2</span>, java.sql.Types.VARCHAR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行存储过程</span></span><br><span class="line">    cstmt.execute();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 OUT 参数的值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> cstmt.getString(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;User name is: &quot;</span> + userName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>结论</strong>：当业务逻辑被封装在数据库的存储过程中时，<code>CallableStatement</code> 是与它们交互的唯一标准方式。</p>
<hr>
<h3 id="3-4-总结对比"><a href="#3-4-总结对比" class="headerlink" title="3.4 总结对比"></a>3.4 总结对比</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>Statement</code></th>
<th align="left"><code>PreparedStatement</code></th>
<th align="left"><code>CallableStatement</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>用途</strong></td>
<td align="left">执行静态、无参数的SQL</td>
<td align="left">执行带参数、预编译的SQL</td>
<td align="left">调用数据库存储过程&#x2F;函数</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">差 (每次都编译)</td>
<td align="left"><strong>好</strong> (编译一次，多次运行)</td>
<td align="left">同 PreparedStatement</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left"><strong>不安全 (易SQL注入)</strong></td>
<td align="left"><strong>安全 (从根本上防止)</strong></td>
<td align="left">安全</td>
</tr>
<tr>
<td align="left"><strong>参数类型</strong></td>
<td align="left">无</td>
<td align="left">仅 IN 参数</td>
<td align="left">IN, OUT, INOUT 参数</td>
</tr>
<tr>
<td align="left"><strong>推荐使用</strong></td>
<td align="left"><strong>永不用于生产</strong></td>
<td align="left"><strong>绝大多数场景下的首选</strong></td>
<td align="left">仅用于调用存储过程</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-ResultSet"><a href="#4-ResultSet" class="headerlink" title="4. ResultSet"></a>4. ResultSet</h2><h3 id="4-1-核心概念：行光标-Cursor"><a href="#4-1-核心概念：行光标-Cursor" class="headerlink" title="4.1 核心概念：行光标 (Cursor)"></a>4.1 核心概念：行光标 (Cursor)</h3><p>理解 <code>ResultSet</code> 的关键在于理解其内部的光标（也叫指针）。</p>
<ul>
<li><strong>初始位置</strong>: 当你刚拿到一个 <code>ResultSet</code> 对象时，光标指向一个虚拟的“第 0 行”，即在第一行实际数据之前。</li>
<li><strong>移动光标</strong>: 你需要调用 <code>next()</code> 方法将光标向下移动一行。</li>
<li><strong>数据访问</strong>: 只有当光标指向一个有效的数据行时，你才能使用 <code>getXXX()</code> 方法来获取该行的数据。</li>
<li><strong>结束位置</strong>: 当 <code>next()</code> 方法将光标移动到最后一行数据时，再次调用 <code>next()</code> 将返回 <code>false</code>，表示所有数据都已遍历完毕。</li>
</ul>
<hr>
<h3 id="4-2-核心方法详解"><a href="#4-2-核心方法详解" class="headerlink" title="4.2 核心方法详解"></a>4.2 核心方法详解</h3><h4 id="4-2-1-移动光标与遍历"><a href="#4-2-1-移动光标与遍历" class="headerlink" title="4.2.1 移动光标与遍历"></a>4.2.1 移动光标与遍历</h4><p><strong><code>boolean next()</code></strong></p>
<ul>
<li><p><strong>这是最核心、最常用的方法</strong>。</p>
</li>
<li><p><strong>双重作用</strong>:</p>
<ol>
<li>将光标从当前位置向下移动一行。</li>
<li><strong>返回一个布尔值</strong>：如果光标成功移动到了一个有效的数据行，返回 <code>true</code>；如果当前已经是最后一行，再次移动将越过末尾，此时返回 <code>false</code>。</li>
</ol>
</li>
<li><p><strong>典型用法</strong>: 与 <code>while</code> 循环结合，构成标准的 <code>ResultSet</code> 遍历模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">    <span class="comment">// 在这里处理当前行的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种结构优雅地处理了从 0 行到 N 行的所有情况，当没有查询结果时，第一次调用 <code>rs.next()</code> 就会返回 <code>false</code>，循环体根本不会执行。</p>
</li>
</ul>
<hr>
<h4 id="4-2-2-获取数据-getXXX"><a href="#4-2-2-获取数据-getXXX" class="headerlink" title="4.2.2 获取数据 (getXXX)"></a>4.2.2 获取数据 (getXXX)</h4><p>当光标指向一个有效行时，你可以使用 <code>getXXX()</code> 系列方法来提取该行中特定列的值。<code>XXX</code> 代表 Java 的数据类型。</p>
<p>有两种方式来指定列：</p>
<ol>
<li><p><strong>通过列名 (Column Name) - 推荐</strong></p>
<ul>
<li><p><strong>方法</strong>: <code>getXXX(&quot;column_name&quot;)</code></p>
</li>
<li><p><strong>优点</strong>: 代码可读性强，不依赖于 <code>SELECT</code> 语句中列的顺序。即使你改变了查询列的顺序（例如 <code>SELECT name, id FROM users</code>），代码依然能正常工作。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">createTime</span> <span class="operator">=</span> rs.getDate(<span class="string">&quot;created_at&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;price&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>通过列索引 (Column Index)</strong></p>
<ul>
<li><p><strong>方法</strong>: <code>getXXX(int columnIndex)</code></p>
</li>
<li><p><strong>注意</strong>: <strong>列索引从 1 开始，而不是 0！</strong></p>
</li>
<li><p><strong>优点</strong>: 性能可能略高于使用列名，因为它省去了查找列名对应索引的步骤。</p>
</li>
<li><p><strong>缺点</strong>: 代码可读性差，且与 <code>SELECT</code> 语句的列顺序紧密耦合。一旦 <code>SELECT</code> 语句的列顺序发生变化，代码就必须随之修改，否则会取错数据，非常容易出错。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 SQL 是 SELECT id, name, created_at, price FROM ...</span></span><br><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>); <span class="comment">// 第 1 列是 id</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="number">2</span>); <span class="comment">// 第 2 列是 name</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">createTime</span> <span class="operator">=</span> rs.getDate(<span class="number">3</span>); <span class="comment">// 第 3 列是 created_at</span></span><br><span class="line"><span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> rs.getDouble(<span class="number">4</span>); <span class="comment">// 第 4 列是 price</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>最佳实践</strong>: 除非是在对性能有极致要求的场景，否则<strong>始终推荐使用列名</strong>来获取数据，以提高代码的可读性和可维护性。</p>
<hr>
<h4 id="4-2-3-资源管理"><a href="#4-2-3-资源管理" class="headerlink" title="4.2.3 资源管理"></a>4.2.3 资源管理</h4><p><strong><code>void close()</code></strong></p>
<ul>
<li>与 <code>Connection</code> 和 <code>Statement</code> 一样，<code>ResultSet</code> 也必须在使用完毕后显式关闭。</li>
<li>它会释放与该结果集相关的数据库资源（如服务器端的游标）。</li>
<li><strong>必须在 <code>finally</code> 块或 <code>try-with-resources</code> 语句中关闭</strong>。</li>
<li><strong>关闭顺序</strong>: 遵循“后开先关”原则，<code>ResultSet</code> 应在 <code>Statement</code> 和 <code>Connection</code> 之前关闭。<code>try-with-resources</code> 会自动处理好这个顺序。</li>
</ul>
<hr>
<h3 id="4-3-ResultSet-的类型与并发性-高级特性"><a href="#4-3-ResultSet-的类型与并发性-高级特性" class="headerlink" title="4.3 ResultSet 的类型与并发性 (高级特性)"></a>4.3 ResultSet 的类型与并发性 (高级特性)</h3><p>默认情况下，我们创建的 <code>ResultSet</code> 是<strong>只读、只能向前移动</strong>的。但在创建 <code>Statement</code> 或 <code>PreparedStatement</code> 时，我们可以指定 <code>ResultSet</code> 的类型和并发性，以获得更强大的功能。</p>
<p><code>connection.createStatement(int resultSetType, int resultSetConcurrency);</code></p>
<p><code>connection.prepareStatement(String sql, int resultSetType, int resultSetConcurrency);</code></p>
<h4 id="4-3-1-resultSetType-滚动性"><a href="#4-3-1-resultSetType-滚动性" class="headerlink" title="4.3.1 resultSetType (滚动性)"></a>4.3.1 <code>resultSetType</code> (滚动性)</h4><ol>
<li><strong><code>ResultSet.TYPE_FORWARD_ONLY</code> (默认)</strong><ul>
<li>光标只能向前移动（通过 <code>next()</code>）。不能后退，也不能跳到指定行。</li>
<li>这是最轻量、性能最好的类型，适用于绝大多数简单的遍历场景。</li>
</ul>
</li>
<li><strong><code>ResultSet.TYPE_SCROLL_INSENSITIVE</code></strong><ul>
<li><strong>可滚动</strong>: 光标可以自由地向前、向后、跳到第一行、最后一行或任意指定行。<ul>
<li><code>previous()</code>: 向上移动一行。</li>
<li><code>first()</code>: 移动到第一行。</li>
<li><code>last()</code>: 移动到最后一行。</li>
<li><code>absolute(int row)</code>: 移动到指定行号。</li>
</ul>
</li>
<li><strong>不敏感 (Insensitive)</strong>: 结果集是创建时数据库数据的一个<strong>快照</strong>。在 <code>ResultSet</code> 打开期间，其他事务所做的对底层数据的修改（增、删、改）<strong>不会</strong>反映在这个 <code>ResultSet</code> 中。</li>
</ul>
</li>
<li><strong><code>ResultSet.TYPE_SCROLL_SENSITIVE</code></strong><ul>
<li><strong>可滚动</strong>: 与上面一样，光标可以自由移动。</li>
<li><strong>敏感 (Sensitive)</strong>: 结果集是动态的，能够<strong>反映</strong>出在 <code>ResultSet</code> 打开期间，其他事务对底层数据的修改。</li>
<li><strong>注意</strong>: 这是一个非常消耗资源的功能，并且不是所有数据库驱动都支持。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-3-2-resultSetConcurrency-并发性-可更新性"><a href="#4-3-2-resultSetConcurrency-并发性-可更新性" class="headerlink" title="4.3.2 resultSetConcurrency (并发性&#x2F;可更新性)"></a>4.3.2 <code>resultSetConcurrency</code> (并发性&#x2F;可更新性)</h4><ol>
<li><strong><code>ResultSet.CONCUR_READ_ONLY</code> (默认)</strong><ul>
<li>结果集是只读的，你不能通过 <code>ResultSet</code> 对象来修改数据库中的数据。</li>
</ul>
</li>
<li><strong><code>ResultSet.CONCUR_UPDATABLE</code></strong><ul>
<li>结果集是可更新的。你可以通过 <code>updateXXX()</code> 和 <code>updateRow()</code> &#x2F; <code>insertRow()</code> &#x2F; <code>deleteRow()</code> 方法来直接修改、插入或删除数据库中的行。</li>
</ul>
</li>
</ol>
<p><strong>可更新结果集示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个可滚动、可更新的 PreparedStatement</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name FROM users WHERE id = ?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql,</span><br><span class="line">                                               ResultSet.TYPE_SCROLL_INSENSITIVE,</span><br><span class="line">                                               ResultSet.CONCUR_UPDATABLE);</span><br><span class="line">pstmt.setInt(<span class="number">1</span>, <span class="number">101</span>);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">    <span class="comment">// 更新当前行的数据</span></span><br><span class="line">    rs.updateString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;New Name&quot;</span>); <span class="comment">// 在内存中更新</span></span><br><span class="line">    rs.updateRow(); <span class="comment">// 将内存中的更新提交到数据库</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Row updated.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong>: 可滚动和可更新的 <code>ResultSet</code> 提供了强大的功能，尤其是在某些 GUI 桌面应用或需要“即见即改”的场景中。但在典型的 Web 应用中，由于其对数据库资源的消耗较大且与业务逻辑耦合紧密，<strong>使用频率较低</strong>。大多数情况下，我们仍然坚持使用默认的 <code>TYPE_FORWARD_ONLY</code> 和 <code>CONCUR_READ_ONLY</code> 类型，并通过标准的 <code>UPDATE</code> 语句来修改数据。</p>
<hr>
<h3 id="4-4-处理-NULL-值"><a href="#4-4-处理-NULL-值" class="headerlink" title="4.4 处理 NULL 值"></a>4.4 处理 <code>NULL</code> 值</h3><p>当数据库中的列值为 <code>NULL</code> 时，<code>getXXX()</code> 方法的行为需要注意：</p>
<ul>
<li>对于返回对象的 <code>getXXX()</code> 方法（如 <code>getString()</code>, <code>getDate()</code>），它们会直接返回 <code>null</code>。</li>
<li>对于返回基本数据类型的 <code>getXXX()</code> 方法（如 <code>getInt()</code>, <code>getDouble()</code>），它们会返回该类型的默认值（<code>0</code>, <code>0.0</code>）。</li>
</ul>
<p>这会带来一个问题：如果 <code>getInt()</code> 返回 <code>0</code>，你无法区分是数据库里真的存的是 <code>0</code>，还是存的是 <code>NULL</code>。</p>
<p>为了解决这个问题，<code>ResultSet</code> 提供了 <code>wasNull()</code> 方法。</p>
<p><strong><code>boolean wasNull()</code></strong></p>
<ul>
<li><strong>用途</strong>: 检查<strong>最后一次</strong>调用的 <code>getXXX()</code> 方法所读取的值是否为 SQL <code>NULL</code>。</li>
<li><strong>用法</strong>: 必须在调用 <code>getXXX()</code> 之后<strong>立即</strong>调用。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;score&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (rs.wasNull()) &#123;</span><br><span class="line">    <span class="comment">// 数据库中是 NULL</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Score is not available.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 数据库中是 0 或其他整数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Score is: &quot;</span> + score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-MetaData-API"><a href="#5-MetaData-API" class="headerlink" title="5. MetaData API"></a>5. MetaData API</h2><h3 id="5-1-ResultSetMetaData"><a href="#5-1-ResultSetMetaData" class="headerlink" title="5.1 ResultSetMetaData"></a>5.1 <code>ResultSetMetaData</code></h3><p><code>ResultSetMetaData</code> 专注于描述一个<strong>特定查询结果</strong>的结构。当你执行一个查询，但事先不知道（或者不想硬编码）查询结果的列信息时，这个 API 就非常有用了。</p>
<ul>
<li><p><strong>如何获取</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;SELECT id, name, email FROM users&quot;</span>);</span><br><span class="line"><span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>核心应用场景</strong>:</p>
<ul>
<li><strong>编写通用的数据导出工具</strong>: 可以动态地生成 CSV 或 Excel 的表头。</li>
<li><strong>动态 ORM (对象关系映射)</strong>: 自动将 <code>ResultSet</code> 的一行数据映射到一个 <code>JavaBean</code> 或 <code>Map</code> 对象，而无需硬编码列名。</li>
<li><strong>通用数据显示组件</strong>: 在 GUI 或网页上动态地创建一个表格来显示任何查询的结果。</li>
</ul>
</li>
<li><p><strong>关键方法详解</strong>:</p>
<ol>
<li><p><strong><code>int getColumnCount()</code></strong></p>
<ul>
<li><p>返回结果集中的<strong>列数</strong>。这是最常用的方法，通常用于循环遍历所有列。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">    <span class="comment">// ... process column i ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>String getColumnName(int column)</code></strong></p>
<ul>
<li>获取指定列的<strong>原始列名</strong>（在数据库中定义的名称）。</li>
<li><strong>参数</strong>: 列索引，<strong>从 1 开始</strong>。</li>
</ul>
</li>
<li><p><strong><code>String getColumnLabel(int column)</code></strong></p>
<ul>
<li>获取指定列的<strong>显示标签</strong>。在大多数情况下，它和 <code>getColumnName()</code> 返回值相同。</li>
<li>但如果你的 SQL 查询中使用了<strong>别名 (alias)</strong>，如 <code>SELECT user_name AS userName FROM users</code>，那么 <code>getColumnName()</code> 返回 <code>user_name</code>，而 <code>getColumnLabel()</code> 返回 <code>userName</code>。<strong>因此，在显示或映射时，使用 <code>getColumnLabel()</code> 通常是更安全的选择。</strong></li>
</ul>
</li>
<li><p><strong><code>int getColumnType(int column)</code></strong></p>
<ul>
<li>以一个整数代码的形式，返回指定列的 <strong>SQL 数据类型</strong>。</li>
<li>这些整数代码定义在 <code>java.sql.Types</code> 类中（例如, <code>Types.INTEGER</code>, <code>Types.VARCHAR</code>, <code>Types.TIMESTAMP</code>）。你可以用它来判断如何处理该列的数据。</li>
</ul>
</li>
<li><p><strong><code>String getColumnTypeName(int column)</code></strong></p>
<ul>
<li>以字符串形式返回指定列在数据库中的<strong>具体类型名称</strong>，例如 “VARCHAR”, “INT”, “DATETIME”。</li>
</ul>
</li>
<li><p><strong><code>int getPrecision(int column)</code></strong></p>
<ul>
<li>对于数字类型，返回其<strong>精度</strong>（总位数）。</li>
<li>对于字符类型，返回其<strong>最大长度</strong>。</li>
</ul>
</li>
<li><p><strong><code>int getScale(int column)</code></strong></p>
<ul>
<li>对于数字类型（如 <code>DECIMAL</code>），返回其<strong>小数位数</strong>。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>实战示例：将 <code>ResultSet</code> 动态转换为 <code>List&lt;Map&gt;</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">convertResultSetToList</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">ResultSetMetaData</span> <span class="variable">md</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">    <span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> md.getColumnCount();</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; rowData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">            <span class="comment">// 使用 getColumnLabel() 更具稳健性</span></span><br><span class="line">            <span class="comment">// 使用 getObject() 可以自动处理大多数数据类型</span></span><br><span class="line">            rowData.put(md.getColumnLabel(i), rs.getObject(i));</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(rowData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是许多轻量级 JDBC 框架（如 Apache DbUtils）的核心思想。</p>
</li>
</ul>
<hr>
<h3 id="5-2-DatabaseMetaData"><a href="#5-2-DatabaseMetaData" class="headerlink" title="5.2 DatabaseMetaData"></a>5.2 <code>DatabaseMetaData</code></h3><p><code>DatabaseMetaData</code> 提供了关于整个数据库的极其丰富的信息。它是一个庞大的接口，拥有超过 150 个方法。</p>
<ul>
<li><p><strong>如何获取</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="type">DatabaseMetaData</span> <span class="variable">dbmd</span> <span class="operator">=</span> conn.getMetaData();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>核心应用场景</strong>:</p>
<ul>
<li><strong>数据库管理工具</strong>: 类似 Navicat, DBeaver 这样的工具，需要用它来列出所有的数据库、表、视图、索引等。</li>
<li><strong>代码生成器</strong>: 可以读取表结构信息，自动生成对应的 JavaBean 实体类、DAO 代码等。</li>
<li><strong>数据库迁移工具</strong>: 需要用它来获取源数据库的完整结构，以便在目标数据库中重建。</li>
<li><strong>跨数据库兼容性框架</strong>: 判断当前连接的数据库是否支持某个特定的 SQL 特性或语法。</li>
</ul>
</li>
<li><p><strong>关键方法详解 (按功能分类)</strong>:</p>
<p><strong>1. 获取数据库基本信息</strong></p>
<ul>
<li><code>String getDatabaseProductName()</code>: 返回数据库产品名，如 “MySQL”。</li>
<li><code>String getDatabaseProductVersion()</code>: 返回数据库版本号，如 “8.0.33”。</li>
<li><code>String getDriverName()</code>: 返回 JDBC 驱动名。</li>
<li><code>String getURL()</code>: 返回用于创建连接的 URL。</li>
<li><code>String getUserName()</code>: 返回当前连接的用户名。</li>
</ul>
<p><strong>2. 获取数据库对象 (表、列、主键等)</strong><br>这些方法通常返回一个 <code>ResultSet</code>，你需要遍历这个结果集来获取信息。它们支持使用通配符 <code>%</code> (匹配任意多个字符) 和 <code>_</code> (匹配单个字符)。</p>
<ul>
<li><strong><code>ResultSet getTables(String catalog, String schemaPattern, String tableNamePattern, String[] types)</code></strong><ul>
<li>获取数据库中的表信息。</li>
<li><code>catalog</code>: 目录名，对于 MySQL 来说就是数据库名。可以为 <code>null</code>。</li>
<li><code>schemaPattern</code>: 模式名，可以为 <code>null</code>。</li>
<li><code>tableNamePattern</code>: 表名模式，例如 <code>user_%</code> 会匹配所有以 <code>user_</code> 开头的表。<code>null</code> 或 <code>%</code> 表示所有表。</li>
<li><code>types</code>: 一个字符串数组，指定要获取的对象类型，如 <code>{&quot;TABLE&quot;, &quot;VIEW&quot;}</code>。</li>
</ul>
</li>
<li><strong><code>ResultSet getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern)</code></strong><ul>
<li>获取表的列信息。</li>
</ul>
</li>
<li><strong><code>ResultSet getPrimaryKeys(String catalog, String schema, String table)</code></strong><ul>
<li>获取指定表的主键信息。</li>
</ul>
</li>
<li><code>ResultSet getImportedKeys(...)</code>: 获取外键信息。</li>
<li><code>ResultSet getIndexInfo(...)</code>: 获取索引信息。</li>
</ul>
</li>
<li><p><strong>实战示例：列出指定数据库中的所有表名</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listAllTables</span><span class="params">(Connection conn, String dbName)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">DatabaseMetaData</span> <span class="variable">dbmd</span> <span class="operator">=</span> conn.getMetaData();</span><br><span class="line">    <span class="comment">// 第一个参数是 catalog (数据库名), 第三个是表名模式 (null表示所有)</span></span><br><span class="line">    <span class="comment">// 第四个参数是类型 (&quot;TABLE&quot;表示只查找表)</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> dbmd.getTables(dbName, <span class="literal">null</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;TABLE&quot;</span>&#125;)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tables in database &#x27;&quot;</span> + dbName + <span class="string">&quot;&#x27;:&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="comment">// 从返回的 ResultSet 中获取表名，表名在名为 &quot;TABLE_NAME&quot; 的列中</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">tableName</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;TABLE_NAME&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;- &quot;</span> + tableName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 获取数据库能力与限制</strong></p>
<ul>
<li><code>boolean supportsTransactions()</code>: 是否支持事务。</li>
<li><code>boolean supportsBatchUpdates()</code>: 是否支持批量更新。</li>
<li><code>int getMaxConnections()</code>: 最大并发连接数。</li>
<li><code>String getSQLKeywords()</code>: 返回数据库保留的 SQL 关键字列表。</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h1 id="三、数据库操作实战（CRUD-Batch）"><a href="#三、数据库操作实战（CRUD-Batch）" class="headerlink" title="三、数据库操作实战（CRUD &amp; Batch）"></a>三、数据库操作实战（CRUD &amp; Batch）</h1><h2 id="1-查询操作"><a href="#1-查询操作" class="headerlink" title="1. 查询操作"></a>1. 查询操作</h2><h3 id="1-1-核心步骤"><a href="#1-1-核心步骤" class="headerlink" title="1.1 核心步骤"></a>1.1 核心步骤</h3><p>一个完整的查询操作通常遵循以下七个步骤：</p>
<ol>
<li><strong>获取连接</strong>: 从 <code>DriverManager</code> 或 <code>DataSource</code> 获取 <code>Connection</code> 对象。</li>
<li><strong>准备 SQL</strong>: 定义一个包含 <code>SELECT</code> 语句的字符串，使用 <code>?</code>作为参数占位符。</li>
<li><strong>创建 PreparedStatement</strong>: 调用 <code>connection.prepareStatement(sql)</code> 创建预编译的执行器。</li>
<li><strong>设置参数</strong>: 如果 SQL 中有 <code>?</code> 占位符，使用 <code>pstmt.setXXX()</code> 方法为其绑定具体值。</li>
<li><strong>执行查询</strong>: 调用 <code>pstmt.executeQuery()</code> 方法。<strong>该方法专门用于 <code>SELECT</code> 语句，并返回一个 <code>ResultSet</code> 对象。</strong></li>
<li><strong>处理结果集</strong>: 遍历 <code>ResultSet</code>，提取所需的数据。</li>
<li><strong>关闭资源</strong>: 使用 <code>try-with-resources</code> 语句自动关闭 <code>Connection</code>, <code>PreparedStatement</code>, 和 <code>ResultSet</code>。</li>
</ol>
<hr>
<h3 id="1-2-实战代码示例"><a href="#1-2-实战代码示例" class="headerlink" title="1.2 实战代码示例"></a>1.2 实战代码示例</h3><p>假设我们有如下的 <code>users</code> 表结构：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">    registration_date <span class="type">DATE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="1-2-1-查询单个记录-按-ID-查询"><a href="#1-2-1-查询单个记录-按-ID-查询" class="headerlink" title="1.2.1 查询单个记录 (按 ID 查询)"></a>1.2.1 查询单个记录 (按 ID 查询)</h4><p>这是最常见的查询场景之一，例如根据主键查找一个特定的用户。我们预期最多只有一条结果，因此使用 <code>if (rs.next())</code> 来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, email, registration_date FROM users WHERE id = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 try-with-resources 自动管理资源</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DatabaseUtil.getConnection(); <span class="comment">// 假设有一个获取连接的工具类</span></span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 设置参数 (将第一个 ? 设置为 userId)</span></span><br><span class="line">        pstmt.setInt(<span class="number">1</span>, userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 执行查询</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery()) &#123;</span><br><span class="line">            <span class="comment">// 6. 处理结果集</span></span><br><span class="line">            <span class="comment">// 因为是按主键查询，结果最多只有一条，所以用 if</span></span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">                java.sql.<span class="type">Date</span> <span class="variable">regDate</span> <span class="operator">=</span> rs.getDate(<span class="string">&quot;registration_date&quot;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;User Found:&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;ID: &quot;</span> + id);</span><br><span class="line">                System.out.println(<span class="string">&quot;Name: &quot;</span> + name);</span><br><span class="line">                System.out.println(<span class="string">&quot;Email: &quot;</span> + email);</span><br><span class="line">                System.out.println(<span class="string">&quot;Registration Date: &quot;</span> + regDate);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;No user found with ID: &quot;</span> + userId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-2-查询多个记录-查询所有用户"><a href="#1-2-2-查询多个记录-查询所有用户" class="headerlink" title="1.2.2 查询多个记录 (查询所有用户)"></a>1.2.2 查询多个记录 (查询所有用户)</h4><p>当查询可能返回多条记录时，我们需要使用 <code>while (rs.next())</code> 循环来遍历整个结果集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, email FROM users ORDER BY name&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DatabaseUtil.getConnection();</span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">         <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery()) &#123; <span class="comment">// 对于无参数查询，可以直接执行</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;All Users:&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 6. 遍历结果集</span></span><br><span class="line">        <span class="comment">// 当可能有多条结果时，使用 while 循环</span></span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;email&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">&quot;ID: %-5d | Name: %-15s | Email: %s\n&quot;</span>, id, name, email);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-3-将查询结果映射为-Java-对象-ORM-基础"><a href="#1-2-3-将查询结果映射为-Java-对象-ORM-基础" class="headerlink" title="1.2.3 将查询结果映射为 Java 对象 (ORM 基础)"></a>1.2.3 将查询结果映射为 Java 对象 (ORM 基础)</h4><p>在实际开发中，我们很少直接打印数据。更常见的做法是将 <code>ResultSet</code> 中的数据行转换为一个 Java 对象（POJO 或 JavaBean）。这是 ORM (对象关系映射) 思想的基础。</p>
<p>首先，定义一个 <code>User</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">// Getters, Setters, Constructor, toString()...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，修改查询方法，使其返回一个 <code>User</code> 对象的列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAllUsersAsObjects</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, email FROM users&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DatabaseUtil.getConnection();</span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">         <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="comment">// 创建一个新的 User 对象来存储当前行的数据</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">            user.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            user.setEmail(rs.getString(<span class="string">&quot;email&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将填充好的对象添加到列表中</span></span><br><span class="line">            userList.add(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userList; <span class="comment">// 返回包含所有用户对象的列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-3-最佳实践"><a href="#1-3-最佳实践" class="headerlink" title="1.3 最佳实践"></a>1.3 最佳实践</h3><ol>
<li><strong>始终使用 <code>try-with-resources</code></strong>：<br>这是管理 JDBC 资源的最佳方式。它能确保 <code>Connection</code>, <code>PreparedStatement</code>, <code>ResultSet</code> 在代码块结束时被自动、正确地关闭，即使发生异常也能保证，从而彻底避免资源泄露。</li>
<li><strong><code>PreparedStatement</code> 优先</strong>：<br>即使查询没有参数，也推荐使用 <code>PreparedStatement</code>。它不仅能防止 SQL 注入，还能在多次执行相同结构的 SQL 时提供性能优势。</li>
<li><strong>理解 <code>executeQuery()</code> 的返回值</strong>：<br><code>executeQuery()</code> <strong>永远不会返回 <code>null</code></strong>。如果查询没有找到任何匹配的记录，它会返回一个<strong>空的 <code>ResultSet</code> 对象</strong>。你可以通过 <code>rs.next()</code> 的返回值来判断是否有数据。</li>
<li><strong><code>if (rs.next())</code> vs <code>while (rs.next())</code></strong>：<ul>
<li>当你预期查询结果最多只有 <strong>一条</strong> (如按唯一键查询) 时，使用 <code>if</code>。</li>
<li>当你预期查询结果可能有 <strong>多条</strong> 时，使用 <code>while</code> 循环。</li>
</ul>
</li>
<li><strong>使用列名获取数据</strong>：<br>强烈推荐使用 <code>rs.getString(&quot;column_name&quot;)</code> 而不是 <code>rs.getString(1)</code>。使用列名使得代码更具可读性，并且不受 <code>SELECT</code> 语句中列顺序变化的影响。</li>
<li><strong>及时将数据转换为领域对象</strong>：<br>不要让 <code>ResultSet</code> 对象在你的应用程序中传递太远。最佳实践是在数据访问层（DAO）中立即将其转换为业务领域对象（如 <code>User</code> 对象），这样可以使业务逻辑代码与 JDBC API 解耦。</li>
</ol>
<hr>
<h2 id="2-增删改操作"><a href="#2-增删改操作" class="headerlink" title="2. 增删改操作"></a>2. 增删改操作</h2><h3 id="2-1-核心方法：int-executeUpdate"><a href="#2-1-核心方法：int-executeUpdate" class="headerlink" title="2.1 核心方法：int executeUpdate()"></a>2.1 核心方法：<code>int executeUpdate()</code></h3><p><code>executeUpdate()</code> 是执行 DML (Data Manipulation Language) 和 DDL (Data Definition Language) 语句的核心方法。</p>
<ul>
<li><strong>用途</strong>: 用于执行 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> 语句，也可以执行 <code>CREATE TABLE</code>, <code>DROP TABLE</code> 等。</li>
<li><strong>返回值 (<code>int</code>)</strong>: 该方法返回一个整数，表示<strong>受此 SQL 语句影响的数据库行数</strong>。<ul>
<li>对于 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>，返回值是实际被插入、更新或删除的行数。</li>
<li>对于 DDL 语句，返回值通常是 <code>0</code>。</li>
</ul>
</li>
<li><strong>返回值的重要性</strong>: 检查 <code>executeUpdate()</code> 的返回值是<strong>非常重要的</strong>。它可以帮助你判断操作是否真正成功。例如，如果你期望更新一行数据，但返回值是 <code>0</code>，这通常意味着 <code>WHERE</code> 子句没有匹配到任何记录。</li>
</ul>
<hr>
<h3 id="2-2-插入操作-INSERT"><a href="#2-2-插入操作-INSERT" class="headerlink" title="2.2 插入操作 (INSERT)"></a>2.2 插入操作 (INSERT)</h3><p>插入操作用于向数据库表中添加新的记录。</p>
<p><strong>示例：向 <code>users</code> 表中添加一个新用户</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String name, String email, java.sql.Date registrationDate)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO users (name, email, registration_date) VALUES (?, ?, ?)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DatabaseUtil.getConnection();</span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置参数</span></span><br><span class="line">        pstmt.setString(<span class="number">1</span>, name);</span><br><span class="line">        pstmt.setString(<span class="number">2</span>, email);</span><br><span class="line">        pstmt.setDate(<span class="number">3</span>, registrationDate);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行插入操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">affectedRows</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查返回值</span></span><br><span class="line">        <span class="keyword">if</span> (affectedRows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;User inserted successfully!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;User insertion failed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">// 比如，email 字段有 UNIQUE 约束，插入重复 email 会抛出异常</span></span><br><span class="line">        System.err.println(<span class="string">&quot;Error inserting user: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>高级技巧：获取自增主键 (Auto-Generated Keys)</strong></p>
<p>在许多场景下，当我们插入一条新记录后，需要立即知道数据库为它生成的自增主键 。JDBC 提供了标准的方式来获取这个值。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>在调用 <code>connection.prepareStatement()</code> 时，传入第二个参数 <code>Statement.RETURN_GENERATED_KEYS</code>。</li>
<li>正常执行 <code>executeUpdate()</code>。</li>
<li>执行后，通过 <code>pstmt.getGeneratedKeys()</code> 方法获取一个包含生成键的 <code>ResultSet</code>。</li>
<li>遍历这个 <code>ResultSet</code> 来提取键值。</li>
</ol>
<p><strong>示例：插入用户并获取其新生成的 ID</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">addUserAndGetId</span><span class="params">(String name, String email)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO users (name, email) VALUES (?, ?)&quot;</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">newUserId</span> <span class="operator">=</span> -<span class="number">1L</span>; <span class="comment">// 默认为-1，表示失败</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DatabaseUtil.getConnection();</span><br><span class="line">         <span class="comment">// 1. 告知 PreparedStatement 需要返回生成的主键</span></span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) &#123;</span><br><span class="line"></span><br><span class="line">        pstmt.setString(<span class="number">1</span>, name);</span><br><span class="line">        pstmt.setString(<span class="number">2</span>, email);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">affectedRows</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (affectedRows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2. 获取包含主键的 ResultSet</span></span><br><span class="line">            <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">generatedKeys</span> <span class="operator">=</span> pstmt.getGeneratedKeys()) &#123;</span><br><span class="line">                <span class="comment">// 3. 移动到第一行并获取主键值</span></span><br><span class="line">                <span class="keyword">if</span> (generatedKeys.next()) &#123;</span><br><span class="line">                    newUserId = generatedKeys.getLong(<span class="number">1</span>); <span class="comment">// 通常主键在第一列</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;User inserted successfully with ID: &quot;</span> + newUserId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newUserId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-更新操作-UPDATE"><a href="#2-3-更新操作-UPDATE" class="headerlink" title="2.3 更新操作 (UPDATE)"></a>2.3 更新操作 (UPDATE)</h3><p>更新操作用于修改表中已存在的记录。</p>
<p><strong>关键点</strong>: <code>UPDATE</code> 语句<strong>必须</strong>带上 <code>WHERE</code> 子句，否则将会更新表中的所有行，这通常是灾难性的。</p>
<p><strong>示例：根据用户 ID 更新其 email 地址</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateUserEmail</span><span class="params">(<span class="type">int</span> userId, String newEmail)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE users SET email = ? WHERE id = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DatabaseUtil.getConnection();</span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line"></span><br><span class="line">        pstmt.setString(<span class="number">1</span>, newEmail);</span><br><span class="line">        pstmt.setInt(<span class="number">2</span>, userId);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">affectedRows</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 affectedRows == 1，表示成功更新了一行</span></span><br><span class="line">        <span class="comment">// 如果 affectedRows == 0，表示没有找到 ID 匹配的用户</span></span><br><span class="line">        <span class="keyword">if</span> (affectedRows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;User email updated successfully for ID: &quot;</span> + userId);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No user found with ID: &quot;</span> + userId + <span class="string">&quot;. Nothing updated.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-4-删除操作-DELETE"><a href="#2-4-删除操作-DELETE" class="headerlink" title="2.4 删除操作 (DELETE)"></a>2.4 删除操作 (DELETE)</h3><p>删除操作用于从表中移除记录。</p>
<p><strong>关键点</strong>: 与 <code>UPDATE</code> 一样，<code>DELETE</code> 语句<strong>必须</strong>带上 <code>WHERE</code> 子句，否则会清空整个表！</p>
<p><strong>示例：根据用户 ID 删除用户</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteUser</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;DELETE FROM users WHERE id = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DatabaseUtil.getConnection();</span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line"></span><br><span class="line">        pstmt.setInt(<span class="number">1</span>, userId);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">affectedRows</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (affectedRows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;User with ID: &quot;</span> + userId + <span class="string">&quot; was deleted successfully.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No user found with ID: &quot;</span> + userId + <span class="string">&quot;. Nothing deleted.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-5-最佳实践"><a href="#2-5-最佳实践" class="headerlink" title="2.5 最佳实践"></a>2.5 最佳实践</h3><ol>
<li><strong>统一使用 <code>executeUpdate()</code></strong>：这是执行所有数据修改操作的标准方法。</li>
<li><strong><code>PreparedStatement</code> 是必须的</strong>：防止 SQL 注入，提高性能和代码可读性。</li>
<li><strong>总是检查 <code>affectedRows</code></strong>：不要假设你的操作一定成功。通过检查返回值，可以为你的应用程序增加更健壮的逻辑判断（例如，向用户反馈“更新失败，记录不存在”）。</li>
<li><strong><code>WHERE</code> 子句，再三确认</strong>：在编写 <code>UPDATE</code> 和 <code>DELETE</code> 语句时，<code>WHERE</code> 子句是你的安全带。在执行前务必确认其逻辑是正确的。</li>
<li><strong>资源管理</strong>：始终使用 <code>try-with-resources</code> 来确保 <code>Connection</code> 和 <code>PreparedStatement</code> 被正确关闭。</li>
<li><strong>封装到 DAO 方法中</strong>：将这些数据库操作逻辑封装在数据访问对象（DAO）的方法中（如 <code>userDao.addUser()</code>, <code>userDao.updateUser()</code>），使业务逻辑层代码更清晰。</li>
</ol>
<hr>
<h2 id="3-批量操作"><a href="#3-批量操作" class="headerlink" title="3. 批量操作"></a>3. 批量操作</h2><h3 id="3-1-核心方法"><a href="#3-1-核心方法" class="headerlink" title="3.1 核心方法"></a>3.1 核心方法</h3><p><strong>批量操作的核心思想</strong>：将多条 SQL 语句“打包”在一起，通过一次网络通信发送给数据库，由数据库一次性执行完毕。主要通过 <code>Statement</code> 或 <code>PreparedStatement</code> 接口的三个方法实现：</p>
<ol>
<li><strong><code>void addBatch()</code></strong><ul>
<li><strong>作用</strong>: 将当前已设置好参数的 <code>PreparedStatement</code>（或 <code>Statement</code> 的 SQL）添加到当前的“批处理”列表中。它不清空参数，只是将当前状态“暂存”起来，等待执行。</li>
</ul>
</li>
<li><strong><code>int[] executeBatch()</code></strong><ul>
<li><strong>作用</strong>: 将 <code>addBatch()</code> 添加的所有 SQL 语句一次性发送到数据库执行。</li>
<li><strong>返回值 (<code>int[]</code>)</strong>: 返回一个整数数组。数组中的<strong>每个元素对应一批中一条 SQL 语句的执行结果</strong>。<ul>
<li>对于 <code>INSERT/UPDATE/DELETE</code>，该元素的值是该语句影响的行数。</li>
<li>如果某条语句执行成功但无法确定影响的行数，驱动程序可能返回 <code>Statement.SUCCESS_NO_INFO</code> (-2)。</li>
<li>如果某条语句执行失败，驱动程序可能返回 <code>Statement.EXECUTE_FAILED</code> (-3) 或直接抛出 <code>BatchUpdateException</code>。</li>
</ul>
</li>
<li><strong>注意</strong>: 数组的长度等于你调用 <code>addBatch()</code> 的次数。</li>
</ul>
</li>
<li><strong><code>void clearBatch()</code></strong><ul>
<li><strong>作用</strong>: 清空当前批处理列表中的所有 SQL 语句。如果你在执行前想取消这批操作，可以调用此方法。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-2-实战示例"><a href="#3-2-实战示例" class="headerlink" title="3.2 实战示例"></a>3.2 实战示例</h3><p><strong>示例：批量插入多个用户记录</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUsersInBatch</span><span class="params">(List&lt;User&gt; userList)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO users (name, email) VALUES (?, ?)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DatabaseUtil.getConnection();</span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历用户列表</span></span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            <span class="comment">// 1. 设置参数</span></span><br><span class="line">            pstmt.setString(<span class="number">1</span>, user.getName());</span><br><span class="line">            pstmt.setString(<span class="number">2</span>, user.getEmail());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 添加到批处理</span></span><br><span class="line">            pstmt.addBatch();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 执行批处理</span></span><br><span class="line">        <span class="type">int</span>[] updateCounts = pstmt.executeBatch();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. (可选) 检查执行结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Batch execution completed.&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Total statements in batch: &quot;</span> + updateCounts.length);</span><br><span class="line">        <span class="comment">// 可以遍历 updateCounts 数组来检查每一条语句的执行情况</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-最佳实践"><a href="#3-3-最佳实践" class="headerlink" title="3.3 最佳实践"></a>3.3 最佳实践</h3><ol>
<li><p><strong>分批提交 (Batch Sizing)</strong>:<br>一次性向上百万条数据 <code>addBatch()</code> 可能会导致客户端内存溢出。明智的做法是设定一个合理的批次大小（例如每 1000 条执行一次），分批提交。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">BATCH_SIZE</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (User user : largeUserList) &#123;</span><br><span class="line">    pstmt.setString(<span class="number">1</span>, user.getName());</span><br><span class="line">    pstmt.addBatch();</span><br><span class="line">    <span class="keyword">if</span> (++count % BATCH_SIZE == <span class="number">0</span>) &#123;</span><br><span class="line">        pstmt.executeBatch(); <span class="comment">// 执行批处理</span></span><br><span class="line">        <span class="comment">// pstmt.clearBatch(); // 某些驱动需要手动清空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">pstmt.executeBatch(); <span class="comment">// 执行最后一批不足 BATCH_SIZE 的数据</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>MySQL 驱动的特定优化</strong>:<br>对于 MySQL，为了获得最佳的批量插入性能，需要在数据库连接 URL 中添加一个关键参数 <code>rewriteBatchedStatements=true</code>。<br><code>jdbc:mysql://localhost:3306/my_db?rewriteBatchedStatements=true</code><br>这个参数会告诉驱动将多个 <code>INSERT</code> 语句重写为一条多值插入语句 (<code>INSERT INTO ... VALUES (...), (...), ...</code>)，性能提升非常巨大。</p>
</li>
<li><p><strong>关闭自动提交</strong>:<br>执行批量操作前先 <code>conn.setAutoCommit(false)</code>，不仅是为了事务的原子性，在某些数据库和驱动中，这也能带来性能提升，因为它减少了每次操作都要写事务日志的开销。</p>
</li>
</ol>
<hr>
<h2 id="4-事务处理（Transaction）"><a href="#4-事务处理（Transaction）" class="headerlink" title="4. 事务处理（Transaction）"></a>4. 事务处理（Transaction）</h2><h3 id="4-1-事务的开关"><a href="#4-1-事务的开关" class="headerlink" title="4.1 事务的开关"></a>4.1 事务的开关</h3><p><code>setAutoCommit</code> 是 <code>Connection</code> 对象的一个方法，它控制着连接的提交模式。这是 JDBC 事务管理的<strong>核心开关</strong>。</p>
<ul>
<li><strong><code>connection.setAutoCommit(true)</code> (默认模式)</strong><ul>
<li><strong>含义</strong>: 自动提交模式。</li>
<li><strong>行为</strong>: 在这种模式下，<strong>每一条单独的 SQL 语句都被视为一个独立的事务</strong>，并且在执行完毕后会<strong>立即自动提交</strong>到数据库。</li>
<li><strong>优点</strong>: 简单，无需手动管理。对于那些独立的、不需要与其他操作绑定的单条 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> 语句来说非常方便。</li>
<li><strong>缺点</strong>: 无法将多个 SQL 语句组合成一个逻辑单元。例如，在银行转账案例中，如果使用自动提交，扣款操作一旦成功就会立刻生效，即使后续的存款操作失败，也无法撤销扣款。</li>
</ul>
</li>
<li><strong><code>connection.setAutoCommit(false)</code> (手动事务模式)</strong><ul>
<li><strong>含义</strong>: 关闭自动提交，开启手动事务管理。</li>
<li><strong>行为</strong>: 当你调用此方法后，JDBC 不会再自动提交任何 SQL 语句。从这个调用点开始，直到你显式调用 <code>commit()</code> 或 <code>rollback()</code> 方法之前，所有执行的 SQL 语句都属于<strong>同一个事务</strong>。</li>
<li><strong>这是进行手动事务控制的</strong>第一步，也是<strong>必须的</strong>一步。</li>
</ul>
</li>
</ul>
<p><strong>最佳实践</strong>:</p>
<ul>
<li>在一个业务方法开始时，获取连接后，<strong>立即</strong>调用 <code>conn.setAutoCommit(false);</code> 来开启事务。</li>
<li>在方法的 <code>finally</code> 块中，将连接关闭前，<strong>恢复</strong>其自动提交状态 <code>conn.setAutoCommit(true);</code>。这对于使用了<strong>连接池</strong>的环境至关重要，因为当你关闭（归还）连接时，连接池期望连接恢复到默认状态，以免影响下一个使用者。</li>
</ul>
<hr>
<h3 id="4-2-事务的终点"><a href="#4-2-事务的终点" class="headerlink" title="4.2 事务的终点"></a>4.2 事务的终点</h3><p>一旦进入手动事务模式，就必须为事务的结束负责。事务的结束只有两种可能：成功提交或失败回滚。</p>
<ul>
<li><strong><code>void commit()</code></strong><ul>
<li><strong>含义</strong>: 提交事务。</li>
<li><strong>行为</strong>: 将当前事务中自上次提交&#x2F;回滚以来执行的所有 SQL 操作<strong>永久性地保存</strong>到数据库中。这对应了事务的<strong>持久性 (Durability)</strong>。</li>
<li><strong>调用时机</strong>: 在 <code>try</code> 块的<strong>末尾</strong>，当所有数据库操作都已成功执行，并且业务逻辑确认可以提交时调用。</li>
<li>调用 <code>commit()</code> 之后，当前事务结束。如果连接继续使用，一个新的事务会立即隐式开始。</li>
</ul>
</li>
<li><strong><code>void rollback()</code></strong><ul>
<li><strong>含义</strong>: 回滚事务。</li>
<li><strong>行为</strong>: <strong>撤销</strong>当前事务中自上次提交&#x2F;回滚以来执行的所有 SQL 操作，使数据库恢复到事务开始之前的状态。这对应了事务的<strong>原子性 (Atomicity)</strong>。</li>
<li><strong>调用时机</strong>: 在 <code>catch</code> 块中。当 <code>try</code> 块中的任何数据库操作或业务逻辑检查抛出异常时，表明事务无法成功完成，此时必须调用 <code>rollback()</code> 来保证数据的一致性。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-3-事务代码"><a href="#4-3-事务代码" class="headerlink" title="4.3 事务代码"></a>4.3 事务代码</h3><p>结合 <code>try-catch-finally</code> 结构，一个健壮的 JDBC 事务处理代码应遵循以下模板。我们再次以银行转账为例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferMoney</span><span class="params">(<span class="type">int</span> fromId, <span class="type">int</span> toId, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">debitStmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">creditStmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取连接</span></span><br><span class="line">        conn = DatabaseUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 关闭自动提交，开启事务</span></span><br><span class="line">        conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 事务操作开始 ---</span></span><br><span class="line">        <span class="comment">// 步骤 A: 扣款</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">debitSql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE accounts SET balance = balance - ? WHERE id = ?&quot;</span>;</span><br><span class="line">        debitStmt = conn.prepareStatement(debitSql);</span><br><span class="line">        debitStmt.setDouble(<span class="number">1</span>, amount);</span><br><span class="line">        debitStmt.setInt(<span class="number">2</span>, fromId);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowsAffected1</span> <span class="operator">=</span> debitStmt.executeUpdate();</span><br><span class="line">        <span class="keyword">if</span> (rowsAffected1 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;Debit failed, account not found or insufficient funds.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤 B: 存款</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">creditSql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE accounts SET balance = balance + ? WHERE id = ?&quot;</span>;</span><br><span class="line">        creditStmt = conn.prepareStatement(creditSql);</span><br><span class="line">        creditStmt.setDouble(<span class="number">1</span>, amount);</span><br><span class="line">        creditStmt.setInt(<span class="number">2</span>, toId);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowsAffected2</span> <span class="operator">=</span> creditStmt.executeUpdate();</span><br><span class="line">        <span class="keyword">if</span> (rowsAffected2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;Credit failed, account not found.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// --- 事务操作结束 ---</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 所有操作成功，提交事务</span></span><br><span class="line">        conn.commit();</span><br><span class="line">        System.out.println(<span class="string">&quot;Transaction committed successfully.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Transaction failed. Performing rollback.&quot;</span>);</span><br><span class="line">        <span class="comment">// 4. 发生异常，回滚事务</span></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.rollback();</span><br><span class="line">                System.err.println(<span class="string">&quot;Rollback successful.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Error during rollback: &quot;</span> + ex.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 5. 在 finally 块中统一关闭资源</span></span><br><span class="line">        <span class="comment">//    注意：为了代码简洁，这里省略了每个 close 的 try-catch，</span></span><br><span class="line">        <span class="comment">//    在实际工具类中应妥善处理。</span></span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="keyword">if</span> (debitStmt != <span class="literal">null</span>) debitStmt.close(); &#125; <span class="keyword">catch</span> (SQLException e) &#123;&#125;</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="keyword">if</span> (creditStmt != <span class="literal">null</span>) creditStmt.close(); &#125; <span class="keyword">catch</span> (SQLException e) &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 恢复自动提交模式，为连接池做准备</span></span><br><span class="line">                conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码模板要点总结</strong>：</p>
<ol>
<li><strong>资源声明</strong>: 将 <code>Connection</code> 对象在 <code>try</code> 块外部声明为 <code>null</code>，以便 <code>catch</code> 和 <code>finally</code> 块可以访问它。</li>
<li><strong>开启事务</strong>: 在 <code>try</code> 块的开头，获取连接后立即调用 <code>conn.setAutoCommit(false);</code>。</li>
<li><strong>提交事务</strong>: 在 <code>try</code> 块的末尾，所有数据库操作成功后调用 <code>conn.commit();</code>。</li>
<li><strong>回滚事务</strong>: 在 <code>catch (SQLException e)</code> 块中，捕获到任何与数据库相关的异常时，调用 <code>conn.rollback();</code>。回滚操作本身也可能失败，所以 <code>rollback()</code> 调用也应该被一个 <code>try-catch</code> 包围。</li>
<li><strong>资源清理</strong>: 在 <code>finally</code> 块中，<strong>必须</strong>关闭所有打开的 <code>Statement</code> 和 <code>Connection</code> 资源。并且在关闭 <code>Connection</code> 之前，最好将其恢复到自动提交模式 <code>conn.setAutoCommit(true);</code>。</li>
</ol>
<hr>
<hr>
<h1 id="四、企业级开发实践"><a href="#四、企业级开发实践" class="headerlink" title="四、企业级开发实践"></a>四、企业级开发实践</h1><h2 id="1-连接池"><a href="#1-连接池" class="headerlink" title="1. 连接池"></a>1. 连接池</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p><strong>数据库连接池</strong>是一种管理数据库连接的<strong>缓冲池技术</strong>。它的核心思想是在应用程序启动时，预先创建并维护一定数量的数据库连接对象，并将这些连接存放在一个“池子”里。当应用程序需要与数据库交互时，它不是直接创建一个新的连接，而是从池中“借用”一个已存在的空闲连接。使用完毕后，也不是关闭这个连接，而是将其“归还”到池中，以供其他线程或请求复用。</p>
<hr>
<h3 id="1-2-解决的核心问题"><a href="#1-2-解决的核心问题" class="headerlink" title="1.2 解决的核心问题"></a>1.2 解决的核心问题</h3><p>如果不使用连接池，每次数据库操作都遵循“<strong>建立连接 -&gt; 执行SQL -&gt; 关闭连接</strong>”的流程。这个过程，尤其是“建立连接”，是一个非常耗费资源和时间的操作。</p>
<p><strong>建立一个数据库连接的成本包括：</strong></p>
<ol>
<li><strong>网络开销</strong>：客户端与数据库服务器之间需要经过 TCP&#x2F;IP 的三次握手来建立物理连接。</li>
<li><strong>数据库认证</strong>：数据库需要验证客户端提供的用户名和密码。</li>
<li><strong>会话准备</strong>：数据库需要为这个连接创建和分配内存、准备会话环境等。</li>
<li><strong>资源消耗</strong>：频繁地创建和销毁连接会给数据库服务器带来巨大的性能压力，并消耗大量的内存和 CPU 资源。</li>
</ol>
<p><strong>使用连接池带来的核心优势：</strong></p>
<ul>
<li><strong>性能提升</strong>：通过复用连接，避免了频繁创建和销毁连接的开销，极大地减少了请求的响应时间。</li>
<li><strong>资源管理</strong>：连接池可以统一管理连接的分配和释放，有效控制应用程序的最大连接数，防止因连接数过多而压垮数据库。</li>
<li><strong>可靠性增强</strong>：连接池通常具备连接有效性检测、自动重连等功能，可以剔除失效的连接，保证应用程序获取到的连接是可用的。</li>
</ul>
<hr>
<h3 id="1-3-工作原理"><a href="#1-3-工作原理" class="headerlink" title="1.3 工作原理"></a>1.3 工作原理</h3><p>一个典型的连接池工作流程如下：</p>
<ol>
<li><strong>初始化 (Initialization)</strong>：服务启动时，连接池根据配置创建一组初始的数据库连接（<code>initialSize</code>），并将它们置为空闲状态。</li>
<li><strong>借用连接 (Borrowing)</strong>：<ul>
<li>当应用程序请求连接时，连接池首先检查是否有空闲连接。</li>
<li>如果有，就将一个空闲连接标记为“活动”状态并返回给应用程序。</li>
<li>如果没有空闲连接，且当前总连接数未达到上限（<code>maxActive</code>），连接池会创建一个新的连接。</li>
<li>如果已达到上限，请求线程会根据配置进行等待（<code>maxWait</code>），直到有连接被归还或等待超时。</li>
</ul>
</li>
<li><strong>使用连接 (Using)</strong>：应用程序使用这个连接执行数据库操作。</li>
<li><strong>归还连接 (Returning)</strong>：<ul>
<li>应用程序调用 <code>connection.close()</code> 方法。</li>
<li><strong>关键点</strong>：这个 <code>close()</code> 方法被连接池框架重写了。它并<strong>不会真正关闭物理连接</strong>，而是将连接的状态从“活动”重置为“空闲”，然后将其放回池中。</li>
</ul>
</li>
<li><strong>维护 (Maintenance)</strong>：连接池在后台会有一个维护线程，定期检查池中连接的健康状况（如使用 <code>validationQuery</code>），关闭长时间未使用的空闲连接（维持在 <code>minIdle</code> 数量），并确保连接的有效性。</li>
</ol>
<hr>
<h3 id="1-4-核心配置参数解析"><a href="#1-4-核心配置参数解析" class="headerlink" title="1.4 核心配置参数解析"></a>1.4 核心配置参数解析</h3><p>配置连接池时，通常会遇到以下几个关键参数，合理配置它们对系统性能至关重要。</p>
<table>
<thead>
<tr>
<th>参数名 (常见)</th>
<th>含义</th>
<th>建议与说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>initialSize</code></td>
<td>初始连接数。连接池启动时创建的连接数量。</td>
<td>建议设置一个合理的值，避免应用启动后短时间内因创建连接导致响应变慢。</td>
</tr>
<tr>
<td><code>minIdle</code></td>
<td>最小空闲连接数。即使没有请求，池中也要保留的最小连接数。</td>
<td>如果系统有突发流量，设置此值可以保证能快速响应，因为它避免了从零开始创建连接。</td>
</tr>
<tr>
<td><code>maxActive</code> &#x2F; <code>maximumPoolSize</code></td>
<td>最大连接数。池中允许存在的最大连接总数（包括活动和空闲）。</td>
<td><strong>最关键的参数</strong>。设置过小会导致请求排队等待，设置过大会耗尽数据库资源。需要根据数据库并发能力和应用QPS进行压测后确定。</td>
</tr>
<tr>
<td><code>maxWait</code> &#x2F; <code>connectionTimeout</code></td>
<td>最大等待时间。当池中没有可用连接时，请求线程等待的最长时间（毫秒）。</td>
<td>设置-1表示无限等待（不推荐）。建议设置一个合理的超时时间（如3000ms），超时后应抛出异常，防止线程无限期阻塞。</td>
</tr>
<tr>
<td><code>validationQuery</code></td>
<td>连接有效性检查SQL。用于在借出连接前，检查该连接是否仍然有效。</td>
<td>例如 <code>SELECT 1</code> (MySQL)。开启此功能会带来轻微性能损耗，但能有效避免拿到“死亡”连接。</td>
</tr>
<tr>
<td><code>testOnBorrow</code></td>
<td>是否在借用连接前进行有效性检查。</td>
<td>设为 <code>true</code> 可以保证每次拿到的连接都是可用的，但性能开销较大。现代连接池（如HikariCP）有更高效的检测机制。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-5-主流连接池介绍"><a href="#1-5-主流连接池介绍" class="headerlink" title="1.5 主流连接池介绍"></a>1.5 主流连接池介绍</h3><ul>
<li><strong><code>DataSource</code> 接口</strong>:<br>在介绍具体实现之前，必须提到 <code>javax.sql.DataSource</code> 接口。这是 JDBC 2.0 引入的标准接口，是所有连接池实现的<strong>通用门面</strong>。它取代了 <code>DriverManager</code>，成为现代应用中获取连接的首选方式。通过面向 <code>DataSource</code> 编程，你的代码可以与任何连接池实现解耦。</li>
<li><strong>常见连接池库</strong>:<ol>
<li><strong>DBCP (Database Connection Pool)</strong>:<ul>
<li>由 Apache Commons 开发，是比较早期的连接池实现。</li>
<li><strong>优点</strong>: 成熟，与 Apache 其他项目集成良好。</li>
<li><strong>缺点</strong>: 配置相对复杂，性能在现代连接池中已不占优势，存在一些已知的并发问题。</li>
</ul>
</li>
<li><strong>C3P0</strong>:<ul>
<li>一个非常稳定、功能强大的老牌连接池。</li>
<li><strong>优点</strong>: 功能极其丰富，配置项非常多，提供了强大的连接测试和自动重连功能。</li>
<li><strong>缺点</strong>: 配置复杂，性能相比新一代连接池较慢。</li>
</ul>
</li>
<li><strong>HikariCP (光连接池)</strong>:<ul>
<li><strong>当前 Java 社区公认的性能之王</strong>。</li>
<li><strong>优点</strong>:<ul>
<li><strong>极速</strong>: 在性能和可靠性上做了大量的微优化，号称“史上最快连接池”。</li>
<li><strong>轻量</strong>: JAR 包非常小。</li>
<li><strong>稳定可靠</strong>: 设计简洁，代码质量高。</li>
</ul>
</li>
<li><strong>现状</strong>: <strong>Spring Boot 2.x 及以后版本的默认连接池</strong>。对于新项目，<strong>HikariCP 是首选</strong>。</li>
</ul>
</li>
<li><strong>Druid (德鲁伊)</strong>:<ul>
<li>由阿里巴巴开源，是国内使用最广泛的连接池之一。</li>
<li><strong>优点</strong>:<ul>
<li><strong>强大的监控功能</strong>: 提供了丰富、详细的 SQL 监控、Web URI 监控、Session 监控等，并内置了一个美观的监控 Web 界面。这是它最大的特色。</li>
<li><strong>防 SQL 注入</strong>: 内置了 SQL 解析器，可以有效地防御 SQL 注入。</li>
<li><strong>丰富的扩展功能</strong>: 支持数据库密码加密、SQL 防火墙等。</li>
</ul>
</li>
<li><strong>缺点</strong>: 相比 HikariCP，性能略逊一筹，且 JAR 包较大。</li>
<li><strong>适用场景</strong>: 如果你对数据库监控有强烈的需求，Druid 是一个非常好的选择。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>选择建议</strong>:</p>
<ul>
<li><strong>新项目&#x2F;性能优先</strong>: 毫不犹豫地选择 <strong>HikariCP</strong>。</li>
<li><strong>需要强大监控&#x2F;遗留项目升级</strong>: <strong>Druid</strong> 是一个非常可靠且功能丰富的选项。</li>
<li>DBCP 和 C3P0 在新项目中已不推荐使用。</li>
</ul>
<hr>
<h3 id="1-6-Druid-连接池配置与使用示例"><a href="#1-6-Druid-连接池配置与使用示例" class="headerlink" title="1.6 Druid 连接池配置与使用示例"></a>1.6 Druid 连接池配置与使用示例</h3><p>下面以国内广泛使用的 Druid 为例，演示如何配置和使用连接池。</p>
<p><strong>步骤 1: 添加 Maven 依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 使用最新稳定版 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库驱动依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 创建并配置 DataSource</strong></p>
<p>通常我们会创建一个工具类来管理 <code>DataSource</code> 的单例实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块，在类加载时初始化 DataSource</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 加载配置文件</span></span><br><span class="line">            <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> DruidUtil.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">            props.load(is);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 使用 DruidDataSourceFactory 创建 DataSource</span></span><br><span class="line">            dataSource = DruidDataSourceFactory.createDataSource(props);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to initialize Druid DataSource&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个公共的静态方法来获取 DataSource</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个公共的静态方法来获取连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">// 从连接池获取连接</span></span><br><span class="line">        <span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3: 创建配置文件 (<code>druid.properties</code>)</strong></p>
<p>在你的 <code>resources</code> 目录下创建 <code>druid.properties</code> 文件。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本属性</span></span><br><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/my_db?serverTimezone=UTC&amp;rewriteBatchedStatements=true</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">your_password</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Druid 配置项</span></span><br><span class="line"><span class="comment"># 初始化连接池大小</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># 最小空闲连接数</span></span><br><span class="line"><span class="attr">minIdle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># 最大活动连接数</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">20</span></span><br><span class="line"><span class="comment"># 获取连接等待超时的时间 (毫秒)</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">60000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 配置间隔多久才进行一次检测，检测需要关闭的空闲连接 (毫秒)</span></span><br><span class="line"><span class="attr">timeBetweenEvictionRunsMillis</span>=<span class="string">60000</span></span><br><span class="line"><span class="comment"># 配置一个连接在池中最小生存的时间 (毫秒)</span></span><br><span class="line"><span class="attr">minEvictableIdleTimeMillis</span>=<span class="string">300000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 用来检测连接是否有效的 sql</span></span><br><span class="line"><span class="attr">validationQuery</span>=<span class="string">SELECT 1</span></span><br><span class="line"><span class="comment"># 建议配置为 true，不影响性能，并且保证安全性</span></span><br><span class="line"><span class="attr">testWhileIdle</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 申请连接的时候检测</span></span><br><span class="line"><span class="attr">testOnBorrow</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 归还连接的时候检测</span></span><br><span class="line"><span class="attr">testOnReturn</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 是否开启 PS Cache，并指定每个连接上 PS Cache 的大小</span></span><br><span class="line"><span class="attr">poolPreparedStatements</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">maxPoolPreparedStatementPerConnectionSize</span>=<span class="string">20</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 配置监控统计拦截的 filters，wall 用于防火墙</span></span><br><span class="line"><span class="attr">filters</span>=<span class="string">stat,wall,log4j</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 4: 在业务代码中使用</strong></p>
<p>代码不再需要关心 <code>DriverManager</code>，直接通过工具类向连接池获取连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE id = ?&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意这里 conn 的获取方式变了</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DruidUtil.getConnection(); <span class="comment">// 从连接池借用连接</span></span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line"></span><br><span class="line">        pstmt.setInt(<span class="number">1</span>, userId);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                <span class="comment">// ... process data</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// try-with-resources 会自动调用 conn.close()，</span></span><br><span class="line">    <span class="comment">// 对于连接池来说，这实际上是“归还连接”的操作。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>: <code>conn.close()</code> 的行为被连接池<strong>重写 (override)</strong> 了。它不再是关闭物理连接，而是将连接的状态重置并放回池中，等待下一次被借用。这个机制对应用程序是<strong>透明的</strong>。</p>
<hr>
<h3 id="1-7-连接泄漏"><a href="#1-7-连接泄漏" class="headerlink" title="1.7 连接泄漏"></a>1.7 连接泄漏</h3><p><strong>连接泄漏</strong>是指应用程序从连接池中借用了连接，但在使用完毕后<strong>没有将其归还</strong>。这会导致池中的可用连接越来越少，最终耗尽所有连接，使得新的请求无法获取连接，导致整个应用无响应或超时。</p>
<p><strong>主要原因</strong>：通常是由于代码中存在逻辑缺陷，如在 <code>try</code> 块中获取连接，但在 <code>finally</code> 块中没有确保执行 <code>connection.close()</code>。</p>
<p>**如何避免：**始终使用 <code>try-with-resources</code> (Java 7+) 语句或 <code>try-finally</code> 结构来保证连接一定会被关闭（归还）。</p>
<p><strong>正确示范 (try-with-resources):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connection, PreparedStatement, ResultSet 都实现了 AutoCloseable 接口</span></span><br><span class="line"><span class="comment">// JVM 会自动在末尾调用它们的 close() 方法</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">     <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line">    <span class="comment">// ... 执行SQL ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="comment">// ... 异常处理 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正确示范 (try-finally):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    conn = dataSource.getConnection();</span><br><span class="line">    <span class="comment">// ... 执行SQL ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="comment">// ... 异常处理 ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn.close(); <span class="comment">// 确保归还连接</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// log error</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-DAO-Data-Access-Object-设计模式"><a href="#2-DAO-Data-Access-Object-设计模式" class="headerlink" title="2. DAO (Data Access Object) 设计模式"></a>2. DAO (Data Access Object) 设计模式</h2><h3 id="2-1-DAO简介与优势"><a href="#2-1-DAO简介与优势" class="headerlink" title="2.1 DAO简介与优势"></a>2.1 DAO简介与优势</h3><h3 id="2-1-1-简介"><a href="#2-1-1-简介" class="headerlink" title="2.1.1 简介"></a>2.1.1 简介</h3><p>DAO (Data Access Object) 是一种广泛应用于企业级应用中的设计模式。它的核心思想是<strong>将数据访问逻辑（如何与数据库交互）从业务逻辑（做什么业务操作）中分离出来</strong>。</p>
<p>DAO 模式通过定义一个接口和其实现类，为每一种数据实体（如 User, Product, Order）提供一个专门的、统一的数据访问入口，在后续的Web开发中DAO是三层架构的重要组成部分，务必要熟悉DAO设计模式。</p>
<hr>
<h3 id="2-1-2-优势"><a href="#2-1-2-优势" class="headerlink" title="2.1.2 优势"></a>2.1.2 优势</h3><ol>
<li><strong>分层与解耦 (Separation of Concerns)</strong>:<ul>
<li><strong>业务逻辑</strong>（Service 层）变得非常纯粹，它只关心业务流程，而不需要知道数据是存在 MySQL、Oracle 还是文件中。</li>
<li><strong>数据访问</strong>（DAO 层）专注于与特定数据源的交互，所有与 JDBC API、SQL 语句相关的“脏活累活”都封装在这里。</li>
<li>当底层数据库需要更换时，理论上只需要替换 DAO 的实现类，而业务逻辑层代码<strong>完全不需要改动</strong>。</li>
</ul>
</li>
<li><strong>代码复用与可维护性 (Reusability &amp; Maintainability)</strong>:<ul>
<li>对某个实体（如 User）的所有数据库操作（增删改查）都集中在 <code>UserDAO</code> 中，避免了在不同业务代码中散落着重复的 JDBC 代码。</li>
<li>修改 SQL 语句或数据库交互逻辑时，只需要修改 DAO 中的一个地方，所有调用该方法的地方都会受益。</li>
</ul>
</li>
<li><strong>易于测试 (Testability)</strong>:<ul>
<li>由于业务逻辑与数据访问解耦，我们可以很容易地为 Service 层编写单元测试，通过模拟（Mock）一个 DAO 对象来提供测试数据，而无需启动一个真实的数据库。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-2-DAO-模式的组成部分"><a href="#2-2-DAO-模式的组成部分" class="headerlink" title="2.2 DAO 模式的组成部分"></a>2.2 DAO 模式的组成部分</h3><p>一个典型的 DAO 实现通常包含以下几个部分：</p>
<ol>
<li><strong>实体类 (Entity &#x2F; POJO &#x2F; JavaBean)</strong>:<ul>
<li>用于封装数据的普通 Java 对象，其属性与数据库表的字段一一对应。例如 <code>User</code> 类对应 <code>users</code> 表。</li>
</ul>
</li>
<li><strong>DAO 接口 (DAO Interface)</strong>:<ul>
<li>定义了针对该实体类的所有数据访问操作的<strong>契约</strong>。它只包含方法签名，不包含具体实现。</li>
<li>例如 <code>UserDAO</code> 接口会定义 <code>addUser(User user)</code>, <code>findUserById(int id)</code>, <code>findAllUsers()</code> 等方法。</li>
</ul>
</li>
<li><strong>DAO 实现类 (DAO Implementation)</strong>:<ul>
<li>实现了 DAO 接口的具体类。所有与 JDBC API 交互的底层代码都写在这里。</li>
<li>例如 <code>UserDAOImpl</code> 类会具体实现 <code>addUser</code> 方法，包括获取连接、创建 <code>PreparedStatement</code>、设置参数、执行 SQL 等。</li>
</ul>
</li>
<li><strong>(可选) 通用 JDBC 工具类 (Utility Class)</strong>:<ul>
<li>为了避免在每个 DAO 实现类中重复编写获取连接、关闭资源等模板代码，通常会抽取一个 <code>JdbcUtils</code> 或 <code>DBUtil</code> 类来封装这些通用逻辑。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-3-实战"><a href="#2-3-实战" class="headerlink" title="2.3 实战"></a>2.3 实战</h3><p>我们来一步步构建一个完整的 <code>UserDAO</code> 示例。</p>
<p><strong>第 1 步：创建实体类 <code>User.java</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">// 省略构造函数、getters、setters 和 toString()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 2 步：创建通用 JDBC 工具类 <code>JdbcUtils.java</code></strong></p>
<p>这个工具类使用 Druid 连接池来管理连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> JdbcUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">            props.load(is);</span><br><span class="line">            dataSource = DruidDataSourceFactory.createDataSource(props);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to initialize DataSource&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 3 步：定义 <code>UserDAO</code> 接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDAO</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">updateUser</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">deleteUser</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    User <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">findAllUsers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 4 步：创建 <code>UserDAOImpl</code> 实现类</strong></p>
<p>这是 DAO 模式的核心，包含了所有具体的数据库操作逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDAOImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDAO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO users (name, email) VALUES (?, ?)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line">             <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line">            pstmt.setString(<span class="number">1</span>, user.getName());</span><br><span class="line">            pstmt.setString(<span class="number">2</span>, user.getEmail());</span><br><span class="line">            pstmt.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, email FROM users WHERE id = ?&quot;</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line">             <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line">            pstmt.setInt(<span class="number">1</span>, id);</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                    user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">                    user.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                    user.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                    user.setEmail(rs.getString(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, email FROM users&quot;</span>;</span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line">             <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">             <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery()) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">                user.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                user.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                user.setEmail(rs.getString(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">                userList.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... updateUser 和 deleteUser 的实现 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第 5 步：在业务层 (Service) 中使用 DAO</strong></p>
<p>业务层通过接口与 DAO 交互，完全不知道底层实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 通过依赖注入或工厂模式获取 DAO 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDAO</span> <span class="variable">userDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDAOImpl</span>(); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerNewUser</span><span class="params">(String name, String email)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span> || name.isEmpty() || email == <span class="literal">null</span> || email.isEmpty()) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Invalid user data.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">User</span> <span class="variable">newUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        newUser.setName(name);</span><br><span class="line">        newUser.setEmail(email);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用 DAO 方法完成数据持久化</span></span><br><span class="line">        userDAO.addUser(newUser);</span><br><span class="line">        System.out.println(<span class="string">&quot;User &quot;</span> + name + <span class="string">&quot; registered successfully.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-4-使用反射简化"><a href="#2-4-使用反射简化" class="headerlink" title="2.4 使用反射简化"></a>2.4 使用反射简化</h3><p>在 <code>findUserById</code> 和 <code>findAllUsers</code> 方法中，我们看到了一段重复的、繁琐的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">user.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">user.setEmail(rs.getString(<span class="string">&quot;email&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>如果 <code>User</code> 类有 20 个属性，这段代码会变得非常长且容易出错。我们可以利用 <strong>Java 反射 (Reflection)</strong> 和 <strong><code>ResultSetMetaData</code></strong> 来编写一个通用的映射工具，自动完成这个过程。</p>
<p>许多 JDBC 框架（如 Apache DbUtils, Spring JDBC Template, MyBatis）的核心原理就是基于此。虽然我们不一定要自己实现一个完美的框架，但理解其原理非常重要。</p>
<p><strong>简化的实现思路</strong>:</p>
<ol>
<li>创建一个通用的查询方法，接收 SQL、参数和一个 <code>Class</code> 对象（如 <code>User.class</code>）。</li>
<li>执行查询后，获取 <code>ResultSet</code> 和 <code>ResultSetMetaData</code>。</li>
<li>遍历 <code>ResultSet</code> 的每一行。</li>
<li>在每一行中，通过 <code>rsmd.getColumnLabel(i)</code> 获取列名。</li>
<li>通过 Java 反射，找到 <code>User.class</code> 中与列名对应的 <code>setter</code> 方法（例如，列名是 <code>user_name</code>，就去找 <code>setUserName</code> 方法）。</li>
<li>调用 <code>setter</code> 方法，将 <code>rs.getObject(i)</code> 的值设置到新创建的 <code>User</code> 对象实例中。</li>
</ol>
<hr>
<hr>
<h1 id="五、高级主题与性能优化"><a href="#五、高级主题与性能优化" class="headerlink" title="五、高级主题与性能优化"></a>五、高级主题与性能优化</h1><h2 id="1-高级查询"><a href="#1-高级查询" class="headerlink" title="1. 高级查询"></a>1. 高级查询</h2><h3 id="1-1-分页查询实现-Pagination"><a href="#1-1-分页查询实现-Pagination" class="headerlink" title="1.1 分页查询实现 (Pagination)"></a>1.1 分页查询实现 (Pagination)</h3><h4 id="1-1-1-为什么需要分页？"><a href="#1-1-1-为什么需要分页？" class="headerlink" title="1.1.1 为什么需要分页？"></a>1.1.1 为什么需要分页？</h4><p>一个拥有数百万条记录的商品表。如果执行 <code>SELECT * FROM products</code>，会发生</p>
<ul>
<li><strong>内存溢出 (OOM)</strong>: 应用程序试图将数百万条记录加载到内存中，很可能导致内存耗尽而崩溃。</li>
<li><strong>网络拥堵</strong>: 大量数据通过网络从数据库传输到应用程序，耗时极长。</li>
<li><strong>数据库压力</strong>: 数据库需要读取并处理海量数据，消耗大量 I&#x2F;O 和 CPU 资源。</li>
<li><strong>用户体验差</strong>: 用户无法也无需一次性看到所有数据。</li>
</ul>
<p><strong>分页 (Pagination)</strong> 就是解决这个问题的标准方案。其核心思想是：<strong>每次只从数据库中查询出用户当前需要看的一小部分数据（一“页”）</strong>。</p>
<hr>
<h4 id="1-1-2-分页的两个核心参数："><a href="#1-1-2-分页的两个核心参数：" class="headerlink" title="1.1.2 分页的两个核心参数："></a>1.1.2 分页的两个核心参数：</h4><ul>
<li><code>pageNumber</code> (或 <code>currentPage</code>)：当前页码，例如第 1 页，第 2 页。</li>
<li><code>pageSize</code>：每页显示的记录数，例如每页 10 条，每页 20 条。</li>
</ul>
<hr>
<h4 id="1-1-3-如何用-SQL-实现分页？"><a href="#1-1-3-如何用-SQL-实现分页？" class="headerlink" title="1.1.3 如何用 SQL 实现分页？"></a>1.1.3 如何用 SQL 实现分页？</h4><p>JDBC 本身<strong>没有</strong>提供标准的分页 API。分页是<strong>通过特定数据库的 SQL 方言</strong>来实现的。你需要为你的目标数据库编写相应的分页 SQL。</p>
<ul>
<li><p><strong>MySQL &amp; PostgreSQL (使用 <code>LIMIT ... OFFSET ...</code>)</strong></p>
<ul>
<li><strong>语法</strong>: <code>SELECT ... FROM ... ORDER BY ... LIMIT [每页数量] OFFSET [跳过的记录数]</code></li>
<li><code>LIMIT</code>: 指定最多返回多少条记录。</li>
<li><code>OFFSET</code>: 指定从结果集的第几条记录开始返回（从 0 开始计数）。</li>
<li><strong>计算 <code>OFFSET</code></strong>: <code>offset = (pageNumber - 1) * pageSize</code></li>
<li><strong>示例 SQL (查询第 3 页，每页 10 条)</strong>:<br><code>SELECT * FROM products ORDER BY id LIMIT 10 OFFSET 20;</code> (跳过前 20 条，取 10 条)</li>
</ul>
</li>
<li><p><strong>Oracle (12c 及以后版本，推荐)</strong></p>
<ul>
<li><strong>语法</strong>: <code>SELECT ... FROM ... ORDER BY ... OFFSET [跳过的行数] ROWS FETCH NEXT [获取的行数] ROWS ONLY</code></li>
<li><strong>示例 SQL (查询第 3 页，每页 10 条)</strong>:<br><code>SELECT * FROM products ORDER BY id OFFSET 20 ROWS FETCH NEXT 10 ROWS ONLY;</code></li>
</ul>
</li>
<li><p><strong>Oracle (11g 及以前版本，传统方式)</strong></p>
<ul>
<li><p><strong>语法</strong>: 使用 <code>ROWNUM</code> 和嵌套子查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> t.<span class="operator">*</span>, ROWNUM <span class="keyword">AS</span> row_num <span class="keyword">FROM</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line">    ) t <span class="keyword">WHERE</span> ROWNUM <span class="operator">&lt;=</span> (pageNumber <span class="operator">*</span> pageSize)</span><br><span class="line">) <span class="keyword">WHERE</span> row_num <span class="operator">&gt;</span> ((pageNumber <span class="operator">-</span> <span class="number">1</span>) <span class="operator">*</span> pageSize);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-4-JDBC-代码实战-以-MySQL-为例"><a href="#1-1-4-JDBC-代码实战-以-MySQL-为例" class="headerlink" title="1.1.4 JDBC 代码实战 (以 MySQL 为例)"></a>1.1.4 JDBC 代码实战 (以 MySQL 为例)</h4><p>通常，一个完整的分页查询不仅要返回当前页的数据列表，还要返回<strong>总记录数</strong>，以便前端计算总页数并显示分页控件。</p>
<p><strong>步骤 A: 定义一个分页结果的包装类 <code>Page&lt;T&gt;</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Page</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; data; <span class="comment">// 当前页的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> totalRecords; <span class="comment">// 总记录数</span></span><br><span class="line">    <span class="comment">// ... constructors, getters, setters ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 B: 实现分页查询方法</strong></p>
<p>这个方法需要执行两次数据库查询：一次获取总数，一次获取当前页数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Page&lt;Product&gt; <span class="title function_">findProductsByPage</span><span class="params">(<span class="type">int</span> pageNumber, <span class="type">int</span> pageSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 查询总记录数</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">countSql</span> <span class="operator">=</span> <span class="string">&quot;SELECT COUNT(*) FROM products&quot;</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">countPstmt</span> <span class="operator">=</span> conn.prepareStatement(countSql);</span><br><span class="line">         <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> countPstmt.executeQuery()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">            total = rs.getLong(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 查询当前页的数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">dataSql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, price FROM products ORDER BY id LIMIT ? OFFSET ?&quot;</span>;</span><br><span class="line">    List&lt;Product&gt; productList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">dataPstmt</span> <span class="operator">=</span> conn.prepareStatement(dataSql)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> (pageNumber - <span class="number">1</span>) * pageSize;</span><br><span class="line">        dataPstmt.setInt(<span class="number">1</span>, pageSize);</span><br><span class="line">        dataPstmt.setInt(<span class="number">2</span>, offset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> dataPstmt.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">                product.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                product.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                product.setPrice(rs.getDouble(<span class="string">&quot;price&quot;</span>));</span><br><span class="line">                productList.add(product);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 封装并返回 Page 对象</span></span><br><span class="line">    Page&lt;Product&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;();</span><br><span class="line">    page.setData(productList);</span><br><span class="line">    page.setTotalRecords(total);</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-2-动态-SQL-构建技巧"><a href="#1-2-动态-SQL-构建技巧" class="headerlink" title="1.2 动态 SQL 构建技巧"></a>1.2 动态 SQL 构建技巧</h3><h4 id="1-2-1-什么是动态-SQL？"><a href="#1-2-1-什么是动态-SQL？" class="headerlink" title="1.2.1 什么是动态 SQL？"></a>1.2.1 什么是动态 SQL？</h4><p>在很多应用场景中，SQL 的查询条件是<strong>不固定的</strong>，需要根据用户的输入动态生成。例如，一个商品搜索功能可能包含：</p>
<ul>
<li>商品名称（模糊匹配）</li>
<li>价格区间（大于某个值，小于某个值）</li>
<li>商品分类</li>
<li>库存状态</li>
</ul>
<p>用户可能只填写其中一两个条件，也可能全部填写。为每一种组合都写一个固定的 SQL 是不现实的。<strong>动态 SQL</strong> 就是在 Java 代码中根据条件动态拼接 SQL 字符串的技术。</p>
<hr>
<h4 id="1-2-2-危险的实现方式：字符串拼接"><a href="#1-2-2-危险的实现方式：字符串拼接" class="headerlink" title="1.2.2 危险的实现方式：字符串拼接"></a>1.2.2 危险的实现方式：字符串拼接</h4><p>初学者最容易想到的方法是直接用 <code>+</code> 拼接字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 极度危险，绝对禁止！</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM products WHERE 1=1&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line">    sql += <span class="string">&quot; AND name LIKE &#x27;%&quot;</span> + name + <span class="string">&quot;%&#x27;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (minPrice != <span class="literal">null</span>) &#123;</span><br><span class="line">    sql += <span class="string">&quot; AND price &gt;= &quot;</span> + minPrice;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br></pre></td></tr></table></figure>

<p>这种方式存在<strong>致命的 SQL 注入漏洞</strong>。如果用户输入 <code>name</code> 为 <code>&#39;; DROP TABLE products; --</code>，你的数据表就没了。</p>
<hr>
<h4 id="1-2-3-安全的实现方式：PreparedStatement-条件拼接"><a href="#1-2-3-安全的实现方式：PreparedStatement-条件拼接" class="headerlink" title="1.2.3 安全的实现方式：PreparedStatement + 条件拼接"></a>1.2.3 安全的实现方式：<code>PreparedStatement</code> + 条件拼接</h4><p>正确的做法是，<strong>只动态拼接 SQL 的结构部分，而所有的值都必须通过 <code>?</code> 占位符和 <code>PreparedStatement</code> 来绑定</strong>。</p>
<p><strong>核心思路</strong>：</p>
<ol>
<li>使用 <code>StringBuilder</code> 来构建 SQL 字符串。</li>
<li>使用 <code>ArrayList</code> 来按顺序存储需要绑定的参数值。</li>
<li>以 <code>WHERE 1=1</code> 作为查询条件的开头，这样后续所有条件都可以统一用 <code>AND</code> 来追加，无需判断是否是第一个条件。</li>
</ol>
<p><strong>JDBC 代码实战：动态商品搜索</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">searchProducts</span><span class="params">(String name, Double minPrice, Double maxPrice)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;SELECT id, name, price FROM products WHERE 1=1&quot;</span>);</span><br><span class="line">    List&lt;Object&gt; params = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态构建 SQL 和参数列表</span></span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">null</span> &amp;&amp; !name.trim().isEmpty()) &#123;</span><br><span class="line">        sql.append(<span class="string">&quot; AND name LIKE ?&quot;</span>);</span><br><span class="line">        params.add(<span class="string">&quot;%&quot;</span> + name + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (minPrice != <span class="literal">null</span>) &#123;</span><br><span class="line">        sql.append(<span class="string">&quot; AND price &gt;= ?&quot;</span>);</span><br><span class="line">        params.add(minPrice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxPrice != <span class="literal">null</span>) &#123;</span><br><span class="line">        sql.append(<span class="string">&quot; AND price &lt;= ?&quot;</span>);</span><br><span class="line">        params.add(maxPrice);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sql.append(<span class="string">&quot; ORDER BY id&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Product&gt; productList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line">         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql.toString())) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态设置参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; params.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// setObject 可以处理大多数类型</span></span><br><span class="line">            pstmt.setObject(i + <span class="number">1</span>, params.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">                product.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                product.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                product.setPrice(rs.getDouble(<span class="string">&quot;price&quot;</span>));</span><br><span class="line">                productList.add(product);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> productList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>:</p>
<ul>
<li><strong>分页查询</strong>是处理大数据集显示的基础，其实现依赖于特定数据库的 SQL 语法，通常需要两次查询（一次查总数，一次查数据）。</li>
<li><strong>动态 SQL</strong> 是构建灵活查询功能的关键，<strong>必须</strong>结合 <code>PreparedStatement</code> 和参数列表来构建，以从根本上杜дотвратить SQL 注入。</li>
<li>在实际项目中，这些复杂的 JDBC 操作通常会被 <strong>MyBatis</strong>、<strong>JPA (Hibernate)</strong> 等持久层框架所封装，它们提供了更强大、更便捷的分页和动态 SQL 功能。但理解底层的 JDBC 实现原理，对于排查问题和深入理解框架至关重要。</li>
</ul>
<hr>
<h2 id="2-性能优化建议"><a href="#2-性能优化建议" class="headerlink" title="2. 性能优化建议"></a>2. 性能优化建议</h2><h3 id="2-1-使用数据库连接池"><a href="#2-1-使用数据库连接池" class="headerlink" title="2.1 使用数据库连接池"></a>2.1 使用数据库连接池</h3><ul>
<li><strong>为什么</strong>: 这是<strong>最重要、最有效</strong>的性能优化手段，没有之一。直接使用 <code>DriverManager.getConnection()</code> 在高并发场景下是灾难性的。连接的创建和销毁涉及网络通信、数据库认证、会话创建等重量级操作，开销巨大。</li>
<li><strong>怎么做</strong>:<ul>
<li>在应用程序中集成一个高性能的连接池，如 <strong>HikariCP</strong> (Spring Boot 默认，首选) 或 <strong>Druid</strong> (监控功能强大)。</li>
<li>合理配置连接池参数：<ul>
<li><code>maximumPoolSize</code> (最大连接数): 不是越大越好。需要根据应用的 QPS、数据库服务器的 CPU 核心数和 I&#x2F;O 能力进行压力测试来确定。一个常见的经验法则是 <code>(核心数 * 2) + 1</code>。设置过大会导致数据库因上下文切换而性能下降。</li>
<li><code>minimumIdle</code> (最小空闲连接数): 保持一定数量的“热”连接，以应对突发流量，避免在高峰期临时创建连接。</li>
<li><code>connectionTimeout</code> (连接超时): 设置一个合理的等待时间，避免线程因无法获取连接而无限期阻塞。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-优先并复用-PreparedStatement"><a href="#2-2-优先并复用-PreparedStatement" class="headerlink" title="2.2 优先并复用 PreparedStatement"></a>2.2 优先并复用 <code>PreparedStatement</code></h3><ul>
<li><strong>为什么</strong>:<ul>
<li><strong>预编译</strong>: <code>PreparedStatement</code> 将 SQL 语句发送给数据库进行一次预编译，并缓存执行计划。后续执行时，只需传输参数，数据库无需再次解析和编译 SQL，大大减少了数据库的 CPU 开销。</li>
<li><strong>安全性</strong>: 从根本上防止 SQL 注入。</li>
</ul>
</li>
<li><strong>怎么做</strong>:<ul>
<li><strong>杜绝 <code>Statement</code></strong>: 除非是执行完全静态、无参数的 DDL 语句，否则永远不要使用 <code>Statement</code> 来拼接 SQL。</li>
<li><strong>缓存 <code>PreparedStatement</code></strong>: 在某些极端高性能场景下（通常由连接池实现），可以开启 <code>PreparedStatement</code> 缓存 (<code>poolPreparedStatements=true</code> in Druid&#x2F;HikariCP)，连接池会为每个连接缓存一些常用的 <code>PreparedStatement</code> 对象，避免了 <code>connection.prepareStatement()</code> 的开销。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-使用批量操作处理大量数据"><a href="#2-3-使用批量操作处理大量数据" class="headerlink" title="2.3 使用批量操作处理大量数据"></a>2.3 使用批量操作处理大量数据</h3><ul>
<li><strong>为什么</strong>: 逐条 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> 会产生大量的网络往返，性能极差。批量操作 (<code>addBatch()</code>, <code>executeBatch()</code>) 可以将多条 SQL 打包成一次请求发送给数据库，显著减少网络延迟。</li>
<li><strong>怎么做</strong>:<ul>
<li>当需要插入或更新大量数据时，使用 <code>for</code> 循环构建批处理。</li>
<li><strong>分批提交</strong>: 对于海量数据，不要一次性将所有数据都 <code>addBatch()</code>，这可能导致内存溢出。设置一个合理的批次大小（如 1000），分批执行 <code>executeBatch()</code>。</li>
<li><strong>开启特定驱动优化</strong>: 对于 MySQL，务必在 JDBC URL 中添加 <code>rewriteBatchedStatements=true</code>，性能提升可达数倍。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-4-高效处理-ResultSet"><a href="#2-4-高效处理-ResultSet" class="headerlink" title="2.4 高效处理 ResultSet"></a>2.4 高效处理 <code>ResultSet</code></h3><ul>
<li><strong>为什么</strong>: <code>ResultSet</code> 可能会在内存或数据库端占用大量资源。低效的处理方式会拖慢整个应用。</li>
<li><strong>怎么做</strong>:<ul>
<li><strong>明确指定查询列</strong>: <strong>永远不要使用 <code>SELECT \*</code></strong>。只查询你业务逻辑中确实需要的列。这可以减少网络传输的数据量、降低数据库的 I&#x2F;O 开销，并且如果查询能命中覆盖索引，性能会大幅提升。</li>
<li><strong>尽快处理和关闭</strong>: 遵循“尽早获取，尽快释放”的原则。在循环遍历 <code>ResultSet</code> 时，应尽快将数据转换为业务对象 (DTO&#x2F;VO)，然后立即关闭 <code>ResultSet</code> (通过 <code>try-with-resources</code> 自动完成)。不要持有 <code>ResultSet</code> 对象太长时间。</li>
<li><strong>使用 <code>ResultSet</code> 的 <code>getXXX()</code> 方法时，优先使用列索引</strong>: <code>rs.getString(1)</code> 通常比 <code>rs.getString(&quot;column_name&quot;)</code> 性能稍好，因为它避免了通过列名查找索引的开销。但这会牺牲代码的可读性和可维护性，因此只在性能压榨到极致的场景下考虑。在绝大多数情况下，<strong>可读性更重要</strong>。</li>
<li><strong>流式处理大结果集 (Fetch Size)</strong>: 默认情况下，JDBC 驱动可能会一次性将所有查询结果都从数据库拉取到内存中。如果结果集非常大，这会导致 OOM。可以通过 <code>statement.setFetchSize(int rows)</code> 来提示驱动一次从数据库拉取多少行数据到内存中。<ul>
<li>对于 MySQL，需要 <code>setFetchSize(Integer.MIN_VALUE)</code> 来开启流式读取。</li>
<li>这是一种高级优化，只在处理百万级别以上的大结果集时才需要考虑。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-5-事务管理优化"><a href="#2-5-事务管理优化" class="headerlink" title="2.5 事务管理优化"></a>2.5 事务管理优化</h3><ul>
<li><strong>为什么</strong>: 事务会持有数据库锁，过长的事务会阻塞其他操作，降低系统的并发能力。</li>
<li><strong>怎么做</strong>:<ul>
<li><strong>事务尽可能短</strong>: 遵循“小事务”原则。只将必要的数据库操作放在事务边界内。避免在事务中包含耗时的非数据库操作（如文件 I&#x2F;O、网络调用）。</li>
<li><strong>合理设置事务隔离级别</strong>: 不要盲目使用最高的 <code>SERIALIZABLE</code> 级别。根据业务需求选择足够用的最低隔离级别（通常是 <code>READ_COMMITTED</code> 或 <code>REPEATABLE_READ</code>），以在数据一致性和并发性能之间取得平衡。</li>
<li><strong>只在需要时开启事务</strong>: 对于只读的查询操作，如果业务允许（不需要在一次业务中保证多次查询的一致性），可以不开启事务（即使用自动提交模式），这样可以减少事务开销和锁竞争。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-6-正确关闭资源"><a href="#2-6-正确关闭资源" class="headerlink" title="2.6 正确关闭资源"></a>2.6 正确关闭资源</h3><ul>
<li><strong>为什么</strong>: 资源泄露（特别是连接泄露）是 JDBC 应用中最常见也最致命的问题。它会逐渐耗尽连接池中的所有连接，最终导致整个应用无法访问数据库。</li>
<li><strong>怎么做</strong>:<ul>
<li><strong>始终使用 <code>try-with-resources</code></strong>: 这是 Java 7+ 的最佳实践，能从语法层面保证 <code>Connection</code>, <code>Statement</code>, <code>ResultSet</code> 被自动、安全、正确地关闭。彻底告别手写 <code>finally</code> 块。</li>
</ul>
</li>
</ul>
<hr>
<hr>
<h1 id="六、故障排查与最佳实践"><a href="#六、故障排查与最佳实践" class="headerlink" title="六、故障排查与最佳实践"></a>六、故障排查与最佳实践</h1><h2 id="1-常见问题与解决方案"><a href="#1-常见问题与解决方案" class="headerlink" title="1. 常见问题与解决方案"></a>1. 常见问题与解决方案</h2><h3 id="1-1-连接异常-ClassNotFoundException-SQLException"><a href="#1-1-连接异常-ClassNotFoundException-SQLException" class="headerlink" title="1.1 连接异常: ClassNotFoundException &#x2F; SQLException"></a>1.1 连接异常: <code>ClassNotFoundException</code> &#x2F; <code>SQLException</code></h3><h4 id="1-1-1-java-lang-ClassNotFoundException-com-mysql-cj-jdbc-Driver"><a href="#1-1-1-java-lang-ClassNotFoundException-com-mysql-cj-jdbc-Driver" class="headerlink" title="1.1.1 java.lang.ClassNotFoundException: com.mysql.cj.jdbc.Driver"></a>1.1.1 <code>java.lang.ClassNotFoundException: com.mysql.cj.jdbc.Driver</code></h4><p><strong>问题描述</strong>: JVM 在运行时无法在 Classpath (类路径) 中找到指定的 JDBC 驱动类。</p>
<p><strong>根本原因</strong>: <strong>JDBC 驱动的 JAR 包没有被正确地添加到项目中。</strong></p>
<p><strong>解决方案</strong>:</p>
<ol>
<li><strong>检查依赖管理工具 (Maven&#x2F;Gradle)</strong>:<ul>
<li>打开 <code>pom.xml</code> (Maven) 或 <code>build.gradle</code> (Gradle) 文件。</li>
<li>确认你已经添加了正确的数据库驱动依赖，例如 <code>&lt;dependency&gt;&lt;groupId&gt;com.mysql&lt;/groupId&gt;...&lt;/dependency&gt;</code>。</li>
<li>检查 <code>groupId</code>, <code>artifactId</code>, <code>version</code> 是否拼写正确。</li>
<li>刷新或重新导入你的项目依赖，确保 IDE 已经将 JAR 包下载到本地仓库并添加到项目中。</li>
</ul>
</li>
<li><strong>检查手动导入的 JAR 包</strong>:<ul>
<li>如果你是手动管理 JAR 包，请确保驱动 JAR 文件（如 <code>mysql-connector-j-8.x.x.jar</code>）已经被复制到项目的 <code>lib</code> 目录下。</li>
<li>在 IDE (Eclipse&#x2F;IntelliJ IDEA) 中，检查项目的构建路径 (Build Path) 或模块依赖 (Module Dependencies)，确认这个 JAR 文件已经被明确地添加为库。</li>
</ul>
</li>
<li><strong>检查部署环境 (Tomcat 等)</strong>:<ul>
<li>如果是在 Web 服务器（如 Tomcat）上运行，请确保驱动 JAR 包被放置在 <code>WEB-INF/lib</code> 目录下，这样它才能被 Web 应用程序的类加载器找到。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-1-2-java-sql-SQLException-No-suitable-driver-found-for-jdbc-mysql"><a href="#1-1-2-java-sql-SQLException-No-suitable-driver-found-for-jdbc-mysql" class="headerlink" title="1.1.2 java.sql.SQLException: No suitable driver found for jdbc:mysql://..."></a>1.1.2 <code>java.sql.SQLException: No suitable driver found for jdbc:mysql://...</code></h4><p><strong>问题描述</strong>: <code>DriverManager</code> 已经成功加载，但在其已注册的驱动列表中，没有一个驱动能够识别并处理你提供的数据库连接 URL。</p>
<p><strong>常见原因与解决方案</strong>:</p>
<ol>
<li><strong>驱动未加载 (根因同上)</strong>: 这是最常见的原因。虽然没有报 <code>ClassNotFoundException</code>，但驱动确实没被加载和注册。请先按照上面 <code>ClassNotFoundException</code> 的解决方案排查。</li>
<li><strong>URL 拼写错误</strong>: 仔细检查你的 JDBC URL 字符串。<ul>
<li>协议部分是否正确？<code>jdbc:mysql://</code>，<code>jdbc:oracle:thin:@</code>。一个字母的错误都会导致匹配失败。</li>
<li>主机名、端口、数据库名是否正确？</li>
</ul>
</li>
<li><strong>驱动与数据库版本不兼容</strong>:<ul>
<li>例如，使用非常老的 MySQL 驱动 (5.x) 去连接最新的 MySQL 数据库 (8.x)，或者反之，可能会导致驱动无法正确处理连接。请确保驱动版本与你的数据库版本大致匹配。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-1-3-java-sql-SQLException-Access-denied-for-user-root-localhost"><a href="#1-1-3-java-sql-SQLException-Access-denied-for-user-root-localhost" class="headerlink" title="1.1.3 java.sql.SQLException: Access denied for user &#39;root&#39;@&#39;localhost&#39;"></a>1.1.3 <code>java.sql.SQLException: Access denied for user &#39;root&#39;@&#39;localhost&#39;</code></h4><p><strong>问题描述</strong>: 数据库服务器拒绝了你的连接请求。</p>
<p><strong>原因与解决方案</strong>:</p>
<ol>
<li><strong>用户名或密码错误</strong>: 这是最直接的原因。请再三确认你在代码中使用的用户名和密码与数据库中设置的完全一致。注意区分大小写，以及密码中是否包含特殊字符。</li>
<li><strong>权限问题</strong>:<ul>
<li>你使用的数据库用户可能没有从你的应用程序所在的主机（例如 <code>localhost</code> 或某个 IP 地址）连接的权限。</li>
<li>登录到数据库，检查用户权限。在 MySQL 中，可以使用 <code>SELECT user, host FROM mysql.user;</code> 查看。如果 <code>host</code> 字段是 <code>localhost</code>，那么该用户只能从数据库服务器本机登录。你需要创建一个允许从 <code>%</code> (任何主机) 或你应用服务器的特定 IP 登录的用户，或者修改现有用户的 <code>host</code>。</li>
</ul>
</li>
<li><strong>防火墙</strong>: 检查数据库服务器或网络中的防火墙是否阻止了来自应用服务器对数据库端口（如 MySQL 的 3306）的访问。</li>
</ol>
<hr>
<h3 id="1-2-中文乱码问题"><a href="#1-2-中文乱码问题" class="headerlink" title="1.2 中文乱码问题"></a>1.2 中文乱码问题</h3><p><strong>问题描述</strong>: 向数据库中插入中文字符后，在数据库客户端查看时显示为 <code>???</code> 或乱码；或者从数据库读取出的中文字符在 Java 程序中显示为乱码。</p>
<p><strong>根本原因</strong>: 字符编码不一致。涉及的环节包括：<strong>Java 源代码文件编码</strong>、<strong>JVM 运行环境编码</strong>、<strong>JDBC 连接编码</strong>、<strong>数据库服务器编码</strong>、<strong>数据库表&#x2F;字段编码</strong>。任何一个环节出错都可能导致乱码。</p>
<p><strong>解决方案 (系统性排查)</strong>:</p>
<ol>
<li><p><strong>统一数据库编码</strong>: 确保你的数据库、表、字段都使用统一的字符集，<strong>强烈推荐 <code>utf8mb4</code></strong> (对于 MySQL) 或 <code>UTF-8</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MySQL</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE my_db <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> my_table (...) <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置 JDBC 连接 URL</strong>: 这是<strong>最关键</strong>的一步。在 JDBC URL 中明确指定连接使用的字符编码。</p>
<ul>
<li><strong>MySQL</strong>: <code>jdbc:mysql://localhost:3306/my_db?characterEncoding=utf8</code></li>
</ul>
</li>
<li><p><strong>检查 Java 源代码文件编码</strong>: 确保你的 <code>.java</code> 文件是以 UTF-8 编码保存的。在 IDE (Eclipse&#x2F;IntelliJ IDEA) 的设置中可以全局配置。</p>
</li>
<li><p><strong>检查应用服务器配置 (如 Tomcat)</strong>:</p>
<ul>
<li>在 Tomcat 的 <code>server.xml</code> 中，为 <code>&lt;Connector&gt;</code> 添加 <code>URIEncoding=&quot;UTF-8&quot;</code> 属性，以确保 GET 请求参数正确解码。</li>
<li>在 Java Web 应用中，使用过滤器 (Filter) 来统一设置所有请求和响应的编码为 <code>UTF-8</code>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-3-资源泄露-Resource-Leak-与内存溢出-OutOfMemoryError"><a href="#1-3-资源泄露-Resource-Leak-与内存溢出-OutOfMemoryError" class="headerlink" title="1.3 资源泄露 (Resource Leak) 与内存溢出 (OutOfMemoryError)"></a>1.3 资源泄露 (Resource Leak) 与内存溢出 (OutOfMemoryError)</h3><p><strong>问题描述</strong>: 应用程序运行一段时间后，性能逐渐下降，最终抛出 “Too many connections” 错误或 <code>OutOfMemoryError</code>，然后崩溃。</p>
<p><strong>根本原因</strong>: <strong><code>Connection</code>, <code>Statement</code>, <code>ResultSet</code> 等 JDBC 资源在使用完毕后没有被正确关闭</strong>。这会导致连接池中的连接被耗尽，或者 <code>ResultSet</code> 缓存的数据占满内存。</p>
<p><strong>解决方案</strong>:</p>
<ol>
<li><p><strong>强制使用 <code>try-with-resources</code></strong>: 这是<strong>根治</strong>此问题的最佳方法。将所有实现了 <code>AutoCloseable</code> 接口的资源（<code>Connection</code>, <code>Statement</code>, <code>ResultSet</code> 等）都放在 <code>try()</code> 的括号内声明。Java 编译器会保证它们在任何情况下都被自动、安全地关闭。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ...; <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> ...; <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> ...) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代码审查</strong>: 如果是维护旧代码，需要仔细审查所有 JDBC 操作，确保每个 <code>Connection</code>, <code>Statement</code>, <code>ResultSet</code> 都在 <code>finally</code> 块中有对应的 <code>close()</code> 调用，并且 <code>close()</code> 本身也被 <code>try-catch</code> 包围。</p>
</li>
<li><p><strong>使用连接池监控</strong>: 像 Druid 这样的连接池提供了强大的监控功能，可以帮你检测和定位未关闭的连接。开启 “removeAbandoned” (移除被遗弃的连接) 等配置项可以在生产环境中作为一道防线，但最好的方式还是从代码层面解决问题。</p>
</li>
<li><p><strong>处理大结果集</strong>: 如果查询返回的数据量非常大，即使正确关闭了资源，也可能在处理过程中导致内存溢出。此时应考虑：</p>
<ul>
<li><strong>分页查询</strong>: 只查询当前需要的数据。</li>
<li><strong>流式读取</strong>: 使用 <code>statement.setFetchSize()</code> 来控制一次从数据库拉取的数据量，避免一次性加载所有结果到内存。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-单元测试"><a href="#2-单元测试" class="headerlink" title="2. 单元测试"></a>2. 单元测试</h2><h3 id="2-1-为什么需要为-DAO-层编写单元测试"><a href="#2-1-为什么需要为-DAO-层编写单元测试" class="headerlink" title="2.1 为什么需要为 DAO 层编写单元测试"></a>2.1 为什么需要为 DAO 层编写单元测试</h3><p>直接在开发、测试甚至生产数据库上进行调试是一种低效且危险的做法。为 DAO (Data Access Object) 层编写单元测试能带来诸多好处：</p>
<ol>
<li><strong>快速验证</strong>: 可以在不启动整个应用程序的情况下，快速、独立地验证 SQL 语句和 JDBC 逻辑是否正确。</li>
<li><strong>隔离性</strong>: 测试在隔离的环境中运行，不依赖于外部数据库的状态，也不会污染开发数据库。每次测试都可以从一个干净、可预测的数据库状态开始。</li>
<li><strong>回归防护</strong>: 建立一套完整的测试用例后，每当修改了 DAO 层的代码或 SQL 语句，只需运行一遍测试，就能立即发现是否引入了新的 bug（即回归问题）。</li>
<li><strong>提升开发效率</strong>: “测试驱动开发”(TDD) 理念鼓励先写测试再写实现，这能帮助开发者更清晰地思考接口设计和边界情况。</li>
<li><strong>自动化</strong>: 单元测试可以轻松地集成到持续集成&#x2F;持续部署 (CI&#x2F;CD) 流程中，实现自动化构建和质量保证。</li>
</ol>
<hr>
<h3 id="2-2-如何隔离对数据库的依赖？"><a href="#2-2-如何隔离对数据库的依赖？" class="headerlink" title="2.2 如何隔离对数据库的依赖？"></a>2.2 如何隔离对数据库的依赖？</h3><p>DAO 层的测试有一个核心挑战：它天生就依赖于数据库。如果直接连接开发数据库，测试会变得：</p>
<ul>
<li><strong>慢</strong>: 涉及网络 I&#x2F;O，运行速度慢。</li>
<li><strong>不稳定</strong>: 依赖于网络和开发数据库的可用性。</li>
<li><strong>不干净</strong>: 测试会产生脏数据，影响其他开发者。</li>
</ul>
<p><strong>解决方案：使用内存数据库 (In-Memory Database)</strong></p>
<p>内存数据库是一种将数据存储在主内存（RAM）中的数据库。它具有以下特性，使其成为单元测试的理想选择：</p>
<ul>
<li><strong>极速</strong>: 所有操作都在内存中完成，没有磁盘 I&#x2F;O，速度飞快。</li>
<li><strong>易于集成</strong>: 通常以一个简单的 JAR 包形式提供，无需安装独立的数据库服务器。</li>
<li><strong>生命周期短暂</strong>: 数据库实例可以与 JVM 的生命周期绑定。测试开始时创建，测试结束时所有数据随之销毁，每次测试都是全新的开始。</li>
<li><strong>兼容性</strong>: 许多内存数据库（如 H2）提供了与标准 SQL 和主流数据库（如 MySQL, PostgreSQL）的兼容模式，使得 SQL 语句可以无缝运行。</li>
</ul>
<p><strong>H2 数据库</strong> 是 Java 社区中最流行、最常用的内存数据库之一，非常适合用于单元测试。</p>
<hr>
<h3 id="2-3-实战-1"><a href="#2-3-实战-1" class="headerlink" title="2.3 实战"></a>2.3 实战</h3><p>使用 JUnit 5（当前主流的 Java 测试框架）和 H2 数据库来为之前创建的 <code>UserDAOImpl</code> 编写测试。</p>
<p><strong>步骤 1: 添加测试依赖 (Maven <code>pom.xml</code>)</strong></p>
<p>这些依赖的作用域通常是 <code>test</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JUnit 5 (Jupiter) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.9.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.9.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- H2 Database --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.224<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 准备测试用的数据库环境</strong></p>
<p>我们需要一个机制，在<strong>每个测试方法运行前</strong>创建一个干净的 H2 数据库和表，并在<strong>测试方法运行后</strong>销毁它。JUnit 5 提供了 <code>@BeforeEach</code> 和 <code>@AfterEach</code> 注解可以完成这种操作。</p>
<p>在测试资源目录 (<code>src/test/resources</code>) 下创建一个 SQL 脚本来初始化数据库。</p>
<p><strong><code>src/test/resources/schema.sql</code> (建表语句)</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong><code>src/test/resources/data.sql</code> (初始数据)</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> users (name, email) <span class="keyword">VALUES</span> (<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;alice@test.com&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> users (name, email) <span class="keyword">VALUES</span> (<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;bob@test.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3: 编写 <code>UserDAOImplTest.java</code></strong></p>
<p>这个测试类通常放在 <code>src/test/java</code> 目录下，包结构与被测试的类对应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserDAOImplTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> UserDAO userDAO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在所有测试运行前执行一次，用于建立 H2 数据库连接</span></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setupDatabase</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// H2 内存数据库的连接 URL，MODE=MySQL 使其兼容 MySQL 语法</span></span><br><span class="line">        <span class="comment">// DB_CLOSE_DELAY=-1 防止连接关闭时数据库被清空</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:h2:mem:testdb;MODE=MySQL;DB_CLOSE_DELAY=-1&quot;</span>;</span><br><span class="line">        connection = DriverManager.getConnection(url, <span class="string">&quot;sa&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在每个测试方法运行前执行</span></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setupTestData</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        userDAO = <span class="keyword">new</span> <span class="title class_">UserDAOImpl</span>(connection); <span class="comment">// 假设 DAO 实现可以接收一个 Connection</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次测试前，清空并重建表结构和数据</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> connection.createStatement()) &#123;</span><br><span class="line">            stmt.execute(<span class="string">&quot;DROP TABLE IF EXISTS users&quot;</span>);</span><br><span class="line">            <span class="comment">// 这里可以写一个辅助方法来执行 SQL 脚本</span></span><br><span class="line">            stmt.execute(<span class="string">&quot;CREATE TABLE users (id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(50), email VARCHAR(100))&quot;</span>);</span><br><span class="line">            stmt.execute(<span class="string">&quot;INSERT INTO users (id, name, email) VALUES (1, &#x27;Alice&#x27;, &#x27;alice@test.com&#x27;)&quot;</span>);</span><br><span class="line">            stmt.execute(<span class="string">&quot;INSERT INTO users (id, name, email) VALUES (2, &#x27;Bob&#x27;, &#x27;bob@test.com&#x27;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testFindUserById_existingUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDAO.findUserById(<span class="number">1</span>);</span><br><span class="line">        assertNotNull(user, <span class="string">&quot;User should not be null&quot;</span>);</span><br><span class="line">        assertEquals(<span class="number">1</span>, user.getId());</span><br><span class="line">        assertEquals(<span class="string">&quot;Alice&quot;</span>, user.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testFindUserById_nonExistingUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDAO.findUserById(<span class="number">99</span>);</span><br><span class="line">        assertNull(user, <span class="string">&quot;User should be null for non-existing ID&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testFindAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; users = userDAO.findAllUsers();</span><br><span class="line">        assertNotNull(users);</span><br><span class="line">        assertEquals(<span class="number">2</span>, users.size(), <span class="string">&quot;Should find 2 users&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testAddUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">newUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        newUser.setName(<span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line">        newUser.setEmail(<span class="string">&quot;charlie@test.com&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        userDAO.addUser(newUser);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 验证是否真的插入成功</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">foundUser</span> <span class="operator">=</span> userDAO.findUserByEmail(<span class="string">&quot;charlie@test.com&quot;</span>); <span class="comment">// 假设有这个方法</span></span><br><span class="line">        assertNotNull(foundUser);</span><br><span class="line">        assertEquals(<span class="string">&quot;Charlie&quot;</span>, foundUser.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他测试，如 updateUser, deleteUser ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在所有测试运行后执行一次，关闭连接</span></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tearDownDatabase</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 为了让测试代码能够控制数据库连接，通常需要对原有的 <code>UserDAOImpl</code> 做一些调整，比如提供一个构造函数，允许外部注入一个 <code>Connection</code> 或 <code>DataSource</code>。这是实现可测试性的常见模式。</p>
<p><strong>测试要点总结</strong>:</p>
<ol>
<li><strong>使用 H2 内存数据库</strong>：在 <code>pom.xml</code> 中添加依赖，并使用 <code>jdbc:h2:mem:...</code> URL。</li>
<li><strong>JUnit 5 生命周期注解</strong>:<ul>
<li><code>@BeforeAll</code>: 在所有测试之前初始化数据库连接。</li>
<li><code>@BeforeEach</code>: 在每个测试方法之前，创建干净的表和测试数据。这是保证测试<strong>独立性</strong>的关键。</li>
<li><code>@AfterAll</code>: 在所有测试之后关闭连接。</li>
</ul>
</li>
<li><strong>断言 (Assertions)</strong>: 使用 <code>assertEquals</code>, <code>assertNotNull</code>, <code>assertTrue</code> 等 JUnit 的断言方法来验证 DAO 方法的返回值是否符合预期。</li>
<li><strong>覆盖各种场景</strong>: 不仅要测试成功的情况（如找到用户），也要测试失败或边界情况（如找不到用户、插入 null 数据等）。</li>
</ol>
<hr>
<h2 id="3-日志与调试"><a href="#3-日志与调试" class="headerlink" title="3. 日志与调试"></a>3. 日志与调试</h2><h3 id="3-1-为什么需要日志？"><a href="#3-1-为什么需要日志？" class="headerlink" title="3.1 为什么需要日志？"></a>3.1 为什么需要日志？</h3><p>在开发过程中，可以通过 <code>System.out.println()</code> 来打印信息或使用 Debugger 逐行调试。但一旦应用程序部署到服务器上，这些方法就失效了。这时，<strong>日志 (Logging)</strong> 就成了我们了解应用程序内部运行状态的唯一窗口。</p>
<p>对于 JDBC 编程而言，日志尤其重要，因为：</p>
<ol>
<li><strong>SQL 可见性</strong>: 能够清晰地看到应用程序<strong>实际执行</strong>的 SQL 语句是什么，以及绑定的参数是什么。这是排查 SQL 语法错误、逻辑错误（如 <code>WHERE</code> 条件不符预期）的最直接方式。</li>
<li><strong>性能监控</strong>: 记录每条 SQL 的执行耗时，可以帮助我们快速定位慢查询，找到性能瓶颈。</li>
<li><strong>异常追踪</strong>: 当 <code>SQLException</code> 发生时，日志可以记录下完整的异常堆栈信息、上下文参数以及当时的 SQL，为事后分析问题提供了宝贵的线索。</li>
<li><strong>审计与安全</strong>: 在某些场景下，记录关键的数据库操作（谁、在什么时间、执行了什么 SQL）是合规性审计的要求。</li>
</ol>
<p><strong>日志框架的选择</strong>:</p>
<p>在 Java 世界中，我们通常不直接使用 <code>java.util.logging</code>，而是选择更强大、更灵活的日志框架。</p>
<ul>
<li><strong>SLF4J (Simple Logging Facade for Java)</strong>: 这是一个<strong>日志门面 (Facade)</strong>，它本身不实现日志功能，而是提供一套标准的 API。</li>
<li><strong>Logback &#x2F; Log4j2</strong>: 这是 SLF4J 背后具体的<strong>日志实现 (Implementation)</strong>。<br><strong>最佳实践</strong>：在代码中<strong>始终面向 SLF4J API 编程</strong>，而在配置中选择 Logback 或 Log4j2 作为实现。这样你的代码就与具体的日志实现解耦了。</li>
</ul>
<hr>
<h3 id="3-2-在-JDBC-代码中添加日志"><a href="#3-2-在-JDBC-代码中添加日志" class="headerlink" title="3.2 在 JDBC 代码中添加日志"></a>3.2 在 JDBC 代码中添加日志</h3><p>让我们看看如何在一个 DAO 方法中有效地使用日志。</p>
<p><strong>步骤 1: 添加 SLF4J 和 Logback 依赖 (Maven <code>pom.xml</code>)</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 在 DAO 实现类中添加日志记录</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDAOImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDAO</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取 Logger 实例，通常为静态常量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(UserDAOImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, email FROM users WHERE id = ?&quot;</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 使用 DEBUG 级别记录将要执行的 SQL 和参数</span></span><br><span class="line">        logger.debug(<span class="string">&quot;Executing SQL: &#123;&#125; with parameters: &#123;&#125;&quot;</span>, sql, id);</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line">             <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line">            </span><br><span class="line">            pstmt.setInt(<span class="number">1</span>, id);</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                    user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">                    <span class="comment">// ... map result set to user object ...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// 3. 使用 ERROR 级别记录异常</span></span><br><span class="line">            logger.error(<span class="string">&quot;Failed to find user by ID: &#123;&#125;&quot;</span>, id, e);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 4. 使用 INFO 或 DEBUG 级别记录执行耗时</span></span><br><span class="line">        logger.info(<span class="string">&quot;SQL execution time: &#123;&#125; ms&quot;</span>, (endTime - startTime));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>日志级别的使用约定</strong>:</p>
<ul>
<li><code>ERROR</code>: 严重错误，影响程序正常运行。<strong>必须</strong>记录异常堆栈信息。</li>
<li><code>WARN</code>: 警告，潜在的问题或非预期的技术性事件，但程序仍可继续运行。</li>
<li><code>INFO</code>: 关键业务流程的进度信息，如“用户登录成功”、“订单创建完毕”，或重要的性能指标。</li>
<li><code>DEBUG</code>: 用于开发和调试的详细信息，如 SQL 语句、参数、方法入参&#x2F;出参等。</li>
<li><code>TRACE</code>: 比 DEBUG 更细粒度的信息，用于追踪代码执行的详细路径。</li>
</ul>
<hr>
<h3 id="3-3-使用专业的-JDBC-日志代理-拦截器-更强大的方式"><a href="#3-3-使用专业的-JDBC-日志代理-拦截器-更强大的方式" class="headerlink" title="3.3 使用专业的 JDBC 日志代理&#x2F;拦截器 (更强大的方式)"></a>3.3 使用专业的 JDBC 日志代理&#x2F;拦截器 (更强大的方式)</h3><p>手动在每个 DAO 方法中添加日志虽然可行，但很繁琐且容易遗漏。更专业、更强大的方式是使用能够<strong>自动拦截</strong> JDBC 调用并记录日志的工具。</p>
<p><strong>p6spy</strong>:</p>
<ul>
<li><strong>是什么</strong>: 一个开源的 JDBC 驱动代理。它把自己“包装”在你的真实 JDBC 驱动外面，拦截所有对数据库的调用（包括执行的 SQL、参数、耗时等），并将这些信息输出到日志中，而你<strong>无需修改任何一行 DAO 代码</strong>。</li>
<li><strong>优点</strong>: 非侵入式，配置简单，功能强大，可以格式化输出 SQL，非常适合在开发和测试环境中使用。</li>
</ul>
<p><strong>Druid 连接池的内置 Filter</strong>:</p>
<ul>
<li><p>如果你正在使用 Druid 连接池，它内置了强大的 <code>Filter</code> 链，可以轻松开启日志功能。</p>
</li>
<li><p><strong>配置 (<code>druid.properties</code>)</strong>:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># stat 用于监控，log4j 或 log4j2 用于记录日志</span></span><br><span class="line"><span class="attr">druid.filters</span>=<span class="string">stat,log4j2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 配置 log4j2 filter 的属性</span></span><br><span class="line"><span class="attr">druid.filter.log4j2.statementExecutableSqlLogEnable</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点</strong>: 与连接池紧密集成，配置方便，性能较好。</p>
</li>
</ul>
<p><strong>使用这些工具后，你可以在日志文件中看到类似这样的输出，非常清晰</strong>:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEBUG 2023-10-27 10:30:00 [com.yourapp.UserDAOImpl] - ==&gt; Preparing: SELECT id, name, email FROM users WHERE id = ?</span><br><span class="line">DEBUG 2023-10-27 10:30:00 [com.yourapp.UserDAOImpl] - ==&gt; Parameters: 1(Integer)</span><br><span class="line">INFO  2023-10-27 10:30:00 [com.yourapp.UserDAOImpl] - &lt;== Total: 1</span><br><span class="line">INFO  2023-10-27 10:30:00 [com.yourapp.UserDAOImpl] - Time Elapsed: 5ms</span><br></pre></td></tr></table></figure>

<p>(这是模仿 MyBatis 日志的风格，但 p6spy 和 Druid 的输出格式类似)</p>
<hr>
<h3 id="3-4-调试技巧"><a href="#3-4-调试技巧" class="headerlink" title="3.4 调试技巧"></a>3.4 调试技巧</h3><p>当遇到复杂的数据库问题时，除了日志，调试器 (Debugger) 也可以为你提供帮助。</p>
<ol>
<li><strong>断点位置</strong>:<ul>
<li>在 <code>PreparedStatement</code> 执行前（<code>executeQuery()</code> &#x2F; <code>executeUpdate()</code>）设置断点，检查 SQL 语句是否拼接正确（对于动态 SQL），以及绑定的参数值是否符合预期。</li>
<li>在 <code>ResultSet</code> 遍历循环内设置断点，检查从数据库取出的原始数据是否正确，是否存在 <code>null</code> 值或意外的格式。</li>
<li>在 <code>catch (SQLException e)</code> 块的第一行设置断点，当异常发生时，可以立即暂停程序，检查 <code>e</code> 对象中的 <code>errorCode</code>, <code>sqlState</code> 和 <code>message</code>，获取最直接的错误原因。</li>
</ul>
</li>
<li><strong>检查变量状态</strong>:<ul>
<li><strong><code>Connection</code> 对象</strong>: 检查其 <code>isClosed()</code>, <code>getAutoCommit()</code> 等状态，确认连接是否正常，事务模式是否正确。</li>
<li><strong><code>PreparedStatement</code> 对象</strong>: 在 Debugger 的监视窗口中，有时可以（取决于驱动和 IDE 的实现）看到 <code>pstmt</code> 内部绑定的参数值。</li>
<li><strong><code>ResultSet</code> 对象</strong>: 检查其内部状态，确认是否包含数据。</li>
</ul>
</li>
<li><strong>结合数据库客户端</strong>:<ul>
<li>当你从日志或 Debugger 中获取到<strong>最终执行的 SQL 和参数</strong>后，如果仍然不明白为什么结果不符合预期，<strong>立即将这条 SQL 语句复制到数据库客户端工具（如 Navicat, DBeaver, MySQL Workbench）中，手动执行一遍</strong>。</li>
<li>这可以帮助你判断问题是出在 Java 代码逻辑层面，还是 SQL 语句本身就有问题。这是<strong>最高效</strong>的调试方法之一。</li>
</ul>
</li>
</ol>
<hr>
<hr>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/09/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/Mysql/" rel="prev" title="Mysql">
                  <i class="fa fa-angle-left"></i> Mysql
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/ORM%E6%A1%86%E6%9E%B6/" rel="next" title="ORM框架">
                  ORM框架 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
