<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="三、单元测试前言：单元测试的价值与哲学单元测试的真正价值单元测试的价值远不止于“保证代码正确运行”或“提高测试覆盖率”。它为我们开发者带来了多维度的、深刻的益处：  提供安全的重构保障这是单元测试最核心、最无可替代的价值。一套良好的单元测试集就像一张精密的安全网。它赋予我们“大刀阔斧”重构代码的勇气，无论是优化算法、调整设计模式，还是消除技术债。只要测试全部通过，我们就有极大的信心，相信既有功能没">
<meta property="og:type" content="article">
<meta property="og:title" content="三、单元测试">
<meta property="og:url" content="http://example.com/2025/11/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%B4%A8%E9%87%8F/%E4%B8%89%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="三、单元测试前言：单元测试的价值与哲学单元测试的真正价值单元测试的价值远不止于“保证代码正确运行”或“提高测试覆盖率”。它为我们开发者带来了多维度的、深刻的益处：  提供安全的重构保障这是单元测试最核心、最无可替代的价值。一套良好的单元测试集就像一张精密的安全网。它赋予我们“大刀阔斧”重构代码的勇气，无论是优化算法、调整设计模式，还是消除技术债。只要测试全部通过，我们就有极大的信心，相信既有功能没">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-11-02T03:49:49.000Z">
<meta property="article:modified_time" content="2025-11-04T04:58:17.795Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/11/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%B4%A8%E9%87%8F/%E4%B8%89%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/11/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%B4%A8%E9%87%8F/%E4%B8%89%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","path":"2025/11/02/软件工程与质量/三、单元测试/","title":"三、单元测试"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>三、单元测试 | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-text">三、单元测试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80%EF%BC%9A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BB%B7%E5%80%BC%E4%B8%8E%E5%93%B2%E5%AD%A6"><span class="nav-text">前言：单元测试的价值与哲学</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E7%9C%9F%E6%AD%A3%E4%BB%B7%E5%80%BC"><span class="nav-text">单元测试的真正价值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E5%93%B2%E5%AD%A6%EF%BC%9A%E4%B8%80%E7%A7%8D%E4%B8%93%E4%B8%9A%E7%9A%84%E5%BC%80%E5%8F%91%E8%8C%83%E5%BC%8F"><span class="nav-text">单元测试的哲学：一种专业的开发范式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%E4%B8%8E%E7%90%86%E5%BF%B5"><span class="nav-text">1. 核心工具与理念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80"><span class="nav-text">1.1 单元测试基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Unit-Test-%EF%BC%9F"><span class="nav-text">1.1.1 什么是单元测试 (Unit Test)？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%B9%89"><span class="nav-text">1. 核心定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E2%80%9C%E5%8D%95%E5%85%83-Unit-%E2%80%9D%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">2. “单元 (Unit)”到底是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9F%BA%E7%9F%B3%EF%BC%9A%E9%9A%94%E7%A6%BB-Isolation"><span class="nav-text">3. 单元测试的基石：隔离 (Isolation)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-text">4. 一个简单的例子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-2-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-text">1.1.2 第一个单元测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-%E4%BD%BF%E7%94%A8-Maven-%E6%88%96-Gradle"><span class="nav-text">1. 环境准备 (使用 Maven 或 Gradle)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%BC%96%E5%86%99%E8%A2%AB%E6%B5%8B%E4%BB%A3%E7%A0%81-Class-Under-Test-CUT"><span class="nav-text">2. 编写被测代码 (Class Under Test, CUT)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E7%BC%96%E5%86%99%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="nav-text">3. 编写你的第一个测试用例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E5%B9%B6%E8%A7%A3%E8%AF%BB%E7%BB%93%E6%9E%9C"><span class="nav-text">4. 运行测试并解读结果</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-JUnit-5-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">1.1.3 JUnit 5 核心注解与生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3"><span class="nav-text">1. 核心注解详解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%8E%A7%E5%88%B6%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E8%A7%A3"><span class="nav-text">2. 控制测试执行：生命周期注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%8F%90%E5%8D%87%E5%8F%AF%E8%AF%BB%E6%80%A7%E4%B8%8E%E7%81%B5%E6%B4%BB%E6%80%A7"><span class="nav-text">3. 提升可读性与灵活性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%AE%8C%E6%95%B4%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%BC%94%E7%A4%BA"><span class="nav-text">4. 完整生命周期演示</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-4-%E6%A0%B8%E5%BF%83%E6%96%AD%E8%A8%80-Assertions"><span class="nav-text">1.1.4 核心断言 (Assertions)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AF%BC%E5%85%A5%E6%96%AD%E8%A8%80%E6%96%B9%E6%B3%95"><span class="nav-text">1. 导入断言方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-JUnit-5-%E5%B8%B8%E7%94%A8%E6%96%AD%E8%A8%80%E6%96%B9%E6%B3%95"><span class="nav-text">2. JUnit 5 常用断言方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%8F%90%E5%8D%87%E6%96%AD%E8%A8%80%E5%8F%AF%E8%AF%BB%E6%80%A7%EF%BC%9A%E4%BD%BF%E7%94%A8-AssertJ-%E6%88%96-Hamcrest"><span class="nav-text">3. 提升断言可读性：使用 AssertJ 或 Hamcrest</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%B0%8F%E7%BB%93%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">4. 小结与最佳实践</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95"><span class="nav-text">2. 进阶用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E9%9A%94%E7%A6%BB%E4%BE%9D%E8%B5%96%EF%BC%9AMock-%E4%B8%8E-Stub"><span class="nav-text">2.1 隔离依赖：Mock 与 Stub</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Mock%EF%BC%9F"><span class="nav-text">2.1.1 为什么需要 Mock？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E6%B5%8B%E8%AF%95%E6%9B%BF%E8%BA%AB-Test-Doubles-%E7%90%86%E8%AE%BA%EF%BC%9ADummy-Fake-Stub-Spy-Mock"><span class="nav-text">2.1.2 测试替身 (Test Doubles) 理论：Dummy, Fake, Stub, Spy, Mock</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Dummy%EF%BC%88%E5%93%91%E5%85%83%EF%BC%89"><span class="nav-text">1. Dummy（哑元）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Fake%EF%BC%88%E4%BC%AA%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="nav-text">2. Fake（伪对象）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Stub%EF%BC%88%E6%A1%A9%EF%BC%89"><span class="nav-text">3. Stub（桩）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-Spy%EF%BC%88%E9%97%B4%E8%B0%8D%EF%BC%89"><span class="nav-text">4. Spy（间谍）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-Mock%EF%BC%88%E6%A8%A1%E6%8B%9F%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="nav-text">5. Mock（模拟对象）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB%EF%BC%9AStub-vs-Mock"><span class="nav-text">6. 核心区别：Stub vs. Mock</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-Mockito-%E6%A1%86%E6%9E%B6%EF%BC%9AJava-Mock-%E7%9A%84%E4%BA%8B%E5%AE%9E%E6%A0%87%E5%87%86"><span class="nav-text">2.1.3 Mockito 框架：Java Mock 的事实标准</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%9A%E5%BC%95%E5%85%A5-Mockito-%E4%BE%9D%E8%B5%96"><span class="nav-text">1. 环境搭建：引入 Mockito 依赖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%88%9B%E5%BB%BA%E3%80%81%E6%89%93%E6%A1%A9%E3%80%81%E9%AA%8C%E8%AF%81"><span class="nav-text">2. 核心三步：创建、打桩、验证</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-InjectMocks-%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5-Mock-%E5%AF%B9%E8%B1%A1"><span class="nav-text">3. @InjectMocks: 自动注入 Mock 对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%8F%82%E6%95%B0%E5%8C%B9%E9%85%8D%E5%99%A8-Argument-Matchers"><span class="nav-text">4. 参数匹配器 (Argument Matchers)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-Spying%EF%BC%9A%E9%83%A8%E5%88%86-Mock-%E7%9C%9F%E5%AE%9E%E5%AF%B9%E8%B1%A1-Spy-%E6%B3%A8%E8%A7%A3"><span class="nav-text">5. Spying：部分 Mock 真实对象 (@Spy 注解)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%8F%90%E5%8D%87%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87%E4%B8%8E%E8%B4%A8%E9%87%8F"><span class="nav-text">2.2 提升测试覆盖率与质量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87-Code-Coverage"><span class="nav-text">2.2.1 代码覆盖率 (Code Coverage)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%8E%87%EF%BC%9F-%E8%A1%8C%E3%80%81%E5%88%86%E6%94%AF%E3%80%81%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E7%8E%87"><span class="nav-text">1. 什么是覆盖率？(行、分支、方法覆盖率)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E8%A6%86%E7%9B%96%E7%8E%87%E6%8C%87%E6%A0%87%EF%BC%9F-%E5%AE%83%E4%B8%8D%E6%98%AF%E9%93%B6%E5%BC%B9"><span class="nav-text">2. 如何看待覆盖率指标？(它不是银弹)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%B7%A5%E5%85%B7%E9%9B%86%E6%88%90%EF%BC%9A%E4%BD%BF%E7%94%A8-JaCoCo-%E7%94%9F%E6%88%90%E8%A6%86%E7%9B%96%E7%8E%87%E6%8A%A5%E5%91%8A"><span class="nav-text">3. 工具集成：使用 JaCoCo 生成覆盖率报告</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E6%B5%8B%E8%AF%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">2.2.2 编写高质量测试的最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-AAA-%E6%A8%A1%E5%BC%8F%EF%BC%9AArrange-Act-Assert"><span class="nav-text">1. AAA 模式：Arrange, Act, Assert</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-FIRST-%E5%8E%9F%E5%88%99"><span class="nav-text">2. FIRST 原则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%B5%8B%E8%AF%95%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%EF%BC%9Ashould-%E6%9C%9F%E6%9C%9B%E8%A1%8C%E4%B8%BA-when-%E7%BB%99%E5%AE%9A%E6%9D%A1%E4%BB%B6"><span class="nav-text">3. 测试命名规范：should_期望行为_when_给定条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E4%BF%9D%E6%8C%81%E6%B5%8B%E8%AF%95%E7%9A%84%E7%AE%80%E6%B4%81%E4%B8%8E%E4%B8%93%E6%B3%A8%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E5%8F%AA%E6%B5%8B%E4%B8%80%E4%B8%AA%E7%82%B9"><span class="nav-text">4. 保持测试的简洁与专注：一个测试只测一个点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E9%AB%98%E7%BA%A7%E6%B5%8B%E8%AF%95%E5%9C%BA%E6%99%AF"><span class="nav-text">2.2.3 高级测试场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95-ParameterizedTest-%E7%94%A8%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E5%A4%9A%E6%AC%A1%E8%BF%90%E8%A1%8C%E5%90%8C%E4%B8%80%E6%B5%8B%E8%AF%95"><span class="nav-text">1. 参数化测试 (@ParameterizedTest): 用不同数据多次运行同一测试</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%B5%8C%E5%A5%97%E6%B5%8B%E8%AF%95-Nested-%E7%BB%93%E6%9E%84%E5%8C%96%E5%9C%B0%E7%BB%84%E7%BB%87%E7%9B%B8%E5%85%B3%E6%B5%8B%E8%AF%95%E7%B1%BB"><span class="nav-text">2. 嵌套测试 (@Nested): 结构化地组织相关测试类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%B5%8B%E8%AF%95%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%EF%BC%9F-%E8%AE%A8%E8%AE%BA"><span class="nav-text">3. 测试私有方法？(讨论)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%9E%8D%E5%85%A5%E7%8E%B0%E4%BB%A3%E5%BC%80%E5%8F%91%E7%94%9F%E6%80%81"><span class="nav-text">3. 融入现代开发生态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Spring-Spring-Boot-%E5%BA%94%E7%94%A8%E6%B5%8B%E8%AF%95"><span class="nav-text">3.1 Spring&#x2F;Spring Boot 应用测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-Spring-%E6%B5%8B%E8%AF%95%E4%B8%8A%E4%B8%8B%E6%96%87-ExtendWith-SpringExtension-class"><span class="nav-text">3.1.1 Spring 测试上下文 (@ExtendWith(SpringExtension.class))</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%BA%90%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%99%AE%E9%80%9A%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%8D%E5%A4%9F%E7%94%A8%EF%BC%9F"><span class="nav-text">1. 问题的根源：为什么普通的单元测试不够用？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9ASpring-%E6%B5%8B%E8%AF%95%E4%B8%8A%E4%B8%8B%E6%96%87-Spring-Test-Context"><span class="nav-text">2. 解决方案：Spring 测试上下文 (Spring Test Context)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-ExtendWith-SpringExtension-class-%EF%BC%9A%E8%BF%9E%E6%8E%A5-JUnit-5-%E4%B8%8E-Spring-%E7%9A%84%E6%A1%A5%E6%A2%81"><span class="nav-text">3. @ExtendWith(SpringExtension.class)：连接 JUnit 5 与 Spring 的桥梁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="nav-text">4. 工作流程与示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BC%93%E5%AD%98-Context-Caching"><span class="nav-text">5. 上下文缓存 (Context Caching)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-SpringBootTest-%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%95%B4%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E8%BF%9B%E8%A1%8C%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="nav-text">3.1.2 @SpringBootTest: 加载完整的应用上下文进行集成测试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-SpringBootTest-%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8"><span class="nav-text">1. @SpringBootTest 的核心作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-SpringBootTest"><span class="nav-text">2. 何时使用 @SpringBootTest</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-text">3. 基本用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E7%9C%9F%E5%AE%9E%E7%9A%84-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">4. 启动一个真实的 Web 服务器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-SpringBootTest-%E7%9A%84%E7%BC%BA%E7%82%B9%E4%B8%8E%E6%9D%83%E8%A1%A1"><span class="nav-text">5. @SpringBootTest 的缺点与权衡</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-%E5%88%87%E7%89%87%E6%B5%8B%E8%AF%95-Slice-Tests-%EF%BC%9A%E6%9B%B4%E5%BF%AB%E3%80%81%E6%9B%B4%E4%B8%93%E6%B3%A8%E7%9A%84%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="nav-text">3.1.3 切片测试 (Slice Tests)：更快、更专注的集成测试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-WebMvcTest-%E5%8F%AA%E6%B5%8B%E8%AF%95-Web-%E5%B1%82-Controller"><span class="nav-text">1. @WebMvcTest: 只测试 Web 层 (Controller)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-DataJpaTest-%E5%8F%AA%E6%B5%8B%E8%AF%95-JPA-%E6%8C%81%E4%B9%85%E5%B1%82"><span class="nav-text">2. @DataJpaTest: 只测试 JPA 持久层</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-RestClientTest-%E6%B5%8B%E8%AF%95%E5%AE%A2%E6%88%B7%E7%AB%AF-REST-%E8%B0%83%E7%94%A8"><span class="nav-text">3. @RestClientTest: 测试客户端 REST 调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E5%88%87%E7%89%87%E6%B5%8B%E8%AF%95%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-text">总结：切片测试的选择</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4-%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%AE%A1%E7%90%86-Beans"><span class="nav-text">3.1.4 在测试中管理 Beans</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Autowired-%E6%B3%A8%E5%85%A5%E7%9C%9F%E5%AE%9E%E7%9A%84-Bean"><span class="nav-text">1. @Autowired: 注入真实的 Bean</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-MockBean-%E5%B0%86-Spring-Context-%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA-Bean-%E6%9B%BF%E6%8D%A2%E4%B8%BA-Mockito-Mock"><span class="nav-text">2. @MockBean: 将 Spring Context 中的某个 Bean 替换为 Mockito Mock</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-SpyBean-%E5%B0%86-Spring-Context-%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA-Bean-%E5%8C%85%E8%A3%85%E4%B8%BA-Spy"><span class="nav-text">3. @SpyBean: 将 Spring Context 中的某个 Bean 包装为 Spy</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="nav-text">总结与对比</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-5-%E4%BD%BF%E7%94%A8-MockMvc-%E6%B5%8B%E8%AF%95-RESTful-API"><span class="nav-text">3.1.5 使用 MockMvc 测试 RESTful API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%EF%BC%9A%E6%B3%A8%E5%85%A5-MockMvc"><span class="nav-text">1. 准备工作：注入 MockMvc</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-MockMvc-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">2. MockMvc 的核心工作流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82-MockMvcRequestBuilders"><span class="nav-text">3. 发起请求 (MockMvcRequestBuilders)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E9%AA%8C%E8%AF%81%E5%93%8D%E5%BA%94-MockMvcResultMatchers"><span class="nav-text">4. 验证响应 (MockMvcResultMatchers)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B"><span class="nav-text">5. 综合示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%8E%AF%E5%A2%83%E7%9A%84%E6%8C%91%E6%88%98"><span class="nav-text">3.2 数据与环境的挑战</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5"><span class="nav-text">3.2.1 数据库测试策略</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%A6%82-H2"><span class="nav-text">1. 使用内存数据库 (如 H2)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8-Testcontainers%EF%BC%9A%E9%80%9A%E8%BF%87-Docker-%E5%90%AF%E5%8A%A8%E7%9C%9F%E5%AE%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%BE%8B"><span class="nav-text">2. 使用 Testcontainers：通过 Docker 启动真实的数据库实例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86"><span class="nav-text">3. 测试数据管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E7%AD%96%E7%95%A5%E9%80%89%E6%8B%A9%E6%80%BB%E7%BB%93"><span class="nav-text">4. 策略选择总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E6%B5%8B%E8%AF%95%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81"><span class="nav-text">3.2.2 测试异步代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%B5%8B%E8%AF%95-CompletableFuture"><span class="nav-text">1. 测试 CompletableFuture</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%B5%8B%E8%AF%95%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-Kafka-RabbitMQ"><span class="nav-text">2. 测试消息队列 (Kafka&#x2F;RabbitMQ)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-text">3.2.3 微服务架构下的测试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%9A%84%E8%BE%B9%E7%95%8C%EF%BC%9A%E4%BC%A0%E7%BB%9F%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9B%B0%E5%A2%83"><span class="nav-text">1. 集成测试的边界：传统端到端测试的困境</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%B6%88%E8%B4%B9%E8%80%85%E9%A9%B1%E5%8A%A8%E5%A5%91%E7%BA%A6%E6%B5%8B%E8%AF%95-Consumer-Driven-Contract-Testing-CDC"><span class="nav-text">2. 消费者驱动契约测试 (Consumer-Driven Contract Testing, CDC)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Pact-%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B"><span class="nav-text">3. Pact 框架简介</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-TDD-%E4%B8%8E%E8%A1%8C%E4%B8%BA%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-BDD"><span class="nav-text">3.3 测试驱动开发 (TDD) 与行为驱动开发 (BDD)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-TDD-Test-Driven-Development"><span class="nav-text">3.3.1 TDD (Test-Driven Development)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%BA%A2-%E7%BB%BF-%E9%87%8D%E6%9E%84-Red-Green-Refactor-%E5%BE%AA%E7%8E%AF"><span class="nav-text">1. 红-绿-重构 (Red-Green-Refactor) 循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-TDD-%E5%A6%82%E4%BD%95%E9%A9%B1%E5%8A%A8%E5%87%BA%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1"><span class="nav-text">2. TDD 如何驱动出更好的代码设计</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-BDD-Behavior-Driven-Development"><span class="nav-text">3.3.2 BDD (Behavior-Driven Development)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BB%8E%E4%B8%9A%E5%8A%A1%E9%9C%80%E6%B1%82%E5%87%BA%E5%8F%91%EF%BC%9AGherkin-%E8%AF%AD%E8%A8%80-Given-When-Then"><span class="nav-text">1. 从业务需求出发：Gherkin 语言 (Given-When-Then)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%B7%A5%E5%85%B7%E7%AE%80%E4%BB%8B%EF%BC%9ACucumber"><span class="nav-text">2. 工具简介：Cucumber</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-BDD-%E4%B8%8E-TDD-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">3. BDD 与 TDD 的关系</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4%E8%B4%A8%E9%87%8F"><span class="nav-text">4. 追求极致质量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E8%87%AA%E5%8A%A8%E5%8C%96%E4%B8%8E-CI-CD-%E9%9B%86%E6%88%90"><span class="nav-text">4.1 自动化与 CI&#x2F;CD 集成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%E5%9C%A8%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E4%B8%AD%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95-Maven-Surefire-Gradle-test-task"><span class="nav-text">4.1.1 在构建工具中运行测试 (Maven Surefire &#x2F; Gradle test task)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Maven-Surefire-%E6%8F%92%E4%BB%B6"><span class="nav-text">1. Maven: Surefire 插件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Gradle-test-%E4%BB%BB%E5%8A%A1"><span class="nav-text">2. Gradle: test 任务</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-%E5%B0%86%E6%B5%8B%E8%AF%95%E9%9B%86%E6%88%90%E5%88%B0-CI-CD-%E6%B5%81%E6%B0%B4%E7%BA%BF-Jenkins-GitLab-CI-GitHub-Actions"><span class="nav-text">4.1.2 将测试集成到 CI&#x2F;CD 流水线 (Jenkins, GitLab CI, GitHub Actions)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%EF%BC%9A%E6%9E%84%E5%BB%BA%E5%A4%B1%E8%B4%A5-on-%E6%B5%8B%E8%AF%95%E5%A4%B1%E8%B4%A5"><span class="nav-text">1. 核心配置：构建失败 on 测试失败</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%9C%A8%E4%B8%8D%E5%90%8C-CI-CD-%E5%B7%A5%E5%85%B7%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">2. 在不同 CI&#x2F;CD 工具中的实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%B9%B6%E5%8F%91%E5%B8%83%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%E5%92%8C%E8%A6%86%E7%9B%96%E7%8E%87%E6%8A%A5%E5%91%8A"><span class="nav-text">3. 自动生成并发布测试报告和覆盖率报告</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E9%AB%98%E7%BA%A7%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81%E6%8A%80%E6%9C%AF"><span class="nav-text">4.2 高级质量保证技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E5%8F%98%E5%BC%82%E6%B5%8B%E8%AF%95-Mutation-Testing"><span class="nav-text">4.2.1 变异测试 (Mutation Testing)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E6%80%A7%E8%83%BD%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95-Benchmark-Testing"><span class="nav-text">4.2.2 性能基准测试 (Benchmark Testing)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-%E6%A3%98%E6%89%8B%E9%97%AE%E9%A2%98%EF%BC%9A%E5%A4%84%E7%90%86%E7%89%87%E7%8A%B6%E6%B5%8B%E8%AF%95-Flaky-Tests"><span class="nav-text">4.2.3 棘手问题：处理片状测试 (Flaky Tests)</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%B4%A8%E9%87%8F/%E4%B8%89%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="三、单元测试 | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          三、单元测试
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-11-02 11:49:49" itemprop="dateCreated datePublished" datetime="2025-11-02T11:49:49+08:00">2025-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-04 12:58:17" itemprop="dateModified" datetime="2025-11-04T12:58:17+08:00">2025-11-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%B4%A8%E9%87%8F/" itemprop="url" rel="index"><span itemprop="name">软件工程与质量</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="三、单元测试"><a href="#三、单元测试" class="headerlink" title="三、单元测试"></a>三、单元测试</h1><h2 id="前言：单元测试的价值与哲学"><a href="#前言：单元测试的价值与哲学" class="headerlink" title="前言：单元测试的价值与哲学"></a>前言：单元测试的价值与哲学</h2><h4 id="单元测试的真正价值"><a href="#单元测试的真正价值" class="headerlink" title="单元测试的真正价值"></a>单元测试的真正价值</h4><p>单元测试的价值远不止于“保证代码正确运行”或“提高测试覆盖率”。它为我们开发者带来了多维度的、深刻的益处：</p>
<ol>
<li><strong>提供安全的重构保障</strong><br>这是单元测试最核心、最无可替代的价值。一套良好的单元测试集就像一张精密的安全网。它赋予我们“大刀阔斧”重构代码的勇气，无论是优化算法、调整设计模式，还是消除技术债。只要测试全部通过，我们就有极大的信心，相信既有功能没有被破坏。没有这层保障，任何有深度的重构都无从谈起。</li>
<li><strong>充当代码的“活文档”</strong><br>注释会过时，文档会疏于更新，但单元测试不会说谎。一个命名清晰的测试用例（例如 <code>should_throwException_when_inputIsNull</code>），能极其直观地展示出被测方法在特定条件下的预期行为。当需要了解一个类的功能时，阅读它的测试代码往往比阅读实现代码本身更快速、更准确。</li>
<li><strong>驱动出更好的设计 (Driving Better Design)</strong><br>“可测试性”是衡量代码设计优良的重要标准。为了让代码易于测试，我们自然而然地会倾向于编写短小、功能单一的方法，遵循单一职责原则（SRP），并面向接口编程以方便隔离依赖。这个过程会“逼迫”我们写出低耦合、高内聚的优雅代码。可以说，<strong>难于测试的代码，通常就是设计糟糕的代码</strong>。</li>
<li><strong>加速开发与调试周期 (Accelerating Development)</strong><br>当你需要调试一个深藏在复杂业务流程中的方法时，你是在本地启动整个庞大的应用，手动操作十几步来复现场景，还是运行一个毫秒级的单元测试？单元测试提供了一个快速、可重复的反馈循环。当测试失败时，问题被精准定位在极小的范围内，极大地缩减了发现和修复Bug的时间。</li>
<li><strong>提升团队协作效率与信心 (Enhancing Collaboration)</strong><br>在一个集成了自动化测试的团队中，当我修改了公共模块时，CI&#x2F;CD流水线上的测试会立刻告诉我是否影响到了其他同事的功能。这建立了一种基于代码的信任契约，减少了集成阶段的冲突与混乱，让团队交付更有信心。</li>
</ol>
<hr>
<h4 id="单元测试的哲学：一种专业的开发范式"><a href="#单元测试的哲学：一种专业的开发范式" class="headerlink" title="单元测试的哲学：一种专业的开发范式"></a>单元测试的哲学：一种专业的开发范式</h4><p>将单元测试视为一种“哲学”或“范式”，意味着它不仅仅是一项任务，更是一种思维方式和工作习惯。</p>
<ul>
<li><strong>测试是代码的一部分，而非附属品</strong>：专业的工程师认为，没有经过测试的代码就是未完成的代码。测试代码与业务代码同等重要，需要同样的关注、设计和维护。</li>
<li><strong>关注行为，而非实现</strong>：好的单元测试应该验证“这个方法做了什么”，而不是“它是如何做的”。这使得当内部实现变化时，只要外部行为不变，测试就无需修改。</li>
<li><strong>测试金字塔模型 (The Testing Pyramid)</strong>：这是一个经典的测试策略模型。它告诉我们，应该拥有大量的、快速的<strong>单元测试</strong>作为地基，辅以适量的、稍慢的<strong>集成测试</strong>，以及少量的、最慢的<strong>端到端测试（E2E）</strong>。将大部分测试精力投入到金字塔底部，是构建稳定、高效的质量保障体系的关键。</li>
</ul>
<hr>
<h2 id="1-核心工具与理念"><a href="#1-核心工具与理念" class="headerlink" title="1. 核心工具与理念"></a>1. 核心工具与理念</h2><h3 id="1-1-单元测试基础"><a href="#1-1-单元测试基础" class="headerlink" title="1.1 单元测试基础"></a>1.1 单元测试基础</h3><h4 id="1-1-1-什么是单元测试-Unit-Test-？"><a href="#1-1-1-什么是单元测试-Unit-Test-？" class="headerlink" title="1.1.1 什么是单元测试 (Unit Test)？"></a>1.1.1 什么是单元测试 (Unit Test)？</h4><h5 id="1-核心定义"><a href="#1-核心定义" class="headerlink" title="1. 核心定义"></a>1. 核心定义</h5><p>单元测试是软件测试的一种方法，其目标是<strong>验证程序中最小的可测试单元是否按预期工作</strong>。它是一种白盒测试，测试人员清楚代码的内部结构和逻辑。</p>
<p>这个定义包含两个关键点：<strong>“单元”</strong> 和 <strong>“隔离”</strong>。</p>
<hr>
<h5 id="2-“单元-Unit-”到底是什么？"><a href="#2-“单元-Unit-”到底是什么？" class="headerlink" title="2. “单元 (Unit)”到底是什么？"></a>2. “单元 (Unit)”到底是什么？</h5><p>在不同的编程范式和语言中，“单元”的粒度有所不同。在面向对象的Java世界里，一个“单元”通常指：</p>
<ul>
<li><strong>一个方法 (Method)</strong>：这是最常见、最理想的单元。例如，测试一个 <code>Calculator</code> 类的 <code>add(int a, int b)</code> 方法，验证它是否能正确地将两个数字相加。</li>
<li><strong>一个类 (Class)</strong>：有时，一个类的多个方法紧密协作以完成一个完整的职责，此时可以将整个类视为一个单元。测试时，我们通过调用其公共方法（Public API）来验证类的行为和状态变化是否符合预期。</li>
</ul>
<p><strong>核心思想</strong>：一个单元应该是逻辑上独立的、能够单独拿出来进行验证的最小代码块。</p>
<hr>
<h5 id="3-单元测试的基石：隔离-Isolation"><a href="#3-单元测试的基石：隔离-Isolation" class="headerlink" title="3. 单元测试的基石：隔离 (Isolation)"></a>3. 单元测试的基石：隔离 (Isolation)</h5><p>这是区分单元测试与其他测试（如集成测试）的<strong>最重要原则</strong>。</p>
<p>一个真正的单元测试必须在<strong>隔离的环境</strong>中运行。这意味着被测试的“单元”应该与系统的其他部分解耦，特别是要与以下这些“外部依赖”隔离开：</p>
<ul>
<li><strong>数据库</strong>：不应连接真实的数据库。</li>
<li><strong>网络服务</strong>：不应发起真实的HTTP请求去调用其他微服务或第三方API。</li>
<li><strong>文件系统</strong>：不应在硬盘上读写真实的文件。</li>
<li><strong>其他业务类</strong>：例如，<code>OrderService</code> 的单元测试不应该依赖一个真实的 <code>InventoryService</code> 或 <code>UserService</code>。</li>
<li><strong>不确定的外部因素</strong>：如系统当前时间、随机数生成等。</li>
</ul>
<p><strong>为什么要隔离？</strong></p>
<ul>
<li><strong>速度</strong>：隔离了缓慢的I&#x2F;O操作（网络、磁盘、数据库），单元测试才能运行得极快。成千上万的测试在几秒或几十秒内就能跑完，这提供了即时反馈。</li>
<li><strong>精确定位问题</strong>：当一个隔离的测试失败时，问题几乎可以100%确定就出在这个“单元”内部，而不是它的某个依赖项。这极大地简化了调试过程。</li>
<li><strong>可重复性</strong>：测试结果不应受到外部环境变化的影响。无论数据库里有什么数据，无论网络是否通畅，测试结果都应该保持一致。</li>
</ul>
<p>为了实现这种隔离，我们稍后会学习一个强大的技术——<strong>Mocking（模拟）</strong>。通过模拟这些外部依赖，我们可以完全控制被测单元的输入和环境。</p>
<hr>
<h5 id="4-一个简单的例子"><a href="#4-一个简单的例子" class="headerlink" title="4. 一个简单的例子"></a>4. 一个简单的例子</h5><p>假设我们有一个简单的用户服务类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUsernameValid</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (username == <span class="literal">null</span> || username.trim().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> username.length() &gt;= <span class="number">5</span> &amp;&amp; username.length() &lt;= <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对 <code>isUsernameValid</code> 这个<strong>单元</strong>，我们可以设计以下几个<strong>测试用例 (Test Cases)</strong>：</p>
<ul>
<li><strong>测试用例1</strong>：给定一个正常的用户名（如 <code>&quot;johndoe&quot;</code>），期望返回 <code>true</code>。</li>
<li><strong>测试用例2</strong>：给定一个过短的用户名（如 <code>&quot;a&quot;</code>），期望返回 <code>false</code>。</li>
<li><strong>测试用例3</strong>：给定一个 <code>null</code> 值，期望返回 <code>false</code>。</li>
<li><strong>测试用例4</strong>：给定一个只包含空格的字符串（如 <code>&quot; &quot;</code>），期望返回 <code>false</code>。</li>
</ul>
<p>这些测试用例共同验证了 <code>isUsernameValid</code> 方法在各种边界条件和正常情况下的行为是否正确。</p>
<hr>
<h5 id="1-1-2-第一个单元测试"><a href="#1-1-2-第一个单元测试" class="headerlink" title="1.1.2 第一个单元测试"></a>1.1.2 第一个单元测试</h5><h5 id="1-环境准备-使用-Maven-或-Gradle"><a href="#1-环境准备-使用-Maven-或-Gradle" class="headerlink" title="1. 环境准备 (使用 Maven 或 Gradle)"></a>1. 环境准备 (使用 Maven 或 Gradle)</h5><p>现代Java项目都使用构建工具（如Maven或Gradle）来管理依赖。我们首先需要在项目中引入JUnit 5。</p>
<p><strong>a. 确认项目结构</strong></p>
<p>一个标准的Java项目结构如下，业务代码和测试代码是分离的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">my-project/</span><br><span class="line">├── pom.xml  (或 build.gradle)</span><br><span class="line">└── src/</span><br><span class="line">    ├── main/</span><br><span class="line">    │   └── java/</span><br><span class="line">    │       └── com/example/myproject/   &lt;-- 你的业务代码放在这里</span><br><span class="line">    └── test/</span><br><span class="line">        └── java/</span><br><span class="line">            └── com/example/myproject/   &lt;-- 你的测试代码放在这里</span><br></pre></td></tr></table></figure>

<p><strong>b. 添加 JUnit 5 依赖</strong></p>
<ul>
<li><p><strong>如果使用 Maven</strong>，在 <code>pom.xml</code> 文件的 <code>&lt;dependencies&gt;</code> 标签内添加：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 建议使用最新稳定版 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>junit-jupiter-api</code>: 提供了编写测试所需的注解和断言方法（如 <code>@Test</code>, <code>assertEquals</code>）。</li>
<li><code>junit-jupiter-engine</code>: 提供了在运行时发现并执行测试的引擎。</li>
<li><code>&lt;scope&gt;test&lt;/scope&gt;</code>: 告诉Maven这些依赖只在测试阶段需要，不会被打包到最终的应用程序中。</li>
</ul>
</li>
<li><p><strong>如果使用 Gradle</strong>，在 <code>build.gradle</code> (或 <code>build.gradle.kts</code>) 文件的 <code>dependencies</code> 代码块中添加：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Groovy DSL</span></span><br><span class="line">testImplementation <span class="string">&#x27;org.junit.jupiter:junit-jupiter-api:5.10.2&#x27;</span></span><br><span class="line">testRuntimeOnly <span class="string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.10.2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保测试任务使用JUnit Platform</span></span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-编写被测代码-Class-Under-Test-CUT"><a href="#2-编写被测代码-Class-Under-Test-CUT" class="headerlink" title="2. 编写被测代码 (Class Under Test, CUT)"></a>2. 编写被测代码 (Class Under Test, CUT)</h5><p>让我们创建一个非常简单的计算器类作为我们的测试对象。</p>
<p>在 <code>src/main/java/com/example/myproject/</code> 目录下创建 <code>Calculator.java</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main/java/com/example/myproject/Calculator.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.myproject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个极其简单的类，但足以让我们演示单元测试的完整流程。</p>
<hr>
<h5 id="3-编写你的第一个测试用例"><a href="#3-编写你的第一个测试用例" class="headerlink" title="3. 编写你的第一个测试用例"></a>3. 编写你的第一个测试用例</h5><p>现在，我们为 <code>Calculator</code> 类的 <code>add</code> 方法编写一个测试。</p>
<p>在 <code>src/test/java/com/example/myproject/</code> 目录下创建 <code>CalculatorTest.java</code>。注意，测试类的命名通常是**“被测类名 + Test”**。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/test/java/com/example/myproject/CalculatorTest.java</span></span><br><span class="line"><span class="keyword">package</span> com.example.myproject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test; <span class="comment">// 导入 @Test 注解</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.assertEquals; <span class="comment">// 导入断言方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalculatorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">// 1. 这是一个JUnit测试方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">should_returnSum_when_addTwoNumbers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 准备 (Arrange)</span></span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedResult</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 执行 (Act)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">actualResult</span> <span class="operator">=</span> calculator.add(a, b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 断言 (Assert)</span></span><br><span class="line">        Assertions.assertEquals(expectedResult, actualResult, <span class="string">&quot;2 + 3 应该等于 5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们来分解这个测试代码：</p>
<ol>
<li><strong><code>@Test</code> 注解</strong>：这是JUnit 5的核心注解。它告诉JUnit，被标记的这个方法 (<code>should_returnSum_when_addTwoNumbers</code>) 是一个需要被执行的测试用例。</li>
<li><strong>准备 (Arrange)</strong>：我们创建了被测对象 <code>Calculator</code> 的实例，并准备好了输入数据 (<code>a</code>, <code>b</code>) 和我们期望的结果 (<code>expectedResult</code>)。</li>
<li><strong>执行 (Act)</strong>：我们调用了被测方法 <code>calculator.add(a, b)</code>，并获取了它的实际返回结果 <code>actualResult</code>。</li>
<li><strong>断言 (Assert)</strong>：这是测试的灵魂。我们使用 <code>assertEquals</code> 方法来比较<strong>期望结果</strong>和<strong>实际结果</strong>是否相等。<ul>
<li><code>assertEquals(expected, actual)</code> 是最常用的断言。如果两者相等，测试通过。如果不相等，测试失败。</li>
<li>最后一个可选参数是失败时显示的提示信息，有助于快速定位问题。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>最佳实践提示</strong>：这个“准备-执行-断言”（Arrange-Act-Assert, AAA）的结构是编写清晰单元测试的黄金法则。</p>
</blockquote>
<hr>
<h5 id="4-运行测试并解读结果"><a href="#4-运行测试并解读结果" class="headerlink" title="4. 运行测试并解读结果"></a>4. 运行测试并解读结果</h5><ul>
<li><strong>在 IDE 中运行 (推荐)</strong><ul>
<li>在 IntelliJ IDEA 或 Eclipse 中，你会看到 <code>CalculatorTest</code> 类或 <code>should_returnSum_when_addTwoNumbers</code> 方法旁边有一个绿色的“播放”按钮。</li>
<li>点击这个按钮，选择“Run ‘…Test’”。</li>
<li>IDE会编译并运行测试，然后在测试窗口中显示结果。如果一切顺利，你会看到一个<strong>绿色的进度条</strong>，表示所有测试都通过了！</li>
</ul>
</li>
<li><strong>通过构建工具运行 (用于自动化)</strong><ul>
<li>打开命令行&#x2F;终端，导航到项目根目录。</li>
<li>如果你使用 Maven，运行：<code>mvn test</code></li>
<li>如果你使用 Gradle，运行：<code>./gradlew test</code> (或 <code>gradlew.bat test</code> on Windows)</li>
<li>构建工具会自动找到并执行所有测试，并在控制台输出报告，最终显示 <code>BUILD SUCCESS</code>。</li>
</ul>
</li>
</ul>
<p><strong>模拟一次失败</strong></p>
<p>为了理解测试失败是什么样子，让我们故意把测试改错。将 <code>expectedResult</code> 修改为 <code>6</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span> <span class="variable">expectedResult</span> <span class="operator">=</span> <span class="number">6</span>; <span class="comment">// 故意写错</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Assertions.assertEquals(expectedResult, actualResult, <span class="string">&quot;2 + 3 应该等于 5&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>再次运行测试，你会看到：</p>
<ul>
<li><p>IDE中的进度条变成了<strong>红色</strong>。</p>
</li>
<li><p>测试结果窗口会清晰地指出哪个测试失败了，并提供详细的错误信息，类似：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.opentest4j.AssertionFailedError: 2 + 3 应该等于 5 ==&gt; </span><br><span class="line">预期:6</span><br><span class="line">实际:5</span><br></pre></td></tr></table></figure>

<p>这个信息告诉我们：期望得到 <code>6</code>，但实际得到的是 <code>5</code>。这正是单元测试的威力——快速、精准地告诉你代码的行为与你的预期不符。</p>
<p>现在，将 <code>expectedResult</code> 改回 <code>5</code>，测试就会再次变绿。</p>
</li>
</ul>
<hr>
<h4 id="1-1-3-JUnit-5-核心注解与生命周期"><a href="#1-1-3-JUnit-5-核心注解与生命周期" class="headerlink" title="1.1.3 JUnit 5 核心注解与生命周期"></a>1.1.3 JUnit 5 核心注解与生命周期</h4><h5 id="1-核心注解详解"><a href="#1-核心注解详解" class="headerlink" title="1. 核心注解详解"></a>1. 核心注解详解</h5><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
<th>执行时机</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Test</code></td>
<td>声明一个方法是测试方法。</td>
<td>测试执行的核心部分。</td>
</tr>
<tr>
<td><code>@DisplayName</code></td>
<td>为测试类或测试方法提供一个自定义的、更具可读性的名称。</td>
<td>显示在测试报告和IDE中。</td>
</tr>
<tr>
<td><code>@BeforeEach</code></td>
<td>在<strong>每个</strong> <code>@Test</code> 方法执行<strong>之前</strong>执行一次。</td>
<td>每个测试方法前。</td>
</tr>
<tr>
<td><code>@AfterEach</code></td>
<td>在<strong>每个</strong> <code>@Test</code> 方法执行<strong>之后</strong>执行一次。</td>
<td>每个测试方法后。</td>
</tr>
<tr>
<td><code>@BeforeAll</code></td>
<td>在当前测试类中<strong>所有</strong> <code>@Test</code> 方法执行<strong>之前</strong>执行一次。方法必须是<code>static</code>。</td>
<td>所有测试方法前，仅一次。</td>
</tr>
<tr>
<td><code>@AfterAll</code></td>
<td>在当前测试类中<strong>所有</strong> <code>@Test</code> 方法执行<strong>之后</strong>执行一次。方法必须是<code>static</code>。</td>
<td>所有测试方法后，仅一次。</td>
</tr>
<tr>
<td><code>@Disabled</code></td>
<td>禁用一个测试类或测试方法，使其不被执行。</td>
<td>测试运行时会被跳过。</td>
</tr>
</tbody></table>
<p>让我们通过一个例子来深入理解它们。</p>
<hr>
<h5 id="2-控制测试执行：生命周期注解"><a href="#2-控制测试执行：生命周期注解" class="headerlink" title="2. 控制测试执行：生命周期注解"></a>2. 控制测试执行：生命周期注解</h5><p>在测试一个需要操作集合的类。为了保证每个测试的独立性（不受其他测试影响），希望每个测试方法开始前都有一个全新的、干净的集合，测试结束后再做一些清理。这时，生命周期注解就派上用场了。</p>
<ul>
<li><p><strong><code>@BeforeEach</code> 和 <code>@AfterEach</code> (每个测试前后)</strong></p>
<p>这两个注解是保证<strong>测试独立性</strong>的基石。</p>
<ul>
<li><strong><code>@BeforeEach</code></strong>：用于初始化测试资源。例如，创建被测对象的新实例，重置数据等。</li>
<li><strong><code>@AfterEach</code></strong>：用于释放测试资源。例如，清理临时文件，恢复被修改的状态等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListOperationsTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span> <span class="comment">// 在每个测试方法运行前，都会执行这个方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing @BeforeEach: Initializing list...&quot;</span>);</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">        assertEquals(<span class="number">1</span>, list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testIsEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        assertTrue(list.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span> <span class="comment">// 在每个测试方法运行后，都会执行这个方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing @AfterEach: Tearing down...&quot;</span>);</span><br><span class="line">        list.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你运行 <code>ListOperationsTest</code> 时，<code>testAdd</code> 和 <code>testIsEmpty</code> 都会在拥有一个全新 <code>ArrayList</code> 实例的环境中执行，它们之间互不干扰。</p>
</li>
<li><p><strong><code>@BeforeAll</code> 和 <code>@AfterAll</code> (所有测试前后)</strong></p>
<p>当某些准备或清理工作非常耗时，且只需要执行一次时（例如，启动数据库连接、初始化一个全局配置），就应该使用这两个注解。</p>
<p><strong>注意</strong>：由于它们在测试类的任何实例创建之前&#x2F;之后执行，所以被标记的方法<strong>必须是 <code>static</code> 的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeavyResourceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setupAll</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing @BeforeAll: Connecting to database...&quot;</span>);</span><br><span class="line">        <span class="comment">// 假设这里是启动数据库或网络服务的昂贵操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">someTest</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">anotherTest</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tearDownAll</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing @AfterAll: Disconnecting from database...&quot;</span>);</span><br><span class="line">        <span class="comment">// 假设这里是关闭数据库连接的清理操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>setupAll</code> 只会在所有测试开始前运行一次，<code>tearDownAll</code> 只会在所有测试结束后运行一次。</p>
</li>
</ul>
<hr>
<h5 id="3-提升可读性与灵活性"><a href="#3-提升可读性与灵活性" class="headerlink" title="3. 提升可读性与灵活性"></a>3. 提升可读性与灵活性</h5><ul>
<li><p><strong><code>@DisplayName(&quot;自定义测试名称&quot;)</code></strong></p>
<p>默认情况下，测试报告会显示方法名，如 <code>should_returnSum_when_addTwoNumbers</code>。虽然这已经很清晰了，但 <code>@DisplayName</code> 允许我们使用包含空格、特殊字符甚至 Emojis 的自然语言描述，让非开发人员也能看懂测试报告。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;我的计算器测试类&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalculatorDisplayNameTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;✅ 2 + 3 应该等于 5&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testAddition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在IDE的测试运行器中，你将看到 “✅ 2 + 3 应该等于 5” 而不是 “testAddition()”。</p>
</li>
<li><p><strong><code>@Disabled</code></strong></p>
<p>有时，某个功能尚未完成，或者其依赖的服务暂时不可用，导致相关测试会失败。与其注释掉或删除测试（这样很容易被遗忘），不如使用 <code>@Disabled</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Disabled(&quot;This feature is currently under development. JIRA-1234&quot;)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpcomingFeature</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被禁用的测试会被跳过，并在报告中明确标记出来，附带提供的原因。这既能保持构建成功，又能提醒团队这个测试需要后续关注。</p>
<hr>
</li>
</ul>
<h5 id="4-完整生命周期演示"><a href="#4-完整生命周期演示" class="headerlink" title="4. 完整生命周期演示"></a>4. 完整生命周期演示</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;JUnit 5 Lifecycle Demo&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LifecycleDemoTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">beforeAll</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--- @BeforeAll: Executed once before all tests ---&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">beforeEach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;  - @BeforeEach: Executed before each test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;First Test&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">firstTest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;    -&gt; Running First Test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;Second Test&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">secondTest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;    -&gt; Running Second Test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Disabled(&quot;This test is skipped for demonstration&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">disabledTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// This code will not be executed</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterEach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;  - @AfterEach: Executed after each test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">afterAll</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--- @AfterAll: Executed once after all tests ---&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这个测试类，你将在控制台看到以下输出，清晰地展示了完整的生命周期：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--- @BeforeAll: Executed once before all tests ---</span><br><span class="line">  - @BeforeEach: Executed before each test</span><br><span class="line">    -&gt; Running First Test</span><br><span class="line">  - @AfterEach: Executed after each test</span><br><span class="line">  - @BeforeEach: Executed before each test</span><br><span class="line">    -&gt; Running Second Test</span><br><span class="line">  - @AfterEach: Executed after each test</span><br><span class="line">--- @AfterAll: Executed once after all tests ---</span><br></pre></td></tr></table></figure>

<p>注意 <code>disabledTest</code> 完全没有触发 <code>@BeforeEach</code> 或 <code>@AfterEach</code>，它被完全跳过了。</p>
<hr>
<h4 id="1-1-4-核心断言-Assertions"><a href="#1-1-4-核心断言-Assertions" class="headerlink" title="1.1.4 核心断言 (Assertions)"></a>1.1.4 核心断言 (Assertions)</h4><h5 id="1-导入断言方法"><a href="#1-导入断言方法" class="headerlink" title="1. 导入断言方法"></a><strong>1. 导入断言方法</strong></h5><p>为了方便使用，我们通常使用静态导入（<code>import static</code>）来直接引用这些方法，这样就不必每次都写 <code>Assertions.</code> 前缀。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.*;</span><br></pre></td></tr></table></figure>

<h5 id="2-JUnit-5-常用断言方法"><a href="#2-JUnit-5-常用断言方法" class="headerlink" title="2. JUnit 5 常用断言方法"></a>2. JUnit 5 常用断言方法</h5><p>下面是最常用的一些断言方法，覆盖了绝大多数测试场景。</p>
<p><strong><code>assertEquals(expected, actual)</code> &#x2F; <code>assertNotEquals(unexpected, actual)</code></strong></p>
<ul>
<li><strong>作用</strong>：验证实际值 (<code>actual</code>) 是否等于期望值 (<code>expected</code>)。这是<strong>最常用</strong>的断言。</li>
<li><strong>注意</strong>：对于对象，它使用对象的 <code>.equals()</code> 方法进行比较。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAddition</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> calculator.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    assertEquals(<span class="number">5</span>, result, <span class="string">&quot;计算结果不符合预期&quot;</span>); <span class="comment">// 第三个参数是可选的失败信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>assertTrue(boolean condition)</code> &#x2F; <code>assertFalse(boolean condition)</code></strong></p>
<ul>
<li><strong>作用</strong>：验证一个布尔条件是否为 <code>true</code> 或 <code>false</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testIsPositive</span><span class="params">()</span> &#123;</span><br><span class="line">    assertTrue(<span class="number">5</span> &gt; <span class="number">0</span>, <span class="string">&quot;5 应该是正数&quot;</span>);</span><br><span class="line">    assertFalse(-<span class="number">1</span> &gt; <span class="number">0</span>, <span class="string">&quot;-1 不应该是正数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>assertNull(Object actual)</code> &#x2F; <code>assertNotNull(Object actual)</code></strong></p>
<ul>
<li><strong>作用</strong>：验证一个对象是否为 <code>null</code> 或非 <code>null</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testObjectNullness</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    assertNull(name, <span class="string">&quot;对象应该为 null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> <span class="string">&quot;New York&quot;</span>;</span><br><span class="line">    assertNotNull(city, <span class="string">&quot;对象不应该为 null&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>assertSame(Object expected, Object actual)</code> &#x2F; <code>assertNotSame(Object unexpected, Object actual)</code></strong></p>
<ul>
<li><strong>作用</strong>：验证两个对象引用是否指向<strong>同一个对象</strong>（即比较内存地址，等同于 <code>==</code>）。</li>
<li><strong>区别于 <code>assertEquals</code></strong>：<code>assertEquals</code> 比较的是值（通过 <code>.equals()</code>），而 <code>assertSame</code> 比较的是身份。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testObjectIdentity</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> a;</span><br><span class="line">    </span><br><span class="line">    assertEquals(a, b); <span class="comment">// 通过，因为值相等</span></span><br><span class="line">    assertNotSame(a, b); <span class="comment">// 通过，因为是两个不同的对象实例</span></span><br><span class="line">    assertSame(a, c);    <span class="comment">// 通过，因为指向同一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>assertThrows(Class&lt;T&gt; expectedType, Executable executable)</code></strong></p>
<ul>
<li><strong>作用</strong>：验证一段代码（<code>Executable</code>）在执行时是否<strong>抛出了指定类型</strong>的异常。这对于测试异常处理逻辑至关重要。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDivisionByZero</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">    <span class="comment">// 使用 lambda 表达式传入要执行的代码块</span></span><br><span class="line">    assertThrows(ArithmeticException.class, () -&gt; &#123;</span><br><span class="line">        calculator.divide(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>assertAll(Executable... executables)</code></strong></p>
<ul>
<li><strong>作用</strong>：分组断言。它会执行所有传入的断言，即使其中有断言失败，也会继续执行完剩余的，最后统一报告所有失败。这在需要一次性验证一个对象的多个属性时非常有用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPersonProperties</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    assertAll(<span class="string">&quot;person properties&quot;</span>,</span><br><span class="line">        () -&gt; assertEquals(<span class="string">&quot;John&quot;</span>, person.getFirstName(), <span class="string">&quot;First name is wrong&quot;</span>),</span><br><span class="line">        () -&gt; assertEquals(<span class="string">&quot;Doe&quot;</span>, person.getLastName(), <span class="string">&quot;Last name is wrong&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-提升断言可读性：使用-AssertJ-或-Hamcrest"><a href="#3-提升断言可读性：使用-AssertJ-或-Hamcrest" class="headerlink" title="3. 提升断言可读性：使用 AssertJ 或 Hamcrest"></a>3. 提升断言可读性：使用 AssertJ 或 Hamcrest</h5><p>虽然 JUnit 5 自带的断言功能强大，但在企业级开发中，为了追求极致的<strong>可读性</strong>和<strong>链式调用</strong>的流畅性，我们更推荐使用第三方的“流式”断言库，如 <strong>AssertJ</strong>。</p>
<ul>
<li><strong>为什么要用 AssertJ?</strong><ul>
<li><strong>语法更自然</strong>：<code>assertThat(actual).is...</code> 的写法更接近自然语言。</li>
<li><strong>更丰富的断言</strong>：提供了对集合、字符串、日期、文件等特定类型的强大断言。</li>
<li><strong>更好的错误信息</strong>：失败时的提示信息非常清晰。</li>
<li><strong>IDE 自动补全友好</strong>：输入 <code>assertThat(myObject).</code> 后，IDE 会智能提示所有可用的断言。</li>
</ul>
</li>
</ul>
<p><strong>Maven 依赖 (AssertJ):</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.assertj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>assertj-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.25.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 建议使用最新稳定版 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例对比：</strong></p>
<ul>
<li><p><strong>使用 JUnit 5 断言：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">assertNotNull(list);</span><br><span class="line">assertEquals(<span class="number">3</span>, list.size());</span><br><span class="line">assertTrue(list.contains(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">assertFalse(list.isEmpty());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 AssertJ 断言 (推荐)：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.assertThat;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">assertThat(list)</span><br><span class="line">    .isNotNull()</span><br><span class="line">    .hasSize(<span class="number">3</span>)</span><br><span class="line">    .contains(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    .doesNotContain(<span class="string">&quot;d&quot;</span>)</span><br><span class="line">    .startsWith(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    .isNotEmpty();</span><br></pre></td></tr></table></figure>

<p>可以看到，AssertJ 的链式调用将多个断言组织在一起，代码更紧凑，可读性也大大增强。</p>
</li>
</ul>
<hr>
<h5 id="4-小结与最佳实践"><a href="#4-小结与最佳实践" class="headerlink" title="4. 小结与最佳实践"></a>4. 小结与最佳实践</h5><ul>
<li><strong>一个测试只测一个核心点</strong>：尽量让每个测试方法只关注一个逻辑分支或行为。如果需要验证一个对象的多个属性，优先使用 <code>assertAll</code>。</li>
<li><strong>提供清晰的失败信息</strong>：在 <code>assertEquals</code> 等方法中加入描述性消息，能让你在测试失败时更快地理解问题所在。</li>
<li><strong>优先选择 AssertJ</strong>：在新项目中，强烈建议使用 AssertJ 来编写断言，这会显著提升你测试代码的质量和可维护性。</li>
</ul>
<hr>
<h2 id="2-进阶用法"><a href="#2-进阶用法" class="headerlink" title="2. 进阶用法"></a>2. 进阶用法</h2><h3 id="2-1-隔离依赖：Mock-与-Stub"><a href="#2-1-隔离依赖：Mock-与-Stub" class="headerlink" title="2.1 隔离依赖：Mock 与 Stub"></a>2.1 隔离依赖：Mock 与 Stub</h3><h4 id="2-1-1-为什么需要-Mock？"><a href="#2-1-1-为什么需要-Mock？" class="headerlink" title="2.1.1 为什么需要 Mock？"></a>2.1.1 为什么需要 Mock？</h4><p>在我们编写了第一个简单的 <code>Calculator</code> 测试后，一切看起来都很美好。但现实世界的软件远比一个独立的计算器复杂。我们的代码单元（比如一个 <code>Service</code> 类）几乎不可避免地会与其他组件产生<strong>依赖（Dependency）</strong>。</p>
<p>单元测试的核心原则是<strong>隔离 (Isolation)</strong>。当我们测试一个单元时，我们只想验证这个单元自身的逻辑是否正确，而不希望测试结果受到其依赖项的影响。</p>
<p>如果一个测试不隔离依赖，它就会退化成一个<strong>集成测试</strong>，并带来一系列问题：</p>
<ol>
<li><strong>速度极慢</strong>：依赖于网络、数据库或文件系统的测试，其执行时间可能是纯内存计算的成百上千倍。当测试数量达到几百上千个时，一次完整的测试运行可能会从几十秒延长到几十分钟，这完全破坏了单元测试提供的“快速反馈”价值。</li>
<li><strong>结果不稳定</strong>：依赖外部系统会引入大量不确定性。网络可能会抖动，数据库可能恰好在维护，第三方API可能会超时或返回非预期的错误。这些因素会导致测试时好时坏，我们称之为“片状测试”，它会严重侵蚀团队对测试套件的信任。</li>
<li><strong>难以定位错误</strong>：当一个包含真实依赖的测试失败时，你很难立刻判断问题是出在被测单元本身，还是出在它的依赖项上。例如，一个 <code>OrderService</code> 的测试失败了，是因为 <code>OrderService</code> 的逻辑错了，还是因为它依赖的 <code>InventoryService</code> 返回了错误数据，又或是数据库连接失败了？这种模糊性违背了单元测试“精确定位问题”的初衷。</li>
<li><strong>难以模拟特定场景</strong>：如何测试你的代码在“异常”情况下的表现？<ul>
<li>如何测试当支付网关返回“余额不足”时，订单状态是否被正确设置为“支付失败”？你总不能真的准备一张余额不足的信用卡去测试吧。</li>
<li>如何测试当数据库连接突然断开时，你的代码是否能优雅地抛出自定义异常，而不是直接崩溃？</li>
<li>如何测试在闰年的2月29日，你的日期处理逻辑是否正确？你总不能把系统时间调到那一天吧。</li>
</ul>
</li>
</ol>
<p>这些场景在真实依赖下几乎<strong>不可能</strong>或<strong>成本极高</strong>地进行测试。</p>
<p>为了解决以上所有问题，我们引入了 <strong>Mocking</strong> 技术。</p>
<p><strong>Mock 对象</strong>（或更广义的<strong>测试替身 Test Double</strong>）是一个在测试环境中用来<strong>替代真实依赖</strong>的“假”对象。它就像电影里的“替身演员”，完全由我们控制，可以模仿真实对象的行为，从而帮助我们完成对主角（被测单元）的测试。</p>
<p><strong>使用 Mock 的核心目的：</strong></p>
<ol>
<li><strong>打破依赖，实现隔离</strong>：通过用 Mock 对象替换真实的数据库、外部服务或其他的业务类，我们的被测单元就运行在了一个完全隔离、纯内存的环境中。</li>
<li><strong>控制行为，模拟场景</strong>：我们可以对 Mock 对象进行“编程”，让它在被调用时返回我们想要的任何结果，或者抛出我们指定的任何异常。<ul>
<li>我们可以让 Mock 的支付网关返回“支付成功”。</li>
<li>我们可以让 Mock 的支付网关返回“余额不足”。</li>
<li>我们可以让 Mock 的数据库操作抛出 <code>SQLException</code>。</li>
<li>我们可以让 Mock 的时间服务返回一个固定的未来日期。</li>
</ul>
</li>
</ol>
<p><strong>一个具体的例子：订单服务</strong></p>
<p>假设我们有这样一个 <code>OrderService</code>，它依赖 <code>PaymentGateway</code> 来处理支付。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖项接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentGateway</span> &#123;</span><br><span class="line">    PaymentResult <span class="title function_">charge</span><span class="params">(<span class="type">double</span> amount, String creditCardInfo)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被测单元</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentGateway paymentGateway;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentGateway paymentGateway)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentGateway = paymentGateway;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">placeOrder</span><span class="params">(Order order, String creditCardInfo)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用依赖项</span></span><br><span class="line">        <span class="type">PaymentResult</span> <span class="variable">result</span> <span class="operator">=</span> paymentGateway.charge(order.getTotalAmount(), creditCardInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.isSuccess()) &#123;</span><br><span class="line">            order.setStatus(OrderStatus.PAID);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            order.setStatus(OrderStatus.FAILED);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果不使用 Mock，我们该如何测试 <code>placeOrder</code> 方法？</strong></p>
<p>我们必须提供一个真实的 <code>PaymentGateway</code> 实现，它会连接到一个真实的支付服务（如Stripe、支付宝）。这意味着：</p>
<ul>
<li>测试会发起真实的网络请求。</li>
<li>我们可能需要用真实的或测试用的信用卡号。</li>
<li>我们无法轻易模拟“支付失败”的场景。</li>
</ul>
<p><strong>使用 Mock 之后，测试变得简单可控：</strong></p>
<p>我们可以创建一个 <code>PaymentGateway</code> 的 Mock 对象。</p>
<ul>
<li><strong>测试场景1：支付成功</strong><ol>
<li>创建一个 <code>mockPaymentGateway</code>。</li>
<li><strong>设定 Mock 行为</strong>：告诉它“当 <code>charge</code> 方法被任何金额和信用卡信息调用时，返回一个表示成功的 <code>PaymentResult</code> 对象”。</li>
<li>将这个 <code>mockPaymentGateway</code> 注入到 <code>OrderService</code> 中。</li>
<li>调用 <code>orderService.placeOrder()</code>。</li>
<li><strong>断言</strong>：验证返回的 <code>order</code> 状态是否为 <code>PAID</code>。</li>
</ol>
</li>
<li><strong>测试场景2：支付失败</strong><ol>
<li>创建一个 <code>mockPaymentGateway</code>。</li>
<li><strong>设定 Mock 行为</strong>：告诉它“当 <code>charge</code> 方法被调用时，返回一个表示失败的 <code>PaymentResult</code> 对象”。</li>
<li>…（后续步骤同上）…</li>
<li><strong>断言</strong>：验证返回的 <code>order</code> 状态是否为 <code>FAILED</code>。</li>
</ol>
</li>
</ul>
<p>通过 Mock，我们完全掌控了 <code>PaymentGateway</code> 的行为，从而可以专注地、确定地测试 <code>OrderService</code> 内部的 <code>if-else</code> 逻辑是否正确。这就是 Mock 的核心价值所在。</p>
<hr>
<h4 id="2-1-2-测试替身-Test-Doubles-理论：Dummy-Fake-Stub-Spy-Mock"><a href="#2-1-2-测试替身-Test-Doubles-理论：Dummy-Fake-Stub-Spy-Mock" class="headerlink" title="2.1.2 测试替身 (Test Doubles) 理论：Dummy, Fake, Stub, Spy, Mock"></a>2.1.2 测试替身 (Test Doubles) 理论：Dummy, Fake, Stub, Spy, Mock</h4><p>这个术语体系由 Gerard Meszaros 在他的著作《xUnit Test Patterns》中提出，它借鉴了电影行业的概念——当主角（被测代码）需要在特定场景（测试用例）下与配角（依赖项）互动时，我们不一定需要请来真正的“大牌”配角，而是可以使用“替身演员”（Test Doubles）。</p>
<p>虽然在日常交流中，我们经常笼统地用 “Mock” 这个词来指代所有测试替身，但严格来说，它们分为五种不同的类型，每种都有其特定的用途。</p>
<table>
<thead>
<tr>
<th>替身类型</th>
<th>电影行业类比</th>
<th>核心作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Dummy</strong></td>
<td>群众演员 (Extra)</td>
<td>只是为了填充参数列表，本身不会被使用。</td>
</tr>
<tr>
<td><strong>Fake</strong></td>
<td>特技演员 (Stuntman)</td>
<td>拥有可工作的、但通常是简化的实现（如用内存数据库代替真实数据库）。</td>
</tr>
<tr>
<td><strong>Stub</strong></td>
<td>带剧本的替身 (Scripted Double)</td>
<td>按预设的“剧本”返回固定的值或抛出异常，用于提供间接输入。</td>
</tr>
<tr>
<td><strong>Spy</strong></td>
<td>间谍&#x2F;卧底 (Spy)</td>
<td>包装真实对象，记录调用信息，但不改变其行为（除非特别指示）。</td>
</tr>
<tr>
<td><strong>Mock</strong></td>
<td>表演指导 (Acting Coach)</td>
<td>预设期望的交互行为，并验证这些交互是否按预期发生。</td>
</tr>
</tbody></table>
<p>下面我们用一个统一的场景来详细解释这五种替身：</p>
<p><strong>场景</strong>：我们正在测试一个 <code>RegistrationService</code>，它在用户注册成功后，需要调用 <code>NotificationService</code> 来发送一封欢迎邮件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NotificationService</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">sendWelcomeEmail</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被测类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegistrationService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NotificationService notificationService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RegistrationService</span><span class="params">(NotificationService notificationService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.notificationService = notificationService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 保存用户的逻辑 ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用依赖</span></span><br><span class="line">        <span class="built_in">this</span>.notificationService.sendWelcomeEmail(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="1-Dummy（哑元）"><a href="#1-Dummy（哑元）" class="headerlink" title="1. Dummy（哑元）"></a>1. Dummy（哑元）</h5><ul>
<li><p><strong>定义</strong>：一个几乎没有任何实现的对象，它的唯一作用是“占位”，以满足方法签名的要求。</p>
</li>
<li><p><strong>特点</strong>：你传递一个 Dummy 对象给方法，但从不期望它被调用。如果它被调用了，通常意味着测试或代码逻辑有误。</p>
</li>
<li><p><strong>何时使用</strong>：当一个方法的参数列表需要某个对象，但在当前测试的特定代码路径下，这个对象完全不会被用到。</p>
</li>
<li><p><strong>示例</strong>：假设 <code>RegistrationService</code> 的构造函数还需要一个 <code>Logger</code> 对象，但我们在测试 <code>register</code> 方法时并不关心日志行为。这时可以传递一个 Dummy <code>Logger</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在测试中，我们并不关心 logger</span></span><br><span class="line"><span class="type">Logger</span> <span class="variable">dummyLogger</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 或者 new DummyLogger();</span></span><br><span class="line"><span class="type">NotificationService</span> <span class="variable">mockNotificationService</span> <span class="operator">=</span> ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dummyLogger 只是为了让构造函数能被调用</span></span><br><span class="line"><span class="type">RegistrationService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistrationService</span>(mockNotificationService, dummyLogger); </span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-Fake（伪对象）"><a href="#2-Fake（伪对象）" class="headerlink" title="2. Fake（伪对象）"></a>2. Fake（伪对象）</h5><ul>
<li><p><strong>定义</strong>：一个拥有完整、可工作但实现方式较为简单的对象。它模拟了真实对象的功能，但绕过了生产环境的复杂性（如数据库、网络）。</p>
</li>
<li><p><strong>特点</strong>：它有自己的行为和状态，不仅仅是返回硬编码的值。</p>
</li>
<li><p><strong>何时使用</strong>：当你需要一个行为相对复杂的依赖，但又不希望引入真实依赖的开销时。最经典的例子就是内存数据库（如 H2）作为真实数据库（如 MySQL）的 Fake。</p>
</li>
<li><p><strong>示例</strong>：我们可以创建一个 <code>InMemoryNotificationService</code>，它不发送真的邮件，而是把通知信息添加到一个 <code>List</code> 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FakeNotificationService</span> <span class="keyword">implements</span> <span class="title class_">NotificationService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;User&gt; sentTo = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendWelcomeEmail</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        sentTo.add(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;Faked email sent to &quot;</span> + user.getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getSentToUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sentTo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在测试中</span></span><br><span class="line"><span class="type">FakeNotificationService</span> <span class="variable">fakeService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FakeNotificationService</span>();</span><br><span class="line"><span class="type">RegistrationService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistrationService</span>(fakeService);</span><br><span class="line">service.register(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断言 Fake 对象的状态</span></span><br><span class="line">assertThat(fakeService.getSentToUsers()).hasSize(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="3-Stub（桩）"><a href="#3-Stub（桩）" class="headerlink" title="3. Stub（桩）"></a>3. Stub（桩）</h5><ul>
<li><p><strong>定义</strong>：一个持有预定义数据并根据调用返回这些数据的对象。它用于提供测试所需的<strong>间接输入 (Indirect Inputs)</strong>。</p>
</li>
<li><p><strong>特点</strong>：通常不响应任何未被预设的调用。它的核心是“状态验证”——我们用 Stub 控制依赖的输出，然后检查<strong>被测单元的状态</strong>是否正确。</p>
</li>
<li><p><strong>何时使用</strong>：这是最常见的测试替身。当你需要依赖项返回特定值或抛出特定异常，来驱动被测代码走向不同的逻辑分支时。</p>
</li>
<li><p><strong>示例</strong>（使用 Mockito 框架）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Mockito 创建一个 Stub</span></span><br><span class="line"><span class="type">NotificationService</span> <span class="variable">stubService</span> <span class="operator">=</span> Mockito.mock(NotificationService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定“剧本”：当 sendWelcomeEmail 被调用时，返回 true</span></span><br><span class="line"><span class="keyword">when</span>(stubService.sendWelcomeEmail(any(User.class))).thenReturn(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">RegistrationService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistrationService</span>(stubService);</span><br><span class="line"><span class="comment">// ... 调用 service.register(user) ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们不关心 stubService 被如何调用，只关心 service 的结果（如果它有状态变化的话）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="4-Spy（间谍）"><a href="#4-Spy（间谍）" class="headerlink" title="4. Spy（间谍）"></a>4. Spy（间谍）</h5><ul>
<li><p><strong>定义</strong>：一个包装了真实对象的替身。默认情况下，它将所有调用都委托给真实对象，但它会<strong>记录</strong>这些调用的信息（如调用次数、参数等）。你也可以选择性地“桩化”（Stub）它的某些方法。</p>
</li>
<li><p><strong>特点</strong>：部分真实，部分伪造。</p>
</li>
<li><p><strong>何时使用</strong>：当你需要测试一个类的<strong>大部分真实行为</strong>，但又想修改其中一小部分行为（如避免一个网络调用），或者想验证某个内部方法是否被正确调用时。常用于测试遗留代码。</p>
</li>
<li><p><strong>示例</strong>（使用 Mockito 框架）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们有一个真实的 EmailNotificationService</span></span><br><span class="line"><span class="type">EmailNotificationService</span> <span class="variable">realService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmailNotificationService</span>();</span><br><span class="line"><span class="comment">// 创建一个 Spy</span></span><br><span class="line"><span class="type">NotificationService</span> <span class="variable">spyService</span> <span class="operator">=</span> Mockito.spy(realService);</span><br><span class="line"></span><br><span class="line"><span class="type">RegistrationService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistrationService</span>(spyService);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">service.register(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证：spyService 的 sendWelcomeEmail 方法是否被以 user 为参数调用了1次</span></span><br><span class="line">verify(spyService, times(<span class="number">1</span>)).sendWelcomeEmail(user); </span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-Mock（模拟对象）"><a href="#5-Mock（模拟对象）" class="headerlink" title="5. Mock（模拟对象）"></a>5. Mock（模拟对象）</h5><ul>
<li><strong>定义</strong>：一个能够<strong>预设期望</strong>并<strong>验证</strong>这些期望是否被满足的对象。它的核心是“行为验证”——我们用 Mock 来验证<strong>被测单元的行为</strong>是否符合预期（即是否正确地调用了依赖）。</li>
<li><strong>特点</strong>：测试代码会先对 Mock 对象设置期望（例如，<code>sendWelcomeEmail</code> 方法必须被调用一次），然后执行测试，最后向 Mock 对象请求验证这些期望是否都已满足。</li>
<li><strong>何时使用</strong>：当你需要验证的是一个<strong>没有明显返回值</strong>的交互时。例如，发送邮件、记录日志、写入数据库等操作，我们无法通过返回值来判断是否成功，只能通过验证“调用”这个行为本身是否发生来判断。</li>
</ul>
<hr>
<h5 id="6-核心区别：Stub-vs-Mock"><a href="#6-核心区别：Stub-vs-Mock" class="headerlink" title="6. 核心区别：Stub vs. Mock"></a>6. 核心区别：Stub vs. Mock</h5><p>这是最容易混淆的一对概念，但它们的关注点完全不同。</p>
<ul>
<li><p><strong>Stub (桩) -&gt; 用于状态验证 (State Verification)</strong></p>
<ul>
<li><p><strong>目的</strong>：提供数据，驱动被测对象。</p>
</li>
<li><p><strong>测试关注点</strong>：被测对象在执行完毕后的<strong>状态</strong>是否正确。</p>
</li>
<li><p><strong>伪代码</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 1. 准备：设置 Stub 返回 &#x27;true&#x27;</span><br><span class="line">// 2. 执行：调用 orderService.placeOrder()</span><br><span class="line">// 3. 断言：assert(order.getStatus() == &#x27;PAID&#x27;)  &lt;-- 检查被测对象的状态</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Mock (模拟对象) -&gt; 用于行为验证 (Behavior Verification)</strong></p>
<ul>
<li><p><strong>目的</strong>：验证被测对象是否与依赖进行了正确的交互。</p>
</li>
<li><p><strong>测试关注点</strong>：依赖项的<strong>方法是否被以预期的方式调用</strong>（正确的参数、正确的次数）。</p>
</li>
<li><p><strong>伪代码</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 1. 准备：设置 Mock 期望 charge() 方法被调用一次</span><br><span class="line">// 2. 执行：调用 orderService.placeOrder()</span><br><span class="line">// 3. 断言：mockPaymentGateway.verify()  &lt;-- 检查 Mock 自身，看交互是否符合期望</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>在现代框架（如 Mockito）中</strong>，这种区别变得模糊，因为同一个由 <code>Mockito.mock()</code> 创建的对象既可以用来做 Stubbing（用 <code>when().thenReturn()</code>），也可以用来做 Mocking&#x2F;Verification（用 <code>verify()</code>）。但理解其背后的理论差异，有助于你编写出意图更清晰的测试。</p>
<hr>
<h4 id="2-1-3-Mockito-框架：Java-Mock-的事实标准"><a href="#2-1-3-Mockito-框架：Java-Mock-的事实标准" class="headerlink" title="2.1.3 Mockito 框架：Java Mock 的事实标准"></a>2.1.3 Mockito 框架：Java Mock 的事实标准</h4><p>Mockito 是 Java 社区最流行、功能最强大的 Mocking 框架。它通过简洁流畅的 API，让我们能够轻松地创建和配置测试替身（Mocks, Stubs, Spies），从而将我们的测试单元从其依赖项中彻底隔离出来。</p>
<h5 id="1-环境搭建：引入-Mockito-依赖"><a href="#1-环境搭建：引入-Mockito-依赖" class="headerlink" title="1. 环境搭建：引入 Mockito 依赖"></a>1. 环境搭建：引入 Mockito 依赖</h5><p>为了在项目中使用 Mockito，尤其是在 JUnit 5 环境下使用注解，你需要添加两个核心依赖。</p>
<ul>
<li><p><strong>如果使用 Maven</strong>，在 <code>pom.xml</code> 中添加：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Mockito 核心库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mockito<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mockito-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 建议使用最新稳定版 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mockito 与 JUnit 5 的集成库，支持 @Mock, @InjectMocks 等注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mockito<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mockito-junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>如果使用 Gradle</strong>，在 <code>build.gradle</code> 中添加：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testImplementation <span class="string">&#x27;org.mockito:mockito-core:5.12.0&#x27;</span></span><br><span class="line">testImplementation <span class="string">&#x27;org.mockito:mockito-junit-jupiter:5.12.0&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-核心三步：创建、打桩、验证"><a href="#2-核心三步：创建、打桩、验证" class="headerlink" title="2. 核心三步：创建、打桩、验证"></a>2. 核心三步：创建、打桩、验证</h5><p>掌握 Mockito 的使用，主要就是掌握以下三个核心步骤。我们继续使用之前的 <code>OrderService</code> 和 <code>PaymentGateway</code> 作为例子。</p>
<p>首先，为了让 <code>@Mock</code> 等注解生效，需要在测试类上添加 JUnit 5 的扩展注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.extension.ExtendWith;</span><br><span class="line"><span class="keyword">import</span> org.mockito.junit.jupiter.MockitoExtension;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExtendWith(MockitoExtension.class)</span> <span class="comment">// 激活 Mockito 注解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderServiceTest</span> &#123;</span><br><span class="line">    <span class="comment">// ... 测试代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>a. 创建 Mock 对象</strong></p>
<p>你有两种主要方式来创建 Mock 对象：</p>
<ul>
<li><p><strong>编程式：<code>Mockito.mock()</code></strong><br>在方法内部直接创建，比较灵活。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPlaceOrder_programmatic</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 手动创建 Mock</span></span><br><span class="line">    <span class="type">PaymentGateway</span> <span class="variable">mockGateway</span> <span class="operator">=</span> Mockito.mock(PaymentGateway.class);</span><br><span class="line">    <span class="type">OrderService</span> <span class="variable">orderService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderService</span>(mockGateway);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>声明式：<code>@Mock</code> 注解 (推荐)</strong><br>在测试类的字段上使用 <code>@Mock</code> 注解，代码更简洁，意图更清晰。Mockito 会在测试运行前自动为我们创建好 Mock 实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(MockitoExtension.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Mock</span> <span class="comment">// Mockito 会自动创建这个接口的 Mock 实现</span></span><br><span class="line">    <span class="keyword">private</span> PaymentGateway mockGateway;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>b. “打桩” (Stubbing)：<code>when(...).thenReturn(...)</code></strong></p>
<p>打桩就是为 Mock 对象的某个方法调用设定一个预期的返回值或行为。这是为被测单元提供“间接输入”的关键。</p>
<ul>
<li><p><strong>返回一个固定的值：<code>thenReturn()</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">should_setOrderStatusToPaid_when_paymentIsSuccessful</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Arrange (准备)</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(<span class="number">100.0</span>);</span><br><span class="line">    <span class="comment">// Stubbing: 当 mockGateway 的 charge 方法被调用时，返回一个成功的 PaymentResult</span></span><br><span class="line">    <span class="keyword">when</span>(mockGateway.charge(<span class="number">100.0</span>, <span class="string">&quot;valid_card&quot;</span>))</span><br><span class="line">        .thenReturn(<span class="keyword">new</span> <span class="title class_">PaymentResult</span>(<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">OrderService</span> <span class="variable">orderService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderService</span>(mockGateway);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Act (执行)</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">resultOrder</span> <span class="operator">=</span> orderService.placeOrder(order, <span class="string">&quot;valid_card&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Assert (断言)</span></span><br><span class="line">    assertEquals(OrderStatus.PAID, resultOrder.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>抛出一个异常：<code>thenThrow()</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">should_throwException_when_paymentGatewayIsDown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Stubbing: 当 charge 方法被调用时，抛出一个 RuntimeException</span></span><br><span class="line">    <span class="keyword">when</span>(mockGateway.charge(anyDouble(), anyString()))</span><br><span class="line">        .thenThrow(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Payment Gateway is down&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">OrderService</span> <span class="variable">orderService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderService</span>(mockGateway);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assert: 验证调用 placeOrder 会抛出指定的异常</span></span><br><span class="line">    assertThrows(RuntimeException.class, () -&gt; &#123;</span><br><span class="line">        orderService.placeOrder(<span class="keyword">new</span> <span class="title class_">Order</span>(<span class="number">50.0</span>), <span class="string">&quot;any_card&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>处理 void 方法：<code>doThrow(...).when(...)</code> &#x2F; <code>doNothing()</code></strong><br>对于没有返回值 (<code>void</code>) 的方法，语法稍有不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有一个 void 方法</span></span><br><span class="line"><span class="comment">// doThrow(new IOException()).when(mockWriter).write(anyString());</span></span><br><span class="line"><span class="comment">// doNothing().when(mockWriter).close(); // 确保调用 close 时什么都不做</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>c. 行为验证 (Verification)：<code>verify(...)</code></strong></p>
<p>验证是检查被测代码是否与依赖项进行了正确的<strong>交互</strong>。这是测试那些没有明显返回值的方法（如发送邮件、记录日志）的关键。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">should_callChargeMethod_when_placingOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Arrange</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(<span class="number">100.0</span>);</span><br><span class="line">    <span class="keyword">when</span>(mockGateway.charge(anyDouble(), anyString())).thenReturn(<span class="keyword">new</span> <span class="title class_">PaymentResult</span>(<span class="literal">true</span>));</span><br><span class="line">    <span class="type">OrderService</span> <span class="variable">orderService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderService</span>(mockGateway);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Act</span></span><br><span class="line">    orderService.placeOrder(order, <span class="string">&quot;valid_card&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Verify (验证)</span></span><br><span class="line">    <span class="comment">// 验证 mockGateway 的 charge 方法是否被以 100.0 和 &quot;valid_card&quot; 为参数调用了 1 次</span></span><br><span class="line">    verify(mockGateway, times(<span class="number">1</span>)).charge(<span class="number">100.0</span>, <span class="string">&quot;valid_card&quot;</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更多验证方式</span></span><br><span class="line">    <span class="comment">// verify(mockGateway, never()).someOtherMethod(); // 验证从未被调用</span></span><br><span class="line">    <span class="comment">// verify(mockGateway, atLeast(1)).charge(anyDouble(), anyString()); // 验证至少被调用1次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-InjectMocks-自动注入-Mock-对象"><a href="#3-InjectMocks-自动注入-Mock-对象" class="headerlink" title="3. @InjectMocks: 自动注入 Mock 对象"></a>3. <code>@InjectMocks</code>: 自动注入 Mock 对象</h5><p><code>@InjectMocks</code> 是一个极其方便的注解，它能自动创建被测类的实例，并<strong>将类中声明的 <code>@Mock</code> 或 <code>@Spy</code> 对象注入进去</strong>。这极大地减少了测试的准备代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(MockitoExtension.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span> <span class="comment">// 1. 创建 Mock 依赖</span></span><br><span class="line">    <span class="keyword">private</span> PaymentGateway mockGateway;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InjectMocks</span> <span class="comment">// 2. 创建 OrderService 实例, 并自动注入 mockGateway</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testPlaceOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Arrange</span></span><br><span class="line">        <span class="comment">// orderService 已经准备好了，可以直接使用</span></span><br><span class="line">        <span class="keyword">when</span>(mockGateway.charge(anyDouble(), anyString())).thenReturn(<span class="keyword">new</span> <span class="title class_">PaymentResult</span>(<span class="literal">true</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Act &amp; Assert</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>@InjectMocks</code> 后，你不再需要手动 <code>new OrderService(mockGateway)</code>。</p>
<hr>
<h5 id="4-参数匹配器-Argument-Matchers"><a href="#4-参数匹配器-Argument-Matchers" class="headerlink" title="4. 参数匹配器 (Argument Matchers)"></a>4. 参数匹配器 (Argument Matchers)</h5><p>当你打桩或验证时，如果不在乎方法的具体参数值，或者无法预测参数值，就可以使用参数匹配器。</p>
<ul>
<li><strong>常用匹配器</strong>：<code>any()</code>, <code>any(Class.class)</code>, <code>anyString()</code>, <code>anyInt()</code>, <code>anyBoolean()</code>, <code>anyList()</code> 等。</li>
<li><strong><code>eq()</code></strong>: 当你需要混合使用匹配器和具体值时，必须用 <code>eq()</code> 来包装具体值。</li>
</ul>
<p><strong>黄金法则</strong>：<strong>只要有一个参数使用了匹配器，所有参数都必须使用匹配器。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确: 混合使用匹配器和具体值，用 eq() 包装</span></span><br><span class="line"><span class="keyword">when</span>(mockGateway.charge(anyDouble(), eq(<span class="string">&quot;master_card&quot;</span>)))</span><br><span class="line">    .thenReturn(<span class="keyword">new</span> <span class="title class_">PaymentResult</span>(<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误: 不能混合原始值和匹配器</span></span><br><span class="line"><span class="comment">// when(mockGateway.charge(anyDouble(), &quot;master_card&quot;)) -&gt; 编译不通过或运行时报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确: 所有参数都用匹配器</span></span><br><span class="line">verify(mockGateway).charge(anyDouble(), anyString());</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-Spying：部分-Mock-真实对象-Spy-注解"><a href="#5-Spying：部分-Mock-真实对象-Spy-注解" class="headerlink" title="5. Spying：部分 Mock 真实对象 (@Spy 注解)"></a>5. Spying：部分 Mock 真实对象 (<code>@Spy</code> 注解)</h5><p>Spy（间谍）包装一个真实的对象。默认情况下，调用 Spy 对象的方法会执行真实对象的逻辑。但你也可以选择性地对某些方法进行打桩。</p>
<ul>
<li><strong>何时使用</strong>：主要用于遗留代码，当你无法轻易地将一个大类拆分成可测试的小单元时，可以使用 Spy 来测试其中一个方法，同时又想保留其他方法的真实行为。<strong>在新代码中应谨慎使用，它可能意味着设计有待改进。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(MockitoExtension.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpyExampleTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Spy</span> <span class="comment">// 创建一个基于真实 ArrayList 的 Spy</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSpy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用真实方法</span></span><br><span class="line">        list.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 验证真实方法的调用</span></span><br><span class="line">        verify(list).add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">        assertEquals(<span class="number">2</span>, list.size()); <span class="comment">// list.size() 也是真实调用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对 Spy 的某个方法进行打桩</span></span><br><span class="line">        <span class="comment">// **注意：对 Spy 打桩必须用 doReturn/doThrow 语法！**</span></span><br><span class="line">        doReturn(<span class="number">100</span>).<span class="keyword">when</span>(list).size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次调用，此时返回的是桩数据</span></span><br><span class="line">        assertEquals(<span class="number">100</span>, list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：对 Spy 对象打桩时，使用 <code>when(spy.someMethod()).thenReturn(...)</code> 会实际调用 <code>someMethod</code>，可能导致非预期的副作用。因此，<strong>必须使用 <code>doReturn(value).when(spy).someMethod()</code> 的语法</strong>。</p>
<hr>
<h3 id="2-2-提升测试覆盖率与质量"><a href="#2-2-提升测试覆盖率与质量" class="headerlink" title="2.2 提升测试覆盖率与质量"></a>2.2 提升测试覆盖率与质量</h3><h4 id="2-2-1-代码覆盖率-Code-Coverage"><a href="#2-2-1-代码覆盖率-Code-Coverage" class="headerlink" title="2.2.1 代码覆盖率 (Code Coverage)"></a>2.2.1 代码覆盖率 (Code Coverage)</h4><p>代码覆盖率是一个度量指标，用于描述在一个特定的测试运行中，你的<strong>生产代码（Production Code）有多大比例被执行过</strong>。它能直观地告诉你，你的测试用例“触及”了代码库的哪些部分，又“遗漏”了哪些部分。</p>
<h5 id="1-什么是覆盖率？-行、分支、方法覆盖率"><a href="#1-什么是覆盖率？-行、分支、方法覆盖率" class="headerlink" title="1. 什么是覆盖率？(行、分支、方法覆盖率)"></a>1. 什么是覆盖率？(行、分支、方法覆盖率)</h5><p>代码覆盖率通常不是一个单一的数字，而是由多个不同粒度的指标组成。理解它们的区别至关重要。</p>
<ul>
<li><p><strong>行覆盖率 (Line Coverage)</strong></p>
<ul>
<li><p><strong>定义</strong>：这是最直观的指标，表示在测试中<strong>被执行过的代码行数</strong>占总代码行数的百分比。</p>
</li>
<li><p><strong>优点</strong>：简单易懂。</p>
</li>
<li><p><strong>缺点</strong>：非常粗糙。一行代码可能包含多个逻辑分支，即使该行被覆盖，也无法保证所有逻辑都已测试。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getGrade</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> score &gt;= <span class="number">60</span> ? <span class="string">&quot;Pass&quot;</span> : <span class="string">&quot;Fail&quot;</span>; <span class="comment">// 1行代码，但有2个逻辑分支</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个测试用例 <code>getGrade(70)</code> 会让这行代码的行覆盖率达到100%，但 <code>&quot;Fail&quot;</code> 这个分支的逻辑完全没有被测试到。</p>
</li>
</ul>
</li>
<li><p><strong>分支&#x2F;决策覆盖率 (Branch&#x2F;Decision Coverage)</strong></p>
<ul>
<li><strong>定义</strong>：衡量代码中<strong>所有逻辑分支</strong>（如 <code>if/else</code>, <code>switch</code>, <code>while</code> 循环中的条件判断）被执行的比例。对于每个条件判断，它的 <code>true</code> 和 <code>false</code> 两种情况是否都至少被执行过一次。</li>
<li><strong>优点</strong>：比行覆盖率更严格、更有价值。100%的分支覆盖率通常意味着100%的行覆盖率（反之则不成立）。</li>
<li><strong>缺点</strong>：仍然无法覆盖所有条件的组合情况（这由更复杂的“条件覆盖率”来衡量）。</li>
<li><strong>示例</strong>（接上例）：要达到 <code>getGrade</code> 方法100%的分支覆盖率，你需要至少两个测试用例：<ul>
<li>一个 <code>score &gt;= 60</code> 的情况，如 <code>getGrade(70)</code>，覆盖 <code>true</code> 分支。</li>
<li>一个 <code>score &lt; 60</code> 的情况，如 <code>getGrade(50)</code>，覆盖 <code>false</code> 分支。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>方法&#x2F;函数覆盖率 (Method&#x2F;Function Coverage)</strong></p>
<ul>
<li><strong>定义</strong>：衡量在测试中<strong>被调用过的方法</strong>占总方法数的百分比。</li>
<li><strong>优点</strong>：提供一个非常宏观的视角。</li>
<li><strong>缺点</strong>：这是最弱的覆盖率指标。一个方法可能被调用了，但其内部复杂的逻辑可能完全没被测试到。通常只作为参考。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>JaCoCo 报告中的其他指标</strong>：</p>
<ul>
<li><strong>指令覆盖率 (Instruction Coverage)</strong>：衡量被执行的Java字节码指令的比例。这是 JaCoCo 内部最核心的指标，比行覆盖率更精细。</li>
<li><strong>圈复杂度 (Cyclomatic Complexity)</strong>：衡量一个方法有多少独立的执行路径，用来评估代码的复杂性。覆盖率报告会显示测试覆盖了多少条路径。</li>
</ul>
</blockquote>
<hr>
<h5 id="2-如何看待覆盖率指标？-它不是银弹"><a href="#2-如何看待覆盖率指标？-它不是银弹" class="headerlink" title="2. 如何看待覆盖率指标？(它不是银弹)"></a>2. 如何看待覆盖率指标？(它不是银弹)</h5><p>这是一个至关重要的问题。错误地理解和使用覆盖率指标，带来的危害可能比帮助更大。</p>
<p><strong>代码覆盖率的真正价值：</strong></p>
<ul>
<li><strong>发现未经测试的代码</strong>：这是覆盖率<strong>最核心、最无可争议的价值</strong>。低覆盖率（例如低于50%）是一个强烈的危险信号，明确地告诉你代码库的大部分区域都是测试的“盲区”。覆盖率报告是寻找这些盲区的最佳工具。</li>
<li><strong>作为一种趋势指标</strong>：监控覆盖率的变化趋势可以反映项目的健康状况。如果覆盖率持续下降，可能意味着团队在添加新功能时忽略了编写测试。</li>
<li><strong>作为CI&#x2F;CD的质量门禁</strong>：可以在持续集成流水线中设置一个“最低覆盖率阈值”。例如，“如果一次代码提交导致项目整体覆盖率低于80%，则构建失败”。这能强制推行测试文化。</li>
</ul>
<p><strong>代码覆盖率的陷阱与误区（“不是银弹”的原因）：</strong></p>
<ul>
<li><p><strong>100% 覆盖率 ≠ 100% 没有 Bug</strong>：一个测试可以<strong>执行</strong>一行代码，但<strong>没有验证</strong>这行代码的行为是否正确。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">uselessTestWithHighCoverage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">    calculator.add(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 这行代码被执行了，覆盖率增加了</span></span><br><span class="line">    <span class="comment">// 但是……没有断言！(No Assertions)</span></span><br><span class="line">    <span class="comment">// 这个测试毫无意义，但它贡献了覆盖率。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>“为覆盖率而测试”的陷阱</strong>：如果将覆盖率作为唯一的KPI（关键绩效指标），开发者可能会为了达标而编写大量像上面那样的“垃圾测试”，只求执行代码，不求验证逻辑。这会产生一种<strong>虚假的安全感</strong>，比没有测试更糟糕。</p>
</li>
<li><p><strong>边际效益递减</strong>：将覆盖率从80%提升到90%可能很有价值，但从95%提升到100%的成本可能极高。为了覆盖那些极其罕见的异常分支或简单的getter&#x2F;setter方法，可能需要付出不成比例的努力。</p>
</li>
</ul>
<p><strong>最佳实践：</strong></p>
<ul>
<li>将覆盖率<strong>视为一个指南，而不是一个僵化的目标</strong>。</li>
<li><strong>优先关注核心业务逻辑和复杂算法</strong>的覆盖率。</li>
<li><strong>结合代码审查 (Code Review)</strong> 来保证测试的<strong>质量</strong>，而不仅仅是<strong>数量</strong>。</li>
<li>设定一个<strong>合理、务实</strong>的团队目标（例如，80%-85%的分支覆盖率），并将其作为质量门禁，而不是个人绩效考核的工具。</li>
</ul>
<hr>
<h5 id="3-工具集成：使用-JaCoCo-生成覆盖率报告"><a href="#3-工具集成：使用-JaCoCo-生成覆盖率报告" class="headerlink" title="3. 工具集成：使用 JaCoCo 生成覆盖率报告"></a>3. 工具集成：使用 JaCoCo 生成覆盖率报告</h5><p><strong>JaCoCo (Java Code Coverage)</strong> 是目前Java生态中最主流的代码覆盖率工具。它通过在运行时动态地“插桩”（Instrument）Java字节码来收集覆盖率数据。</p>
<p><strong>Maven 集成</strong></p>
<p>在 <code>pom.xml</code> 的 <code>&lt;build&gt;&lt;plugins&gt;</code> 部分添加 <code>jacoco-maven-plugin</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jacoco<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jacoco-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.8.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 使用最新稳定版 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>prepare-agent<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>prepare-agent<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>report<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>test<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>report<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 可选：添加覆盖率检查，作为质量门禁 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>check<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>check<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">rules</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">element</span>&gt;</span>BUNDLE<span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">limits</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">limit</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">counter</span>&gt;</span>BRANCH<span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">value</span>&gt;</span>COVEREDRATIO<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">minimum</span>&gt;</span>0.80<span class="tag">&lt;/<span class="name">minimum</span>&gt;</span> <span class="comment">&lt;!-- 要求分支覆盖率不低于80% --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">limit</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">limits</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">rules</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如何运行</strong>：只需正常执行Maven的测试命令即可：<code>mvn clean test</code> 或 <code>mvn clean verify</code>。</li>
<li><strong>查看报告</strong>：执行完毕后，JaCoCo会生成一个精美的HTML报告。在项目目录下找到 <code>target/site/jacoco/index.html</code>，用浏览器打开即可。报告会用红&#x2F;黄&#x2F;绿三种颜色高亮代码，让你一目了然地看到未被覆盖的行和分支。</li>
</ul>
<p><strong>Gradle 集成</strong></p>
<p>在 <code>build.gradle</code> 文件中应用 JaCoCo 插件并进行配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;jacoco&#x27;</span> <span class="comment">// 1. 应用 JaCoCo 插件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 配置 JaCoCo 任务</span></span><br><span class="line">jacoco &#123;</span><br><span class="line">    toolVersion = <span class="string">&quot;0.8.12&quot;</span> <span class="comment">// 指定 JaCoCo 版本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    finalizedBy jacocoTestReport <span class="comment">// 3. 确保 test 任务执行后，自动执行 jacocoTestReport</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jacocoTestReport &#123;</span><br><span class="line">    dependsOn test <span class="comment">// 确保报告生成前，测试已执行</span></span><br><span class="line">    reports &#123;</span><br><span class="line">        xml.required = <span class="literal">true</span></span><br><span class="line">        html.required = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 可选：配置覆盖率检查</span></span><br><span class="line">jacocoTestCoverageVerification &#123;</span><br><span class="line">    violationRules &#123;</span><br><span class="line">        rule &#123;</span><br><span class="line">            element = <span class="string">&#x27;BUNDLE&#x27;</span></span><br><span class="line">            limit &#123;</span><br><span class="line">                counter = <span class="string">&#x27;BRANCH&#x27;</span></span><br><span class="line">                value = <span class="string">&#x27;COVEREDRATIO&#x27;</span></span><br><span class="line">                minimum = <span class="number">0.80</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check.dependsOn jacocoTestCoverageVerification <span class="comment">// 让 &#x27;check&#x27; 任务依赖覆盖率检查</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如何运行</strong>：执行 <code>test</code> 和 <code>jacocoTestReport</code> 任务：<code>./gradlew test jacocoTestReport</code>。如果要触发检查，执行 <code>./gradlew check</code>。</li>
<li><strong>查看报告</strong>：报告位于 <code>build/reports/jacoco/test/html/index.html</code>。</li>
</ul>
<hr>
<h4 id="2-2-2-编写高质量测试的最佳实践"><a href="#2-2-2-编写高质量测试的最佳实践" class="headerlink" title="2.2.2 编写高质量测试的最佳实践"></a>2.2.2 编写高质量测试的最佳实践</h4><p>仅仅让测试通过是不够的。测试代码本身也是代码，它需要像生产代码一样被精心设计、编写和维护。一套混乱、脆弱、难以理解的测试集，其维护成本甚至可能超过它带来的价值。</p>
<p>遵循以下行业公认的最佳实践，可以帮助我们编写出清晰、健壮且易于维护的高质量单元测试。</p>
<h5 id="1-AAA-模式：Arrange-Act-Assert"><a href="#1-AAA-模式：Arrange-Act-Assert" class="headerlink" title="1. AAA 模式：Arrange, Act, Assert"></a>1. AAA 模式：Arrange, Act, Assert</h5><p>AAA 模式是组织测试方法内部结构的一个黄金标准，它将测试逻辑清晰地划分为三个部分。</p>
<ul>
<li><strong>Arrange (准备)</strong>：准备测试所需的一切。这包括：<ul>
<li>创建被测对象（Class Under Test, CUT）的实例。</li>
<li>创建 Mock 对象。</li>
<li>设置 Mock 对象的行为（“打桩”）。</li>
<li>准备输入数据和期望的输出结果。</li>
</ul>
</li>
<li><strong>Act (执行)</strong>：调用<strong>一个</strong>被测方法。这是测试的核心动作，也是你真正想要验证的行为。在 Act 部分，通常只有一行代码。</li>
<li><strong>Assert (断言)</strong>：验证 Act 步骤的结果是否符合你在 Arrange 阶段的预期。这可能包括：<ul>
<li>检查方法的返回值。</li>
<li>检查被测对象的状态是否发生了预期的变化。</li>
<li>验证 Mock 对象的方法是否被正确地调用（行为验证）。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">should_returnCorrectSum_when_addingTwoNumbers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Arrange (准备)</span></span><br><span class="line">    <span class="comment">// - 创建被测对象</span></span><br><span class="line">    <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>(); </span><br><span class="line">    <span class="comment">// - 准备输入和期望输出</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedSum</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Act (执行)</span></span><br><span class="line">    <span class="comment">// - 调用被测方法</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">actualSum</span> <span class="operator">=</span> calculator.add(a, b); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assert (断言)</span></span><br><span class="line">    <span class="comment">// - 验证结果</span></span><br><span class="line">    assertEquals(expectedSum, actualSum); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么 AAA 如此重要？</strong></p>
<p>它极大地增强了测试的<strong>可读性</strong>。任何阅读此测试的人都可以立即识别出测试的设置、执行的动作以及验证的条件，无需费力去理解混杂在一起的逻辑。</p>
<hr>
<h5 id="2-FIRST-原则"><a href="#2-FIRST-原则" class="headerlink" title="2. FIRST 原则"></a>2. FIRST 原则</h5><p>FIRST 是高质量单元测试应该具备的一组特性的缩写。</p>
<ul>
<li><strong>F - Fast (快速)</strong><br>单元测试应该运行得非常快（毫秒级）。一个缓慢的测试套件会成为开发的瓶颈，因为开发者会因为等待时间过长而不愿意频繁运行它，从而失去了快速反馈的价值。这也是为什么单元测试必须隔离外部依赖（如数据库、网络）的核心原因。</li>
<li><strong>I - Independent&#x2F;Isolated (独立&#x2F;隔离)</strong><br>每个测试都应该是独立的，不依赖于其他任何测试。它们的执行顺序不应该影响测试结果。你不应该在一个测试中创建的数据，期望在另一个测试中使用。<ul>
<li><strong>实践</strong>：使用 <code>@BeforeEach</code> 来为每个测试创建全新的、干净的测试环境。</li>
</ul>
</li>
<li><strong>R - Repeatable (可重复)</strong><br>一个测试在任何环境（你的本地机器、同事的机器、CI&#x2F;CD服务器）、任何时间运行，都应该产生相同的结果。<ul>
<li><strong>反模式</strong>：测试代码依赖于不确定因素，如系统当前时间 (<code>new Date()</code>)、随机数、外部环境的特定配置等。这些都应该通过 Mock 或固定的测试数据来控制。</li>
</ul>
</li>
<li><strong>S - Self-Validating (自我验证)</strong><br>测试的输出应该是明确的布尔值：<strong>通过</strong>或<strong>失败</strong>。测试运行后，不需要任何人工检查（如查看日志、检查数据库）来判断结果是否正确。<ul>
<li><strong>实践</strong>：每个测试都必须包含断言（Assertions）。没有断言的测试是无效的。</li>
</ul>
</li>
<li><strong>T - Timely (及时)</strong><br>测试代码应该与生产代码一同编写，或者最好是在生产代码之前编写（即测试驱动开发，TDD）。如果等到功能开发完成后很久才去“补”测试，你可能会发现代码设计得难以测试，从而导致重构成本高昂，或者干脆放弃测试。</li>
</ul>
<hr>
<h5 id="3-测试命名规范：should-期望行为-when-给定条件"><a href="#3-测试命名规范：should-期望行为-when-给定条件" class="headerlink" title="3. 测试命名规范：should_期望行为_when_给定条件"></a>3. 测试命名规范：<code>should_期望行为_when_给定条件</code></h5><p>一个好的测试方法名本身就是一句简短的需求文档。当测试失败时，光看名字就应该能大致猜到是哪个功能点出了问题。</p>
<p><strong>推荐的命名格式</strong>：<code>should_ExpectedBehavior_when_StateOrCondition</code></p>
<ul>
<li><code>should_</code>：描述预期的行为或结果。</li>
<li><code>when_</code>：描述测试发生的条件或状态。</li>
</ul>
<p><strong>示例对比：</strong></p>
<ul>
<li><strong>不好的命名</strong><ul>
<li><code>test1()</code></li>
<li><code>add()</code></li>
<li><code>testAddWithNegative()</code></li>
</ul>
</li>
<li><strong>好的命名</strong><ul>
<li><code>should_returnPositiveNumber_when_addingTwoPositiveNumbers</code></li>
<li><code>should_throwIllegalArgumentException_when_divisorIsZero</code></li>
<li><code>should_setOrderStatusToPaid_when_paymentIsSuccessful</code></li>
</ul>
</li>
</ul>
<p>当 <code>should_throwIllegalArgumentException_when_divisorIsZero</code> 这个测试失败时，你立刻就知道是“除数为零时抛出异常”这个逻辑分支坏了。</p>
<hr>
<h5 id="4-保持测试的简洁与专注：一个测试只测一个点"><a href="#4-保持测试的简洁与专注：一个测试只测一个点" class="headerlink" title="4. 保持测试的简洁与专注：一个测试只测一个点"></a>4. 保持测试的简洁与专注：一个测试只测一个点</h5><p>每个测试方法应该只验证一个独立的逻辑概念或行为分支。</p>
<p><strong>为什么？</strong></p>
<ul>
<li><strong>清晰性</strong>：测试的意图一目了然。</li>
<li><strong>精确的失败报告</strong>：当测试失败时，你能精确地知道是哪个具体的行为不符合预期。如果一个测试包含了多个断言来验证多个不相关的点，一旦其中一个失败，你可能不知道是哪个或哪几个点出了问题。</li>
</ul>
<p><strong>示例：用户注册</strong></p>
<p>假设 <code>registerUser</code> 方法有多个逻辑分支：成功、用户名已存在、邮箱格式错误。</p>
<ul>
<li><p><strong>不好的实践：一个测试测所有事</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUserRegistration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 测试成功场景...</span></span><br><span class="line">    assertEquals(Status.SUCCESS, service.register(<span class="string">&quot;newUser&quot;</span>, <span class="string">&quot;pwd&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试用户名重复场景...</span></span><br><span class="line">    assertThrows(DuplicateUserException.class, () -&gt; &#123;</span><br><span class="line">        service.register(<span class="string">&quot;newUser&quot;</span>, <span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试邮箱格式错误场景... (假设有另一个方法)</span></span><br><span class="line">    assertThrows(InvalidEmailException.class, () -&gt; &#123;</span><br><span class="line">        service.validateEmail(<span class="string">&quot;bad-email&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个测试过于臃肿，意图模糊。一旦失败，难以定位根本原因。</p>
</li>
<li><p><strong>好的实践：拆分成多个专注的测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">should_createUserSuccessfully_when_providingValidInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... Arrange, Act, Assert for success case ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">should_throwDuplicateUserException_when_usernameAlreadyExists</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... Arrange, Act, Assert for duplicate username case ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">should_throwInvalidEmailException_when_emailFormatIsIncorrect</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... Arrange, Act, Assert for invalid email case ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个测试都小巧、专注、命名清晰。这才是高质量的测试套件。</p>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>：一个测试只测一个“点”，不等于一个测试只能有一个“断言”。如果这些断言都是为了验证<strong>同一个行为的结果</strong>，那么将它们放在一起是合理的，尤其推荐使用 <code>assertAll()</code> 来确保所有断言都被执行。</p>
</blockquote>
<hr>
<h4 id="2-2-3-高级测试场景"><a href="#2-2-3-高级测试场景" class="headerlink" title="2.2.3 高级测试场景"></a>2.2.3 高级测试场景</h4><p>当掌握了单元测试的基础后，你会遇到一些场景，用基本的 <code>@Test</code> 写法会显得笨拙或重复。JUnit 5 提供了一些高级特性来优雅地解决这些问题。</p>
<h5 id="1-参数化测试-ParameterizedTest-用不同数据多次运行同一测试"><a href="#1-参数化测试-ParameterizedTest-用不同数据多次运行同一测试" class="headerlink" title="1. 参数化测试 (@ParameterizedTest): 用不同数据多次运行同一测试"></a>1. 参数化测试 (<code>@ParameterizedTest</code>): 用不同数据多次运行同一测试</h5><p><strong>问题场景</strong>：你需要用多组不同的输入和期望输出来测试同一个方法，特别是为了覆盖边界条件。例如，测试一个验证邮箱格式的方法，你需要用合法的、非法的、空的、<code>null</code> 的等多种数据来测试。</p>
<p>如果用普通 <code>@Test</code>，你可能需要写很多个几乎一模一样的测试方法，这违反了 DRY (Don’t Repeat Yourself) 原则。</p>
<p><strong>解决方案</strong>：使用 <code>@ParameterizedTest</code>，它允许你将测试逻辑与测试数据分离。</p>
<p><strong>如何使用：</strong></p>
<ol>
<li>用 <code>@ParameterizedTest</code> 替代 <code>@Test</code>。</li>
<li>使用一个“数据源”注解来提供测试数据，如 <code>@ValueSource</code>, <code>@CsvSource</code>, <code>@MethodSource</code> 等。</li>
</ol>
<p><strong>示例：测试一个 <code>StringUtils.isBlank()</code> 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringUtilsTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个参数化测试会运行 4 次，每次使用一行 CSV 数据</span></span><br><span class="line">    <span class="meta">@ParameterizedTest</span></span><br><span class="line">    <span class="meta">@CsvSource(&#123;</span></span><br><span class="line"><span class="meta">        &quot;&#x27;&#x27;   , true&quot;,   // 空字符串，期望为 true</span></span><br><span class="line"><span class="meta">        &quot;&#x27; &#x27;  , true&quot;,   // 只包含空格的字符串，期望为 true</span></span><br><span class="line"><span class="meta">        &quot;abc  , false&quot;,  // 普通字符串，期望为 false</span></span><br><span class="line"><span class="meta">        &quot;null , true&quot;    // 使用 &#x27;null&#x27; 字符串代表 null 值</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">should_correctlyDetermineIfStringIsBlank</span><span class="params">(String input, <span class="type">boolean</span> expected)</span> &#123;</span><br><span class="line">        <span class="comment">// 当 CSV 源中的值为 &#x27;null&#x27; 时，JUnit 会自动将其转换成 null 对象</span></span><br><span class="line">        assertEquals(expected, StringUtils.isBlank(input));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>@CsvSource</code></strong>：一个非常方便的数据源，每一行 CSV 字符串就是一次测试的参数。</li>
<li><strong><code>@ValueSource</code></strong>：适用于只提供单个参数的简单场景。例如 <code>@ValueSource(strings = {&quot;racecar&quot;, &quot;madam&quot;, &quot;level&quot;})</code>。</li>
<li><strong><code>@MethodSource</code></strong>：最灵活的方式，允许你通过一个静态方法返回一个 <code>Stream</code> 对象来提供复杂的测试数据（如自定义对象）。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>代码简洁</strong>：用一个方法代替多个重复的测试方法。</li>
<li><strong>易于扩展</strong>：添加新的测试用例只需增加一行数据。</li>
<li><strong>意图清晰</strong>：将测试逻辑和边界数据清晰地分离开。</li>
</ul>
<hr>
<h5 id="2-嵌套测试-Nested-结构化地组织相关测试类"><a href="#2-嵌套测试-Nested-结构化地组织相关测试类" class="headerlink" title="2. 嵌套测试 (@Nested): 结构化地组织相关测试类"></a>2. 嵌套测试 (<code>@Nested</code>): 结构化地组织相关测试类</h5><p><strong>问题场景</strong>：当一个类的行为在不同状态（或上下文）下有显著差异时，你希望将针对同一状态的测试组织在一起，形成一个有逻辑的层次结构。例如，一个 <code>Stack</code> 对象在“空”和“非空”两种状态下的行为完全不同。</p>
<p><strong>解决方案</strong>：使用 <code>@Nested</code> 注解，它允许你在一个测试类内部创建非静态的内部类，每个内部类代表一个测试分组或上下文。</p>
<p><strong>如何使用：</strong></p>
<ol>
<li>在外部测试类中创建一个非静态的内部类。</li>
<li>为这个内部类添加 <code>@Nested</code> 注解。</li>
<li>在内部类中编写相关的 <code>@Test</code> 方法。</li>
</ol>
<p><strong>示例：测试一个 <code>java.util.Stack</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;A stack&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Object&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;is instantiated with new Stack()&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">isInstantiatedWithNew</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;when new&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WhenNew</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@BeforeEach</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">createNewStack</span><span class="params">()</span> &#123;</span><br><span class="line">            stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;is empty&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">            assertTrue(stack.isEmpty());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;throws EmptyStackException when popped&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">throwsExceptionWhenPopped</span><span class="params">()</span> &#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, () -&gt; stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;after pushing an element&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AfterPushing</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">anElement</span> <span class="operator">=</span> <span class="string">&quot;an element&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@BeforeEach</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">pushAnElement</span><span class="params">()</span> &#123;</span><br><span class="line">            stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">            stack.push(anElement);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;is no longer empty&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">isNotEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">            assertFalse(stack.isEmpty());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;returns the element when popped&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">returnElementWhenPopped</span><span class="params">()</span> &#123;</span><br><span class="line">            assertEquals(anElement, stack.pop());</span><br><span class="line">            assertTrue(stack.isEmpty());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：</p>
<ul>
<li><strong>结构清晰</strong>：测试报告会以树状结构展示，极大地增强了可读性。</li>
<li><strong>共享上下文</strong>：外部类的 <code>@BeforeEach</code> 会在内部类的 <code>@BeforeEach</code> 之前运行，可以用来建立共享的基线状态。</li>
<li><strong>更好地表达行为</strong>：通过 <code>DisplayName</code> 和嵌套结构，测试代码几乎可以像 BDD（行为驱动开发）的 Gherkin 脚本一样阅读。</li>
</ul>
<hr>
<h5 id="3-测试私有方法？-讨论"><a href="#3-测试私有方法？-讨论" class="headerlink" title="3. 测试私有方法？(讨论)"></a>3. 测试私有方法？(讨论)</h5><p>这是一个经典的、具有争议性的话题。</p>
<p><strong>核心原则：通常不直接测试私有方法。</strong></p>
<p><strong>为什么不应该直接测试私有方法？</strong></p>
<ol>
<li><strong>违反封装原则</strong>：单元测试应该关注一个类的<strong>公共契约（Public API）</strong>，即它的“行为”是什么，而不是它的“实现细节”是怎样的。私有方法是实现细节，它们随时可能被重构、内联或删除。</li>
<li><strong>导致测试脆弱</strong>：如果你的测试直接依赖于私有方法，那么任何对内部实现的重构（比如修改私有方法名或参数）都会破坏你的测试，即使这个类的公共行为完全没有改变。这违背了单元测试“保护重构”的核心价值。</li>
<li><strong>是“代码异味”（Code Smell）的信号</strong>：如果你觉得一个私有方法非常复杂，以至于需要为它单独编写测试，这通常是一个强烈的信号，表明这个私有方法承担了过多的职责。它可能是一个独立的逻辑单元，应该被<strong>提取到一个新的类中</strong>，并拥有自己的公共接口。然后你就可以为这个新类编写清晰、独立的单元测试。</li>
</ol>
<p><strong>正确的做法：通过公共方法间接测试</strong></p>
<p>私有方法的逻辑，最终总是会被一个或多个公共方法所调用。因此，我们应该通过测试这些公共方法，设计不同的输入和场景，来<strong>间接覆盖</strong>私有方法的逻辑分支。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPasswordStrong(password)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Password is not strong enough.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... 其他注册逻辑 ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有方法，是实现细节</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPasswordStrong</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password != <span class="literal">null</span> &amp;&amp; password.length() &gt;= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何测试 <code>isPasswordStrong</code>？</strong> 不要用反射去调用它！而是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">should_throwException_when_registeringWithWeakPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        <span class="comment">// 通过调用公共方法 register，来间接测试 isPasswordStrong 的逻辑</span></span><br><span class="line">        assertThrows(IllegalArgumentException.class, () -&gt; &#123;</span><br><span class="line">            service.register(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;weak&quot;</span>); <span class="comment">// &quot;weak&quot; 会让 isPasswordStrong 返回 false</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">should_registerSuccessfully_when_providingStrongPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        <span class="comment">// 同样通过公共方法，测试 isPasswordStrong 返回 true 的情况</span></span><br><span class="line">        assertDoesNotThrow(() -&gt; &#123;</span><br><span class="line">            service.register(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;strong-enough-password&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例外情况（The Pragmatic View）</strong></p>
<p>在极少数情况下，特别是在处理难以修改的<strong>遗留代码</strong>时，为了增加测试覆盖率以进行安全的重构，你可能不得不“打破规则”。这时可以考虑：</p>
<ul>
<li><strong>提升可见性</strong>：将 <code>private</code> 修改为 <code>package-private</code>（默认，无修饰符），这样测试类（只要在同一个包下）就可以直接访问它。这比反射要好。</li>
<li><strong>使用反射（最后的手段）</strong>：通过 Java 反射 API 强行调用私有方法。这应该被视为最后的手段，因为它非常脆弱且难以维护。一旦决定这样做，应该在测试代码中留下清晰的注释，说明为什么必须这样做，并计划在未来重构掉它。</li>
</ul>
<hr>
<h2 id="3-融入现代开发生态"><a href="#3-融入现代开发生态" class="headerlink" title="3. 融入现代开发生态"></a>3. 融入现代开发生态</h2><h3 id="3-1-Spring-Spring-Boot-应用测试"><a href="#3-1-Spring-Spring-Boot-应用测试" class="headerlink" title="3.1 Spring&#x2F;Spring Boot 应用测试"></a>3.1 Spring&#x2F;Spring Boot 应用测试</h3><h4 id="3-1-1-Spring-测试上下文-ExtendWith-SpringExtension-class"><a href="#3-1-1-Spring-测试上下文-ExtendWith-SpringExtension-class" class="headerlink" title="3.1.1 Spring 测试上下文 (@ExtendWith(SpringExtension.class))"></a>3.1.1 Spring 测试上下文 (<code>@ExtendWith(SpringExtension.class)</code>)</h4><h5 id="1-问题的根源：为什么普通的单元测试不够用？"><a href="#1-问题的根源：为什么普通的单元测试不够用？" class="headerlink" title="1. 问题的根源：为什么普通的单元测试不够用？"></a>1. 问题的根源：为什么普通的单元测试不够用？</h5><p>在之前的章节中，我们测试的都是普通的 Java 对象 (POJO)，我们可以通过 <code>new</code> 关键字来自由地创建它们。</p>
<p>然而，Spring 应用的核心是<strong>控制反转 (IoC) 容器</strong>，也就是 <code>ApplicationContext</code>。我们编写的业务类（如 <code>@Service</code>, <code>@Component</code>, <code>@Repository</code>）都不是孤立存在的，它们是作为 <strong>Beans</strong> 由 Spring 容器来创建、管理和装配的。这些 Beans 享受着 Spring 提供的各种“魔法”：</p>
<ul>
<li><strong>依赖注入 (DI)</strong>：通过 <code>@Autowired</code> 自动注入所依赖的其他 Beans。</li>
<li><strong>配置属性注入</strong>：通过 <code>@Value</code> 从 <code>application.properties</code> 文件中读取配置。</li>
<li><strong>AOP 切面</strong>：事务管理 (<code>@Transactional</code>)、安全控制 (<code>@PreAuthorize</code>) 等功能都是通过代理实现的。</li>
<li><strong>生命周期管理</strong>：<code>@PostConstruct</code> 等回调。</li>
</ul>
<p>如果我们像测试普通 POJO 那样，在测试代码里手动 <code>new MyService()</code>，那么得到的只是一个孤立的、未经 Spring 加工的普通对象。它的所有 <code>@Autowired</code> 字段都将是 <code>null</code>，<code>@Value</code> 注解不会生效，事务和AOP切面也不会被应用。这样的测试毫无意义。</p>
<hr>
<h5 id="2-解决方案：Spring-测试上下文-Spring-Test-Context"><a href="#2-解决方案：Spring-测试上下文-Spring-Test-Context" class="headerlink" title="2. 解决方案：Spring 测试上下文 (Spring Test Context)"></a>2. 解决方案：Spring 测试上下文 (Spring Test Context)</h5><p>为了解决这个问题，Spring 框架提供了一个强大的测试模块 (<code>spring-test</code>)。它的核心思想是：<strong>在运行 JUnit 测试时，启动一个专用于测试的 <code>ApplicationContext</code></strong>。</p>
<p>这个<strong>测试上下文 (Test Context)</strong> 就是一个微型的、在你测试期间运行的 Spring IoC 容器。它会像真实应用一样，负责扫描组件、创建 Beans、处理依赖注入和应用 AOP。</p>
<p>这样，在测试代码中，我们就可以直接从这个测试上下文中获取到<strong>完全初始化好的、功能完备的 Bean</strong>，并对它进行测试。</p>
<hr>
<h5 id="3-ExtendWith-SpringExtension-class-：连接-JUnit-5-与-Spring-的桥梁"><a href="#3-ExtendWith-SpringExtension-class-：连接-JUnit-5-与-Spring-的桥梁" class="headerlink" title="3. @ExtendWith(SpringExtension.class)：连接 JUnit 5 与 Spring 的桥梁"></a>3. <code>@ExtendWith(SpringExtension.class)</code>：连接 JUnit 5 与 Spring 的桥梁</h5><p><code>@ExtendWith</code> 是 JUnit 5 的核心扩展机制。它告诉 JUnit 5：“在运行这个测试类时，请使用指定的扩展来增强你的功能。”</p>
<p><code>SpringExtension.class</code> (来自于 <code>spring-test</code> 模块) 就是 Spring 为 JUnit 5 提供的官方扩展。</p>
<p><strong>它的核心职责就是：</strong></p>
<blockquote>
<p><strong>管理 Spring Test Context 的生命周期。</strong> 这包括在合适的时机创建、配置、缓存以及关闭 <code>ApplicationContext</code>。</p>
</blockquote>
<p><strong>简而言之：</strong></p>
<blockquote>
<p><strong><code>@ExtendWith(SpringExtension.class)</code> 是开启 Spring 测试功能的“总开关”。</strong></p>
</blockquote>
<p>一旦你在测试类上添加了这个注解，JUnit 5 在执行测试时就会将控制权部分交给 <code>SpringExtension</code>，从而让 Spring 的“魔法”能够在测试环境中生效。</p>
<blockquote>
<p><strong>历史注记</strong>：在 JUnit 4 中，对应的注解是 <code>@RunWith(SpringRunner.class)</code>。它们的作用是相同的，只是适应了不同版本的 JUnit。</p>
</blockquote>
<hr>
<h5 id="4-工作流程与示例"><a href="#4-工作流程与示例" class="headerlink" title="4. 工作流程与示例"></a>4. 工作流程与示例</h5><p>让我们看一个最简单的例子，它展示了整个流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们的业务 Bean</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.greeting&#125;&quot;)</span> <span class="comment">// 假设 application.properties 中有 app.greeting=Hello</span></span><br><span class="line">    <span class="keyword">private</span> String greeting;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGreeting</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们的测试类</span></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span> <span class="comment">// 1. 开启 Spring 测试功能</span></span><br><span class="line"><span class="meta">@SpringBootTest</span> <span class="comment">// 2. 告诉 Spring 如何加载上下文 (这个注解我们将在下一节详述)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreetingServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 3. 从测试上下文中注入完全初始化好的 GreetingService Bean</span></span><br><span class="line">    <span class="keyword">private</span> GreetingService greetingService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">should_returnGreetingFromProperties</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 4. greetingService 已经是一个功能完备的 Bean, @Value 注解已生效</span></span><br><span class="line">        assertEquals(<span class="string">&quot;Hello&quot;</span>, greetingService.getGreeting());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解析：</strong></p>
<ol>
<li><strong><code>@ExtendWith(SpringExtension.class)</code></strong>：通知 JUnit 5 使用 Spring 扩展。</li>
<li><strong><code>@SpringBootTest</code></strong>: 这是配置注解，它告诉 <code>SpringExtension</code> 应该如何构建 <code>ApplicationContext</code>。在这里，它会像启动一个真正的 Spring Boot 应用一样加载上下文（但不会启动 web 服务器）。</li>
<li><strong><code>@Autowired</code></strong>: 在测试类中，我们可以像在业务代码中一样使用 <code>@Autowired</code>。<code>SpringExtension</code> 会确保从它管理的测试上下文中找到对应的 Bean 并注入进来。</li>
<li><strong>测试执行</strong>：当 <code>should_returnGreetingFromProperties</code> 方法运行时，<code>greetingService</code> 实例已经由 Spring 完全创建并配置好了，它的 <code>greeting</code> 字段已经被成功注入了 “Hello” 值。</li>
</ol>
<hr>
<h5 id="5-上下文缓存-Context-Caching"><a href="#5-上下文缓存-Context-Caching" class="headerlink" title="5. 上下文缓存 (Context Caching)"></a>5. 上下文缓存 (Context Caching)</h5><p>一个重要的性能优化是，Spring Test Context 是<strong>可以被缓存的</strong>。如果多个测试类使用完全相同的上下文配置，Spring 不会为每个类都重新启动一个容器，而是会重用已经创建好的那个。这极大地加快了测试套件的整体执行速度。</p>
<hr>
<h4 id="3-1-2-SpringBootTest-加载完整的应用上下文进行集成测试"><a href="#3-1-2-SpringBootTest-加载完整的应用上下文进行集成测试" class="headerlink" title="3.1.2 @SpringBootTest: 加载完整的应用上下文进行集成测试"></a>3.1.2 <code>@SpringBootTest</code>: 加载完整的应用上下文进行集成测试</h4><p><code>@SpringBootTest</code> 是 Spring Boot 测试生态中的“核武器”。它提供了一种极其方便的方式来<strong>启动一个与你的生产环境几乎完全一致的 Spring <code>ApplicationContext</code></strong>，从而让你可以在一个非常接近真实的环境中进行集成测试。</p>
<h5 id="1-SpringBootTest-的核心作用"><a href="#1-SpringBootTest-的核心作用" class="headerlink" title="1. @SpringBootTest 的核心作用"></a>1. <code>@SpringBootTest</code> 的核心作用</h5><p>当你为一个测试类添加 <code>@SpringBootTest</code> 注解时，Spring Test 框架会：</p>
<ol>
<li><strong>扫描主配置类</strong>：它会从当前测试类所在的包开始向上查找，直到找到一个带有 <code>@SpringBootApplication</code> 或 <code>@SpringBootConfiguration</code> 的主启动类。</li>
<li><strong>加载完整上下文</strong>：一旦找到主启动类，它就会像你运行 <code>java -jar my-app.jar</code> 一样，触发 Spring Boot 的自动配置机制，扫描你项目中所有的 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code> 等，并把它们全部创建为 Beans，装载到一个完整的 <code>ApplicationContext</code> 中。</li>
<li><strong>应用 <code>application.properties</code></strong>：它会加载位于 <code>src/test/resources</code> 下的 <code>application.properties</code> (或 <code>.yml</code>) 文件。如果找不到，则会退而求其次加载 <code>src/main/resources</code> 下的同名文件。这允许你为测试环境定义一套专属的配置（比如，使用内存数据库 H2）。</li>
</ol>
<p><strong>简而言之，<code>@SpringBootTest</code> 就是在你的测试执行期间，模拟了一次完整的 Spring Boot 应用启动（但默认不启动嵌入式服务器）。</strong></p>
<hr>
<h5 id="2-何时使用-SpringBootTest"><a href="#2-何时使用-SpringBootTest" class="headerlink" title="2. 何时使用 @SpringBootTest"></a>2. 何时使用 <code>@SpringBootTest</code></h5><p><code>@SpringBootTest</code> 主要用于<strong>端到端（End-to-End）的集成测试</strong>场景，即当你需要验证多个层（如 Controller -&gt; Service -&gt; Repository）之间协同工作是否正常时。</p>
<p><strong>适用场景：</strong></p>
<ul>
<li>测试一个完整的业务流程，该流程跨越了多个 Service 和 Repository。</li>
<li>验证在完整的 Spring 环境下，AOP 切面（如 <code>@Transactional</code>）是否按预期工作。</li>
<li>测试需要从 <code>application.properties</code> 中读取复杂配置的组件。</li>
<li>当你的测试需要应用中大部分 Bean 都参与时。</li>
</ul>
<hr>
<h5 id="3-基本用法"><a href="#3-基本用法" class="headerlink" title="3. 基本用法"></a>3. 基本用法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们有 UserService, 它依赖 UserRepository</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line">    <span class="comment">// ... constructor</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Spring Boot 中，@SpringBootTest 已经包含了 @ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="comment">// 所以你可以只写 @SpringBootTest</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceIntegrationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">should_findUser_when_userExistsInDatabase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Arrange: 准备数据 (通常会使用内存数据库如 H2)</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">savedUser</span> <span class="operator">=</span> userRepository.save(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;john_doe&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act: 调用业务方法</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">foundUser</span> <span class="operator">=</span> userService.findUserById(savedUser.getId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert: 验证结果</span></span><br><span class="line">        assertThat(foundUser).isNotNull();</span><br><span class="line">        assertThat(foundUser.getUsername()).isEqualTo(<span class="string">&quot;john_doe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>@SpringBootTest</code> 启动了完整的上下文，<code>UserService</code> 和 <code>UserRepository</code> (一个 JPA Repository 接口的实现) 都被成功创建并注入。测试就像在真实应用环境中一样运行。</p>
<hr>
<h5 id="4-启动一个真实的-Web-服务器"><a href="#4-启动一个真实的-Web-服务器" class="headerlink" title="4. 启动一个真实的 Web 服务器"></a>4. 启动一个真实的 Web 服务器</h5><p>默认情况下，<code>@SpringBootTest</code> 创建的上下文是一个 <code>mock</code> 的 Web 环境，并不会启动像 Tomcat、Jetty 或 Netty 这样的嵌入式 Web 服务器。</p>
<p>如果你需要测试 HTTP API 端点，比如模拟一个真实的客户端请求，你可以通过 <code>webEnvironment</code> 属性来启动一个真实的服务器。</p>
<ul>
<li><strong><code>@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</code></strong><ul>
<li>启动一个<strong>真实</strong>的嵌入式 Web 服务器，并监听一个<strong>随机</strong>的、未被占用的端口。</li>
<li>这是进行 Web 集成测试的<strong>推荐方式</strong>，可以避免端口冲突，尤其是在 CI&#x2F;CD 环境中。</li>
<li>你可以通过 <code>@LocalServerPort</code> 注解来获取这个随机端口。</li>
</ul>
</li>
<li><strong><code>@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)</code></strong><ul>
<li>启动一个真实的 Web 服务器，并监听你在 <code>application.properties</code> 中定义的 <code>server.port</code>。</li>
<li>不推荐，因为容易造成端口冲突。</li>
</ul>
</li>
</ul>
<p><strong>示例：使用随机端口进行测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloControllerIntegrationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LocalServerPort</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestRestTemplate restTemplate; <span class="comment">// Spring Boot 提供的测试 REST 客户端</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">should_returnDefaultMessage_when_callingRootUrl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:&quot;</span> + port + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="built_in">this</span>.restTemplate.getForObject(url, String.class);</span><br><span class="line"></span><br><span class="line">        assertThat(body).isEqualTo(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，应用会在一个随机端口上启动，然后我们使用 <code>TestRestTemplate</code> 像一个真实的 HTTP 客户端一样向它发起请求。</p>
<hr>
<h5 id="5-SpringBootTest-的缺点与权衡"><a href="#5-SpringBootTest-的缺点与权衡" class="headerlink" title="5. @SpringBootTest 的缺点与权衡"></a>5. <code>@SpringBootTest</code> 的缺点与权衡</h5><p>尽管功能强大，但 <code>@SpringBootTest</code> 也有其明显的缺点：</p>
<ul>
<li><strong>慢 (Slow)</strong>：启动完整的 Spring 上下文是一个非常耗时的操作。如果你的项目很大，每个 <code>@SpringBootTest</code> 测试类的启动时间可能长达数秒甚至更久。一个大型项目中如果有几十上百个这样的测试，整个测试套件的运行时间会变得难以接受。</li>
<li><strong>资源密集 (Resource-intensive)</strong>：它加载了应用中所有的 Bean，即使你的测试只用到了其中的一小部分。这会消耗大量的内存和 CPU。</li>
</ul>
<p><strong>因此，使用 <code>@SpringBootTest</code> 时必须进行权衡：</strong></p>
<blockquote>
<p><strong>不要滥用 <code>@SpringBootTest</code>！</strong> 它应该是你测试工具箱中的“重武器”，而不是日常工具。只有在确实需要测试多层集成时才使用它。</p>
</blockquote>
<p>在下一节，我们将学习更轻量、更快的<strong>切片测试（Slice Tests）</strong>，它们是测试特定层的首选方案。</p>
<hr>
<h4 id="3-1-3-切片测试-Slice-Tests-：更快、更专注的集成测试"><a href="#3-1-3-切片测试-Slice-Tests-：更快、更专注的集成测试" class="headerlink" title="3.1.3 切片测试 (Slice Tests)：更快、更专注的集成测试"></a>3.1.3 切片测试 (Slice Tests)：更快、更专注的集成测试</h4><p>我们已经知道 <code>@SpringBootTest</code> 功能强大但速度缓慢，因为它加载了整个应用的 <code>ApplicationContext</code>。然而，在大多数情况下，我们只想测试应用中的某一个“层”或“切片”，而不需要其他层的参与。</p>
<p><strong>切片测试 (Slice Tests)</strong> 正是为此而生。它只加载和自动配置与特定层相关的 Spring Beans，而将其他所有层排除在外。这使得测试启动<strong>更快</strong>、消耗资源<strong>更少</strong>，并且<strong>更专注</strong>于待测层的逻辑。</p>
<p>Spring Boot 提供了一系列专用的测试注解来实现切片测试，每个注解对应应用的一个“切片”。</p>
<h5 id="1-WebMvcTest-只测试-Web-层-Controller"><a href="#1-WebMvcTest-只测试-Web-层-Controller" class="headerlink" title="1. @WebMvcTest: 只测试 Web 层 (Controller)"></a>1. <code>@WebMvcTest</code>: 只测试 Web 层 (Controller)</h5><ul>
<li><strong>目的</strong>：专门用于测试 Spring MVC 的 <code>Controller</code> 层。它让你可以在一个接近真实的 Spring MVC 环境中测试请求映射、请求参数绑定、JSON 序列化&#x2F;反序列化、验证 (<code>@Valid</code>) 等 Web 相关的功能，而<strong>无需启动完整的应用</strong>。</li>
<li><strong>加载的切片</strong>：<ul>
<li>你指定的 Controller (<code>@Controller</code>, <code>@RestController</code>)。</li>
<li>Spring MVC 核心组件（<code>DispatcherServlet</code>, <code>HandlerMapping</code>, <code>MessageConverter</code> 等）。</li>
<li>Web 相关的配置（<code>@JsonComponent</code>, <code>WebMvcConfigurer</code> 等）。</li>
</ul>
</li>
<li><strong>不加载的切片</strong>：<ul>
<li>通用的 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code> 等业务层和持久层 Beans。</li>
</ul>
</li>
<li><strong>核心工具</strong>：<ul>
<li><strong><code>MockMvc</code></strong>：一个强大的服务器端测试框架，让你能够模拟 HTTP 请求并对响应进行精细的断言，而无需启动真正的 HTTP 服务器。</li>
<li><strong><code>@MockBean</code></strong>：由于业务层 (<code>@Service</code>) 不会被加载，你<strong>必须</strong>使用 <code>@MockBean</code> 来提供 Controller 所依赖的 Service 的 Mock 对象。</li>
</ul>
</li>
</ul>
<p><strong>示例：测试一个 <code>GreetingController</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Controller</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GreetingService greetingService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GreetingController</span><span class="params">(GreetingService greetingService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.greetingService = greetingService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/greeting&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">greet</span><span class="params">(<span class="meta">@RequestParam</span> String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> greetingService.greet(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Service (在测试中它不会被加载)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">greet</span><span class="params">(String name)</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 测试代码 ---</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.<span class="keyword">when</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebMvcTest(controllers = GreetingController.class)</span> <span class="comment">// 1. 指定只测试 GreetingController</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreetingControllerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc; <span class="comment">// 2. 注入 MockMvc 用于模拟请求</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockBean</span> <span class="comment">// 3. Mock Controller 的依赖 GreetingService</span></span><br><span class="line">    <span class="keyword">private</span> GreetingService greetingService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">should_returnGreetingFromService</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Arrange: 准备 Mock 行为</span></span><br><span class="line">        <span class="keyword">when</span>(greetingService.greet(<span class="string">&quot;World&quot;</span>)).thenReturn(<span class="string">&quot;Hello from Mock, World&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act &amp; Assert: 执行模拟请求并断言响应</span></span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/greeting&quot;</span>).param(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;World&quot;</span>))</span><br><span class="line">               .andExpect(status().isOk()) <span class="comment">// 验证 HTTP 状态码为 200</span></span><br><span class="line">               .andExpect(content().string(<span class="string">&quot;Hello from Mock, World&quot;</span>)); <span class="comment">// 验证响应体内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-DataJpaTest-只测试-JPA-持久层"><a href="#2-DataJpaTest-只测试-JPA-持久层" class="headerlink" title="2. @DataJpaTest: 只测试 JPA 持久层"></a>2. <code>@DataJpaTest</code>: 只测试 JPA 持久层</h5><ul>
<li><strong>目的</strong>：专门用于测试与 JPA 相关的代码，如 Spring Data JPA 的 <code>Repository</code> 接口和自定义的 JPA 查询。</li>
<li><strong>加载的切片</strong>：<ul>
<li>JPA 实体 (<code>@Entity</code>) 的扫描和配置。</li>
<li>Spring Data JPA 的 <code>Repository</code> 接口的实现。</li>
<li><code>EntityManager</code>, <code>DataSource</code> 等 JPA 核心组件。</li>
</ul>
</li>
<li><strong>不加载的切片</strong>：<ul>
<li><code>@Component</code>, <code>@Service</code>, <code>@Controller</code> 等其他所有层的 Beans。</li>
</ul>
</li>
<li><strong>核心特性与工具</strong>：<ul>
<li><strong>默认使用内存数据库</strong>：通常会自动配置一个嵌入式的内存数据库（如 H2），避免了连接真实数据库的麻烦。</li>
<li><strong>事务回滚</strong>：每个测试方法默认都在一个事务中运行，并在测试结束后<strong>自动回滚</strong>。这保证了每个测试之间的数据是隔离的，互不影响。</li>
<li><strong><code>TestEntityManager</code></strong>：一个专门为测试设计的 <code>EntityManager</code>，提供了方便的方法来准备测试数据（如 <code>persistAndFlush</code>）和清理。</li>
</ul>
</li>
</ul>
<p><strong>示例：测试一个 <code>UserRepository</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Entity</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123; <span class="comment">/* id, username... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    Optional&lt;User&gt; <span class="title function_">findByUsername</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 测试代码 ---</span></span><br><span class="line"><span class="meta">@DataJpaTest</span> <span class="comment">// 1. 启用 JPA 持久层测试切片</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserRepositoryTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestEntityManager entityManager; <span class="comment">// 2. 用于准备数据</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 3. 注入要测试的 Repository</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">should_findUserByUsername_when_userExists</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Arrange: 使用 TestEntityManager 准备数据并持久化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;testuser&quot;</span>);</span><br><span class="line">        entityManager.persistAndFlush(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act: 调用 Repository 的方法</span></span><br><span class="line">        Optional&lt;User&gt; found = userRepository.findByUsername(<span class="string">&quot;testuser&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert: 验证查询结果</span></span><br><span class="line">        assertThat(found).isPresent();</span><br><span class="line">        assertThat(found.get().getUsername()).isEqualTo(<span class="string">&quot;testuser&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-RestClientTest-测试客户端-REST-调用"><a href="#3-RestClientTest-测试客户端-REST-调用" class="headerlink" title="3. @RestClientTest: 测试客户端 REST 调用"></a>3. <code>@RestClientTest</code>: 测试客户端 REST 调用</h5><ul>
<li><strong>目的</strong>：专门用于测试那些扮演“客户端”角色的代码，即那些使用 <code>RestTemplate</code> 或 <code>WebClient</code> 去调用外部 REST API 的类。</li>
<li><strong>加载的切片</strong>：<ul>
<li>你指定的被测组件。</li>
<li>JSON 序列化&#x2F;反序列化支持（Jackson）。</li>
</ul>
</li>
<li><strong>不加载的切片</strong>：<ul>
<li>完整的应用上下文，<strong>也不会启动任何 Web 服务器</strong>。</li>
</ul>
</li>
<li><strong>核心工具</strong>：<ul>
<li><strong><code>MockRestServiceServer</code></strong>: 这是 <code>@RestClientTest</code> 的“魔法”所在。它会自动创建一个 Mock 服务器，拦截所有由 <code>RestTemplate</code> 发出的请求。你可以预设这个 Mock 服务器对特定请求应该返回什么响应。</li>
</ul>
</li>
</ul>
<p><strong>示例：测试一个调用外部天气服务的 <code>WeatherClient</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client to be tested</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="comment">// ... constructor</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getForecast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;/api/weather/now&quot;</span>, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 测试代码 ---</span></span><br><span class="line"><span class="meta">@RestClientTest(components = WeatherClient.class)</span> <span class="comment">// 1. 指定测试 WeatherClient</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeatherClientTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockRestServiceServer mockServer; <span class="comment">// 2. 注入 Mock 服务器</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WeatherClient weatherClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">should_returnForecast_when_serverRespondsSuccessfully</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Arrange: 设定 Mock 服务器的期望行为</span></span><br><span class="line">        mockServer.expect(requestTo(<span class="string">&quot;/api/weather/now&quot;</span>)) <span class="comment">// 期望一个到该 URL 的请求</span></span><br><span class="line">                  .andRespond(withSuccess(<span class="string">&quot;Sunny&quot;</span>, MediaType.TEXT_PLAIN)); <span class="comment">// 并返回成功的响应</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act: 调用客户端方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">forecast</span> <span class="operator">=</span> weatherClient.getForecast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert: 验证客户端方法的返回值</span></span><br><span class="line">        assertThat(forecast).isEqualTo(<span class="string">&quot;Sunny&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Verify: 确认 Mock 服务器收到了预期的请求</span></span><br><span class="line">        mockServer.verify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="总结：切片测试的选择"><a href="#总结：切片测试的选择" class="headerlink" title="总结：切片测试的选择"></a>总结：切片测试的选择</h5><table>
<thead>
<tr>
<th>注解</th>
<th>测试目标</th>
<th>加载内容</th>
<th>关键工具&#x2F;特性</th>
</tr>
</thead>
<tbody><tr>
<td><code>@WebMvcTest</code></td>
<td>Controller 层</td>
<td>Spring MVC 栈, 指定的 Controller</td>
<td><code>MockMvc</code>, <code>@MockBean</code></td>
</tr>
<tr>
<td><code>@DataJpaTest</code></td>
<td>JPA 持久层</td>
<td>JPA 配置, <code>Repository</code>, <code>EntityManager</code></td>
<td>内存数据库, 自动回滚, <code>TestEntityManager</code></td>
</tr>
<tr>
<td><code>@RestClientTest</code></td>
<td>REST 客户端调用</td>
<td>指定的客户端, Jackson 支持</td>
<td><code>MockRestServiceServer</code></td>
</tr>
<tr>
<td>…</td>
<td>(还有其他切片)</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td><code>@SpringBootTest</code></td>
<td><strong>整个应用集成</strong></td>
<td><strong>所有 Beans</strong>, 完整的应用上下文</td>
<td><code>TestRestTemplate</code>, <code>WebEnvironment</code></td>
</tr>
</tbody></table>
<p><strong>核心思想</strong>：优先使用最窄、最快的测试“切片”。只有当你的测试场景确实需要跨多个层进行集成时，才考虑使用更“重”的 <code>@SpringBootTest</code>。</p>
<hr>
<h4 id="3-1-4-在测试中管理-Beans"><a href="#3-1-4-在测试中管理-Beans" class="headerlink" title="3.1.4 在测试中管理 Beans"></a>3.1.4 在测试中管理 Beans</h4><p>在使用 Spring 进行集成测试时（无论是 <code>@SpringBootTest</code> 还是切片测试），我们面对的是一个由 Spring 容器管理的 <code>ApplicationContext</code>。如何与这个上下文中的 Beans 进行交互，以及如何替换其中的某些 Beans 以实现隔离，是编写高质量集成测试的关键。Spring Boot 提供了三个核心注解来帮助我们完成这项工作。</p>
<hr>
<h5 id="1-Autowired-注入真实的-Bean"><a href="#1-Autowired-注入真实的-Bean" class="headerlink" title="1. @Autowired: 注入真实的 Bean"></a>1. <code>@Autowired</code>: 注入真实的 Bean</h5><ul>
<li><p><strong>作用</strong>：与你在生产代码中使用 <code>@Autowired</code> 完全一样。它从当前 Spring 测试上下文中<strong>获取一个已经存在的、完全由 Spring 管理的真实 Bean</strong>，并将其注入到你的测试类字段中。</p>
</li>
<li><p><strong>何时使用</strong>：</p>
<ul>
<li>当你想要获取<strong>被测试的主体对象 (Subject Under Test, SUT)</strong> 时。例如，在 <code>@SpringBootTest</code> 中测试一个 <code>OrderService</code>，你需要注入一个真实的 <code>OrderService</code> 实例。</li>
<li>当你需要使用一个真实的依赖来进行断言时。例如，在 <code>@DataJpaTest</code> 中，你需要注入真实的 <code>UserRepository</code> 来调用它的方法并验证结果。</li>
</ul>
</li>
<li><p><strong>示例</strong> (在 <code>@SpringBootTest</code> 场景下)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderServiceIntegrationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 注入一个由 Spring 完整创建和装配的 OrderService 实例</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 注入一个真实的 UserRepository 实例 (例如，连接到 H2 数据库)</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testPlaceOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ... 使用 orderService 和 userRepository 进行真实的集成测试 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-MockBean-将-Spring-Context-中的某个-Bean-替换为-Mockito-Mock"><a href="#2-MockBean-将-Spring-Context-中的某个-Bean-替换为-Mockito-Mock" class="headerlink" title="2. @MockBean: 将 Spring Context 中的某个 Bean 替换为 Mockito Mock"></a>2. <code>@MockBean</code>: 将 Spring Context 中的某个 Bean 替换为 Mockito Mock</h5><ul>
<li><p><strong>作用</strong>：这是 Spring 测试中<strong>实现隔离</strong>的最重要工具。<code>@MockBean</code> 会做两件事：</p>
<ol>
<li>在 Spring <code>ApplicationContext</code> 中查找指定类型（或名称）的 Bean。</li>
<li>如果找到了，就用一个 <strong>Mockito Mock 对象</strong>替换掉它。</li>
<li>如果没找到，就将这个 Mock 对象<strong>添加</strong>到上下文中。</li>
</ol>
<p>这个 Mock 对象会被注入到任何需要它的其他 Bean 中。同时，这个 Mock 实例也会被注入到你的测试类中，以便你对其进行打桩 (<code>when...then</code>) 和验证 (<code>verify</code>)。</p>
</li>
<li><p><strong>何时使用</strong>：</p>
<ul>
<li>在<strong>切片测试</strong>中，用于提供被测层所依赖的、但又未被加载的外部层。最典型的例子就是在 <code>@WebMvcTest</code> 中 Mock <code>Service</code> 层。</li>
<li>在<strong>完整的 <code>@SpringBootTest</code></strong> 中，用于替换那些你<strong>不希望在测试中真实调用</strong>的依赖。例如：<ul>
<li>调用外部第三方 API 的客户端 (<code>PaymentGateway</code>, <code>SmsClient</code>)。</li>
<li>与消息队列（Kafka, RabbitMQ）交互的组件。</li>
<li>任何缓慢、不稳定或难以控制的外部依赖。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>示例</strong> (在 <code>@WebMvcTest</code> 场景下):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebMvcTest(controllers = UserController.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserControllerTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UserService 是一个外部依赖，在 @WebMvcTest 中不会被加载</span></span><br><span class="line">    <span class="comment">// @MockBean 会创建一个 Mock 的 UserService 并放入上下文中</span></span><br><span class="line">    <span class="comment">// 这个 Mock 会被自动注入到 UserController 实例中</span></span><br><span class="line">    <span class="meta">@MockBean</span> </span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">should_returnUserDetails_when_userExists</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Arrange: 对 MockBean 进行打桩</span></span><br><span class="line">        <span class="keyword">when</span>(userService.findById(<span class="number">1L</span>)).thenReturn(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;John Doe&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act &amp; Assert</span></span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/users/1&quot;</span>))</span><br><span class="line">               .andExpect(status().isOk())</span><br><span class="line">               .andExpect(jsonPath(<span class="string">&quot;$.name&quot;</span>).value(<span class="string">&quot;John Doe&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Verify: 验证 MockBean 是否被正确调用</span></span><br><span class="line">        verify(userService).findById(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="3-SpyBean-将-Spring-Context-中的某个-Bean-包装为-Spy"><a href="#3-SpyBean-将-Spring-Context-中的某个-Bean-包装为-Spy" class="headerlink" title="3. @SpyBean: 将 Spring Context 中的某个 Bean 包装为 Spy"></a>3. <code>@SpyBean</code>: 将 Spring Context 中的某个 Bean 包装为 Spy</h5><ul>
<li><p><strong>作用</strong>：<code>@SpyBean</code> 类似于 <code>@MockBean</code>，但它不是用一个全新的 Mock 对象替换 Bean，而是用一个 <strong>Mockito Spy 对象</strong>来包装<strong>真实的 Bean 实例</strong>。</p>
<p>这意味着：</p>
<ol>
<li>默认情况下，调用 SpyBean 的任何方法都会执行<strong>真实 Bean 的原始逻辑</strong>。</li>
<li>你可以像操作普通 Mockito Spy 一样，对其进行<strong>行为验证 (<code>verify</code>)</strong>。</li>
<li>你也可以选择性地<strong>对某些方法进行打桩</strong>，让它们返回假数据或抛出异常，而其他方法仍然执行真实逻辑。</li>
</ol>
</li>
<li><p><strong>何时使用</strong>：</p>
<ul>
<li>当你需要测试一个 Bean，并且希望<strong>大部分行为是真实的</strong>，但又想<strong>控制或验证其中一小部分方法的行为</strong>时。</li>
<li>当你想要验证一个真实方法的调用次数或参数，但又不想 Mock 掉整个方法时。</li>
<li><strong>警告</strong>：过度使用 <code>@SpyBean</code> 可能是一个“代码异味”，表明你的类职责过大，难以测试。应优先考虑重构，而不是依赖 Spy。</li>
</ul>
</li>
<li><p><strong>示例</strong>：<br>假设我们有一个 <code>EmailService</code>，它有一个复杂的 <code>sendReportEmail</code> 方法，该方法内部会调用一个简单的私有或公有方法 <code>generateReportContent</code>。我们想在测试中跳过真正发送邮件的部分，但又想验证 <code>generateReportContent</code> 的真实逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmailServiceSpyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SpyBean</span> <span class="comment">// 包装真实的 EmailService Bean</span></span><br><span class="line">    <span class="keyword">private</span> EmailService emailService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@MockBean</span> <span class="comment">// 替换真实的 MailSender，防止邮件真的被发出</span></span><br><span class="line">    <span class="keyword">private</span> MailSender mailSender; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">should_generateCorrectReportContent_and_attemptToSend</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Arrange: 对 SpyBean 的部分方法打桩 (使用 do...when 语法)</span></span><br><span class="line">        <span class="comment">// 我们不想真的发送邮件，所以让 send 方法什么都不做</span></span><br><span class="line">        doNothing().<span class="keyword">when</span>(emailService).send(anyString(), anyString(), anyString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act: 调用被测方法，这将执行真实的 generateReportContent 逻辑</span></span><br><span class="line">        emailService.sendReportEmail(<span class="string">&quot;admin@example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Verify: 验证真实方法的调用</span></span><br><span class="line">        <span class="comment">// 验证 send 方法被以特定参数调用了</span></span><br><span class="line">        verify(emailService).send(eq(<span class="string">&quot;admin@example.com&quot;</span>), anyString(), contains(<span class="string">&quot;Report for today&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="总结与对比"><a href="#总结与对比" class="headerlink" title="总结与对比"></a>总结与对比</h5><table>
<thead>
<tr>
<th>注解</th>
<th>类型</th>
<th>目的</th>
<th>行为</th>
<th>核心场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>@Autowired</code></strong></td>
<td><strong>真实 Bean</strong></td>
<td>获取并使用上下文中的<strong>真实对象</strong>。</td>
<td>执行 Bean 的原始、完整逻辑。</td>
<td>获取被测主体 (SUT) 或需要其真实行为的依赖。</td>
</tr>
<tr>
<td><strong><code>@MockBean</code></strong></td>
<td><strong>Mockito Mock</strong></td>
<td><strong>完全替换</strong>上下文中的一个 Bean 以实现隔离。</td>
<td>默认什么都不做（返回 null、0 或 false）。必须通过 <code>when()...</code> 来为其打桩。</td>
<td>1. 在切片测试中提供外部依赖。<br>2. 在集成测试中隔离外部系统（API, MQ等）。</td>
</tr>
<tr>
<td><strong><code>@SpyBean</code></strong></td>
<td><strong>Mockito Spy (包装器)</strong></td>
<td><strong>部分 Mock</strong> 一个真实 Bean。</td>
<td>默认执行真实 Bean 的逻辑。可以验证调用，也可以对部分方法进行打桩。</td>
<td>1. 测试遗留代码。<br>2. 当需要验证真实方法的调用，但又想保留其大部分真实行为时。</td>
</tr>
</tbody></table>
<hr>
<h4 id="3-1-5-使用-MockMvc-测试-RESTful-API"><a href="#3-1-5-使用-MockMvc-测试-RESTful-API" class="headerlink" title="3.1.5 使用 MockMvc 测试 RESTful API"></a>3.1.5 使用 <code>MockMvc</code> 测试 RESTful API</h4><p><code>MockMvc</code> 提供了一套流畅的、链式调用的 API，让我们可以在<strong>服务器端</strong>对 Spring MVC 的 Controller 进行测试。它的核心优势在于：</p>
<ul>
<li><strong>不启动真正的 Web 服务器</strong>：它通过一个模拟的 <code>DispatcherServlet</code> 直接调用 Controller 的方法，绕过了整个网络协议栈，因此测试运行速度非常快。</li>
<li><strong>完全控制</strong>：你可以精细地构建 HTTP 请求的每一个细节（方法、URL、头部、请求体等），并对响应的每一个细节（状态码、头部、响应体等）进行断言。</li>
</ul>
<p><code>MockMvc</code> 通常与 <code>@WebMvcTest</code> 结合使用，是进行 Web 层切片测试的理想工具。</p>
<h5 id="1-准备工作：注入-MockMvc"><a href="#1-准备工作：注入-MockMvc" class="headerlink" title="1. 准备工作：注入 MockMvc"></a>1. 准备工作：注入 <code>MockMvc</code></h5><p>在你的 <code>@WebMvcTest</code> 测试类中，只需通过 <code>@Autowired</code> 注入 <code>MockMvc</code> 实例即可。Spring Boot 会自动为你配置好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebMvcTest(controllers = UserController.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserControllerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc; <span class="comment">// Spring Boot 自动配置并注入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 测试方法 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-MockMvc-的核心工作流程"><a href="#2-MockMvc-的核心工作流程" class="headerlink" title="2. MockMvc 的核心工作流程"></a>2. <code>MockMvc</code> 的核心工作流程</h5><p>一次典型的 <code>MockMvc</code> 测试遵循“三步走”模式：</p>
<ol>
<li><strong>执行请求 (Perform a Request)</strong>：使用 <code>mockMvc.perform()</code> 方法，并传入一个由 <code>MockMvcRequestBuilders</code> 构建的请求对象。</li>
<li><strong>（可选）打印结果 (Print the Result)</strong>：使用 <code>.andDo(print())</code> 来打印详细的请求和响应信息，非常适合在调试时使用。</li>
<li><strong>断言期望 (Expect and Assert)</strong>：使用 <code>.andExpect()</code> 方法，并传入一系列由 <code>MockMvcResultMatchers</code> 提供的“结果匹配器”来进行断言。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/users/1&quot;</span>)) <span class="comment">// 1. 执行请求</span></span><br><span class="line">       .andDo(print())                                    <span class="comment">// 2. 打印结果</span></span><br><span class="line">       .andExpect(status().isOk());                       <span class="comment">// 3. 断言期望</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-发起请求-MockMvcRequestBuilders"><a href="#3-发起请求-MockMvcRequestBuilders" class="headerlink" title="3. 发起请求 (MockMvcRequestBuilders)"></a>3. 发起请求 (<code>MockMvcRequestBuilders</code>)</h5><p><code>MockMvcRequestBuilders</code> 类提供了静态方法来构建各种 HTTP 请求。</p>
<ul>
<li><p><strong>HTTP 方法</strong>: <code>get()</code>, <code>post()</code>, <code>put()</code>, <code>delete()</code>, <code>patch()</code> 等。</p>
</li>
<li><p><strong>构建带参数的 GET 请求</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL 路径变量: /users/123</span></span><br><span class="line">mockMvc.perform(get(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>, <span class="number">123</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// URL 查询参数: /users/search?name=john&amp;page=0</span></span><br><span class="line">mockMvc.perform(get(<span class="string">&quot;/users/search&quot;</span>)</span><br><span class="line">        .param(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;john&quot;</span>)</span><br><span class="line">        .param(<span class="string">&quot;page&quot;</span>, <span class="string">&quot;0&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>构建带请求体的 POST&#x2F;PUT 请求</strong>:<br>通常用于发送 JSON 数据。你需要 <code>Jackson</code> 的 <code>ObjectMapper</code> 来将一个 Java 对象序列化为 JSON 字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ObjectMapper objectMapper; <span class="comment">// Jackson 的 ObjectMapper，Spring Boot 会自动配置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">should_createUser</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">UserCreationRequest</span> <span class="variable">requestDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserCreationRequest</span>(<span class="string">&quot;New User&quot;</span>, <span class="string">&quot;password123&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">requestJson</span> <span class="operator">=</span> objectMapper.writeValueAsString(requestDto);</span><br><span class="line"></span><br><span class="line">    mockMvc.perform(post(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON) <span class="comment">// 设置请求头 Content-Type</span></span><br><span class="line">            .content(requestJson));                  <span class="comment">// 设置请求体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置请求头 (Headers)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(get(<span class="string">&quot;/secure/resource&quot;</span>)</span><br><span class="line">        .header(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer your_jwt_token&quot;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="4-验证响应-MockMvcResultMatchers"><a href="#4-验证响应-MockMvcResultMatchers" class="headerlink" title="4. 验证响应 (MockMvcResultMatchers)"></a>4. 验证响应 (<code>MockMvcResultMatchers</code>)</h5><p><code>MockMvcResultMatchers</code> 类提供了一系列静态方法（“结果匹配器”），用于对 HTTP 响应进行断言。</p>
<p><strong>验证状态码 (Status Code)</strong></p>
<p>这是最常用的断言。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.andExpect(status().isOk())           <span class="comment">// 200 OK</span></span><br><span class="line">.andExpect(status().isCreated())      <span class="comment">// 201 Created</span></span><br><span class="line">.andExpect(status().isNoContent())    <span class="comment">// 204 No Content</span></span><br><span class="line">.andExpect(status().isBadRequest())   <span class="comment">// 400 Bad Request</span></span><br><span class="line">.andExpect(status().isNotFound())     <span class="comment">// 404 Not Found</span></span><br><span class="line">.andExpect(status().isForbidden())    <span class="comment">// 403 Forbidden</span></span><br></pre></td></tr></table></figure>

<p><strong>验证响应头 (Headers)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证 Location 头部是否指向 /users/1</span></span><br><span class="line">.andExpect(header().string(<span class="string">&quot;Location&quot;</span>, <span class="string">&quot;/users/1&quot;</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证 Content-Type 头部是否为 application/json</span></span><br><span class="line">.andExpect(header().string(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE))</span><br></pre></td></tr></table></figure>

<p><strong>验证响应体 (Response Body)</strong></p>
<p>这是功能最强大、最灵活的部分。</p>
<ul>
<li><p><strong>验证响应体为精确的字符串</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.andExpect(content().string(<span class="string">&quot;Hello, World!&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>验证响应体为 JSON (使用 JsonPath)</strong>:<br><code>JsonPath</code> 是一种类似 XPath 的表达式语言，用于查询 JSON 文档。这是测试 RESTful API 响应的<strong>核心工具</strong>。你需要引入 <code>json-path</code> 依赖（Spring Boot 的 <code>spring-boot-starter-test</code> 默认已包含）。</p>
<p>假设响应 JSON 为：<code>{ &quot;id&quot;: 1, &quot;name&quot;: &quot;John Doe&quot;, &quot;address&quot;: { &quot;city&quot;: &quot;New York&quot; } }</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.andExpect(jsonPath(<span class="string">&quot;$.id&quot;</span>).value(<span class="number">1</span>))                 <span class="comment">// 验证根对象的 id 字段值为 1</span></span><br><span class="line">.andExpect(jsonPath(<span class="string">&quot;$.name&quot;</span>).value(<span class="string">&quot;John Doe&quot;</span>))      <span class="comment">// 验证 name 字段</span></span><br><span class="line">.andExpect(jsonPath(<span class="string">&quot;$.address.city&quot;</span>).value(<span class="string">&quot;New York&quot;</span>)) <span class="comment">// 验证嵌套对象的字段</span></span><br><span class="line">.andExpect(jsonPath(<span class="string">&quot;$.email&quot;</span>).doesNotExist())        <span class="comment">// 验证某个字段不存在</span></span><br></pre></td></tr></table></figure>

<p>对于数组&#x2F;列表：<code>{ &quot;users&quot;: [ { &quot;name&quot;: &quot;A&quot; }, { &quot;name&quot;: &quot;B&quot; } ] }</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.andExpect(jsonPath(<span class="string">&quot;$.users&quot;</span>).isArray())             <span class="comment">// 验证 users 是一个数组</span></span><br><span class="line">.andExpect(jsonPath(<span class="string">&quot;$.users.length()&quot;</span>).value(<span class="number">2</span>))     <span class="comment">// 验证数组长度 (需要 Hamcrest 匹配器)</span></span><br><span class="line">.andExpect(jsonPath(<span class="string">&quot;$.users[0].name&quot;</span>).value(<span class="string">&quot;A&quot;</span>))    <span class="comment">// 验证数组第一个元素的 name 字段</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-综合示例"><a href="#5-综合示例" class="headerlink" title="5. 综合示例"></a>5. 综合示例</h5><p>让我们把所有知识点整合到一个完整的 <code>UserController</code> 测试中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebMvcTest(UserController.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserControllerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;GET /users/&#123;id&#125; - 应该在用户存在时返回 200 OK 和用户信息&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">should_returnUser_when_userExists</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Arrange</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="string">&quot;John Doe&quot;</span>, <span class="string">&quot;john.doe@example.com&quot;</span>);</span><br><span class="line">        <span class="keyword">when</span>(userService.findById(<span class="number">1L</span>)).thenReturn(Optional.of(user));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act &amp; Assert</span></span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>, <span class="number">1L</span>)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON)) <span class="comment">// 设置 Accept 请求头</span></span><br><span class="line">               .andExpect(status().isOk())</span><br><span class="line">               .andExpect(content().contentType(MediaType.APPLICATION_JSON))</span><br><span class="line">               .andExpect(jsonPath(<span class="string">&quot;$.id&quot;</span>).value(<span class="number">1</span>))</span><br><span class="line">               .andExpect(jsonPath(<span class="string">&quot;$.name&quot;</span>).value(<span class="string">&quot;John Doe&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;GET /users/&#123;id&#125; - 应该在用户不存在时返回 404 Not Found&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">should_returnNotFound_when_userDoesNotExist</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Arrange</span></span><br><span class="line">        <span class="keyword">when</span>(userService.findById(<span class="number">99L</span>)).thenReturn(Optional.empty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act &amp; Assert</span></span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>, <span class="number">99L</span>))</span><br><span class="line">               .andExpect(status().isNotFound());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;POST /users - 应该在创建成功时返回 201 Created 和 Location 头部&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">should_createUser_when_requestIsValid</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Arrange</span></span><br><span class="line">        <span class="type">UserCreationRequest</span> <span class="variable">requestDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserCreationRequest</span>(<span class="string">&quot;Jane Doe&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">createdUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2L</span>, <span class="string">&quot;Jane Doe&quot;</span>, <span class="string">&quot;jane.doe@example.com&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 ArgumentMatchers.any() 因为我们无法预测传入的 User 对象</span></span><br><span class="line">        <span class="keyword">when</span>(userService.createUser(any(UserCreationRequest.class))).thenReturn(createdUser);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act &amp; Assert</span></span><br><span class="line">        mockMvc.perform(post(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                .content(objectMapper.writeValueAsString(requestDto)))</span><br><span class="line">               .andExpect(status().isCreated())</span><br><span class="line">               .andExpect(header().string(<span class="string">&quot;Location&quot;</span>, containsString(<span class="string">&quot;/users/2&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-2-数据与环境的挑战"><a href="#3-2-数据与环境的挑战" class="headerlink" title="3.2 数据与环境的挑战"></a>3.2 数据与环境的挑战</h3><h4 id="3-2-1-数据库测试策略"><a href="#3-2-1-数据库测试策略" class="headerlink" title="3.2.1 数据库测试策略"></a>3.2.1 数据库测试策略</h4><p>当我们的业务逻辑依赖于数据库时（这在绝大多数企业应用中都是如此），单元测试的“隔离”原则就面临了挑战。我们需要一种方法来测试我们的持久层代码（如 JPA Repositories）和依赖数据库的 Service，同时又要保证测试的快速、可靠和独立。以下是三种主流的策略，各有优劣。</p>
<h5 id="1-使用内存数据库-如-H2"><a href="#1-使用内存数据库-如-H2" class="headerlink" title="1. 使用内存数据库 (如 H2)"></a>1. 使用内存数据库 (如 H2)</h5><p>这是最传统、最轻量级的数据库测试策略。</p>
<ul>
<li><p><strong>核心思想</strong>：<br>在测试运行时，启动一个完全在内存中运行的、临时的数据库实例。当测试结束，JVM退出时，这个数据库及其所有数据都会被销毁。H2 是 Java 生态中最常用的内存数据库。</p>
</li>
<li><p><strong>如何实现</strong>：</p>
<ol>
<li><p><strong>添加依赖</strong>：在 Maven 或 Gradle 中添加 H2 数据库的依赖（<code>scope</code> 为 <code>test</code>）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Maven --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置测试环境</strong>：在 <code>src/test/resources/application.properties</code> (或 <code>.yml</code>) 中，覆盖主数据源配置，指向 H2。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># src/test/resources/application.properties</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1</span></span><br><span class="line"><span class="attr">spring.datasource.driverClassName</span>=<span class="string">org.h2.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 让 Hibernate 在启动时自动创建表结构，在关闭时删除</span></span><br><span class="line"><span class="attr">spring.jpa.hibernate.ddl-auto</span>=<span class="string">create-drop</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>与 <code>@DataJpaTest</code> 结合</strong>：<code>@DataJpaTest</code> 会自动检测到 classpath 上的 H2，并优先使用它，甚至无需你手动配置 <code>application.properties</code>。</p>
</li>
</ol>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>极速</strong>：因为完全在内存中操作，没有磁盘 I&#x2F;O，速度非常快。</li>
<li><strong>简单</strong>：通常只需添加一个依赖，Spring Boot 就能很好地自动配置。</li>
<li><strong>零外部依赖</strong>：不需要开发者安装任何额外的软件（如 Docker）。</li>
</ul>
</li>
<li><p><strong>缺点 (致命的)</strong>：</p>
<ul>
<li><strong>生产环境不一致 (Dialect Difference)</strong>：这是最大的问题。H2 数据库的 SQL 方言、数据类型、函数支持都与生产环境的数据库（如 MySQL, PostgreSQL, Oracle）存在差异。一个在 H2 上运行通过的复杂 SQL 查询，在生产数据库上可能会因为语法不兼容而失败。</li>
<li><strong>虚假的安全感</strong>：100% 通过的 H2 测试并不能完全保证持久层代码在生产环境中的正确性，特别是当你使用了数据库特有的高级功能时（如 PostgreSQL 的 JSONB 查询、MySQL 的窗口函数等）。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li>非常简单的 CRUD 应用，几乎不涉及原生 SQL 或复杂的 JPQL 查询。</li>
<li>当对测试执行速度有极致要求，且团队愿意承担方言不一致风险时。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-使用-Testcontainers：通过-Docker-启动真实的数据库实例"><a href="#2-使用-Testcontainers：通过-Docker-启动真实的数据库实例" class="headerlink" title="2. 使用 Testcontainers：通过 Docker 启动真实的数据库实例"></a>2. 使用 Testcontainers：通过 Docker 启动真实的数据库实例</h5><p>这是目前社区<strong>最推荐</strong>的、兼顾了可靠性与便利性的现代数据库测试策略。</p>
<ul>
<li><p><strong>核心思想</strong>：<br>在运行测试前，通过代码以编程方式启动一个 Docker 容器，这个容器里运行着与你生产环境<strong>完全相同</strong>的数据库（例如，一个真实的 MySQL 8.0 或 PostgreSQL 14 实例）。测试代码连接到这个临时的容器数据库，测试结束后，容器被自动销毁。</p>
</li>
<li><p><strong>如何实现</strong>：</p>
<ol>
<li><p><strong>安装 Docker</strong>：开发者和 CI&#x2F;CD 环境必须安装并运行 Docker。</p>
</li>
<li><p><strong>添加依赖</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Maven --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.testcontainers<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testcontainers-bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.19.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- JUnit 5 集成 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.testcontainers<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 你需要的数据库模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.testcontainers<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>postgresql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编写测试代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Testcontainers</span> <span class="comment">// 1. 启用 Testcontainers 对 JUnit 5 的支持</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserRepositoryTCIntegrationTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Container</span> <span class="comment">// 2. 声明一个由 Testcontainers 管理的容器实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> PostgreSQLContainer&lt;?&gt; postgresqlContainer = </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PostgreSQLContainer</span>&lt;&gt;(<span class="string">&quot;postgres:14-alpine&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 动态地将 Spring 的数据源配置指向运行中的容器</span></span><br><span class="line">    <span class="meta">@DynamicPropertySource</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(DynamicPropertyRegistry registry)</span> &#123;</span><br><span class="line">        registry.add(<span class="string">&quot;spring.datasource.url&quot;</span>, postgresqlContainer::getJdbcUrl);</span><br><span class="line">        registry.add(<span class="string">&quot;spring.datasource.username&quot;</span>, postgresqlContainer::getUsername);</span><br><span class="line">        registry.add(<span class="string">&quot;spring.datasource.password&quot;</span>, postgresqlContainer::getPassword);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在一个真实的 PostgreSQL 14 数据库上进行测试</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>极高的保真度 (High Fidelity)</strong>：你在一个与生产环境完全一致的数据库引擎上进行测试，消除了所有方言不一致的风险。测试通过，就意味着在生产上也能通过。</li>
<li><strong>环境干净、隔离</strong>：每个测试（或测试类）都可以拥有一个全新的、纯净的数据库实例，测试之间绝无干扰。</li>
<li><strong>生态系统强大</strong>：Testcontainers 不仅支持数据库，还支持几乎所有能跑在 Docker 里的东西，如 Kafka, Redis, Elasticsearch, LocalStack (AWS模拟) 等，为所有集成测试提供了一致的解决方案。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>启动稍慢</strong>：首次启动 Docker 容器需要几秒钟时间，比 H2 慢。但 Testcontainers 有复用容器（Reusable Containers）等优化策略。</li>
<li><strong>依赖 Docker</strong>：需要本地和 CI 环境都安装 Docker。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li><strong>强烈推荐</strong>用于所有对可靠性有要求的现代企业级应用。</li>
<li>当使用了数据库特有功能，或者有复杂原生 SQL 查询时，<strong>必须</strong>使用此方案。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-测试数据管理"><a href="#3-测试数据管理" class="headerlink" title="3. 测试数据管理"></a>3. 测试数据管理</h5><p>无论使用哪种数据库，你都需要一种策略来管理测试数据：在测试前插入数据，在测试后清理数据。</p>
<ul>
<li><p><strong>策略一：<code>@Sql</code> 注解</strong></p>
<ul>
<li><p><strong>描述</strong>：一个声明式的注解，让你可以在测试方法执行前后运行指定的 SQL 脚本。</p>
</li>
<li><p><strong>用法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductRepositoryTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Sql(scripts = &quot;/sql/insert-products.sql&quot;, executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD)</span></span><br><span class="line">    <span class="meta">@Sql(scripts = &quot;/sql/cleanup.sql&quot;, executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">should_findProductsByCategory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ... 测试逻辑 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>insert-products.sql</code> 和 <code>cleanup.sql</code> 文件需放在 <code>src/test/resources/sql</code> 目录下。</p>
</li>
<li><p><strong>优点</strong>：简单明了，SQL 与 Java 代码分离。</p>
</li>
<li><p><strong>缺点</strong>：数据是静态的，不方便创建动态数据。</p>
</li>
</ul>
</li>
<li><p><strong>策略二：使用 Flyway &#x2F; Liquibase</strong></p>
<ul>
<li><strong>描述</strong>：这两个是数据库版本迁移工具。在测试中，它们的主要价值是<strong>保证测试数据库的表结构（Schema）与生产环境完全一致</strong>。</li>
<li><strong>用法</strong>：当 Spring Boot 检测到 Flyway&#x2F;Liquibase 依赖时，它会在启动测试上下文时自动运行迁移脚本，创建所有表、索引和约束。</li>
<li><strong>优点</strong>：一劳永逸地解决了 Schema 一致性问题。</li>
<li><strong>注意</strong>：它们主要负责 Schema，对于测试<strong>数据</strong>的插入，你仍需结合 <code>@Sql</code> 或手动方式。</li>
</ul>
</li>
<li><p><strong>策略三：手动准备和清理</strong></p>
<ul>
<li><p><strong>描述</strong>：在 <code>@BeforeEach</code> 中使用 Repository 或 <code>TestEntityManager</code> 插入数据，在 <code>@AfterEach</code> 中清理数据。</p>
</li>
<li><p><strong>用法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span> <span class="comment">// @DataJpaTest 默认回滚，通常不需要手动清理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        orderRepository.save(<span class="keyword">new</span> <span class="title class_">Order</span>(...));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        orderRepository.deleteAll(); <span class="comment">// 手动清理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点</strong>：最灵活，可以在 Java 代码中动态创建复杂的测试数据。</p>
</li>
<li><p><strong>缺点</strong>：可能会导致一些模板代码。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-策略选择总结"><a href="#4-策略选择总结" class="headerlink" title="4. 策略选择总结"></a>4. 策略选择总结</h5><table>
<thead>
<tr>
<th>策略</th>
<th>速度</th>
<th>可靠性&#x2F;保真度</th>
<th>复杂度</th>
<th>推荐度</th>
</tr>
</thead>
<tbody><tr>
<td><strong>H2 内存数据库</strong></td>
<td>极快</td>
<td>低</td>
<td>低</td>
<td>仅适用于非常简单的项目，或对速度要求极高的场景</td>
</tr>
<tr>
<td><strong>Testcontainers</strong></td>
<td>中等</td>
<td><strong>极高</strong></td>
<td>中等</td>
<td><strong>现代企业级应用的首选和最佳实践</strong></td>
</tr>
<tr>
<td><strong>数据管理</strong></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><strong>与以上策略结合使用</strong>：<code>Flyway</code> (Schema) + <code>@Sql</code> (静态数据) &#x2F; 手动 (动态数据) 是常见的组合。</td>
</tr>
</tbody></table>
<hr>
<h4 id="3-2-2-测试异步代码"><a href="#3-2-2-测试异步代码" class="headerlink" title="3.2.2 测试异步代码"></a>3.2.2 测试异步代码</h4><p>在现代应用中，为了提升性能和响应能力，我们经常使用异步编程模型。例如，调用一个耗时的外部API、发送消息到消息队列、执行一个并行的后台任务等。这些异步操作的测试不能像同步代码那样直接进行断言，因为在调用异步方法后，结果并不会立即返回。</p>
<h5 id="1-测试-CompletableFuture"><a href="#1-测试-CompletableFuture" class="headerlink" title="1. 测试 CompletableFuture"></a>1. 测试 <code>CompletableFuture</code></h5><p><code>CompletableFuture</code> 是 Java 8 引入的强大的异步编程工具。测试它的核心在于<strong>等待其完成</strong>，然后再进行断言。</p>
<p><strong>场景</strong>：假设我们有一个 <code>AsyncService</code>，它异步地从某个地方获取数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 异步执行一个耗时操作</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">fetchDataAsync</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟一个耗时的网络调用</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Async Data&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何测试？</strong></p>
<ul>
<li><p><strong>简单但不可靠的方法：<code>Thread.sleep()</code> (反模式)</strong><br>你可能会想在测试中断言前 <code>sleep</code> 一段时间。<strong>这是绝对错误的做法！</strong> 因为你无法保证异步操作一定能在你 <code>sleep</code> 的时间内完成，这会导致“片状测试 (Flaky Tests)”。</p>
</li>
<li><p><strong>正确的方法一：阻塞式获取结果 <code>.get()</code></strong><br><code>CompletableFuture.get()</code> 方法会阻塞当前线程，直到 Future 完成并返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">should_fetchData_usingGet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; <span class="comment">// 注意：.get() 会抛出受检异常</span></span><br><span class="line">    <span class="comment">// Arrange</span></span><br><span class="line">    <span class="type">AsyncService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Act</span></span><br><span class="line">    CompletableFuture&lt;String&gt; future = service.fetchDataAsync();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Assert</span></span><br><span class="line">    <span class="comment">// .get() 会阻塞，直到 future 完成</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(<span class="number">2</span>, TimeUnit.SECONDS); <span class="comment">// 可以加超时时间，防止无限等待</span></span><br><span class="line">    </span><br><span class="line">    assertEquals(<span class="string">&quot;Async Data&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>：简单直接。<br><strong>缺点</strong>：如果异步操作耗时很长，会拖慢整个测试套件的执行速度。</p>
</li>
<li><p><strong>正确的方法二：使用 Awaitility (推荐)</strong><br>Awaitility 是一个专门用于测试异步系统的小型 DSL (Domain-Specific Language) 库。它以一种优雅、可读性高的方式来轮询一个条件，直到它满足为止。</p>
<ol>
<li><p><strong>添加依赖</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Maven --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.awaitility<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>awaitility<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 使用最新稳定版 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编写测试</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.awaitility.Awaitility.await;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">should_fetchData_usingAwaitility</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Arrange</span></span><br><span class="line">    <span class="type">AsyncService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Act</span></span><br><span class="line">    CompletableFuture&lt;String&gt; future = service.fetchDataAsync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assert: 使用 Awaitility 优雅地等待</span></span><br><span class="line">    await().atMost(<span class="number">2</span>, TimeUnit.SECONDS) <span class="comment">// 最多等待 2 秒</span></span><br><span class="line">           .until(future::isDone);     <span class="comment">// 直到 future 完成</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在可以安全地断言了</span></span><br><span class="line">    assertTrue(future.isDone());</span><br><span class="line">    assertEquals(<span class="string">&quot;Async Data&quot;</span>, future.join()); <span class="comment">// .join() 是 .get() 的非受检异常版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>可读性高</strong>：<code>await().until(...)</code> 的语法非常清晰。</li>
<li><strong>健壮</strong>：它会以一定间隔轮询条件，一旦条件满足就立即继续，不会浪费不必要的时间。</li>
<li><strong>功能强大</strong>：支持超时、轮询间隔、忽略特定异常等多种配置。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-测试消息队列-Kafka-RabbitMQ"><a href="#2-测试消息队列-Kafka-RabbitMQ" class="headerlink" title="2. 测试消息队列 (Kafka&#x2F;RabbitMQ)"></a>2. 测试消息队列 (Kafka&#x2F;RabbitMQ)</h5><p>测试与消息队列的集成是更复杂的异步场景。我们不仅要发送消息，还要验证消息是否被正确地消费和处理，这中间有网络延迟和处理时间。</p>
<p><strong>策略一：使用 <code>spring-kafka-test</code> &#x2F; <code>spring-rabbit-test</code> (嵌入式 Broker)</strong></p>
<p>Spring 为 Kafka 和 RabbitMQ 提供了测试支持库，它们可以在测试期间启动一个<strong>嵌入式的、内存中的消息代理 (Broker)</strong>。</p>
<ul>
<li><p><strong>核心思想</strong>：<br>与 H2 内存数据库类似，启动一个轻量级的、内存中的 Kafka 或 RabbitMQ Broker。你的生产者和消费者在测试时连接到这个内存 Broker，而不是真实的 Broker。</p>
</li>
<li><p><strong>示例 (<code>spring-kafka-test</code>)</strong>:</p>
<ol>
<li><strong>添加依赖</strong>: <code>spring-kafka-test</code></li>
<li><strong>注解测试类</strong>: <code>@EmbeddedKafka</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@EmbeddedKafka(partitions = 1, brokerProperties = &#123; &quot;listeners=PLAINTEXT://localhost:9092&quot;, &quot;port=9092&quot; &#125;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KafkaMessageListenerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设我们有一个 @KafkaListener 监听 &quot;test-topic&quot;</span></span><br><span class="line">    <span class="meta">@SpyBean</span></span><br><span class="line">    <span class="keyword">private</span> MyKafkaListener myKafkaListener;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">should_processMessage_when_messageIsSent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Act: 发送一条消息到嵌入式 Kafka</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello Kafka&quot;</span>;</span><br><span class="line">        kafkaTemplate.send(<span class="string">&quot;test-topic&quot;</span>, message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert: 使用 Awaitility 来验证监听器的方法是否被调用</span></span><br><span class="line">        await().atMost(<span class="number">5</span>, TimeUnit.SECONDS).untilAsserted(() -&gt; &#123;</span><br><span class="line">            verify(myKafkaListener, times(<span class="number">1</span>)).listen(eq(message), any());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点</strong>：相对简单，无需外部依赖（如 Docker）。</p>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>保真度有限</strong>：嵌入式 Broker 的行为可能与生产环境的集群版 Broker 在某些高级特性（如分区、集群行为）上不完全一致。</li>
<li><strong>可能不稳定</strong>：嵌入式 Broker 有时可能在复杂的测试场景下出现稳定性问题。</li>
</ul>
</li>
</ul>
<p><strong>策略二：使用 Testcontainers (推荐)</strong></p>
<p>与数据库测试一样，Testcontainers 提供了<strong>最高保真度</strong>的消息队列测试方案。</p>
<ul>
<li><p><strong>核心思想</strong>：<br>在测试前启动一个运行着<strong>真实 Kafka 或 RabbitMQ</strong> 的 Docker 容器。你的应用连接到这个容器化的 Broker 进行测试。</p>
</li>
<li><p><strong>示例 (Testcontainers + Kafka)</strong>:</p>
<ol>
<li><strong>添加依赖</strong>: <code>org.testcontainers:kafka</code></li>
<li><strong>编写测试</strong>:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Testcontainers</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KafkaTCIntegrationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Container</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">KafkaContainer</span> <span class="variable">kafka</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KafkaContainer</span>(DockerImageName.parse(<span class="string">&quot;confluentinc/cp-kafka:7.0.1&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态设置 Spring Boot 的 Kafka Broker 地址</span></span><br><span class="line">    <span class="meta">@DynamicPropertySource</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">kafkaProperties</span><span class="params">(DynamicPropertyRegistry registry)</span> &#123;</span><br><span class="line">        registry.add(<span class="string">&quot;spring.kafka.bootstrap-servers&quot;</span>, kafka::getBootstrapServers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SpyBean</span></span><br><span class="line">    <span class="keyword">private</span> MyKafkaListener myKafkaListener;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">should_processMessage_inRealKafkaContainer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Act: 发送消息到容器化的真实 Kafka</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello Containerized Kafka&quot;</span>;</span><br><span class="line">        kafkaTemplate.send(<span class="string">&quot;test-topic&quot;</span>, message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert: 使用 Awaitility 等待并验证</span></span><br><span class="line">        await().atMost(<span class="number">10</span>, TimeUnit.SECONDS).untilAsserted(() -&gt; &#123;</span><br><span class="line">            verify(myKafkaListener).listen(eq(message), any());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>100% 生产环境一致</strong>：你在一个真实的 Kafka 实例上测试，可靠性最高。</li>
<li><strong>稳定</strong>：与 Testcontainers 生态系统无缝集成，稳定可靠。</li>
<li><strong>通用</strong>：适用于任何可以通过 Docker 运行的消息队列。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：需要 Docker 环境，启动比嵌入式 Broker 稍慢。</p>
</li>
</ul>
<hr>
<h4 id="3-2-3-微服务架构下的测试"><a href="#3-2-3-微服务架构下的测试" class="headerlink" title="3.2.3 微服务架构下的测试"></a>3.2.3 微服务架构下的测试</h4><p>在微服务架构中，一个完整的业务流程通常需要多个独立部署的服务相互协作来完成。这给测试带来了新的挑战：我们如何确保一个服务发生变更后，不会破坏依赖它的其他服务？我们如何以一种高效、可靠的方式来测试服务之间的集成？</p>
<h5 id="1-集成测试的边界：传统端到端测试的困境"><a href="#1-集成测试的边界：传统端到端测试的困境" class="headerlink" title="1. 集成测试的边界：传统端到端测试的困境"></a>1. 集成测试的边界：传统端到端测试的困境</h5><p>在单体应用时代，我们可以通过启动整个应用来进行端到端（E2E）测试。但在微服务世界里，这样做会面临巨大的困难：</p>
<ul>
<li><strong>环境搭建复杂</strong>：要进行一次完整的端到端测试，你可能需要同时在测试环境中部署十几个甚至几十个微服务，以及它们各自的数据库、消息队列等依赖。这个环境的维护成本极高。</li>
<li><strong>执行速度极慢</strong>：一次跨越多个网络调用的测试流程，耗时可能是秒级甚至分钟级，这严重影响了开发反馈速度。</li>
<li><strong>极度不稳定（片状）</strong>：整个测试链路中任何一个服务、任何一个网络连接出现抖动，都会导致测试失败。</li>
<li><strong>错误定位困难</strong>：当一个端到端测试失败时，你很难快速定位问题出在哪一个具体服务上。</li>
</ul>
<p><strong>结论</strong>：在微服务架构中，<strong>大规模的、同步的端到端集成测试是一种反模式</strong>。我们必须寻找一种更轻量、更专注的集成测试策略。</p>
<p><strong>新的集成测试边界</strong>：</p>
<p>我们应该将测试的重心下移，回到“测试金字塔”的中间层。对于一个微服务（我们称之为<strong>服务A</strong>）来说，它的“集成测试”边界应该仅限于：</p>
<blockquote>
<p><strong>验证服务A能够与其直接依赖的外部组件（如数据库、消息队列、以及它所调用的其他服务B、C）正确集成。</strong></p>
</blockquote>
<p>这里的关键是，在测试服务A时，我们<strong>不应该启动一个真实的服务B和服务C</strong>。相反，我们应该使用一种<strong>契约</strong>来保证服务A和服务B&#x2F;C之间的交互是正确的。这就是“消费者驱动契约测试”的用武之地。</p>
<hr>
<h5 id="2-消费者驱动契约测试-Consumer-Driven-Contract-Testing-CDC"><a href="#2-消费者驱动契约测试-Consumer-Driven-Contract-Testing-CDC" class="headerlink" title="2. 消费者驱动契约测试 (Consumer-Driven Contract Testing, CDC)"></a>2. 消费者驱动契约测试 (Consumer-Driven Contract Testing, CDC)</h5><p>CDC 是一种解决微服务集成测试难题的强大模式。</p>
<ul>
<li><strong>核心思想</strong>：<br>服务间的集成问题，本质上是“消费者”（调用方）和“提供者”（被调用方）之间对 API 接口的<strong>期望不一致</strong>。CDC 的目标就是捕捉这种期望，并将其固化为一份**“契约（Contract）”**。这份契约既是测试，也是文档。</li>
<li><strong>工作流程</strong>：<ol>
<li><strong>在消费者端定义期望</strong>：<ul>
<li><strong>消费者</strong>（例如 <code>OrderService</code>）的开发团队在其单元测试&#x2F;集成测试中，定义它希望<strong>提供者</strong>（例如 <code>UserService</code>）如何响应它的请求。</li>
<li>例如：“当我向 <code>UserService</code> 发送一个 <code>GET /users/1</code> 请求时，我期望得到一个 <code>200 OK</code> 的响应，并且响应体中包含一个 <code>id</code> 为 <code>1</code> 和一个 <code>name</code> 字段。”</li>
<li>这个定义过程会生成一个<strong>契约文件（Pact File）</strong>，这是一个 JSON 文件，精确地记录了消费者的所有期望（请求和期望的响应）。</li>
</ul>
</li>
<li><strong>消费者发布契约</strong>：<ul>
<li>消费者将生成的契约文件发布到一个中心化的服务器，称为 <strong>Pact Broker</strong>。</li>
</ul>
</li>
<li><strong>在提供者端验证契约</strong>：<ul>
<li><strong>提供者</strong>（<code>UserService</code>）的开发团队在其 CI&#x2F;CD 流水线中，从 Pact Broker 下载所有依赖它的消费者发布的契约。</li>
<li>然后，提供者框架会启动一个真实的 <code>UserService</code> 实例，并<strong>重放</strong>契约中的每一个请求。</li>
<li>框架会捕获 <code>UserService</code> 产生的<strong>真实响应</strong>，并与契约中消费者期望的响应进行<strong>比对</strong>。</li>
<li>如果真实响应与期望完全匹配，契约验证通过。如果任何地方不匹配（例如，<code>name</code> 字段被改成了 <code>fullName</code>），契约验证失败，<strong>构建中断</strong>。</li>
</ul>
</li>
</ol>
</li>
<li><strong>CDC 带来的好处</strong>：<ul>
<li><strong>快速、可靠的反馈</strong>：提供者每次构建时都会验证契约。如果一个变更破坏了对某个消费者的承诺，它会<strong>立即在提供者的 CI 流程中被发现</strong>，而不是等到部署到测试环境后才暴露出来。</li>
<li><strong>独立的开发与部署</strong>：只要契约保持不变，消费者和提供者团队就可以独立地开发、测试和部署自己的服务，而无需担心破坏集成。</li>
<li><strong>清晰的依赖关系</strong>：Pact Broker 提供了一个可视化的网络拓扑图，清晰地展示了哪个服务依赖哪个服务，以及它们的集成状态，成为了微服务架构的“活文档”。</li>
<li><strong>避免了大规模集成环境</strong>：测试都是在各个服务自己的 CI 流程中<strong>异步地</strong>、<strong>独立地</strong>完成的，完全不需要一个庞大的、同步的集成测试环境。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-Pact-框架简介"><a href="#3-Pact-框架简介" class="headerlink" title="3. Pact 框架简介"></a>3. Pact 框架简介</h5><p>Pact 是实现消费者驱动契约测试的<strong>事实标准框架</strong>。它支持多种语言（Java, Go, Ruby, JS, .NET 等）。</p>
<p><strong>Pact 的核心组件（Java版）</strong>：</p>
<ul>
<li><p><strong>Pact JVM - Consumer</strong>: 消费者端的库，提供 DSL 让你在 JUnit 测试中定义期望。</p>
<ul>
<li><p><strong>示例 (消费者 <code>OrderService</code> 的测试)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(PactConsumerTestExt.class)</span></span><br><span class="line"><span class="meta">@PactTestFor(providerName = &quot;UserService&quot;, port = &quot;8081&quot;)</span> <span class="comment">// 告诉 Pact 提供者是谁，以及 Mock Server 的端口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServicePactTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 定义契约 (Pact)</span></span><br><span class="line">    <span class="meta">@Pact(consumer = &quot;OrderService&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RequestResponsePact <span class="title function_">createPact</span><span class="params">(PactDslWithProvider builder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">            .given(<span class="string">&quot;a user with id 1 exists&quot;</span>) <span class="comment">// 预设提供者的状态</span></span><br><span class="line">            .uponReceiving(<span class="string">&quot;a request for user 1&quot;</span>) <span class="comment">// 描述这个交互</span></span><br><span class="line">                .path(<span class="string">&quot;/users/1&quot;</span>)</span><br><span class="line">                .method(<span class="string">&quot;GET&quot;</span>)</span><br><span class="line">            .willRespondWith() <span class="comment">// 期望的响应</span></span><br><span class="line">                .status(<span class="number">200</span>)</span><br><span class="line">                .header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">                .body(<span class="keyword">new</span> <span class="title class_">PactDslJsonBody</span>()</span><br><span class="line">                        .integerType(<span class="string">&quot;id&quot;</span>, <span class="number">1L</span>)</span><br><span class="line">                        .stringType(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;John Doe&quot;</span>))</span><br><span class="line">            .toPact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 在测试中使用这个契约</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetUserFromUserService</span><span class="params">(MockServer mockServer)</span> &#123;</span><br><span class="line">        <span class="comment">// Pact 框架会启动一个 Mock Server，它会根据你的契约定义返回响应</span></span><br><span class="line">        <span class="type">UserServiceClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceClient</span>(mockServer.getUrl());</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> client.getUser(<span class="number">1L</span>); <span class="comment">// 这个调用会打到 Mock Server 上</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 断言客户端代码的行为</span></span><br><span class="line">        assertEquals(<span class="number">1L</span>, user.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这个测试后，会在 <code>target/pacts</code> 目录下生成一个名为 <code>OrderService-UserService.json</code> 的契约文件。</p>
</li>
</ul>
</li>
<li><p><strong>Pact JVM - Provider</strong>: 提供者端的库，用于验证契约。</p>
<ul>
<li><p><strong>示例 (提供者 <code>UserService</code> 的测试)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provider(&quot;UserService&quot;)</span> <span class="comment">// 声明服务提供者的名字</span></span><br><span class="line"><span class="meta">@PactBroker</span> <span class="comment">// 从 Pact Broker 加载契约</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServicePactVerificationTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 告诉 Pact 如何启动你的服务</span></span><br><span class="line">    <span class="meta">@TestTemplate</span></span><br><span class="line">    <span class="meta">@ExtendWith(PactVerificationInvocationContextProvider.class)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pactVerificationTestTemplate</span><span class="params">(PactVerificationContext context)</span> &#123;</span><br><span class="line">        context.verifyInteraction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉 Pact 在验证前如何设置状态 (对应消费者契约中的 `given(...)`)</span></span><br><span class="line">    <span class="meta">@State(&quot;a user with id 1 exists&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userExists</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里准备你的数据库，插入一个 id 为 1 的用户</span></span><br><span class="line">        <span class="comment">// userRepository.save(new User(1L, &quot;John Doe&quot;));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Pact 框架会启动你的 Spring Boot 应用，然后从 Pact Broker 拉取契约，逐一验证。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-3-测试驱动开发-TDD-与行为驱动开发-BDD"><a href="#3-3-测试驱动开发-TDD-与行为驱动开发-BDD" class="headerlink" title="3.3 测试驱动开发 (TDD) 与行为驱动开发 (BDD)"></a>3.3 测试驱动开发 (TDD) 与行为驱动开发 (BDD)</h3><h4 id="3-3-1-TDD-Test-Driven-Development"><a href="#3-3-1-TDD-Test-Driven-Development" class="headerlink" title="3.3.1 TDD (Test-Driven Development)"></a>3.3.1 TDD (Test-Driven Development)</h4><p>测试驱动开发（TDD）是一种软件开发过程，它要求开发者在编写任何生产代码（Production Code）之前，先编写一个失败的自动化测试用例。TDD 的核心在于它改变了开发者的思考顺序：从“如何实现这个功能？”转变为“<strong>如何验证这个功能已经正确实现？</strong>”。</p>
<p>TDD 不是关于“测试”，而是关于“开发”和“设计”。测试只是这个过程中的一个工具和产物。</p>
<h5 id="1-红-绿-重构-Red-Green-Refactor-循环"><a href="#1-红-绿-重构-Red-Green-Refactor-循环" class="headerlink" title="1. 红-绿-重构 (Red-Green-Refactor) 循环"></a>1. 红-绿-重构 (Red-Green-Refactor) 循环</h5><p>TDD 的实践过程遵循一个简单而严格的循环，这个循环通常只有几分钟甚至几十秒长。</p>
<p><strong>第一步：红 (Red) - 编写一个失败的测试</strong></p>
<ol>
<li><strong>明确需求</strong>：从需求中选择一个最小、最具体的行为点。</li>
<li><strong>编写测试</strong>：为这个尚未实现的行为编写一个单元测试。</li>
<li><strong>运行测试</strong>：运行这个测试。由于你还没有编写任何生产代码，这个测试<strong>必须失败</strong>。失败的原因可能是编译错误（因为被测的类或方法还不存在），也可能是断言失败。</li>
<li><strong>看到红色</strong>：在你的IDE或构建工具中，你会看到一个红色的条，表示测试失败。<strong>看到预期的失败是这一步成功的标志。</strong> 这证明了你的测试本身是有效的，它确实能够捕捉到你将要修复的那个“错误”（即功能的缺失）。</li>
</ol>
<p><strong>示例</strong>：我们要实现一个简单的 <code>StringCalculator</code>，它的第一个需求是“对于空字符串，<code>add</code> 方法应返回0”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 红：编写一个失败的测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">should_returnZero_when_inputIsEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringCalculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringCalculator</span>(); <span class="comment">// 可能编译失败</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> calculator.add(<span class="string">&quot;&quot;</span>); <span class="comment">// 可能编译失败</span></span><br><span class="line">    assertEquals(<span class="number">0</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，<code>StringCalculator</code> 类和 <code>add</code> 方法都不存在，代码无法编译。</p>
<p><strong>第二步：绿 (Green) - 编写最少的代码让测试通过</strong></p>
<ol>
<li><strong>编写生产代码</strong>：编写<strong>最简单、最直接</strong>的代码，仅仅为了让刚刚那个红色的测试变绿。</li>
<li><strong>不做多余的事</strong>：在这一步，你<strong>不需要考虑代码的优雅、效率或未来的扩展性</strong>。你的唯一目标就是让测试通过。哪怕是返回一个硬编码的常量，只要能让测试通过就行。这种“作弊”式的写法是完全被允许甚至被鼓励的，因为它能让你保持专注。</li>
<li><strong>运行测试</strong>：再次运行所有测试。</li>
<li><strong>看到绿色</strong>：现在，所有的测试都应该通过了。你看到了一个绿色的条。</li>
</ol>
<p><strong>示例</strong>：为了让 <code>should_returnZero_when_inputIsEmpty</code> 通过，我们编写最少的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringCalculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(String numbers)</span> &#123;</span><br><span class="line">        <span class="comment">// 最简单的实现，让测试通过</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在再运行测试，它会变绿。</p>
<p><strong>第三步：重构 (Refactor) - 消除重复，改善设计</strong></p>
<ol>
<li><strong>审视代码</strong>：现在测试是绿色的，你有了一张“安全网”。你可以放心地审视刚刚编写的生产代码和测试代码，寻找改进的机会。</li>
<li><strong>进行重构</strong>：<ul>
<li>消除重复（DRY - Don’t Repeat Yourself）。</li>
<li>提高代码的可读性（例如，重命名变量、提取方法）。</li>
<li>改善设计（例如，引入新的类或设计模式）。</li>
<li>移除硬编码的“魔法值”。</li>
</ul>
</li>
<li><strong>持续运行测试</strong>：在重构的每一步之后，都应该再次运行测试，确保它们<strong>始终保持绿色</strong>。这保证了你的重构没有破坏任何已有的功能。</li>
</ol>
<p><strong>示例</strong>：在我们的例子中，代码 <code>return 0;</code> 已经足够简单，暂时不需要重构。</p>
<p>现在，我们开始下一个需求：“对于单个数字，<code>add</code> 方法应返回该数字本身”。我们重新开始“红-绿-重构”循环。</p>
<ul>
<li><p><strong>红</strong>：添加新测试 <code>should_returnNumber_when_inputIsSingleNumber</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">should_returnNumber_when_inputIsSingleNumber</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringCalculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringCalculator</span>();</span><br><span class="line">    assertEquals(<span class="number">5</span>, calculator.add(<span class="string">&quot;5&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试，这个新测试会失败（因为 <code>add(&quot;5&quot;)</code> 会返回0，而不是5）。</p>
</li>
<li><p><strong>绿</strong>：修改生产代码让新测试通过，同时保证旧测试仍然通过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(String numbers)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Integer.parseInt(numbers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行所有测试，全部变绿。</p>
</li>
<li><p><strong>重构</strong>：代码依然很简单，无需重构。</p>
</li>
</ul>
<p>通过不断重复这个短小精悍的循环，功能被逐步地、安全地构建起来，并且始终有一套完整的测试集保驾护航。</p>
<hr>
<h5 id="2-TDD-如何驱动出更好的代码设计"><a href="#2-TDD-如何驱动出更好的代码设计" class="headerlink" title="2. TDD 如何驱动出更好的代码设计"></a>2. TDD 如何驱动出更好的代码设计</h5><p>TDD 不仅仅是“先写测试”，它从根本上影响着代码的设计，使其朝着更优良的方向演进。</p>
<ol>
<li><strong>可测试性 (Testability) 成为首要目标</strong>：<br>因为你必须先为代码编写测试，所以你自然会被“逼迫”去思考“如何让这段代码变得容易测试？”。这种思考会引导你自然地遵循优秀的设计原则：<ul>
<li><strong>单一职责原则 (SRP)</strong>：为了方便测试，你会倾向于编写短小的、只做一件事的类和方法。一个庞大而复杂的类是极难测试的。</li>
<li><strong>依赖倒置原则 (DIP)</strong>：为了隔离依赖，你会倾向于面向接口编程，而不是面向具体实现，这样就可以轻松地在测试中用 Mock 替换真实依赖。</li>
</ul>
</li>
<li><strong>只编写必要的代码 (YAGNI - You Ain’t Gonna Need It)</strong>：<br>TDD 让你只编写那些能让当前失败的测试通过的代码。你不会去实现那些“将来可能有用”但当前需求并未要求的功能。这使得代码库保持精简，避免了过度工程。</li>
<li><strong>提供快速反馈，鼓励小步快跑</strong>：<br>TDD 的短循环提供了持续、快速的反馈。这使得开发者能够随时验证自己的想法，并以很小的成本进行试错和调整，从而更有信心地进行开发。</li>
<li><strong>充当代码的“活文档”</strong>：<br>最终产出的测试集本身就是一份最精确、最新的代码使用文档。任何想了解一个类如何使用的人，都可以通过阅读它的测试用例来快速掌握。</li>
<li><strong>赋予重构的勇气</strong>：<br>这是 TDD 带来的最大心理收益。由于有一套完整的、可信赖的测试集作为安全网，开发者可以毫无畏惧地对代码进行大规模的重构和优化，因为任何破坏性的修改都会被测试立刻捕捉到。没有 TDD，大规模的重构几乎是不可能的。</li>
</ol>
<p><strong>TDD 的挑战</strong>：</p>
<ul>
<li><strong>学习曲线</strong>：TDD 需要改变开发者根深蒂固的编程习惯，初期可能会感到不适应和效率低下。</li>
<li><strong>需要训练</strong>：如何将一个大需求拆分成小的、可测试的步骤，是一项需要练习才能掌握的技能。</li>
<li><strong>不适用于所有场景</strong>：对于探索性的编程、GUI 开发或一些高度依赖外部框架的场景，严格的 TDD 可能不那么适用或需要调整。</li>
</ul>
<hr>
<h4 id="3-3-2-BDD-Behavior-Driven-Development"><a href="#3-3-2-BDD-Behavior-Driven-Development" class="headerlink" title="3.3.2 BDD (Behavior-Driven Development)"></a>3.3.2 BDD (Behavior-Driven Development)</h4><p>行为驱动开发（BDD）是一种敏捷软件开发实践，它鼓励团队中的开发者、QA（质量保证）和非技术背景的业务分析师（BA）或产品经理（PO）之间进行协作。BDD 的核心目标是<strong>使用一种通用的、人类可读的语言来描述软件的预期行为</strong>，从而确保所有人对需求的理解都是一致的。</p>
<p>BDD 可以看作是 TDD 的一个“超集”或“演进”，它继承了 TDD 的技术实践，但将焦点从“测试”提升到了“行为”和“协作”。</p>
<h5 id="1-从业务需求出发：Gherkin-语言-Given-When-Then"><a href="#1-从业务需求出发：Gherkin-语言-Given-When-Then" class="headerlink" title="1. 从业务需求出发：Gherkin 语言 (Given-When-Then)"></a>1. 从业务需求出发：Gherkin 语言 (Given-When-Then)</h5><p>BDD 的基石是一种名为 <strong>Gherkin</strong> 的简单结构化语言。Gherkin 使得我们可以用近乎自然语言的方式来编写<strong>可执行的规约（Executable Specifications）</strong>。这些规约既是需求文档，也是自动化测试的脚本。</p>
<p>Gherkin 的核心结构是 <strong>Given-When-Then</strong>：</p>
<ul>
<li><strong>Given (给定)</strong>：描述一个<strong>初始的上下文或前置条件</strong>。它负责搭建场景。<ul>
<li>例如：<code>Given 我是一个已登录的用户</code></li>
<li>例如：<code>Given 我的购物车里有一个价格为 100 元的商品</code></li>
</ul>
</li>
<li><strong>When (当)</strong>：描述一个<strong>触发事件或用户行为</strong>。这是被测试的核心动作。<ul>
<li>例如：<code>When 我点击“添加到购物车”按钮</code></li>
<li>例如：<code>When 我进行结算</code></li>
</ul>
</li>
<li><strong>Then (那么)</strong>：描述一个<strong>预期的结果或输出</strong>。这是需要验证的断言。<ul>
<li>例如：<code>Then 我的购物车商品数量应该变为 1</code></li>
<li>例如：<code>Then 我应该看到一条“订单已成功创建”的消息</code></li>
</ul>
</li>
</ul>
<p><strong>一个完整的 BDD 场景（Scenario）示例</strong>：</p>
<p>用 Gherkin 编写的 BDD 场景通常保存在 <code>.feature</code> 文件中。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件名: atm_withdrawal.feature</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Feature</span>: 银行账户取款</span><br><span class="line"></span><br><span class="line">  为了能够管理我的现金</span><br><span class="line">  作为一个银行账户持有人</span><br><span class="line">  我希望可以从ATM机取款</span><br><span class="line"></span><br><span class="line">  <span class="keyword">Scenario</span>: 账户余额充足时取款</span><br><span class="line">    <span class="keyword">Given</span> 我的银行账户余额为 1000 元</span><br><span class="line">    <span class="keyword">And</span> ATM 机里有足够的现金</span><br><span class="line">    <span class="keyword">When</span> 我请求取出 200 元</span><br><span class="line">    <span class="keyword">Then</span> 我的银行账户余额应变为 800 元</span><br><span class="line">    <span class="keyword">And</span> 我应该收到 200 元现金</span><br><span class="line"></span><br><span class="line">  <span class="keyword">Scenario</span>: 账户余额不足时取款</span><br><span class="line">    <span class="keyword">Given</span> 我的银行账户余额为 100 元</span><br><span class="line">    <span class="keyword">When</span> 我请求取出 200 元</span><br><span class="line">    <span class="keyword">Then</span> 我不应该收到任何现金</span><br><span class="line">    <span class="keyword">And</span> 我应该看到一条 <span class="string">&quot;余额不足&quot;</span> 的错误消息</span><br></pre></td></tr></table></figure>

<p><strong>Gherkin 的价值</strong>：</p>
<ul>
<li><strong>消除歧义</strong>：这份 <code>.feature</code> 文件成为了业务人员、开发人员和测试人员沟通的共同语言和唯一事实来源（Single Source of Truth）。</li>
<li><strong>活文档 (Living Documentation)</strong>：由于这些 Gherkin 脚本是可执行的，它们永远不会过时。只要自动化测试能通过，就证明了软件的行为与文档描述完全一致。</li>
</ul>
<hr>
<h5 id="2-工具简介：Cucumber"><a href="#2-工具简介：Cucumber" class="headerlink" title="2. 工具简介：Cucumber"></a>2. 工具简介：Cucumber</h5><p><strong>Cucumber</strong> 是实现 BDD 和执行 Gherkin 脚本的最著名工具。它能够“阅读”<code>.feature</code> 文件，并将其中的每一个步骤（Given, When, Then）与实际的 Java 代码（或其他语言代码）进行“粘合”。</p>
<p>Cucumber 的工作流程：</p>
<ol>
<li><strong>编写 <code>.feature</code> 文件</strong>：如上例所示，由团队（包括非技术人员）共同编写。</li>
<li><strong>生成步骤定义 (Step Definitions) 的骨架</strong>：当你第一次运行 Cucumber 时，它会发现这些 Gherkin 步骤还没有对应的代码，并为你生成需要实现的 Java 方法的骨架。</li>
<li><strong>编写步骤定义代码</strong>：开发者需要填充这些骨架方法，将自然语言的步骤翻译成具体的代码操作。</li>
</ol>
<p><strong>示例：为上述 Gherkin 场景编写 Java 步骤定义</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtmStepDefinitions</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">private</span> Atm atm;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Given(&quot;我的银行账户余额为 &#123;int&#125; 元&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">my_account_balance_is</span><span class="params">(Integer initialBalance)</span> &#123;</span><br><span class="line">        account = <span class="keyword">new</span> <span class="title class_">Account</span>(initialBalance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Given(&quot;ATM 机里有足够的现金&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">atm_has_enough_money</span><span class="params">()</span> &#123;</span><br><span class="line">        atm = <span class="keyword">new</span> <span class="title class_">Atm</span>(<span class="number">2000</span>); <span class="comment">// 假设ATM机有2000元</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@When(&quot;我请求取出 &#123;int&#125; 元&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">i_request_to_withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        atm.withdraw(account, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Then(&quot;我的银行账户余额应变为 &#123;int&#125; 元&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">my_account_balance_should_be</span><span class="params">(Integer finalBalance)</span> &#123;</span><br><span class="line">        assertEquals(finalBalance.intValue(), account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Then(&quot;我应该收到 &#123;int&#125; 元现金&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">i_should_receive_cash</span><span class="params">(Integer dispensedAmount)</span> &#123;</span><br><span class="line">        assertEquals(dispensedAmount.intValue(), atm.getCashDispensed());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 为“余额不足”场景编写其他的 Then 步骤定义 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Cucumber 使用注解（如 <code>@Given</code>, <code>@When</code>, <code>@Then</code>）和正则表达式来将 Gherkin 文本与 Java 方法进行匹配。</li>
<li>在这些方法内部，你可以进行任何 Java 操作：创建对象、调用 Service、与数据库交互、进行断言等。</li>
</ul>
<hr>
<h5 id="3-BDD-与-TDD-的关系"><a href="#3-BDD-与-TDD-的关系" class="headerlink" title="3. BDD 与 TDD 的关系"></a>3. BDD 与 TDD 的关系</h5><p>BDD 和 TDD 并不是相互排斥的，它们是相辅相成的，可以看作是不同粒度上的“测试驱动”。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>TDD (测试驱动开发)</th>
<th>BDD (行为驱动开发)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>驱动力</strong></td>
<td><strong>开发者</strong>对代码单元的期望</td>
<td><strong>业务</strong>对软件整体行为的期望</td>
</tr>
<tr>
<td><strong>焦点</strong></td>
<td><strong>单元 (Unit)</strong> 的正确性（代码如何工作）</td>
<td><strong>行为 (Behavior)</strong> 的正确性（软件做什么）</td>
</tr>
<tr>
<td><strong>语言</strong></td>
<td><strong>技术语言</strong> (JUnit, xUnit 测试代码)</td>
<td><strong>业务语言</strong> (Gherkin: Given-When-Then)</td>
</tr>
<tr>
<td><strong>协作方</strong></td>
<td>主要是<strong>开发者</strong>自己</td>
<td><strong>开发者、QA、业务分析师</strong> (The Three Amigos)</td>
</tr>
<tr>
<td><strong>粒度</strong></td>
<td><strong>小循环 (内循环)</strong>：红-绿-重构一个类或方法</td>
<td><strong>大循环 (外循环)</strong>：定义一个业务场景 -&gt; 实现它 -&gt; 通过测试</td>
</tr>
<tr>
<td><strong>关系</strong></td>
<td>BDD 是 TDD 思想的<strong>扩展和演进</strong></td>
<td>BDD 可以驱动 TDD</td>
</tr>
</tbody></table>
<p><strong>BDD 如何驱动 TDD？（“双循环”模式）</strong></p>
<p>在一个理想的 BDD&#x2F;TDD 工作流中，开发者会这样工作：</p>
<ol>
<li><strong>外循环（BDD） - 红</strong>：<ul>
<li>运行整个 <code>.feature</code> 文件，由于步骤定义或底层逻辑还未实现，这个 BDD 场景测试会失败（通常是 Pending 状态或失败）。</li>
</ul>
</li>
<li><strong>内循环（TDD） - 红-绿-重构</strong>：<ul>
<li>为了让 BDD 场景中的某一个步骤（例如 <code>When 我进行结算</code>）能够工作，开发者会发现需要一个新的类或方法（例如 <code>OrderService.checkout()</code>）。</li>
<li>此时，开发者切换到 TDD 模式，开始为 <code>OrderService.checkout()</code> 编写一个失败的<strong>单元测试</strong>（红）。</li>
<li>编写最少的代码让这个<strong>单元测试</strong>通过（绿）。</li>
<li>重构代码。</li>
<li>重复这个 TDD 循环，直到所有需要的底层单元都被实现并通过了单元测试。</li>
</ul>
</li>
<li><strong>外循环（BDD） - 绿</strong>：<ul>
<li>现在，底层的代码逻辑已经通过 TDD 实现好了。开发者回到 BDD 的步骤定义代码中，将它们“粘合”起来。</li>
<li>再次运行整个 <code>.feature</code> 文件，这一次，这个 BDD 场景测试应该会<strong>通过</strong>。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="4-追求极致质量"><a href="#4-追求极致质量" class="headerlink" title="4. 追求极致质量"></a>4. 追求极致质量</h2><h3 id="4-1-自动化与-CI-CD-集成"><a href="#4-1-自动化与-CI-CD-集成" class="headerlink" title="4.1 自动化与 CI&#x2F;CD 集成"></a>4.1 自动化与 CI&#x2F;CD 集成</h3><p>编写单元测试只是第一步。为了真正发挥其“安全网”的作用，测试必须被<strong>自动化</strong>地、<strong>频繁地</strong>执行。持续集成（Continuous Integration, CI）和持续交付（Continuous Delivery, CD）流水线是实现这一目标的核心平台。</p>
<hr>
<h4 id="4-1-1-在构建工具中运行测试-Maven-Surefire-Gradle-test-task"><a href="#4-1-1-在构建工具中运行测试-Maven-Surefire-Gradle-test-task" class="headerlink" title="4.1.1 在构建工具中运行测试 (Maven Surefire &#x2F; Gradle test task)"></a><strong>4.1.1 在构建工具中运行测试 (Maven Surefire &#x2F; Gradle <code>test</code> task)</strong></h4><p>在将测试集成到 CI&#x2F;CD 之前，我们首先要确保它们可以在本地通过标准的构建工具命令来执行。这是自动化的基础。</p>
<h5 id="1-Maven-Surefire-插件"><a href="#1-Maven-Surefire-插件" class="headerlink" title="1. Maven: Surefire 插件"></a>1. Maven: Surefire 插件</h5><ul>
<li><p><strong>角色</strong>：<code>maven-surefire-plugin</code> 是 Maven 中负责<strong>运行单元测试</strong>的核心插件。它被绑定到 Maven 标准生命周期的 <code>test</code> 阶段。</p>
</li>
<li><p><strong>如何工作</strong>：当你执行 <code>mvn test</code> 或 <code>mvn verify</code> 或 <code>mvn install</code> 时，Maven 在执行到 <code>test</code> 阶段时会自动调用 Surefire 插件。</p>
</li>
<li><p><strong>约定</strong>：Surefire 默认会扫描 <code>src/test/java</code> 目录下所有符合以下命名约定的类并执行它们：</p>
<ul>
<li><code>**/*Test.java</code></li>
<li><code>**/Test*.java</code></li>
<li><code>**/*TestCase.java</code><br>这就是为什么我们通常将测试类命名为 <code>XxxTest.java</code>。</li>
</ul>
</li>
<li><p><strong>配置 (pom.xml)</strong>：通常你不需要任何显式配置，因为它是标准构建的一部分。但有时你可能需要自定义，例如，跳过测试。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 建议使用较新版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 例如，跳过测试 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;skipTests&gt;true&lt;/skipTests&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>命令</strong>：</p>
<ul>
<li><code>mvn test</code>: 编译代码并运行所有单元测试。</li>
<li><code>mvn clean install</code>: 清理、编译、测试、打包并安装到本地仓库。<strong>如果任何一个测试失败，整个构建过程会立即中断</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-Gradle-test-任务"><a href="#2-Gradle-test-任务" class="headerlink" title="2. Gradle: test 任务"></a>2. Gradle: <code>test</code> 任务</h5><ul>
<li><p><strong>角色</strong>：在 Gradle 中，<code>java</code> 插件会自动创建一个名为 <code>test</code> 的任务，它负责编译和运行测试。</p>
</li>
<li><p><strong>如何工作</strong>：当你执行 <code>./gradlew test</code> 或 <code>./gradlew build</code> 时，<code>test</code> 任务会被触发。</p>
</li>
<li><p><strong>约定</strong>：与 Maven 类似，它默认扫描 <code>src/test/java</code> 目录下的测试类。</p>
</li>
<li><p><strong>配置 (build.gradle)</strong>：<code>test</code> 任务可以被非常灵活地配置。最常见的是指定使用 JUnit 5 (JUnit Platform)。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build.gradle (Groovy DSL)</span></span><br><span class="line">test &#123;</span><br><span class="line">    useJUnitPlatform() <span class="comment">// 告诉 Gradle 使用 JUnit 5 的测试平台</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在这里配置系统属性、环境变量等</span></span><br><span class="line">    systemProperty <span class="string">&#x27;some.property&#x27;</span>, <span class="string">&#x27;value&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤测试</span></span><br><span class="line">    <span class="comment">// filter &#123;</span></span><br><span class="line">    <span class="comment">//     includeTestsMatching &quot;*MySpecificTest&quot;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>命令</strong>：</p>
<ul>
<li><code>./gradlew test</code>: 编译并运行所有测试。</li>
<li><code>./gradlew build</code>: 执行包括编译、测试、打包在内的一系列任务。<strong>如果 <code>test</code> 任务失败，<code>build</code> 任务也会失败</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-1-2-将测试集成到-CI-CD-流水线-Jenkins-GitLab-CI-GitHub-Actions"><a href="#4-1-2-将测试集成到-CI-CD-流水线-Jenkins-GitLab-CI-GitHub-Actions" class="headerlink" title="4.1.2 将测试集成到 CI&#x2F;CD 流水线 (Jenkins, GitLab CI, GitHub Actions)"></a><strong>4.1.2 将测试集成到 CI&#x2F;CD 流水线 (Jenkins, GitLab CI, GitHub Actions)</strong></h4><p>CI&#x2F;CD 流水线（Pipeline）的核心理念是自动化从代码提交到部署的整个过程。单元测试是这个流水线中<strong>第一个也是最重要的质量门禁</strong>。</p>
<h5 id="1-核心配置：构建失败-on-测试失败"><a href="#1-核心配置：构建失败-on-测试失败" class="headerlink" title="1. 核心配置：构建失败 on 测试失败"></a>1. 核心配置：构建失败 on 测试失败</h5><p>这是 CI&#x2F;CD 集成中最关键的一步。流水线必须被配置为：<strong>一旦测试执行失败，整个流水线立即停止并标记为“失败”</strong>。</p>
<p>这会带来几个巨大的好处：</p>
<ul>
<li><strong>快速反馈</strong>：代码提交者会立即收到通知（通过邮件、Slack等），知道自己的提交破坏了构建。</li>
<li><strong>防止缺陷流入主干</strong>：失败的构建无法被合并到主分支（<code>main</code> &#x2F; <code>master</code>），从而保护了代码库的健康。</li>
<li><strong>建立团队责任感</strong>：修复构建失败成为团队的最高优先级任务（“Stop the line”文化）。</li>
</ul>
<p>幸运的是，所有主流的 CI&#x2F;CD 工具都将这作为默认行为。因为构建命令（如 <code>mvn install</code> 或 <code>./gradlew build</code>）在测试失败时会返回一个非零的退出码，CI&#x2F;CD 工具会捕获这个退出码并自动将该阶段标记为失败。</p>
<hr>
<h5 id="2-在不同-CI-CD-工具中的实现"><a href="#2-在不同-CI-CD-工具中的实现" class="headerlink" title="2. 在不同 CI&#x2F;CD 工具中的实现"></a>2. 在不同 CI&#x2F;CD 工具中的实现</h5><p>下面是在三种主流 CI&#x2F;CD 工具中配置测试阶段的简化示例。</p>
<ul>
<li><p><strong>Jenkins (使用 Jenkinsfile - 声明式流水线)</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Jenkinsfile</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">&#x27;mvn --version&#x27;</span> <span class="comment">// 打印工具版本，是个好习惯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Test&#x27;</span>) &#123; <span class="comment">// 定义一个专门的“Test”阶段</span></span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="comment">// 对于 Maven 项目</span></span><br><span class="line">                sh <span class="string">&#x27;mvn clean verify&#x27;</span> </span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 对于 Gradle 项目</span></span><br><span class="line">                <span class="comment">// sh &#x27;./gradlew clean build&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... 其他阶段，如 Deploy ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 Jenkins 执行到 <code>Test</code> 阶段时，如果 <code>mvn verify</code> 命令失败，整个流水线就会变红并停止。</p>
</li>
<li><p><strong>GitLab CI (使用 <code>.gitlab-ci.yml</code>)</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .gitlab-ci.yml</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">maven:3.8-openjdk-17</span> <span class="comment"># 使用一个包含 Maven 和 Java 的 Docker 镜像</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mvn</span> <span class="string">compile</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mvn</span> <span class="string">test</span> <span class="comment"># 运行测试</span></span><br><span class="line">  <span class="attr">artifacts:</span> <span class="comment"># 收集产物</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">always</span> <span class="comment"># 无论成功失败，都收集报告</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">target/surefire-reports/</span> <span class="comment"># Surefire 的 XML 报告</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">target/site/jacoco/</span> <span class="comment"># JaCoCo 的 HTML 覆盖率报告</span></span><br><span class="line">    <span class="attr">reports:</span></span><br><span class="line">      <span class="attr">junit:</span> <span class="string">target/surefire-reports/TEST-*.xml</span> <span class="comment"># 告诉 GitLab 这是 JUnit 报告</span></span><br></pre></td></tr></table></figure>

<p>GitLab CI 有内置的 JUnit 报告解析功能，可以在合并请求（Merge Request）的 UI 中直接展示测试结果。</p>
</li>
<li><p><strong>GitHub Actions (使用 workflow yml)</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .github/workflows/build.yml</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Java</span> <span class="string">CI</span> <span class="string">with</span> <span class="string">Maven</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>, <span class="string">pull_request</span>] <span class="comment"># 在 push 和 pull_request 时触发</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">code</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">JDK</span> <span class="number">17</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-java@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">java-version:</span> <span class="string">&#x27;17&#x27;</span></span><br><span class="line">        <span class="attr">distribution:</span> <span class="string">&#x27;temurin&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">test</span> <span class="string">with</span> <span class="string">Maven</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">mvn</span> <span class="string">-B</span> <span class="string">verify</span> <span class="comment"># -B 表示 batch mode，适合 CI 环境</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">Test</span> <span class="string">Report</span> <span class="comment"># 上传测试报告作为构建产物</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">always()</span> <span class="comment"># 无论成功失败都执行</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/upload-artifact@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">surefire-report</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">target/surefire-reports/</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">Code</span> <span class="string">Coverage</span> <span class="string">Report</span> <span class="comment"># 上传覆盖率报告</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">success()</span> <span class="comment"># 只在成功时上传</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/upload-artifact@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">jacoco-report</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">target/site/jacoco/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="3-自动生成并发布测试报告和覆盖率报告"><a href="#3-自动生成并发布测试报告和覆盖率报告" class="headerlink" title="3. 自动生成并发布测试报告和覆盖率报告"></a>3. 自动生成并发布测试报告和覆盖率报告</h5><ul>
<li><strong>测试报告 (Test Reports)</strong>：<ul>
<li>构建工具（Surefire&#x2F;Gradle）在运行时会生成 XML 格式的测试报告（通常是 JUnit XML 格式）。</li>
<li>CI&#x2F;CD 工具（如 GitLab, Jenkins with a plugin）可以解析这些 XML 文件，并在 Web UI 上以友好的方式展示：<ul>
<li>总共运行了多少测试？</li>
<li>哪些测试失败了？失败的原因和堆栈是什么？</li>
<li>测试运行了多久？</li>
</ul>
</li>
<li>这使得开发者无需登录到构建服务器查看日志，就能快速诊断问题。</li>
</ul>
</li>
<li><strong>覆盖率报告 (Coverage Reports)</strong>：<ul>
<li>我们之前配置的 JaCoCo 插件会在测试执行后生成一个 HTML 格式的覆盖率报告。</li>
<li>我们可以将这个 HTML 报告作为 CI&#x2F;CD 的**构建产物（Artifact）**进行归档和发布。</li>
<li>这样，团队成员就可以通过点击构建结果页面的链接，直接在线浏览详细的代码覆盖率报告，查看哪些代码行或分支没有被测试覆盖到。</li>
<li>一些更高级的集成（如 SonarQube）还可以对覆盖率进行历史趋势分析，并在覆盖率下降时发出警告。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-2-高级质量保证技术"><a href="#4-2-高级质量保证技术" class="headerlink" title="4.2 高级质量保证技术"></a>4.2 高级质量保证技术</h3><h4 id="4-2-1-变异测试-Mutation-Testing"><a href="#4-2-1-变异测试-Mutation-Testing" class="headerlink" title="4.2.1 变异测试 (Mutation Testing)"></a>4.2.1 变异测试 (Mutation Testing)</h4><p><strong>它是什么？(测试你的测试)</strong></p>
<p>代码覆盖率告诉我们<strong>哪些代码被执行了</strong>，但它并不能告诉我们这些代码的<strong>行为是否被有效地验证了</strong>。一个没有断言的测试也能贡献100%的覆盖率，但这毫无意义。</p>
<p><strong>变异测试 (Mutation Testing)</strong> 正是为了弥补这一缺陷而生。它的核心思想是：</p>
<blockquote>
<p><strong>如果我稍微修改一下你的生产代码，而你的测试套件依然全部通过，那么你的测试很可能不够好，因为它没有发现这个“bug”。</strong></p>
</blockquote>
<p>变异测试工具会自动地、系统性地对你的生产代码进行微小的、符合语法规则的修改，生成大量的“<strong>变异体 (Mutants)</strong>”。然后，它会为每一个变异体运行你的全部单元测试。</p>
<ul>
<li><strong>变异体被杀死 (Killed)</strong>：如果某个变异体导致了至少一个测试失败，那么恭喜你，你的测试成功地“杀死”了这个变异体。这说明你的测试能够检测到这种类型的代码变更。</li>
<li><strong>变异体存活 (Survived)</strong>：如果一个变异体被创建后，你的所有测试依然全部通过，那么这个变异体就“存活”了下来。这是一个<strong>危险信号</strong>，它意味着你的测试存在漏洞，无法发现这种潜在的 bug。</li>
</ul>
<p><strong>常见的变异操作 (Mutators)</strong>：</p>
<ul>
<li><strong>条件边界变异</strong>：将 <code>&gt;</code> 变为 <code>&gt;=</code>。</li>
<li><strong>布尔值替换</strong>：将 <code>true</code> 变为 <code>false</code>。</li>
<li><strong>数学运算符替换</strong>：将 <code>+</code> 变为 <code>-</code>。</li>
<li><strong>返回值替换</strong>：将 <code>return value;</code> 变为 <code>return null;</code> 或 <code>return 0;</code>。</li>
<li><strong>方法调用删除</strong>：直接移除一个 <code>void</code> 方法的调用。</li>
</ul>
<p><strong>变异测试得分</strong>：最终，你会得到一个变异覆盖率得分，即 <code>(被杀死的变异体数量 / 总变异体数量) * 100%</code>。这个分数比传统的代码覆盖率更能真实地反映你测试的质量。</p>
<p><strong>工具：Pitest (PIT)</strong></p>
<p><strong>Pitest (或 PIT)</strong> 是 Java 生态中最流行、最成熟的变异测试框架。</p>
<ul>
<li><p><strong>集成方式</strong>：它提供了 Maven 和 Gradle 插件，可以轻松集成到你的构建流程中。</p>
</li>
<li><p><strong>Maven 配置示例</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.pitest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pitest-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- PIT 与 JUnit 5 的集成 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.pitest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pitest-junit5-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">targetClasses</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span>&gt;</span>com.example.myproject.*<span class="tag">&lt;/<span class="name">param</span>&gt;</span> <span class="comment">&lt;!-- 指定要变异的类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">targetClasses</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">targetTests</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span>&gt;</span>com.example.myproject.*&lt;/*Test.java&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">targetTests</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>如何运行</strong>：<code>mvn org.pitest:pitest-maven:mutationCoverage</code></p>
</li>
<li><p><strong>报告</strong>：Pitest 会生成一个非常详细的 HTML 报告，精确地告诉你哪个变异体存活了下来，以及它是在代码的哪一行被创建的。这为你改进测试提供了极其精确的指导。</p>
</li>
</ul>
<p><strong>缺点</strong>：变异测试的计算量非常大（它需要为成百上千个变异体重复运行测试），因此速度很慢。通常只在 CI&#x2F;CD 的夜间构建或发布构建中运行，而不是在每次提交时都运行。</p>
<hr>
<h4 id="4-2-2-性能基准测试-Benchmark-Testing"><a href="#4-2-2-性能基准测试-Benchmark-Testing" class="headerlink" title="4.2.2 性能基准测试 (Benchmark Testing)"></a>4.2.2 性能基准测试 (Benchmark Testing)</h4><p>单元测试验证代码的<strong>正确性</strong>，而性能基准测试（或称微基准测试）则衡量代码的<strong>性能</strong>（如执行时间、吞吐量、内存分配等）。</p>
<p><strong>为什么要用 JMH 而不是 <code>System.currentTimeMillis()</code>？</strong></p>
<p>自己写一个循环，用 <code>System.currentTimeMillis()</code> 或 <code>System.nanoTime()</code> 来计算代码执行时间是<strong>极其错误和不准确的</strong>。因为 Java 虚拟机 (JVM) 是一个非常复杂的动态系统，很多因素会严重影响代码的真实性能，而简单的计时无法解决这些问题：</p>
<ul>
<li><strong>JIT 编译 (Just-In-Time Compilation)</strong>：JVM 会在运行时将热点代码编译成本地机器码以提高性能。你的代码可能在前几次循环中是解释执行，后面是编译执行，性能完全不同。</li>
<li><strong>死码消除 (Dead Code Elimination)</strong>：如果 JIT 编译器发现你的代码计算结果没有被使用，它可能会直接优化掉整段代码，导致你测量的执行时间为零。</li>
<li><strong>预热 (Warm-up)</strong>：JVM 需要一段时间“预热”才能达到稳定的最佳性能状态。</li>
<li><strong>垃圾回收 (GC)</strong>：GC 的发生会随机地中断你的代码执行，造成计时偏差。</li>
</ul>
<p><strong>JMH (Java Microbenchmark Harness)</strong></p>
<p>JMH 是由 Oracle官方（OpenJDK团队）开发的、用于编写和运行 Java 微基准测试的框架。它是一个旨在解决上述所有问题的专业工具，是进行 Java 性能测试的<strong>黄金标准</strong>。</p>
<ul>
<li><p><strong>核心特性</strong>：</p>
<ul>
<li><strong>自动处理预热</strong>：JMH 会在正式测量前，先执行若干轮“预热”迭代。</li>
<li><strong>多轮迭代与测量</strong>：它会进行多轮独立的测量，并对结果进行统计分析，以减少偶然因素的影响。</li>
<li><strong>防止优化</strong>：它通过巧妙的设计（如 <code>Blackhole</code> 类）来防止 JIT 的死码消除等过度优化。</li>
<li><strong>支持多种模式</strong>：可以测量吞吐量 (Throughput)、平均时间 (AverageTime)、单次执行时间 (SingleShotTime) 等。</li>
</ul>
</li>
<li><p><strong>示例：比较 <code>String</code> 拼接和 <code>StringBuilder</code></strong></p>
<ol>
<li><p><strong>添加依赖</strong>: <code>jmh-core</code> 和 <code>jmh-generator-annprocess</code></p>
</li>
<li><p><strong>编写 Benchmark 类</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="meta">@State(Scope.Thread)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringConcatenationBenchmark</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testStringConcatenation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> str1 + str2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testStringBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(str1).append(str2).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行</strong>: JMH 测试通常需要通过一个 Main 方法来启动。</p>
</li>
</ol>
</li>
</ul>
<p><strong>结论</strong>：当你需要对一个关键算法或热点代码路径的性能进行精确评估和优化时，<strong>必须使用 JMH</strong>。任何其他手写的计时方法都是不可信的。</p>
<hr>
<h4 id="4-2-3-棘手问题：处理片状测试-Flaky-Tests"><a href="#4-2-3-棘手问题：处理片状测试-Flaky-Tests" class="headerlink" title="4.2.3 棘手问题：处理片状测试 (Flaky Tests)"></a>4.2.3 棘手问题：处理片状测试 (Flaky Tests)</h4><p><strong>片状测试</strong>是指那些在代码没有任何变更的情况下，时而通过、时而失败的测试。它们是 CI&#x2F;CD 流水线中最令人头疼的“毒瘤”，因为它们会：</p>
<ul>
<li><strong>侵蚀团队对测试的信任</strong>：当大家习惯了“哦，这个测试又随机失败了，重跑一下就好”时，真正的 Bug 就会被忽略。</li>
<li><strong>降低开发效率</strong>：开发者需要花费大量时间来重跑和排查这些不确定的失败。</li>
</ul>
<p><strong>常见原因与排查策略</strong>：</p>
<ol>
<li><strong>异步问题 (Asynchrony)</strong><ul>
<li><strong>原因</strong>：测试代码没有正确地等待一个异步操作完成就进行了断言。</li>
<li><strong>策略</strong>：<ul>
<li><strong>绝不使用 <code>Thread.sleep()</code></strong>。</li>
<li><strong>使用 Awaitility</strong> 或其他专用的异步测试工具，以轮询的方式等待一个确定的状态。</li>
<li>对于 <code>CompletableFuture</code>，使用 <code>.get()</code> 或 <code>.join()</code> 阻塞等待。</li>
</ul>
</li>
</ul>
</li>
<li><strong>资源竞争与状态共享 (Race Conditions &amp; Shared State)</strong><ul>
<li><strong>原因</strong>：多个测试（或一个测试的多个线程）共享和修改了同一个可变的状态，例如一个静态变量、一个共享的数据库记录、一个单例对象。</li>
<li><strong>策略</strong>：<ul>
<li><strong>严格遵循测试独立性原则</strong>。使用 <code>@BeforeEach</code> 为每个测试创建全新的对象和状态。</li>
<li><strong>避免使用静态可变状态</strong>。如果必须使用，确保在 <code>@AfterEach</code> 中将其重置。</li>
<li>在数据库测试中，确保每个测试都在一个独立的回滚事务中运行（<code>@DataJpaTest</code> 默认如此），或在测试后进行彻底的数据清理。</li>
</ul>
</li>
</ul>
</li>
<li><strong>对顺序的隐式依赖 (Order Dependency)</strong><ul>
<li><strong>原因</strong>：测试 A 的成功依赖于测试 B 已经先执行过。当测试执行器以不同顺序运行测试时，测试 A 就会失败。</li>
<li><strong>策略</strong>：<ul>
<li>每个测试都应该能独立运行。在 <code>@BeforeEach</code> 中准备好该测试所需的所有前置条件。</li>
<li>如果确实需要顺序，可以使用 JUnit 5 的 <code>@TestMethodOrder</code> 和 <code>@Order</code> 注解来<strong>显式地</strong>声明顺序，但这通常被视为一种“坏味道”，应优先重构。</li>
</ul>
</li>
</ul>
</li>
<li><strong>外部环境的不确定性 (External Dependencies)</strong><ul>
<li><strong>原因</strong>：测试依赖了不稳定的网络、会变化的系统时间、随机数生成器等。</li>
<li><strong>策略</strong>：<ul>
<li><strong>Mock 一切外部依赖</strong>。使用 Mockito 替换网络客户端，使用 Testcontainers 启动受控的数据库&#x2F;消息队列实例。</li>
<li>对于时间，注入一个 <code>java.time.Clock</code> 对象而不是直接调用 <code>LocalDateTime.now()</code>，这样在测试中就可以 Mock <code>Clock</code> 来返回一个固定的时间。</li>
<li>对于随机数，注入一个 <code>java.util.Random</code> 对象并给它一个固定的种子。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>处理片状测试的流程</strong>：</p>
<ol>
<li><strong>隔离</strong>：一旦发现片状测试，立即将其标记为 <code>@Disabled</code> 并附上原因，防止它继续阻塞流水线。</li>
<li><strong>复现</strong>：在本地循环运行该测试（<code>mvn test -Dtest=MyFlakyTest</code> 或 IDE 功能），尝试稳定地复现失败。</li>
<li><strong>分析</strong>：根据上述常见原因逐一排查。仔细检查代码，看是否存在共享状态、异步等待问题等。</li>
<li><strong>修复</strong>：应用正确的策略进行修复。</li>
<li><strong>验证</strong>：在修复后，多次运行该测试以确保其稳定性，然后再将其重新启用。</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/11/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%B4%A8%E9%87%8F/%E4%BA%8C%E3%80%81%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" rel="prev" title="二、代码规范">
                  <i class="fa fa-angle-left"></i> 二、代码规范
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/11/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%B4%A8%E9%87%8F/%E5%9B%9B%E3%80%81%E5%BC%80%E5%8F%91%E6%8F%90%E6%95%88%E8%A7%84%E8%8C%83/" rel="next" title="四、开发提效规范">
                  四、开发提效规范 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
