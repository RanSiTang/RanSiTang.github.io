<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="一、 实时通信的演进1. HTTP 的无状态性我们在”HTTP协议“这一笔  记中介绍了HTTP的核心特点无状态，这里简单回顾一下  定义：“无状态”指的是协议本身对于事务处理没有记忆能力。每一次 HTTP 请求都是完全独立的，服务器不会保留前一次请求的任何信息。 **优点 **： 简化服务器设计：服务器不需要花费额外的资源（如内存）来存储海量的客户端状态信息。 提升服务器的可伸缩性：由于服务器不">
<meta property="og:type" content="article">
<meta property="og:title" content="WebSocket">
<meta property="og:url" content="http://example.com/2025/10/18/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/WebSocket/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="一、 实时通信的演进1. HTTP 的无状态性我们在”HTTP协议“这一笔  记中介绍了HTTP的核心特点无状态，这里简单回顾一下  定义：“无状态”指的是协议本身对于事务处理没有记忆能力。每一次 HTTP 请求都是完全独立的，服务器不会保留前一次请求的任何信息。 **优点 **： 简化服务器设计：服务器不需要花费额外的资源（如内存）来存储海量的客户端状态信息。 提升服务器的可伸缩性：由于服务器不">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-18T03:22:31.000Z">
<meta property="article:modified_time" content="2025-10-21T01:38:51.529Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/10/18/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/WebSocket/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/10/18/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/WebSocket/","path":"2025/10/18/主流框架与工具库/WebSocket/","title":"WebSocket"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>WebSocket | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81-%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="nav-text">一、 实时通信的演进</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-HTTP-%E7%9A%84%E6%97%A0%E7%8A%B6%E6%80%81%E6%80%A7"><span class="nav-text">1. HTTP 的无状态性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%9F%BA%E4%BA%8E-HTTP-%E7%9A%84%E4%BC%AA%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1"><span class="nav-text">2. 基于 HTTP 的伪实时通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E7%9F%AD%E8%BD%AE%E8%AF%A2-Short-Polling"><span class="nav-text">2.1 短轮询 (Short Polling)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E9%95%BF%E8%BD%AE%E8%AF%A2-Long-Polling"><span class="nav-text">2.2 长轮询 (Long Polling)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-HTTP-%E6%B5%81-HTTP-Streaming"><span class="nav-text">2.3 HTTP 流 (HTTP Streaming)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-WebSocket-%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="nav-text">3. WebSocket 的诞生</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%AE%9A%E4%B9%89"><span class="nav-text">3.1 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF"><span class="nav-text">3.2 核心优势</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82"><span class="nav-text">二、协议底层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%A1%A5%E6%A2%81%EF%BC%9AHTTP-Upgrade-%E6%8F%A1%E6%89%8B%E6%9C%BA%E5%88%B6"><span class="nav-text">1. 连接的桥梁：HTTP Upgrade 握手机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8F%A1%E6%89%8B%E8%AF%B7%E6%B1%82"><span class="nav-text">1.1 客户端握手请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8F%A1%E6%89%8B%E5%93%8D%E5%BA%94"><span class="nav-text">1.2 服务端握手响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E6%8F%A1%E6%89%8B%E6%88%90%E5%8A%9F%E4%B9%8B%E5%90%8E%EF%BC%9A-%E8%BF%9E%E6%8E%A5%E6%AD%A3%E5%BC%8F%E4%BB%8E-HTTP-%E5%88%87%E6%8D%A2%E5%88%B0-WebSocket-%E5%8D%8F%E8%AE%AE%E3%80%82"><span class="nav-text">1.3 握手成功之后： 连接正式从 HTTP 切换到 WebSocket 协议。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%80%9A%E4%BF%A1%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8D%95%E5%85%83%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B8%A7-Data-Frame"><span class="nav-text">2. 通信的最小单元：数据帧 (Data Frame)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%B8%A7%E7%BB%93%E6%9E%84%E5%9B%BE%E8%A7%A3"><span class="nav-text">2.1 帧结构图解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%93%8D%E4%BD%9C%E7%A0%81-Opcode-%E5%88%86%E7%B1%BB"><span class="nav-text">2.2 操作码 (Opcode) 分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%AE%89%E5%85%A8%E4%B8%8E%E5%9C%B0%E5%9D%80%EF%BC%9Aws-vs-wss"><span class="nav-text">3. 安全与地址：ws:&#x2F;&#x2F; vs wss:&#x2F;&#x2F;</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81Java-%E5%8E%9F%E7%94%9F-API-JSR-356"><span class="nav-text">三、Java 原生 API (JSR 356)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0%E4%B8%8E%E4%BE%9D%E8%B5%96"><span class="nav-text">1. 概述与依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-JSR-356-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FJava-EE-Jakarta-EE-%E7%9A%84%E6%A0%87%E5%87%86"><span class="nav-text">1.1 JSR 356 是什么？Java EE&#x2F;Jakarta EE 的标准</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE"><span class="nav-text">1.2 依赖配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="nav-text">1.3 何时使用？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E7%8E%B0"><span class="nav-text">2. 服务端实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%82%B9%E7%B1%BB%EF%BC%9A-ServerEndpoint-%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3"><span class="nav-text">2.1 服务端点类：@ServerEndpoint 注解详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E8%A7%A3"><span class="nav-text">2.2 生命周期注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-text">2.3 核心组件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="nav-text">3. 高级特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86%EF%BC%9A-ServerEndpoint-%E4%B8%8E-PathParam"><span class="nav-text">3.1 路径参数处理：@ServerEndpoint 与 @PathParam</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E9%85%8D%E7%BD%AE%E7%B1%BB-ServerEndpointConfig-Configurator-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">3.2 配置类 ServerEndpointConfig.Configurator 的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-text">4. 示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%92%8C%E4%BE%9D%E8%B5%96"><span class="nav-text">4.1 项目结构和依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%82%B9-ChatRoomEndpoint-java"><span class="nav-text">4.2 服务端点 ChatRoomEndpoint.java</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%90%AF%E7%94%A8-WebSocket-%E6%94%AF%E6%8C%81-ApplicationConfig-java"><span class="nav-text">4.3 启用 WebSocket 支持 (ApplicationConfig.java)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B5%8B%E8%AF%95-index-html"><span class="nav-text">4.4 客户端测试 (index.html)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B5%8B%E8%AF%95"><span class="nav-text">4.5 部署与测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81Spring-Boot-%E9%9B%86%E6%88%90%E5%8E%9F%E7%94%9F-WebSocket"><span class="nav-text">四、Spring Boot 集成原生 WebSocket</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E4%B8%89%E6%AD%A5%E8%B5%B0"><span class="nav-text">1. 核心三步走</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96"><span class="nav-text">1.1 添加依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E7%BC%96%E5%86%99%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-text">1.2 编写处理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E6%B3%A8%E5%86%8C%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-text">1.3 注册处理器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="nav-text">2. 核心组件详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Spring-%E5%B0%81%E8%A3%85%E7%9A%84%E4%BC%9A%E8%AF%9D%E5%AF%B9%E8%B1%A1"><span class="nav-text">2.1 Spring 封装的会话对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%8F%A1%E6%89%8B%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="nav-text">2.2 握手拦截器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%B6%88%E6%81%AF%E8%BD%BD%E4%BD%93%E5%AF%B9%E8%B1%A1"><span class="nav-text">2.3 消息载体对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%AE%9E%E8%B7%B5%E6%8A%80%E5%B7%A7"><span class="nav-text">3. 实践技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E7%AE%A1%E7%90%86%E6%89%80%E6%9C%89-WebSocketSession-%E5%AE%9E%E7%8E%B0%E5%B9%BF%E6%92%AD%E5%8A%9F%E8%83%BD"><span class="nav-text">3.1 管理所有 WebSocketSession 实现广播功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E7%BB%93%E5%90%88-HandshakeInterceptor-%E5%92%8C-WebSocketSession-%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E8%AF%86%E5%88%AB"><span class="nav-text">3.2 结合 HandshakeInterceptor 和 WebSocketSession 实现用户身份识别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="nav-text">4. 示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE-pom-xml"><span class="nav-text">4.1 项目设置 (pom.xml)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%88%9B%E5%BB%BA%E6%8F%A1%E6%89%8B%E6%8B%A6%E6%88%AA%E5%99%A8-UserStatusHandshakeInterceptor"><span class="nav-text">4.2 创建握手拦截器 (UserStatusHandshakeInterceptor)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%88%9B%E5%BB%BA-WebSocket-%E5%A4%84%E7%90%86%E5%99%A8-OnlineStatusHandler"><span class="nav-text">4.3 创建 WebSocket 处理器 (OnlineStatusHandler)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E9%85%8D%E7%BD%AE-WebSocket-WebSocketConfig"><span class="nav-text">4.4 配置 WebSocket (WebSocketConfig)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E5%88%9B%E5%BB%BA%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95%E9%A1%B5%E9%9D%A2-index-html"><span class="nav-text">4.5 创建前端测试页面 (index.html)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%E8%BF%90%E8%A1%8C%E5%92%8C%E6%B5%8B%E8%AF%95"><span class="nav-text">4.6 运行和测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81Spring-Boot-STOMP"><span class="nav-text">五、Spring Boot + STOMP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-STOMP%EF%BC%9F"><span class="nav-text">1. 为什么需要 STOMP？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%BC%BA%E4%B9%8F%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E6%B6%88%E6%81%AF%E8%AF%AD%E4%B9%89"><span class="nav-text">1.1 缺乏结构化的消息语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%B2%A1%E6%9C%89%E5%86%85%E7%BD%AE%E7%9A%84%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%EF%BC%88Pub-Sub%EF%BC%89%E5%92%8C%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6"><span class="nav-text">1.2 没有内置的发布&#x2F;订阅（Pub&#x2F;Sub）和路由机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E7%BC%BA%E4%B9%8F%E9%AB%98%E7%BA%A7%E6%B6%88%E6%81%AF%E7%89%B9%E6%80%A7"><span class="nav-text">1.3 缺乏高级消息特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E6%80%BB%E7%BB%93%E4%B8%8E%E7%B1%BB%E6%AF%94"><span class="nav-text">1.4 总结与类比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Spring-STOMP-%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE"><span class="nav-text">2. Spring STOMP 核心配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-EnableWebSocketMessageBroker"><span class="nav-text">2.1 @EnableWebSocketMessageBroker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-WebSocketMessageBrokerConfigurer-%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3"><span class="nav-text">2.2 WebSocketMessageBrokerConfigurer 接口详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-registerStompEndpoints-StompEndpointRegistry-registry"><span class="nav-text">2.2.1 registerStompEndpoints(StompEndpointRegistry registry)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-configureMessageBroker-MessageBrokerRegistry-registry"><span class="nav-text">2.2.2 configureMessageBroker(MessageBrokerRegistry registry)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%80%BB%E7%BB%93%EF%BC%9A%E4%B8%80%E5%BC%A0%E5%AE%8C%E6%95%B4%E7%9A%84%E9%85%8D%E7%BD%AE%E8%93%9D%E5%9B%BE"><span class="nav-text">2.3 总结：一张完整的配置蓝图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%B6%88%E6%81%AF%E6%94%B6%E5%8F%91%E4%B8%8E%E8%B7%AF%E7%94%B1"><span class="nav-text">3. 消息收发与路由</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%EF%BC%9A-MessageMapping"><span class="nav-text">3.1 消息接收：@MessageMapping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81-%E5%B9%BF%E6%92%AD"><span class="nav-text">3.2 消息发送&#x2F;广播</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-SendTo%EF%BC%9A%E5%B9%BF%E6%92%AD%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E7%9A%84%E5%9C%B0"><span class="nav-text">3.2.1 @SendTo：广播到指定目的地</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-SendToUser%EF%BC%9A%E5%90%91%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E5%8F%91%E9%80%81%E7%A7%81%E4%BF%A1"><span class="nav-text">3.2.2 @SendToUser：向当前用户发送私信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-SimpMessagingTemplate%EF%BC%9A%E4%B8%BB%E5%8A%A8%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E2%80%9C%E7%A5%9E%E5%99%A8%E2%80%9D"><span class="nav-text">3.2.3 SimpMessagingTemplate：主动发送消息的“神器”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85%EF%BC%9A-SubscribeMapping-%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94"><span class="nav-text">3.2.4 消息订阅：@SubscribeMapping (特殊用途)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%AE%89%E5%85%A8%E4%B8%8E%E6%8B%A6%E6%88%AA"><span class="nav-text">4. 安全与拦截</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-ChannelInterceptor%EF%BC%9A%E6%B6%88%E6%81%AF%E7%AE%A1%E9%81%93%E7%9A%84%E2%80%9C%E5%AE%88%E5%8D%AB%E2%80%9D"><span class="nav-text">4.1 ChannelInterceptor：消息管道的“守卫”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E7%BB%93%E5%90%88-Spring-Security%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%AE%89%E5%85%A8"><span class="nav-text">4.2 结合 Spring Security：实现声明式安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E6%80%BB%E7%BB%93"><span class="nav-text">4.3 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BA%A4%E4%BA%92%EF%BC%88%E7%AE%80%E8%BF%B0%EF%BC%89"><span class="nav-text">5. 客户端交互（简述）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98"><span class="nav-text">六、生产环境最佳实践与高级主题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%EF%BC%9A%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="nav-text">1. 连接的稳定性：心跳机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BF%83%E8%B7%B3%EF%BC%9F"><span class="nav-text">1.1 为什么需要心跳？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Spring-STOMP-%E7%9A%84%E5%86%85%E7%BD%AE%E5%BF%83%E8%B7%B3%E9%85%8D%E7%BD%AE"><span class="nav-text">1.2 Spring STOMP 的内置心跳配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%8E%9F%E7%94%9F-WebSocket-%E7%9A%84%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0-Ping-Pong"><span class="nav-text">1.3 原生 WebSocket 的手动实现 (Ping&#x2F;Pong)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%81%A5%E5%A3%AE%E6%80%A7%EF%BC%9A%E6%96%AD%E7%BA%BF%E9%87%8D%E8%BF%9E%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">2. 健壮性：断线重连与异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%87%8D%E8%BF%9E%E7%AD%96%E7%95%A5-%E6%8C%87%E6%95%B0%E9%80%80%E9%81%BF"><span class="nav-text">2.1 客户端重连策略 (指数退避)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%98%E9%9B%85%E5%A4%84%E7%90%86%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80%E4%BA%8B%E4%BB%B6"><span class="nav-text">2.2 服务端优雅处理连接断开事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E4%BD%BF%E7%94%A8-MessageExceptionHandler-%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86-STOMP-%E5%BC%82%E5%B8%B8"><span class="nav-text">2.3 使用 @MessageExceptionHandler 统一处理 STOMP 异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%A8%AA%E5%90%91%E6%89%A9%E5%B1%95%EF%BC%9A%E5%A4%9A%E5%AE%9E%E4%BE%8B%E9%83%A8%E7%BD%B2"><span class="nav-text">3. 横向扩展：多实例部署</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%8E%9F%E7%94%9F-WebSocket-Spring-%E5%8E%9F%E7%94%9F-WebSocket-%E7%9A%84%E6%8C%91%E6%88%98%EF%BC%9ASticky-Session"><span class="nav-text">3.1 原生 WebSocket&#x2F;Spring 原生 WebSocket 的挑战：Sticky Session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-STOMP-%E5%A4%96%E9%83%A8%E6%B6%88%E6%81%AF%E4%BB%A3%E7%90%86-RabbitMQ-%E7%9A%84%E5%A4%A9%E7%84%B6%E4%BC%98%E5%8A%BF"><span class="nav-text">3.2 STOMP + 外部消息代理 (RabbitMQ) 的天然优势</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA"><span class="nav-text">4. 安全加固</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%BC%BA%E5%88%B6-WSS%EF%BC%9A%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8A%A0%E5%AF%86"><span class="nav-text">4.1 强制 WSS：数据传输加密</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81-Authentication"><span class="nav-text">4.2 身份验证 (Authentication)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E8%B7%A8%E7%AB%99-WebSocket-%E5%8A%AB%E6%8C%81-CSWSH-%E9%98%B2%E5%BE%A1"><span class="nav-text">4.3 跨站 WebSocket 劫持 (CSWSH) 防御</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%80%A7%E8%83%BD%E4%B8%8E%E8%B0%83%E4%BC%98"><span class="nav-text">5. 性能与调优</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E6%B6%88%E6%81%AF%E5%A4%A7%E5%B0%8F%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E9%85%8D%E7%BD%AE"><span class="nav-text">5.1 消息大小与缓冲区配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-text">5.2 同步与异步发送的选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F%E9%80%89%E6%8B%A9%EF%BC%9AJSON-vs-Protobuf"><span class="nav-text">5.3 消息格式选择：JSON vs Protobuf</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B"><span class="nav-text">七、总结与展望</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E6%8C%87%E5%8D%97"><span class="nav-text">1. 技术选型指南</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-JSR-356-Java-%E5%8E%9F%E7%94%9F-API-%EF%BC%9F"><span class="nav-text">1.1 何时使用 JSR 356 (Java 原生 API)？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-Spring-%E5%8E%9F%E7%94%9F-WebSocket-WebSocketHandler-%EF%BC%9F"><span class="nav-text">1.2 何时使用 Spring 原生 WebSocket (WebSocketHandler)？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-Spring-STOMP%EF%BC%9F"><span class="nav-text">1.3 何时使用 Spring + STOMP？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E5%AF%B9%E6%AF%94%E9%80%9F%E6%9F%A5%E8%A1%A8"><span class="nav-text">1.4 技术选型对比速查表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="nav-text">2. 常用调试工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7-Network-WS"><span class="nav-text">2.1 浏览器开发者工具 (Network -&gt; WS)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Postman-Apifox-%E7%9A%84-WebSocket-%E6%B5%8B%E8%AF%95%E5%8A%9F%E8%83%BD"><span class="nav-text">2.2 Postman &#x2F; Apifox 的 WebSocket 测试功能</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/18/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/WebSocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="WebSocket | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          WebSocket
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-18 11:22:31" itemprop="dateCreated datePublished" datetime="2025-10-18T11:22:31+08:00">2025-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-21 09:38:51" itemprop="dateModified" datetime="2025-10-21T09:38:51+08:00">2025-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="一、-实时通信的演进"><a href="#一、-实时通信的演进" class="headerlink" title="一、 实时通信的演进"></a>一、 实时通信的演进</h1><h2 id="1-HTTP-的无状态性"><a href="#1-HTTP-的无状态性" class="headerlink" title="1. HTTP 的无状态性"></a>1. HTTP 的无状态性</h2><p>我们在”HTTP协议“这一笔  记中介绍了HTTP的核心特点<strong>无状态</strong>，这里简单回顾一下</p>
<ul>
<li><strong>定义</strong>：“无状态”指的是<strong>协议本身对于事务处理没有记忆能力</strong>。每一次 HTTP 请求都是完全独立的，服务器不会保留前一次请求的任何信息。</li>
<li>**优点 **：<ul>
<li><strong>简化服务器设计</strong>：服务器不需要花费额外的资源（如内存）来存储海量的客户端状态信息。</li>
<li><strong>提升服务器的可伸缩性</strong>：由于服务器不存储状态，任何一台服务器都可以处理任何一个客户端的请求。这使得在服务器集群中做<strong>负载均衡</strong>变得非常容易。如果一台服务器宕机，请求可以无缝切换到另一台，因为新服务器不需要任何历史上下文。</li>
</ul>
</li>
<li><strong>缺点与解决方案</strong>：<ul>
<li><strong>功能受限</strong>：然而，现代 Web 应用（如购物车、用户登录）恰恰需要“记住状态”。</li>
<li><strong>解决方案</strong>：为了弥补 HTTP 的无状态性，Web 应用通过<strong>Cookie 和 Session 机制</strong>来“创造”状态。<ul>
<li><strong>Cookie</strong>: 服务器通过 <code>Set-Cookie</code> 响应头给客户端一个“通行证”（一小段文本）。</li>
<li>之后，客户端在每次请求时都会通过 <code>Cookie</code> 请求头带上这个“通行证”。</li>
<li>服务器通过检查这个“通行证”就能识别出用户，从而维持登录状态或购物车内容。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>HTTP 的无状态性和“客户端发起”的特性，对于需要 <strong>服务端主动推送信息</strong> 的实时应用（如在线聊天、股票行情、实时通知、游戏等）来说，就成了一个天然的障碍。</p>
<p>想象一下开发一个网页聊天室：</p>
<ul>
<li>用户 A 发送了一条消息。</li>
<li>服务器如何将这条新消息实时地告诉在线的其他用户 B 和 C？</li>
</ul>
<p>在纯粹的 HTTP 模型下，服务器无法做到这一点。因为服务器处理完 A 的“发送消息”请求后，就“忘记”了 B 和 C 的存在，它没有任何机制可以主动联系 B 和 C 并告诉他们：“嘿，有新消息了！”，虽然 <code>Cookie-Session</code> 机制解决了身份认证和会话保持的问题，但它并没有解决 <strong>服务端无法主动推送</strong> 这一根本性矛盾。</p>
<hr>
<h2 id="2-基于-HTTP-的伪实时通信"><a href="#2-基于-HTTP-的伪实时通信" class="headerlink" title="2. 基于 HTTP 的伪实时通信"></a>2. 基于 HTTP 的伪实时通信</h2><p>正如上一节所述，HTTP 的无状态性和“请求-响应”模式，天然地阻碍了服务端主动向客户端推送数据。然而，对实时性的需求是真实存在的。为了绕过这一限制，开发者们发明了一系列“模拟”实时通信的技术，它们统称为“伪实时通信”或“Comet”技术。这些方案的核心思想都是：<strong>既然服务器不能主动“推”，那就让客户端不知疲倦地“拉”</strong>。</p>
<hr>
<h3 id="2-1-短轮询-Short-Polling"><a href="#2-1-短轮询-Short-Polling" class="headerlink" title="2.1 短轮询 (Short Polling)"></a>2.1 短轮询 (Short Polling)</h3><p>短轮询是最简单、最直观的实现方式。</p>
<ul>
<li><p><strong>工作原理</strong>：</p>
<ol>
<li>客户端以一个固定的、较短的时间间隔（例如每隔 1-3 秒）向服务器发送一个 HTTP 请求，询问“是否有新消息？”。</li>
<li>服务器立即检查是否有新数据。</li>
<li><strong>如果有新数据</strong>，服务器将其放在 HTTP 响应中返回给客户端。</li>
<li><strong>如果没新数据</strong>，服务器也立即返回一个空的或表示“无新内容”的响应。</li>
<li>客户端收到响应后，无论有无数据，都会在等待预设的间隔时间后，再次发起下一次请求。这个过程会无限循环下去。</li>
</ol>
</li>
<li><p><strong>图解流程</strong>:</p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant Client
    participant Server

    Client-&gt;&gt;Server: (1) Request
    Server--&gt;&gt;Client: (2) Response(No Data)
    note over Client: (wait 2s)

    Client-&gt;&gt;Server: (3) Request
    Server--&gt;&gt;Client: (4) Response(No Data)
    note over Client: (wait 2s)

    Client-&gt;&gt;Server: (5) Request
    note over Server: Has new data
    Server--&gt;&gt;Client: (6) Response(With Data)
    note over Client: (wait 2s)

    Client-&gt;&gt;Server: (7) Request
    note over Client,Server: ...</code></pre>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>实现简单</strong>：前后端实现都非常容易，逻辑清晰。</li>
<li><strong>兼容性好</strong>：几乎所有浏览器都支持，没有兼容性问题。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>延迟性高</strong>：消息的实时性取决于轮询间隔。如果间隔设为3秒，那么一条消息最多会有3秒的延迟才能被客户端接收到。</li>
<li><strong>服务器压力大</strong>：无论有无新消息，客户端都会持续不断地发起请求，其中绝大多数是无效的“空请求”（无功请求），这会极大地消耗服务器的 CPU 和带宽资源。</li>
<li><strong>网络拥堵</strong>：大量的 HTTP 请求头（Header）在网络中传输，造成了不必要的带宽浪费。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-长轮询-Long-Polling"><a href="#2-2-长轮询-Long-Polling" class="headerlink" title="2.2 长轮询 (Long Polling)"></a>2.2 长轮询 (Long Polling)</h3><p>长轮询是短轮询的优化版，旨在减少无效请求，降低延迟。</p>
<ul>
<li><p><strong>工作原理</strong>：</p>
<ol>
<li>客户端向服务器发起一个请求，询问“是否有新消息？”。</li>
<li>服务器收到请求后，<strong>并不立即响应</strong>。它会“挂起”（hold）这个连接，检查是否有新数据。</li>
<li><strong>如果在一定超时时间（例如30秒）内有新数据</strong>，服务器立即将数据放入响应中，返回给客户端，并关闭当前连接。</li>
<li><strong>如果在超时时间内一直没有新数据</strong>，服务器会返回一个表示超时的空响应，并关闭当前连接。</li>
<li>客户端在收到响应（无论是带数据的还是超时的）后，会<strong>立即</strong>发起下一个长轮询请求。</li>
</ol>
</li>
<li><p><strong>图解流程</strong>:</p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant Client
    participant Server

    Client-&gt;&gt;Server: (1) Request
    note over Server: Holds connection...

    note over Server: ... after 15s, new data arrives
    Server--&gt;&gt;Client: (2) Response(With Data)

    note over Client: Client immediately re-requests
    Client-&gt;&gt;Server: (3) Request
    note over Server: Holds connection...

    note over Server: ... after 30s, connection times out
    Server--&gt;&gt;Client: (4) Response(Timeout)

    note over Client: Client immediately re-requests
    Client-&gt;&gt;Server: (5) Request
    note over Server: Holds connection...
    note over Client, Server: ...</code></pre>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>准实时性</strong>：一旦有数据，服务器会立即发送，大大降低了消息的延迟。</li>
<li><strong>减少无效请求</strong>：相比短轮询，极大地减少了客户端发起的请求总数，节省了网络带宽和服务器的瞬时处理压力。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>服务器资源占用</strong>：服务器需要长时间维持（hold）客户端的连接。在高并发场景下，大量的挂起连接会占用大量的服务器内存和线程（或其他连接句柄），容易导致服务器连接数耗尽，这是著名的 <strong>C10K 问题</strong> 的一个典型场景。</li>
<li><strong>实现相对复杂</strong>：服务器端需要管理连接的挂起、超时和唤醒，逻辑比短轮询复杂。</li>
<li><strong>消息传递仍有延迟</strong>：每次数据传输后，连接会断开，客户端需要重新建立连接，这个过程（TCP握手、HTTP请求）仍然存在开销和延迟。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-HTTP-流-HTTP-Streaming"><a href="#2-3-HTTP-流-HTTP-Streaming" class="headerlink" title="2.3 HTTP 流 (HTTP Streaming)"></a>2.3 HTTP 流 (HTTP Streaming)</h3><p>这是一种更为激进的方案，试图在单个 HTTP 连接上实现持续的数据传输。</p>
<ul>
<li><strong>工作原理</strong>：<ol>
<li>客户端发起一个 HTTP 请求。</li>
<li>服务器返回一个 <code>Content-Type</code> 为 <code>application/octet-stream</code> 或类似类型的响应，并且响应头中不包含 <code>Content-Length</code> (或使用 <code>Transfer-Encoding: chunked</code>)。</li>
<li>关键在于，服务器<strong>不关闭这个响应连接</strong>。它会周期性地向这个打开的连接中“冲刷”（flush）数据块。</li>
<li>客户端通过监听 <code>XMLHttpRequest</code> 的 <code>onprogress</code> 事件或使用隐藏的 <code>&lt;iframe&gt;</code> 来持续接收这些数据块。</li>
</ol>
</li>
<li><strong>优点</strong>：<ul>
<li><strong>低延迟</strong>：在连接的生命周期内，消息几乎可以无延迟地从服务器推送到客户端。</li>
<li><strong>连接开销小</strong>：只需建立一次连接，后续所有消息都在这个连接上传输，省去了重复建立连接的开销。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>单向通信</strong>：这种方式本质上只解决了“服务器 -&gt; 客户端”的推送问题。如果客户端需要向服务器发送数据，仍然需要发起一个新的 HTTP 请求。它不是一个真正的双向通道。</li>
<li><strong>代理和防火墙问题</strong>：很多网络中间设备（如代理服务器、防火墙）可能会对这种“永不结束”的响应进行缓存或中断，导致连接不可靠。</li>
<li><strong>控制复杂</strong>：客户端和服务器对连接状态的控制比较复杂，例如如何判断连接真正断开。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-WebSocket-的诞生"><a href="#3-WebSocket-的诞生" class="headerlink" title="3. WebSocket 的诞生"></a>3. WebSocket 的诞生</h2><p>在短轮询、长轮询等“伪实时”方案的种种妥协与挣扎之后，Web 开发社区迫切需要一个原生的、高效的、真正的双向通信解决方案。终于，在 2011 年，IETF 将其标准化为 RFC 6455，HTML5 标准中也包含了 WebSocket API。一个为实时而生的协议——WebSocket——正式登上了历史舞台。</p>
<h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p>WebSocket 从根本上改变了客户端与服务器的交互方式，其核心特性可以概括为以下三点：</p>
<ol>
<li><strong>一次握手 (Single Handshake)</strong><br>WebSocket 的连接建立过程非常巧妙。它并非一个全新的协议，而是“寄生”于 HTTP 协议之上。客户端首先发起一个特殊的 HTTP 请求，请求头中包含 <code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code> 等字段。服务器如果支持 WebSocket，就会响应一个状态码为 <code>101 Switching Protocols</code> 的 HTTP 响应。这个过程被称为“WebSocket 握手”。一旦握手成功，底层的 TCP 连接就不再用于传输 HTTP 数据，而是切换为 WebSocket 协议的专属通道。</li>
<li><strong>持久连接 (Persistent Connection)</strong><br>握手成功后，该 TCP 连接会一直保持打开状态，直到客户端或服务器某一方主动关闭连接，或者网络发生中断。这与 HTTP 的“请求-响应-断开”模式完全不同。在一个持久的连接上，双方可以随时进行通信，免去了反复建立和断开连接所带来的巨大开销和延迟。</li>
<li><strong>全双工通信 (Full-Duplex Communication)</strong><br>这是 WebSocket 最具革命性的特点。在建立的持久连接上，客户端和服务器处于完全平等的地位，双方都可以<strong>在任何时刻、主动地</strong>向对方发送数据，无需等待对方的请求。这就像从使用“对讲机”（一次只能一方说）升级到了使用“电话”（双方可以同时自由交谈）。</li>
</ol>
<hr>
<h3 id="3-2-核心优势"><a href="#3-2-核心优势" class="headerlink" title="3.2 核心优势"></a>3.2 核心优势</h3><p>基于以上定义，WebSocket 带来了碾压式的优势：</p>
<ul>
<li><strong>极低延迟 (Low Latency)</strong>：数据可以直接在已建立的持久连接上发送，无需等待客户端轮询，也无需重新进行 TCP 和 TLS 握手。消息几乎可以瞬时从一端到达另一端，这是实现高实时性应用（如在线游戏、金融交易）的基石。</li>
<li><strong>极低开销 (Low Overhead)</strong>：<ul>
<li><strong>连接开销</strong>：只需一次握手，后续通信不再有建立连接的开销。</li>
<li><strong>协议开销</strong>：一旦握手完成，后续传输的数据单元是“数据帧 (Frame)”。WebSocket 的数据帧头部非常小，最小仅为 2 字节。相比之下，HTTP 请求&#x2F;响应的头部动辄数百字节，每次通信都携带大量的冗余信息。在频繁通信的场景下，WebSocket 能节省巨量的带宽。</li>
</ul>
</li>
<li><strong>真正的双向通信 (True Bidirectional Communication)</strong>：服务器可以主动向客户端推送数据，客户端也可以随时向服务器发送数据。这极大地简化了需要双向交互的应用的开发模型。开发者不再需要用复杂的技巧去“模拟”服务器推送，而是可以直接调用 <code>send()</code> 方法。</li>
<li><strong>更好的兼容性</strong>：WebSocket 握手通过 HTTP 协议进行，默认使用与 HTTP 相同的 80 和 443 端口。这使得它能够很好地穿透大多数企业防火墙和网络代理服务器，而这些中间设备往往会阻碍非标准的自定义 TCP 协议。</li>
</ul>
<hr>
<h1 id="二、协议底层"><a href="#二、协议底层" class="headerlink" title="二、协议底层"></a>二、协议底层</h1><h2 id="1-连接的桥梁：HTTP-Upgrade-握手机制"><a href="#1-连接的桥梁：HTTP-Upgrade-握手机制" class="headerlink" title="1. 连接的桥梁：HTTP Upgrade 握手机制"></a>1. 连接的桥梁：HTTP Upgrade 握手机制</h2><p>WebSocket 的设计者非常聪明，他们没有发明一个需要开放新端口的全新协议，因为这很可能会被企业防火墙或代理服务器拦截。相反，他们让 WebSocket 连接“伪装”成一个普通的 HTTP 请求开始，一旦双方确认“身份”，再“摇身一变”，切换到 WebSocket 协议。</p>
<h3 id="1-1-客户端握手请求"><a href="#1-1-客户端握手请求" class="headerlink" title="1.1 客户端握手请求"></a>1.1 客户端握手请求</h3><p>一切始于客户端（如浏览器）向服务器发起的一个特殊的 HTTP GET 请求。这个请求看起来和普通的 HTTP 请求很像，但包含了几个关键的请求头，它们是升级协议的“暗号”。</p>
<p>一个典型的客户端握手请求如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>server.example.com</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span><span class="punctuation">: </span>13 </span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://example.com</span><br></pre></td></tr></table></figure>

<p>让我们来逐一解读这些关键的头部字段：</p>
<ul>
<li><strong><code>GET /chat HTTP/1.1</code></strong><ul>
<li>请求行本身是标准的。路径 <code>/chat</code> 告诉服务器，客户端希望在哪个端点上建立 WebSocket 连接。服务器可以根据不同的路径提供不同的 WebSocket 服务。</li>
</ul>
</li>
<li><strong><code>Upgrade: websocket</code></strong> (<strong>核心暗号①</strong>)<ul>
<li>这是最直接的信号。它明确告诉服务器：“我（客户端）希望将当前这个 HTTP 连接升级到 WebSocket 协议。”</li>
</ul>
</li>
<li><strong><code>Connection: Upgrade</code></strong> (<strong>核心暗号②</strong>)<ul>
<li>HTTP 的 <code>Connection</code> 头通常用于管理连接的持续性（如 <code>keep-alive</code>）。在这里，<code>Upgrade</code> 值是一个补充说明，它告诉服务器以及路径上的所有中间代理：“请注意，这个连接即将发生协议转换，<code>Upgrade</code> 头中指定的协议就是要转换的目标。” 这是一个标准的 HTTP&#x2F;1.1 机制，用于协议升级。</li>
</ul>
</li>
<li><strong><code>Sec-WebSocket-Key</code></strong> (<strong>安全与身份验证</strong>)<ul>
<li>这是一个非常重要的字段，主要有两个作用：<ol>
<li><strong>证明服务器是真正的 WebSocket 服务器</strong>：客户端会发送一个由 Base64 编码的 16 字节随机字符串。服务器必须使用这个 <code>key</code> 和一个固定的“魔法字符串”通过特定算法计算出一个 <code>Sec-WebSocket-Accept</code> 值并返回。如果客户端收到的 <code>Accept</code> 值是正确的，它就知道对方确实是一个 WebSocket 服务器，而不是一个恰好返回了错误响应的普通 HTTP 服务器。</li>
<li><strong>防止代理缓存攻击</strong>：一些代理服务器可能会缓存 HTTP GET 请求的响应。如果一个恶意的 WebSocket 请求被代理缓存，当一个普通的 HTTP 客户端发出相同的 GET 请求时，代理可能会错误地返回一个 WebSocket 握手响应，导致客户端解析混乱。由于 <code>Sec-WebSocket-Key</code> 对于每次握手都是随机且唯一的，这保证了每次握手的响应都不同，从而有效防止了缓存污染。</li>
</ol>
</li>
</ul>
</li>
<li><strong><code>Sec-WebSocket-Version: 13</code></strong><ul>
<li>指定了客户端期望使用的 WebSocket 协议版本。<code>13</code> 是当前最广泛使用的版本，对应 RFC 6455 标准。如果服务器不支持此版本，它应该返回一个错误。</li>
</ul>
</li>
<li><strong><code>Origin</code></strong><ul>
<li>这个头部用于浏览器环境，提供了发起请求的源地址。服务器可以使用它来实施安全策略，例如判断是否允许该来源的页面建立 WebSocket 连接，以防止跨站 WebSocket 劫持 (Cross-Site WebSocket Hijacking)。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-服务端握手响应"><a href="#1-2-服务端握手响应" class="headerlink" title="1.2 服务端握手响应"></a>1.2 服务端握手响应</h3><p>如果服务器理解并同意客户端的升级请求，它会返回一个 HTTP 状态码为 <code>101 Switching Protocols</code> 的响应。</p>
<p>一个典型的服务端握手响应如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span><span class="punctuation">: </span>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>HTTP/1.1 101 Switching Protocols</code></strong></p>
<ul>
<li>这个状态码是明确的协议转换信号，告诉客户端：“好的，我同意你的请求，我们现在开始切换协议。”</li>
</ul>
</li>
<li><p><strong><code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code></strong></p>
<ul>
<li>服务器会原样返回这两个头部，作为对客户端请求的确认。</li>
</ul>
</li>
<li><p><strong><code>Sec-WebSocket-Accept</code></strong> (<strong>握手成功的凭证</strong>)</p>
<ul>
<li>这是握手成功的关键凭证。它的值是服务器根据客户端发送的 <code>Sec-WebSocket-Key</code> 精心计算出来的。计算逻辑在 RFC 6455 中有严格规定：<ol>
<li><strong>拼接</strong>：将客户端发送的 <code>Sec-WebSocket-Key</code> 的值与一个固定的“魔法字符串” <code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code> 进行拼接。<br>例如：<code>dGhlIHNhbXBsZSBub25jZQ==</code> + <code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code></li>
<li><strong>哈希</strong>：对拼接后的字符串计算 <strong>SHA-1</strong> 哈希值。这将得到一个 20 字节的二进制结果。</li>
<li><strong>编码</strong>：将这个 20 字节的二进制哈希值进行 <strong>Base64</strong> 编码。</li>
</ol>
</li>
</ul>
<p>客户端收到响应后，会用同样的算法在本地计算一遍，然后比较自己计算出的结果和服务器返回的 <code>Sec-WebSocket-Accept</code> 值是否完全一致。如果一致，握手成功；如果不一致，连接将立即关闭。</p>
</li>
</ul>
<hr>
<h3 id="1-3-握手成功之后：-连接正式从-HTTP-切换到-WebSocket-协议。"><a href="#1-3-握手成功之后：-连接正式从-HTTP-切换到-WebSocket-协议。" class="headerlink" title="1.3 握手成功之后： 连接正式从 HTTP 切换到 WebSocket 协议。"></a>1.3 握手成功之后： 连接正式从 HTTP 切换到 WebSocket 协议。</h3><p>一旦客户端验证 <code>Sec-WebSocket-Accept</code> 成功，这次 HTTP “对话”就宣告结束。但底层的 TCP 连接并未断开。此时，这条连接的“控制权”就从 HTTP 协议转移到了 WebSocket 协议。</p>
<ul>
<li><strong>协议转换</strong>：这条通道不再遵循 HTTP 的请求-响应模式。</li>
<li><strong>数据格式改变</strong>：之后在这条通道上传输的数据，将不再是 HTTP 报文，而是遵循 WebSocket 协议格式的 <strong>数据帧 (Data Frame)</strong>。</li>
<li><strong>全双工开启</strong>：客户端和服务器现在都可以随时、主动地通过这个连接向对方发送数据帧，实现了真正的全双工通信。</li>
</ul>
<p>这个巧妙的握手过程，既保证了与现有 Web 基础设施的兼容性，又通过 challenge-response 机制确保了连接的可靠性和安全性，为后续高效的实时通信铺平了道路。接下来，我们将深入了解在这条新建立的通道上奔跑的“信使”——数据帧。</p>
<hr>
<h2 id="2-通信的最小单元：数据帧-Data-Frame"><a href="#2-通信的最小单元：数据帧-Data-Frame" class="headerlink" title="2. 通信的最小单元：数据帧 (Data Frame)"></a>2. 通信的最小单元：数据帧 (Data Frame)</h2><p>握手成功后，WebSocket 连接就进入了数据传输阶段。与 HTTP 这种基于文本、格式冗长的协议不同，WebSocket 定义了一种紧凑的、基于二进制的帧结构来承载数据。这使得协议开销极小，传输效率极高。无论是客户端发送给服务器，还是服务器推送给客户端，所有消息都被切割并封装成一个或多个数据帧进行传输。</p>
<h3 id="2-1-帧结构图解"><a href="#2-1-帧结构图解" class="headerlink" title="2.1 帧结构图解"></a>2.1 帧结构图解</h3><p>一个 WebSocket 数据帧由一个固定长度的头部和可变长度的载荷（Payload）组成。其结构如下图所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>让我们来详细解析每个关键字段的作用：</p>
<ul>
<li><strong><code>FIN</code> (1 bit)</strong>: <strong>结束标志位 (Final Fragment)</strong><ul>
<li><code>1</code>: 当前帧是该消息的最后一个帧。如果消息不大，只用一个数据帧就能装下，那么这个帧的 <code>FIN</code> 位就是 <code>1</code>.</li>
<li><code>0</code>: 还有更多帧。</li>
<li>这个机制允许 WebSocket 将一个大消息分割成多个帧来发送，接收方可以逐帧接收，避免了因等待完整大消息而造成的延迟。接收方需要缓存这些 <code>FIN</code> 为 <code>0</code> 的帧，直到收到一个 <code>FIN</code> 为 <code>1</code> 的帧，然后将所有分片按序组合成完整的消息。</li>
</ul>
</li>
<li><strong><code>RSV1</code>, <code>RSV2</code>, <code>RSV3</code> (1 bit each)</strong>: <strong>保留位</strong><ul>
<li>这三个是保留位，必须设置为 <code>0</code>，除非有扩展协议定义了它们的用途。如果接收方收到的帧中这些位不为 <code>0</code> 且没有协商过任何扩展，就必须关闭连接。</li>
</ul>
</li>
<li><strong><code>Opcode</code> (4 bits)</strong>: <strong>操作码 (Operation Code)</strong><ul>
<li>这是至关重要的字段，它定义了该帧的数据类型。具体分类见下一节。</li>
</ul>
</li>
<li><strong><code>MASK</code> (1 bit)</strong>: <strong>掩码标志位</strong><ul>
<li><code>1</code>: 表示“载荷数据”被掩码（XOR异或加密）处理过。<strong>客户端发送给服务器的帧必须置 <code>1</code> (MASKED)</strong>。</li>
<li><code>0</code>: 表示“载荷数据”没有被掩码。<strong>服务器发送给客户端的帧必须置 <code>0</code> (UNMASKED)</strong>。</li>
<li><strong>为什么需要掩码？</strong> 这是为了防止代理缓存污染攻击 (Cache Poisoning)。一些设计不佳的代理服务器可能会解析并缓存 WebSocket 流量。如果客户端数据是明文的，攻击者可以构造一个特殊的 WebSocket 消息，让其看起来像一个 HTTP 响应，从而毒化代理的缓存。通过对客户端数据进行掩码，可以使数据变得不可预测，避免了这种风险。掩码密钥 (<code>Masking-key</code>) 是由客户端随机生成的，每次发送数据帧时都会变化。</li>
</ul>
</li>
<li><strong><code>Payload len</code> (7 bits), <code>Extended payload length</code> (16 or 64 bits)</strong>: <strong>载荷长度</strong><ul>
<li>这个区域用于表示 <code>Payload Data</code> 的长度，设计得非常精巧以节省空间：<ul>
<li><strong>如果 <code>Payload len</code> 在 0-125 之间</strong>：它的值就是载荷的实际长度（字节）。</li>
<li><strong>如果 <code>Payload len</code> 是 126</strong>：那么紧随其后的 2 个字节（16 bits）表示一个无符号整数，这个整数才是载荷的实际长度。用于传输长度在 126 到 65535 字节之间的载荷。</li>
<li><strong>如果 <code>Payload len</code> 是 127</strong>：那么紧随其后的 8 个字节（64 bits）表示一个无符号整数，这个整数才是载荷的实际长度。用于传输超大载荷。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>Masking-key</code> (0 or 4 bytes)</strong>: <strong>掩码密钥</strong><ul>
<li>如果 <code>MASK</code> 位是 <code>1</code>，那么这个字段就存在，占用 4 个字节。</li>
<li>如果 MASK 位是 0，则没有此字段。</li>
<li>它是由客户端随机生成的 32 位值。用于对载荷数据进行异或（XOR）掩码操作，以防止中间件干扰（即使数据是明文，看起来也是随机的）。服务器需要用这个密钥来解开 <code>Payload Data</code> 的掩码。解密算法很简单：<code>decoded[i] = encoded[i] XOR masking-key[i % 4]</code>。</li>
</ul>
</li>
<li><strong><code>Payload Data</code> (x bytes)</strong>: <strong>载荷数据</strong><ul>
<li>实际传输的应用数据。长度由 Payload Length 字段定义。</li>
<li>如果存在 Masking-Key，这部分数据是经过掩码（异或加密）的。服务器收到后需要先解掩码才能使用。服务器发送的数据则是明文的。</li>
<li>载荷数据的内容由 Opcode 决定（文本、二进制、控制帧的特定数据如关闭原因等）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-操作码-Opcode-分类"><a href="#2-2-操作码-Opcode-分类" class="headerlink" title="2.2 操作码 (Opcode) 分类"></a>2.2 操作码 (Opcode) 分类</h3><p><code>Opcode</code> 字段决定了如何解释 <code>Payload Data</code>。主要分为三类：</p>
<ul>
<li><strong>数据帧 (Data Frames)</strong><ul>
<li><code>%x1</code> (<strong>Text Frame</strong>): 文本帧。<code>Payload Data</code> 是 UTF-8 编码的文本数据。一个完整的文本消息由一个或多个文本帧组成。</li>
<li><code>%x2</code> (<strong>Binary Frame</strong>): 二进制帧。<code>Payload Data</code> 是任意的二进制数据。一个完整的二进制消息由一个或多个二进制帧组成。例如，可以用来传输图片、音频、Protobuf 或任何自定义的二进制格式。</li>
<li><code>%x0</code> (<strong>Continuation Frame</strong>): 连续帧。当一个消息被分割成多个帧时，第一个帧的 <code>Opcode</code> 是 <code>%x1</code> 或 <code>%x2</code>，后续所有帧的 <code>Opcode</code> 都必须是 <code>%x0</code>，直到 <code>FIN</code> 位为 <code>1</code> 的帧为止。</li>
</ul>
</li>
<li><strong>控制帧 (Control Frames)</strong><ul>
<li>控制帧用于处理 WebSocket 连接本身的状态，它们 <strong>不能被分片</strong>（即 <code>FIN</code> 位必须为 <code>1</code>），且其载荷长度不能超过 125 字节。</li>
<li><code>%x8</code> (<strong>Close Frame</strong>): 关闭帧。用于发起一个“优雅的”关闭握手。发送方可以包含一个状态码和关闭原因，接收方收到后应回复一个关闭帧，然后双方关闭连接。</li>
<li><code>%x9</code> (<strong>Ping Frame</strong>): Ping 帧。主要用于心跳检测，以确认连接仍然存活。发送方可以包含任意载荷数据，接收方收到 Ping 帧后，<strong>必须</strong> 尽快回复一个 Pong 帧，并将 Ping 帧的载荷数据一模一样地返回。</li>
<li><code>%xA</code> (<strong>Pong Frame</strong>): Pong 帧。是对 Ping 帧的响应。也可以由任意一方主动发送，作为一种单向的心跳。</li>
</ul>
</li>
<li><strong>保留的操作码</strong><ul>
<li><code>%x3</code> - <code>%x7</code> 和 <code>%xB</code> - <code>%xF</code> 是为未来扩展保留的。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-安全与地址：ws-vs-wss"><a href="#3-安全与地址：ws-vs-wss" class="headerlink" title="3. 安全与地址：ws:// vs wss://"></a>3. 安全与地址：<code>ws://</code> vs <code>wss://</code></h2><p>与 HTTP 协议拥有 <code>http://</code> 和 <code>https://</code> 两种模式一样，WebSocket 也有两种对应的 URI 类型：<code>ws://</code> (WebSocket) 和 <code>wss://</code> (WebSocket Secure)。选择哪一种，直接决定了你的通信内容在网络中是“裸奔”还是“加密传输”。</p>
<ul>
<li><strong><code>ws://</code> (WebSocket)</strong><ul>
<li><strong>定义</strong>：一个<strong>未加密</strong>的 WebSocket 连接。</li>
<li><strong>工作方式</strong>：<ul>
<li>它通过标准的 HTTP 握手建立连接，默认使用 <strong>80</strong> 端口。</li>
<li>握手成功后，所有的数据帧（Data Frame）都以<strong>明文</strong>形式在 TCP 连接上传输。</li>
</ul>
</li>
<li><strong>风险</strong>：这意味着任何在网络路径上的中间节点（如路由器、ISP、恶意攻击者）都可以轻易地监听、窃取甚至篡改你的通信内容。这对于涉及敏感信息（如用户凭证、私人消息、交易数据）的应用来说是绝对不可接受的。</li>
<li><strong>适用场景</strong>：仅限于在完全可信的内部网络或本地开发环境中进行测试和调试。<strong>严禁在任何公共网络（互联网）的生产环境中使用 <code>ws://</code>。</strong></li>
</ul>
</li>
<li><strong><code>wss://</code> (WebSocket Secure)</strong><ul>
<li><strong>定义</strong>：一个<strong>加密</strong>的 WebSocket 连接。</li>
<li><strong>工作方式</strong>：<ul>
<li>它并非一个全新的协议，而是将标准的 WebSocket 协议运行在 <strong>TLS (Transport Layer Security)</strong> 层之上。TLS 是 <code>https://</code> 使用的同一种加密协议。</li>
<li>连接过程如下：<ol>
<li>首先，客户端和服务之间会建立一个标准的 <strong>TLS 握手</strong>，创建一个安全的加密通道。这个过程与访问一个 <code>https://</code> 网站完全相同，服务器需要提供一个有效的 SSL&#x2F;TLS 证书。</li>
<li>然后，在这个已经建立的加密通道内，再进行标准的 WebSocket HTTP Upgrade 握手。</li>
<li>握手成功后，所有后续的 WebSocket 数据帧都会在发送前被 TLS 层加密，在接收后被 TLS 层解密。</li>
</ol>
</li>
</ul>
</li>
<li><strong>默认端口</strong>：<code>wss://</code> 默认使用 <strong>443</strong> 端口，这也是 <code>https://</code> 的标准端口。这使得 <code>wss://</code> 连接更容易穿透那些只允许标准 Web 流量（HTTP&#x2F;HTTPS）的防火墙。</li>
</ul>
</li>
</ul>
<p><strong><code>wss://</code> 的重要性：基于 TLS 的加密传输</strong></p>
<p>在现代 Web 应用中，<strong>使用 <code>wss://</code> 而不是 <code>ws://</code> 是一个强制性的安全最佳实践</strong>。其重要性体味在以下几个方面：</p>
<ol>
<li><strong>机密性 (Confidentiality)</strong><ul>
<li><code>wss://</code> 通过 TLS 加密了客户端和服务器之间的所有通信内容。这意味着即使数据包被网络嗅探工具（如 Wireshark）截获，攻击者看到的也只是一堆无意义的乱码，无法解析出原始的聊天消息、用户数据或其他敏感信息。</li>
</ul>
</li>
<li><strong>完整性 (Integrity)</strong><ul>
<li>TLS 协议包含了消息认证码 (MAC) 机制。每一条消息都会附加一个校验码，接收方会验证该校验码。如果数据在传输过程中被篡改（哪怕只修改了一个比特），校验码将不再匹配，连接会立即中断。这确保了你收到的数据就是对方发送的原始数据，未被篡改。</li>
</ul>
</li>
<li><strong>身份认证 (Authentication)</strong><ul>
<li>在 TLS 握手期间，服务器会向客户端出示其 SSL&#x2F;TLS 证书。客户端（浏览器）会验证该证书的有效性（例如，是否由受信任的证书颁发机构 CA 签发、域名是否匹配、是否在有效期内）。这向客户端证明了它正在与之通信的服务器是它声称的那个服务器（例如 <code>your-app.com</code>），而不是一个伪装的中间人攻击者。</li>
</ul>
</li>
<li><strong>浏览器安全策略的要求</strong><ul>
<li>现代浏览器正在强制推行“HTTPS Everywhere”策略。如果你的主页面是通过 <code>https://</code> 加载的，浏览器会出于安全考虑（混合内容 Mixed Content 策略），<strong>禁止</strong>该页面发起不安全的 <code>ws://</code> 连接。你只能从 <code>https://</code> 页面连接到 <code>wss://</code> 服务器。这意味着，只要你的网站启用了 HTTPS，你就必须使用 <code>wss://</code>。</li>
</ul>
</li>
</ol>
<p><strong>总结与实践建议</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>ws://</code></th>
<th align="left"><code>wss://</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>加密</strong></td>
<td align="left">否 (明文传输)</td>
<td align="left"><strong>是 (基于 TLS 加密)</strong></td>
</tr>
<tr>
<td align="left"><strong>默认端口</strong></td>
<td align="left">80</td>
<td align="left"><strong>443</strong></td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left">极低，易受窃听和篡改</td>
<td align="left"><strong>高</strong>，提供机密性、完整性、身份认证</td>
</tr>
<tr>
<td align="left"><strong>浏览器限制</strong></td>
<td align="left"><code>https://</code> 页面无法连接到 <code>ws://</code></td>
<td align="left"><strong>无限制</strong>，兼容 <code>http://</code> 和 <code>https://</code> 页面</td>
</tr>
<tr>
<td align="left"><strong>生产环境</strong></td>
<td align="left"><strong>禁止使用</strong></td>
<td align="left"><strong>强制要求</strong></td>
</tr>
</tbody></table>
<p><strong>结论</strong>：在项目规划和开发阶段，就应该将 <code>wss://</code> 作为唯一的选择。这意味着 WebSocket 服务器（无论是 Java、Node.js 还是其他语言实现）必须配置 SSL&#x2F;TLS 证书。在 Spring Boot 中，这通常与为整个 Web 应用启用 HTTPS 的配置是集成在一起的，非常方便。</p>
<hr>
<h1 id="三、Java-原生-API-JSR-356"><a href="#三、Java-原生-API-JSR-356" class="headerlink" title="三、Java 原生 API (JSR 356)"></a>三、Java 原生 API (JSR 356)</h1><h2 id="1-概述与依赖"><a href="#1-概述与依赖" class="headerlink" title="1. 概述与依赖"></a>1. 概述与依赖</h2><h3 id="1-1-JSR-356-是什么？Java-EE-Jakarta-EE-的标准"><a href="#1-1-JSR-356-是什么？Java-EE-Jakarta-EE-的标准" class="headerlink" title="1.1 JSR 356 是什么？Java EE&#x2F;Jakarta EE 的标准"></a>1.1 JSR 356 是什么？Java EE&#x2F;Jakarta EE 的标准</h3><ul>
<li><strong>定义</strong>：<strong>JSR 356</strong>，其标题为 <strong>“Java API for WebSocket”</strong>，是 Java Community Process (JCP) 定义的一个官方规范 (Java Specification Request)。它为 Java 平台提供了一套标准的、用于构建 WebSocket 应用的 API。</li>
<li><strong>标准化意味着什么？</strong><ul>
<li><strong>统一接口</strong>：JSR 356 定义了一系列的注解 (Annotations) 和接口，如 <code>@ServerEndpoint</code>、<code>@OnOpen</code>、<code>Session</code>、<code>Endpoint</code> 等。开发者只需要面向这些标准接口编程，而无需关心底层的具体实现。</li>
<li><strong>厂商实现</strong>：各大 Servlet 容器（应用服务器）厂商，如 Apache Tomcat, Eclipse Jetty, WildFly 等，都需要遵循 JSR 356 规范来提供自己的 WebSocket 功能实现。这就好比 JDBC 是数据库访问的标准，而各大数据库厂商提供自己的驱动程序一样。</li>
<li><strong>可移植性</strong>：只要你的代码是基于 JSR 356 API 编写的，理论上它可以不加修改地部署在任何兼容该规范的 Servlet 容器上。</li>
</ul>
</li>
<li><strong>历史演进</strong>：<ul>
<li>JSR 356 最初是作为 <strong>Java EE 7</strong> (Java Enterprise Edition 7) 的一部分被引入的。</li>
<li>随着 Java EE 迁移到 Eclipse 基金会并更名为 <strong>Jakarta EE</strong>，该规范也随之演进。在 Jakarta EE 8 及更高版本中，它被称为 <strong>Jakarta WebSocket</strong>。核心 API 和注解基本保持不变，只是包名从 <code>javax.websocket.*</code> 迁移到了 <code>jakarta.websocket.*</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-依赖配置"><a href="#1-2-依赖配置" class="headerlink" title="1.2 依赖配置"></a>1.2 依赖配置</h3><p>由于 JSR 356 是一个“规范”，你需要的依赖通常是一个 <code>api</code> 包，它只包含接口和注解，不包含具体实现。</p>
<ul>
<li><p><strong>Maven 依赖 (适用于 Jakarta EE)</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 使用与你的服务器兼容的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Maven 依赖 (适用于旧版 Java EE)</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 经典的 Java EE 7/8 版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>scope</code> 设置为 <code>provided</code> 的原因</strong>：<br>我们将 <code>scope</code> 设置为 <code>provided</code>，是因为我们期望最终的应用是部署在一个已经内置了 JSR 356 实现的 Servlet 容器（如 Tomcat 8+、Jetty 9+）中的。容器在运行时会提供具体的实现类。我们只需要这个 API 依赖在<strong>编译时</strong>可用，以便我们的代码能够通过编译检查。如果将实现打包到我们的 <code>.war</code> 文件中，可能会与容器自带的实现产生冲突。</p>
</li>
</ul>
<hr>
<h3 id="1-3-何时使用？"><a href="#1-3-何时使用？" class="headerlink" title="1.3 何时使用？"></a>1.3 何时使用？</h3><p>虽然 Spring 提供了更高级的抽象，但在某些场景下，直接使用 JSR 356 仍然是一个非常好的选择：</p>
<ol>
<li><strong>原生 Servlet 容器环境</strong><ul>
<li>当项目是一个不使用 Spring 或其他大型框架的、标准的 Web 应用（打包成 <code>.war</code> 文件），并直接部署在 Tomcat, Jetty, Undertow 等 Servlet 容器上时，JSR 356 是最自然、最轻量级的选择。这些容器都内置了对 JSR 356 的原生支持。</li>
</ul>
</li>
<li><strong>轻量级应用与微服务</strong><ul>
<li>对于一些简单的、功能单一的微服务，如果引入整个 Spring Boot 框架显得过于臃肿，使用如 JAX-RS (用于 REST) + JSR 356 (用于 WebSocket) 的组合，可以构建出非常轻量级的服务。</li>
</ul>
</li>
<li><strong>追求极致性能与底层控制</strong><ul>
<li>JSR 356 提供了相对底层的 API，让你能更直接地控制 <code>Session</code>、消息分片、超时等。对于需要进行深度性能调优或实现复杂协议交互的场景，直接使用原生 API 可能比经过多层封装的框架更灵活。</li>
</ul>
</li>
<li><strong>学习和理解 WebSocket 基础</strong><ul>
<li>从学习的角度看，先掌握 JSR 356 有助于你深刻理解 WebSocket 的生命周期和事件模型。这些基础知识对于后续学习和排查 Spring WebSocket 的问题也大有裨益。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-服务端实现"><a href="#2-服务端实现" class="headerlink" title="2. 服务端实现"></a>2. 服务端实现</h2><p>使用 JSR 356 实现 WebSocket 服务端非常直观，其核心是创建一个普通的 Java 类 (POJO)，并使用一系列注解来标记它，使其成为一个“服务端点 (Server Endpoint)”。容器会自动扫描、实例化并管理这些端点。</p>
<h3 id="2-1-服务端点类：-ServerEndpoint-注解详解"><a href="#2-1-服务端点类：-ServerEndpoint-注解详解" class="headerlink" title="2.1 服务端点类：@ServerEndpoint 注解详解"></a>2.1 服务端点类：<code>@ServerEndpoint</code> 注解详解</h3><p><code>@ServerEndpoint</code> 是 JSR 356 中最核心的注解。一个类一旦被此注解标记，容器就会将其识别为一个 WebSocket 端点，并为指定的 URI 路径提供服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint(&quot;/chat/&#123;room&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatEndpoint</span> &#123;</span><br><span class="line">    <span class="comment">// ... 生命周期方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@ServerEndpoint</code> 注解有多个常用属性：</p>
<ul>
<li><strong><code>value</code> (必需)</strong>:<ul>
<li><strong>作用</strong>：定义此端点对外暴露的 URI 路径。客户端需要连接到这个路径才能建立 WebSocket 通信。</li>
<li><strong>示例</strong>：<code>@ServerEndpoint(&quot;/chat&quot;)</code>，客户端需要连接 <code>ws://your-host/your-context/chat</code>。</li>
<li><strong>路径参数 (Path Parameters)</strong>：支持类似 JAX-RS 的路径模板。你可以使用 <code>{}</code> 来定义路径变量，并在生命周期方法中通过 <code>@PathParam</code> 注解获取。<ul>
<li><strong>示例</strong>：<code>@ServerEndpoint(&quot;/chat/{room}&quot;)</code>，客户端连接 <code>ws://.../chat/gaming</code> 时，<code>room</code> 变量的值就是 “gaming”。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>configurator</code> (可选)</strong>:<ul>
<li><strong>作用</strong>：指定一个自定义的 <code>ServerEndpointConfig.Configurator</code> 类的实例。这是一个高级特性，允许你在握手阶段进行深度定制，例如：<ul>
<li>在连接建立前修改 WebSocket 的配置。</li>
<li>根据 HTTP 握手请求头中的信息（如 <code>Origin</code> 或自定义 <code>token</code>）来决定是否允许连接。</li>
<li>在创建端点实例之前或之后执行特定逻辑。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>decoders</code> (可选)</strong>:<ul>
<li><strong>作用</strong>：指定一个或多个 <code>Decoder</code> 类的数组。Decoder 用于将传入的文本或二进制消息（如                                                                                                                                                                                                                                                                                                                                                     JSON 字符串）自动解码为自定义的 Java 对象。</li>
<li><strong>示例</strong>：<code>decoders = {MessageDecoder.class}</code></li>
</ul>
</li>
<li><strong><code>encoders</code> (可选)</strong>:<ul>
<li><strong>作用</strong>：指定一个或多个 <code>Encoder</code> 类的数组。Encoder 用于将传出的 Java 对象自动编码为 WebSocket 能发送的文本或二进制消息（如序列化为 JSON 字符串）。</li>
<li><strong>示例</strong>：<code>encoders = {MessageEncoder.class}</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-生命周期注解"><a href="#2-2-生命周期注解" class="headerlink" title="2.2 生命周期注解"></a>2.2 生命周期注解</h3><p>JSR 356 定义了四个注解，用于标记在 WebSocket 连接生命周期的不同阶段应该被调用的方法。</p>
<ul>
<li><p><strong><code>@OnOpen</code></strong>: <strong>连接建立时</strong></p>
<ul>
<li>当一个客户端成功与服务端点建立 WebSocket 连接后，被此注解标记的方法会被调用。</li>
<li><strong>方法签名</strong>：可以接受 <code>Session</code> 对象作为参数，也可以通过 <code>@PathParam</code> 获取 URI 中的路径变量。</li>
<li><strong>用途</strong>：通常用于初始化操作，如记录新用户上线、将会话 <code>Session</code> 存入一个全局集合以便后续广播、向新连接的用户发送欢迎消息等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnOpen</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session, <span class="meta">@PathParam(&quot;room&quot;)</span> String room)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Client connected to room: &quot;</span> + room);</span><br><span class="line">    <span class="comment">// session.getBasicRemote().sendText(&quot;Welcome to the chat!&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@OnMessage</code></strong>: <strong>收到消息时</strong></p>
<ul>
<li>当服务器从客户端收到一个完整的消息时，被此注解标记的方法会被调用。</li>
<li><strong>方法签名</strong>：<ul>
<li>可以接受消息内容作为参数，类型可以是 <code>String</code> (文本消息)、<code>byte[]</code> 或 <code>ByteBuffer</code> (二进制消息)、<code>Reader</code> (流式处理文本)、<code>InputStream</code> (流式处理二进制)。</li>
<li>如果配置了 <code>Decoder</code>，参数类型可以是解码后的自定义 Java 对象。</li>
<li>也可以接受 <code>Session</code> 参数来识别消息来源。</li>
</ul>
</li>
<li><strong>用途</strong>：处理业务逻辑的核心。例如，接收聊天消息并广播给其他人。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnMessage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Received message: &quot;</span> + message);</span><br><span class="line">    <span class="comment">// 广播消息给聊天室其他人...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@OnClose</code></strong>: <strong>连接关闭时</strong></p>
<ul>
<li>当连接被关闭时（无论由客户端、服务端主动关闭，还是因网络异常中断），被此注解标记的方法会被调用。</li>
<li><strong>方法签名</strong>：可以接受 <code>Session</code> 和 <code>CloseReason</code> 对象作为参数。<code>CloseReason</code> 包含了关闭状态码和原因描述。</li>
<li><strong>用途</strong>：执行清理工作，如用户下线通知、从全局会话集合中移除该 <code>Session</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnClose</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session, CloseReason closeReason)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Connection closed: &quot;</span> + closeReason.getReasonPhrase());</span><br><span class="line">    <span class="comment">// 从会话集合中移除 session</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@OnError</code></strong>: <strong>发生错误时</strong></p>
<ul>
<li>当通信过程中发生错误时（如网络异常、消息编解码失败等），被此注解标记的方法会被调用。</li>
<li><strong>方法签名</strong>：必须接受一个 <code>Throwable</code> 类型的参数，用于表示发生的异常。也可以接受一个 <code>Session</code> 参数。</li>
<li><strong>用途</strong>：记录错误日志、进行必要的资源清理。<strong>注意</strong>：在很多实现中，一个错误发生后，连接通常会紧接着被关闭，所以 <code>@OnClose</code> 方法也常常会被调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnError</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable throwable)</span> &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;An error occurred: &quot;</span> + throwable.getMessage());</span><br><span class="line">    throwable.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-3-核心组件"><a href="#2-3-核心组件" class="headerlink" title="2.3 核心组件"></a>2.3 核心组件</h3><p>在生命周期方法中，<code>Session</code> 对象是你与客户端交互的唯一桥梁。</p>
<ul>
<li><strong><code>Session</code></strong><ul>
<li><strong>定义</strong>：代表一个客户端与服务端点之间的<strong>单一连接会话</strong>。每个成功连接的客户端都有一个独立的 <code>Session</code> 实例。</li>
<li><strong>关键方法</strong>：<ul>
<li><code>getId()</code>: 获取此会话的唯一ID。</li>
<li><code>isOpen()</code>: 检查连接是否仍然打开。</li>
<li><code>close()</code> &#x2F; <code>close(CloseReason reason)</code>: 主动关闭连接。</li>
<li><code>getRequestURI()</code>: 获取建立此连接的完整 URI。</li>
<li><code>getPathParameters()</code>: 获取一个 <code>Map</code>，包含 URI 模板中的所有路径参数。</li>
<li><code>getUserProperties()</code>: 提供一个 <code>Map&lt;String, Object&gt;</code>，可以在会话期间存储与该连接相关的自定义数据（如用户名、状态等）。这是一个非常有用的“会话状态”存储空间。</li>
<li><code>getBasicRemote()</code>: 获取<strong>同步</strong>消息发送器。</li>
<li><code>getAsyncRemote()</code>: 获取<strong>异步</strong>消息发送器。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>RemoteEndpoint.Basic</code> &#x2F; <code>RemoteEndpoint.Async</code></strong><ul>
<li><code>RemoteEndpoint</code> 是 <code>Session</code> 的一个属性，代表了“远程的那一端”（即客户端），用于向其发送消息。它提供了两种发送模式：</li>
<li><strong><code>RemoteEndpoint.Basic</code> (同步发送)</strong><ul>
<li><strong>获取方式</strong>：<code>session.getBasicRemote()</code></li>
<li><strong>特点</strong>：调用发送方法（如 <code>sendText(String text)</code>）时，当前线程会被<strong>阻塞</strong>，直到消息完全发送出去。</li>
<li><strong>优点</strong>：简单直接，易于理解。</li>
<li><strong>缺点</strong>：如果网络状况不佳或者发送的数据量大，会导致处理线程长时间阻塞，影响服务器处理其他连接的能力。在高并发场景下可能成为性能瓶颈。</li>
<li><strong>常用方法</strong>：<code>sendText(String)</code>, <code>sendBinary(ByteBuffer)</code>, <code>sendObject(Object)</code> (需配置 Encoder)。</li>
</ul>
</li>
<li><strong><code>RemoteEndpoint.Async</code> (异步发送)</strong><ul>
<li><strong>获取方式</strong>：<code>session.getAsyncRemote()</code></li>
<li><strong>特点</strong>：调用发送方法时，方法会<strong>立即返回</strong>，消息的发送操作会在另一个后台线程中进行。</li>
<li><strong>优点</strong>：非阻塞，不会占用当前业务处理线程，能显著提升服务器的吞吐量和响应能力，是<strong>生产环境推荐</strong>的方式。</li>
<li><strong>缺点</strong>：编程模型稍复杂，需要通过回调 (<code>Future</code> 或 <code>SendHandler</code>) 来处理发送成功或失败的结果。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>sendText(String text)</code>: 立即返回，不关心结果。</li>
<li><code>sendText(String text, SendHandler handler)</code>: 传入一个回调处理器，当发送完成（成功或失败）时，<code>handler</code> 的 <code>onResult</code> 方法会被调用。</li>
<li><code>sendObject(Object obj)</code>: 立即返回一个 <code>Future&lt;Void&gt;</code>，可以通过 <code>Future</code> 来检查发送是否完成或捕获异常。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-高级特性"><a href="#3-高级特性" class="headerlink" title="3. 高级特性"></a>3. 高级特性</h2><h3 id="3-1-路径参数处理：-ServerEndpoint-与-PathParam"><a href="#3-1-路径参数处理：-ServerEndpoint-与-PathParam" class="headerlink" title="3.1 路径参数处理：@ServerEndpoint 与 @PathParam"></a>3.1 路径参数处理：<code>@ServerEndpoint</code> 与 <code>@PathParam</code></h3><p>在实际应用中，我们往往不希望所有 WebSocket 连接都混在同一个“大厅”里。我们可能需要根据业务逻辑对连接进行分组，例如创建不同的聊天室、为特定用户推送消息等。JSR 356 借鉴了 JAX-RS (Java API for RESTful Web Services) 的设计，通过在 <code>@ServerEndpoint</code> 的路径中使用模板变量，并结合 <code>@PathParam</code> 注解来实现这一点。</p>
<ul>
<li><p><strong>定义带参数的路径</strong></p>
<p>在 <code>@ServerEndpoint</code> 注解的 <code>value</code> 属性中，使用 <code>{variableName}</code> 的形式来定义路径参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint(&quot;/websocket/chat/&#123;room&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdvancedChatEndpoint</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了两个路径参数：<code>room</code> 和 <code>username</code>。</p>
</li>
<li><p><strong>在方法中获取参数值</strong></p>
<p>在任何生命周期方法（<code>@OnOpen</code>, <code>@OnMessage</code>, <code>@OnClose</code>, <code>@OnError</code>）的参数列表中，使用 <code>@PathParam(&quot;variableName&quot;)</code> 注解来注入对应的路径参数值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint(&quot;/websocket/chat/&#123;room&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdvancedChatEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session,</span></span><br><span class="line"><span class="params">                       <span class="meta">@PathParam(&quot;room&quot;)</span> String room,</span></span><br><span class="line"><span class="params">                       <span class="meta">@PathParam(&quot;username&quot;)</span> String username)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;Session %s connected. User &#x27;%s&#x27; joined room &#x27;%s&#x27;.%n&quot;</span>,</span><br><span class="line">                          session.getId(), username, room);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们可以利用这些信息来管理会话</span></span><br><span class="line">        <span class="comment">// 例如，将会话按房间分组存储</span></span><br><span class="line">        <span class="comment">// chatRooms.computeIfAbsent(room, k -&gt; new CopyOnWriteArraySet&lt;&gt;()).add(session);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将用户信息存储在会话中，方便后续使用</span></span><br><span class="line">        session.getUserProperties().put(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">        session.getUserProperties().put(<span class="string">&quot;room&quot;</span>, room);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> &#123;</span><br><span class="line">        <span class="comment">// 从会话中直接获取用户信息，而无需再次解析路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">room</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;room&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.printf(<span class="string">&quot;Received message from &#x27;%s&#x27; in room &#x27;%s&#x27;: %s%n&quot;</span>,</span><br><span class="line">                          username, room, message);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接下来可以实现只向同一个 room 的其他用户广播消息</span></span><br><span class="line">        <span class="comment">// broadcastToRoom(room, username + &quot;: &quot; + message);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他生命周期方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点</strong></p>
<ul>
<li><strong>动态路由</strong>：使得一个端点类可以服务于多个逻辑隔离的 WebSocket 通道。</li>
<li><strong>语义清晰</strong>：URI 本身就携带了连接的上下文信息，非常直观。</li>
<li><strong>简化逻辑</strong>：避免了在连接建立后再通过第一条消息来传递“房间号”之类的元数据，简化了客户端和服务器的协议。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-2-配置类-ServerEndpointConfig-Configurator-的使用"><a href="#3-2-配置类-ServerEndpointConfig-Configurator-的使用" class="headerlink" title="3.2 配置类 ServerEndpointConfig.Configurator 的使用"></a>3.2 配置类 <code>ServerEndpointConfig.Configurator</code> 的使用</h3><p><code>ServerEndpointConfig.Configurator</code> 是一个强大的钩子 (hook)，它允许你在 WebSocket 握手和端点实例化的过程中进行深度干预。这对于实现认证、授权或动态修改配置等高级功能至关重要。</p>
<ul>
<li><p><strong>使用步骤</strong>：</p>
<ol>
<li><strong>创建一个自定义的 Configurator 类</strong>：<br>这个类需要继承 <code>ServerEndpointConfig.Configurator</code>。</li>
<li><strong>重写关键方法</strong>：<ul>
<li><code>modifyHandshake(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response)</code>:<br>这是最有用的方法。它在 HTTP Upgrade 握手期间被调用。你可以在这里：<ul>
<li><strong>访问 HTTP 请求头</strong> (<code>request.getHeaders()</code>)：可以获取 <code>Cookie</code>, <code>Authorization</code>, <code>Origin</code> 或任何自定义的请求头，用于身份验证或安全检查。</li>
<li><strong>拒绝连接</strong>：如果验证失败，可以抛出一个异常，或者修改 <code>HandshakeResponse</code> 来返回一个非 101 的 HTTP 状态码，从而阻止 WebSocket 连接的建立。</li>
<li><strong>传递信息</strong>：可以将从 HTTP 请求中获取的信息（如用户 ID）存入 <code>ServerEndpointConfig</code> 的 <code>userProperties</code> 中，这些属性随后可以在端点实例中被访问。</li>
</ul>
</li>
<li><code>getEndpointInstance(Class&lt;T&gt; endpointClass)</code>:<br>这个方法用于创建端点类的实例。默认行为是简单地调用 <code>endpointClass.newInstance()</code>。你可以重写它来实现：<ul>
<li><strong>依赖注入</strong>：如果你想在一个非 Spring 环境下为 WebSocket 端点注入依赖（比如一个 <code>UserService</code>），可以在这里手动创建实例并注入。</li>
<li><strong>实例池</strong>：实现一个端点实例池来复用对象（尽管在大多数情况下，每个连接一个新实例是更清晰的模型）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>在 <code>@ServerEndpoint</code> 中关联 Configurator</strong>：<br>使用 <code>configurator</code> 属性指向你的自定义 Configurator 类。</li>
</ol>
</li>
<li><p><strong>示例：基于 Token 的身份验证</strong></p>
<p>假设客户端在建立 WebSocket 连接时，会通过一个名为 <code>X-Auth-Token</code> 的 HTTP 请求头来传递认证令牌。</p>
<p><strong>Step 1: 创建 Configurator</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthConfigurator</span> <span class="keyword">extends</span> <span class="title class_">ServerEndpointConfig</span>.Configurator &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyHandshake</span><span class="params">(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 HTTP 请求头中的 token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeaders().get(<span class="string">&quot;X-Auth-Token&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 伪代码：验证 token 的有效性</span></span><br><span class="line">        <span class="keyword">if</span> (token != <span class="literal">null</span> &amp;&amp; isValidToken(token)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Token validation successful.&quot;</span>);</span><br><span class="line">            <span class="comment">// Token 有效，可以将解析出的用户信息存入 userProperties</span></span><br><span class="line">            <span class="comment">// 以便在 @OnOpen 中使用</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> getUserIdFromToken(token);</span><br><span class="line">            sec.getUserProperties().put(<span class="string">&quot;userId&quot;</span>, userId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Token validation failed. Refusing connection.&quot;</span>);</span><br><span class="line">            <span class="comment">// Token 无效，可以采取措施拒绝连接</span></span><br><span class="line">            <span class="comment">// 抛出异常是 JSR 356 规范中没有明确定义但一些容器支持的方式。</span></span><br><span class="line">            <span class="comment">// 更标准的方式是修改响应，但这在 modifyHandshake 中不易做到。</span></span><br><span class="line">            <span class="comment">// 实际开发中通常在此处记录日志，并在 @OnOpen 中检查属性并立即关闭。</span></span><br><span class="line">            <span class="comment">// 或者直接在此处抛出未检查异常，多数容器会捕获并中止握手。</span></span><br><span class="line">            <span class="comment">// 这里我们简单地设置一个标志</span></span><br><span class="line">            sec.getUserProperties().put(<span class="string">&quot;auth_failed&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValidToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="comment">// 实现你的 token 验证逻辑，例如查询数据库或调用认证服务</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;valid-token-string&quot;</span>.equals(token);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getUserIdFromToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user123&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Step 2: 在端点中应用 Configurator</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint(value = &quot;/secure/data&quot;, configurator = AuthConfigurator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecureDataEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        <span class="comment">// 在 OnOpen 中检查认证结果</span></span><br><span class="line">        <span class="keyword">if</span> (session.getUserProperties().containsKey(<span class="string">&quot;auth_failed&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Authentication failed, closing session.&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                session.close(<span class="keyword">new</span> <span class="title class_">CloseReason</span>(CloseReason.CloseCodes.VIOLATED_POLICY, <span class="string">&quot;Authentication Failed&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// handle error</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;Secure connection established for user: %s (Session ID: %s)%n&quot;</span>, userId, session.getId());</span><br><span class="line">        <span class="comment">// 后续可以将 session 与 userId 关联起来</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>通过这种方式，<code>AuthConfigurator</code> 扮演了一个“门卫”的角色，在连接真正建立之前就完成了安全检查，将业务逻辑与认证逻辑清晰地分离开来。</p>
<hr>
<h2 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="4. 示例代码"></a>4. 示例代码</h2><h3 id="4-1-项目结构和依赖"><a href="#4-1-项目结构和依赖" class="headerlink" title="4.1 项目结构和依赖"></a>4.1 项目结构和依赖</h3><p>首先，确保你的项目是一个标准的 Web 应用（例如 Maven 的 <code>war</code> packaging），并已添加 <code>jakarta.websocket-api</code> 或 <code>javax.websocket-api</code> 依赖，且 <code>scope</code> 为 <code>provided</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 你还需要一个 Servlet API 依赖，通常也是 provided --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2-服务端点-ChatRoomEndpoint-java"><a href="#4-2-服务端点-ChatRoomEndpoint-java" class="headerlink" title="4.2 服务端点 ChatRoomEndpoint.java"></a>4.2 服务端点 <code>ChatRoomEndpoint.java</code></h3><p>这是我们的核心逻辑所在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的多房间聊天室 WebSocket 端点。</span></span><br><span class="line"><span class="comment"> * 用户通过 ws://&lt;host&gt;:&lt;port&gt;/&lt;context&gt;/chat/&#123;username&#125;/&#123;room&#125; 连接。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/chat/&#123;username&#125;/&#123;room&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatRoomEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态集合，用于存储所有聊天室的会话。</span></span><br><span class="line">    <span class="comment">// Key: 房间名, Value: 该房间内所有会话的 Set。</span></span><br><span class="line">    <span class="comment">// 使用 ConcurrentHashMap 和 CopyOnWriteArraySet 来保证线程安全。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, CopyOnWriteArraySet&lt;Session&gt;&gt; rooms = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当一个新的 WebSocket 连接建立时调用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session  代表当前连接的会话对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 从 URL 路径中提取的用户名。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> room     从 URL 路径中提取的房间名。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session, <span class="meta">@PathParam(&quot;username&quot;)</span> String username, <span class="meta">@PathParam(&quot;room&quot;)</span> String room)</span> &#123;</span><br><span class="line">        <span class="comment">// 将用户信息存储在 session 的 userProperties 中，方便后续使用。</span></span><br><span class="line">        session.getUserProperties().put(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">        session.getUserProperties().put(<span class="string">&quot;room&quot;</span>, room);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将会话加入对应房间的集合中。</span></span><br><span class="line">        <span class="comment">// computeIfAbsent 是一个原子操作，如果 room 不存在，则创建一个新的 Set。</span></span><br><span class="line">        rooms.computeIfAbsent(room, k -&gt; <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;()).add(session);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;User &#x27;%s&#x27; joined room &#x27;%s&#x27;. Session ID: %s%n&quot;</span>, username, room, session.getId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备一条加入通知消息。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">joinMessage</span> <span class="operator">=</span> String.format(<span class="string">&quot;System: User &#x27;%s&#x27; has joined the room.&quot;</span>, username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向房间内的所有用户广播这条加入消息。</span></span><br><span class="line">        broadcast(room, joinMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当服务器从客户端收到消息时调用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送的文本消息。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 发送消息的会话。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session session)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">room</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;room&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;Received message from &#x27;%s&#x27; in room &#x27;%s&#x27;: %s%n&quot;</span>, username, room, message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 格式化消息，附带发送者信息。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">formattedMessage</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s: %s&quot;</span>, username, message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将消息广播给同一房间内的所有用户（包括发送者自己）。</span></span><br><span class="line">        broadcast(room, formattedMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当一个 WebSocket 连接关闭时调用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session     被关闭的会话。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> closeReason 关闭的原因。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session, CloseReason closeReason)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">room</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;room&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从房间的会话集合中移除当前会话。</span></span><br><span class="line">        CopyOnWriteArraySet&lt;Session&gt; roomSessions = rooms.get(room);</span><br><span class="line">        <span class="keyword">if</span> (roomSessions != <span class="literal">null</span>) &#123;</span><br><span class="line">            roomSessions.remove(session);</span><br><span class="line">            <span class="comment">// 如果房间变空，可以考虑从 rooms Map 中移除。</span></span><br><span class="line">            <span class="keyword">if</span> (roomSessions.isEmpty()) &#123;</span><br><span class="line">                rooms.remove(room);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;User &#x27;%s&#x27; left room &#x27;%s&#x27;. Reason: %s%n&quot;</span>, username, room, closeReason.getReasonPhrase());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备一条离开通知消息。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">leaveMessage</span> <span class="operator">=</span> String.format(<span class="string">&quot;System: User &#x27;%s&#x27; has left the room.&quot;</span>, username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向房间内剩余的用户广播这条离开消息。</span></span><br><span class="line">        broadcast(room, leaveMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通信过程中发生错误时调用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session   发生错误的会话。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> throwable 抛出的异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getUserProperties().get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.err.printf(<span class="string">&quot;Error for user &#x27;%s&#x27; in session %s: %s%n&quot;</span>, username, session.getId(), throwable.getMessage());</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">        <span class="comment">// 发生错误后，通常连接会随之关闭，onClose 方法会被调用。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 辅助方法：向指定房间的所有会话广播消息。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> room    房间名。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 要广播的消息。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">broadcast</span><span class="params">(String room, String message)</span> &#123;</span><br><span class="line">        CopyOnWriteArraySet&lt;Session&gt; sessionsInRoom = rooms.get(room);</span><br><span class="line">        <span class="keyword">if</span> (sessionsInRoom != <span class="literal">null</span>) &#123;</span><br><span class="line">            sessionsInRoom.forEach(session -&gt; &#123;</span><br><span class="line">                <span class="comment">// 使用异步方式发送消息，避免阻塞。</span></span><br><span class="line">                <span class="keyword">synchronized</span> (session) &#123; <span class="comment">// 简单同步，防止多线程同时操作一个 session</span></span><br><span class="line">                    <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                        session.getAsyncRemote().sendText(message, result -&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> (result.isOK()) &#123;</span><br><span class="line">                                <span class="comment">// System.out.println(&quot;Async message sent to &quot; + session.getId());</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                System.err.printf(<span class="string">&quot;Failed to send message to session %s: %s%n&quot;</span>,</span><br><span class="line">                                        session.getId(), result.getException().getMessage());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-启用-WebSocket-支持-ApplicationConfig-java"><a href="#4-3-启用-WebSocket-支持-ApplicationConfig-java" class="headerlink" title="4.3 启用 WebSocket 支持 (ApplicationConfig.java)"></a>4.3 启用 WebSocket 支持 (<code>ApplicationConfig.java</code>)</h3><p>为了让 Servlet 容器（如 Tomcat）能够扫描到我们的 <code>@ServerEndpoint</code>，我们需要一个配置类来初始化 WebSocket 环境。最简单的方法是创建一个实现了 <code>ServerApplicationConfig</code> 接口的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个类用于告诉容器哪些类是 WebSocket 端点。</span></span><br><span class="line"><span class="comment"> * 容器启动时会自动扫描并加载这个配置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketAppConfig</span> <span class="keyword">implements</span> <span class="title class_">ServerApplicationConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;ServerEndpointConfig&gt; <span class="title function_">getEndpointConfigs</span><span class="params">(Set&lt;Class&lt;? extends Endpoint&gt;&gt; endpointClasses)</span> &#123;</span><br><span class="line">        <span class="comment">// 这个方法可以用于动态创建和配置端点，我们这里用不到，返回空集合即可。</span></span><br><span class="line">        <span class="keyword">return</span> Set.of();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getAnnotatedEndpointClasses(Set&lt;Class&lt;?&gt;&gt; scanned) &#123;</span><br><span class="line">        <span class="comment">// 这个方法是关键。容器会传入所有扫描到的类，我们在这里筛选出带有 @ServerEndpoint 注解的类。</span></span><br><span class="line">        <span class="comment">// 如果你的端点类在扫描路径下，直接返回 scanned 也可以。</span></span><br><span class="line">        <span class="comment">// 为了清晰，我们这里显式地返回我们的端点类。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Scanning for WebSocket endpoints... Found: &quot;</span> + scanned.size());</span><br><span class="line">        </span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; endpoints = Stream.of(</span><br><span class="line">            com.example.websocket.chat.ChatRoomEndpoint.class</span><br><span class="line">        ).collect(Collectors.toSet());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Registering WebSocket endpoints: &quot;</span> + endpoints);</span><br><span class="line">        <span class="keyword">return</span> endpoints;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在实际项目中，更通用的做法是不过滤，让容器自己处理：</span></span><br><span class="line">        <span class="comment">// return scanned;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-4-客户端测试-index-html"><a href="#4-4-客户端测试-index-html" class="headerlink" title="4.4 客户端测试 (index.html)"></a>4.4 客户端测试 (<code>index.html</code>)</h3><p>创建一个简单的 HTML 页面来测试我们的聊天室。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JSR 356 WebSocket Chat<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123; <span class="attribute">font-family</span>: sans-serif; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#chat-window</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>; <span class="attribute">height</span>: <span class="number">300px</span>; <span class="attribute">overflow-y</span>: scroll; <span class="attribute">padding</span>: <span class="number">10px</span>; <span class="attribute">margin-bottom</span>: <span class="number">10px</span>; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#chat-window</span> <span class="selector-tag">p</span> &#123; <span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">0</span>; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#controls</span> <span class="selector-tag">input</span> &#123; <span class="attribute">width</span>: <span class="number">200px</span>; <span class="attribute">margin-right</span>: <span class="number">10px</span>; &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Simple WebSocket Chat<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;connect-controls&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Your Username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;User_&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;room&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Room Name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;general&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;connectBtn&quot;</span>&gt;</span>Connect<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;disconnectBtn&quot;</span> <span class="attr">disabled</span>&gt;</span>Disconnect<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;chat-window&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;message-controls&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Type a message...&quot;</span> <span class="attr">disabled</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;sendBtn&quot;</span> <span class="attr">disabled</span>&gt;</span>Send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> usernameInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;username&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> roomInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;room&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> connectBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;connectBtn&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> disconnectBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;disconnectBtn&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> chatWindow = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;chat-window&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> messageInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;message&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> sendBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;sendBtn&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> websocket;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 动态生成一个唯一用户名</span></span></span><br><span class="line"><span class="language-javascript">        usernameInput.<span class="property">value</span> += <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">logMessage</span>(<span class="params">message</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> p = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            p.<span class="property">textContent</span> = message;</span></span><br><span class="line"><span class="language-javascript">            chatWindow.<span class="title function_">appendChild</span>(p);</span></span><br><span class="line"><span class="language-javascript">            chatWindow.<span class="property">scrollTop</span> = chatWindow.<span class="property">scrollHeight</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        connectBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> username = usernameInput.<span class="property">value</span>.<span class="title function_">trim</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> room = roomInput.<span class="property">value</span>.<span class="title function_">trim</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (!username || !room) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&#x27;Username and Room Name cannot be empty.&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 注意：这里的 URL 路径需要与你的 Web 应用部署路径匹配。</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 如果你的应用部署在根路径，就是 ws://.../chat/...</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 如果部署在 /my-app，就是 ws://.../my-app/chat/...</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> wsUrl = <span class="string">`ws://<span class="subst">$&#123;<span class="variable language_">window</span>.location.host&#125;</span>/your-app-context/chat/<span class="subst">$&#123;username&#125;</span>/<span class="subst">$&#123;room&#125;</span>`</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">logMessage</span>(<span class="string">`Connecting to <span class="subst">$&#123;wsUrl&#125;</span>...`</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(wsUrl);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">logMessage</span>(<span class="string">&#x27;Connection established.&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                connectBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">                disconnectBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">                messageInput.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">                sendBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">logMessage</span>(event.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">logMessage</span>(<span class="string">`Connection closed. Code: <span class="subst">$&#123;event.code&#125;</span>, Reason: <span class="subst">$&#123;event.reason&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">                connectBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">                disconnectBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">                messageInput.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">                sendBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">logMessage</span>(<span class="string">&#x27;An error occurred.&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;WebSocket Error:&#x27;</span>, event);</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        disconnectBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (websocket) &#123;</span></span><br><span class="line"><span class="language-javascript">                websocket.<span class="title function_">close</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        sendBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> message = messageInput.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (message &amp;&amp; websocket &amp;&amp; websocket.<span class="property">readyState</span> === <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                websocket.<span class="title function_">send</span>(message);</span></span><br><span class="line"><span class="language-javascript">                messageInput.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        messageInput.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (event.<span class="property">key</span> === <span class="string">&#x27;Enter&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                sendBtn.<span class="title function_">click</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：请将 <code>wsUrl</code> 中的 <code>/your-app-context/</code> 替换为你的 Web 应用的实际上下文路径。如果应用部署在根目录，就直接删除它。</p>
<hr>
<h3 id="4-5-部署与测试"><a href="#4-5-部署与测试" class="headerlink" title="4.5 部署与测试"></a>4.5 部署与测试</h3><ol>
<li>将项目打包成 <code>.war</code> 文件。</li>
<li>将 <code>.war</code> 文件部署到任何支持 JSR 356 的 Servlet 容器中，如 Tomcat 8.5+ 或 Jetty 9+。</li>
<li>启动容器。</li>
<li>在浏览器中打开多个标签页，访问 <code>index.html</code>。</li>
<li>在不同的标签页中输入不同的用户名，可以进入相同或不同的房间。</li>
<li>测试发送消息，观察消息是否只在同一房间内广播，以及加入&#x2F;离开的系统通知是否正常工作。</li>
</ol>
<hr>
<h1 id="四、Spring-Boot-集成原生-WebSocket"><a href="#四、Spring-Boot-集成原生-WebSocket" class="headerlink" title="四、Spring Boot 集成原生 WebSocket"></a>四、Spring Boot 集成原生 WebSocket</h1><h2 id="1-核心三步走"><a href="#1-核心三步走" class="headerlink" title="1. 核心三步走"></a>1. 核心三步走</h2><h3 id="1-1-添加依赖"><a href="#1-1-添加依赖" class="headerlink" title="1.1 添加依赖"></a>1.1 添加依赖</h3><p>首先，在你的 <code>pom.xml</code> 文件中添加 Spring Boot 的 WebSocket starter 依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-2-编写处理器"><a href="#1-2-编写处理器" class="headerlink" title="1.2 编写处理器"></a>1.2 编写处理器</h3><p>在 JSR 356 中，我们使用带注解的 POJO (<code>@ServerEndpoint</code>)。在 Spring 中，我们创建一个<strong>处理器类 (Handler)</strong>，并将其注册为 Spring Bean。这个处理器负责处理 WebSocket 连接的整个生命周期。</p>
<p>Spring 提供了两个方便的抽象基类：</p>
<ul>
<li><code>TextWebSocketHandler</code>: 用于处理文本消息。</li>
<li><code>BinaryWebSocketHandler</code>: 用于处理二进制消息。</li>
</ul>
<p>你需要创建一个类继承其中之一，并重写其关键方法，这些方法与 JSR 356 的生命周期注解一一对应：</p>
<ul>
<li><code>afterConnectionEstablished(WebSocketSession session)</code>: 对应 <code>@OnOpen</code>，在连接建立后调用。</li>
<li><code>handleTextMessage(WebSocketSession session, TextMessage message)</code>: 对应 <code>@OnMessage</code>，在收到文本消息时调用。</li>
<li><code>afterConnectionClosed(WebSocketSession session, CloseStatus status)</code>: 对应 <code>@OnClose</code>，在连接关闭后调用。</li>
<li><code>handleTransportError(WebSocketSession session, Throwable exception)</code>: 对应 <code>@OnError</code>，在发生传输错误时调用。</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 关键：将这个 Handler 注册为 Spring Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebSocketHandler</span> <span class="keyword">extends</span> <span class="title class_">TextWebSocketHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存储所有活动会话的线程安全集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;WebSocketSession&gt; sessions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        sessions.add(session);</span><br><span class="line">        System.out.println(<span class="string">&quot;New connection established: &quot;</span> + session.getId());</span><br><span class="line">        <span class="comment">// 可以向新连接发送欢迎消息</span></span><br><span class="line">        session.sendMessage(<span class="keyword">new</span> <span class="title class_">TextMessage</span>(<span class="string">&quot;Welcome to the WebSocket server!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> message.getPayload();</span><br><span class="line">        System.out.println(<span class="string">&quot;Received message: &quot;</span> + payload + <span class="string">&quot; from session: &quot;</span> + session.getId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简单的广播逻辑：将收到的消息发给所有其他会话</span></span><br><span class="line">        <span class="keyword">for</span> (WebSocketSession webSocketSession : sessions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (webSocketSession.isOpen() &amp;&amp; !session.getId().equals(webSocketSession.getId())) &#123;</span><br><span class="line">                webSocketSession.sendMessage(<span class="keyword">new</span> <span class="title class_">TextMessage</span>(<span class="string">&quot;Broadcast: &quot;</span> + payload));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus status)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        sessions.remove(session);</span><br><span class="line">        System.out.println(<span class="string">&quot;Connection closed: &quot;</span> + session.getId() + <span class="string">&quot; with status: &quot;</span> + status.getCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Error for session &quot;</span> + session.getId() + <span class="string">&quot;: &quot;</span> + exception.getMessage());</span><br><span class="line">        <span class="comment">// 发生错误后，Spring 通常会自动关闭会话，所以 afterConnectionClosed 也会被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-3-注册处理器"><a href="#1-3-注册处理器" class="headerlink" title="1.3 注册处理器"></a>1.3 注册处理器</h3><p>我们已经创建了处理器 Bean，但 Spring 并不知道应该在哪个 URL 路径上激活这个处理器。我们需要一个配置类来完成这个“映射”。</p>
<ol>
<li>创建一个 Java 配置类，并注解为 <code>@Configuration</code>。</li>
<li>使用 <code>@EnableWebSocket</code> 注解来开启 Spring 的 WebSocket 功能。</li>
<li>实现 <code>WebSocketConfigurer</code> 接口。</li>
<li>重写 <code>registerWebSocketHandlers(WebSocketHandlerRegistry registry)</code> 方法，在其中注册你的处理器。</li>
</ol>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span> <span class="comment">// 开启 WebSocket 支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyWebSocketHandler myWebSocketHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造器注入我们之前创建的 Handler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WebSocketConfig</span><span class="params">(MyWebSocketHandler myWebSocketHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myWebSocketHandler = myWebSocketHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addHandler(myWebSocketHandler, <span class="string">&quot;/my-handler&quot;</span>) <span class="comment">// 注册 Handler 到指定的路径</span></span><br><span class="line">                .setAllowedOrigins(<span class="string">&quot;*&quot;</span>); <span class="comment">// 解决跨域问题</span></span><br><span class="line">                <span class="comment">// .withSockJS(); // (可选) 如果需要支持不支持 WebSocket 的旧浏览器，可以开启 SockJS 后备选项</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>registry.addHandler(myWebSocketHandler, &quot;/my-handler&quot;)</code>: 这行代码是核心，它告诉 Spring：“当有 WebSocket 连接请求访问 <code>/my-handler</code> 这个路径时，请交由 <code>myWebSocketHandler</code> 这个 Bean 来处理。”</li>
<li><code>.setAllowedOrigins(&quot;*&quot;)</code>: 这是非常重要的配置，用于处理浏览器的跨域请求。<code>&quot;*&quot;</code> 表示允许来自任何源的连接，在生产环境中应配置为具体的域名列表。</li>
<li><code>.withSockJS()</code>: 这是一个强大的后备选项。如果客户端的浏览器不支持 WebSocket，SockJS 会自动降级，使用 HTTP 长轮询等技术来模拟 WebSocket 通信，对上层应用代码是透明的。</li>
</ul>
<p>完成这三步之后，启动你的 Spring Boot 应用。一个位于 <code>ws://localhost:8080/my-handler</code> 的 WebSocket 服务就已经在运行了。这套流程充分体现了 Spring 框架“约定优于配置”和“依赖注入”的设计哲学。</p>
<hr>
<h2 id="2-核心组件详解"><a href="#2-核心组件详解" class="headerlink" title="2. 核心组件详解"></a>2. 核心组件详解</h2><p>在 Spring WebSocket 中，我们不直接与底层的 Servlet API 或 JSR-356 API 交互，而是通过 Spring 提供的一系列高度封装和抽象的组件。理解这些核心组件是掌握 Spring WebSocket 的关键。</p>
<hr>
<h3 id="2-1-Spring-封装的会话对象"><a href="#2-1-Spring-封装的会话对象" class="headerlink" title="2.1 Spring 封装的会话对象"></a>2.1 Spring 封装的会话对象</h3><p><code>WebSocketSession</code> 是 Spring 对一个 WebSocket 连接的抽象，可以将其理解为一个特定客户端连接的会话句柄。它在原生 <code>javax.websocket.Session</code> 的基础上进行了功能增强和整合，使其与 Spring 生态无缝集成。</p>
<p><strong><code>WebSocketSession</code> 与原生 <code>Session</code> 的异同：</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Spring <code>WebSocketSession</code></th>
<th align="left">原生 <code>javax.websocket.Session</code> (JSR-356)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>本质</strong></td>
<td align="left">Spring WebSocket 模块提供的接口，是 Spring 对 WebSocket 连接的统一抽象。</td>
<td align="left">Java EE 规范 (JSR-356) 中定义的标准接口。</td>
</tr>
<tr>
<td align="left"><strong>获取方式</strong></td>
<td align="left">作为 <code>WebSocketHandler</code> 方法的参数传入。</td>
<td align="left">通过 <code>@OnOpen</code> 等注解的方法参数传入。</td>
</tr>
<tr>
<td align="left"><strong>发送消息</strong></td>
<td align="left"><code>sendMessage(WebSocketMessage&lt;?&gt; message)</code></td>
<td align="left"><code>getBasicRemote().sendText(String text)</code> 或 <code>getAsyncRemote().sendBinary(ByteBuffer data)</code></td>
</tr>
<tr>
<td align="left"><strong>会话属性</strong></td>
<td align="left"><code>Map&lt;String, Object&gt; getAttributes()</code>，与 <code>HandshakeInterceptor</code> 强关联，是传递认证信息和业务数据的核心。</td>
<td align="left"><code>Map&lt;String, Object&gt; getUserProperties()</code>，功能类似，但与 Spring 生态集成度低。</td>
</tr>
<tr>
<td align="left"><strong>用户身份</strong></td>
<td align="left"><code>getPrincipal()</code> 方法，可以方便地与 Spring Security 集成，直接获取认证后的用户信息 (<code>Principal</code> 对象)。</td>
<td align="left">需要手动从 <code>getUserProperties()</code> 中获取或通过其他方式管理用户身份。</td>
</tr>
<tr>
<td align="left"><strong>实现无关性</strong></td>
<td align="left">屏蔽了底层 WebSocket 服务器（如 Tomcat, Jetty, Undertow）的实现差异，提供统一的编程模型。</td>
<td align="left">实现由具体的 Servlet 容器提供，理论上可移植，但 Spring 提供了更高层次的抽象。</td>
</tr>
<tr>
<td align="left"><strong>关闭连接</strong></td>
<td align="left"><code>close()</code> 或 <code>close(CloseStatus status)</code></td>
<td align="left"><code>close()</code> 或 <code>close(CloseReason reason)</code></td>
</tr>
</tbody></table>
<p><strong>核心方法与属性解读：</strong></p>
<ul>
<li><strong><code>String getId()</code></strong>: 获取 Spring 自动生成的唯一会话 ID。</li>
<li><strong><code>URI getUri()</code></strong>: 获取客户端连接的 URI。</li>
<li><strong><code>Map&lt;String, Object&gt; getAttributes()</code></strong>: <strong>【极其重要】</strong> 获取在握手阶段 <code>HandshakeInterceptor</code> 中存入的属性。这是从 HTTP 握手上下文向 WebSocket 会话传递数据的<strong>核心桥梁</strong>。例如，可以存放用户 ID、租户信息等。</li>
<li><strong><code>Principal getPrincipal()</code></strong>: 如果集成了 Spring Security，此方法可以直接返回当前会-话关联的认证主体。</li>
<li><strong><code>void sendMessage(WebSocketMessage&lt;?&gt; message)</code></strong>: 发送消息到客户端。参数是 <code>TextMessage</code> 或 <code>BinaryMessage</code> 的实例。</li>
<li><strong><code>boolean isOpen()</code></strong>: 判断连接是否依然处于打开状态。</li>
<li><strong><code>void close(CloseStatus status)</code></strong>: 以指定的状态码和原因关闭连接。</li>
</ul>
<p><strong>使用场景示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 WebSocketHandler 的实现中</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 从 session 的 attributes 中获取握手时存入的用户ID</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> (String) session.getAttributes().get(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;用户 &quot;</span> + userId + <span class="string">&quot; 连接成功，会话ID: &quot;</span> + session.getId());</span><br><span class="line">    <span class="comment">// 将 session 存入一个Map，以便后续根据用户ID查找并发送消息</span></span><br><span class="line">    sessionMap.put(userId, session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-握手拦截器"><a href="#2-2-握手拦截器" class="headerlink" title="2.2 握手拦截器"></a>2.2 握手拦截器</h3><p><code>HandshakeInterceptor</code> 是一个典型的拦截器（或AOP）模式应用。它在 WebSocket 的“握手”阶段（即客户端发起 HTTP Upgrade 请求时）介入，允许你在连接正式建立之前执行自定义逻辑。</p>
<p><strong>核心用途：</strong></p>
<ol>
<li><strong>身份验证与授权</strong>：这是最常见的用途。拦截器可以检查 HTTP 请求中的 <code>Cookie</code>, <code>Authorization</code> Header (如 JWT)，或者 <code>HttpSession</code>，判断用户是否已登录、是否有权限建立 WebSocket 连接。</li>
<li><strong>传递属性</strong>：将从 HTTP 请求中获取的信息（如用户ID、设备信息等）存入 <code>WebSocketSession</code> 的 <code>attributes</code> 中，供后续的 <code>WebSocketHandler</code> 使用。</li>
<li><strong>连接拒绝</strong>：如果验证失败，可以直接中断握手过程，拒绝 WebSocket 连接。</li>
</ol>
<p><strong>核心方法详解：</strong></p>
<ul>
<li><strong><code>boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</code></strong>:<ul>
<li><strong>执行时机</strong>：在握手发生之前调用。</li>
<li><strong>参数解读</strong>：<ul>
<li><code>request</code>: 强转为 <code>ServletServerHttpRequest</code> 后，可从中获取 <code>HttpServletRequest</code>，进而拿到 <code>HttpSession</code>、<code>Headers</code>、<code>Cookies</code> 等所有 HTTP 相关信息。</li>
<li><code>response</code>: 如果需要拒绝连接，可以通过它设置 HTTP 状态码，例如 <code>response.setStatusCode(HttpStatus.FORBIDDEN)</code>。</li>
<li><code>wsHandler</code>: 即将处理此 WebSocket 连接的 <code>WebSocketHandler</code> 实例。</li>
<li><code>attributes</code>: <strong>【关键】</strong> 一个空的 <code>Map</code>。你可以在此方法中向这个 <code>Map</code> 填充数据，这些数据随后会被复制到 <code>WebSocketSession</code> 的 <code>attributes</code> 中。</li>
</ul>
</li>
<li><strong>返回值</strong>：<ul>
<li><code>true</code>: 握手继续，连接将建立。</li>
<li><code>false</code>: 握手被中断，连接建立失败。此时应通过 <code>response</code> 对象返回一个合适的 HTTP 错误码。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception exception)</code></strong>:<ul>
<li><strong>执行时机</strong>：在握手成功或失败之后调用。</li>
<li><strong>参数解读</strong>：<ul>
<li><code>exception</code>: 如果握手过程中发生异常，此参数将不为 <code>null</code>。</li>
</ul>
</li>
<li><strong>主要用途</strong>：记录日志、资源清理等。无论握手成功与否，此方法都会被调用。</li>
</ul>
</li>
</ul>
<p><strong>实践代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthHandshakeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandshakeInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">beforeHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span><br><span class="line"><span class="params">                                   WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 将 request 强转为 ServletServerHttpRequest 以获取 HttpSession</span></span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> ServletServerHttpRequest) &#123;</span><br><span class="line">            <span class="type">ServletServerHttpRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> (ServletServerHttpRequest) request;</span><br><span class="line">            <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> servletRequest.getServletRequest().getSession(<span class="literal">false</span>); <span class="comment">// false表示不创建新session</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (session != <span class="literal">null</span> &amp;&amp; session.getAttribute(<span class="string">&quot;LOGGED_IN_USER_ID&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 用户已登录，将用户ID存入WebSocket的attributes</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;LOGGED_IN_USER_ID&quot;</span>);</span><br><span class="line">                attributes.put(<span class="string">&quot;userId&quot;</span>, userId);</span><br><span class="line">                System.out.println(<span class="string">&quot;握手拦截器：用户 &quot;</span> + userId + <span class="string">&quot; 验证通过。&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 允许握手</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用户未登录或 session 不存在，拒绝握手</span></span><br><span class="line">        System.out.println(<span class="string">&quot;握手拦截器：未认证用户，拒绝连接。&quot;</span>);</span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED); <span class="comment">// 401 Unauthorized</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 拒绝握手</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span><br><span class="line"><span class="params">                               WebSocketHandler wsHandler, Exception exception)</span> &#123;</span><br><span class="line">        <span class="comment">// 此处可以记录日志，例如 &quot;Handshake completed&quot; or &quot;Handshake failed with exception: ...&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-消息载体对象"><a href="#2-3-消息载体对象" class="headerlink" title="2.3 消息载体对象"></a>2.3 消息载体对象</h3><p>WebSocket 协议支持两种基本的数据帧类型：文本帧（Text Frame）和二进制帧（Binary Frame）。Spring WebSocket 提供了 <code>TextMessage</code> 和 <code>BinaryMessage</code> 这两个具体的类来分别承载这两种类型的消息。它们都继承自抽象类 <code>WebSocketMessage</code>。</p>
<p><strong><code>TextMessage</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：用于传输纯文本数据，最常见的如 <strong>JSON</strong>、XML、或者简单的字符串命令。</p>
</li>
<li><p><strong>构造</strong>：<code>new TextMessage(&quot;your string payload&quot;)</code>。</p>
</li>
<li><p><strong>获取内容</strong>：<code>getPayload()</code> 方法返回一个 <code>String</code>。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送JSON字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;type\&quot;:\&quot;chat\&quot;, \&quot;content\&quot;:\&quot;Hello, world!\&quot;&#125;&quot;</span>;</span><br><span class="line">session.sendMessage(<span class="keyword">new</span> <span class="title class_">TextMessage</span>(json));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 handleTextMessage 方法中接收</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> message.getPayload(); <span class="comment">// payload 是 &quot;&#123;\&quot;type\&quot;:\&quot;chat\&quot;, ...&#125;&quot;</span></span><br><span class="line">    <span class="comment">// 后续通常会用 Jackson 或 Gson 等库将 payload 解析为 Java 对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>BinaryMessage</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：用于传输非文本数据，如图片、音频、视频流、文件，或者经过 Protobuf&#x2F;Thrift 等序列化框架编码后的二进制数据。</p>
</li>
<li><p><strong>构造</strong>：<code>new BinaryMessage(byte[] payload)</code> 或 <code>new BinaryMessage(ByteBuffer payload)</code>。</p>
</li>
<li><p><strong>获取内容</strong>：<code>getPayload()</code> 方法返回一个 <code>ByteBuffer</code>。你可以通过 <code>byteBuffer.array()</code> 转换为 <code>byte[]</code>。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送一张图片的字节数据</span></span><br><span class="line"><span class="type">byte</span>[] imageBytes = readImageFromFile(<span class="string">&quot;path/to/image.jpg&quot;</span>);</span><br><span class="line">session.sendMessage(<span class="keyword">new</span> <span class="title class_">BinaryMessage</span>(imageBytes));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 handleBinaryMessage 方法中接收</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleBinaryMessage</span><span class="params">(WebSocketSession session, BinaryMessage message)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">payload</span> <span class="operator">=</span> message.getPayload();</span><br><span class="line">    <span class="type">byte</span>[] binaryData = <span class="keyword">new</span> <span class="title class_">byte</span>[payload.remaining()];</span><br><span class="line">    payload.get(binaryData);</span><br><span class="line">    <span class="comment">// 后续可以处理这些二进制数据，如存为文件、显示图片等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>补充：消息分片（Message Fragmentation）</strong></p>
<p>对于非常大的消息，WebSocket 允许将其分割成多个帧进行传输。</p>
<ul>
<li><code>WebSocketMessage</code> 有一个 <code>isLast()</code> 方法，<code>true</code> 表示这是消息的最后一个分片。</li>
<li>在 <code>AbstractWebSocketHandler</code> 中，默认行为是<strong>缓冲所有分片</strong>，直到接收完最后一个分片，然后将它们合并成一个完整的 <code>TextMessage</code> 或 <code>BinaryMessage</code>，再调用 <code>handleTextMessage</code> 或 <code>handleBinaryMessage</code>。</li>
<li>这意味着在大多数情况下，你无需关心消息分片问题，Spring 已经为你处理好了。如果需要处理流式大数据，可以重写 <code>supportsPartialMessages()</code> 返回 <code>true</code>，并实现 <code>handleMessage()</code> 来处理每一个分片。但这属于高级用法。</li>
</ul>
<hr>
<h2 id="3-实践技巧"><a href="#3-实践技巧" class="headerlink" title="3. 实践技巧"></a>3. 实践技巧</h2><h4 id="3-1-管理所有-WebSocketSession-实现广播功能"><a href="#3-1-管理所有-WebSocketSession-实现广播功能" class="headerlink" title="3.1 管理所有 WebSocketSession 实现广播功能"></a>3.1 管理所有 <code>WebSocketSession</code> 实现广播功能</h4><p>广播（Broadcast）是指向所有当前连接的客户端发送同一条消息。这是许多实时应用的常见需求，例如系统公告、在线用户列表更新等。</p>
<p>要实现广播，服务器端必须持有一个所有活动 <code>WebSocketSession</code> 的引用集合。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li><strong>选择一个线程安全的集合</strong>：<br>由于 WebSocket 的连接和断开是并发操作（可能多个用户同时连接或断开），用于存储 <code>WebSocketSession</code> 的集合<strong>必须是线程安全的</strong>。<ul>
<li><strong><code>CopyOnWriteArraySet&lt;WebSocketSession&gt;</code></strong>：<strong>强烈推荐用于广播场景</strong>。它是一个线程安全的 <code>Set</code>。其特点是“写入时复制”，读操作（迭代）非常快且不需要加锁，非常适合“读多写少”的场景。广播就是典型的读多场景，而连接&#x2F;断开（写操作）相对较少。</li>
<li><code>ConcurrentHashMap&lt;String, WebSocketSession&gt;</code>：当你不仅需要广播，还需要根据特定标识（如用户ID）快速查找并向单个用户发送消息时，这是更好的选择。键（<code>String</code>）可以是 <code>session.getId()</code> 或更业务化的用户ID。</li>
</ul>
</li>
<li><strong>在 <code>WebSocketHandler</code> 中维护该集合</strong>：<br>在你的 <code>WebSocketHandler</code> 实现类中，声明这个线程安全的集合作为成员变量。</li>
<li><strong>在连接生命周期方法中更新集合</strong>：<ul>
<li>在 <code>afterConnectionEstablished()</code> 方法中，将新建立的 <code>WebSocketSession</code> 添加到集合中。</li>
<li>在 <code>afterConnectionClosed()</code> 方法中，将已关闭的 <code>WebSocketSession</code> 从集合中移除，以防内存泄漏和向无效连接发送消息。</li>
</ul>
</li>
<li><strong>实现广播方法</strong>：<br>遍历集合，对每一个 <code>WebSocketSession</code> 调用 <code>sendMessage()</code> 方法。</li>
</ol>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBroadcastHandler</span> <span class="keyword">extends</span> <span class="title class_">TextWebSocketHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 使用 CopyOnWriteArraySet 存储所有 session，保证线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;WebSocketSession&gt; sessions = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 2. 连接建立后，将 session 添加到集合中</span></span><br><span class="line">        sessions.add(session);</span><br><span class="line">        System.out.println(<span class="string">&quot;新连接加入! 当前在线人数: &quot;</span> + sessions.size());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// (可选) 可以向新连接发送一条欢迎消息或当前状态</span></span><br><span class="line">        session.sendMessage(<span class="keyword">new</span> <span class="title class_">TextMessage</span>(<span class="string">&quot;欢迎连接到广播服务！&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 当一个客户端发送消息时，我们将其广播给所有客户端</span></span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息: &quot;</span> + message.getPayload());</span><br><span class="line">        broadcast(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus status)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 3. 连接关闭后，将 session 从集合中移除</span></span><br><span class="line">        sessions.remove(session);</span><br><span class="line">        System.out.println(<span class="string">&quot;一个连接关闭! 当前在线人数: &quot;</span> + sessions.size());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 传输发生错误时，也需要从集合中移除 session</span></span><br><span class="line">        System.err.println(<span class="string">&quot;连接出现错误: &quot;</span> + exception.getMessage());</span><br><span class="line">        sessions.remove(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4. 实现广播消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 要发送的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">broadcast</span><span class="params">(TextMessage message)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (WebSocketSession session : sessions) &#123;</span><br><span class="line">            <span class="comment">// 检查 session 是否还打开</span></span><br><span class="line">            <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 发送消息</span></span><br><span class="line">                    session.sendMessage(message);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// 记录错误，通常这里不需要做特别处理，因为 afterConnectionClosed 会处理会话移除</span></span><br><span class="line">                    System.err.println(<span class="string">&quot;广播消息失败: &quot;</span> + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-结合-HandshakeInterceptor-和-WebSocketSession-实现用户身份识别"><a href="#3-2-结合-HandshakeInterceptor-和-WebSocketSession-实现用户身份识别" class="headerlink" title="3.2 结合 HandshakeInterceptor 和 WebSocketSession 实现用户身份识别"></a>3.2 结合 <code>HandshakeInterceptor</code> 和 <code>WebSocketSession</code> 实现用户身份识别</h4><p>匿名连接在很多场景下是无用的。我们通常需要知道每个 <code>WebSocketSession</code> 对应的是哪个用户。这个身份识别的过程完美地体现了 <code>HandshakeInterceptor</code> 和 <code>WebSocketSession</code> 的协同工作。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li><strong>客户端在握手时提供身份信息</strong>：<ul>
<li><strong>对于有状态Web应用</strong>：通常浏览器在发起 WebSocket 连接请求时会自动带上 <code>Cookie</code>，其中包含了 <code>JSESSIONID</code>。</li>
<li><strong>对于无状态&#x2F;前后端分离应用</strong>：客户端通常会在 URL 查询参数 (<code>ws://.../?token=xxx</code>) 或 HTTP Header (<code>Authorization: Bearer xxx</code>) 中携带认证凭证（如 JWT）。</li>
</ul>
</li>
<li><strong>创建 <code>HandshakeInterceptor</code> 进行身份验证</strong>：<ul>
<li>实现 <code>HandshakeInterceptor</code> 接口，重点是 <code>beforeHandshake</code> 方法。</li>
<li>在 <code>beforeHandshake</code> 中，从 <code>ServerHttpRequest</code> 中获取身份信息。</li>
<li>验证身份。如果验证失败，返回 <code>false</code> 拒绝连接。</li>
<li>如果验证成功，将用户的唯一标识（如用户ID）存入 <code>attributes</code> 这个 <code>Map</code> 中。</li>
</ul>
</li>
<li><strong>在 <code>WebSocketHandler</code> 中获取并使用用户身份</strong>：<ul>
<li>在 <code>afterConnectionEstablished</code> 或其他处理器方法中，通过 <code>session.getAttributes().get(&quot;yourKey&quot;)</code> 来获取之前存入的用户ID。</li>
<li>利用这个ID，你可以实现更复杂的逻辑，例如：<ul>
<li>维护一个 <code>ConcurrentHashMap&lt;String, WebSocketSession&gt;</code> 来实现<strong>向指定用户发送消息</strong>。</li>
<li>记录用户行为日志。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>代码示例：</strong></p>
<p><strong>第一步：创建握手拦截器 <code>AuthHandshakeInterceptor</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthHandshakeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandshakeInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">beforeHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span><br><span class="line"><span class="params">                                   WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 场景：从 HttpSession 中获取登录用户ID</span></span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> ServletServerHttpRequest) &#123;</span><br><span class="line">            <span class="type">ServletServerHttpRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> (ServletServerHttpRequest) request;</span><br><span class="line">            <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> servletRequest.getServletRequest().getSession(<span class="literal">false</span>); <span class="comment">// false:不创建新session</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 假设登录后，用户ID被存储在HttpSession的 &quot;userId&quot; 属性中</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (userId != <span class="literal">null</span> &amp;&amp; !userId.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 验证通过，将 userId 放入 WebSocketSession 的 attributes 中</span></span><br><span class="line">                    attributes.put(<span class="string">&quot;userId&quot;</span>, userId);</span><br><span class="line">                    System.out.println(<span class="string">&quot;握手成功，用户ID: &quot;</span> + userId);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 允许握手</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果是JWT，则可以这样获取:</span></span><br><span class="line">        <span class="comment">// String token = request.getHeaders().getFirst(&quot;Authorization&quot;);</span></span><br><span class="line">        <span class="comment">// if (jwtUtil.validate(token)) &#123;</span></span><br><span class="line">        <span class="comment">//     String userId = jwtUtil.getUserIdFrom(token);</span></span><br><span class="line">        <span class="comment">//     attributes.put(&quot;userId&quot;, userId);</span></span><br><span class="line">        <span class="comment">//     return true;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;握手失败，用户未认证！&quot;</span>);</span><br><span class="line">        <span class="comment">// 验证失败，拒绝握手</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span><br><span class="line"><span class="params">                               WebSocketHandler wsHandler, Exception exception)</span> &#123;</span><br><span class="line">        <span class="comment">// 握手后的操作，无论成功失败都会执行，可用于记录日志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步：在 <code>WebSocketConfig</code> 中注册拦截器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addHandler(myBroadcastHandler(), <span class="string">&quot;/broadcast&quot;</span>)</span><br><span class="line">                .addInterceptors(<span class="keyword">new</span> <span class="title class_">AuthHandshakeInterceptor</span>()) <span class="comment">// &lt;-- 在这里添加拦截器</span></span><br><span class="line">                .setAllowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyBroadcastHandler <span class="title function_">myBroadcastHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBroadcastHandler</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三步：在 <code>WebSocketHandler</code> 中使用身份信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 从 session 的 attributes 中获取握手时存入的用户ID</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> (String) session.getAttributes().get(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (userId != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户 &quot;</span> + userId + <span class="string">&quot; 连接成功！&quot;</span>);</span><br><span class="line">        <span class="comment">// 此时，你可以将 userId 和 session 的关系存储起来，用于后续的单点消息发送</span></span><br><span class="line">        <span class="comment">// userSessionMap.put(userId, session);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-示例代码-1"><a href="#4-示例代码-1" class="headerlink" title="4. 示例代码"></a>4. 示例代码</h2><p><strong>业务目标：</strong></p>
<ol>
<li>当一个新用户连接时，所有已在线的用户都会收到通知，告知新用户加入了，并更新自己的在线用户列表。</li>
<li>当一个用户断开连接时，所有剩余的在线用户都会收到通知，告知该用户已离开，并更新自己的在线用户列表。</li>
<li>客户端通过 WebSocket URL 的查询参数传递自己的用户名，例如 <code>ws://localhost:8080/status?username=Alice</code>。</li>
<li>服务器拒绝重名用户的连接。</li>
</ol>
<p>这个示例将完美地演示 <code>HandshakeInterceptor</code>（用于身份识别和验证）和 <code>WebSocketHandler</code>（用于会话管理和广播）的协同工作。</p>
<hr>
<h3 id="4-1-项目设置-pom-xml"><a href="#4-1-项目设置-pom-xml" class="headerlink" title="4.1 项目设置 (pom.xml)"></a>4.1 项目设置 (pom.xml)</h3><p>确保你的 Spring Boot 项目中包含了 WebSocket 的启动器。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... 其他依赖 ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2-创建握手拦截器-UserStatusHandshakeInterceptor"><a href="#4-2-创建握手拦截器-UserStatusHandshakeInterceptor" class="headerlink" title="4.2 创建握手拦截器 (UserStatusHandshakeInterceptor)"></a>4.2 创建握手拦截器 (<code>UserStatusHandshakeInterceptor</code>)</h3><p>这个拦截器的职责是：</p>
<ol>
<li>从连接请求的 URI 中解析出 <code>username</code>。</li>
<li>验证 <code>username</code> 是否存在且不重复。</li>
<li>如果验证通过，将 <code>username</code> 存入 <code>attributes</code>，以便后续的 <code>WebSocketHandler</code> 使用。</li>
<li>如果验证失败，中断握手。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserStatusHandshakeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandshakeInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">beforeHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span><br><span class="line"><span class="params">                                   WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 从 URI 中解析出 username</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> UriComponentsBuilder.fromUri(request.getURI())</span><br><span class="line">                .build()</span><br><span class="line">                .getQueryParams()</span><br><span class="line">                .getFirst(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 验证 username 是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(username)) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;握手失败：username 参数为空&quot;</span>);</span><br><span class="line">            response.setStatusCode(HttpStatus.BAD_REQUEST); <span class="comment">// 400 Bad Request</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 验证 username 是否已在线 (简单起见，我们直接访问 Handler 里的静态 Map)</span></span><br><span class="line">        <span class="keyword">if</span> (OnlineStatusHandler.isUserOnline(username)) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;握手失败：用户 &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; 已在线&quot;</span>);</span><br><span class="line">            response.setStatusCode(HttpStatus.CONFLICT); <span class="comment">// 409 Conflict</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将 username 存入 attributes，传递给 WebSocketHandler</span></span><br><span class="line">        attributes.put(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">        System.out.println(<span class="string">&quot;握手成功，用户: &quot;</span> + username);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span><br><span class="line"><span class="params">                               WebSocketHandler wsHandler, Exception exception)</span> &#123;</span><br><span class="line">        <span class="comment">// 无需实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-创建-WebSocket-处理器-OnlineStatusHandler"><a href="#4-3-创建-WebSocket-处理器-OnlineStatusHandler" class="headerlink" title="4.3 创建 WebSocket 处理器 (OnlineStatusHandler)"></a>4.3 创建 WebSocket 处理器 (<code>OnlineStatusHandler</code>)</h3><p>这个处理器的职责是：</p>
<ol>
<li>管理所有在线用户的 <code>WebSocketSession</code>。我们使用 <code>ConcurrentHashMap&lt;String, WebSocketSession&gt;</code> 来存储用户名到会话的映射。</li>
<li>在 <code>afterConnectionEstablished</code> 中，将新用户加入 Map，并广播“用户加入”的消息。</li>
<li>在 <code>afterConnectionClosed</code> 中，将用户从 Map 中移除，并广播“用户离开”的消息。</li>
<li>提供一个 <code>broadcastStatusUpdate</code> 方法来统一处理广播逻辑。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnlineStatusHandler</span> <span class="keyword">extends</span> <span class="title class_">TextWebSocketHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ConcurrentHashMap 存储在线用户的 session，key 是 username</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, WebSocketSession&gt; userSessions = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>(); <span class="comment">// 用于序列化 JSON</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getAttributes().get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        userSessions.put(username, session);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户 &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; 连接成功. 当前在线人数: &quot;</span> + userSessions.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 广播状态更新</span></span><br><span class="line">        broadcastStatusUpdate(<span class="string">&quot;USER_JOIN&quot;</span>, username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus status)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) session.getAttributes().get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        userSessions.remove(username);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户 &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; 断开连接. 当前在线人数: &quot;</span> + userSessions.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 广播状态更新</span></span><br><span class="line">        broadcastStatusUpdate(<span class="string">&quot;USER_LEAVE&quot;</span>, username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 广播用户状态更新</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type &quot;USER_JOIN&quot; 或 &quot;USER_LEAVE&quot;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 发生状态改变的用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">broadcastStatusUpdate</span><span class="params">(String type, String username)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 构建消息体</span></span><br><span class="line">        Map&lt;String, Object&gt; messagePayload = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        messagePayload.put(<span class="string">&quot;type&quot;</span>, type);</span><br><span class="line">        messagePayload.put(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">        messagePayload.put(<span class="string">&quot;onlineUsers&quot;</span>, userSessions.keySet()); <span class="comment">// 发送当前所有在线用户的列表</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TextMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextMessage</span>(objectMapper.writeValueAsString(messagePayload));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向所有在线用户广播</span></span><br><span class="line">        <span class="keyword">for</span> (WebSocketSession session : userSessions.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                session.sendMessage(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助方法，用于拦截器检查用户是否已在线</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isUserOnline</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userSessions.containsKey(username);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在这个示例中，我们不处理客户端发来的消息，但保留该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 可以用于实现心跳等功能</span></span><br><span class="line">        System.out.println(<span class="string">&quot;收到来自 &quot;</span> + session.getAttributes().get(<span class="string">&quot;username&quot;</span>) + <span class="string">&quot; 的消息: &quot;</span> + message.getPayload());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Pro Tip</strong>: 在更大型的应用中，<code>userSessions</code> 这个 Map 最好放在一个单独的 <code>@Service</code> Bean 中，然后注入到 Handler 和 Interceptor 里，而不是使用 <code>static</code> 变量。这更符合 Spring 的依赖注入思想。</p>
<hr>
<h3 id="4-4-配置-WebSocket-WebSocketConfig"><a href="#4-4-配置-WebSocket-WebSocketConfig" class="headerlink" title="4.4 配置 WebSocket (WebSocketConfig)"></a>4.4 配置 WebSocket (<code>WebSocketConfig</code>)</h3><p>将我们创建的 Handler 和 Interceptor 注册到 Spring WebSocket 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span> <span class="comment">// 开启 WebSocket 支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OnlineStatusHandler onlineStatusHandler;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserStatusHandshakeInterceptor userStatusHandshakeInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addHandler(onlineStatusHandler, <span class="string">&quot;/status&quot;</span>) <span class="comment">// 注册处理器到 &quot;/status&quot; 路径</span></span><br><span class="line">                .addInterceptors(userStatusHandshakeInterceptor) <span class="comment">// 添加握手拦截器</span></span><br><span class="line">                .setAllowedOrigins(<span class="string">&quot;*&quot;</span>); <span class="comment">// 允许跨域访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-5-创建前端测试页面-index-html"><a href="#4-5-创建前端测试页面-index-html" class="headerlink" title="4.5 创建前端测试页面 (index.html)"></a>4.5 创建前端测试页面 (<code>index.html</code>)</h3><p>创建一个简单的 HTML 文件来测试我们的服务。你可以将它放在 <code>src/main/resources/static/index.html</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebSocket Online Status Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123; <span class="attribute">font-family</span>: sans-serif; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#controls</span>, <span class="selector-id">#status</span>, <span class="selector-id">#users</span> &#123; <span class="attribute">margin-bottom</span>: <span class="number">20px</span>; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#user-list</span> &#123; <span class="attribute">list-style-type</span>: none; <span class="attribute">padding</span>: <span class="number">0</span>; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#user-list</span> <span class="selector-tag">li</span> &#123; <span class="attribute">background</span>: <span class="number">#f0f0f0</span>; <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">8px</span>; <span class="attribute">border-radius</span>: <span class="number">4px</span>; &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#log</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>; <span class="attribute">padding</span>: <span class="number">10px</span>; <span class="attribute">height</span>: <span class="number">200px</span>; <span class="attribute">overflow-y</span>: scroll; <span class="attribute">background</span>: <span class="number">#fafafa</span>; &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>在线用户状态广播服务<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;controls&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username-input&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;输入你的用户名&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;connect()&quot;</span>&gt;</span>连接<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;disconnect()&quot;</span> <span class="attr">disabled</span>&gt;</span>断开<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;users&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>在线用户 (<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;user-count&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span>)<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;user-list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;status&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>系统日志<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;log&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> websocket = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> usernameInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;username-input&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> connectBtn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button[onclick=&quot;connect()&quot;]&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> disconnectBtn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button[onclick=&quot;disconnect()&quot;]&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> logDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;log&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> userList = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;user-list&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> userCount = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;user-count&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">message</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            logDiv.<span class="property">innerHTML</span> += <span class="string">`&lt;p&gt;<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;</span>: <span class="subst">$&#123;message&#125;</span>&lt;/p&gt;`</span>;</span></span><br><span class="line"><span class="language-javascript">            logDiv.<span class="property">scrollTop</span> = logDiv.<span class="property">scrollHeight</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">connect</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> username = usernameInput.<span class="property">value</span>.<span class="title function_">trim</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (!username) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&#x27;请输入用户名!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> url = <span class="string">`ws://localhost:8080/status?username=<span class="subst">$&#123;username&#125;</span>`</span>;</span></span><br><span class="line"><span class="language-javascript">            websocket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(url);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">log</span>(<span class="string">`与服务器连接成功！`</span>);</span></span><br><span class="line"><span class="language-javascript">                usernameInput.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">                connectBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">                disconnectBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(event.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">log</span>(<span class="string">`收到消息: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">                </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (data.<span class="property">type</span> === <span class="string">&#x27;USER_JOIN&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">log</span>(<span class="string">`[系统] 用户 &quot;<span class="subst">$&#123;data.username&#125;</span>&quot; 加入了聊天室。`</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.<span class="property">type</span> === <span class="string">&#x27;USER_LEAVE&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">log</span>(<span class="string">`[系统] 用户 &quot;<span class="subst">$&#123;data.username&#125;</span>&quot; 离开了聊天室。`</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                </span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 更新在线用户列表</span></span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">updateUserList</span>(data.<span class="property">onlineUsers</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onclose</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">log</span>(<span class="string">`连接已关闭。原因: <span class="subst">$&#123;event.reason || <span class="string">&#x27;未知&#x27;</span>&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">resetUI</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            websocket.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">log</span>(<span class="string">`发生错误: <span class="subst">$&#123;event.message || <span class="string">&#x27;连接失败&#x27;</span>&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">resetUI</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">disconnect</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (websocket) &#123;</span></span><br><span class="line"><span class="language-javascript">                websocket.<span class="title function_">close</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">updateUserList</span>(<span class="params">users</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            userList.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">            users.<span class="title function_">forEach</span>(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">                li.<span class="property">textContent</span> = user;</span></span><br><span class="line"><span class="language-javascript">                userList.<span class="title function_">appendChild</span>(li);</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">            userCount.<span class="property">textContent</span> = users.<span class="property">length</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">resetUI</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            usernameInput.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">            connectBtn.<span class="property">disabled</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">            disconnectBtn.<span class="property">disabled</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">            websocket = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">            userList.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">            userCount.<span class="property">textContent</span> = <span class="string">&#x27;0&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-6-运行和测试"><a href="#4-6-运行和测试" class="headerlink" title="4.6 运行和测试"></a>4.6 运行和测试</h3><ol>
<li>启动你的 Spring Boot 应用程序。</li>
<li>在浏览器中打开 <code>http://localhost:8080/index.html</code>。</li>
<li><strong>打开多个浏览器标签页或窗口</strong>，都访问该地址。</li>
<li>在第一个标签页，输入用户名 “Alice”，点击“连接”。你会看到日志显示连接成功，在线用户列表显示 “Alice”。</li>
<li>在第二个标签页，输入用户名 “Bob”，点击“连接”。<ul>
<li>“Bob” 的窗口会显示连接成功，在线用户列表为 [“Alice”, “Bob”]。</li>
<li>“Alice” 的窗口会收到一条广播消息，日志显示 “用户 Bob 加入了聊天室”，同时其在线用户列表也会更新为 [“Alice”, “Bob”]。</li>
</ul>
</li>
<li>尝试在第三个标签页使用已在线的用户名（如 “Alice”）连接，连接会失败（检查浏览器开发者工具的 Console 和 Network 面板，会看到 WebSocket 握手失败，HTTP 状态码为 409 Conflict）。</li>
<li>关闭 “Alice” 的浏览器标签页或点击“断开”。<ul>
<li>“Bob” 的窗口会收到一条广播消息，日志显示 “用户 Alice 离开了聊天室”，其在线用户列表更新为只有 “Bob”。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="五、Spring-Boot-STOMP"><a href="#五、Spring-Boot-STOMP" class="headerlink" title="五、Spring Boot + STOMP"></a>五、Spring Boot + STOMP</h1><h2 id="1-为什么需要-STOMP？"><a href="#1-为什么需要-STOMP？" class="headerlink" title="1. 为什么需要 STOMP？"></a>1. 为什么需要 STOMP？</h2><p>原生 WebSocket (JSR-356) 协议本身非常强大，它提供了一个全双工、低延迟的持久化连接通道。然而，它也仅仅是一个<strong>传输层协议</strong>，就像 TCP 一样。它只规定了如何建立连接和如何传输“一帧一帧”的数据（文本或二进制），但<strong>并未规定这些数据内容的具体格式和含义</strong>。</p>
<p>这就好比我们建好了一条双向高速公路（WebSocket 连接），但是路上没有任何交通规则、路牌或导航系统。每辆车（消息）都需要自己决定开往哪里，并且到达目的地后，接收方还需要自己解析这辆车里装的是什么。</p>
<p>在实际应用开发中，只使用原生 WebSocket 会遇到以下几个核心痛点：</p>
<h3 id="1-1-缺乏结构化的消息语义"><a href="#1-1-缺乏结构化的消息语义" class="headerlink" title="1.1 缺乏结构化的消息语义"></a>1.1 缺乏结构化的消息语义</h3><ul>
<li><p><strong>原生 WebSocket 的困境</strong>：服务器收到一个字符串消息，比如 <code>&quot;{&quot;user&quot;:&quot;Alice&quot;, &quot;message&quot;:&quot;Hello Bob&quot;}&quot;</code>。这个消息是什么意图？是发送给特定用户的私聊消息？还是广播到聊天室的公共消息？服务器必须解析 JSON 内容，然后根据自定义的字段（如 <code>type</code>, <code>action</code>, <code>toUser</code> 等）来编写大量的 <code>if-else</code> 或 <code>switch-case</code> 逻辑来分发消息。</p>
</li>
<li><p><strong>STOMP 的解决方案</strong>：STOMP (Simple Text Oriented Messaging Protocol) 是一种<strong>应用层协议</strong>，它定义了一套标准化的消息格式和命令。客户端不再是简单地 <code>send(&quot;some string&quot;)</code>，而是发送一个带有明确“意图”的<strong>命令帧 (Command Frame)</strong>。</p>
<p>例如，客户端想订阅一个主题：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE</span><br><span class="line">id:sub-1</span><br><span class="line">destination:/topic/chatRoom-A</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<p>客户端想发送一条消息到某个目的地：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SEND</span><br><span class="line">destination:/app/chat</span><br><span class="line">content-type:application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;from&quot;:&quot;Alice&quot;, &quot;text&quot;:&quot;Hello!&quot;&#125;</span><br><span class="line">^@</span><br></pre></td></tr></table></figure>

<p>服务器（或 Broker）看到 <code>SEND</code> 和 <code>destination</code> 就立刻明白了消息的目的地和意图，无需再解析消息体来做路由判断。</p>
</li>
</ul>
<hr>
<h3 id="1-2-没有内置的发布-订阅（Pub-Sub）和路由机制"><a href="#1-2-没有内置的发布-订阅（Pub-Sub）和路由机制" class="headerlink" title="1.2 没有内置的发布&#x2F;订阅（Pub&#x2F;Sub）和路由机制"></a>1.2 没有内置的发布&#x2F;订阅（Pub&#x2F;Sub）和路由机制</h3><ul>
<li><p><strong>原生 WebSocket 的困境</strong>：如果要实现一个聊天室，你需要手动维护一个映射关系，比如 <code>Map&lt;String, Set&lt;Session&gt;&gt;</code>，其中 Key 是聊天室 ID，Value 是该聊天室中所有用户的 WebSocket <code>Session</code> 集合。当收到一条发往该聊天室的消息时，你需要：</p>
<ol>
<li>从 Map 中找到对应的 <code>Set&lt;Session&gt;</code>。</li>
<li>遍历这个 Set。</li>
<li>对每一个 <code>Session</code> 调用 <code>session.getBasicRemote().sendText(...)</code>。<br>这个过程完全是手动编码，容易出错且难以扩展。</li>
</ol>
</li>
<li><p><strong>STOMP 的解决方案</strong>：STOMP 的核心就是<strong>基于“目的地”（Destination）的路由</strong>。它天然支持两种主流的消息模型：</p>
<ul>
<li><strong>发布&#x2F;订阅（Topics）</strong>：通常以 <code>/topic/</code> 开头。一个消息被发送到 <code>/topic/news</code>，所有订阅了该主题的客户端都会收到这个消息。非常适合广播场景，如股票行情、在线状态更新、公共聊天室。</li>
<li><strong>点对点（Queues）</strong>：通常以 <code>/queue/</code> 或 <code>/user/</code> 开头。一个消息被发送到队列，只有一个消费者（订阅者）会收到并处理它。非常适合任务处理、私聊消息等。</li>
</ul>
<p>开发者只需要让客户端 <code>SUBSCRIBE</code> 到某个 destination，然后向这个 destination <code>SEND</code> 消息即可。Spring 的 STOMP 支持会自动将消息路由给所有正确的订阅者，完全解耦了消息的生产者和消费者。</p>
</li>
</ul>
<hr>
<h3 id="1-3-缺乏高级消息特性"><a href="#1-3-缺乏高级消息特性" class="headerlink" title="1.3 缺乏高级消息特性"></a>1.3 缺乏高级消息特性</h3><ul>
<li><strong>原生 WebSocket 的困境</strong>：像消息确认（ACK）、事务、回执等企业级消息队列（MQ）中的常见功能，原生 WebSocket 均不提供。如果需要确保消息被客户端成功处理，你必须自己设计一套复杂的回执和重发机制。</li>
<li><strong>STOMP 的解决方案</strong>：STOMP 协议的设计深受传统 MQ 的影响，它支持更丰富的交互模式。例如，客户端可以在 <code>SUBSCRIBE</code> 时指定 <code>ack</code> 模式（<code>auto</code>, <code>client</code>, <code>client-individual</code>），从而实现消息的可靠消费。服务器发送消息后，需要等待客户端发回 <code>ACK</code> 或 <code>NACK</code> 帧，才能决定是否将消息从队列中移除。</li>
</ul>
<hr>
<h3 id="1-4-总结与类比"><a href="#1-4-总结与类比" class="headerlink" title="1.4 总结与类比"></a>1.4 总结与类比</h3><p>一个绝佳的类比是 <strong>HTTP 与 TCP</strong> 的关系：</p>
<ul>
<li><strong>WebSocket 就像 TCP</strong>：它提供了可靠的、双向的字节流传输通道。它很底层，很纯粹，给了你最大的灵活性，但也意味着你需要自己构建上层的一切。</li>
<li><strong>STOMP over WebSocket 就像 HTTP over TCP</strong>：它在底层的通道之上，定义了一套标准的、语义化的通信规则（命令、头信息、目的地）。它让你不再关心底层的字节流，而是专注于“发送一个请求”或“订阅一个资源”这样的业务逻辑。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">原生 WebSocket</th>
<th align="left">STOMP over WebSocket</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>抽象层级</strong></td>
<td align="left">传输层协议 (Transport-level)</td>
<td align="left">应用层协议 (Application-level)</td>
</tr>
<tr>
<td align="left"><strong>消息格式</strong></td>
<td align="left">无规定，通常是自定义 JSON&#x2F;XML</td>
<td align="left">标准化帧 (Frame)，包含命令、头部、内容</td>
</tr>
<tr>
<td align="left"><strong>路由</strong></td>
<td align="left">手动实现，管理 Session 集合</td>
<td align="left">基于 “Destination” 的自动路由</td>
</tr>
<tr>
<td align="left"><strong>消息模型</strong></td>
<td align="left">无内置模型，需手动实现</td>
<td align="left">内置 Pub&#x2F;Sub (<code>/topic</code>) 和 P2P (<code>/queue</code>)</td>
</tr>
<tr>
<td align="left"><strong>高级特性</strong></td>
<td align="left">无 (如 ACK, 事务)</td>
<td align="left">支持 (ACK, NACK, 事务等)</td>
</tr>
<tr>
<td align="left"><strong>开发复杂度</strong></td>
<td align="left">较高，需要处理大量底层细节</td>
<td align="left">较低，专注于业务逻辑和消息目的地</td>
</tr>
</tbody></table>
<p><strong>结论：</strong></p>
<p>虽然对于极简的场景，原生 WebSocket 已经足够，但只要你的应用涉及到任何形式的广播、路由、分类消息或需要与消息队列类似的行为时，<strong>使用 STOMP 就能极大地简化你的服务器和客户端代码，提供更健壮、更具扩展性的消息处理架构。</strong> Spring 对 STOMP 的完美支持更是让这一切变得唾手可得。</p>
<hr>
<h2 id="2-Spring-STOMP-核心配置"><a href="#2-Spring-STOMP-核心配置" class="headerlink" title="2. Spring STOMP 核心配置"></a>2. Spring STOMP 核心配置</h2><p>当你在 Spring Boot 项目中引入 <code>spring-boot-starter-websocket</code> 依赖后，Spring 的自动配置机制就已经为 WebSocket 和 STOMP 准备好了基础环境。我们接下来的配置，就是通过实现 <code>WebSocketMessageBrokerConfigurer</code> 接口，来定制和覆盖这些默认行为，使其符合我们的业务需求。</p>
<p>这整个配置可以看作是在绘制一张<strong>消息流转的蓝图</strong>。</p>
<h3 id="2-1-EnableWebSocketMessageBroker"><a href="#2-1-EnableWebSocketMessageBroker" class="headerlink" title="2.1 @EnableWebSocketMessageBroker"></a>2.1 <code>@EnableWebSocketMessageBroker</code></h3><p>这是一个核心注解，通常放在一个 <code>@Configuration</code> 类上。它不仅仅是一个开关，它的作用是<strong>启用 Spring 的 WebSocket 消息代理功能</strong>。</p>
<p>当 Spring 容器扫描到这个注解时，它会：</p>
<ol>
<li><strong>创建和注册处理 WebSocket 消息的核心组件 (Bean)</strong>。其中最重要的两个是：<ul>
<li>一个负责接收和解析客户端消息，并将其路由到 <code>@MessageMapping</code> 或 <code>@SubscribeMapping</code> 注解的方法。</li>
<li>另一个是内置的消息代理（Message Broker），用于处理订阅和广播。</li>
</ul>
</li>
<li><strong>使得 <code>WebSocketMessageBrokerConfigurer</code> 的配置生效</strong>。没有这个注解，你实现的配置类将不会被 Spring 用来配置 STOMP。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 开启STOMP协议的WebSocket消息代理支持</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">// ... 配置方法将在这里实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-WebSocketMessageBrokerConfigurer-接口详解"><a href="#2-2-WebSocketMessageBrokerConfigurer-接口详解" class="headerlink" title="2.2 WebSocketMessageBrokerConfigurer 接口详解"></a>2.2 <code>WebSocketMessageBrokerConfigurer</code> 接口详解</h3><p>这个接口提供了多个 <code>default</code> 方法，我们只需要重写需要定制的部分即可。最核心的是以下两个方法：</p>
<h4 id="2-2-1-registerStompEndpoints-StompEndpointRegistry-registry"><a href="#2-2-1-registerStompEndpoints-StompEndpointRegistry-registry" class="headerlink" title="2.2.1 registerStompEndpoints(StompEndpointRegistry registry)"></a>2.2.1 <code>registerStompEndpoints(StompEndpointRegistry registry)</code></h4><ul>
<li><strong>作用</strong>：注册 STOMP “端点” (Endpoint)。</li>
<li><strong>什么是端点？</strong> 这是 WebSocket 或 SockJS 客户端为了进行 WebSocket 握手而需要连接的 <strong>HTTP URL</strong>。可以把它理解为 WebSocket 服务的**“入口”<strong>或</strong>“接入点”**。</li>
<li><strong>核心代码与解释</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 注册一个名为 &quot;/ws-stomp&quot; 的 STOMP 端点。</span></span><br><span class="line">    <span class="comment">//    客户端将连接到 &quot;ws://localhost:8080/ws-stomp&quot;</span></span><br><span class="line">    <span class="type">StompEndpointRegistration</span> <span class="variable">endpoint</span> <span class="operator">=</span> registry.addEndpoint(<span class="string">&quot;/ws-stomp&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. setAllowedOrigins(&quot;*&quot;)：解决跨域问题。允许所有域的客户端连接。</span></span><br><span class="line">    <span class="comment">//    在生产环境中，应该指定具体的域名，如 &quot;https://example.com&quot;。</span></span><br><span class="line">    endpoint.setAllowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. withSockJS()：启用 SockJS 后备选项。</span></span><br><span class="line">    <span class="comment">//    如果浏览器不支持 WebSocket，SockJS 会自动降级为其他通信方式（如 HTTP Polling）。</span></span><br><span class="line">    <span class="comment">//    这极大地提高了应用的兼容性。客户端也需要使用 SockJS 库。</span></span><br><span class="line">    endpoint.withSockJS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>小结</strong>：这个方法定义了<strong>客户端如何连接到我们的服务</strong>。你可以注册多个端点，用于不同场景或不同类型的客户端。</li>
</ul>
<hr>
<h4 id="2-2-2-configureMessageBroker-MessageBrokerRegistry-registry"><a href="#2-2-2-configureMessageBroker-MessageBrokerRegistry-registry" class="headerlink" title="2.2.2 configureMessageBroker(MessageBrokerRegistry registry)"></a>2.2.2 <code>configureMessageBroker(MessageBrokerRegistry registry)</code></h4><ul>
<li><strong>作用</strong>：配置消息代理（Message Broker），它是 STOMP 消息处理的<strong>核心</strong>，负责<strong>路由、存储和广播消息</strong>。</li>
<li><strong>核心概念：消息流转路径</strong><ul>
<li><strong>发往应用 (Application)</strong>：客户端发送的消息，需要经过服务器端的 <code>@MessageMapping</code> 方法处理。这些消息的目的地通常有一个特定的前缀，如 <code>/app</code>。</li>
<li><strong>发往代理 (Broker)</strong>：消息直接由代理进行广播，无需应用层代码处理。这些消息的目的地前缀通常是 <code>/topic</code> (发布&#x2F;订阅) 或 <code>/queue</code> (点对点)。</li>
</ul>
</li>
<li><strong>核心代码与解释</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 配置应用程序目标前缀 (Application Destination Prefix)</span></span><br><span class="line">    <span class="comment">//    所有目的地以 &quot;/app&quot; 开头的 STOMP 消息都将被路由到 @MessageMapping 注解的方法中。</span></span><br><span class="line">    <span class="comment">//    例如，客户端发送目的地为 &quot;/app/chat&quot; 的消息，将由一个 @MessageMapping(&quot;/chat&quot;) 的方法处理。</span></span><br><span class="line">    registry.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 配置消息代理 (Message Broker)</span></span><br><span class="line">    <span class="comment">//    这里我们启用一个简单的、基于内存的消息代理。</span></span><br><span class="line">    <span class="comment">//    它将处理目的地以 &quot;/topic&quot; 或 &quot;/queue&quot; 开头的消息。</span></span><br><span class="line">    <span class="comment">//    - &quot;/topic&quot; 通常用于发布/订阅模式（一对多广播）。</span></span><br><span class="line">    <span class="comment">//    - &quot;/queue&quot; 通常用于点对点模式（一对一消息）。</span></span><br><span class="line">    registry.enableSimpleBroker(<span class="string">&quot;/topic&quot;</span>, <span class="string">&quot;/queue&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. (可选) 配置用户目的地前缀 (User Destination Prefix)</span></span><br><span class="line">    <span class="comment">//    当使用 @SendToUser 或 SimpMessagingTemplate.convertAndSendToUser() 时，</span></span><br><span class="line">    <span class="comment">//    Spring 会自动将消息的目的地重写为类似 &quot;/user/&#123;sessionId&#125;/...&quot; 的形式，</span></span><br><span class="line">    <span class="comment">//    确保消息只发送给特定的用户。默认就是 &quot;/user&quot;，一般无需修改。</span></span><br><span class="line">    <span class="comment">//    registry.setUserDestinationPrefix(&quot;/user&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>代理的两种模式：</strong></p>
<ul>
<li><p><strong>简单代理 (Simple Broker)</strong>：<code>enableSimpleBroker()</code></p>
<ul>
<li><strong>特点</strong>：内置，基于内存，无需任何外部依赖。</li>
<li><strong>优点</strong>：配置简单，启动快，非常适合开发、测试和单体小型应用。</li>
<li><strong>缺点</strong>：<ul>
<li>功能有限，不支持复杂的路由和持久化。</li>
<li><strong>无法横向扩展</strong>。如果是多实例部署，一个实例内存中的消息无法被另一个实例的客户端接收到。</li>
<li>服务重启后，所有订阅关系和未发送的消息都会丢失。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>外部代理 (External Broker)</strong>：<code>enableStompBrokerRelay()</code></p>
<ul>
<li><strong>特点</strong>：将消息代理的任务委托给一个专业的外部消息中间件（MQ），如 RabbitMQ, ActiveMQ。Spring 只是作为一个<strong>中继 (Relay)</strong>。</li>
<li><strong>优点</strong>：<ul>
<li><strong>天然支持集群和横向扩展</strong>。</li>
<li><strong>高可用和高可靠</strong>：MQ 通常支持消息持久化、ACK 确认机制等。</li>
<li><strong>功能强大</strong>：支持更复杂的路由拓扑、延迟队列等。</li>
<li><strong>异构系统集成</strong>：其他非 WebSocket 的服务也可以通过 MQ 与你的应用进行消息交互。</li>
</ul>
</li>
<li><strong>配置示例 (RabbitMQ)</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">registry.enableStompBrokerRelay(<span class="string">&quot;/topic&quot;</span>, <span class="string">&quot;/queue&quot;</span>)</span><br><span class="line">        .setRelayHost(<span class="string">&quot;localhost&quot;</span>)</span><br><span class="line">        .setRelayPort(<span class="number">61613</span>) <span class="comment">// STOMP 插件默认端口</span></span><br><span class="line">        .setClientLogin(<span class="string">&quot;guest&quot;</span>)</span><br><span class="line">        .setClientPasscode(<span class="string">&quot;guest&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-总结：一张完整的配置蓝图"><a href="#2-3-总结：一张完整的配置蓝图" class="headerlink" title="2.3 总结：一张完整的配置蓝图"></a>2.3 总结：一张完整的配置蓝图</h3><p>将以上部分组合起来，我们就得到了一个完整的 <code>WebSocketConfig</code> 类，它清晰地定义了整个 STOMP 消息系统的行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 STOMP 协议的端点。</span></span><br><span class="line"><span class="comment">     * 客户端将通过这个端点进行 WebSocket 握手。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义客户端连接的入口地址 &quot;/ws-stomp&quot;，并开启 SockJS 支持以便在浏览器不支持 WebSocket 时回退</span></span><br><span class="line">        registry.addEndpoint(<span class="string">&quot;/ws-stomp&quot;</span>).setAllowedOrigins(<span class="string">&quot;*&quot;</span>).withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置消息代理。</span></span><br><span class="line"><span class="comment">     * 定义了消息的路由规则。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义了服务器处理消息的前缀，发往这些前缀的消息将由 @MessageMapping 方法处理</span></span><br><span class="line">        registry.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义了消息代理的前缀，发往这些前缀的消息将由消息代理直接路由到订阅者</span></span><br><span class="line">        <span class="comment">// 使用内置的简单代理，处理 &quot;/topic&quot; 和 &quot;/queue&quot;</span></span><br><span class="line">        registry.enableSimpleBroker(<span class="string">&quot;/topic&quot;</span>, <span class="string">&quot;/queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这份配置，我们告诉 Spring：</p>
<ol>
<li><strong>入口</strong>：请在 <code>/ws-stomp</code> 这个 URL 上监听 WebSocket 连接请求，并做好兼容性处理 (SockJS)。</li>
<li><strong>分流</strong>：当收到客户端的 STOMP 消息时：<ul>
<li>如果目的地是 <code>/app/xxx</code>，请把它交给我的 Controller (<code>@MessageMapping</code>) 去处理。</li>
<li>如果目的地是 <code>/topic/yyy</code> 或 <code>/queue/zzz</code>，请直接把它广播给所有订阅了这些主题的客户端。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-消息收发与路由"><a href="#3-消息收发与路由" class="headerlink" title="3. 消息收发与路由"></a>3. 消息收发与路由</h2><p>在 <code>WebSocketConfig</code> 中配置好“蓝图”后，我们现在需要构建实际的“交通枢纽”和“目的地”。这主要通过在 Controller 中使用一系列注解来完成，其模式与 Spring MVC 的 <code>@RestController</code> 和 <code>@RequestMapping</code> 非常相似。</p>
<p>首先，创建一个用于处理 WebSocket 消息的 Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 @Controller 注解，而非 @RestController。</span></span><br><span class="line"><span class="comment">// 因为我们不是返回 JSON body，而是处理 STOMP 消息。</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketController</span> &#123;</span><br><span class="line">    <span class="comment">// ... 消息处理方法将在这里实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-1-消息接收：-MessageMapping"><a href="#3-1-消息接收：-MessageMapping" class="headerlink" title="3.1 消息接收：@MessageMapping"></a>3.1 消息接收：<code>@MessageMapping</code></h3><ul>
<li><p><strong>作用</strong>: 这是 STOMP 消息的<strong>主要入口</strong>。它将一个方法映射到一个消息目的地，类似于 <code>@RequestMapping</code> 映射一个 HTTP URL。</p>
</li>
<li><p><strong>工作原理</strong>:</p>
<ol>
<li>客户端使用 STOMP <code>SEND</code> 命令，将消息发送到一个以 <code>/app</code> (我们在配置中定义的应用前缀) 开头的目的地，例如 <code>/app/chat</code>。</li>
<li>Spring 的 STOMP 处理器接收到此消息，剥离 <code>/app</code> 前缀，得到 <code>/chat</code>。</li>
<li>它会在所有 <code>@Controller</code> 中寻找一个被 <code>@MessageMapping(&quot;/chat&quot;)</code> 注解的方法，并将消息的 payload 传递给该方法。</li>
<li>Spring 会自动将 JSON 格式的 payload 反序列化为方法的参数对象（POJO）。</li>
</ol>
</li>
<li><p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有 ChatMessage 类: &#123; &quot;from&quot;: &quot;userA&quot;, &quot;text&quot;: &quot;hello&quot; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理发往 &quot;/app/chat&quot; 的消息。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message 客户端发送的 JSON 数据会自动转为 ChatMessage 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 方法的返回值将作为新消息的 payload</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MessageMapping(&quot;/chat&quot;)</span> <span class="comment">// 映射目的地 /app/chat</span></span><br><span class="line"><span class="meta">@SendTo(&quot;/topic/public&quot;)</span> <span class="comment">// 将返回值广播到 /topic/public</span></span><br><span class="line"><span class="keyword">public</span> ChatMessage <span class="title function_">handleChatMessage</span><span class="params">(ChatMessage message)</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里可以进行消息处理，如过滤敏感词、存入数据库等</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Received message: &quot;</span> + message.getText());</span><br><span class="line">    <span class="comment">// 方法返回的对象将被序列化为 JSON 并发送出去</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChatMessage</span>(<span class="string">&quot;Server&quot;</span>, <span class="string">&quot;Processed: &quot;</span> + message.getText());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端交互</strong>: 客户端需要执行 <code>stompClient.send(&quot;/app/chat&quot;, {}, JSON.stringify({from: &#39;Alice&#39;, text: &#39;Hello World!&#39;}));</code></p>
</li>
</ul>
<hr>
<h3 id="3-2-消息发送-广播"><a href="#3-2-消息发送-广播" class="headerlink" title="3.2 消息发送&#x2F;广播"></a>3.2 消息发送&#x2F;广播</h3><h4 id="3-2-1-SendTo：广播到指定目的地"><a href="#3-2-1-SendTo：广播到指定目的地" class="headerlink" title="3.2.1 @SendTo：广播到指定目的地"></a>3.2.1 <code>@SendTo</code>：广播到指定目的地</h4><ul>
<li><p><strong>作用</strong>: 通常与 <code>@MessageMapping</code> 结合使用，用于声明方法返回值的<strong>目标地址</strong>。</p>
</li>
<li><p><strong>工作原理</strong>: 方法执行完毕后，返回值会被发送到 <code>@SendTo</code> 指定的 broker 目的地（如 <code>/topic/public</code>）。然后，消息代理 (Simple Broker) 会将此消息广播给所有订阅了 <code>/topic/public</code> 的客户端。</p>
</li>
<li><p><strong>动态目的地</strong>: <code>@SendTo</code> 的值可以包含占位符，这些占位符会从 <code>@MessageMapping</code> 的路径变量中解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端发送到 /app/chat/room123</span></span><br><span class="line"><span class="meta">@MessageMapping(&quot;/chat/&#123;roomId&#125;&quot;)</span></span><br><span class="line"><span class="comment">// 返回值会被广播到 /topic/messages/room123</span></span><br><span class="line"><span class="meta">@SendTo(&quot;/topic/messages/&#123;roomId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ChatMessage <span class="title function_">handleRoomChat</span><span class="params">(<span class="meta">@DestinationVariable</span> String roomId, ChatMessage message)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-2-2-SendToUser：向当前用户发送私信"><a href="#3-2-2-SendToUser：向当前用户发送私信" class="headerlink" title="3.2.2 @SendToUser：向当前用户发送私信"></a>3.2.2 <code>@SendToUser</code>：向当前用户发送私信</h4><ul>
<li><p><strong>作用</strong>: 将消息只发送给<strong>发起请求的那个用户</strong>。非常适合实现“请求-响应”模式或发送私有错误&#x2F;确认信息。</p>
</li>
<li><p><strong>工作原理</strong>:</p>
<ol>
<li>Spring 会将 <code>@SendToUser</code> 的目的地（如 <code>/queue/errors</code>）转换为一个对该用户唯一的目的地，通常是 <code>/user/{username}/queue/errors</code>。</li>
<li>要使其工作，客户端必须订阅这个<strong>用户特定的</strong>目的地。通常客户端库（如 <code>stomp.js</code>）会简化这个过程，你只需要订阅 <code>/user/queue/errors</code>，库会自动处理底层的会话 ID 映射。</li>
<li>需要结合 Spring Security 或其他认证机制来识别用户 (<code>Principal</code>)。</li>
</ol>
</li>
<li><p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理一个需要私密回复的请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> principal Spring Security 注入的当前用户信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MessageMapping(&quot;/private-request&quot;)</span></span><br><span class="line"><span class="meta">@SendToUser(&quot;/queue/replies&quot;)</span> <span class="comment">// 将返回值发送到 /user/&#123;username&#125;/queue/replies</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handlePrivateRequest</span><span class="params">(Principal principal)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (principal != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;This is a private reply for &quot;</span> + principal.getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Error: User not authenticated.&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端交互</strong>: 客户端需要 <code>stompClient.subscribe(&#39;/user/queue/replies&#39;, callback);</code> 才能收到消息。</p>
</li>
</ul>
<hr>
<h4 id="3-2-3-SimpMessagingTemplate：主动发送消息的“神器”"><a href="#3-2-3-SimpMessagingTemplate：主动发送消息的“神器”" class="headerlink" title="3.2.3 SimpMessagingTemplate：主动发送消息的“神器”"></a>3.2.3 <code>SimpMessagingTemplate</code>：主动发送消息的“神器”</h4><ul>
<li><p><strong>作用</strong>: 让你可以在<strong>任何地方</strong>（<code>@Service</code>, <code>@RestController</code>, 定时任务等），而不仅仅是在 <code>@MessageMapping</code> 方法中，主动向客户端发送消息。</p>
</li>
<li><p><strong>工作原理</strong>: 这是一个可以被 <code>@Autowired</code> 注入的 Bean。你只需调用它的方法，并指定目的地和 payload。</p>
</li>
<li><p><strong>核心方法</strong>:</p>
<ul>
<li><code>convertAndSend(destination, payload)</code>: 发送到一个公共目的地 (如 <code>/topic/notifications</code>)。</li>
<li><code>convertAndSendToUser(user, destination, payload)</code>: 发送给一个特定用户。<code>user</code> 参数是用户名（<code>Principal.getName()</code>）。</li>
</ul>
</li>
<li><p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpMessagingTemplate messagingTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NotificationService</span><span class="params">(SimpMessagingTemplate messagingTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messagingTemplate = messagingTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景1：由一个 HTTP 请求触发 WebSocket 广播</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyAllUsers</span><span class="params">(String notification)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Broadcasting notification: &quot;</span> + notification);</span><br><span class="line">        <span class="comment">// 向 /topic/notifications 广播消息</span></span><br><span class="line">        messagingTemplate.convertAndSend(<span class="string">&quot;/topic/notifications&quot;</span>, notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景2：发送私信给特定用户</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendPrivateNotification</span><span class="params">(String userId, String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending private message to &quot;</span> + userId);</span><br><span class="line">        <span class="comment">// 向 /user/&#123;userId&#125;/queue/private 发送消息</span></span><br><span class="line">        messagingTemplate.convertAndSendToUser(userId, <span class="string">&quot;/queue/private&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 场景3：定时任务，每5秒广播一次服务器时间</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 5000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">broadcastServerTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="string">&quot;Server time is: &quot;</span> + <span class="keyword">new</span> <span class="title class_">java</span>.util.Date();</span><br><span class="line">        messagingTemplate.convertAndSend(<span class="string">&quot;/topic/time&quot;</span>, time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-2-4-消息订阅：-SubscribeMapping-特殊用途"><a href="#3-2-4-消息订阅：-SubscribeMapping-特殊用途" class="headerlink" title="3.2.4 消息订阅：@SubscribeMapping (特殊用途)"></a>3.2.4 消息订阅：<code>@SubscribeMapping</code> (特殊用途)</h4><ul>
<li><p><strong>作用</strong>: 这个注解很容易被误解。它<strong>不是</strong>用来处理所有订阅的通用钩子。它的特定用途是：当一个客户端<strong>首次订阅</strong>某个目的地时，触发该方法，并<strong>立即</strong>将返回值作为一条消息<strong>只</strong>发送给这个订阅者。</p>
</li>
<li><p><strong>工作原理</strong>:</p>
<ol>
<li>客户端 <code>SUBSCRIBE</code> 一个以 <code>/app</code> 开头的目的地，例如 <code>/app/initial-users</code>。</li>
<li>Spring 找到 <code>@SubscribeMapping(&quot;/initial-users&quot;)</code> 方法，并执行它。</li>
<li>方法的返回值会直接发送给刚刚订阅的客户端，其行为类似于 <code>@SendToUser</code>。</li>
</ol>
</li>
<li><p><strong>典型场景</strong>: 当用户加入聊天室时，立即给他发送当前的在线用户列表。</p>
</li>
<li><p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当客户端订阅 &quot;/app/online-users&quot; 时，立即向其返回在线用户列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回值将只发送给发起订阅的客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SubscribeMapping(&quot;/online-users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getOnlineUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Client subscribed for online users, sending initial list.&quot;</span>);</span><br><span class="line">    <span class="comment">// 在实际应用中，这里应该从一个服务中获取真实的在线用户列表</span></span><br><span class="line">    <span class="keyword">return</span> List.of(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端交互</strong>: 客户端执行 <code>stompClient.subscribe(&#39;/app/online-users&#39;, callback);</code>，<code>callback</code> 会立即被调用一次，并收到 <code>[&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;]</code>。</p>
</li>
</ul>
<hr>
<h2 id="4-安全与拦截"><a href="#4-安全与拦截" class="headerlink" title="4. 安全与拦截"></a>4. 安全与拦截</h2><p>默认情况下，任何人都可以连接到你的 WebSocket 端点并订阅任何主题，这在生产环境中是极其危险的。我们需要一套机制来确保只有经过身份验证的用户才能连接，并且他们只能收发自己有权限的消息。</p>
<h3 id="4-1-ChannelInterceptor：消息管道的“守卫”"><a href="#4-1-ChannelInterceptor：消息管道的“守卫”" class="headerlink" title="4.1 ChannelInterceptor：消息管道的“守卫”"></a>4.1 <code>ChannelInterceptor</code>：消息管道的“守卫”</h3><p><code>ChannelInterceptor</code> 是 Spring Messaging 提供的一个强大拦截器接口，它允许你在消息被发送或接收的各个阶段插入自定义逻辑。它就像是消息流经的管道上的一个个阀门和检查点。</p>
<ul>
<li><strong>核心作用</strong>：<ul>
<li><strong>认证 (Authentication)</strong>：在连接建立后，从消息头中提取令牌（如 JWT），验证用户身份，并将其与 WebSocket <code>Session</code> 关联起来。</li>
<li><strong>授权 (Authorization)</strong>：在处理 <code>SUBSCRIBE</code> 或 <code>SEND</code> 命令时，检查用户是否有权订阅该目的地或向该目的地发送消息。</li>
<li><strong>日志记录</strong>：记录所有进出的消息，用于调试和审计。</li>
<li><strong>消息修改</strong>：在消息发送前修改其内容或头部信息。</li>
</ul>
</li>
<li><strong>关键方法</strong>：<ul>
<li><code>preSend(Message&lt;?&gt; message, MessageChannel channel)</code>: 在消息发送到 Channel <strong>之前</strong>被调用。这是最常用的方法，用于认证和授权。如果返回 <code>null</code>，则消息处理流程会中止。</li>
<li><code>postSend(Message&lt;?&gt; message, MessageChannel channel, boolean sent)</code>: 在消息发送<strong>之后</strong>被调用，无论成功与否。</li>
<li><code>afterSendCompletion(...)</code>: 在消息发送<strong>完成</strong>后（包括所有事务提交）被调用。</li>
</ul>
</li>
<li><strong>配置方式</strong>：<br><code>ChannelInterceptor</code> 需要注册到 <code>clientInboundChannel</code> (处理客户端发来消息的通道) 或 <code>clientOutboundChannel</code> (处理发往客户端消息的通道) 上。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 WebSocketConfig.java 中</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他配置</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureClientInboundChannel</span><span class="params">(ChannelRegistration registration)</span> &#123;</span><br><span class="line">        registration.interceptors(<span class="keyword">new</span> <span class="title class_">MyChannelInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>示例：使用拦截器进行 JWT 认证</strong></p>
<p>这是一个典型的认证场景：客户端在 STOMP 连接的 <code>CONNECT</code> 帧的 header 中携带 JWT。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtChannelInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ChannelInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) &#123;</span><br><span class="line">        <span class="type">StompHeaderAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 判断是否为 CONNECT 命令，如果是，则进行认证</span></span><br><span class="line">        <span class="keyword">if</span> (StompCommand.CONNECT.equals(accessor.getCommand())) &#123;</span><br><span class="line">            <span class="comment">// 2. 从 header 中获取 token</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">jwtToken</span> <span class="operator">=</span> accessor.getFirstNativeHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (jwtToken != <span class="literal">null</span> &amp;&amp; jwtToken.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">                jwtToken = jwtToken.substring(<span class="number">7</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 3. 使用 JWT 工具类或 Spring Security 进行 token 验证</span></span><br><span class="line">                <span class="comment">//    如果验证成功，会返回一个 Authentication 对象</span></span><br><span class="line">                <span class="type">Authentication</span> <span class="variable">userAuth</span> <span class="operator">=</span> JwtUtil.getAuthentication(jwtToken);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (userAuth != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 4. 将认证信息设置到 STOMP 的 session 中</span></span><br><span class="line">                    <span class="comment">//    这样在后续的 @MessageMapping 方法中，就可以通过 Principal 参数获取到用户信息</span></span><br><span class="line">                    accessor.setUser(userAuth);</span><br><span class="line">                    <span class="keyword">return</span> message;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 5. 如果认证失败，可以抛出异常，连接将被拒绝</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Authentication failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于非 CONNECT 命令，直接放行（后续可以结合 Spring Security 做更细粒度的授权）</span></span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端配合 (stomp.js)</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jwtToken = <span class="string">&#x27;your-jwt-token&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> headers = &#123;</span><br><span class="line">  <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">`Bearer <span class="subst">$&#123;jwtToken&#125;</span>`</span></span><br><span class="line">&#125;;</span><br><span class="line">stompClient.<span class="title function_">connect</span>(headers, onConnected, onError);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="4-2-结合-Spring-Security：实现声明式安全"><a href="#4-2-结合-Spring-Security：实现声明式安全" class="headerlink" title="4.2 结合 Spring Security：实现声明式安全"></a>4.2 结合 Spring Security：实现声明式安全</h3><p>虽然 <code>ChannelInterceptor</code> 功能强大，但对于复杂的授权规则（例如，只有 “ADMIN” 角色的用户才能订阅 <code>/topic/admin</code>），手动编写 <code>if-else</code> 逻辑会变得非常繁琐。Spring Security 提供了与 WebSocket 的深度集成，让我们能够以<strong>声明式</strong>的方式配置安全规则。</p>
<ul>
<li><p><strong>核心思想</strong>：将 WebSocket 的消息类型（CONNECT, SUBSCRIBE, MESSAGE, SEND）类比于 HTTP 的方法（GET, POST），将消息目的地（Destination）类比于 HTTP 的 URL。这样，我们就可以用与保护 Web 端点类似的方式来保护 WebSocket 消息。</p>
</li>
<li><p><strong>配置步骤</strong>：</p>
<ol>
<li><p><strong>添加依赖</strong>: 确保项目中包含 <code>spring-boot-starter-security</code> 和 <code>spring-security-messaging</code>。</p>
</li>
<li><p><strong>创建安全配置类</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.socket.AbstractSecurityWebSocketMessageBrokerConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.messaging.MessageSecurityMetadataSourceRegistry;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractSecurityWebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置消息的安全规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configureInbound</span><span class="params">(MessageSecurityMetadataSourceRegistry messages)</span> &#123;</span><br><span class="line">        messages</span><br><span class="line">            <span class="comment">// 1. 所有目的地以 /app/admin/ 开头的消息，需要 ADMIN 角色</span></span><br><span class="line">            .simpDestMatchers(<span class="string">&quot;/app/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">            <span class="comment">// 2. 所有目的地以 /user/ 开头的消息（通常是私信），要求用户已认证</span></span><br><span class="line">            .simpDestMatchers(<span class="string">&quot;/user/**&quot;</span>).authenticated()</span><br><span class="line">            <span class="comment">// 3. 订阅 /topic/private 主题，需要 &quot;SPECIAL_USER&quot; 权限</span></span><br><span class="line">            .simpSubscribeDestMatchers(<span class="string">&quot;/topic/private&quot;</span>).hasAuthority(<span class="string">&quot;SPECIAL_USER&quot;</span>)</span><br><span class="line">            <span class="comment">// 4. 对其他所有消息（如公共聊天室），允许所有访问</span></span><br><span class="line">            .anyMessage().permitAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 禁用 CSRF token 验证 for WebSocket</span></span><br><span class="line"><span class="comment">     * 在现代 JWT/Token-based 认证中，CSRF 保护通常是不必要的，</span></span><br><span class="line"><span class="comment">     * 因为客户端不会在 cookie 中自动发送凭证。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">sameOriginDisabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>关键点解释</strong>：</p>
<ul>
<li><code>AbstractSecurityWebSocketMessageBrokerConfigurer</code>: 这是配置 WebSocket 安全的专用基类。</li>
<li><code>configureInbound()</code>: 这是配置入口，用于定义对<strong>入站消息</strong>（来自客户端）的安全约束。</li>
<li><code>simpDestMatchers()</code>: 匹配消息的目的地（Destination）。适用于 <code>MESSAGE</code> 和 <code>SEND</code> 类型的消息。</li>
<li><code>simpSubscribeDestMatchers()</code>: 专门匹配 <code>SUBSCRIBE</code> 类型的消息。</li>
<li><code>simpTypeMatchers()</code>: 可以匹配消息的类型，如 <code>CONNECT</code>, <code>DISCONNECT</code>。例如，<code>.simpTypeMatchers(SimpMessageType.CONNECT).permitAll()</code> 允许所有连接。</li>
<li><code>.authenticated()</code>: 要求用户必须已登录。</li>
<li><code>.hasRole(&quot;ADMIN&quot;)</code> &#x2F; <code>.hasAuthority(&quot;WRITE&quot;)</code>: 要求用户拥有指定的角色或权限。</li>
<li><code>sameOriginDisabled()</code>: 返回 <code>true</code> 以禁用 Spring Security 的同源策略保护。对于非浏览器的 WebSocket 客户端或需要跨域的场景，这通常是必需的。</li>
</ul>
</li>
<li><p><strong>认证如何进行？</strong><br>Spring Security 的 WebSocket 集成<strong>重用了 Web 层的认证机制</strong>。这意味着：</p>
<ol>
<li>如果你的应用使用 Session + Cookie，当 WebSocket 握手时，HTTP 请求中携带的 Cookie 会被用来识别用户身份。</li>
<li>如果你的应用使用 JWT，你需要像前面 <code>ChannelInterceptor</code> 示例那样，在握手阶段或第一个 STOMP <code>CONNECT</code> 帧中验证 JWT，并将 <code>Authentication</code> 对象与会话关联。一旦关联成功，Spring Security 的授权规则就能自动生效。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h3><p>在实际项目中，<code>ChannelInterceptor</code> 和 Spring Security 通常结合使用：</p>
<ol>
<li><strong>使用 <code>ChannelInterceptor</code></strong>：<ul>
<li>在 STOMP <code>CONNECT</code> 阶段，从 header 中解析 Token (如 JWT)。</li>
<li>验证 Token 并构建 <code>Authentication</code> 对象。</li>
<li>通过 <code>StompHeaderAccessor.setUser()</code> 将 <code>Authentication</code> 对象关联到当前会话。</li>
</ul>
</li>
<li><strong>使用 <code>WebSocketSecurityConfig</code></strong>：<ul>
<li>利用 Spring Security 声明式的强大能力，轻松配置各种目的地的访问控制规则 (<code>hasRole</code>, <code>authenticated</code> 等)。</li>
<li>这些规则会自动作用于第一步中已认证的用户。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="5-客户端交互（简述）"><a href="#5-客户端交互（简述）" class="headerlink" title="5. 客户端交互（简述）"></a>5. 客户端交互（简述）</h2><p>后端搭建了强大的 STOMP 服务，但其价值最终需要通过客户端的交互来体现。对于 Web 前端，最流行和健壮的组合是使用 <code>SockJS</code> 作为底层传输，<code>stomp.js</code> (或其现代变体 <code>@stomp/stompjs</code>) 作为上层协议库。</p>
<ul>
<li><strong>SockJS</strong>: 一个浏览器 JavaScript 库，它提供了一个类似 WebSocket 的对象。其核心价值在于<strong>兼容性</strong>：如果浏览器不支持原生 WebSocket，它会自动降级 (fallback) 到其他可用的双向通信技术，如 HTTP Long Polling。这确保了你的应用在老旧浏览器或特殊网络环境下依然可以工作。</li>
<li><strong>stomp.js</strong>: 一个实现了 STOMP 协议的 JavaScript 客户端库。它负责将你的业务操作（如“订阅&#x2F;topic&#x2F;news”）封装成标准格式的 STOMP 帧，并通过底层的 WebSocket 或 SockJS 连接发送出去。</li>
</ul>
<p><strong>1. 引入库</strong></p>
<p>通常通过 CDN 或 npm&#x2F;yarn 包管理器引入。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过 CDN --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/@stomp/stompjs@7/bundles/stomp.umd.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 建立连接 (<code>CONNECT</code>)</strong></p>
<p>这是所有交互的起点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个 StompJs 客户端实例</span></span><br><span class="line"><span class="keyword">const</span> stompClient = <span class="keyword">new</span> <span class="title class_">StompJs</span>.<span class="title class_">Client</span>(&#123;</span><br><span class="line">    <span class="comment">// 2. 底层传输配置：使用 SockJS</span></span><br><span class="line">    <span class="comment">//    这里的 URL &#x27;/ws-stomp&#x27; 必须与后端 `registerStompEndpoints` 中配置的端点一致</span></span><br><span class="line">    <span class="attr">webSocketFactory</span>: <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">SockJS</span>(<span class="string">&#x27;http://localhost:8080/ws-stomp&#x27;</span>),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (可选) 连接成功时的回调函数</span></span><br><span class="line">    <span class="attr">onConnect</span>: <span class="function">(<span class="params">frame</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connected: &#x27;</span> + frame);</span><br><span class="line">        <span class="comment">// 连接成功后，通常在这里进行订阅</span></span><br><span class="line">        <span class="title function_">subscribeToTopics</span>(); </span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (可选) 连接失败时的回调函数</span></span><br><span class="line">    <span class="attr">onStompError</span>: <span class="function">(<span class="params">frame</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Broker reported error: &#x27;</span> + frame.<span class="property">headers</span>[<span class="string">&#x27;message&#x27;</span>]);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Additional details: &#x27;</span> + frame.<span class="property">body</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// (可选) 用于调试，打印所有 STOMP 帧</span></span><br><span class="line">    <span class="attr">debug</span>: <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), str);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (可选) 如果需要携带认证信息（如JWT），在 connectHeaders 中设置</span></span><br><span class="line">    <span class="attr">connectHeaders</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;Bearer your-jwt-token&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 激活连接</span></span><br><span class="line">stompClient.<span class="title function_">activate</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键点</strong>:<ul>
<li><code>webSocketFactory</code>: 指定了底层的传输方式。这里我们使用 SockJS，它会首先尝试 WebSocket，失败则降级。</li>
<li><code>onConnect</code>: 连接成功的回调至关重要，后续的订阅和发送操作都应该在连接成功后进行。</li>
<li><code>connectHeaders</code>: 这是向后端传递认证令牌（如 JWT）的标准方式，对应后端 <code>ChannelInterceptor</code> 中的 <code>accessor.getFirstNativeHeader(&quot;Authorization&quot;)</code>。</li>
</ul>
</li>
</ul>
<p><strong>3. 订阅目的地 (<code>SUBSCRIBE</code>)</strong></p>
<p>订阅一个“频道”，以便接收来自该频道的广播消息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">subscribeToTopics</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 订阅公共聊天室主题</span></span><br><span class="line">    stompClient.<span class="title function_">subscribe</span>(<span class="string">&#x27;/topic/public&#x27;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 当收到消息时，此回调函数被触发</span></span><br><span class="line">        <span class="comment">// message.body 通常是一个 JSON 字符串</span></span><br><span class="line">        <span class="keyword">const</span> chatMessage = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(message.<span class="property">body</span>);</span><br><span class="line">        <span class="title function_">showGreeting</span>(chatMessage.<span class="property">from</span> + <span class="string">&quot;: &quot;</span> + chatMessage.<span class="property">text</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅一个用户私有队列，用于接收私信或个人通知</span></span><br><span class="line">    <span class="comment">// stomp.js 会自动处理 /user 前缀</span></span><br><span class="line">    stompClient.<span class="title function_">subscribe</span>(<span class="string">&#x27;/user/queue/replies&#x27;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received private message: &#x27;</span>, message.<span class="property">body</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键点</strong>:<ul>
<li><code>stompClient.subscribe(destination, callback)</code>: 第一个参数是 STOMP 目的地，与后端 <code>@SendTo</code> 或 <code>SimpMessagingTemplate</code> 的目标地址对应。第二个参数是收到消息后的处理函数。</li>
<li>订阅 <code>/user/...</code> 格式的目的地时，库会自动将其映射到与当前用户会话相关的唯一地址。</li>
</ul>
</li>
</ul>
<p><strong>4. 发送消息 (<code>SEND</code>)</strong></p>
<p>向一个目的地发送消息，通常由用户操作触发（如点击“发送”按钮）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sendMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">from</span> = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;from&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">const</span> text = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;text&#x27;</span>).<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">from</span> &amp;&amp; text) &#123;</span><br><span class="line">        <span class="comment">// 使用 publish 方法 (等同于 send)</span></span><br><span class="line">        stompClient.<span class="title function_">publish</span>(&#123;</span><br><span class="line">            <span class="comment">// 目的地，与后端 @MessageMapping(&quot;/chat&quot;) 对应</span></span><br><span class="line">            <span class="attr">destination</span>: <span class="string">&#x27;/app/chat&#x27;</span>,</span><br><span class="line">            <span class="comment">// 消息体，通常是 JSON 字符串</span></span><br><span class="line">            <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="string">&#x27;from&#x27;</span>: <span class="keyword">from</span>, <span class="string">&#x27;text&#x27;</span>: text&#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键点</strong>:<ul>
<li><code>stompClient.publish({destination, body, headers})</code>:<ul>
<li><code>destination</code>: 目标地址。如果需要后端 <code>@MessageMapping</code> 方法处理，通常以 <code>/app</code> 开头。</li>
<li><code>body</code>: 消息的 payload，需要手动序列化成字符串（如 JSON.stringify）。</li>
<li><code>headers</code>: (可选) 可以添加自定义的 STOMP 消息头。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>5. 断开连接 (<code>DISCONNECT</code>)</strong></p>
<p>在页面卸载或用户登出时，应主动断开连接以释放服务器资源。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">disconnect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    stompClient.<span class="title function_">deactivate</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Disconnected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如，在浏览器窗口关闭前断开连接</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">disconnect</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键点</strong>:<ul>
<li><code>stompClient.deactivate()</code>: 会向服务器发送一个 <code>DISCONNECT</code> 帧，优雅地关闭连接。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="六、生产环境最佳实践与高级主题"><a href="#六、生产环境最佳实践与高级主题" class="headerlink" title="六、生产环境最佳实践与高级主题"></a>六、生产环境最佳实践与高级主题</h1><h2 id="1-连接的稳定性：心跳机制"><a href="#1-连接的稳定性：心跳机制" class="headerlink" title="1. 连接的稳定性：心跳机制"></a>1. 连接的稳定性：心跳机制</h2><p>心跳机制是维持 WebSocket 长连接稳定性的核心手段。它通过在客户端和服务器之间定期发送“心跳”消息，来解决两个核心问题：<strong>防止意外断开</strong> 和 <strong>检测僵尸连接</strong>。</p>
<h3 id="1-1-为什么需要心跳？"><a href="#1-1-为什么需要心跳？" class="headerlink" title="1.1 为什么需要心跳？"></a>1.1 为什么需要心跳？</h3><p>在一个理想的网络环境中，TCP 连接一旦建立，只要双方不主动关闭，就会一直保持。但在现实世界中，情况要复杂得多：</p>
<ul>
<li><strong>防止代理&#x2F;防火墙超时 (Preventing Proxy Timeouts):</strong><ul>
<li><strong>问题描述:</strong> 生产环境中，客户端和服务器之间通常会经过多个网络中间件，如负载均衡器（Nginx、F5）、防火墙、NAT 网关等。这些设备为了节省自身资源，通常会设置一个“空闲连接超时”（Idle Timeout）。如果一个 TCP 连接在指定时间（例如 60 秒）内没有任何数据传输，中间件会单方面认为该连接已失效并将其关闭，而此时客户端和服务器可能对此毫不知情。</li>
<li><strong>解决方案:</strong> 心跳机制通过定期发送一个极小的数据包（心跳包），模拟“通信正在进行”的状态，从而重置所有中间件的空闲计时器，确保连接不会因为“空闲”而被意外切断。这就像是告诉沿途的所有设备：“我还活着，别挂断我！”</li>
</ul>
</li>
<li><strong>检测僵尸连接 (Detecting Zombie Connections):</strong><ul>
<li><strong>问题描述:</strong> 当一方发生异常掉线时（如客户端应用崩溃、用户关闭浏览器页签、手机网络突然切换、服务器宕机重启），TCP 连接可能不会被优雅地关闭（即没有发送 <code>FIN</code> 包）。另一方会一直维持着这个“已死亡”的连接，持续占用服务器的内存、文件句柄等宝贵资源。这种无法通信但仍占用资源的连接被称为“僵尸连接”。大量的僵尸连接会耗尽服务器资源，导致无法接受新的连接。</li>
<li><strong>解决方案:</strong> 心跳机制提供了一种主动检测连接状态的手段。<ul>
<li><strong>单向检测:</strong> 服务器定期向客户端发送心跳请求（如 Ping）。如果在一定时间内没有收到客户端的响应（如 Pong），服务器就可以判定客户端已失联，从而主动关闭这个僵尸连接，释放资源。</li>
<li><strong>双向检测:</strong> 同样，客户端也可以向服务器发送心跳，以检测服务器是否在线，从而实现更及时的断线重连逻辑。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong> 心跳的核心作用有两个：</p>
<ol>
<li><strong>主动保活 (Keep-Alive):</strong> 告知网络中间件连接是活动的。</li>
<li><strong>被动检测 (Health-Check):</strong> 确认对方是否仍然在线。</li>
</ol>
<hr>
<h3 id="1-2-Spring-STOMP-的内置心跳配置"><a href="#1-2-Spring-STOMP-的内置心跳配置" class="headerlink" title="1.2 Spring STOMP 的内置心跳配置"></a>1.2 Spring STOMP 的内置心跳配置</h3><p>Spring 对 STOMP over WebSocket 提供了非常完善且易于配置的内置心跳支持。配置是<strong>双向</strong>的，即服务器和客户端需要进行协商。</p>
<ul>
<li><p><strong>服务端配置 (<code>WebSocketMessageBrokerConfigurer</code>):</strong></p>
<p>心跳在 <code>configureMessageBroker</code> 方法中通过 <code>TaskScheduler</code> 来启用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.messaging.simp.config.MessageBrokerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 其他配置</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">ThreadPoolTaskScheduler</span> <span class="variable">taskScheduler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskScheduler</span>();</span><br><span class="line">        taskScheduler.setPoolSize(<span class="number">1</span>);</span><br><span class="line">        taskScheduler.setThreadNamePrefix(<span class="string">&quot;websocket-heartbeat-&quot;</span>);</span><br><span class="line">        taskScheduler.initialize();</span><br><span class="line"></span><br><span class="line">        registry.enableSimpleBroker(<span class="string">&quot;/topic&quot;</span>, <span class="string">&quot;/queue&quot;</span>)</span><br><span class="line">                .setHeartbeatValue(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;</span><br><span class="line">                    <span class="number">10000</span>, <span class="comment">// server -&gt; client: 服务器每 10 秒向客户端发送一次心跳</span></span><br><span class="line">                    <span class="number">10000</span>  <span class="comment">// client -&gt; server: 服务器期望每 10 秒从客户端接收一次心跳</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .setTaskScheduler(taskScheduler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>setHeartbeatValue(new long[]{ outgoing, incoming })</code>:<ul>
<li><code>outgoing</code> (10000 ms): 服务器保证至少每 10 秒向客户端发送一次心跳。如果在此期间有其他消息发送，则心跳可以省略。<code>0</code> 表示服务器不主动发送心跳。</li>
<li><code>incoming</code> (10000 ms): 服务器期望至少每 10 秒从客户端那里收到一次心跳。如果超过这个时间（通常会有一个宽限期）没有收到任何消息（包括心跳），服务器将判定客户端断开并关闭连接。<code>0</code> 表示服务器不要求客户端发送心跳。</li>
</ul>
</li>
<li><code>setTaskScheduler</code>: 为心跳任务提供一个专用的线程池，避免与业务线程混用，是推荐的最佳实践。</li>
</ul>
</li>
<li><p><strong>客户端配置 (以 <code>stompjs</code> 为例):</strong></p>
<p>客户端在连接时也需要声明自己的心跳期望。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Client</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@stomp/stompjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">Client</span>(&#123;</span><br><span class="line">    <span class="attr">brokerURL</span>: <span class="string">&#x27;ws://localhost:8080/your-websocket-endpoint&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 心跳配置</span></span><br><span class="line">    <span class="attr">heartbeatIncoming</span>: <span class="number">10000</span>, <span class="comment">// 期望从服务器每 10 秒接收一次心跳</span></span><br><span class="line">    <span class="attr">heartbeatOutgoing</span>: <span class="number">10000</span>, <span class="comment">// 保证每 10 秒向服务器发送一次心跳</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">reconnectDelay</span>: <span class="number">5000</span>, <span class="comment">// 断线后 5 秒尝试重连</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他配置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.<span class="property">onConnect</span> = <span class="keyword">function</span>(<span class="params">frame</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connected: &#x27;</span> + frame);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">client.<span class="property">onStompError</span> = <span class="keyword">function</span>(<span class="params">frame</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Broker reported error: &#x27;</span> + frame.<span class="property">headers</span>[<span class="string">&#x27;message&#x27;</span>]);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Additional details: &#x27;</span> + frame.<span class="property">body</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">client.<span class="title function_">activate</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>心跳协商机制:</strong><br>最终的心跳间隔是<strong>客户端与服务器配置的较大值</strong>。例如：</p>
<ul>
<li>Server 配置 <code>[10000, 10000]</code>，Client 配置 <code>[5000, 5000]</code>。</li>
<li>最终结果：<ul>
<li>Server -&gt; Client：<code>max(10000, 5000) = 10000</code> ms。服务器每 10 秒发一次。</li>
<li>Client -&gt; Server：<code>max(10000, 5000) = 10000</code> ms。客户端每 10 秒发一次。<br>这种设计避免了一方过于频繁地发送心跳给另一方造成压力。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-原生-WebSocket-的手动实现-Ping-Pong"><a href="#1-3-原生-WebSocket-的手动实现-Ping-Pong" class="headerlink" title="1.3 原生 WebSocket 的手动实现 (Ping&#x2F;Pong)"></a>1.3 原生 WebSocket 的手动实现 (Ping&#x2F;Pong)</h3><p>如果你使用原生 WebSocket API（JSR 356 或 Spring 的 <code>WebSocketHandler</code>），则需要手动实现心跳逻辑。WebSocket 协议本身定义了 <code>Ping</code> 和 <code>Pong</code> 两种<strong>控制帧 (Control Frame)</strong>，它们是实现心跳的理想选择。</p>
<ul>
<li><p><strong>协议特性:</strong></p>
<ul>
<li><code>Ping</code> 帧: 由一方发送，用于检测连接或作为保活信号。可以携带少量数据。</li>
<li><code>Pong</code> 帧: 当收到 <code>Ping</code> 帧时，另一方<strong>必须</strong>自动回复一个 <code>Pong</code> 帧。这个响应是 WebSocket 协议栈底层自动完成的，你通常不需要手动编码发送 <code>Pong</code> 来回应 <code>Ping</code>。</li>
</ul>
</li>
<li><p><strong>服务端实现思路:</strong></p>
<ol>
<li><strong>定时发送 Ping:</strong> 创建一个定时任务（如 <code>@Scheduled</code>），遍历所有已连接的 <code>WebSocketSession</code>。</li>
<li><strong>检测 Pong 响应:</strong> 虽然 <code>Pong</code> 是自动回复的，但我们可以监听 <code>PongMessage</code> 事件来确认客户端是否还活着。</li>
<li><strong>关闭僵尸连接:</strong> 记录每个会话的“最后活跃时间”（收到任何消息或 Pong 时更新）。另一个定时任务检查这个时间，如果长时间未更新，则认为连接已死，并主动关闭。</li>
</ol>
</li>
<li><p><strong>示例代码 (基于 Spring 原生 WebSocketHandler):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHeartbeatHandler</span> <span class="keyword">extends</span> <span class="title class_">TextWebSocketHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ConcurrentHashMap 存储 session 和最后活跃时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;WebSocketSession, Long&gt; sessionActivityMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">HEARTBEAT_INTERVAL</span> <span class="operator">=</span> <span class="number">15_000</span>; <span class="comment">// 15 秒发送一次 ping</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SESSION_TIMEOUT</span> <span class="operator">=</span> <span class="number">45_000</span>;    <span class="comment">// 45 秒未收到任何消息则超时</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        sessionActivityMap.put(session, System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;New connection: &quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 收到任何文本消息，都更新活跃时间</span></span><br><span class="line">        sessionActivityMap.put(session, System.currentTimeMillis());</span><br><span class="line">        <span class="comment">// ... 处理业务消息</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handlePongMessage</span><span class="params">(WebSocketSession session, PongMessage message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 收到 Pong 消息，是心跳响应，更新活跃时间</span></span><br><span class="line">        sessionActivityMap.put(session, System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;Pong received from: &quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus status)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        sessionActivityMap.remove(session);</span><br><span class="line">        System.out.println(<span class="string">&quot;Connection closed: &quot;</span> + session.getId() + <span class="string">&quot; with status: &quot;</span> + status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时任务：发送 Ping</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = HEARTBEAT_INTERVAL)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendPingToClients</span><span class="params">()</span> &#123;</span><br><span class="line">        sessionActivityMap.keySet().forEach(session -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Ping 消息可以携带一个 payload，客户端的 Pong 响应会原样返回</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">payload</span> <span class="operator">=</span> ByteBuffer.wrap(String.valueOf(System.currentTimeMillis()).getBytes());</span><br><span class="line">                    session.sendMessage(<span class="keyword">new</span> <span class="title class_">PingMessage</span>(payload));</span><br><span class="line">                    System.out.println(<span class="string">&quot;Ping sent to: &quot;</span> + session.getId());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;Error sending ping to &quot;</span> + session.getId() + <span class="string">&quot;: &quot;</span> + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时任务：检查僵尸连接</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = SESSION_TIMEOUT)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkZombieConnections</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        sessionActivityMap.forEach((session, lastActivity) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> ((now - lastActivity) &gt; SESSION_TIMEOUT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Closing zombie connection: &quot;</span> + session.getId());</span><br><span class="line">                        session.close(CloseStatus.SESSION_NOT_RELIABLE);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                         System.err.println(<span class="string">&quot;Error closing zombie session &quot;</span> + session.getId() + <span class="string">&quot;: &quot;</span> + e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sessionActivityMap.remove(session);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端实现思路:</strong></p>
<ul>
<li><p><strong>响应 Ping:</strong> 现代浏览器 WebSocket API 会自动处理收到的 <code>Ping</code> 帧并回复 <code>Pong</code>。你<strong>不需要</strong>也<strong>无法</strong>通过 JavaScript 监听 <code>ping</code> 事件或手动发送 <code>pong</code>。</p>
</li>
<li><p><strong>主动发送心跳:</strong> 如果需要客户端主动检测服务端状态，由于浏览器 API 没有提供 <code>sendPing()</code> 方法，通常的做法是发送一个<strong>应用层心跳</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/my-heartbeat-handler&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> heartbeatInterval;</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connection opened.&#x27;</span>);</span><br><span class="line">    <span class="comment">// 每 20 秒发送一个应用层心跳包</span></span><br><span class="line">    heartbeatInterval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ws.<span class="property">readyState</span> === <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>) &#123;</span><br><span class="line">            ws.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;heartbeat&#x27;</span>, <span class="attr">timestamp</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>() &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">20000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connection closed.&#x27;</span>);</span><br><span class="line">    <span class="built_in">clearInterval</span>(heartbeatInterval); <span class="comment">// 清除定时器</span></span><br><span class="line">    <span class="comment">// 这里可以加入断线重连逻辑</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 收到服务器消息，可以认为连接是健康的</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message from server &#x27;</span>, event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>服务端对应的 <code>handleTextMessage</code> 需要能识别并忽略这种应用层心跳消息，但仍然用它来更新 <code>sessionActivityMap</code> 中的活跃时间。</p>
</li>
</ul>
<hr>
<h2 id="2-健壮性：断线重连与异常处理"><a href="#2-健壮性：断线重连与异常处理" class="headerlink" title="2. 健壮性：断线重连与异常处理"></a>2. 健壮性：断线重连与异常处理</h2><p>网络是不可靠的，用户操作是不可预测的。一个健壮的 WebSocket 应用必须能够优雅地处理各种异常情况，并在连接中断时尝试恢复，以提供无缝的用户体验。</p>
<h3 id="2-1-客户端重连策略-指数退避"><a href="#2-1-客户端重连策略-指数退避" class="headerlink" title="2.1 客户端重连策略 (指数退避)"></a>2.1 客户端重连策略 (指数退避)</h3><p>当 WebSocket 连接意外断开时（例如网络波动、服务器重启），客户端不应该立即、持续地尝试重连。这种行为会带来两个严重问题：</p>
<ol>
<li><strong>服务器风暴 (Thundering Herd):</strong> 如果服务器短暂离线后重启，成千上万的客户端同时发起重连请求，会瞬间耗尽服务器的连接资源，导致“雪崩效应”，使服务器再次宕机。</li>
<li><strong>客户端资源消耗:</strong> 在服务器长时间不可用或网络完全断开的情况下，持续的重连尝试会耗尽客户端（尤其是移动设备）的电量和网络流量。</li>
</ol>
<p><strong>指数退避 (Exponential Backoff)</strong> 是一种被广泛采用的、优雅的重连算法。</p>
<ul>
<li><p><strong>核心思想:</strong> 每次重连失败后，将下一次重连的等待时间加倍，并设置一个最大等待时间上限，同时引入随机性（Jitter）来打乱重连时机。</p>
</li>
<li><p><strong>算法步骤:</strong></p>
<ol>
<li>从一个较短的基础延迟开始（如 1 秒）。</li>
<li>尝试连接。如果失败，将延迟时间乘以一个因子（通常是 2）。</li>
<li>增加一个随机的“抖动”时间（Jitter），以防止客户端在同一时刻同步重连。</li>
<li>等待计算出的延迟时间后，返回步骤 2。</li>
<li>设置一个最大延迟时间（如 60 秒），防止等待时间无限增长。</li>
<li>一旦连接成功，重置所有计数器和延迟时间，以便下次断开时从头开始。</li>
</ol>
</li>
<li><p><strong>使用 <code>stompjs</code> 库实现:</strong><br><code>@stomp/stompjs</code> 库内置了非常完善的重连机制，我们只需要通过配置启用它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Client</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@stomp/stompjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">Client</span>(&#123;</span><br><span class="line">    <span class="attr">brokerURL</span>: <span class="string">&#x27;ws://localhost:8080/your-websocket-endpoint&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心配置：自动重连</span></span><br><span class="line">    <span class="comment">// stompjs 内部已经实现了带抖动的指数退避算法</span></span><br><span class="line">    <span class="attr">reconnectDelay</span>: <span class="number">5000</span>, <span class="comment">// 初始重连延迟为 5 秒。之后会指数增长。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以手动实现更复杂的逻辑</span></span><br><span class="line">    <span class="comment">// beforeConnect: () =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(&#x27;Trying to connect...&#x27;);</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他配置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.<span class="property">onWebSocketClose</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket closed. Will attempt to reconnect.&#x27;</span>, event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">client.<span class="title function_">activate</span>();</span><br></pre></td></tr></table></figure>

<p><code>reconnectDelay</code> 设置了初始延迟，后续的重连会自动遵循指数退避策略。这是最推荐的方式。</p>
</li>
<li><p><strong>原生 WebSocket 手动实现:</strong><br>如果你使用原生 <code>WebSocket</code> API，需要自己实现这个逻辑。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">connect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> reconnectAttempts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> baseDelay = <span class="number">1000</span>; <span class="comment">// 基础延迟 1 秒</span></span><br><span class="line">    <span class="keyword">const</span> maxDelay = <span class="number">30000</span>; <span class="comment">// 最大延迟 30 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">attemptConnection</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080/your-endpoint&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        ws.<span class="property">onopen</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket connection established.&#x27;</span>);</span><br><span class="line">            <span class="comment">// 连接成功，重置尝试次数</span></span><br><span class="line">            reconnectAttempts = <span class="number">0</span>; </span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ws.<span class="property">onclose</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket connection closed.&#x27;</span>, event.<span class="property">code</span>, event.<span class="property">reason</span>);</span><br><span class="line">            reconnectAttempts++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算下一次重连的延迟（指数退避 + 随机抖动）</span></span><br><span class="line">            <span class="keyword">const</span> delay = <span class="title class_">Math</span>.<span class="title function_">min</span>(maxDelay, baseDelay * <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, reconnectAttempts));</span><br><span class="line">            <span class="keyword">const</span> jitter = delay * <span class="number">0.2</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>(); <span class="comment">// 增加最多 20% 的抖动</span></span><br><span class="line">            <span class="keyword">const</span> reconnectTimeout = delay + jitter;</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Will attempt to reconnect in <span class="subst">$&#123;<span class="built_in">Math</span>.round(reconnectTimeout / <span class="number">1000</span>)&#125;</span> seconds.`</span>);</span><br><span class="line">            <span class="built_in">setTimeout</span>(attemptConnection, reconnectTimeout);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ws.<span class="property">onerror</span> = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;WebSocket error:&#x27;</span>, error);</span><br><span class="line">            <span class="comment">// onerror 事件之后通常会立即触发 onclose 事件，所以重连逻辑放在 onclose 中处理</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">attemptConnection</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">connect</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-2-服务端优雅处理连接断开事件"><a href="#2-2-服务端优雅处理连接断开事件" class="headerlink" title="2.2 服务端优雅处理连接断开事件"></a>2.2 服务端优雅处理连接断开事件</h3><p>当一个客户端连接断开时，无论是正常关闭还是异常掉线，服务端都必须能够捕获这个事件并执行相应的清理工作。这被称为“优雅处理”。</p>
<ul>
<li><p><strong>核心任务:</strong></p>
<ol>
<li><strong>释放资源:</strong> 从内存中移除与该会话相关的数据结构（如 Session 对象、用户状态 Map 等），避免内存泄漏。</li>
<li><strong>更新业务状态:</strong> 例如，在聊天室中将用户状态更新为“离线”，在协作文档中释放文档锁。</li>
<li><strong>通知其他用户:</strong> 如果需要，向其他相关的客户端广播该用户离线的消息。</li>
</ol>
</li>
<li><p><strong>Spring STOMP 实现 (<code>SessionDisconnectEvent</code>):</strong><br>Spring 提供了一个非常方便的事件监听机制来处理断连。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketDisconnectListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;SessionDisconnectEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设有一个服务来管理在线用户</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OnlineUserService onlineUserService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SimpMessagingTemplate messagingTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(SessionDisconnectEvent event)</span> &#123;</span><br><span class="line">        <span class="type">SimpMessageHeaderAccessor</span> <span class="variable">headerAccessor</span> <span class="operator">=</span> SimpMessageHeaderAccessor.wrap(event.getMessage());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从会话属性中获取用户信息（在握手拦截器中存入）</span></span><br><span class="line">        <span class="type">Principal</span> <span class="variable">user</span> <span class="operator">=</span> headerAccessor.getUser();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sessionId</span> <span class="operator">=</span> headerAccessor.getSessionId();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> user.getName();</span><br><span class="line">            System.out.println(<span class="string">&quot;User disconnected: &quot;</span> + username + <span class="string">&quot; (Session ID: &quot;</span> + sessionId + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 更新业务状态：移除在线用户</span></span><br><span class="line">            onlineUserService.removeUser(username);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 通知其他用户：广播更新后的在线用户列表</span></span><br><span class="line">            <span class="comment">// 假设有一个 &quot;/topic/online-users&quot; 主题</span></span><br><span class="line">            messagingTemplate.convertAndSend(<span class="string">&quot;/topic/online-users&quot;</span>, onlineUserService.getOnlineUsers());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;Anonymous session disconnected: &quot;</span> + sessionId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 释放其他资源（如果需要）</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点:</strong> 在握手阶段（<code>HandshakeInterceptor</code>）将用户信息（如 <code>Principal</code> 或自定义 User 对象）存入 <code>session.getAttributes()</code>，这样在断开连接时才能识别是哪个用户离线了。</p>
</li>
</ul>
<hr>
<h3 id="2-3-使用-MessageExceptionHandler-统一处理-STOMP-异常"><a href="#2-3-使用-MessageExceptionHandler-统一处理-STOMP-异常" class="headerlink" title="2.3 使用 @MessageExceptionHandler 统一处理 STOMP 异常"></a>2.3 使用 <code>@MessageExceptionHandler</code> 统一处理 STOMP 异常</h3><p>在处理 STOMP 消息（即 <code>@MessageMapping</code> 方法）的过程中，可能会抛出各种异常（如业务校验失败、数据库访问错误等）。如果不加处理，异常会导致连接被关闭。更好的方式是捕获这些异常，并向触发异常的客户端发送一条错误消息。</p>
<p><code>@MessageExceptionHandler</code> 类似于 Spring MVC 中的 <code>@ExceptionHandler</code>，但专用于 WebSocket 消息处理。</p>
<ul>
<li><p><strong>核心优势:</strong></p>
<ul>
<li><strong>集中处理:</strong> 将异常处理逻辑从业务代码中分离出来，保持 <code>@MessageMapping</code> 方法的整洁。</li>
<li><strong>定向发送:</strong> 可以方便地将错误消息只发送给引发异常的用户，而不是广播给所有人。</li>
</ul>
</li>
<li><p><strong>实现步骤:</strong></p>
<ol>
<li>创建一个带有 <code>@ControllerAdvice</code> 注解的类，使其成为一个全局的异常处理器。</li>
<li>在类中定义方法，并使用 <code>@MessageExceptionHandler</code> 注解。该注解可以指定要处理的异常类型。</li>
<li>使用 <code>@SendToUser</code> 注解，将方法的返回值发送到该用户的特定队列（默认为 <code>/user/queue/errors</code>）。</li>
</ol>
</li>
<li><p><strong>示例代码:</strong></p>
<p><strong>1. 可能抛出异常的 Controller:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MessageMapping(&quot;/chat.sendMessage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@Payload</span> ChatMessage chatMessage, Principal user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (chatMessage.getContent() == <span class="literal">null</span> || chatMessage.getContent().trim().isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 抛出业务异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message content cannot be empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (chatMessage.getContent().contains(<span class="string">&quot;spam&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SpamMessageException</span>(<span class="string">&quot;Your message was detected as spam.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... 正常处理消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpamMessageException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SpamMessageException</span><span class="params">(String message)</span> &#123; <span class="built_in">super</span>(message); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 全局异常处理器:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个简单的错误响应体</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ErrorResponse</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> String error;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ErrorResponse</span><span class="params">(String error)</span> &#123; <span class="built_in">this</span>.error = error; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理特定类型的业务异常</span></span><br><span class="line">    <span class="meta">@MessageExceptionHandler(SpamMessageException.class)</span></span><br><span class="line">    <span class="meta">@SendToUser(&quot;/queue/errors&quot;)</span> <span class="comment">// 将错误消息发送到 /user/queue/errors</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleSpamMessage</span><span class="params">(SpamMessageException ex)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Caught a spam message: &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(<span class="string">&quot;Spam detected! Message rejected.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理通用的校验异常</span></span><br><span class="line">    <span class="meta">@MessageExceptionHandler(IllegalArgumentException.class)</span></span><br><span class="line">    <span class="meta">@SendToUser(&quot;/queue/errors&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleIllegalArgument</span><span class="params">(IllegalArgumentException ex)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Invalid argument: &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理所有其他未捕获的异常</span></span><br><span class="line">    <span class="meta">@MessageExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@SendToUser(&quot;/queue/errors&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleGenericException</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;An unexpected error occurred: &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="comment">// 注意：生产环境不应将原始异常信息直接暴露给客户端</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(<span class="string">&quot;An internal server error occurred. Please try again later.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 客户端订阅错误队列:</strong><br>客户端需要订阅这个私有的错误队列来接收错误通知。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 stompjs</span></span><br><span class="line">client.<span class="property">onConnect</span> = <span class="function">(<span class="params">frame</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connected: &#x27;</span> + frame);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 订阅业务主题</span></span><br><span class="line">    client.<span class="title function_">subscribe</span>(<span class="string">&#x27;/topic/public&#x27;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123; <span class="comment">/* ... */</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅个人错误队列</span></span><br><span class="line">    client.<span class="title function_">subscribe</span>(<span class="string">&#x27;/user/queue/errors&#x27;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> error = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(message.<span class="property">body</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Received an error from server:&#x27;</span>, error.<span class="property">error</span>);</span><br><span class="line">        <span class="comment">// 在 UI 上显示错误提示</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;Error: &#x27;</span> + error.<span class="property">error</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="3-横向扩展：多实例部署"><a href="#3-横向扩展：多实例部署" class="headerlink" title="3. 横向扩展：多实例部署"></a>3. 横向扩展：多实例部署</h2><p>当单个应用实例无法满足高并发或高可用性需求时，就需要进行横向扩展（Horizontal Scaling），即部署多个应用实例并使用负载均衡器分发流量。然而，由于 WebSocket 的<strong>有状态性</strong>，这带来了独特的挑战。</p>
<h3 id="3-1-原生-WebSocket-Spring-原生-WebSocket-的挑战：Sticky-Session"><a href="#3-1-原生-WebSocket-Spring-原生-WebSocket-的挑战：Sticky-Session" class="headerlink" title="3.1 原生 WebSocket&#x2F;Spring 原生 WebSocket 的挑战：Sticky Session"></a><strong>3.1 原生 WebSocket&#x2F;Spring 原生 WebSocket 的挑战：Sticky Session</strong></h3><ul>
<li><p><strong>问题根源：有状态的连接</strong></p>
<ul>
<li>当一个客户端通过 WebSocket 连接到你的服务时，这个 TCP 连接是与<strong>某一个特定</strong>的应用实例（例如 Server A）建立的。</li>
<li>该实例的内存中维护着这个连接的 <code>WebSocketSession</code> 对象以及所有相关状态。</li>
<li>负载均衡器（如 Nginx）默认情况下会使用轮询（Round-Robin）等策略，将请求随机分发到后端的不同服务器上。</li>
</ul>
</li>
<li><p><strong>场景分析：为什么会失败？</strong></p>
<ol>
<li><strong>Client A</strong> 的 WebSocket 连接被负载均衡器分配到了 <strong>Server A</strong>。</li>
<li><strong>Client B</strong> 的 WebSocket 连接被分配到了 <strong>Server B</strong>。</li>
<li>现在，<strong>Client B</strong> 想给 <strong>Client A</strong> 发送一条消息。它将消息通过自己的 WebSocket 连接发送给 <strong>Server B</strong>。</li>
<li><strong>Server B</strong> 接收到消息，但它在其内存中找不到 <strong>Client A</strong> 的 <code>WebSocketSession</code>。这个 Session 存在于 <strong>Server A</strong> 的内存中。</li>
<li><strong>消息无法送达！</strong> Server B 不知道如何将消息路由到 Server A。</li>
</ol>
</li>
<li><p><strong>传统解决方案：Sticky Session (会话保持)</strong></p>
<ul>
<li><p><strong>概念:</strong> 配置负载均衡器，使其能够识别来自同一客户端的所有请求，并始终将它们转发到<strong>同一个</strong>后端服务器。这通常通过 IP 哈希（<code>ip_hash</code> in Nginx）或设置特定的 Cookie 来实现。</p>
</li>
<li><p><strong>Nginx 配置示例 (<code>ip_hash</code>):</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> websocket_backend &#123;</span><br><span class="line">    ip_hash; // 核心配置：基于客户端 <span class="attribute">IP</span> 地址进行哈希</span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    <span class="attribute">server</span> backend2.example.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="section">location</span> /ws/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://websocket_backend;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;Upgrade&quot;</span>;</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Sticky Session 的严重缺陷:</strong></p>
<ol>
<li><strong>破坏了负载均衡的初衷:</strong> 如果某些“粘性”会话的用户活动非常频繁，可能会导致某些服务器负载过高，而其他服务器却很空闲，无法做到真正的负载均衡。</li>
<li><strong>单点故障风险:</strong> 如果 Client A 所在的 Server A 宕机或重启，Client A 的连接会中断。即使它能立即重连，负载均衡器也可能会因为 <code>ip_hash</code> 而继续尝试连接到已经宕机的 Server A，或者即使连接到了 Server B，它之前的会话状态也全部丢失了。</li>
<li><strong>广播&#x2F;群聊实现的复杂性:</strong> 即使使用了 Sticky Session，如果要实现一个跨所有服务器的广播（如系统公告）或群聊，你仍然需要自己实现一套<strong>服务器间的通信机制</strong>（例如，使用 Redis Pub&#x2F;Sub、Kafka 或 Hazelcast），让一个服务器能通知其他所有服务器向它们各自连接的客户端推送消息。这大大增加了系统的复杂性。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="3-2-STOMP-外部消息代理-RabbitMQ-的天然优势"><a href="#3-2-STOMP-外部消息代理-RabbitMQ-的天然优势" class="headerlink" title="3.2 STOMP + 外部消息代理 (RabbitMQ) 的天然优势"></a>3.2 STOMP + 外部消息代理 (RabbitMQ) 的天然优势</h3><p>这套架构是解决 WebSocket 水平扩展问题的<strong>黄金标准</strong>。它通过引入一个外部的、专业的消息中间件（Message Broker）来解耦应用服务器和消息路由。</p>
<ul>
<li><p><strong>核心思想：</strong><br>让应用服务器（你的 Spring Boot 应用）只充当一个“哑”网关（Dumb Gateway）。它的职责是：</p>
<ol>
<li>维护与客户端的 WebSocket 连接。</li>
<li>在 STOMP 协议层面与客户端和外部消息代理进行中继（Relay）。<br>消息的路由、分发、订阅管理等“有状态”的复杂工作全部交给外部的专业消息代理来完成。</li>
</ol>
</li>
<li><p><strong>架构与消息流：</strong></p>
<ol>
<li><strong>连接:</strong> Client 通过负载均衡器（无需 Sticky Session）连接到<strong>任意一个</strong>应用实例（如 Server A）。</li>
<li><strong>订阅:</strong> Client 发送一个 <code>SUBSCRIBE</code> 帧到某个主题（如 <code>/topic/news</code>）。Server A 收到后，并<strong>不是在自己内存中记录</strong>，而是代表该 Client 在外部消息代理（RabbitMQ）上创建一个订阅。</li>
<li><strong>发送消息:</strong> 另一个 Client（可能连接在 Server B）发送一个 <code>SEND</code> 帧到 <code>/topic/news</code>。</li>
<li><strong>中继到代理:</strong> Server B 收到消息后，直接将其<strong>转发</strong>给 RabbitMQ。</li>
<li><strong>代理分发:</strong> RabbitMQ 作为消息中心，知道所有关于 <code>/topic/news</code> 的订阅（包括来自 Server A 和 Server B 的）。它会将消息分发给所有订阅了此主题的应用服务器实例。</li>
<li><strong>推送到客户端:</strong> Server A 收到来自 RabbitMQ 的消息后，查询其<strong>本地</strong>维护的 WebSocket 连接，找到订阅了 <code>/topic/news</code> 的 Client，并将消息通过 WebSocket 推送给它。Server B 也做同样的事情。</li>
</ol>
</li>
<li><p><strong>配置 Spring Boot 使用 STOMP Broker Relay</strong></p>
<p>你需要在 <code>WebSocketMessageBrokerConfigurer</code> 中启用 <code>stompBrokerRelay</code>，并配置外部代理的地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageBroker</span><span class="params">(MessageBrokerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 设置客户端发送消息的目标前缀</span></span><br><span class="line">        registry.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 启用外部消息代理中继</span></span><br><span class="line">        registry.enableStompBrokerRelay(<span class="string">&quot;/topic&quot;</span>, <span class="string">&quot;/queue&quot;</span>) <span class="comment">// 声明哪些前缀由外部代理处理</span></span><br><span class="line">                .setRelayHost(<span class="string">&quot;localhost&quot;</span>)     <span class="comment">// RabbitMQ 主机地址</span></span><br><span class="line">                .setRelayPort(<span class="number">61613</span>)           <span class="comment">// RabbitMQ STOMP 插件默认端口</span></span><br><span class="line">                .setClientLogin(<span class="string">&quot;guest&quot;</span>)       <span class="comment">// 连接 RabbitMQ 的用户名</span></span><br><span class="line">                .setClientPasscode(<span class="string">&quot;guest&quot;</span>);   <span class="comment">// 连接 RabbitMQ 的密码</span></span><br><span class="line">                <span class="comment">// 对于生产环境，还应配置 systemLogin/systemPasscode 用于服务器自身的连接</span></span><br><span class="line">                <span class="comment">// .setSystemLogin(&quot;user&quot;)</span></span><br><span class="line">                <span class="comment">// .setSystemPasscode(&quot;password&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... registerStompEndpoints 配置保持不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> 你需要确保你的 RabbitMQ 已经安装并启用了 <code>rabbitmq_stomp</code> 插件。<br><code>rabbitmq-plugins enable rabbitmq_stomp</code></p>
</li>
<li><p><strong>天然优势总结:</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Sticky Session 方案</th>
<th align="left">STOMP + Broker Relay 方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>架构复杂度</strong></td>
<td align="left">高（需要手动实现服务器间通信）</td>
<td align="left">低（配置即可，复杂性由 Broker 处理）</td>
</tr>
<tr>
<td align="left"><strong>可扩展性</strong></td>
<td align="left">差（负载不均，难以扩展）</td>
<td align="left"><strong>极好</strong>（应用实例无状态，可随意增减）</td>
</tr>
<tr>
<td align="left"><strong>可用性</strong></td>
<td align="left">差（服务器宕机导致会话丢失）</td>
<td align="left"><strong>高</strong>（客户端可重连至任何实例，Broker 可集群）</td>
</tr>
<tr>
<td align="left"><strong>负载均衡</strong></td>
<td align="left">策略受限 (ip_hash)</td>
<td align="left">灵活（Round-Robin, Least Connections 等）</td>
</tr>
<tr>
<td align="left"><strong>耦合度</strong></td>
<td align="left">应用服务器间紧密耦合</td>
<td align="left"><strong>松散耦合</strong>（应用服务器与 Broker 通信）</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>结论：</strong> 对于任何需要横向扩展的生产级 WebSocket 应用，采用 <strong>STOMP 配合外部消息代理（如 RabbitMQ、ActiveMQ）</strong> 的方案是目前业界公认的最佳实践。它将你的应用服务器变成了易于扩展和维护的无状态节点，而将状态管理的重任交给了为此而生的专业消息中间件。</p>
<hr>
<h2 id="4-安全加固"><a href="#4-安全加固" class="headerlink" title="4. 安全加固"></a>4. 安全加固</h2><p>一旦 WebSocket 连接建立，它就为客户端和服务器之间打开了一条双向通信的“隧道”。这条隧道绕过了常规的 HTTP 请求&#x2F;响应周期，因此必须在连接建立时和连接期间都实施严格的安全策略。</p>
<h3 id="4-1-强制-WSS：数据传输加密"><a href="#4-1-强制-WSS：数据传输加密" class="headerlink" title="4.1 强制 WSS：数据传输加密"></a>4.1 强制 WSS：数据传输加密</h3><ul>
<li><p><strong>是什么？</strong></p>
<ul>
<li><code>ws://</code> (WebSocket) 类似于 <code>http://</code>，其传输的数据是<strong>未加密的明文</strong>。</li>
<li><code>wss://</code> (WebSocket Secure) 类似于 <code>https://</code>，它在标准的 WebSocket 协议基础上，通过 TLS&#x2F;SSL 加密层进行数据传输。</li>
</ul>
</li>
<li><p><strong>为什么必须使用？</strong><br>在生产环境中，如果使用 <code>ws://</code>，任何处在客户端和服务器之间的中间节点（如不安全的 Wi-Fi、代理、ISP）都可以轻易地<strong>窃听</strong>（读取消息内容）和<strong>篡改</strong>（修改消息内容）通信数据，这被称为中间人攻击（Man-in-the-Middle, MITM）。<code>wss://</code> 通过加密可以有效防止这类攻击，确保通信的<strong>机密性</strong>和<strong>完整性</strong>。</p>
</li>
<li><p><strong>如何实现？</strong></p>
<ol>
<li><p><strong>应用服务器配置 SSL&#x2F;TLS：</strong><br>在 Spring Boot 中，最简单的方式是在 <code>application.properties</code> 或 <code>application.yml</code> 中配置 SSL。你需要一个 SSL 证书（例如 <code>.p12</code> 或 <code>.jks</code> 格式）。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8443</span></span><br><span class="line"><span class="attr">server.ssl.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">server.ssl.key-store-type</span>=<span class="string">PKCS12</span></span><br><span class="line"><span class="attr">server.ssl.key-store</span>=<span class="string">classpath:keystore/your-certificate.p12</span></span><br><span class="line"><span class="attr">server.ssl.key-store-password</span>=<span class="string">your_password</span></span><br><span class="line"><span class="attr">server.ssl.key-alias</span>=<span class="string">your_alias</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在反向代理中终止 SSL (推荐的生产实践):</strong><br>在大多数生产环境中，SSL&#x2F;TLS 通常在反向代理层（如 Nginx、API Gateway）被终止。客户端连接到 Nginx 的 <code>wss://</code> 地址，而 Nginx 再通过内网的 <code>ws://</code> 连接到后端的 Spring Boot 应用。这样可以集中管理证书，并减轻应用服务器的加解密负担。<br><strong>Nginx 配置示例：</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> your.domain.com;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">ssl_certificate</span> /path/to/your/fullchain.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /path/to/your/privkey.pem;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /ws/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://&lt;your_spring_boot_app_ip&gt;:8080/ws/;</span><br><span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 关键头信息，用于协议升级</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;Upgrade&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 传递真实 IP 和协议信息</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>客户端修改连接地址：</strong><br>客户端只需将连接 URL 从 <code>ws://your.domain.com/ws</code> 修改为 <code>wss://your.domain.com/ws</code> 即可。</p>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-2-身份验证-Authentication"><a href="#4-2-身份验证-Authentication" class="headerlink" title="4.2 身份验证 (Authentication)"></a>4.2 身份验证 (Authentication)</h3><p>匿名 WebSocket 连接在大多数应用中是无用的，我们必须知道是<strong>谁</strong>在连接。</p>
<ul>
<li><p><strong>1. 基于 Token 的验证 (适用于前后端分离&#x2F;SPA)</strong><br>这是最常见的方式。用户通过 HTTP 登录获取一个 Token (如 JWT)，然后在建立 WebSocket 连接时携带此 Token。</p>
<ul>
<li><strong>实现方式：</strong> 在握手拦截器 <code>HandshakeInterceptor</code> 的 <code>beforeHandshake</code> 方法中进行校验。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServletServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.HandshakeInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.Principal;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthHandshakeInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandshakeInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入你的 Token 验证服务</span></span><br><span class="line">    <span class="comment">// @Autowired private JwtTokenProvider tokenProvider;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">beforeHandshake</span><span class="params">(ServerHttpRequest request, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> ServletServerHttpRequest) &#123;</span><br><span class="line">            <span class="type">ServletServerHttpRequest</span> <span class="variable">servletRequest</span> <span class="operator">=</span> (ServletServerHttpRequest) request;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从 HTTP Header 中获取 Token</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> servletRequest.getServletRequest().getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 简单的 Bearer Token 格式校验</span></span><br><span class="line">            <span class="keyword">if</span> (token != <span class="literal">null</span> &amp;&amp; token.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">                token = token.substring(<span class="number">7</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 验证 Token (伪代码)</span></span><br><span class="line">                <span class="comment">// if (tokenProvider.validateToken(token)) &#123;</span></span><br><span class="line">                <span class="comment">//    String username = tokenProvider.getUsernameFromJWT(token);</span></span><br><span class="line">                <span class="keyword">if</span> (isValid(token)) &#123; <span class="comment">// 替换为真实的 Token 验证逻辑</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> getUsernameFrom(token);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 创建一个 Principal 对象代表已认证的用户</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">Principal</span> <span class="variable">userPrincipal</span> <span class="operator">=</span> () -&gt; username;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 将认证信息放入 WebSocket Session 的 attributes 中</span></span><br><span class="line">                    <span class="comment">// 后续在 STOMP 的事件或控制器中可以通过 HeaderAccessor.getUser() 获取</span></span><br><span class="line">                    attributes.put(<span class="string">&quot;user&quot;</span>, userPrincipal);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 握手成功</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验证失败，拒绝握手</span></span><br><span class="line">        System.err.println(<span class="string">&quot;WebSocket handshake rejected: Invalid or missing token.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... afterHandshake 方法 ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 WebSocket 配置中注册此拦截器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> &#123;</span><br><span class="line">    registry.addEndpoint(<span class="string">&quot;/ws&quot;</span>)</span><br><span class="line">            .addInterceptors(<span class="keyword">new</span> <span class="title class_">AuthHandshakeInterceptor</span>()) <span class="comment">// 添加拦截器</span></span><br><span class="line">            .setAllowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端在连接时，需要在 <code>stompjs</code> 的 <code>connectHeaders</code> 中传入 Token。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">Client</span>(&#123;</span><br><span class="line">    <span class="attr">brokerURL</span>: <span class="string">&#x27;wss://your.domain.com/ws&#x27;</span>,</span><br><span class="line">    <span class="attr">connectHeaders</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;Bearer your-jwt-token-here&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>2. 集成 Spring Security (适用于传统 Session 或统一安全框架)</strong><br>如果你的应用已经在使用 Spring Security，那么集成 WebSocket 认证会非常自然。</p>
<ul>
<li><strong>原理：</strong> WebSocket 的 HTTP Upgrade 握手请求本身就是一个 HTTP 请求，它会经过 Spring Security 的 Filter 链。如果用户已经通过 HTTP 登录（例如，持有 Session Cookie），Spring Security 会自动将认证信息（<code>Principal</code>）填充到 <code>HttpServletRequest</code> 中。</li>
<li><strong>实现：</strong> Spring WebSocket 会<strong>自动</strong>从握手请求中获取 <code>Principal</code> 并将其与 <code>WebSocketSession</code> 关联。你几乎不需要做任何额外配置！</li>
<li><strong>使用：</strong> 在你的 <code>@MessageMapping</code> 方法中，可以直接注入 <code>Principal</code> 对象来获取当前用户信息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateMessageController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MessageMapping(&quot;/private.message&quot;)</span></span><br><span class="line">    <span class="meta">@SendToUser(&quot;/queue/reply&quot;)</span> <span class="comment">// 发送给当前用户</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendPrivateMessage</span><span class="params">(<span class="meta">@Payload</span> String message, Principal principal)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> principal.getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Received a private message from &quot;</span> + username + <span class="string">&quot;: &quot;</span> + message);</span><br><span class="line">        <span class="comment">// 处理私信逻辑...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Reply to &quot;</span> + username + <span class="string">&quot;: message received.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="4-3-跨站-WebSocket-劫持-CSWSH-防御"><a href="#4-3-跨站-WebSocket-劫持-CSWSH-防御" class="headerlink" title="4.3 跨站 WebSocket 劫持 (CSWSH) 防御"></a>4.3 跨站 WebSocket 劫持 (CSWSH) 防御</h3><ul>
<li><p><strong>攻击原理 (Cross-Site WebSocket Hijacking):</strong><br>这是一种类似于 CSRF 的攻击。假设用户已登录你的网站 <code>A.com</code>。然后，用户访问了一个恶意网站 <code>B.com</code>。<code>B.com</code> 的页面中的 JavaScript 可以尝试向你的 WebSocket 端点 <code>wss://A.com/ws</code> 发起连接。由于浏览器会自动携带 <code>A.com</code> 的 Cookie，如果你的认证是基于 Cookie 的，这个连接就会被认证成功。此时，<code>B.com</code> 就能以用户的身份与你的服务器进行 WebSocket 通信，窃取信息或执行恶意操作。</p>
</li>
<li><p><strong>防御手段：校验 <code>Origin</code> 头部</strong><br>浏览器在发起跨域请求（包括 WebSocket 握手）时，会自动在请求头中添加一个 <code>Origin</code> 字段，标明请求发起的源（例如 <code>https://B.com</code>）。服务器端必须校验这个 <code>Origin</code> 头部，只允许来自受信任域名的连接。</p>
</li>
<li><p><strong>Spring 实现：</strong><br>Spring WebSocket 提供了非常便捷的配置方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> &#123;</span><br><span class="line">    registry.addEndpoint(<span class="string">&quot;/ws&quot;</span>)</span><br><span class="line">            <span class="comment">// 只允许来自 &quot;https://your-frontend.com&quot; 的连接</span></span><br><span class="line">            .setAllowedOrigins(<span class="string">&quot;https://your-frontend.com&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 或者使用模式匹配，允许所有子域名</span></span><br><span class="line">            <span class="comment">// .setAllowedOriginPatterns(&quot;https://*.your-domain.com&quot;, &quot;http://localhost:3000&quot;)</span></span><br><span class="line">            </span><br><span class="line">            .withSockJS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最佳实践：</strong></p>
<ul>
<li><strong>永远不要使用 <code>setAllowedOrigins(&quot;\*&quot;)</code> 在生产环境！</strong> 这会完全禁用 Origin 检查，使你的应用暴露在 CSWSH 攻击之下。</li>
<li>尽可能使用 <code>setAllowedOrigins</code> 提供精确的域名列表。</li>
<li>如果需要支持多个子域或开发环境，谨慎使用 <code>setAllowedOriginPatterns</code>。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-性能与调优"><a href="#5-性能与调优" class="headerlink" title="5. 性能与调优"></a>5. 性能与调优</h2><p>当 WebSocket 应用的用户量和消息吞吐量增长时，性能瓶颈可能会出现在网络、CPU 或内存等多个方面。合理的调优可以显著提升应用的吞吐能力和稳定性。</p>
<h3 id="5-1-消息大小与缓冲区配置"><a href="#5-1-消息大小与缓冲区配置" class="headerlink" title="5.1 消息大小与缓冲区配置"></a>5.1 消息大小与缓冲区配置</h3><ul>
<li><p><strong>背景：</strong><br>为了处理网络 I&#x2F;O，WebSocket 服务器（如 Tomcat, Undertow）和 Spring 框架本身都会使用缓冲区（Buffer）。当应用发送消息时，消息数据会先被写入这些缓冲区，然后由 I&#x2F;O 线程异步发送到网络上。缓冲区的大小直接影响了消息处理的方式和效率。</p>
</li>
<li><p><strong>核心参数：</strong><br>在 Spring Boot 中，主要有两层配置需要关注：</p>
<ol>
<li><p><strong>Spring WebSocket 消息缓冲区 (<code>spring.websocket.messaging.\*</code>):</strong><br>这些配置控制 Spring <code>StompSubProtocolHandler</code> 的行为。</p>
<ul>
<li><code>send-buffer-size-limit</code>: 发送缓冲区的总大小限制（默认 512KB）。当缓冲区满时，尝试发送消息的线程会被<strong>阻塞</strong>，直到缓冲区有可用空间。这是一种背压（Back-pressure）机制，防止应用因生产消息过快而耗尽内存。</li>
<li><code>send-time-limit</code>: 发送消息的超时时间（默认 10秒）。如果一个消息因为缓冲区持续满而无法在规定时间内发送，连接将被关闭。这可以防止一个缓慢的客户端拖垮整个服务器。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"><span class="comment"># 将发送缓冲区上限增加到 1MB</span></span><br><span class="line"><span class="attr">spring.websocket.messaging.send-buffer-size-limit</span>=<span class="string">1048576 </span></span><br><span class="line"><span class="comment"># 将发送超时时间增加到 20 秒</span></span><br><span class="line"><span class="attr">spring.websocket.messaging.send-time-limit</span>=<span class="string">20000 </span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Web 容器 I&#x2F;O 缓冲区 (<code>server.tomcat.\*</code> or <code>server.undertow.\*</code>):</strong><br>这控制了底层 Web 容器的 TCP 缓冲区大小。如果一条 WebSocket 消息的大小超过了这个缓冲区，它将被<strong>分片 (Fragmented)</strong> 成多个 WebSocket 帧进行传输。</p>
<ul>
<li><strong>Tomcat:</strong> <code>server.tomcat.max-http-post-size</code> (虽然名字是post，但也影响WebSocket消息大小)</li>
<li><strong>Undertow:</strong> <code>server.undertow.buffer-size</code></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>调优策略：</strong></p>
<ul>
<li><strong>对于大量小消息：</strong> 默认配置通常表现良好。过大的缓冲区可能会造成内存浪费。</li>
<li><strong>对于需要发送大消息的场景（如文件传输、大数据可视化）：</strong><ul>
<li>必须适当<strong>增大 <code>send-buffer-size-limit</code></strong>，否则发送线程会频繁阻塞，导致吞吐量下降。</li>
<li>同时，可能需要增大底层容器的缓冲区（如 <code>server.undertow.buffer-size</code>），以<strong>避免消息被过度分片</strong>。消息分片和重组会带来额外的 CPU 和网络开销。</li>
<li><strong>原则：</strong> 容器的 I&#x2F;O 缓冲区大小应略大于你预期的最大单条消息大小。</li>
</ul>
</li>
<li><strong>监控：</strong> 在生产环境中，监控发送缓冲区的利用率和因缓冲区满而导致的阻塞时间，是决定是否需要调优的关键依据。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-2-同步与异步发送的选择"><a href="#5-2-同步与异步发送的选择" class="headerlink" title="5.2 同步与异步发送的选择"></a>5.2 同步与异步发送的选择</h3><ul>
<li><strong>Spring STOMP 的默认行为：异步发送</strong><br>当你使用 <code>SimpMessagingTemplate.convertAndSend()</code> 时，这个调用是<strong>异步</strong>的。<ul>
<li><strong>工作原理：</strong> 你的调用线程（例如，一个处理 HTTP 请求的线程）将消息交给 Spring 的 <code>clientOutboundChannel</code> 后会<strong>立即返回</strong>。专门的 <code>outbound-channel-executor</code> 线程池会负责将消息实际写入 WebSocket 连接。</li>
<li><strong>优势：</strong><ol>
<li><strong>高吞吐量：</strong> 应用线程不会因为网络 I&#x2F;O 或慢客户端而被阻塞，可以快速处理更多业务请求。</li>
<li><strong>隔离性：</strong> WebSocket 的发送性能问题不会直接影响到应用的其它部分（如 HTTP API 的响应时间）。</li>
</ol>
</li>
<li><strong>结论：</strong> 在绝大多数情况下，<strong>你应该坚持使用默认的异步发送</strong>。这是 Spring 设计的精髓所在，旨在构建高并发、响应迅速的应用。</li>
</ul>
</li>
<li><strong>原生 WebSocket API 的行为：同步发送</strong><br>如果你使用原生的 <code>WebSocketSession.sendMessage()</code>，这个调用通常是<strong>同步阻塞</strong>的。<ul>
<li><strong>潜在风险：</strong> 调用线程会一直等待，直到消息被完全写入操作系统的 TCP 发送缓冲区。如果网络拥塞或者客户端接收缓慢，这个调用可能会<strong>阻塞很长时间</strong>。</li>
<li><strong>严重后果：</strong> 如果你在一个处理 HTTP 请求的关键线程中调用了 <code>session.sendMessage()</code>，一个慢速的 WebSocket 客户端就可能耗尽你的 HTTP 线程池，导致整个应用无响应。</li>
<li><strong>解决方案：</strong> 如果你必须使用原生 API 并且需要发送大量数据，你应该将 <code>sendMessage()</code> 的调用<strong>包装在自己的异步任务中</strong>（例如，提交给一个专用的线程池），以避免阻塞关键线程。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-3-消息格式选择：JSON-vs-Protobuf"><a href="#5-3-消息格式选择：JSON-vs-Protobuf" class="headerlink" title="5.3 消息格式选择：JSON vs Protobuf"></a>5.3 消息格式选择：JSON vs Protobuf</h3><p>消息格式的选择直接影响到<strong>网络带宽占用</strong>、<strong>CPU 序列化&#x2F;反序列化开销</strong>和<strong>开发调试效率</strong>。</p>
<ul>
<li><strong>JSON (JavaScript Object Notation)</strong><ul>
<li><strong>优点：</strong><ul>
<li><strong>可读性强：</strong> 纯文本，易于人类阅读和调试。</li>
<li><strong>通用性好：</strong> Web 前端原生支持（<code>JSON.parse</code>, <code>JSON.stringify</code>），几乎所有语言都有完善的库。</li>
<li><strong>开发友好：</strong> 无需预定义 schema，动态修改结构方便。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>冗余：</strong> 包含大量的键名、括号、引号，体积较大。</li>
<li><strong>性能：</strong> 基于文本的解析比二进制解析慢。</li>
<li><strong>类型不安全：</strong> 无法在协议层面保证数据类型和结构的正确性。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Protobuf (Protocol Buffers)</strong><ul>
<li><strong>优点：</strong><ul>
<li><strong>极致紧凑：</strong> 二进制格式，移除了所有冗余信息，消息体积通常比 JSON 小 3-10 倍。</li>
<li><strong>高性能：</strong> 序列化和反序列化速度极快，CPU 占用低。</li>
<li><strong>强类型与 schema：</strong> 通过 <code>.proto</code> 文件预定义消息结构，具有严格的类型检查，减少运行时错误。</li>
<li><strong>向后&#x2F;向前兼容：</strong> 良好的版本管理机制，便于协议升级。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>不可读：</strong> 二进制格式，无法直接阅读，调试需要借助工具。</li>
<li><strong>需要编译：</strong> <code>.proto</code> 文件需要编译成特定语言的代码（如 Java, JS）。</li>
<li><strong>前期工作量大：</strong> 需要预先设计和维护 <code>.proto</code> 文件。</li>
</ul>
</li>
</ul>
</li>
<li><strong>选型指南与对比</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">JSON</th>
<th align="left">Protobuf</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>可读性</strong></td>
<td align="left"><strong>高</strong></td>
<td align="left">低 (二进制)</td>
</tr>
<tr>
<td align="left"><strong>消息体积</strong></td>
<td align="left">大 (冗余)</td>
<td align="left"><strong>小</strong> (紧凑)</td>
</tr>
<tr>
<td align="left"><strong>序列化性能</strong></td>
<td align="left">中等</td>
<td align="left"><strong>高</strong></td>
</tr>
<tr>
<td align="left"><strong>Schema 约束</strong></td>
<td align="left">无 (灵活但易错)</td>
<td align="left"><strong>强</strong> (<code>.proto</code> 文件)</td>
</tr>
<tr>
<td align="left"><strong>开发效率</strong></td>
<td align="left"><strong>高</strong> (快速上手)</td>
<td align="left">低 (需要预定义和编译)</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">Web 应用、管理后台、API</td>
<td align="left">高性能游戏、金融行情、IoT、移动端</td>
</tr>
</tbody></table>
<p><strong>如何在 Spring 中使用 Protobuf？</strong></p>
<p>你需要创建一个自定义的 <code>MessageConverter</code>。</p>
<ol>
<li><p><strong>添加依赖:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.protobuf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.21.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- Use an appropriate version --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建 <code>ProtobufMessageConverter</code>:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtobufMessageConverter</span> <span class="keyword">extends</span> <span class="title class_">AbstractMessageConverter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProtobufMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 定义此转换器支持的 MimeType</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">MimeType</span>(<span class="string">&quot;application&quot;</span>, <span class="string">&quot;x-protobuf&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否是 Protobuf 生成的类</span></span><br><span class="line">        <span class="keyword">return</span> GeneratedMessageV3.class.isAssignableFrom(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">convertFromInternal</span><span class="params">(Message&lt;?&gt; message, Class&lt;?&gt; targetClass, Object conversionHint)</span> &#123;</span><br><span class="line">        <span class="comment">// 反序列化逻辑（省略）</span></span><br><span class="line">        <span class="comment">// 从 message.getPayload() (byte[]) 反序列化为 targetClass</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.convertFromInternal(message, targetClass, conversionHint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">convertToInternal</span><span class="params">(Object payload, MessageHeaders headers, Object conversionHint)</span> &#123;</span><br><span class="line">        <span class="comment">// 序列化逻辑</span></span><br><span class="line">        <span class="comment">// 将 payload (Protobuf 对象) 序列化为 byte[]</span></span><br><span class="line">        <span class="keyword">return</span> ((GeneratedMessageV3) payload).toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 WebSocket 配置中注册转换器：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">configureMessageConverters</span><span class="params">(List&lt;MessageConverter&gt; messageConverters)</span> &#123;</span><br><span class="line">    messageConverters.add(<span class="keyword">new</span> <span class="title class_">ProtobufMessageConverter</span>());</span><br><span class="line">    <span class="comment">// 返回 false 以保留 Spring 默认的转换器 (如 Jackson2JsonMessageConverter)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="七、总结与展望"><a href="#七、总结与展望" class="headerlink" title="七、总结与展望"></a>七、总结与展望</h1><h2 id="1-技术选型指南"><a href="#1-技术选型指南" class="headerlink" title="1. 技术选型指南"></a>1. 技术选型指南</h2><p>在 Java 生态中，实现 WebSocket 有多种层次的抽象。选择哪一种技术取决于你的项目需求、团队熟悉度、以及对未来扩展性的预期。下面是三种主流方案的选型对比。</p>
<h3 id="1-1-何时使用-JSR-356-Java-原生-API-？"><a href="#1-1-何时使用-JSR-356-Java-原生-API-？" class="headerlink" title="1.1 何时使用 JSR 356 (Java 原生 API)？"></a>1.1 何时使用 JSR 356 (Java 原生 API)？</h3><p><strong>一句话总结：当你不使用 Spring 框架，或者你需要对 WebSocket 协议进行“像素级”的底层控制时。</strong></p>
<ul>
<li><strong>核心特征：</strong><ul>
<li><strong>标准规范：</strong> 作为 Java EE 的一部分，它保证了在不同实现了该规范的应用服务器（Tomcat, Jetty, Undertow 等）之间的可移植性。</li>
<li><strong>轻量级：</strong> 无需任何额外的框架依赖，非常轻量。</li>
<li><strong>最大控制权：</strong> 你可以直接操作 <code>Session</code>、处理 <code>Ping/Pong</code> 控制帧、自定义消息分片等，拥有对连接最底层的完全控制。</li>
</ul>
</li>
<li><strong>适用场景：</strong><ul>
<li><strong>非 Spring 环境：</strong> 在一个未使用 Spring 或 Spring Boot 的传统 Java Web 项目中。</li>
<li><strong>高度定制的协议：</strong> 当你需要实现一个完全自定义的、非 STOMP 的二进制或文本协议时。</li>
<li><strong>极限性能压榨：</strong> 在某些需要极致优化内存和 CPU 的场景下，你希望避免任何框架开销，并手动管理所有资源。</li>
<li><strong>构建 WebSocket 框架或代理：</strong> 如果你的目标是开发一个基于 WebSocket 的中间件或库，直接使用标准 API 是最合适的。</li>
</ul>
</li>
<li><strong>局限性：</strong><ul>
<li><strong>所有事情都得自己做：</strong> 你需要手动管理 Session 列表、实现用户与 Session 的映射、编写消息广播&#x2F;群发&#x2F;单发的路由逻辑、手动实现心跳检测和重连策略。工作量巨大且容易出错。</li>
<li><strong>与 Spring 生态脱节：</strong> 无法直接利用 Spring 的依赖注入、AOP、安全管理等便利特性。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-何时使用-Spring-原生-WebSocket-WebSocketHandler-？"><a href="#1-2-何时使用-Spring-原生-WebSocket-WebSocketHandler-？" class="headerlink" title="1.2 何时使用 Spring 原生 WebSocket (WebSocketHandler)？"></a>1.2 何时使用 Spring 原生 WebSocket (<code>WebSocketHandler</code>)？</h3><p><strong>一句话总结：当你需要一个简单的、事件驱动的 WebSocket 实现，并且希望与 Spring 生态无缝集成时。</strong></p>
<ul>
<li><strong>核心特征：</strong><ul>
<li><strong>Spring 生态集成：</strong> 完美融入 Spring，可以自由使用 <code>@Autowired</code> 注入任何 Bean。<code>WebSocketHandler</code> 本身就是一个 Spring Bean。</li>
<li><strong>事件驱动模型：</strong> 提供了清晰的生命周期方法，如 <code>afterConnectionEstablished</code>, <code>handleMessage</code>, <code>afterConnectionClosed</code>。逻辑清晰，易于理解。</li>
<li><strong>中间层抽象：</strong> 它隐藏了 JSR 356 的底层细节，但又不像 STOMP 那样引入完整的消息协议。你处理的是 <code>WebSocketMessage</code>，而不是更复杂的 STOMP 帧。</li>
</ul>
</li>
<li><strong>适用场景：</strong><ul>
<li><strong>简单的服务器推送 (Server-Push)：</strong> 例如，向客户端推送系统状态、股票行情、日志更新等，客户端主要是接收方。</li>
<li><strong>简单的请求-响应：</strong> 客户端发送一个请求，服务器处理后返回一个结果，没有复杂的路由需求。</li>
<li><strong>自定义协议原型：</strong> 你想在 Spring 环境中实现一个简单的自定义 JSON 协议，但又觉得 STOMP 太重。</li>
<li><strong>SockJS 兼容性：</strong> 当你需要利用 Spring 提供的 SockJS 后备方案来兼容不支持 WebSocket 的旧浏览器时。</li>
</ul>
</li>
<li><strong>局限性：</strong><ul>
<li><strong>缺少协议层支持：</strong> 你仍然需要自己定义消息的格式（例如，在 JSON 中包含 “type”, “payload” 字段）并手动解析和路由。</li>
<li><strong>广播&#x2F;订阅逻辑需自建：</strong> 仍然需要手动维护 Session 列表来实现向多个用户发送消息。</li>
<li><strong>无内置用户目标：</strong> 不支持像 STOMP 那样方便的 <code>/user/queue/private</code> 私有消息。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-何时使用-Spring-STOMP？"><a href="#1-3-何时使用-Spring-STOMP？" class="headerlink" title="1.3 何时使用 Spring + STOMP？"></a>1.3 何时使用 Spring + STOMP？</h3><p><strong>一句话总结：对于绝大多数需要复杂交互（如聊天、协作、通知）的现代 Web 应用，这应该是你的</strong>默认<strong>和</strong>首选<strong>方案。</strong></p>
<ul>
<li><strong>核心特征：</strong><ul>
<li><strong>完整的消息协议：</strong> STOMP 是一个成熟的、轻量级的消息协议。它定义了 <code>SUBSCRIBE</code>, <code>SEND</code>, <code>MESSAGE</code> 等命令，让通信变得结构化。</li>
<li><strong>面向消息的编程模型：</strong> 使用 <code>@MessageMapping</code> 和 <code>@SubscribeMapping</code>，就像使用 Spring MVC 的 <code>@RequestMapping</code> 一样自然，极大地提高了开发效率。</li>
<li><strong>内置路由和广播：</strong> 基于目标地址（Destination）的发布-订阅（Pub-Sub）模型。你只需要向一个主题（如 <code>/topic/news</code>）发送消息，所有订阅了该主题的客户端都会收到，无需手动遍历 Session。</li>
<li><strong>强大的用户私信：</strong> 内置的 <code>/user</code> 目标前缀可以轻松实现向特定用户发送消息，这是许多应用的核心需求。</li>
<li><strong>完美的横向扩展能力：</strong> 可以无缝地从内置的简单代理切换到外部消息代理（如 RabbitMQ, ActiveMQ），以支持多实例集群部署，这是企业级应用的关键。</li>
</ul>
</li>
<li><strong>适用场景：</strong><ul>
<li><strong>聊天室&#x2F;即时通讯（IM）</strong></li>
<li><strong>在线协作工具</strong>（如协同编辑、白板）</li>
<li><strong>实时通知系统</strong></li>
<li><strong>实时数据仪表盘</strong>（Dashboard）</li>
<li><strong>任何需要 Pub-Sub、点对点消息、且未来可能需要水平扩展的应用。</strong></li>
</ul>
</li>
<li><strong>局限性：</strong><ul>
<li><strong>有一定学习成本：</strong> 需要理解 STOMP 协议的基本概念（Destination, Frame, Broker 等）。</li>
<li><strong>协议开销：</strong> 相比原生 WebSocket，STOMP 帧会增加一些协议头的开销，但对于大多数应用来说，这种开销可以忽略不计，换来的是巨大的开发便利性和可扩展性。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-4-技术选型对比速查表"><a href="#1-4-技术选型对比速查表" class="headerlink" title="1.4 技术选型对比速查表"></a>1.4 技术选型对比速查表</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">JSR 356 (原生)</th>
<th align="left">Spring 原生 WebSocket</th>
<th align="left">Spring + STOMP (推荐)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>抽象级别</strong></td>
<td align="left"><strong>底层</strong> (直接操作 Session 和帧)</td>
<td align="left"><strong>中层</strong> (事件驱动，消息对象)</td>
<td align="left"><strong>高层</strong> (消息协议，注解驱动)</td>
</tr>
<tr>
<td align="left"><strong>开发效率</strong></td>
<td align="left">低</td>
<td align="left">中</td>
<td align="left"><strong>高</strong></td>
</tr>
<tr>
<td align="left"><strong>功能完备性</strong></td>
<td align="left">基础</td>
<td align="left">中等</td>
<td align="left"><strong>非常完备</strong> (路由, 用户目标, 心跳…)</td>
</tr>
<tr>
<td align="left"><strong>横向扩展</strong></td>
<td align="left">困难 (需手动实现)</td>
<td align="left">困难 (需手动实现)</td>
<td align="left"><strong>简单</strong> (切换到外部 Broker)</td>
</tr>
<tr>
<td align="left"><strong>典型用例</strong></td>
<td align="left">非 Spring 环境，定制协议</td>
<td align="left">简单的服务器推送，简单请求响应</td>
<td align="left"><strong>聊天、通知、协作、任何复杂交互</strong></td>
</tr>
<tr>
<td align="left"><strong>推荐指数</strong></td>
<td align="left">★☆☆☆☆</td>
<td align="left">★★☆☆☆</td>
<td align="left">★★★★★</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-常用调试工具"><a href="#2-常用调试工具" class="headerlink" title="2. 常用调试工具"></a>2. 常用调试工具</h2><p>调试 WebSocket 不像调试 HTTP 那样直观，因为连接是持久的，通信是异步的。幸运的是，我们有多种强大的工具来帮助我们窥探 WebSocket 的内部世界。</p>
<h3 id="2-1-浏览器开发者工具-Network-WS"><a href="#2-1-浏览器开发者工具-Network-WS" class="headerlink" title="2.1 浏览器开发者工具 (Network -&gt; WS)"></a>2.1 浏览器开发者工具 (Network -&gt; WS)</h3><p>这是最直接、最常用的前端 WebSocket 调试工具，每个现代浏览器（Chrome, Firefox, Edge, Safari）都内置了它。</p>
<ul>
<li><strong>如何找到它？</strong><ol>
<li>在你的网页上按 <code>F12</code> 或右键选择“检查”打开开发者工具。</li>
<li>切换到 <strong>Network (网络)</strong> 面板。</li>
<li>在筛选器中，点击 <strong>WS</strong> (WebSocket) 来过滤出 WebSocket 连接。</li>
<li>刷新页面或执行建立 WebSocket 连接的操作。</li>
</ol>
</li>
<li><strong>核心功能与解读：</strong><ol>
<li><strong>Headers (标头) 面板：</strong><ul>
<li><strong>General (常规):</strong> 显示请求 URL (<code>wss://...</code>)、请求方法（<code>GET</code>）和最重要的<strong>状态码 <code>101 Switching Protocols</code></strong>。如果不是 101，说明 WebSocket 握手失败了，你需要检查 URL、服务器配置或拦截器逻辑。</li>
<li><strong>Response Headers (响应标头):</strong> 确认服务器返回了 <code>Upgrade: websocket</code> 和 <code>Connection: Upgrade</code>。</li>
<li><strong>Request Headers (请求标头):</strong> 检查客户端是否正确发送了 <code>Upgrade: websocket</code>、<code>Connection: Upgrade</code> 以及重要的 <code>Sec-WebSocket-Key</code>。这也是检查 <code>Origin</code> 头和自定义认证头（如 <code>Authorization</code>）的地方。</li>
</ul>
</li>
<li><strong>Messages (消息&#x2F;帧) 面板：</strong><ul>
<li>这是<strong>最核心</strong>的调试区域。它实时显示客户端和服务器之间传输的所有数据帧。</li>
<li><strong>绿色向上箭头 (<code>↑</code>):</strong> 表示由客户端<strong>发送</strong>到服务器的消息。</li>
<li><strong>红色向下箭头 (<code>↓</code>):</strong> 表示由服务器<strong>接收</strong>到客户端的消息。</li>
<li><strong>Data (数据) 列：</strong> 显示消息的内容。如果内容是 JSON，通常可以直接展开查看。对于 STOMP，你会看到完整的 STOMP 帧，包括命令（<code>CONNECT</code>, <code>SUBSCRIBE</code>, <code>MESSAGE</code>）、头部和 Body。</li>
<li><strong>Time (时间) 列：</strong> 显示消息的时间戳，有助于分析延迟和消息顺序。</li>
<li><strong>筛选器：</strong> 你可以在顶部输入关键词来筛选特定的消息，这在消息流非常快时特别有用。</li>
</ul>
</li>
</ol>
</li>
<li><strong>调试技巧：</strong><ul>
<li><strong>握手失败：</strong> 首先检查 <code>Headers</code> 面板，确认状态码和请求&#x2F;响应头是否正确。检查控制台（Console）是否有相关的错误信息。</li>
<li><strong>消息未收到：</strong> 在 <code>Messages</code> 面板确认消息是否真的被发送或接收。检查 STOMP 帧的目标地址（<code>destination</code> header）是否正确。</li>
<li><strong>消息格式错误：</strong> 点击具体的消息行，查看原始数据，确认 JSON 格式是否正确，或者 STOMP 帧的结构是否符合规范。</li>
<li><strong>心跳观察：</strong> 如果配置了 STOMP 心跳，你会在 <code>Messages</code> 面板中看到周期性的换行符（<code>\n</code>）或 <code>MESSAGE</code> 帧（取决于代理实现），这可以用来确认心跳机制是否在正常工作。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-Postman-Apifox-的-WebSocket-测试功能"><a href="#2-2-Postman-Apifox-的-WebSocket-测试功能" class="headerlink" title="2.2 Postman &#x2F; Apifox 的 WebSocket 测试功能"></a>2.2 Postman &#x2F; Apifox 的 WebSocket 测试功能</h3><p>虽然浏览器是调试前端的好地方，但有时我们需要一个独立的、功能更强大的客户端来模拟各种场景或进行后端接口测试。Postman 和 Apifox 等 API 工具提供了出色的 WebSocket 测试支持。</p>
<ul>
<li><strong>核心优势：</strong><ul>
<li><strong>独立于前端：</strong> 无需编写任何前端代码，可以直接连接到 WebSocket 服务器，非常适合后端开发人员自测接口。</li>
<li><strong>强大的请求定制能力：</strong> 可以方便地设置 URL、自定义握手请求头（如 <code>Authorization</code> Token）、URL 参数等。</li>
<li><strong>保存和复用：</strong> 可以将 WebSocket 请求保存到集合中，方便团队协作和回归测试。</li>
<li><strong>清晰的消息流展示：</strong> 提供了独立的发送和接收消息面板，并且可以格式化显示 JSON 或其他格式。</li>
</ul>
</li>
<li><strong>使用方法 (以 Postman 为例):</strong><ol>
<li><strong>新建请求：</strong> 在 Postman 中，点击 “New”，然后选择 “WebSocket Request”。</li>
<li><strong>输入 URL：</strong> 在地址栏输入你的 WebSocket 端点 URL（例如 <code>ws://localhost:8080/ws</code>）。</li>
<li><strong>配置握手 (Handshake):</strong><ul>
<li>切换到 <strong>Headers</strong> 标签页。</li>
<li>添加必要的头信息，例如 <code>Authorization</code> <code>Bearer your-jwt-token</code>。</li>
</ul>
</li>
<li><strong>连接 (Connect):</strong> 点击 “Connect” 按钮。如果连接成功，下方会显示 “CONNECTED” 状态，并且 “Messages” 区域会被激活。</li>
<li><strong>发送&#x2F;接收消息 (Compose &amp; View):</strong><ul>
<li>在下方的 “Message” 输入框中编写你要发送的消息内容。</li>
<li>点击 “Send” 按钮。</li>
<li>你发送的消息和从服务器收到的消息都会按时间顺序显示在主窗口中，并用不同的颜色和图标区分方向。</li>
</ul>
</li>
<li><strong>断开连接 (Disconnect):</strong> 测试完成后，点击 “Disconnect” 关闭连接。</li>
</ol>
</li>
<li><strong>调试场景：</strong><ul>
<li><strong>后端接口测试：</strong> 在后端开发完一个 <code>@MessageMapping</code> 接口后，立即用 Postman&#x2F;Apifox 模拟客户端发送消息，验证接口逻辑是否正确，而不需要等待前端开发完成。</li>
<li><strong>异常场景模拟：</strong> 发送格式错误的消息、不合法的 STOMP 帧，测试服务器的异常处理能力 (<code>@MessageExceptionHandler</code>)。</li>
<li><strong>认证测试：</strong> 快速测试不同的 Token 或认证凭据是否能成功建立连接。</li>
<li><strong>性能&#x2F;压力测试：</strong> 某些工具的高级版本或插件支持编写脚本来模拟大量并发连接和消息，进行简单的压力测试。</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li><strong>浏览器开发者工具</strong> 是调试<strong>前端与后端集成</strong>时的首选，它真实反映了用户浏览器中的情况。</li>
<li><strong>Postman&#x2F;Apifox</strong> 则是<strong>后端开发和纯接口测试</strong>的利器，它将后端逻辑与前端界面完全解耦，让测试更纯粹、更高效。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/10/17/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/HTTP%E5%8D%8F%E8%AE%AE/" rel="prev" title="HTTP协议">
                  <i class="fa fa-angle-left"></i> HTTP协议
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/10/20/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF/" rel="next" title="HTTP客户端">
                  HTTP客户端 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
