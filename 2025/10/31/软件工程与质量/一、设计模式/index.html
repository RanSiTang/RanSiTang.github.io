<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="一、设计模式1. 基础篇1.1 引言1.1.1 软件设计的“复杂度”问题作为软件工程师，我们日常工作的核心就是对抗复杂度 (Complexity)。一个软件系统从最初简单的“Hello World”到承载百万用户访问的企业级应用，其复杂度是呈指数级增长的。 这种复杂度并非仅仅指代码行数的增加，它体现在多个维度：  需求的不确定性 (Uncertainty of Requirements): 客户的">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="http://example.com/2025/10/31/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%B4%A8%E9%87%8F/%E4%B8%80%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="一、设计模式1. 基础篇1.1 引言1.1.1 软件设计的“复杂度”问题作为软件工程师，我们日常工作的核心就是对抗复杂度 (Complexity)。一个软件系统从最初简单的“Hello World”到承载百万用户访问的企业级应用，其复杂度是呈指数级增长的。 这种复杂度并非仅仅指代码行数的增加，它体现在多个维度：  需求的不确定性 (Uncertainty of Requirements): 客户的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://martinfowler.com/bliki/images/circuitBreaker/state.png">
<meta property="article:published_time" content="2025-10-31T03:52:28.000Z">
<meta property="article:modified_time" content="2025-11-01T02:01:08.003Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://martinfowler.com/bliki/images/circuitBreaker/state.png">


<link rel="canonical" href="http://example.com/2025/10/31/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%B4%A8%E9%87%8F/%E4%B8%80%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/10/31/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%B4%A8%E9%87%8F/%E4%B8%80%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","path":"2025/10/31/软件工程与质量/一、设计模式/","title":"设计模式"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>设计模式 | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">一、设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="nav-text">1. 基础篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%BC%95%E8%A8%80"><span class="nav-text">1.1 引言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E2%80%9C%E5%A4%8D%E6%9D%82%E5%BA%A6%E2%80%9D%E9%97%AE%E9%A2%98"><span class="nav-text">1.1.1 软件设计的“复杂度”问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E5%89%8D%E4%BA%BA%E7%BB%8F%E9%AA%8C%E7%9A%84%E7%BB%93%E6%99%B6"><span class="nav-text">1.1.2 前人经验的结晶</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-%E5%AD%A6%E4%B9%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-text">1.1.3 学习设计模式的好处</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%EF%BC%88SOLID-2%EF%BC%89"><span class="nav-text">1.2 设计模式的七大原则（SOLID + 2）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-S-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99-Single-Responsibility-Principle-SRP"><span class="nav-text">1.2.1 S - 单一职责原则 (Single Responsibility Principle, SRP)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-O-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99-Open-Closed-Principle-OCP"><span class="nav-text">1.2.2 O - 开闭原则 (Open-Closed Principle, OCP)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-L-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99-Liskov-Substitution-Principle-LSP"><span class="nav-text">1.2.3 L - 里氏替换原则 (Liskov Substitution Principle, LSP)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4-I-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99-Interface-Segregation-Principle-ISP"><span class="nav-text">1.2.4 I - 接口隔离原则 (Interface Segregation Principle, ISP)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-5-D-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99-Dependency-Inversion-Principle-DIP"><span class="nav-text">1.2.5 D - 依赖倒置原则 (Dependency Inversion Principle, DIP)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-6-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99-Law-of-Demeter-LoD-%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E5%8E%9F%E5%88%99"><span class="nav-text">1.2.6 迪米特法则 (Law of Demeter, LoD) &#x2F; 最少知识原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-7-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99-Composite-Reuse-Principle-CRP"><span class="nav-text">1.2.7 合成复用原则 (Composite Reuse Principle, CRP)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-Creational-Patterns"><span class="nav-text">2. 创建型模式 (Creational Patterns)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Singleton-Pattern"><span class="nav-text">2.1 单例模式 (Singleton Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">2.1.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">2.1.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E6%8C%89%E6%8E%A8%E8%8D%90%E5%BA%A6%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="nav-text">2.1.3 实现方式（按推荐度排序）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%9E%9A%E4%B8%BE%EF%BC%88Enum%EF%BC%89-%E3%80%90%E6%9E%81%E5%8A%9B%E6%8E%A8%E8%8D%90%E3%80%91"><span class="nav-text">1. 枚举（Enum）- 【极力推荐】</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Static-Inner-Class%EF%BC%89-%E3%80%90%E6%8E%A8%E8%8D%90%E3%80%91"><span class="nav-text">2. 静态内部类（Static Inner Class）- 【推荐】</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%EF%BC%88Double-Checked-Locking-DCL%EF%BC%89"><span class="nav-text">3. 双重检查锁定（Double-Checked Locking, DCL）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%88Eager-Initialization%EF%BC%89"><span class="nav-text">4. 饿汉式（Eager Initialization）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">2.1.4 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-Factory-Method-Pattern"><span class="nav-text">2.2 工厂方法模式 (Factory Method Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">2.2.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">2.2.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-text">2.2.3 实现方式（经典结构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">2.2.4 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-Abstract-Factory-Pattern"><span class="nav-text">2.3 抽象工厂模式 (Abstract Factory Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">2.3.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">2.3.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-text">2.3.3 实现方式（经典结构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-%E4%B8%8E%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-text">2.3.4 与工厂方法模式的对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-5-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">2.3.5 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-Builder-Pattern"><span class="nav-text">2.4 建造者模式 (Builder Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">2.4.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">2.4.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E6%8C%89%E6%8E%A8%E8%8D%90%E5%BA%A6%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="nav-text">2.4.3 实现方式（按推荐度排序）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Lombok-%E7%9A%84-Builder-%E6%B3%A8%E8%A7%A3-%E3%80%90%E6%9E%81%E5%8A%9B%E6%8E%A8%E8%8D%90%E3%80%91"><span class="nav-text">1. Lombok 的 @Builder 注解 - 【极力推荐】</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Static-Inner-Class%EF%BC%89-%E3%80%90%E7%BB%8F%E5%85%B8%E4%B8%94%E6%8E%A8%E8%8D%90%E3%80%91"><span class="nav-text">2. 静态内部类（Static Inner Class） - 【经典且推荐】</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-4-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">2.4.4 实际解决问题 &#x2F; 使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%B7%B1%E6%8B%B7%E8%B4%9D-Deep-Clone-%E3%80%90%E6%8E%A8%E8%8D%90%E3%80%91"><span class="nav-text">2. 深拷贝 (Deep Clone) - 【推荐】</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-4-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">2.5.4 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F-Structural-Patterns"><span class="nav-text">3. 结构型模式 (Structural Patterns)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-Adapter-Pattern"><span class="nav-text">3.1 适配器模式 (Adapter Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">3.1.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">3.1.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">3.1.3 实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8-Object-Adapter-%E3%80%90%E6%9E%81%E5%8A%9B%E6%8E%A8%E8%8D%90%E3%80%91"><span class="nav-text">1. 对象适配器 (Object Adapter) - 【极力推荐】</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8-Class-Adapter"><span class="nav-text">2. 类适配器 (Class Adapter)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">3.1.4 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F-Decorator-Pattern"><span class="nav-text">3.2 装饰器模式 (Decorator Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">3.2.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">3.2.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-text">3.2.3 实现方式（经典结构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-%E4%B8%8E%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-text">3.2.4 与适配器模式的对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-5-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">3.2.5 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-Proxy-Pattern"><span class="nav-text">3.3 代理模式 (Proxy Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">3.3.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">3.3.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E6%8C%89%E6%8E%A8%E8%8D%90%E5%BA%A6%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="nav-text">3.3.3 实现方式（按推荐度排序）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-Dynamic-Proxy-%E3%80%90%E6%9E%81%E5%8A%9B%E6%8E%A8%E8%8D%90%E3%80%91"><span class="nav-text">1. 动态代理 (Dynamic Proxy) - 【极力推荐】</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-Static-Proxy"><span class="nav-text">2. 静态代理 (Static Proxy)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">3.3.4 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F-Facade-Pattern"><span class="nav-text">3.4 外观模式 (Facade Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">3.4.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">3.4.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-text">3.4.3 实现方式（经典结构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-4-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="nav-text">3.4.4 外观模式的优点与缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-5-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">3.4.5 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-Bridge-Pattern"><span class="nav-text">3.5 桥接模式 (Bridge Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">3.5.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">3.5.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-text">3.5.3 实现方式（经典结构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-4-%E4%B8%8E%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-text">3.5.4 与适配器模式的对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-5-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">3.5.5 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-Composite-Pattern"><span class="nav-text">3.6 组合模式 (Composite Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">3.6.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">3.6.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-text">3.6.3 实现方式（经典结构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-4-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">3.6.4 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F-Flyweight-Pattern"><span class="nav-text">3.7 享元模式 (Flyweight Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">3.7.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">3.7.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-text">3.7.3 实现方式（经典结构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-4-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="nav-text">3.7.4 享元模式的优点与缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-5-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">3.7.5 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-Behavioral-Patterns"><span class="nav-text">4. 行为型模式 (Behavioral Patterns)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-Strategy-Pattern"><span class="nav-text">4.1 策略模式 (Strategy Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">4.1.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">4.1.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-text">4.1.3 实现方式（经典结构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-4-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">4.1.4 实际解决问题 &#x2F; 使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-5-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-vs-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="nav-text">4.1.5 策略模式 vs 状态模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-Template-Method-Pattern"><span class="nav-text">4.2 模板方法模式 (Template Method Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">4.2.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">4.2.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-text">4.2.3 实现方式（经典结构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-4-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">4.2.4 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-Observer-Pattern"><span class="nav-text">4.3 观察者模式 (Observer Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">4.3.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">4.3.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-text">4.3.3 实现方式（经典结构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-4-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">4.3.4 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F-Chain-of-Responsibility-Pattern"><span class="nav-text">4.4 责任链模式 (Chain of Responsibility Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">4.4.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">4.4.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-text">4.4.3 实现方式（经典结构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-4-%E7%BA%AF%E4%B8%8E%E4%B8%8D%E7%BA%AF%E7%9A%84%E8%B4%A3%E4%BB%BB%E9%93%BE"><span class="nav-text">4.4.4 纯与不纯的责任链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-5-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">4.4.5 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-Command-Pattern"><span class="nav-text">4.5 命令模式 (Command Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">4.5.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">4.5.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-text">4.5.3 实现方式（经典结构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-4-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">4.5.4 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F-Iterator-Pattern"><span class="nav-text">4.6 迭代器模式 (Iterator Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">4.6.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">4.6.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-text">4.6.3 实现方式（经典结构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-4-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">4.6.4 实际解决问题 &#x2F; 使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-5-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9AFail-Fast%E6%9C%BA%E5%88%B6"><span class="nav-text">4.6.5 迭代器模式的注意事项：Fail-Fast机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F-Mediator-Pattern"><span class="nav-text">4.7 中介者模式 (Mediator Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">4.7.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">4.7.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-text">4.7.3 实现方式（经典结构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-4-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F-vs-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-text">4.7.4 中介者模式 vs 观察者模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-5-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">4.7.5 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F-Memento-Pattern"><span class="nav-text">4.8 备忘录模式 (Memento Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">4.8.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">4.8.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-text">4.8.3 实现方式（经典结构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-8-4-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">4.8.4 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-9-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F-State-Pattern"><span class="nav-text">4.9 状态模式 (State Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-9-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">4.9.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-9-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">4.9.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-9-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-text">4.9.3 实现方式（经典结构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-9-4-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F-vs-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="nav-text">4.9.4 状态模式 vs 策略模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-9-5-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">4.9.5 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-10-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F-Visitor-Pattern"><span class="nav-text">4.10 访问者模式 (Visitor Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-10-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">4.10.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-10-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">4.10.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-10-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-text">4.10.3 实现方式（经典结构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-10-4-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">4.10.4 访问者模式的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-10-5-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">4.10.5 适用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-10-6-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">4.10.6 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-11-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F-Interpreter-Pattern"><span class="nav-text">4.11 解释器模式 (Interpreter Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-11-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">4.11.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-11-2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">4.11.2 主要作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-11-3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-text">4.11.3 实现方式（经典结构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-11-4-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">4.11.4 解释器模式的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-11-5-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">4.11.5 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%8E%B0%E4%BB%A3Java%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E6%A8%A1%E5%BC%8F"><span class="nav-text">5. 现代Java开发中的其他重要模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F-Concurrency-Patterns"><span class="nav-text">5.1 并发编程模式 (Concurrency Patterns)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-Future-Promise%E6%A8%A1%E5%BC%8F-CompletableFuture"><span class="nav-text">5.1.1 Future &#x2F; Promise模式 (CompletableFuture)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">1. 核心思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%A5%BD%E5%A4%84"><span class="nav-text">2. 主要作用与好处</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%A0%B8%E5%BF%83%E7%94%A8%E6%B3%95%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">3. 核心用法与代码示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">4. 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F-BlockingQueue"><span class="nav-text">5.1.2 生产者-消费者模式 (BlockingQueue)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-1"><span class="nav-text">1. 核心思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Java%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%A9%E5%99%A8%EF%BC%9ABlockingQueue"><span class="nav-text">2. Java中的实现利器：BlockingQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">3. 代码示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-text">4. 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A8%A1%E5%BC%8F-ExecutorService"><span class="nav-text">5.1.3 线程池模式 (ExecutorService)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-2"><span class="nav-text">1. 核心思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Java%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9AExecutor-%E6%A1%86%E6%9E%B6"><span class="nav-text">2. Java中的实现：Executor 框架</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-ThreadPoolExecutor-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="nav-text">3. ThreadPoolExecutor 的核心参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">4. 代码示例：手动创建并使用线程池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB%E5%9E%8B-%E9%80%9A%E8%BF%87Executors%E5%B7%A5%E5%8E%82%E5%88%9B%E5%BB%BA"><span class="nav-text">5. 常见的线程池类型 (通过Executors工厂创建)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">6. 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-%E8%AF%BB%E5%86%99%E9%94%81%E6%A8%A1%E5%BC%8F-ReadWriteLock"><span class="nav-text">5.1.4 读写锁模式 (ReadWriteLock)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-3"><span class="nav-text">1. 核心思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Java%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9AReadWriteLock-%E6%8E%A5%E5%8F%A3"><span class="nav-text">2. Java中的实现：ReadWriteLock 接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="nav-text">3. 代码示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E9%94%81%E7%9A%84%E5%8D%87%E9%99%8D%E7%BA%A7"><span class="nav-text">4. 锁的升降级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">5. 适用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E4%BC%81%E4%B8%9A%E7%BA%A7%E4%B8%8E%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F-Enterprise-Architectural-Patterns"><span class="nav-text">5.2 企业级与架构模式 (Enterprise &amp; Architectural Patterns)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-MVC%E6%A8%A1%E5%BC%8F-Model-View-Controller"><span class="nav-text">5.2.1 MVC模式 (Model-View-Controller)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-text">1. 核心组成部分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">2. 工作流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-MVC%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-text">3. MVC模式的优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-MVC%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%98%E4%BD%93"><span class="nav-text">4. MVC模式的变体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-Spring-MVC"><span class="nav-text">5. Spring MVC</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-DAO%E6%A8%A1%E5%BC%8F-Data-Access-Object"><span class="nav-text">5.2.2 DAO模式 (Data Access Object)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-4"><span class="nav-text">1. 核心思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8"><span class="nav-text">2. 主要作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-DAO%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-text">3. DAO模式的组成部分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%9C%A8%E7%8E%B0%E4%BB%A3Java%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="nav-text">4. 在现代Java框架中的演进</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3-%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F-Null-Object-Pattern"><span class="nav-text">5.2.3 空对象模式 (Null Object Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-5"><span class="nav-text">1. 核心思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8-1"><span class="nav-text">2. 主要作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BB%8F%E5%85%B8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-text">3. 实现方式（经典结构）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E4%B8%8EJava-8-Optional-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-text">4. 与Java 8 Optional 的对比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">5. 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-4-%E7%86%94%E6%96%AD%E5%99%A8%E6%A8%A1%E5%BC%8F-Circuit-Breaker-Pattern"><span class="nav-text">5.2.4 熔断器模式 (Circuit Breaker Pattern)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-6"><span class="nav-text">1. 核心思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%86%94%E6%96%AD%E5%99%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-text">2. 熔断器的三种状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%A5%BD%E5%A4%84"><span class="nav-text">3. 主要作用与好处</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-Java%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">4. Java中的实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E5%AE%9E%E9%99%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-text">5. 实际解决问题 &#x2F; 使用场景</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/31/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%B4%A8%E9%87%8F/%E4%B8%80%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="设计模式 | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          设计模式
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-31 11:52:28" itemprop="dateCreated datePublished" datetime="2025-10-31T11:52:28+08:00">2025-10-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-11-01 10:01:08" itemprop="dateModified" datetime="2025-11-01T10:01:08+08:00">2025-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%B4%A8%E9%87%8F/" itemprop="url" rel="index"><span itemprop="name">软件工程与质量</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="一、设计模式"><a href="#一、设计模式" class="headerlink" title="一、设计模式"></a>一、设计模式</h1><h2 id="1-基础篇"><a href="#1-基础篇" class="headerlink" title="1. 基础篇"></a>1. 基础篇</h2><h3 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h3><h4 id="1-1-1-软件设计的“复杂度”问题"><a href="#1-1-1-软件设计的“复杂度”问题" class="headerlink" title="1.1.1 软件设计的“复杂度”问题"></a>1.1.1 软件设计的“复杂度”问题</h4><p>作为软件工程师，我们日常工作的核心就是对抗<strong>复杂度 (Complexity)</strong>。一个软件系统从最初简单的“Hello World”到承载百万用户访问的企业级应用，其复杂度是呈指数级增长的。</p>
<p>这种复杂度并非仅仅指代码行数的增加，它体现在多个维度：</p>
<ul>
<li><strong>需求的不确定性 (Uncertainty of Requirements):</strong> 客户的需求总是在变化，今天的功能明天可能就要修改或废弃。如何设计一个能够“拥抱变化”的系统？</li>
<li><strong>系统规模的膨胀 (Expansion of System Scale):</strong> 随着业务增长，代码量、模块数、服务数越来越多，模块间的依赖关系错综复杂，最终可能演变成一个难以维护的“屎山”。</li>
<li><strong>团队协作的困难 (Difficulty in Team Collaboration):</strong> 不同的开发者有不同的编码习惯和思路。如果没有统一的规范和蓝图，代码将变得五花八门，新成员难以快速上手，最终导致“牵一发而动全身”的窘境。</li>
<li><strong>技术的快速迭代 (Rapid Iteration of Technology):</strong> 新的框架、新的语言特性层出不穷。如何让我们的系统设计不被某个特定技术栈过度绑定，保持其生命力？</li>
</ul>
<p><strong>失控的复杂度</strong>是软件项目的头号杀手，它会导致开发效率低下、Bug频出、维护成本高昂，最终使项目走向失败。而<strong>优秀的软件设计</strong>，其根本目的就是<strong>管理和控制复杂度</strong>。</p>
<hr>
<h4 id="1-1-2-前人经验的结晶"><a href="#1-1-2-前人经验的结晶" class="headerlink" title="1.1.2 前人经验的结晶"></a>1.1.2 前人经验的结晶</h4><p>我们遇到的设计难题，前人大多也遇到过。在数十年的软件工程实践中，大师们发现，对于一些反复出现的特定问题，总有一些通用且优雅的解决方案。</p>
<p>他们将这些**“问题-场景-解决方案”<strong>提炼、归纳并命名，就形成了</strong>设计模式 (Design Patterns)**。</p>
<p>可以这样理解设计模式：</p>
<ul>
<li><strong>它不是具体的代码，而是解决问题的“思路”或“模板”。</strong> 就像菜谱，它告诉你做宫保鸡丁需要哪些食材、步骤和火候，但不会规定你必须用哪个牌子的酱油。</li>
<li><strong>它是工程师之间沟通的“行话”和“黑话”。</strong> 当你说“这里用一个策略模式”，团队成员立刻就能明白你的意图，而无需你费力地画图解释类之间的复杂关系。这极大地提高了沟通效率。</li>
<li><strong>它是站在巨人的肩膀上。</strong> 这些模式都是经过了大量项目检验的、被证明是行之有效的“最佳实践”。学习它们，可以让我们避免重蹈覆覆辙，少走很多弯路。</li>
</ul>
<p>1994年，Erich Gamma, Richard Helm, Ralph Johnson 和 John Vlissides 四位作者（被后世尊称为**“四人帮” Gang of Four, GoF**）出版了《设计模式：可复用面向对象软件的基础》一书，系统地整理了23种经典的设计模式，为现代软件设计奠定了基石。</p>
<hr>
<h4 id="1-1-3-学习设计模式的好处"><a href="#1-1-3-学习设计模式的好处" class="headerlink" title="1.1.3 学习设计模式的好处"></a>1.1.3 学习设计模式的好处</h4><ol>
<li><strong>提升代码质量（编码层面）：</strong><ul>
<li><strong>可维护性 (Maintainability):</strong> 设计模式的核心目标之一就是解耦，让模块职责单一、关系清晰。这样的代码在需求变更时，修改起来更容易，也更不容易引入新的Bug。</li>
<li><strong>可扩展性 (Extensibility):</strong> 遵循开闭原则，你的代码将更容易在不修改原有代码的基础上增加新功能。例如，使用策略模式后，增加一种新的算法，只需要新增一个策略类，而无需改动核心逻辑。</li>
<li><strong>可复用性 (Reusability):</strong> 模式化的组件更容易被抽象和复用在项目的不同地方，甚至不同的项目中。</li>
<li><strong>健壮性 (Robustness):</strong> 良好的设计结构能更好地处理异常和边界情况，使系统更加稳定。</li>
</ul>
</li>
<li><strong>提升沟通效率（团队层面）：</strong><ul>
<li>拥有了共同的设计词汇，无论是Code Review、技术方案评审还是日常讨论，你都能和同事在同一个频道上高效交流。</li>
</ul>
</li>
<li><strong>提升技术视野（思维层面）：</strong><ul>
<li><strong>看透优秀框架的底层逻辑：</strong> 你会发现，你日常使用的Spring、MyBatis、JDK源码等，内部充满了设计模式的应用。<ul>
<li>Spring的IoC容器是<strong>工厂模式</strong>和<strong>单例模式</strong>的集大成者。</li>
<li>Spring AOP的实现离不开<strong>代理模式</strong>。</li>
<li><code>JDBCTemplate</code> 完美诠释了<strong>模板方法模式</strong>。</li>
<li>MyBatis的<code>SqlSessionFactory</code>构建过程是典型的<strong>建造者模式</strong>。</li>
</ul>
</li>
<li>理解了这些模式，你就不再是简单地“使用”框架，而是能真正“理解”其设计思想，从而更好地利用它，甚至在出现问题时能更快地定位。</li>
</ul>
</li>
<li><strong>助力职业发展（个人层面）：</strong><ul>
<li>设计能力是区分初级工程师和高级&#x2F;资深工程师的关键分水岭。</li>
<li>在技术面试中，设计模式是考察候选人软件设计能力和技术深度的必考题。</li>
<li>它能让你在面对复杂业务需求时，不再是上来就写<code>if-else</code>，而是能从更高维度思考，设计出更优雅、更具弹性的架构。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-2-设计模式的七大原则（SOLID-2）"><a href="#1-2-设计模式的七大原则（SOLID-2）" class="headerlink" title="1.2 设计模式的七大原则（SOLID + 2）"></a>1.2 设计模式的七大原则（SOLID + 2）</h3><h4 id="1-2-1-S-单一职责原则-Single-Responsibility-Principle-SRP"><a href="#1-2-1-S-单一职责原则-Single-Responsibility-Principle-SRP" class="headerlink" title="1.2.1 S - 单一职责原则 (Single Responsibility Principle, SRP)"></a>1.2.1 S - 单一职责原则 (Single Responsibility Principle, SRP)</h4><ul>
<li><p><strong>核心思想：</strong> 一个类或模块只应该有一个引起它变更的原因。</p>
</li>
<li><p><strong>通俗解读：</strong> 一个类只负责一件事。如果一个类承担了多个职责，当其中一个职责发生变化时，可能会影响到其他职责的实现，导致代码脆弱、难以维护。这就像一个工具，一把锤子就只应该用来敲钉子，如果它还想当螺丝刀用，那它两个功能都做不好。</p>
</li>
<li><p><strong>Java中的体现与反例：</strong></p>
<ul>
<li><p><strong>反例：</strong> 一个<code>UserService</code>类，既负责用户信息的CRUD（职责一：数据持久化），又负责生成用户报表并导出为PDF（职责二：业务报表），还负责向用户发送邮件（职责三：通知）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Anti-pattern</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(User user)</span> &#123; <span class="comment">/*...DB操作...*/</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span> &#123; <span class="comment">/*...DB操作...*/</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateUserReportPdf</span><span class="params">()</span> &#123; <span class="comment">/*...报表逻辑 + PDF生成逻辑...*/</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendWelcomeEmail</span><span class="params">(User user)</span> &#123; <span class="comment">/*...邮件发送逻辑...*/</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>问题：</em> 修改邮件发送逻辑（比如换一个邮件服务商），需要改动<code>UserService</code>；修改报表格式，也需要改动<code>UserService</code>。这个类变得非常臃肿，且任何一处改动都有可能影响到其他看似无关的功能。</p>
</li>
<li><p><strong>正例：</strong> 将职责拆分到不同的类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good practice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepository</span> &#123; <span class="comment">// 职责：用户数据访问</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserReportService</span> &#123; <span class="comment">// 职责：用户报表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] generateUserReportPdf() &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> &#123; <span class="comment">// 职责：邮件通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendWelcomeEmail</span><span class="params">(User user)</span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>目的与好处：</strong> 降低类的复杂度，提高类的可读性和可维护性，降低变更引起的风险。<strong>高内聚、低耦合</strong>的体现。</p>
</li>
</ul>
<hr>
<h4 id="1-2-2-O-开闭原则-Open-Closed-Principle-OCP"><a href="#1-2-2-O-开闭原则-Open-Closed-Principle-OCP" class="headerlink" title="1.2.2 O - 开闭原则 (Open-Closed Principle, OCP)"></a>1.2.2 O - 开闭原则 (Open-Closed Principle, OCP)</h4><ul>
<li><p><strong>核心思想：</strong> 软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。</p>
</li>
<li><p><strong>通俗解读：</strong> 当需要增加新功能时，我们应该通过<strong>增加新代码</strong>的方式来实现，而不是去<strong>修改已有的、稳定的代码</strong>。这就像你的笔记本电脑，你可以通过USB接口（开放的扩展点）插入各种设备（鼠标、键盘），而不需要拆开电脑外壳去修改内部的主板（关闭修改）。</p>
</li>
<li><p><strong>Java中的体现与反例：</strong></p>
<ul>
<li><p><strong>反例：</strong> 根据不同的支付方式进行打折，使用<code>if-else</code>实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Anti-pattern</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateDiscount</span><span class="params">(String paymentType, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;WeChatPay&quot;</span>.equals(paymentType)) &#123;</span><br><span class="line">            <span class="keyword">return</span> amount * <span class="number">0.95</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;AliPay&quot;</span>.equals(paymentType)) &#123;</span><br><span class="line">            <span class="keyword">return</span> amount * <span class="number">0.98</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果要新增一种&quot;BankCardPay&quot;，就必须修改这里的代码！</span></span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>正例：</strong> 使用策略模式（Strategy Pattern）来实现。定义一个支付策略接口，每种支付方式实现该接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good practice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">calculateDiscount</span><span class="params">(<span class="type">double</span> amount)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeChatPayStrategy</span> <span class="keyword">implements</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateDiscount</span><span class="params">(<span class="type">double</span> amount)</span> &#123; <span class="keyword">return</span> amount * <span class="number">0.95</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliPayStrategy</span> <span class="keyword">implements</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateDiscount</span><span class="params">(<span class="type">double</span> amount)</span> &#123; <span class="keyword">return</span> amount * <span class="number">0.98</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当需要新增&quot;BankCardPay&quot;时，只需新增一个类，完全不用修改原有代码。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankCardPayStrategy</span> <span class="keyword">implements</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateDiscount</span><span class="params">(<span class="type">double</span> amount)</span> &#123; <span class="keyword">return</span> amount * <span class="number">0.9</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>目的与好处：</strong> 提高系统的可扩展性和可维护性，是许多设计模式（如策略模式、装饰器模式）要达成的终极目标。</p>
</li>
</ul>
<hr>
<h4 id="1-2-3-L-里氏替换原则-Liskov-Substitution-Principle-LSP"><a href="#1-2-3-L-里氏替换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="1.2.3 L - 里氏替换原则 (Liskov Substitution Principle, LSP)"></a>1.2.3 L - 里氏替换原则 (Liskov Substitution Principle, LSP)</h4><ul>
<li><p><strong>核心思想：</strong> 所有引用基类的地方必须能透明地使用其子类的对象。</p>
</li>
<li><p><strong>通俗解读：</strong> 子类应该可以完全替换掉它的父类，并且程序行为不会产生任何错误或异常。简单说就是：<strong>“子类必须是父类”</strong>。子类可以有自己的“个性”（新方法），但不能改变父类已有的“共性”（重写的方法行为要符合父类预期）。一个经典的例子就是“正方形不是长方形”。</p>
</li>
<li><p><strong>Java中的体现与反例：</strong></p>
<ul>
<li><p><strong>反例：</strong> <code>Square</code>继承<code>Rectangle</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Anti-pattern</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> width;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">int</span> width)</span> &#123; <span class="built_in">this</span>.width = width; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> height)</span> &#123; <span class="built_in">this</span>.height = height; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="comment">// 为了维持正方形的特性，重写了父类方法，改变了其行为</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">int</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        <span class="built_in">this</span>.height = width; <span class="comment">// 破坏了父类setWidth只影响width的约定</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = height;</span><br><span class="line">        <span class="built_in">this</span>.height = height; <span class="comment">// 破坏了父类setHeight只影响height的约定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Rectangle r)</span> &#123;</span><br><span class="line">    r.setWidth(<span class="number">10</span>);</span><br><span class="line">    r.setHeight(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 程序员期望 r 的面积是 10 * 20 = 200</span></span><br><span class="line">    <span class="comment">// 但如果传入的是一个Square对象，面积会是 20 * 20 = 400，行为不符合预期！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>目的与好处：</strong> 保证继承的正确性，是实现开闭原则的重要方式之一。它约束了继承的滥用，让类层次结构更加健壮。</p>
</li>
</ul>
<hr>
<h4 id="1-2-4-I-接口隔离原则-Interface-Segregation-Principle-ISP"><a href="#1-2-4-I-接口隔离原则-Interface-Segregation-Principle-ISP" class="headerlink" title="1.2.4 I - 接口隔离原则 (Interface Segregation Principle, ISP)"></a>1.2.4 I - 接口隔离原则 (Interface Segregation Principle, ISP)</h4><ul>
<li><p><strong>核心思想：</strong> 客户端不应该被强迫依赖它所不需要的接口。</p>
</li>
<li><p><strong>通俗解读：</strong> 不应该设计“胖接口”（Fat Interface），而应该将大接口拆分成多个更小、更具体的接口。这样，客户端只需要关心与它相关的接口即可。</p>
</li>
<li><p><strong>Java中的体现与反例：</strong></p>
<ul>
<li><p><strong>反例：</strong> 一个巨大的<code>IAnimal</code>接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Anti-pattern</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IAnimal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Dog类被迫实现它根本不会的fly()和swim()方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">IAnimal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>正例：</strong> 将接口拆分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good practice</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Eatable</span> &#123; <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123; <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Swimmable</span> &#123; <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Eatable</span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">implements</span> <span class="title class_">Eatable</span>, Flyable &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">implements</span> <span class="title class_">Eatable</span>, Swimmable &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>目的与好处：</strong> 降低耦合度，提高内聚性，接口更清晰，系统更灵活。</p>
</li>
</ul>
<hr>
<h4 id="1-2-5-D-依赖倒置原则-Dependency-Inversion-Principle-DIP"><a href="#1-2-5-D-依赖倒置原则-Dependency-Inversion-Principle-DIP" class="headerlink" title="1.2.5 D - 依赖倒置原则 (Dependency Inversion Principle, DIP)"></a>1.2.5 D - 依赖倒置原则 (Dependency Inversion Principle, DIP)</h4><ul>
<li><p><strong>核心思想：</strong></p>
<ol>
<li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象。</li>
<li>抽象不应该依赖于细节，细节应该依赖于抽象。</li>
</ol>
</li>
<li><p><strong>通俗解读：</strong> 这句话的核心是**“面向接口编程”**，而不是“面向实现编程”。高层模块（比如业务逻辑 <code>Service</code>）定义它需要什么（接口），而低层模块（比如数据访问 <code>MySQLDAO</code>）去实现这个接口。这样，高层模块就不再关心低层模块的具体实现，只关心接口。依赖关系从 <code>Service -&gt; MySQLDAO</code> “倒置” 成了 <code>Service -&gt; IDAO &lt;- MySQLDAO</code>。</p>
</li>
<li><p><strong>Java中的体现与反例：</strong></p>
<ul>
<li><p><strong>反例：</strong> 业务层直接依赖具体的数据访问类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Anti-pattern</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">MySqlDatabase</span> <span class="variable">db</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySqlDatabase</span>(); <span class="comment">// 直接依赖具体实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submitOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        db.save(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>问题：</em> 如果要换成Oracle数据库，必须修改<code>OrderService</code>的源码。</p>
</li>
<li><p><strong>正例：</strong> 业务层依赖接口，通过依赖注入（DI）传入具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good practice</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IDatabase</span> &#123; <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Order order)</span>; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySqlDatabase</span> <span class="keyword">implements</span> <span class="title class_">IDatabase</span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OracleDatabase</span> <span class="keyword">implements</span> <span class="title class_">IDatabase</span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IDatabase db; <span class="comment">// 依赖于抽象接口</span></span><br><span class="line">    <span class="comment">// 构造函数注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(IDatabase db)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.db = db;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submitOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        db.save(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这就是Spring IoC/DI容器的核心思想</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>目的与好处：</strong> 解耦，使系统更具弹性，更容易扩展和测试（可以方便地注入Mock对象）。</p>
</li>
</ul>
<hr>
<h4 id="1-2-6-迪米特法则-Law-of-Demeter-LoD-最少知识原则"><a href="#1-2-6-迪米特法则-Law-of-Demeter-LoD-最少知识原则" class="headerlink" title="1.2.6 迪米特法则 (Law of Demeter, LoD) &#x2F; 最少知识原则"></a>1.2.6 迪米特法则 (Law of Demeter, LoD) &#x2F; 最少知识原则</h4><ul>
<li><p><strong>核心思想：</strong> 一个对象应该对其他对象有最少的了解。只与你的“直接朋友”交谈。</p>
<blockquote>
<p>Talk only to your immediate friends.</p>
</blockquote>
</li>
<li><p><strong>通俗解读：</strong> 在一个类中，应该尽量减少对其他类内部细节的访问。如果需要调用一个陌生对象的方法，最好通过你的“朋友”（成员变量、方法参数等）去间接调用，而不是通过一长串的<code>get</code>方法链。例如 <code>a.getB().getC().doSomething()</code> 这种代码就严重违反了迪米特法则。</p>
</li>
<li><p><strong>Java中的体现与反例：</strong></p>
<ul>
<li><p><strong>反例：</strong> <code>Boss</code>需要让<code>TeamLeader</code>去检查课程数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Anti-pattern</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boss</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkCourses</span><span class="params">(TeamLeader leader)</span> &#123;</span><br><span class="line">        <span class="comment">// Boss知道了TeamLeader有Course，Course有List，然后自己去获取size</span></span><br><span class="line">        <span class="comment">// 这条调用链暴露了太多内部结构</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">courseCount</span> <span class="operator">=</span> leader.getCourse().getCourseList().size();</span><br><span class="line">        System.out.println(<span class="string">&quot;课程数量：&quot;</span> + courseCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>正例：</strong> <code>TeamLeader</code>提供一个直接的方法，封装内部逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good practice</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TeamLeader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Course course;</span><br><span class="line">    <span class="comment">// TeamLeader自己负责清点，并直接返回结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCourseCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> course.getCourseList().size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boss</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkCourses</span><span class="params">(TeamLeader leader)</span> &#123;</span><br><span class="line">        <span class="comment">// Boss只跟直接朋友TeamLeader交流，不关心课程是怎么被统计的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">courseCount</span> <span class="operator">=</span> leader.getCourseCount();</span><br><span class="line">        System.out.println(<span class="string">&quot;课程数量：&quot;</span> + courseCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>目的与好处：</strong> 降低类之间的耦合度，当一个类的内部实现修改时，不会波及到太多其他类，增强了系统的健壮性。</p>
</li>
</ul>
<hr>
<h4 id="1-2-7-合成复用原则-Composite-Reuse-Principle-CRP"><a href="#1-2-7-合成复用原则-Composite-Reuse-Principle-CRP" class="headerlink" title="1.2.7 合成复用原则 (Composite Reuse Principle, CRP)"></a>1.2.7 合成复用原则 (Composite Reuse Principle, CRP)</h4><ul>
<li><p><strong>核心思想：</strong> 尽量使用对象组合&#x2F;聚合，而不是继承来达到复用的目的。</p>
</li>
<li><p><strong>通俗解读：</strong> 当想复用一个类的功能时，优先考虑将这个类的对象作为新类的一个成员变量（<strong>has-a</strong>关系），而不是让新类去继承它（<strong>is-a</strong>关系）。</p>
</li>
<li><p><strong>为什么？</strong></p>
<ul>
<li>继承是“白盒复用”，子类与父类的耦合度很高，父类的任何改动都会影响子类。</li>
<li>组合是“黑盒复用”，新类只通过接口与成员对象交互，耦合度低。</li>
<li>Java是单继承，继承了一个类就不能再继承其他类了，而组合则没有这个限制。</li>
</ul>
</li>
<li><p><strong>Java中的体现与反例：</strong></p>
<ul>
<li><p><strong>反例：</strong> 使用继承来为<code>ArrayList</code>添加计数功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Anti-pattern</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountingArrayList</span> <span class="keyword">extends</span> <span class="title class_">ArrayList</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        count += c.size();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... getCount()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>问题：</em> <code>ArrayList</code>的父类<code>AbstractList</code>中，<code>addAll</code>方法是循环调用<code>add</code>方法的。这样会导致<code>count</code>被重复计算，出现bug。这就是“白盒”复用的脆弱性。</p>
</li>
<li><p><strong>正例：</strong> 使用组合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good practice</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountingList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 组合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        count += c.size();</span><br><span class="line">        list.addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 其他需要委托的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>优势：</em> 内部实现完全由自己控制，不会受<code>ArrayList</code>内部实现变化的影响。</p>
</li>
</ul>
</li>
<li><p><strong>目的与好处：</strong> 提高系统的灵活性和可维护性，降低类与类之间的耦合。</p>
</li>
</ul>
<hr>
<h2 id="2-创建型模式-Creational-Patterns"><a href="#2-创建型模式-Creational-Patterns" class="headerlink" title="2. 创建型模式 (Creational Patterns)"></a>2. 创建型模式 (Creational Patterns)</h2><ul>
<li><strong>核心关注点：</strong> <strong>对象的创建过程。</strong></li>
<li><strong>一句话总结：</strong> 这类模式将对象的创建与使用过程解耦，使得系统在不知道对象具体如何创建、由谁创建的情况下，依然可以灵活地使用这些对象。</li>
<li><strong>通俗比喻：</strong> 就像去**“智能工厂”**买电脑。<ul>
<li><strong>过去（不用模式）：</strong> 你需要自己去买CPU、主板、内存、硬盘（<code>new CPU()</code>, <code>new Motherboard()</code>…），然后自己组装。这个过程非常繁琐，而且一旦某个零件（具体类）换了型号，你就得重新学习组装。</li>
<li><strong>现在（使用创建型模式）：</strong> 你只需要告诉工厂的接待员（<strong>工厂模式</strong>）你想要一台“游戏型电脑”。你不需要关心里面用的是Intel还是AMD的CPU，用的是金士顿还是三星的内存。工厂内部的流水线（<strong>建造者模式</strong>）会帮你搞定一切复杂的组装过程，最后直接给你一台完整的电脑。如果你想要一台一模一样的备用机，工厂可以直接“克隆”一台（<strong>原型模式</strong>）。而整个工厂的管理系统，要确保全公司只有一个总调度中心（<strong>单例模式</strong>）。</li>
</ul>
</li>
<li><strong>解决什么问题？</strong><ul>
<li>让对象的创建过程更加灵活，而不是在代码里到处硬编码 <code>new ConcreteClass()</code>。</li>
<li>隐藏复杂对象的创建逻辑和装配细节。</li>
<li>确保某个类在系统中只有一个实例，并提供全局访问点。</li>
</ul>
</li>
</ul>
<h3 id="2-1-单例模式-Singleton-Pattern"><a href="#2-1-单例模式-Singleton-Pattern" class="headerlink" title="2.1 单例模式 (Singleton Pattern)"></a>2.1 单例模式 (Singleton Pattern)</h3><h4 id="2-1-1-核心思想"><a href="#2-1-1-核心思想" class="headerlink" title="2.1.1 核心思想"></a>2.1.1 核心思想</h4><p><strong>保证一个类在整个应用程序的生命周期中，只有一个实例存在，并提供一个全局统一的访问点来获取这个唯一的实例。</strong></p>
<p>简单来说，就是三点：</p>
<ol>
<li><strong>构造函数私有化 (private constructor)</strong>：防止外部通过 <code>new</code> 关键字随意创建对象。</li>
<li><strong>内部持有静态实例 (private static instance)</strong>：类内部自己创建一个实例。</li>
<li><strong>提供公共静态方法 (public static method)</strong>：暴露一个全局访问点，让外部获取这个唯一的实例。</li>
</ol>
<hr>
<h4 id="2-1-2-主要作用"><a href="#2-1-2-主要作用" class="headerlink" title="2.1.2 主要作用"></a>2.1.2 主要作用</h4><p>单例模式主要用于解决一个全局使用的类被频繁地创建和销毁，从而带来性能和资源浪费的问题。</p>
<ol>
<li><strong>资源共享与控制：</strong> 确保所有对象共享同一个资源实例，方便进行统一管理和控制，例如数据库连接池、线程池。</li>
<li><strong>性能优化：</strong> 避免了对一个频繁使用的对象进行重复的创建和销毁，特别是对于那些创建成本很高的“重量级”对象，可以显著提高性能。</li>
<li><strong>确保唯一性：</strong> 在某些业务场景下，逻辑上要求某个对象必须是唯一的，例如全局配置管理器、唯一序列号生成器、网站计数器等。</li>
</ol>
<h4 id="2-1-3-实现方式（按推荐度排序）"><a href="#2-1-3-实现方式（按推荐度排序）" class="headerlink" title="2.1.3 实现方式（按推荐度排序）"></a>2.1.3 实现方式（按推荐度排序）</h4><h5 id="1-枚举（Enum）-【极力推荐】"><a href="#1-枚举（Enum）-【极力推荐】" class="headerlink" title="1. 枚举（Enum）- 【极力推荐】"></a>1. 枚举（Enum）- <strong>【极力推荐】</strong></h5><p>这是《Effective Java》作者 Joshua Bloch 极力推崇的方式。它不仅写法最简洁，而且能天然地防止反射和反序列化攻击，是实现单例的最佳方法。</p>
<ul>
<li><p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE; <span class="comment">// 唯一的枚举实例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以添加普通方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton by Enum is doing something.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用方式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Singleton.INSTANCE.doSomething();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点：</strong></p>
<ul>
<li><strong>线程安全：</strong> JVM从底层保证枚举实例的创建是线程安全的。</li>
<li><strong>防止反序列化创建新对象：</strong> 枚举的反序列化是由JVM特殊处理的，保证了实例的唯一性。</li>
<li><strong>防止反射攻击：</strong> 无法通过反射来构造一个新的枚举实例。</li>
<li><strong>代码简洁：</strong> 实现简单，可读性高。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-静态内部类（Static-Inner-Class）-【推荐】"><a href="#2-静态内部类（Static-Inner-Class）-【推荐】" class="headerlink" title="2. 静态内部类（Static Inner Class）- 【推荐】"></a>2. 静态内部类（Static Inner Class）- <strong>【推荐】</strong></h5><p>这种方式兼顾了懒加载的性能优势和线程安全，写法优雅，是实际开发中非常流行的一种方式。</p>
<ul>
<li><p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125; <span class="comment">// 构造函数私有</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类，只有在第一次调用getInstance()时才会被加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点：</strong></p>
<ul>
<li><strong>懒加载（Lazy Loading）：</strong> 只有当<code>getInstance()</code>方法被第一次调用时，<code>SingletonHolder</code>类才会被加载，从而实例化<code>INSTANCE</code>。</li>
<li><strong>线程安全：</strong> 类的加载过程是由JVM保证的线程安全的，所以<code>INSTANCE</code>的创建过程也是线程安全的，无需使用<code>synchronized</code>。</li>
<li><strong>实现简单：</strong> 代码清晰，没有锁的开销。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-双重检查锁定（Double-Checked-Locking-DCL）"><a href="#3-双重检查锁定（Double-Checked-Locking-DCL）" class="headerlink" title="3. 双重检查锁定（Double-Checked Locking, DCL）"></a>3. 双重检查锁定（Double-Checked Locking, DCL）</h5><p>这是一种经典的懒加载线程安全实现，在面试中经常被问到。它试图在懒加载的基础上，通过减少同步代码块的范围来提高性能。</p>
<ul>
<li><p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// volatile是关键！禁止指令重排序，保证可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第一次检查：避免不必要的同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 第二次检查：防止多个线程同时进入同步块</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">// 这不是一个原子操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意要点：</strong></p>
<ul>
<li><strong><code>volatile</code>关键字是必须的！</strong> 因为 <code>instance = new Singleton()</code> 这行代码在JVM中不是原子操作，它大致分为三步：1. 分配内存空间；2. 初始化对象；3. 将<code>instance</code>引用指向分配的内存地址。如果没有<code>volatile</code>，指令重排序可能导致一个线程拿到一个未完全初始化的对象。</li>
</ul>
</li>
<li><p><strong>优点：</strong> 实现了懒加载，且在实例已经创建后，后续的调用不会进入同步块，性能较高。</p>
</li>
<li><p><strong>缺点：</strong> 写法相对复杂，容易出错（忘记<code>volatile</code>）。</p>
</li>
</ul>
<hr>
<h5 id="4-饿汉式（Eager-Initialization）"><a href="#4-饿汉式（Eager-Initialization）" class="headerlink" title="4. 饿汉式（Eager Initialization）"></a>4. 饿汉式（Eager Initialization）</h5><p>在类加载时就立即创建实例，简单直接，天生线程安全。</p>
<ul>
<li><p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 类加载时就创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点：</strong></p>
<ul>
<li><strong>线程安全：</strong> 类加载机制保证了实例创建的线程安全。</li>
<li><strong>实现简单。</strong></li>
</ul>
</li>
<li><p><strong>缺点：</strong></p>
<ul>
<li><strong>非懒加载：</strong> 无论是否使用该实例，它都会在类加载时被创建，如果实例创建成本高或占用内存大，可能会造成资源浪费。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-4-实际解决问题-使用场景"><a href="#2-1-4-实际解决问题-使用场景" class="headerlink" title="2.1.4 实际解决问题 &#x2F; 使用场景"></a>2.1.4 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><strong>JDK中的应用：</strong><ul>
<li><code>java.lang.Runtime.getRuntime()</code>：每个Java应用程序都有一个<code>Runtime</code>类的唯一实例，用于与JVM运行时环境交互。它使用的就是<strong>饿汉式</strong>单例。</li>
</ul>
</li>
<li><strong>Spring框架中的应用：</strong><ul>
<li>Spring容器中管理的Bean（组件）<strong>默认就是单例模式</strong>。当你在类上使用<code>@Service</code>, <code>@Repository</code>, <code>@Component</code>等注解时，Spring IoC容器在启动时会为这个类创建一个唯一的实例，并将其放入“单例池”中。后续任何地方通过<code>@Autowired</code>注入的都是这同一个实例。这极大地体现了单例模式资源复用和统一管理的核心思想。</li>
</ul>
</li>
<li><strong>常用业务场景：</strong><ul>
<li><strong>全局配置类：</strong> 一个类负责读取<code>application.properties</code>或<code>application.yml</code>文件，并将其内容保存在内存中，供系统各处使用。这个配置类就非常适合做成单例。</li>
<li><strong>数据库连接池&#x2F;线程池：</strong> 整个应用共享一个连接池或线程池，避免资源的重复创建和销毁。虽然我们通常直接使用如<code>HikariCP</code>, <code>ThreadPoolExecutor</code>等框架，但它们内部的设计思想就遵循了单例或类似的管理模式。</li>
<li><strong>日志框架：</strong> 如Log4j、Logback中的<code>Logger</code>对象，通常也是通过一个工厂以类似单例的方式来管理和获取的，以确保对同一个类的日志记录器是同一个实例。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-2-工厂方法模式-Factory-Method-Pattern"><a href="#2-2-工厂方法模式-Factory-Method-Pattern" class="headerlink" title="2.2 工厂方法模式 (Factory Method Pattern)"></a>2.2 工厂方法模式 (Factory Method Pattern)</h3><p>工厂方法模式也称为<strong>工厂模式 (Factory Pattern)</strong> 或 <strong>虚拟构造器 (Virtual Constructor)</strong>。</p>
<h4 id="2-2-1-核心思想"><a href="#2-2-1-核心思想" class="headerlink" title="2.2.1 核心思想"></a>2.2.1 核心思想</h4><p><strong>定义一个用于创建对象的接口（即工厂方法），但将实际的实例化决策延迟到子类中。</strong></p>
<p>换句话说，基类（抽象工厂）只规定了“必须生产某种产品”，但不关心“具体生产哪种产品”。具体生产哪种产品，由它的子类（具体工厂）来决定。这完美地符合了<strong>开闭原则</strong>。</p>
<hr>
<h4 id="2-2-2-主要作用"><a href="#2-2-2-主要作用" class="headerlink" title="2.2.2 主要作用"></a>2.2.2 主要作用</h4><ol>
<li><strong>解耦创建者与具体产品：</strong> 客户端代码只需要与抽象工厂和抽象产品交互，完全不需要知道具体产品的类名，也不知道产品是如何被创建的。这大大降低了耦合度。</li>
<li><strong>增强系统的可扩展性：</strong> 当需要增加一个新的产品时，只需要增加一个对应的具体产品类和一个对应的具体工厂类即可，无需修改任何现有的代码（包括客户端代码和抽象工厂代码），使得系统扩展非常容易。</li>
<li><strong>封装产品创建细节：</strong> 每个具体工厂类封装了创建对应产品的复杂逻辑（比如初始化、依赖注入等），使得客户端代码更加简洁。</li>
</ol>
<hr>
<h4 id="2-2-3-实现方式（经典结构）"><a href="#2-2-3-实现方式（经典结构）" class="headerlink" title="2.2.3 实现方式（经典结构）"></a>2.2.3 实现方式（经典结构）</h4><p>工厂方法模式通常包含四个核心角色：</p>
<ol>
<li><strong>Product (抽象产品)：</strong> 定义了工厂方法所创建的对象的接口。</li>
<li><strong>ConcreteProduct (具体产品)：</strong> 实现 <code>Product</code> 接口，是工厂方法创建的目标实例。</li>
<li><strong>Creator (抽象工厂)：</strong> 声明一个或多个工厂方法 <code>factoryMethod()</code>，其返回类型是 <code>Product</code> 接口。<code>Creator</code> 也可以定义一个默认的工厂方法实现。</li>
<li><strong>ConcreteCreator (具体工厂)：</strong> 重写 <code>Creator</code> 中的工厂方法，返回一个具体的 <code>ConcreteProduct</code> 实例。</li>
</ol>
<p><strong>代码示例：模拟不同品牌的咖啡店制作咖啡</strong></p>
<p>假设我们有一个咖啡店的业务，不同的店生产不同风味的咖啡。</p>
<p><strong>1. 定义抽象产品 (Product)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品：咖啡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 定义具体产品 (ConcreteProduct)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体产品A：美式咖啡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Americano</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Americano&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B：拿铁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Latte</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Latte&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 定义抽象工厂 (Creator)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂：咖啡店</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoffeeShop</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个业务方法，它依赖于工厂方法来获取产品</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> createCoffee(); <span class="comment">// 调用工厂方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---A cup of &quot;</span> + coffee.getName() + <span class="string">&quot; is ready!---&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象的工厂方法，由子类实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 定义具体工厂 (ConcreteCreator)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体工厂A：专门生产美式咖啡的店</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanoCoffeeShop</span> <span class="keyword">extends</span> <span class="title class_">CoffeeShop</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Americano</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂B：专门生产拿铁的店</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffeeShop</span> <span class="keyword">extends</span> <span class="title class_">CoffeeShop</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Latte</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 客户端使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 我想喝美式咖啡，所以我去了专门做美式咖啡的店</span></span><br><span class="line">        <span class="type">CoffeeShop</span> <span class="variable">americanoShop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmericanoCoffeeShop</span>();</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">americano</span> <span class="operator">=</span> americanoShop.orderCoffee();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=============================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我今天想换口味，喝拿铁，所以我去了专门做拿铁的店</span></span><br><span class="line">        <span class="type">CoffeeShop</span> <span class="variable">latteShop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LatteCoffeeShop</span>();</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">latte</span> <span class="operator">=</span> latteShop.orderCoffee();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时如果需要新增一种“卡布奇诺”，只需增加Cappuccino类和CappuccinoCoffeeShop类，</span></span><br><span class="line">        <span class="comment">// Client端的代码完全不需要修改，只需在需要时 new CappuccinoCoffeeShop() 即可。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// ---A cup of Americano is ready!---</span></span><br><span class="line"><span class="comment">// =============================</span></span><br><span class="line"><span class="comment">// ---A cup of Latte is ready!---</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-4-实际解决问题-使用场景"><a href="#2-2-4-实际解决问题-使用场景" class="headerlink" title="2.2.4 实际解决问题 &#x2F; 使用场景"></a>2.2.4 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><strong>JDK中的应用：<code>java.util.Collection</code> 的 <code>iterator()</code> 方法</strong><ul>
<li><code>Collection</code> 接口扮演了<strong>抽象工厂 (Creator)</strong> 的角色。</li>
<li><code>iterator()</code> 方法就是<strong>工厂方法</strong>，它返回一个 <code>Iterator</code> (抽象产品)。</li>
<li><code>ArrayList</code>, <code>LinkedList</code>, <code>HashSet</code> 等具体集合类扮演了<strong>具体工厂 (ConcreteCreator)</strong> 的角色。</li>
<li>它们各自实现了自己的 <code>iterator()</code> 方法，返回了针对自身数据结构优化的、具体的 <code>Iterator</code> 实现（如 <code>ArrayList</code> 的 <code>Itr</code>，<code>LinkedList</code> 的 <code>ListItr</code>）。</li>
<li>作为使用者，我们只需要调用 <code>list.iterator()</code>，完全不需要关心它返回的到底是哪种迭代器，但我们知道它一定能用。</li>
</ul>
</li>
<li><strong>日志框架中的应用：SLF4J (Simple Logging Facade for Java)</strong><ul>
<li><code>org.slf4j.LoggerFactory</code> 类可以看作是一个工厂。</li>
<li>它的 <code>getLogger(String name)</code> 方法就是一个工厂方法。</li>
<li>你无需关心它背后到底是用 Log4j、Logback 还是 <code>java.util.logging</code> 来创建 <code>Logger</code> 实例。这个决策被推迟到了运行时，由 SLF4J 的绑定包（如<code>slf4j-log4j12.jar</code>）来决定。这使得切换底层日志实现变得极其简单，只需更换一个JAR包即可。</li>
</ul>
</li>
<li><strong>Spring框架中的应用：<code>BeanFactory</code></strong><ul>
<li>Spring 的 <code>BeanFactory</code> 接口（以及其子接口 <code>ApplicationContext</code>），其核心职责就是生产和管理 Bean。<code>getBean()</code> 方法就是最典型的工厂方法。你向工厂索要一个Bean，工厂会根据配置（XML, Annotation）返回一个具体的实例，而你无需关心这个Bean是如何被创建和装配的。</li>
</ul>
</li>
<li><strong>其他业务场景</strong><ul>
<li><strong>多数据源切换：</strong> 可以定义一个 <code>DataSourceFactory</code>，然后有 <code>MySqlDataSourceFactory</code>、<code>OracleDataSourceFactory</code> 等子类，根据配置返回不同的数据源对象。</li>
<li><strong>支付渠道选择：</strong> 定义一个 <code>PaymentFactory</code>，可以有 <code>AliPayFactory</code>、<code>WeChatPayFactory</code>，分别创建对应的支付处理器。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-3-抽象工厂模式-Abstract-Factory-Pattern"><a href="#2-3-抽象工厂模式-Abstract-Factory-Pattern" class="headerlink" title="2.3 抽象工厂模式 (Abstract Factory Pattern)"></a>2.3 抽象工厂模式 (Abstract Factory Pattern)</h3><p>抽象工厂模式是所有工厂模式中最为抽象和最具一般性的一种。它提供了一个创建<strong>一系列相关或相互依赖对象</strong>的接口，而无需指定它们具体的类。</p>
<h4 id="2-3-1-核心思想"><a href="#2-3-1-核心思想" class="headerlink" title="2.3.1 核心思想"></a>2.3.1 核心思想</h4><p><strong>为创建一组（或一个产品族）相互关联、相互依赖的对象提供一个统一的接口，客户端无需关心单个产品的具体实现。</strong></p>
<p>这个模式的关键在于**“产品族（Product Family）”**。与工厂方法模式只生产一个等级结构的产品不同，抽象工厂模式生产的是一整套产品。</p>
<ul>
<li><strong>产品族：</strong> 指的是位于不同产品等级结构中，但功能上相互关联，可以配套使用的一组产品。例如，“深色主题”产品族可能包含<code>DarkButton</code>, <code>DarkTextBox</code>, <code>DarkScrollBar</code>；“浅色主题”产品族可能包含<code>LightButton</code>, <code>LightTextBox</code>, <code>LightScrollBar</code>。</li>
<li><strong>产品等级：</strong> 指的是同一类型产品的不同实现。例如，<code>Button</code>是一个产品等级，它有<code>DarkButton</code>和<code>LightButton</code>等不同的实现。</li>
</ul>
<hr>
<h4 id="2-3-2-主要作用"><a href="#2-3-2-主要作用" class="headerlink" title="2.3.2 主要作用"></a>2.3.2 主要作用</h4><ol>
<li><strong>隔离具体类：</strong> 客户端代码只与抽象工厂和抽象产品接口打交道，完全从具体产品的创建和实现中解耦出来。</li>
<li><strong>保证产品兼容性：</strong> 核心优点。由于一个具体的工厂只生产属于同一个产品族的产品，这就从根本上保证了客户端无论如何使用，得到的都是配套的对象。例如，使用“深色主题工厂”，你绝不可能得到一个“浅色”的按钮，从而保证了UI风格的一致性。</li>
<li><strong>切换产品族方便：</strong> 当需要更换整个产品系列时，只需要更换具体的工厂实例即可，客户端代码无需做任何修改。这使得系统的配置和扩展变得非常灵活。</li>
</ol>
<hr>
<h4 id="2-3-3-实现方式（经典结构）"><a href="#2-3-3-实现方式（经典结构）" class="headerlink" title="2.3.3 实现方式（经典结构）"></a>2.3.3 实现方式（经典结构）</h4><p>抽象工厂模式通常包含以下角色：</p>
<ol>
<li><strong>AbstractFactory (抽象工厂)：</strong> 声明了一组用于创建不同抽象产品的方法（即<code>createProductA()</code>, <code>createProductB()</code>…）。</li>
<li><strong>ConcreteFactory (具体工厂)：</strong> 实现 <code>AbstractFactory</code> 的接口，负责创建具体的产品族。</li>
<li><strong>AbstractProduct (抽象产品)：</strong> 为产品族中的每一种产品定义接口。</li>
<li><strong>ConcreteProduct (具体产品)：</strong> 实现相应的 <code>AbstractProduct</code> 接口，是具体工厂创建的目标实例。</li>
<li><strong>Client (客户端)：</strong> 使用 <code>AbstractFactory</code> 和 <code>AbstractProduct</code> 接口来工作。</li>
</ol>
<p><strong>代码示例：模拟跨平台UI组件的创建（例如深色主题 vs 浅色主题）</strong></p>
<p><strong>1. 定义抽象产品 (AbstractProduct)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品A：按钮</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品B：文本框</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 定义具体产品 (ConcreteProduct)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// “浅色主题”产品族</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Displaying Light Theme Button.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Showing Light Theme TextField.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “深色主题”产品族</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DarkButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Displaying Dark Theme Button.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DarkTextField</span> <span class="keyword">implements</span> <span class="title class_">TextField</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Showing Dark Theme TextField.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 定义抽象工厂 (AbstractFactory)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂：定义了创建一套UI组件的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ThemeFactory</span> &#123;</span><br><span class="line">    Button <span class="title function_">createButton</span><span class="params">()</span>;</span><br><span class="line">    TextField <span class="title function_">createTextField</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 定义具体工厂 (ConcreteFactory)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体工厂A：用于创建浅色主题的组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightThemeFactory</span> <span class="keyword">implements</span> <span class="title class_">ThemeFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LightButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LightTextField</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂B：用于创建深色主题的组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DarkThemeFactory</span> <span class="keyword">implements</span> <span class="title class_">ThemeFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Button <span class="title function_">createButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DarkButton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TextField <span class="title function_">createTextField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DarkTextField</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 客户端使用 (Client)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设当前配置是使用深色主题</span></span><br><span class="line">        <span class="type">ThemeFactory</span> <span class="variable">darkFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DarkThemeFactory</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 客户端完全不知道自己用的是DarkButton还是LightButton，只知道它是一个Button</span></span><br><span class="line">        <span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> darkFactory.createButton();</span><br><span class="line">        <span class="type">TextField</span> <span class="variable">textField</span> <span class="operator">=</span> darkFactory.createTextField();</span><br><span class="line">        </span><br><span class="line">        button.display();</span><br><span class="line">        textField.show();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- Switching to Light Theme ---&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 现在只需要更换工厂，整个UI风格就随之改变，客户端代码完全不变</span></span><br><span class="line">        <span class="type">ThemeFactory</span> <span class="variable">lightFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightThemeFactory</span>();</span><br><span class="line">        button = lightFactory.createButton();</span><br><span class="line">        textField = lightFactory.createTextField();</span><br><span class="line"></span><br><span class="line">        button.display();</span><br><span class="line">        textField.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Displaying Dark Theme Button.</span></span><br><span class="line"><span class="comment">// Showing Dark Theme TextField.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// --- Switching to Light Theme ---</span></span><br><span class="line"><span class="comment">// Displaying Light Theme Button.</span></span><br><span class="line"><span class="comment">// Showing Light Theme TextField.</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-4-与工厂方法模式的对比"><a href="#2-3-4-与工厂方法模式的对比" class="headerlink" title="2.3.4 与工厂方法模式的对比"></a>2.3.4 与工厂方法模式的对比</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">工厂方法模式 (Factory Method)</th>
<th align="left">抽象工厂模式 (Abstract Factory)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>关注点</strong></td>
<td align="left">创建<strong>单个产品</strong>（一个产品等级结构）</td>
<td align="left">创建<strong>一族产品</strong>（多个产品等级结构）</td>
</tr>
<tr>
<td align="left"><strong>目的</strong></td>
<td align="left">将产品的实例化推迟到子类</td>
<td align="left">提供一个创建一系列相关对象的接口</td>
</tr>
<tr>
<td align="left"><strong>复杂度</strong></td>
<td align="left">相对简单</td>
<td align="left">相对复杂，类和接口数量较多</td>
</tr>
<tr>
<td align="left"><strong>开闭原则</strong></td>
<td align="left">扩展时，增加一个具体产品和一个具体工厂</td>
<td align="left">扩展时，增加一个完整的产品族和具体工厂</td>
</tr>
<tr>
<td align="left"><strong>比喻</strong></td>
<td align="left">一个品牌的咖啡店（只生产咖啡）</td>
<td align="left">一个主题的家具厂（生产桌子、椅子、床）</td>
</tr>
</tbody></table>
<p><strong>核心区别：</strong> 如果你只需要生产一种产品，比如“咖啡”，那么用工厂方法模式就够了。但如果你需要生产一个系列的产品，比如“咖啡”和配套的“甜点”，并且要求美式咖啡必须配芝士蛋糕，拿铁必须配提拉米苏，那么你就需要抽象工厂模式来保证这种“套餐”的正确性。</p>
<hr>
<h4 id="2-3-5-实际解决问题-使用场景"><a href="#2-3-5-实际解决问题-使用场景" class="headerlink" title="2.3.5 实际解决问题 &#x2F; 使用场景"></a>2.3.5 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><strong>JDBC中的应用（最经典案例）：</strong><ul>
<li><code>java.sql.Connection</code> 可以被看作是一个<strong>抽象工厂</strong>。</li>
<li><code>java.sql.Statement</code> 和 <code>java.sql.PreparedStatement</code> 是<strong>抽象产品</strong>。</li>
<li>当你通过<code>DriverManager.getConnection(&quot;jdbc:mysql://...&quot;)</code>获取到一个<code>MySQLConnection</code>实例（<strong>具体工厂</strong>）时，这个<code>connection</code>对象上的<code>createStatement()</code>和<code>prepareStatement()</code>方法，返回的必然是<code>MySQLStatementImpl</code>和<code>MySQLPreparedStatementImpl</code>（<strong>具体产品族</strong>）。</li>
<li>你永远不用担心一个MySQL的连接会创建出一个Oracle的Statement，抽象工厂模式保证了这种数据库操作组件的<strong>兼容性</strong>。</li>
</ul>
</li>
<li><strong>更换不同类型的数据库持久层：</strong><ul>
<li>假设系统需要支持MySQL、Oracle、SQL Server等多种数据库。</li>
<li>可以定义一个<code>IDaoFactory</code>（抽象工厂），它有<code>createUserDao()</code>和<code>createOrderDao()</code>方法。</li>
<li>然后分别实现<code>MySqlDaoFactory</code>, <code>OracleDaoFactory</code>等具体工厂。</li>
<li>在系统启动时，根据配置文件选择一个具体的工厂实例化。业务代码中所有的数据访问都通过这个工厂来获取DAO对象，从而实现与具体数据库的解耦。</li>
</ul>
</li>
<li><strong>多套UI主题&#x2F;皮肤切换：</strong><ul>
<li>正如上面的代码示例，在客户端应用（如Swing&#x2F;JavaFX）或Web应用中，通过切换不同的<code>ThemeFactory</code>，可以一键更换整个界面的视觉风格。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-4-建造者模式-Builder-Pattern"><a href="#2-4-建造者模式-Builder-Pattern" class="headerlink" title="2.4 建造者模式 (Builder Pattern)"></a>2.4 建造者模式 (Builder Pattern)</h3><p>建造者模式也称为<strong>生成器模式</strong>。</p>
<h4 id="2-4-1-核心思想"><a href="#2-4-1-核心思想" class="headerlink" title="2.4.1 核心思想"></a>2.4.1 核心思想</h4><p><strong>将一个复杂对象的构建过程与其最终表示相分离，使得同样的构建过程可以创建出不同的表示。</strong></p>
<p>这个定义听起来有点抽象，通俗地讲就是：当创建一个对象需要很多步骤，并且这些步骤的顺序或内容可能变化时，我们把“构建对象”这个任务，从对象本身分离出来，交给一个专门的“建造者”来一步一步地完成。客户端不再直接 <code>new</code> 一个复杂的对象，而是通过指挥这个建造者来得到最终的产品。</p>
<hr>
<h4 id="2-4-2-主要作用"><a href="#2-4-2-主要作用" class="headerlink" title="2.4.2 主要作用"></a>2.4.2 主要作用</h4><ol>
<li><strong>解决“伸缩构造函数（Telescoping Constructor）”问题：</strong> 当一个类有很多可选参数时，我们可能需要提供多个构造函数，例如 <code>User(String name)</code>, <code>User(String name, int age)</code>, <code>User(String name, int age, String address)</code>… 这种构造函数链非常丑陋且难以维护。</li>
<li><strong>提高代码可读性和可维护性：</strong> 使用建造者模式，每个参数的设置都有一个具名的方法，如 <code>.name(&quot;张三&quot;).age(30)</code>，代码像在读一个句子，一目了然。相比之下，<code>new User(&quot;张三&quot;, 30, &quot;xxx&quot;, null, null, true)</code> 这样的调用，没人知道 <code>null</code> 和 <code>true</code> 代表什么。</li>
<li><strong>支持创建不可变对象（Immutable Object）：</strong> 建造者模式是创建不可变对象的绝佳方式。我们可以在对象本身不提供任何 <code>setter</code> 方法，所有属性在 <code>build()</code> 方法中一次性设置并设为 <code>final</code>，从而保证对象在创建后状态不会被改变，这对于并发编程尤其重要。</li>
<li><strong>提供更灵活的构建控制：</strong> 可以在 <code>build()</code> 方法中加入复杂的校验逻辑，确保只有在所有参数都符合业务规则时，对象才能被成功创建。</li>
</ol>
<hr>
<h4 id="2-4-3-实现方式（按推荐度排序）"><a href="#2-4-3-实现方式（按推荐度排序）" class="headerlink" title="2.4.3 实现方式（按推荐度排序）"></a>2.4.3 实现方式（按推荐度排序）</h4><h5 id="1-Lombok-的-Builder-注解-【极力推荐】"><a href="#1-Lombok-的-Builder-注解-【极力推荐】" class="headerlink" title="1. Lombok 的 @Builder 注解 - 【极力推荐】"></a>1. Lombok 的 <code>@Builder</code> 注解 - <strong>【极力推荐】</strong></h5><p>在现代Java项目中，这是最简单、最流行、最高效的方式。只需一个注解，Lombok就会在编译期自动为你生成完整的建造者模式代码。</p>
<ul>
<li><p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String phone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用方式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> User.builder()</span><br><span class="line">                .name(<span class="string">&quot;Lisi&quot;</span>)</span><br><span class="line">                .age(<span class="number">25</span>)</span><br><span class="line">                .address(<span class="string">&quot;123 Main St&quot;</span>)</span><br><span class="line">                .phone(<span class="string">&quot;13800138000&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">System.out.println(user); </span><br><span class="line"><span class="comment">// 输出: User(name=Lisi, age=25, address=123 Main St, phone=13800138000)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点：</strong></p>
<ul>
<li><strong>零模板代码：</strong> 极其简洁，只需一个注解。</li>
<li><strong>功能齐全：</strong> 自动生成所有必要的建造者类、链式调用方法和 <code>build()</code> 方法。</li>
<li><strong>行业标准：</strong> 在大量项目中广泛使用，可读性和接受度非常高。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-静态内部类（Static-Inner-Class）-【经典且推荐】"><a href="#2-静态内部类（Static-Inner-Class）-【经典且推荐】" class="headerlink" title="2. 静态内部类（Static Inner Class） - 【经典且推荐】"></a>2. 静态内部类（Static Inner Class） - <strong>【经典且推荐】</strong></h5><p>这是手写建造者模式最经典、最常见的方式。理解这种方式有助于你理解Lombok背后的工作原理。</p>
<ul>
<li><p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="comment">// 最终产品是不可变的 (final)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String ram;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String storage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String gpu; <span class="comment">// 可选</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String powerSupply; <span class="comment">// 可选</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数私有，只能由Builder调用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Computer</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = builder.cpu;</span><br><span class="line">        <span class="built_in">this</span>.ram = builder.ram;</span><br><span class="line">        <span class="built_in">this</span>.storage = builder.storage;</span><br><span class="line">        <span class="built_in">this</span>.gpu = builder.gpu;</span><br><span class="line">        <span class="built_in">this</span>.powerSupply = builder.powerSupply;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部建造者类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="comment">// 拥有与外部类相同的字段，但不是final的</span></span><br><span class="line">        <span class="keyword">private</span> String cpu;       <span class="comment">// 必选</span></span><br><span class="line">        <span class="keyword">private</span> String ram;       <span class="comment">// 必选</span></span><br><span class="line">        <span class="keyword">private</span> String storage;   <span class="comment">// 必选</span></span><br><span class="line">        <span class="keyword">private</span> String gpu;       <span class="comment">// 可选</span></span><br><span class="line">        <span class="keyword">private</span> String powerSupply; <span class="comment">// 可选</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必选参数通过构造函数传入</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(String cpu, String ram, String storage)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">            <span class="built_in">this</span>.ram = ram;</span><br><span class="line">            <span class="built_in">this</span>.storage = storage;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可选参数通过链式方法设置，返回Builder自身</span></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">gpu</span><span class="params">(String gpu)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.gpu = gpu;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">powerSupply</span><span class="params">(String powerSupply)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.powerSupply = powerSupply;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build()方法创建最终的Computer实例</span></span><br><span class="line">        <span class="keyword">public</span> Computer <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 可以在这里添加校验逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (cpu == <span class="literal">null</span> || ram == <span class="literal">null</span> || storage == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;CPU, RAM, and Storage are required.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用方式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Computer</span> <span class="variable">gamingPC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>.Builder(<span class="string">&quot;Intel i9&quot;</span>, <span class="string">&quot;32GB&quot;</span>, <span class="string">&quot;1TB SSD&quot;</span>)</span><br><span class="line">                                 .gpu(<span class="string">&quot;NVIDIA RTX 4090&quot;</span>)</span><br><span class="line">                                 .powerSupply(<span class="string">&quot;850W&quot;</span>)</span><br><span class="line">                                 .build();</span><br><span class="line">System.out.println(gamingPC);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-4-4-实际解决问题-使用场景"><a href="#2-4-4-实际解决问题-使用场景" class="headerlink" title="2.4.4 实际解决问题 &#x2F; 使用场景"></a>2.4.4 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><p><strong>JDK中的应用：<code>StringBuilder</code> 和 <code>StringBuffer</code></strong></p>
<ul>
<li>这是最经典的建造者模式应用。<code>String</code> 对象是不可变的，每次拼接都会创建新对象，性能低下。<code>StringBuilder</code>（建造者）允许你通过 <code>append()</code> 方法高效地构建字符串，最后通过 <code>toString()</code> 方法（相当于 <code>build()</code>）得到最终的 <code>String</code> 对象。</li>
<li><code>new StringBuilder().append(&quot;Hello&quot;).append(&quot;, &quot;).append(&quot;World!&quot;).toString();</code></li>
</ul>
</li>
<li><p><strong>OkHttp库中的应用：<code>Request</code></strong></p>
<ul>
<li><p>构建一个HTTP请求通常需要设置URL、方法（GET&#x2F;POST）、请求头、请求体等多个部分。OkHttp的 <code>Request</code> 对象就是通过建造者模式创建的，代码非常清晰：</p>
</li>
<li><pre><code class="language-java">Request request = new Request.Builder()
.url(&quot;https://api.example.com/data&quot;)
.header(&quot;Authorization&quot;, &quot;Bearer token123&quot;)
.post(RequestBody.create(json, JSON_MEDIA_TYPE))
.build();
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. **MyBatis中的应用：`SqlSessionFactoryBuilder`**</span><br><span class="line"></span><br><span class="line">   - MyBatis中创建核心对象 `SqlSessionFactory` 的过程比较复杂，需要解析XML配置文件或编程式配置。`SqlSessionFactoryBuilder` 就扮演了建造者的角色，它接收一个输入流（配置文件），然后调用 `build()` 方法，为你构建出配置好的 `SqlSessionFactory` 实例。</span><br><span class="line"></span><br><span class="line">4. **Spring框架中的应用：`BeanDefinitionBuilder`**</span><br><span class="line"></span><br><span class="line">   - 在需要通过Java代码动态注册Bean到Spring容器时，可以使用 `BeanDefinitionBuilder`。它提供了一系列方法如 `addConstructorArgValue`、`addPropertyValue` 来分步配置Bean的定义信息，最后通过 `getBeanDefinition()` 方法生成最终的 `BeanDefinition` 对象。</span><br><span class="line"></span><br><span class="line">5. **日常开发中的DTO/VO/Entity**</span><br><span class="line"></span><br><span class="line">   - 任何属性较多（尤其是超过5个）的JavaBean，特别是那些希望被设计成不可变的数据传输对象（DTO），都强烈建议使用建造者模式来创建实例。</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">### 2.5 原型模式 (Prototype Pattern)</span><br><span class="line"></span><br><span class="line">#### 2.5.1 核心思想</span><br><span class="line"></span><br><span class="line">**通过复制一个已经存在的实例（即“原型”）来创建新的对象，而不是通过调用构造函数从头开始创建。**</span><br><span class="line"></span><br><span class="line">简单来说，就是不通过 `new` 关键字来创建对象，而是通过“克隆”一个模板对象来得到新对象。这个模板对象就是“原型”。</span><br><span class="line"></span><br><span class="line">****</span><br><span class="line"></span><br><span class="line">#### 2.5.2 主要作用</span><br><span class="line"></span><br><span class="line">1. **性能提升（核心优势）：** 当创建一个对象的过程非常耗时或耗费资源时（例如，需要复杂的计算、数据库查询、网络I/O等），原型模式可以显著提高性能。你只需要创建一个原型对象，后续需要新对象时，直接从内存中快速克隆，避免了重复的昂贵初始化过程。</span><br><span class="line">2. **简化对象创建：** 如果一个对象的创建需要复杂的权限或准备步骤，或者需要设置大量默认参数，使用原型模式可以封装这些复杂性。客户端只需找到一个已经配置好的原型，然后克隆它，再稍作修改即可。</span><br><span class="line">3. **解耦客户端与具体类：** 客户端可以不知道要创建的对象的具体类名，只需要通过一个管理器或注册表获取一个原型对象，然后调用其克隆方法即可。这在需要动态创建不同类型对象的场景下很有用。</span><br><span class="line"></span><br><span class="line">****</span><br><span class="line"></span><br><span class="line">#### 2.5.3 实现方式（关键：浅拷贝 vs 深拷贝）</span><br><span class="line"></span><br><span class="line">在Java中，实现原型模式通常需要实现 `Cloneable` 接口并重写 `Object` 类的 `clone()` 方法。但这里有一个至关重要的区别：</span><br><span class="line"></span><br><span class="line">- **浅拷贝 (Shallow Clone)：**</span><br><span class="line">  - **行为：** 只复制对象本身和其中的基本数据类型字段。对于引用类型的字段，只复制其**引用地址**，而不复制引用所指向的对象。</span><br><span class="line">  - **后果：** 克隆对象和原型对象中的引用类型字段将指向**同一个**堆内存中的对象。修改其中一个的引用对象，会影响到另一个。</span><br><span class="line">  - **适用场景：** 当对象的所有成员变量都是值类型（基本类型、`String`等不可变对象）时，浅拷贝就足够了。</span><br><span class="line">- **深拷贝 (Deep Clone)：**</span><br><span class="line">  - **行为：** 不仅复制对象本身，还会**递归地**复制其内部所有引用类型的字段所指向的对象，直到所有对象都被复制一份。</span><br><span class="line">  - **后果：** 克隆对象和原型对象是完全独立的，互不影响。</span><br><span class="line">  - **适用场景：** 当对象中包含可变的引用类型时，为了避免数据混淆，必须使用深拷贝。</span><br><span class="line"></span><br><span class="line">##### 1. 浅拷贝 (Shallow Clone) - 【基础实现】</span><br><span class="line"></span><br><span class="line">这是最简单的实现方式，只需实现`Cloneable`接口并调用`super.clone()`。</span><br><span class="line"></span><br><span class="line">- **实现代码：**</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  // 假设Email类是可变的</span><br><span class="line">  class Email &#123;</span><br><span class="line">      String content;</span><br><span class="line">      public Email(String content) &#123; this.content = content; &#125;</span><br><span class="line">      // ... getters and setters</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 实现Cloneable接口</span><br><span class="line">  public class User implements Cloneable &#123;</span><br><span class="line">      private String name;</span><br><span class="line">      private Email email; // 引用类型</span><br><span class="line">  </span><br><span class="line">      public User(String name, Email email) &#123;</span><br><span class="line">          this.name = name;</span><br><span class="line">          this.email = email;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // ... getters and setters</span><br><span class="line">  </span><br><span class="line">      @Override</span><br><span class="line">      protected User clone() throws CloneNotSupportedException &#123;</span><br><span class="line">          // super.clone() 执行的就是浅拷贝</span><br><span class="line">          return (User) super.clone();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>使用与问题演示：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Email</span> <span class="variable">email</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Email</span>(<span class="string">&quot;Initial content&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>, email);</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> user1.clone(); <span class="comment">// 浅拷贝</span></span><br><span class="line">user2.setName(<span class="string">&quot;Bob&quot;</span>); <span class="comment">// 修改基本类型，互不影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改引用类型字段的内容</span></span><br><span class="line">user2.getEmail().setContent(<span class="string">&quot;Modified content&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;User1: &quot;</span> + user1.getName() + <span class="string">&quot;, Email: &quot;</span> + user1.getEmail().getContent());</span><br><span class="line">System.out.println(<span class="string">&quot;User2: &quot;</span> + user2.getName() + <span class="string">&quot;, Email: &quot;</span> + user2.getEmail().getContent());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// User1: Alice, Email: Modified content  &lt;-- user1的Email内容被意外修改了！</span></span><br><span class="line"><span class="comment">// User2: Bob, Email: Modified content</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-深拷贝-Deep-Clone-【推荐】"><a href="#2-深拷贝-Deep-Clone-【推荐】" class="headerlink" title="2. 深拷贝 (Deep Clone) - 【推荐】"></a>2. 深拷贝 (Deep Clone) - 【推荐】</h5><p>为了解决浅拷贝的问题，我们需要实现深拷贝。</p>
<p><strong>方法A：递归调用<code>clone()</code></strong></p>
<p>如果所有引用类型都实现了<code>Cloneable</code>，可以递归调用它们的<code>clone()</code>方法。</p>
<ul>
<li><p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Email类也需要实现Cloneable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Email</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Email <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Email) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> User <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">// 1. 先进行浅拷贝，得到一个基本框架</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">clonedUser</span> <span class="operator">=</span> (User) <span class="built_in">super</span>.clone();</span><br><span class="line">        <span class="comment">// 2. 对引用类型字段进行单独的深拷贝</span></span><br><span class="line">        clonedUser.setEmail(<span class="built_in">this</span>.email.clone()); </span><br><span class="line">        <span class="keyword">return</span> clonedUser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法最符合<code>clone</code>的设计意图，但需要层层实现<code>Cloneable</code>，比较繁琐。</p>
</li>
</ul>
<p><strong>方法B：通过序列化实现（推荐的“偷懒”技巧）</strong></p>
<p>利用Java的序列化机制，将对象写入流中再读出来，得到的新对象就是一份深拷贝。</p>
<ul>
<li><p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有需要被深拷贝的类都要实现Serializable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Email</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123; <span class="comment">// 注意这里是Serializable</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Email email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">deepClone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 写入字节流</span></span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line">            oos.writeObject(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从字节流中读出</span></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(baos.toByteArray());</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bais);</span><br><span class="line">            <span class="keyword">return</span> (User) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法代码通用，无需关心内部有多少层引用，但性能开销比递归<code>clone</code>大，且所有相关类必须实现<code>Serializable</code>接口。</p>
</li>
</ul>
<hr>
<h4 id="2-5-4-实际解决问题-使用场景"><a href="#2-5-4-实际解决问题-使用场景" class="headerlink" title="2.5.4 实际解决问题 &#x2F; 使用场景"></a>2.5.4 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><strong>JDK中的应用：<code>java.util.ArrayList</code> 的 <code>clone()</code> 方法</strong><ul>
<li><code>ArrayList</code>的<code>clone()</code>方法是一个典型的<strong>浅拷贝</strong>。它会创建一个新的<code>ArrayList</code>实例，并复制一个新的内部数组。但是，数组中存储的<strong>元素本身</strong>并不会被克隆，新旧<code>ArrayList</code>将共享这些元素对象的引用。这在处理基本类型或不可变对象的列表时没问题，但处理可变对象列表时需要特别小心。</li>
</ul>
</li>
<li><strong>Spring框架中的应用：<code>scope=&quot;prototype&quot;</code> 的Bean</strong><ul>
<li>这是原型模式在现代框架中最常见的体现。当你在Spring中将一个Bean的作用域（scope）定义为<code>prototype</code>时，IoC容器就扮演了“原型管理器”的角色。</li>
<li>每次你从容器中请求（<code>getBean()</code>）这个Bean时，Spring都会为你创建一个<strong>新的实例</strong>，而不是返回一个共享的单例。虽然底层不一定是调用<code>clone()</code>方法（通常是通过反射调用构造函数），但其<strong>思想和目的</strong>与原型模式完全一致：基于一个“原型”定义（Bean Definition）来创建��的、独立的对象实例。</li>
<li><strong>适用场景：</strong> 对于那些有状态的、非线程安全的Bean（例如，记录每次请求信息的<code>Action</code>类），就必须使用<code>prototype</code>作用域。</li>
</ul>
</li>
<li><strong>业务场景：数据缓存与保护</strong><ul>
<li>从数据库或缓存中读取出一个“重量级”的数据对象后，将其作为原型保存在内存中。</li>
<li>当业务逻辑需要处理这个数据时，不直接操作原型对象（防止污染缓存），而是<strong>克隆一份副本</strong>交给业务层。这样业务层可以随意修改副本，而不会影响到缓存中的原始数据，保证了缓存的纯洁性和线程安全。</li>
</ul>
</li>
<li><strong>GUI编程中的应用：</strong><ul>
<li>在一个画图应用中，你可以创建一个“模板”形状（如一个配置好颜色、大小的圆），然后通过克隆这个模板来快速在画布上创建多个相同的圆。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-结构型模式-Structural-Patterns"><a href="#3-结构型模式-Structural-Patterns" class="headerlink" title="3. 结构型模式 (Structural Patterns)"></a>3. 结构型模式 (Structural Patterns)</h2><ul>
<li><strong>核心关注点：</strong> <strong>类与对象的组合与结构。</strong></li>
<li><strong>一句话总结：</strong> 这类模式探讨如何将类或对象组合成更大的、更复杂的结构，同时保持这个结构的灵活性和高效率。</li>
<li><strong>通俗比喻：</strong> 就像玩**“乐高积木 (LEGO)”**。<ul>
<li>你手头有很多不同形状和功能的积木块（类和对象）。</li>
<li>当你发现一个新买的特殊积木块插不进你现有的模型时，你可以找一个<strong>转接头</strong>（<strong>适配器模式</strong>）来连接它们。</li>
<li>你想给你的乐高小车加上一个酷炫的尾翼，但又不想改造小车本身，于是你找了一个可以“套”在小车外面的透明装饰件（<strong>装饰器模式</strong>）。</li>
<li>你搭建了一个非常复杂的城堡，但你不想让参观者看到里面乱七八糟的结构，于是你建了一个宏伟的<strong>正门</strong>（<strong>外观模式</strong>），所有人都从这个门进来参观指定路线。</li>
<li>你搭建了一棵树，树由树干和树枝组成，而树枝又由更小的树枝和叶子组成，它们都遵循统一的“组合”规则（<strong>组合模式</strong>）。</li>
</ul>
</li>
<li><strong>解决什么问题？</strong><ul>
<li>在不改变原有接口的情况下，为类增加新的功能。</li>
<li>将不兼容的接口组合在一起工作。</li>
<li>将多个对象组合成一个树形结构，以表示“部分-整体”的层次结构。</li>
<li>为复杂的子系统提供一个简单的统一入口。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-1-适配器模式-Adapter-Pattern"><a href="#3-1-适配器模式-Adapter-Pattern" class="headerlink" title="3.1 适配器模式 (Adapter Pattern)"></a>3.1 适配器模式 (Adapter Pattern)</h3><p>适配器模式也称为<strong>包装器 (Wrapper)</strong> 模式。它的作用就像一个生活中的“转接头”或“翻译官”。</p>
<h4 id="3-1-1-核心思想"><a href="#3-1-1-核心思想" class="headerlink" title="3.1.1 核心思想"></a>3.1.1 核心思想</h4><p><strong>将一个类的接口转换成客户端所期望的另一个接口，从而使得原本因接口不兼容而不能在一起工作的两个类可以协同工作。</strong></p>
<p>简单来说，适配器模式就是充当一个中间人的角色，它包装了一个已有的类（被适配者，Adaptee），并向外暴露一个符合系统标准的新接口（目标接口，Target）。客户端通过调用这个新接口来间接使用被适配者的功能。</p>
<hr>
<h4 id="3-1-2-主要作用"><a href="#3-1-2-主要作用" class="headerlink" title="3.1.2 主要作用"></a>3.1.2 主要作用</h4><ol>
<li><strong>复用现有代码：</strong> 当你有一个功能强大但接口不符合当前系统规范的类时，你无需修改这个类的源码（甚至可能无法修改，比如它是一个第三方库），通过适配器即可将其整合进系统。</li>
<li><strong>增强系统灵活性与兼容性：</strong> 使得系统可以与多个不兼容的外部组件或遗留系统协同工作。每引入一个新组件，只需为其创建一个新的适配器即可，而无需改动系统核心代码，符合开闭原则。</li>
<li><strong>统一接口：</strong> 当系统中存在多个功能相似但接口各异的子系统时，可以通过适配器将它们统一成一个相同的接口，使得客户端可以用同样的方式调用它们。</li>
</ol>
<hr>
<h4 id="3-1-3-实现方式"><a href="#3-1-3-实现方式" class="headerlink" title="3.1.3 实现方式"></a>3.1.3 实现方式</h4><p>适配器模式主要有两种实现方式：对象适配器和类适配器。</p>
<h5 id="1-对象适配器-Object-Adapter-【极力推荐】"><a href="#1-对象适配器-Object-Adapter-【极力推荐】" class="headerlink" title="1. 对象适配器 (Object Adapter) - 【极力推荐】"></a>1. 对象适配器 (Object Adapter) - <strong>【极力推荐】</strong></h5><p>这是最常用、最灵活的方式，它基于<strong>对象组合（Composition）</strong>。</p>
<ul>
<li><p><strong>工作原理：</strong> 适配器类 <code>Adapter</code> 实现目标接口 <code>Target</code>，并且内部持有一个被适配者 <code>Adaptee</code> 的实例。当客户端调用 <code>Adapter</code> 的方法时，<code>Adapter</code> 内部会把这个请求委托（Delegate）给 <code>Adaptee</code> 实例去处理。</p>
</li>
<li><p><strong>优点：</strong> 非常灵活。可以适配 <code>Adaptee</code> 的任何子类，因为 <code>Adaptee</code> 是以对象形式存在的。</p>
</li>
<li><p><strong>实现代码：模拟将220V电压转为5V手机充电电压</strong></p>
<p><strong>a. 被适配者 (Adaptee)：</strong> 现有的220V家用电源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PowerSource220V</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVoltage220V</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Providing 220V AC power.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">220</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>b. 目标接口 (Target)：</strong> 手机需要的5V直流电接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PowerTarget5V</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getVoltage5V</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>c. 适配器 (Adapter)：</strong> 手机充电头。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象适配器：实现目标接口，并持有被适配者对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PowerAdapter</span> <span class="keyword">implements</span> <span class="title class_">PowerTarget5V</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 组合（持有）一个被适配者对象</span></span><br><span class="line">    <span class="keyword">private</span> PowerSource220V powerSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PowerAdapter</span><span class="params">(PowerSource220V powerSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.powerSource = powerSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVoltage5V</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取220V电压</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">voltage220V</span> <span class="operator">=</span> powerSource.getVoltage220V();</span><br><span class="line">        <span class="comment">// 2. 进行“转换”处理</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">voltage5V</span> <span class="operator">=</span> voltage220V / <span class="number">44</span>; <span class="comment">// 简化处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Adapter: Converting 220V to &quot;</span> + voltage5V + <span class="string">&quot;V.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> voltage5V;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>d. 客户端使用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charge</span><span class="params">(PowerTarget5V power)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (power.getVoltage5V() == <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Phone is charging...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Warning: Unsafe voltage, cannot charge!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 我有一个手机，它需要5V电压</span></span><br><span class="line">        <span class="type">Phone</span> <span class="variable">myPhone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        <span class="comment">// 我只有一个220V的电源插座</span></span><br><span class="line">        <span class="type">PowerSource220V</span> <span class="variable">homePower</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PowerSource220V</span>();</span><br><span class="line">        <span class="comment">// 我用一个充电头（适配器）来连接它们</span></span><br><span class="line">        <span class="type">PowerTarget5V</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PowerAdapter</span>(homePower);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 手机成功充电</span></span><br><span class="line">        myPhone.charge(adapter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-类适配器-Class-Adapter"><a href="#2-类适配器-Class-Adapter" class="headerlink" title="2. 类适配器 (Class Adapter)"></a>2. 类适配器 (Class Adapter)</h5><p>这种方式基于<strong>类继承（Inheritance）</strong>。</p>
<ul>
<li><p><strong>工作原理：</strong> 适配器类 <code>Adapter</code> 同时继承被适配者类 <code>Adaptee</code> 和实现目标接口 <code>Target</code>。</p>
</li>
<li><p><strong>缺点：</strong> 不够灵活。由于Java的单继承机制，<code>Adapter</code> 只能继承一个 <code>Adaptee</code> 类，这限制了它的使用。同时，它将 <code>Adaptee</code> 的所有方法都暴露给了子类，可能破坏封装性。</p>
</li>
<li><p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类适配器：同时继承Adaptee和实现Target接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PowerAdapterClass</span> <span class="keyword">extends</span> <span class="title class_">PowerSource220V</span> <span class="keyword">implements</span> <span class="title class_">PowerTarget5V</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVoltage5V</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 直接调用父类（Adaptee）的方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">voltage220V</span> <span class="operator">=</span> <span class="built_in">super</span>.getVoltage220V(); </span><br><span class="line">        <span class="type">int</span> <span class="variable">voltage5V</span> <span class="operator">=</span> voltage220V / <span class="number">44</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Adapter: Converting 220V to &quot;</span> + voltage5V + <span class="string">&quot;V.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> voltage5V;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用方式与对象适配器完全相同，只是创建适配器时 <code>new PowerAdapterClass()</code> 即可。</p>
</li>
</ul>
<hr>
<h4 id="3-1-4-实际解决问题-使用场景"><a href="#3-1-4-实际解决问题-使用场景" class="headerlink" title="3.1.4 实际解决问题 &#x2F; 使用场景"></a>3.1.4 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><strong>JDK中的应用：<code>java.io.InputStreamReader</code></strong><ul>
<li>这是Java IO库中适配器模式最经典的案例。</li>
<li><strong>目标接口 (Target)：</strong> <code>Reader</code>，它是一个字符流，提供 <code>read(char cbuf[])</code> 方法。</li>
<li><strong>被适配者 (Adaptee)：</strong> <code>InputStream</code>，它是一个字节流，提供 <code>read(byte b[])</code> 方法。</li>
<li><code>InputStreamReader</code> 扮演<strong>适配器</strong>角色。它接收一个 <code>InputStream</code> 对象（对象适配器），并实现了 <code>Reader</code> 接口。其内部逻辑就是从 <code>InputStream</code> 读取字节，然后根据指定的字符集（如UTF-8）解码成字符，从而把字节流的功能适配成了字符流。</li>
</ul>
</li>
<li><strong>日志框架中的应用：SLF4J (Simple Logging Facade for Java)</strong><ul>
<li>SLF4J 本身定义了一套标准的日志接口（<code>org.slf4j.Logger</code>），这是<strong>目标接口</strong>。</li>
<li>而市面上有很多成熟的日志实现，如 Log4j、Logback、<code>java.util.logging</code> 等，它们的API各不相同，这些是<strong>被适配者</strong>。</li>
<li>SLF4J提供了诸如 <code>slf4j-log4j12.jar</code>、<code>log4j-slf4j-impl.jar</code> 这样的“桥接包”或“绑定包”，这些包里就包含了<strong>适配器</strong>类。这些适配器实现了SLF4J的<code>Logger</code>接口，但内部调用的是Log4j等具体日志框架的API。这使得我们的应用程序可以只依赖SLF4J的接口，而可以随时更换底层的日志实现。</li>
</ul>
</li>
<li><strong>Spring框架中的应用：<code>HandlerAdapter</code></strong><ul>
<li>在Spring MVC中，<code>DispatcherServlet</code> 需要调用各种类型的处理器（Handler）来处理请求，比如实现了 <code>Controller</code> 接口的类，或者使用了 <code>@RequestMapping</code> 注解的方法。</li>
<li><code>HandlerAdapter</code> 就是一个适配器接口。Spring为不同类型的Handler提供了不同的适配器实现（如 <code>RequestMappingHandlerAdapter</code>），<code>DispatcherServlet</code> 找到合适的 <code>HandlerAdapter</code> 后，由它去“适配”并执行真正的Handler。</li>
</ul>
</li>
<li><strong>日常开发：</strong><ul>
<li>当你需要集成一个第三方的SDK（如支付SDK、地图SDK）时，通常会编写一个适配器。这个适配器实现了你系统内部定义的标准接口（如 <code>PaymentService</code>），而其内部则封装了调用第三方SDK的复杂逻辑。这样做的好处是，如果将来更换支付渠道，只需更换或新增一个适配器，业务代码无需改动。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-2-装饰器模式-Decorator-Pattern"><a href="#3-2-装饰器模式-Decorator-Pattern" class="headerlink" title="3.2 装饰器模式 (Decorator Pattern)"></a>3.2 装饰器模式 (Decorator Pattern)</h3><p>装饰器模式也被称为<strong>包装器 (Wrapper)</strong> 模式，但注意它和适配器模式的包装在目的上有所不同。它的核心思想可以比喻为“给对象穿衣服”。</p>
<h4 id="3-2-1-核心思想"><a href="#3-2-1-核心思想" class="headerlink" title="3.2.1 核心思想"></a>3.2.1 核心思想</h4><p><strong>在不改变原有对象结构和功能的前提下，动态地给一个对象添加一些额外的功能。</strong></p>
<p>就增加功能而言，装饰器模式比生成子类（继承）更为灵活。它允许你在运行时（而不是编译时）根据需要，像搭积木一样，将一个或多个功能叠加到一个对象上。</p>
<hr>
<h4 id="3-2-2-主要作用"><a href="#3-2-2-主要作用" class="headerlink" title="3.2.2 主要作用"></a>3.2.2 主要作用</h4><ol>
<li><strong>遵循开闭原则（OCP）：</strong> 它是OCP的最佳实践之一。你可以通过新增装饰器类来为系统添加新功能，而完全不需要修改现有的核心组件代码或已有的装饰器代码。</li>
<li><strong>避免“类爆炸”问题：</strong> 如果使用继承来组合功能，每增加一个新功能，可能需要派生出大量子类来覆盖所有可能的组合。例如，一个饮料可以加冰、加糖、加奶。用继承实现就需要 <code>饮料</code>、<code>加冰饮料</code>、<code>加糖饮料</code>、<code>加冰加糖饮料</code>… 组合会急剧增多。而使用装饰器，你只需要 <code>饮料</code>、<code>加冰装饰器</code>、<code>加糖装饰器</code>，然后动态组合它们。</li>
<li><strong>职责分离：</strong> 每个装饰器类只负责一项特定的功能，职责清晰，符合单一职责原则。</li>
</ol>
<hr>
<h4 id="3-2-3-实现方式（经典结构）"><a href="#3-2-3-实现方式（经典结构）" class="headerlink" title="3.2.3 实现方式（经典结构）"></a>3.2.3 实现方式（经典结构）</h4><p>装饰器模式的结构非常独特，它要求装饰器和被装饰对象实现同一个接口。</p>
<ol>
<li><strong>Component (组件接口)：</strong> 定义了被装饰对象和装饰器对象的共同接口。</li>
<li><strong>ConcreteComponent (具体组件)：</strong> 定义了被装饰的原始对象，它实现了 <code>Component</code> 接口。这是我们要“穿衣服”的对象。</li>
<li><strong>Decorator (抽象装饰器)：</strong><ul>
<li>它也实现了 <code>Component</code> 接口。</li>
<li>它内部<strong>持有（组合）一个 <code>Component</code> 对象的引用</strong>。</li>
<li>它的方法实现通常是直接调用被包装的 <code>Component</code> 对象的方法。</li>
</ul>
</li>
<li><strong>ConcreteDecorator (具体装饰器)：</strong> 继承自 <code>Decorator</code>，负责向 <code>Component</code> 对象添加新的职责。它在调用父类（即被包装对象）方法的前后，加上自己的增强逻辑。</li>
</ol>
<p><strong>代码示例：制作一杯可以动态加料的咖啡</strong></p>
<p><strong>1. Component (组件接口)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件接口：定义了咖啡的基础功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. ConcreteComponent (具体组件)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体组件：一杯简单的黑咖啡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffee</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Simple Coffee&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. Decorator (抽象装饰器)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象装饰器：持有Coffee引用，并实现Coffee接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoffeeDecorator</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Coffee wrappedCoffee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CoffeeDecorator</span><span class="params">(Coffee coffee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.wrappedCoffee = coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 将价格计算委托给被包装的对象</span></span><br><span class="line">        <span class="keyword">return</span> wrappedCoffee.getCost(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 将描述获取委托给被包装的对象</span></span><br><span class="line">        <span class="keyword">return</span> wrappedCoffee.getDescription();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. ConcreteDecorator (具体装饰器)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体装饰器A：加奶</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MilkDecorator</span> <span class="keyword">extends</span> <span class="title class_">CoffeeDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MilkDecorator</span><span class="params">(Coffee coffee)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在原价基础上加上奶的钱</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getCost() + <span class="number">3.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在原有描述后加上奶的描述</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDescription() + <span class="string">&quot;, with Milk&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰器B：加糖</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SugarDecorator</span> <span class="keyword">extends</span> <span class="title class_">CoffeeDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SugarDecorator</span><span class="params">(Coffee coffee)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getCost() + <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDescription() + <span class="string">&quot;, with Sugar&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 客户端使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeShop</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 先来一杯最基础的咖啡</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">myCoffee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleCoffee</span>();</span><br><span class="line">        System.out.println(myCoffee.getDescription() + <span class="string">&quot; costs $&quot;</span> + myCoffee.getCost());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 动态地给它加点奶</span></span><br><span class="line">        myCoffee = <span class="keyword">new</span> <span class="title class_">MilkDecorator</span>(myCoffee);</span><br><span class="line">        System.out.println(myCoffee.getDescription() + <span class="string">&quot; costs $&quot;</span> + myCoffee.getCost());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 再动态地加点糖</span></span><br><span class="line">        myCoffee = <span class="keyword">new</span> <span class="title class_">SugarDecorator</span>(myCoffee);</span><br><span class="line">        System.out.println(myCoffee.getDescription() + <span class="string">&quot; costs $&quot;</span> + myCoffee.getCost());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 也可以一次性套娃</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- One-time creation ---&quot;</span>);</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">anotherCoffee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SugarDecorator</span>(<span class="keyword">new</span> <span class="title class_">MilkDecorator</span>(<span class="keyword">new</span> <span class="title class_">SimpleCoffee</span>()));</span><br><span class="line">        System.out.println(anotherCoffee.getDescription() + <span class="string">&quot; costs $&quot;</span> + anotherCoffee.getCost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Simple Coffee costs $10.0</span></span><br><span class="line"><span class="comment">// Simple Coffee, with Milk costs $13.0</span></span><br><span class="line"><span class="comment">// Simple Coffee, with Milk, with Sugar costs $14.0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// --- One-time creation ---</span></span><br><span class="line"><span class="comment">// Simple Coffee, with Milk, with Sugar costs $14.0</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-4-与适配器模式的对比"><a href="#3-2-4-与适配器模式的对比" class="headerlink" title="3.2.4 与适配器模式的对比"></a>3.2.4 与适配器模式的对比</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">装饰器模式 (Decorator)</th>
<th align="left">适配器模式 (Adapter)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>意图</strong></td>
<td align="left"><strong>增加</strong>或<strong>增强</strong>一个对象的功能</td>
<td align="left"><strong>转换</strong>一个不兼容的接口为另一个兼容的接口</td>
</tr>
<tr>
<td align="left"><strong>接口关系</strong></td>
<td align="left">装饰器和被装饰者实现<strong>同一个</strong>接口</td>
<td align="left">适配器实现<strong>目标</strong>接口，并包装<strong>被适配</strong>接口</td>
</tr>
<tr>
<td align="left"><strong>比喻</strong></td>
<td align="left">穿衣服，一层层增加功能</td>
<td align="left">转接头、翻译官，改变接口形式</td>
</tr>
</tbody></table>
<hr>
<h4 id="3-2-5-实际解决问题-使用场景"><a href="#3-2-5-实际解决问题-使用场景" class="headerlink" title="3.2.5 实际解决问题 &#x2F; 使用场景"></a>3.2.5 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><p><strong>JDK中的应用：<code>java.io</code> 类库（最经典案例）</strong></p>
<ul>
<li><p><strong>Component:</strong> <code>InputStream</code></p>
</li>
<li><p><strong>ConcreteComponent:</strong> <code>FileInputStream</code>, <code>ByteArrayInputStream</code> 等，它们是真正的数据源。</p>
</li>
<li><p><strong>Decorator:</strong> <code>FilterInputStream</code> (抽象装饰器)，它持有一个<code>InputStream</code>。</p>
</li>
<li><p><strong>ConcreteDecorator:</strong></p>
<ul>
<li><code>BufferedInputStream</code>: 增加了<strong>缓冲功能</strong>，提高读写效率。</li>
<li><code>DataInputStream</code>: 增加了<strong>读取基本数据类型</strong>的功能（如 <code>readInt()</code>, <code>readDouble()</code>）。</li>
<li><code>GZIPInputStream</code>: 增加了<strong>解压缩</strong>功能。</li>
</ul>
</li>
<li><p>经典的“套娃”式用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从文件读取 -&gt; 增加缓冲 -&gt; 增加按基本类型读取的功能</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(</span><br><span class="line">                     <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;myFile.txt&quot;</span>)</span><br><span class="line">                     )</span><br><span class="line">                 );</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>MyBatis中的应用：<code>Cache</code> 接口</strong></p>
<ul>
<li>MyBatis的二级缓存机制就大量使用了装饰器模式。</li>
<li><strong>Component:</strong> <code>org.apache.ibatis.cache.Cache</code></li>
<li><strong>ConcreteComponent:</strong> <code>PerpetualCache</code> 是一个基础的、永不过期的缓存实现。</li>
<li><strong>ConcreteDecorator:</strong><ul>
<li><code>LruCache</code>: 增加了**最近最少使用（LRU）**的淘汰策略。</li>
<li><code>FifoCache</code>: 增加了**先进先出（FIFO）**的淘汰策略。</li>
<li><code>LoggingCache</code>: 增加了<strong>日志记录</strong>功能，记录缓存命中率。</li>
<li><code>SynchronizedCache</code>: 增加了<strong>线程同步</strong>功能，保证缓存线程安全。</li>
</ul>
</li>
<li>通过XML配置，MyBatis可以为你自动“组装”这些装饰器，例如 <code>&lt;cache type=&quot;org.apache.ibatis.cache.decorators.LruCache&quot; /&gt;</code>。</li>
</ul>
</li>
<li><p><strong>Java Servlet API中的应用：<code>HttpServletRequestWrapper</code></strong></p>
<ul>
<li><code>javax.servlet.http.HttpServletRequestWrapper</code> 是一个典型的装饰器类，它允许你包装一个<code>HttpServletRequest</code>对象，并重写其方法，从而在不改变原有Request对象的情况下，修改或增强其行为，例如过滤请求参数、修改请求头等。这在<code>Filter</code>中非常常用。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-3-代理模式-Proxy-Pattern"><a href="#3-3-代理模式-Proxy-Pattern" class="headerlink" title="3.3 代理模式 (Proxy Pattern)"></a>3.3 代理模式 (Proxy Pattern)</h3><h4 id="3-3-1-核心思想"><a href="#3-3-1-核心思想" class="headerlink" title="3.3.1 核心思想"></a>3.3.1 核心思想</h4><p><strong>为其他对象提供一种代理（Surrogate or Placeholder）以控制对这个对象的访问。</strong></p>
<p>代理对象和真实对象通常实现同一个接口。客户端并不知道自己调用的是代理对象还是真实对象，它只与接口交互。代理对象在内部持有对真实对象的引用，它可以在将客户端的请求转发给真实对象之前或之后，执行一些额外的操作。</p>
<p>可以把它想象成一位“明星经纪人”：</p>
<ul>
<li><strong>真实对象 (RealSubject):</strong> 明星本人，很忙，不直接处理所有事务。</li>
<li><strong>代理对象 (Proxy):</strong> 经纪人。</li>
<li><strong>客户端 (Client):</strong> 粉丝、广告商等。<br>客户端想找明星，得先联系经纪人。经纪人可以帮忙过滤不重要的请求（<strong>访问控制</strong>）、安排日程（<strong>增强功能</strong>）、甚至在明星没空时处理一些事情（<strong>懒加载</strong>）。</li>
</ul>
<hr>
<h4 id="3-3-2-主要作用"><a href="#3-3-2-主要作用" class="headerlink" title="3.3.2 主要作用"></a>3.3.2 主要作用</h4><ol>
<li><strong>访问控制与保护：</strong> 代理可以作为真实对象的“防火墙”，在请求到达真实对象前进行权限检查、身份验证等。</li>
<li><strong>功能增强（非侵入式）：</strong> 可以在不修改真实对象代码的前提下，为其增加额外的功能，如日志记录、性能监控、事务管理、缓存等。这是**面向切面编程 (AOP)**的核心思想。</li>
<li><strong>延迟加载（懒加载）：</strong> 如果一个对象的创建成本很高（如加载大图片、初始化数据库连接），代理可以在刚开始时只包含一个引用，直到客户端真正需要调用其方法时，才去创建和加载真实对象，从而优化性能。</li>
<li><strong>远程代理（Remote Proxy）：</strong> 代理可以代表一个位于远程地址空间的对象（如在另一台服务器上）。代理在本地，它负责将请求通过网络编码、发送给远程的真实对象，并将结果带回。这使得客户端调用远程对象就像调用本地对象一样简单，典型的应用是RPC（远程过程调用）框架。</li>
</ol>
<hr>
<h4 id="3-3-3-实现方式（按推荐度排序）"><a href="#3-3-3-实现方式（按推荐度排序）" class="headerlink" title="3.3.3 实现方式（按推荐度排序）"></a>3.3.3 实现方式（按推荐度排序）</h4><h5 id="1-动态代理-Dynamic-Proxy-【极力推荐】"><a href="#1-动态代理-Dynamic-Proxy-【极力推荐】" class="headerlink" title="1. 动态代理 (Dynamic Proxy) - 【极力推荐】"></a>1. 动态代理 (Dynamic Proxy) - <strong>【极力推荐】</strong></h5><p>动态代理是在<strong>运行时</strong>动态生成代理类，而不需要为每个真实对象手写一个代理类。这是现代Java框架的基石。</p>
<p><strong>a. JDK动态代理</strong></p>
<ul>
<li><p><strong>前提：</strong> 目标类（真实对象）<strong>必须实现一个或多个接口</strong>。JDK代理是基于接口的。</p>
</li>
<li><p><strong>核心：</strong> <code>java.lang.reflect.Proxy</code> 类和 <code>java.lang.reflect.InvocationHandler</code> 接口。</p>
</li>
<li><p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 抽象主题：定义服务接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 真实主题：实现服务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending message: &quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 实现 InvocationHandler 接口，这是代理的逻辑核心</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target; <span class="comment">// 持有被代理的真实对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  动态生成的代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 正在被调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   方法的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 在调用真实方法前，执行增强操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;[Proxy] Before method: &quot;</span> + method.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用真实对象的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在调用真实方法后，执行增强操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;[Proxy] After method: &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 获取代理对象的工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JdkProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载器</span></span><br><span class="line">            target.getClass().getInterfaces(),  <span class="comment">// 目标类实现的接口</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DebugInvocationHandler</span>(target)  <span class="comment">// InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>());</span><br><span class="line">        smsService.send(<span class="string">&quot;Hello, JDK Proxy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>b. CGLIB动态代理</strong></p>
<ul>
<li><p><strong>前提：</strong> 目标类<strong>无需实现接口</strong>。CGLIB通过生成目标类的<strong>子类</strong>来作为代理。因此，目标类不能是 <code>final</code> 的，被代理的方法也不能是 <code>final</code> 的。</p>
</li>
<li><p><strong>核心：</strong> 第三方库 <code>cglib</code>，主要使用 <code>Enhancer</code> 类和 <code>MethodInterceptor</code> 接口。Spring框架内部广泛使用它。</p>
</li>
<li><p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 真实主题：一个普通的类，没有实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserService is processing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 实现 MethodInterceptor 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[CGLIB] Before method: &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args); <span class="comment">// 调用父类（真实对象）的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;[CGLIB] After method: &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 获取代理对象的工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CglibProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(clazz); <span class="comment">// 设置父类</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MyMethodInterceptor</span>()); <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create(); <span class="comment">// 创建代理对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) CglibProxyFactory.getProxy(UserService.class);</span><br><span class="line">        userService.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-静态代理-Static-Proxy"><a href="#2-静态代理-Static-Proxy" class="headerlink" title="2. 静态代理 (Static Proxy)"></a>2. 静态代理 (Static Proxy)</h5><p>静态代理需要手动为每个真实类编写一个代理类，代理类和真实类实现相同的接口。</p>
<ul>
<li><p><strong>优点：</strong> 结构简单，易于理解。</p>
</li>
<li><p><strong>缺点：</strong> <strong>“类爆炸”</strong>。如果系统中有大量的类需要被代理，就需要编写同样数量的代理类，维护成本极高。因此在现代开发中已不常用。</p>
</li>
<li><p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口和真实类同上（SmsService, SmsServiceImpl）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 静态代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmsServiceStaticProxy</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService realService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsServiceStaticProxy</span><span class="params">(SmsService realService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.realService = realService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Static Proxy] Before sending message.&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.realService.send(message); <span class="comment">// 委托给真实对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;[Static Proxy] After sending message.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端使用</span></span><br><span class="line"><span class="type">SmsService</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsServiceStaticProxy</span>(<span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>());</span><br><span class="line">proxy.send(<span class="string">&quot;Hello, Static Proxy!&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-3-4-实际解决问题-使用场景"><a href="#3-3-4-实际解决问题-使用场景" class="headerlink" title="3.3.4 实际解决问题 &#x2F; 使用场景"></a>3.3.4 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><strong>Spring AOP（最核心的应用）：</strong><ul>
<li>当你使用 <code>@Transactional</code> (事务), <code>@Cacheable</code> (缓存), <code>@Async</code> (异步) 等注解时，Spring 在运行时并不会修改你的类，而是为你创建了一个<strong>动态代理</strong>对象。</li>
<li>这个代理对象包裹了你的真实Bean。当外部调用你的方法时，首先会命中代理对象。代理对象中的<code>InvocationHandler</code>或<code>MethodInterceptor</code>会先执行切面逻辑（如开启事务、检查缓存），然后再调用你的真实方法，最后再执行切面逻辑（如提交&#x2F;回滚事务、更新缓存）。</li>
<li><strong>Spring会智能选择代理方式</strong>：如果你的Bean实现了接口，Spring默认使用<strong>JDK动态代理</strong>；如果没实现接口，则使用<strong>CGLIB</strong>。</li>
</ul>
</li>
<li><strong>RPC框架（如 Dubbo、gRPC）：</strong><ul>
<li>在服务消费者端，你注入的 <code>XxxService</code> 接口实际上是一个<strong>远程代理</strong>实例。当你调用接口方法时，代理对象将方法调用和参数序列化，通过网络发送给服务提供者，然后等待结果返回。整个网络通信的复杂过程都被代理所封装。</li>
</ul>
</li>
<li><strong>MyBatis的Mapper接口：</strong><ul>
<li>在MyBatis中，我们只定义了Mapper接口（如 <code>UserMapper</code>），并没有写实现类。当我们从Spring容器中注入<code>UserMapper</code>时，得到的就是一个<strong>JDK动态代理</strong>对象。</li>
<li>当你调用<code>userMapper.selectById(1)</code>时，代理的<code>InvocationHandler</code>会拦截这个调用，解析方法名和注解（或XML），找到对应的SQL语句，然后通过JDBC执行，最后将结果映射成Java对象返回。</li>
</ul>
</li>
<li><strong>Hibernate&#x2F;JPA的懒加载：</strong><ul>
<li>当你从数据库加载一个实体<code>A</code>，而它关联了另一个实体<code>B</code> (<code>@ManyToOne(fetch = FetchType.LAZY)</code>)，Hibernate默认不会立即加载<code>B</code>。它会给<code>A</code>的<code>b</code>属性赋一个<code>B</code>的<strong>代理对象</strong>。这个代理对象只有<code>B</code>的ID。当你第一次访问<code>b</code>的非ID属性（如<code>b.getName()</code>）时，代理对象才会去数据库真正加载<code>B</code>的完整数据。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-4-外观模式-Facade-Pattern"><a href="#3-4-外观模式-Facade-Pattern" class="headerlink" title="3.4 外观模式 (Facade Pattern)"></a>3.4 外观模式 (Facade Pattern)</h3><p>外观模式也称为<strong>门面模式</strong>。它的核心思想就像是为一个复杂的系统提供一个“客服前台”或“服务总机”。</p>
<h4 id="3-4-1-核心思想"><a href="#3-4-1-核心思想" class="headerlink" title="3.4.1 核心思想"></a>3.4.1 核心思想</h4><p><strong>为子系统中的一组接口提供一个统一的、高层的入口。外观模式定义了一个高层接口，这个接口使得子系统更加容易使用。</strong></p>
<p>客户端不再需要了解子系统中各个模块的复杂交互关系，只需要与这个单一的“外观”对象打交道。外观对象内部负责协调和委托子系统中的各个组件来完成客户端的请求。</p>
<hr>
<h4 id="3-4-2-主要作用"><a href="#3-4-2-主要作用" class="headerlink" title="3.4.2 主要作用"></a>3.4.2 主要作用</h4><ol>
<li><strong>降低客户端与子系统之间的耦合度：</strong> 这是最核心的作用。客户端只依赖于外观接口，而完全不需要知道子系统的内部实现。当子系统内部发生变化（如模块重构、替换实现）时，只要外观接口不变，客户端代码就无需改动。</li>
<li><strong>简化客户端的使用：</strong> 将一个复杂的操作流程封装在外观方法中。客户端只需调用一个方法，即可完成原来需要调用多个子系统模块才能完成的任务，大大简化了客户端的开发。</li>
<li><strong>对子系统进行分层：</strong> 外观模式可以为复杂的系统划分层次。每个子系统都可以有一个外观接口，用于上层模块的调用。这有助于构建一个层次清晰、结构化的系统。</li>
</ol>
<hr>
<h4 id="3-4-3-实现方式（经典结构）"><a href="#3-4-3-实现方式（经典结构）" class="headerlink" title="3.4.3 实现方式（经典结构）"></a>3.4.3 实现方式（经典结构）</h4><p>外观模式的结构非常简单，主要包含两个角色：</p>
<ol>
<li><strong>Facade (外观类)：</strong><ul>
<li>知道所有子系统模块的职责。</li>
<li>根据客户端的请求，将工作委托给相应的子系统模块处理。</li>
</ul>
</li>
<li><strong>SubSystem (子系统类集合)：</strong><ul>
<li>实现了子系统的具体功能。</li>
<li>处理外观对象指派的任务。</li>
<li>子系统类之间可能相互关联，但它们不直接与外观类关联，即它们不知道外观类的存在。</li>
</ul>
</li>
</ol>
<p><strong>代码示例：模拟一键开启家庭影院</strong></p>
<p>开启家庭影院需要多个步骤：打开投影仪、放下幕布、打开音响、打开DVD播放器。</p>
<p><strong>1. 子系统类集合 (SubSystem)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子系统A：投影仪</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Projector</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Projector is ON.&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Projector is OFF.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统B：幕布</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Screen is DOWN.&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">up</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Screen is UP.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统C：音响</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Amplifier</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Amplifier is ON.&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVolume</span><span class="params">(<span class="type">int</span> level)</span> &#123; System.out.println(<span class="string">&quot;Amplifier volume set to &quot;</span> + level); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Amplifier is OFF.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子系统D：DVD播放器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DvdPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;DVD Player is ON.&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String movie)</span> &#123; System.out.println(<span class="string">&quot;DVD Player is playing \&quot;&quot;</span> + movie + <span class="string">&quot;\&quot;.&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;DVD Player is OFF.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 外观类 (Facade)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外观类：家庭影院总控制器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeTheaterFacade</span> &#123;</span><br><span class="line">    <span class="comment">// 持有所有子系统的引用</span></span><br><span class="line">    <span class="keyword">private</span> Projector projector;</span><br><span class="line">    <span class="keyword">private</span> Screen screen;</span><br><span class="line">    <span class="keyword">private</span> Amplifier amplifier;</span><br><span class="line">    <span class="keyword">private</span> DvdPlayer dvdPlayer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HomeTheaterFacade</span><span class="params">(Projector projector, Screen screen, Amplifier amplifier, DvdPlayer dvdPlayer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.projector = projector;</span><br><span class="line">        <span class="built_in">this</span>.screen = screen;</span><br><span class="line">        <span class="built_in">this</span>.amplifier = amplifier;</span><br><span class="line">        <span class="built_in">this</span>.dvdPlayer = dvdPlayer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个高层接口，封装了复杂的启动流程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watchMovie</span><span class="params">(String movie)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Get ready to watch a movie...&quot;</span>);</span><br><span class="line">        screen.down();</span><br><span class="line">        projector.on();</span><br><span class="line">        amplifier.on();</span><br><span class="line">        amplifier.setVolume(<span class="number">5</span>);</span><br><span class="line">        dvdPlayer.on();</span><br><span class="line">        dvdPlayer.play(movie);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提供另一个高层接口，封装了关闭流程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">endMovie</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\nShutting movie theater down...&quot;</span>);</span><br><span class="line">        dvdPlayer.off();</span><br><span class="line">        amplifier.off();</span><br><span class="line">        projector.off();</span><br><span class="line">        screen.up();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 客户端使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 准备好所有设备</span></span><br><span class="line">        <span class="type">Projector</span> <span class="variable">projector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Projector</span>();</span><br><span class="line">        <span class="type">Screen</span> <span class="variable">screen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Screen</span>();</span><br><span class="line">        <span class="type">Amplifier</span> <span class="variable">amplifier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Amplifier</span>();</span><br><span class="line">        <span class="type">DvdPlayer</span> <span class="variable">dvdPlayer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DvdPlayer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建外观对象</span></span><br><span class="line">        <span class="type">HomeTheaterFacade</span> <span class="variable">homeTheater</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HomeTheaterFacade</span>(projector, screen, amplifier, dvdPlayer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端只需调用一个方法，即可完成所有操作</span></span><br><span class="line">        homeTheater.watchMovie(<span class="string">&quot;Inception&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 同样，关闭也只需一个方法</span></span><br><span class="line">        homeTheater.endMovie();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Get ready to watch a movie...</span><br><span class="line">Screen is DOWN.</span><br><span class="line">Projector is ON.</span><br><span class="line">Amplifier is ON.</span><br><span class="line">Amplifier volume set to 5</span><br><span class="line">DVD Player is ON.</span><br><span class="line">DVD Player is playing &quot;Inception&quot;.</span><br><span class="line"></span><br><span class="line">Shutting movie theater down...</span><br><span class="line">DVD Player is OFF.</span><br><span class="line">Amplifier is OFF.</span><br><span class="line">Projector is OFF.</span><br><span class="line">Screen is UP.</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-4-4-外观模式的优点与缺点"><a href="#3-4-4-外观模式的优点与缺点" class="headerlink" title="3.4.4 外观模式的优点与缺点"></a>3.4.4 外观模式的优点与缺点</h4><ul>
<li><strong>优点：</strong><ul>
<li><strong>解耦：</strong> 客户端与子系统解耦，提高了系统的独立性和可移植性。</li>
<li><strong>简化：</strong> 提供了高层接口，简化了客户端的使用。</li>
<li><strong>安全：</strong> 外观模式并不限制客户端直接访问子系统，如果需要，客户端仍然可以绕过外观类去调用子系统。但通常它提供了一种更简单、更安全的访问路径。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>不符合开闭原则：</strong> 如果业务需求变更，需要修改外观类的代码。</li>
<li><strong>可能演变成上帝类（God Object）：</strong> 如果一个外观类承担了过多的职责，与过多的子系统交互，它本身可能会变得非常庞大和复杂，违背了单一职责原则。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-4-5-实际解决问题-使用场景"><a href="#3-4-5-实际解决问题-使用场景" class="headerlink" title="3.4.5 实际解决问题 &#x2F; 使用场景"></a>3.4.5 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><strong>SLF4J (Simple Logging Facade for Java)：</strong><ul>
<li>这是外观模式最经典的工业级应用。SLF4J本身提供了一套简单的日志API（<code>org.slf4j.Logger</code>），这就是<strong>外观</strong>。</li>
<li>底层可以对接Logback、Log4j、<code>java.util.logging</code>等各种复杂的日志实现（这些是<strong>子系统</strong>）。</li>
<li>应用程序开发者只需要面向SLF4J编程，而无需关心底层到底用了哪个日志框架，实现了日志系统的“可插拔”。</li>
</ul>
</li>
<li><strong>Tomcat的<code>RequestFacade</code> 和 <code>ResponseFacade</code>：</strong><ul>
<li>在Tomcat容器内部，<code>Request</code>和<code>Response</code>对象非常复杂，包含了大量与容器内部实现相关的细节。</li>
<li>Tomcat通过<code>RequestFacade</code>和<code>ResponseFacade</code>将内部的<code>Request</code>和<code>Response</code>对象包装起来，只暴露Servlet规范中定义的标准方法给Web应用（如Servlet、Filter）。</li>
<li>这既简化了开发者的使用，又保护了Tomcat容器的内部组件不被外部应用直接访问和修改，提高了容器的健壮性。</li>
</ul>
</li>
<li><strong>Spring JDBC的<code>JdbcTemplate</code>：</strong><ul>
<li>虽然<code>JdbcTemplate</code>更多被看作是模板方法模式的应用，但它也体现了外观模式的思想。</li>
<li>原生的JDBC操作非常繁琐：需要获取<code>Connection</code>、创建<code>Statement</code>、执行SQL、处理<code>ResultSet</code>、最后还要在<code>finally</code>块中依次关闭<code>ResultSet</code>、<code>Statement</code>和<code>Connection</code>。</li>
<li><code>JdbcTemplate</code>将这一整套复杂的流程封装起来，提供了一个简单的<code>query</code>、<code>update</code>等方法。开发者只需要提供SQL和参数，<code>JdbcTemplate</code>在内部处理了所有资源管理和异常处理的细节。</li>
</ul>
</li>
<li><strong>日常业务开发：</strong><ul>
<li>当一个业务流程（如下单、退款）需要调用多个微服务（订单服务、库存服务、支付服务、用户服务）时，通常会创建一个<code>OrderFacade</code>或<code>OrderService</code>来封装这个流程。这个Facade负责按顺序调用各个微服务接口，并处理它们之间的交互逻辑。对于上层调用者（如Controller），它只需要调用<code>orderFacade.placeOrder()</code>即可。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-5-桥接模式-Bridge-Pattern"><a href="#3-5-桥接模式-Bridge-Pattern" class="headerlink" title="3.5 桥接模式 (Bridge Pattern)"></a>3.5 桥接模式 (Bridge Pattern)</h3><h4 id="3-5-1-核心思想"><a href="#3-5-1-核心思想" class="headerlink" title="3.5.1 核心思想"></a>3.5.1 核心思想</h4><p><strong>将抽象部分与它的实现部分相分离，使它们都可以独立地变化。</strong></p>
<p>这个定义是GoF的经典定义，但比较难懂。我们可以这样理解：</p>
<p>当一个事物有两个或多个独立变化的维度时，不要使用继承来处理。继承会导致类的数量呈爆炸式增长（笛卡尔积）。桥接模式通过<strong>组合</strong>的方式，将这些维度连接起来，让每个维度都可以自由地扩展，而不会互相影响。</p>
<p><strong>通俗比喻：遥控器和电视机</strong></p>
<ul>
<li><strong>维度一（抽象部分）：遥控器</strong>。遥控器可以有很多种：普通遥控器、学习型遥控器、带语音功能的智能遥控器等。它们都具有“开&#x2F;关”、“换台”等抽象功能。</li>
<li><strong>维度二（实现部分）：电视机品牌</strong>。电视机也可以有很多种：索尼电视、三星电视、小米电视等。它们各自有不同的开关机和换台指令。</li>
<li><strong>如果用继承：</strong> 你需要创建<code>索尼普通遥控器</code>、<code>三星普通遥控器</code>、<code>索尼智能遥控器</code>、<code>三星智能遥控器</code>… 类的数量是“遥控器种类 * 电视品牌”，非常可怕。</li>
<li><strong>如果用桥接模式：</strong><ol>
<li>创建一个<code>遥控器</code>的抽象类，它内部**持有（组合）**一个<code>电视机</code>的接口引用。</li>
<li><code>遥控器</code>的<code>on()</code>方法会调用<code>电视机</code>接口的<code>turnOn()</code>方法。</li>
<li>现在，你可以独立地扩展遥控器的种类（<code>普通遥控器</code>、<code>智能遥控器</code>），也可以独立地扩展电视机的品牌（<code>索尼电视</code>、<code>三星电视</code>）。</li>
<li>在运行时，你可以给任何一种遥控器“装上”任何一个品牌的电视机，它们就能协同工作。这就是“桥接”。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="3-5-2-主要作用"><a href="#3-5-2-主要作用" class="headerlink" title="3.5.2 主要作用"></a>3.5.2 主要作用</h4><ol>
<li><strong>分离抽象与实现：</strong> 这是其最核心的目的。让抽象部分和实现部分可以沿着各自的维度独立地演化，降低了耦合度。</li>
<li><strong>避免“类爆炸”：</strong> 通过将多维度变化的系统从继承关系改为组合关系，极大地减少了类的数量。</li>
<li><strong>提高系统的可扩展性：</strong> 无论是想增加一个新的“抽象”（如一个新的遥控器类型），还是一个新的“实现”（如一个新的电视品牌），都非常容易，符合开闭原则。</li>
</ol>
<hr>
<h4 id="3-5-3-实现方式（经典结构）"><a href="#3-5-3-实现方式（经典结构）" class="headerlink" title="3.5.3 实现方式（经典结构）"></a>3.5.3 实现方式（经典结构）</h4><p>桥接模式包含四个核心角色：</p>
<ol>
<li><strong>Abstraction (抽象部分)：</strong> 定义了抽象类的接口，并包含一个对<strong>实现部分 (Implementor)</strong> 接口的引用。</li>
<li><strong>RefinedAbstraction (精确抽象&#x2F;扩充抽象)：</strong> 继承自 <code>Abstraction</code>，扩展抽象部分的接口，实现具体的业务逻辑。它通过调用 <code>Implementor</code> 的方法来完成任务。</li>
<li><strong>Implementor (实现部分接口)：</strong> 定义了实现类的接口，这个接口不一定要与 <code>Abstraction</code> 的接口完全一致，它只提供基本的操作。</li>
<li><strong>ConcreteImplementor (具体实现)：</strong> 实现了 <code>Implementor</code> 接口，给出基本操作的具体实现。</li>
</ol>
<p><strong>代码示例：不同形状和不同颜色的组合</strong></p>
<ul>
<li><strong>维度一：形状 (Abstraction)</strong></li>
<li><strong>维度二：颜色 (Implementor)</strong></li>
</ul>
<p><strong>1. 实现部分接口 (Implementor)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现部分接口：颜色</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    String <span class="title function_">applyColor</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 具体实现 (ConcreteImplementor)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体实现A：红色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Red</span> <span class="keyword">implements</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">applyColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Red&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现B：蓝色</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Blue</span> <span class="keyword">implements</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">applyColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Blue&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 抽象部分 (Abstraction)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象部分：形状</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="comment">// 桥接的关键：持有一个Implementor接口的引用</span></span><br><span class="line">    <span class="keyword">protected</span> Color color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造函数“搭桥”</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">(Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法，由子类实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 精确抽象 (RefinedAbstraction)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 精确抽象A：圆形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在实现自己的业务逻辑时，调用了实现部分的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a &quot;</span> + color.applyColor() + <span class="string">&quot; circle.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精确抽象B：正方形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Square</span><span class="params">(Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a &quot;</span> + color.applyColor() + <span class="string">&quot; square.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 客户端使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 需求1：一个红色的圆</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">redCircle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="keyword">new</span> <span class="title class_">Red</span>());</span><br><span class="line">        redCircle.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求2：一个蓝色的正方形</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">blueSquare</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>(<span class="keyword">new</span> <span class="title class_">Blue</span>());</span><br><span class="line">        blueSquare.draw();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 需求3：一个蓝色的圆</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">blueCircle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="keyword">new</span> <span class="title class_">Blue</span>());</span><br><span class="line">        blueCircle.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果要增加一种新的颜色（比如绿色），只需要增加一个Green类。</span></span><br><span class="line">        <span class="comment">// 如果要增加一种新的形状（比如三角形），只需要增加一个Triangle类。</span></span><br><span class="line">        <span class="comment">// 两个维度互相不影响，可以自由组合。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Drawing a Red circle.</span><br><span class="line">Drawing a Blue square.</span><br><span class="line">Drawing a Blue circle.</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-5-4-与适配器模式的对比"><a href="#3-5-4-与适配器模式的对比" class="headerlink" title="3.5.4 与适配器模式的对比"></a>3.5.4 与适配器模式的对比</h4><p>桥接模式和适配器模式都是为了解耦，但它们的<strong>意图</strong>和<strong>时机</strong>完全不同。</p>
<ul>
<li><strong>意图：</strong><ul>
<li><strong>适配器模式：</strong> 是<strong>事后补救</strong>。当两个已有的、不兼容的接口需要协同工作时，使用适配器来“撮合”它们。</li>
<li><strong>桥接模式：</strong> 是<strong>事前设计</strong>。当你在系统设计阶段，预见到一个类会有多个独立变化的维度时，主动使用桥接模式来分离它们，避免未来的耦合。</li>
</ul>
</li>
<li><strong>结构：</strong><ul>
<li>适配器模式是让一个接口看起来像另一个。</li>
<li>桥接模式是分离一个类的抽象和实现。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-5-5-实际解决问题-使用场景"><a href="#3-5-5-实际解决问题-使用场景" class="headerlink" title="3.5.5 实际解决问题 &#x2F; 使用场景"></a>3.5.5 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><strong>JDBC驱动程序（最经典的案例）：</strong><ul>
<li><strong>抽象部分 (Abstraction)：</strong> Java提供了一套标准的JDBC接口，如 <code>Connection</code>, <code>Statement</code>, <code>ResultSet</code>。这些接口是给应用程序开发者（我们）使用的。</li>
<li><strong>实现部分 (Implementor)：</strong> 各个数据库厂商（MySQL, Oracle, PostgreSQL等）根据这套接口，提供了自己数据库的<strong>驱动实现</strong>。</li>
<li><strong>桥接：</strong> <code>DriverManager.getConnection()</code> 方法就是那个“桥”，它根据你传入的URL，找到了合适的驱动（<code>ConcreteImplementor</code>），并返回一个实现了标准<code>Connection</code>接口（<code>Abstraction</code>）的对象。</li>
<li>这样，我们的Java代码（抽象部分）就可以独立于具体的数据库实现（实现部分）进行开发。更换数据库时，只需更换驱动jar包和连接字符串即可。</li>
</ul>
</li>
<li><strong>不同类型的消息发送：</strong><ul>
<li><strong>维度一（抽象）：消息类型。</strong> 普通消息、加急消息、定时消息。它们都有一个 <code>send()</code> 方法。<code>加急消息</code>的<code>send</code>方法可能会有一些特殊的逻辑，比如标记为高优先级。</li>
<li><strong>维度二（实现）：发送通道。</strong> 短信、邮件、站内信。它们各自有不同的发送API。</li>
<li>使用桥接模式，你可以在运行时决定是“通过短信发送一条加急消息”，还是“通过邮件发送一条普通消息”，而无需为每种组合创建一个类。</li>
</ul>
</li>
<li><strong>跨平台的GUI库：</strong><ul>
<li><strong>抽象部分：</strong> 窗口、按钮、文本框等GUI控件的抽象类。</li>
<li><strong>实现部分：</strong> 针对不同操作系统的具体实现接口（如<code>WindowImpl</code>, <code>ButtonImpl</code>）。</li>
<li><code>WindowsButtonImpl</code> 会调用Windows API来绘制按钮，而<code>MacButtonImpl</code>会调用macOS的API。<code>Button</code>抽象类则通过桥接，可以在不同平台上展现出符合该平台风格的外观。Java AWT库的设计就体现了这种思想。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-6-组合模式-Composite-Pattern"><a href="#3-6-组合模式-Composite-Pattern" class="headerlink" title="3.6 组合模式 (Composite Pattern)"></a>3.6 组合模式 (Composite Pattern)</h3><p>组合模式也被称为<strong>部分-整体模式 (Part-Whole Pattern)</strong>。</p>
<h4 id="3-6-1-核心思想"><a href="#3-6-1-核心思想" class="headerlink" title="3.6.1 核心思想"></a>3.6.1 核心思想</h4><p><strong>将对象组合成树形结构，以表示“部分-整体”的层次关系。组合模式使得客户端可以对单个对象和组合对象进行一致地操作。</strong></p>
<p>这个模式的关键在于定义一个抽象组件，这个组件既可以代表“叶子节点”（单个对象），也可以代表“树枝节点”（组合对象&#x2F;容器）。这样，客户端在调用时，就无需区分它操作的到底是一个简单的叶子，还是一个包含了许多叶子和树枝的复杂容器。</p>
<p><strong>通俗比喻：文件系统</strong></p>
<ul>
<li><strong>叶子节点 (Leaf):</strong> 文件（如 <code>text.txt</code>, <code>image.jpg</code>）。文件是基本单位，它不能再包含其他文件或文件夹。</li>
<li><strong>树枝节点 (Composite):</strong> 文件夹（目录）。文件夹可以包含文件，也可以包含其他文件夹，形成一个嵌套的树形结构。</li>
<li><strong>统一操作：</strong> 无论是文件还是文件夹，它们都有一些共同的操作，比如“计算大小”、“重命名”、“删除”。当你计算一个文件的大小时，直接返回其大小。当你计算一个文件夹的大小时，你需要遍历它下面的所有文件和子文件夹，然后把它们的大小加起来。</li>
<li>组合模式让“文件”和“文件夹”实现同一个接口（比如 <code>FileSystemNode</code>），客户端通过这个接口，可以用同样的方式来计算文件或整个文件夹的大小，而无需关心其内部结构。</li>
</ul>
<hr>
<h4 id="3-6-2-主要作用"><a href="#3-6-2-主要作用" class="headerlink" title="3.6.2 主要作用"></a>3.6.2 主要作用</h4><ol>
<li><strong>统一处理组合结构和单个对象：</strong> 客户端代码可以忽略组合对象与单个对象的差异，以一致的方式处理它们，从而简化了客户端代码。</li>
<li><strong>表示清晰的层次结构：</strong> 非常适合用来表示具有“部分-整体”关系的树形结构，如组织架构、UI控件层级、商品分类等。</li>
<li><strong>高可扩展性：</strong> 添加新的叶子节点或树枝节点非常方便，只需创建一个新类实现共同的组件接口即可，符合开闭原则。</li>
</ol>
<hr>
<h4 id="3-6-3-实现方式（经典结构）"><a href="#3-6-3-实现方式（经典结构）" class="headerlink" title="3.6.3 实现方式（经典结构）"></a>3.6.3 实现方式（经典结构）</h4><p>组合模式主要包含三个核心角色：</p>
<ol>
<li><strong>Component (组件接口)：</strong><ul>
<li>定义了组合中对象的通用接口，既可以是叶子节点，也可以是树枝节点。</li>
<li>声明了所有类共有的接口，如 <code>add</code>, <code>remove</code>, <code>getChild</code> 以及业务方法 <code>operation()</code>。</li>
</ul>
</li>
<li><strong>Leaf (叶子节点)：</strong><ul>
<li>表示树中的叶子对象，它没有子节点。</li>
<li>实现了 <code>Component</code> 接口中属于它的方法（如 <code>operation()</code>）。对于管理子节点的方法（如 <code>add</code>, <code>remove</code>），通常会抛出异常或空实现。</li>
</ul>
</li>
<li><strong>Composite (树枝&#x2F;组合节点)：</strong><ul>
<li>表示树中的容器节点，它可以包含子节点（<code>Leaf</code> 或 <code>Composite</code>）。</li>
<li>实现了 <code>Component</code> 接口，包括管理子节点的方法。</li>
<li>它的业务方法 <code>operation()</code> 通常会遍历其子节点，并调用子节点的 <code>operation()</code> 方法。</li>
</ul>
</li>
</ol>
<p><strong>代码示例：公司组织架构</strong></p>
<p><strong>1. Component (组件接口)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件接口：定义了公司组织（部门或员工）的通用行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OrganizationComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrganizationComponent</span><span class="params">(String name, String description)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认实现，因为叶子节点不需要这些方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(OrganizationComponent component)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(OrganizationComponent component)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 业务方法，打印信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123; <span class="keyword">return</span> description; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>这种实现方式称为“安全模式”，叶子节点不支持管理子节点的方法。还有一种“透明模式”，会将 <code>add/remove</code> 也定义在接口中，叶子节点提供空实现，但可能会让客户端产生误解。</em></p>
<p><strong>2. Leaf (叶子节点)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 叶子节点：员工</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_">OrganizationComponent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, String description)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, description);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;  - &quot;</span> + getName() + <span class="string">&quot; (&quot;</span> + getDescription() + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. Composite (树枝节点)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树枝节点：部门</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Department</span> <span class="keyword">extends</span> <span class="title class_">OrganizationComponent</span> &#123;</span><br><span class="line">    <span class="comment">// 存储子节点的容器</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;OrganizationComponent&gt; children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Department</span><span class="params">(String name, String description)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, description);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(OrganizationComponent component)</span> &#123;</span><br><span class="line">        children.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(OrganizationComponent component)</span> &#123;</span><br><span class="line">        children.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 打印部门信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;+ &quot;</span> + getName() + <span class="string">&quot; (&quot;</span> + getDescription() + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历并打印所有子节点（递归调用）</span></span><br><span class="line">        <span class="keyword">for</span> (OrganizationComponent component : children) &#123;</span><br><span class="line">            component.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 客户端使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建顶层公司</span></span><br><span class="line">        <span class="type">OrganizationComponent</span> <span class="variable">company</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;Tech Corp&quot;</span>, <span class="string">&quot;A technology company&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一级部门</span></span><br><span class="line">        <span class="type">OrganizationComponent</span> <span class="variable">rdDept</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;R&amp;D Department&quot;</span>, <span class="string">&quot;Research and Development&quot;</span>);</span><br><span class="line">        <span class="type">OrganizationComponent</span> <span class="variable">salesDept</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;Sales Department&quot;</span>, <span class="string">&quot;Sales and Marketing&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将一级部门加入公司</span></span><br><span class="line">        company.add(rdDept);</span><br><span class="line">        company.add(salesDept);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为R&amp;D部门添加员工（叶子节点）</span></span><br><span class="line">        rdDept.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Senior Java Developer&quot;</span>));</span><br><span class="line">        rdDept.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Frontend Developer&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为Sales部门添加员工</span></span><br><span class="line">        salesDept.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;Sales Manager&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个子部门</span></span><br><span class="line">        <span class="type">OrganizationComponent</span> <span class="variable">subSalesDept</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;International Sales&quot;</span>, <span class="string">&quot;Handles international markets&quot;</span>);</span><br><span class="line">        subSalesDept.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;David&quot;</span>, <span class="string">&quot;International Sales Rep&quot;</span>));</span><br><span class="line">        salesDept.add(subSalesDept);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端只需调用顶层对象的print方法，即可打印整个树形结构</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Company Structure:&quot;</span>);</span><br><span class="line">        company.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Company Structure:</span><br><span class="line">+ Tech Corp (A technology company)</span><br><span class="line">+ R&amp;D Department (Research and Development)</span><br><span class="line">  - Alice (Senior Java Developer)</span><br><span class="line">  - Bob (Frontend Developer)</span><br><span class="line">+ Sales Department (Sales and Marketing)</span><br><span class="line">  - Charlie (Sales Manager)</span><br><span class="line">+ International Sales (Handles international markets)</span><br><span class="line">  - David (International Sales Rep)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-6-4-实际解决问题-使用场景"><a href="#3-6-4-实际解决问题-使用场景" class="headerlink" title="3.6.4 实际解决问题 &#x2F; 使用场景"></a>3.6.4 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><strong>UI控件的层级结构：</strong><ul>
<li>在图形用户界面（GUI）中，一个窗口(<code>JFrame</code>)是一个容器(Composite)，它可以包含面板(<code>JPanel</code>)。面板本身也是一个容器，又可以包含按钮(<code>JButton</code>)、文本框(<code>JTextField</code>)等叶子组件。</li>
<li>当你对一个容器调用<code>paint()</code>方法时，它会递归地调用其所有子组件的<code>paint()</code>方法，这就是组合模式的典型应用。Java AWT&#x2F;Swing中的<code>Container</code>和<code>Component</code>就是这种关系。</li>
</ul>
</li>
<li><strong>MyBatis的动态SQL节点：</strong><ul>
<li>在MyBatis的XML映射文件中，动态SQL标签（如<code>&lt;if&gt;</code>, <code>&lt;where&gt;</code>, <code>&lt;foreach&gt;</code>）可以相互嵌套，形成一个树形结构。</li>
<li>MyBatis使用<code>SqlNode</code>接口（相当于Component）来表示这些节点。<code>StaticTextSqlNode</code>是叶子节点，表示静态的SQL文本。而<code>IfSqlNode</code>, <code>MixedSqlNode</code>等是Composite节点，它们内部包含一个<code>SqlNode</code>的列表。</li>
<li>当MyBatis解析SQL时，它会调用顶层<code>SqlNode</code>的<code>apply()</code>方法，该方法会递归调用所有子节点的<code>apply()</code>方法，最终拼接出完整的SQL语句。</li>
</ul>
</li>
<li><strong>各种树形菜单或目录结构：</strong><ul>
<li>网站的导航菜单，通常包含一级菜单、二级菜单等，是典型的树形结构。</li>
<li>操作系统的文件&#x2F;文件夹系统。</li>
<li>公司的组织架构图。</li>
<li>电商网站的商品分类。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-7-享元模式-Flyweight-Pattern"><a href="#3-7-享元模式-Flyweight-Pattern" class="headerlink" title="3.7 享元模式 (Flyweight Pattern)"></a>3.7 享元模式 (Flyweight Pattern)</h3><h4 id="3-7-1-核心思想"><a href="#3-7-1-核心思想" class="headerlink" title="3.7.1 核心思想"></a>3.7.1 核心思想</h4><p><strong>运用共享技术来有效地支持大量细粒度的对象。</strong></p>
<p>简单来说，当系统中存在大量相似的对象，而这些对象的大部分状态都可以被外部化（即提取出来，不存储在对象内部）时，我们就可以将这些对象设计为“享元”对象。系统只保留一份共享的享元对象，并在需要时配以外部状态来使用，从而避免创建大量重复的对象，极大地减少内存消耗。</p>
<p><strong>关键概念：内部状态 vs 外部状态</strong></p>
<ul>
<li><strong>内部状态 (Intrinsic State):</strong><ul>
<li>存储在享元对象内部，不随外部环境改变而改变的状态。</li>
<li>这些状态可以被多个客户端共享。</li>
<li>例如，一个围棋棋子的“颜色”（黑或白）就是内部状态。</li>
</ul>
</li>
<li><strong>外部状态 (Extrinsic State):</strong><ul>
<li>随外部环境改变而改变，不可以被共享的状态。</li>
<li>享元对象在使用时，外部状态必须由客户端传入。</li>
<li>例如，一个围棋棋子的“位置”（坐标x, y）就是外部状态，每个棋子的位置都不同。</li>
</ul>
</li>
</ul>
<p><strong>通俗比喻：共享单车</strong></p>
<ul>
<li><strong>享元对象：</strong> 单车本身。城市里有成千上万的人需要用车，但我们不需要为每个人都造一辆车。我们只需在城市里投放一定数量的共享单车即可。单车的品牌、型号、颜色等都是其<strong>内部状态</strong>，是固定的。</li>
<li><strong>外部状态：</strong> 使用时间、骑行地点、当前使用者。这些状态是每次使用时才决定的，由使用者（客户端）提供。</li>
<li><strong>享元工厂：</strong> 共享单车管理中心。当你需要用车时，你通过App（客户端）向管理中心请求，它会告诉你附近哪辆车可用（返回一个享元对象）。</li>
</ul>
<hr>
<h4 id="3-7-2-主要作用"><a href="#3-7-2-主要作用" class="headerlink" title="3.7.2 主要作用"></a>3.7.2 主要作用</h4><ol>
<li><strong>大幅减少内存占用：</strong> 这是享元模式最核心的目标。通过复用对象，可以极大地减少系统中创建的实例数量，特别是在对象数量巨大时效果显著。</li>
<li><strong>提高性能：</strong> 减少了对象的创建和销毁次数，从而降低了GC的压力，提升了系统性能。</li>
</ol>
<hr>
<h4 id="3-7-3-实现方式（经典结构）"><a href="#3-7-3-实现方式（经典结构）" class="headerlink" title="3.7.3 实现方式（经典结构）"></a>3.7.3 实现方式（经典结构）</h4><p>享元模式通常包含以下角色：</p>
<ol>
<li><strong>Flyweight (抽象享元类)：</strong> 定义了享元对象的公共接口。外部状态通常作为这个接口方法的参数传入。</li>
<li><strong>ConcreteFlyweight (具体享元类)：</strong> 实现了 <code>Flyweight</code> 接口，并为内部状态提供存储空间。这个类的对象是可以被共享的。</li>
<li><strong>UnsharedConcreteFlyweight (非共享具体享元类)：</strong> 可选角色。不是所有的 <code>Flyweight</code> 子类都需要被共享。这个类的对象不能被共享，通常用于处理一些特殊情况。</li>
<li><strong>FlyweightFactory (享元工厂)：</strong><ul>
<li>负责创建和管理享元对象。</li>
<li>内部通常有一个<strong>池</strong>（如 <code>HashMap</code>）来存储已经创建的享元对象。</li>
<li>当客户端请求一个享元对象时，工厂会先在池中查找，如果存在则直接返回，如果不存在则创建一个新的享元对象，存入池中，然后返回。</li>
</ul>
</li>
</ol>
<p><strong>代码示例：围棋棋子</strong></p>
<p><strong>1. Flyweight (抽象享元类)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象享元：棋子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChessPiece</span> &#123;</span><br><span class="line">    <span class="comment">// operation方法，外部状态(坐标)作为参数传入</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">place</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">    String <span class="title function_">getColor</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. ConcreteFlyweight (具体享元类)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体享元：黑棋和白棋</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlackChessPiece</span> <span class="keyword">implements</span> <span class="title class_">ChessPiece</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">color</span> <span class="operator">=</span> <span class="string">&quot;Black&quot;</span>; <span class="comment">// 内部状态</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">place</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Placing a &quot;</span> + color + <span class="string">&quot; piece at (&quot;</span> + x + <span class="string">&quot;, &quot;</span> + y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WhiteChessPiece</span> <span class="keyword">implements</span> <span class="title class_">ChessPiece</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">color</span> <span class="operator">=</span> <span class="string">&quot;White&quot;</span>; <span class="comment">// 内部状态</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">place</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Placing a &quot;</span> + color + <span class="string">&quot; piece at (&quot;</span> + x + <span class="string">&quot;, &quot;</span> + y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. FlyweightFactory (享元工厂)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 享元工厂：棋子工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChessPieceFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 享元池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, ChessPiece&gt; pieceMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 预先创建好共享对象</span></span><br><span class="line">        pieceMap.put(<span class="string">&quot;Black&quot;</span>, <span class="keyword">new</span> <span class="title class_">BlackChessPiece</span>());</span><br><span class="line">        pieceMap.put(<span class="string">&quot;White&quot;</span>, <span class="keyword">new</span> <span class="title class_">WhiteChessPiece</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ChessPiece <span class="title function_">getPiece</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pieceMap.get(color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 客户端使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoGame</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取黑棋对象</span></span><br><span class="line">        <span class="type">ChessPiece</span> <span class="variable">black1</span> <span class="operator">=</span> ChessPieceFactory.getPiece(<span class="string">&quot;Black&quot;</span>);</span><br><span class="line">        <span class="type">ChessPiece</span> <span class="variable">black2</span> <span class="operator">=</span> ChessPieceFactory.getPiece(<span class="string">&quot;Black&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Are black1 and black2 the same object? &quot;</span> + (black1 == black2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取白棋对象</span></span><br><span class="line">        <span class="type">ChessPiece</span> <span class="variable">white1</span> <span class="operator">=</span> ChessPieceFactory.getPiece(<span class="string">&quot;White&quot;</span>);</span><br><span class="line">        <span class="type">ChessPiece</span> <span class="variable">white2</span> <span class="operator">=</span> ChessPieceFactory.getPiece(<span class="string">&quot;White&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Are white1 and white2 the same object? &quot;</span> + (white1 == white2));</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- Placing pieces ---&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用享元对象，并传入外部状态</span></span><br><span class="line">        black1.place(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        white1.place(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        black2.place(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        white2.place(<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 整个棋局无论下了多少子，内存中实际只有两个ChessPiece对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Are black1 and black2 the same object? true</span><br><span class="line">Are white1 and white2 the same object? true</span><br><span class="line"></span><br><span class="line">--- Placing pieces ---</span><br><span class="line">Placing a Black piece at (1, 2)</span><br><span class="line">Placing a White piece at (3, 4)</span><br><span class="line">Placing a Black piece at (5, 6)</span><br><span class="line">Placing a White piece at (7, 8)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-7-4-享元模式的优点与缺点"><a href="#3-7-4-享元模式的优点与缺点" class="headerlink" title="3.7.4 享元模式的优点与缺点"></a>3.7.4 享元模式的优点与缺点</h4><ul>
<li><strong>优点：</strong><ul>
<li>显著减少内存占用和对象创建数量，提高系统性能。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>增加了系统的复杂性：</strong> 需要分离内部和外部状态，这使得程序的逻辑比正常情况更复杂。</li>
<li><strong>外部状态管理：</strong> 客户端需要自己管理和维护外部状态，这可能会给客户端带来额外的负担。</li>
<li><strong>线程安全问题：</strong> 享元对象是被共享的，如果它有可写的成员变量（虽然理论上内部状态应该是不可变的），就需要特别注意线程安全问题。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-7-5-实际解决问题-使用场景"><a href="#3-7-5-实际解决问题-使用场景" class="headerlink" title="3.7.5 实际解决问题 &#x2F; 使用场景"></a>3.7.5 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><strong>JDK中的应用：<code>String</code> 常量池</strong><ul>
<li>这是Java中享元模式最经典的体现。<code>String</code>被设计为不可变类。当你使用字面量（如 <code>String s1 = &quot;abc&quot;;</code>）创建字符串时，JVM会首先检查字符串常量池中是否已存在”abc”。如果存在，就直接返回其引用；如果不存在，则在池中创建一个新的”abc”对象并返回。</li>
<li><code>String s1 = &quot;abc&quot;;</code></li>
<li><code>String s2 = &quot;abc&quot;;</code></li>
<li><code>System.out.println(s1 == s2); // true</code></li>
<li>这大大节省了内存，因为像”abc”这样的字符串在程序中可能被使用成千上万次。</li>
</ul>
</li>
<li><strong>JDK中的应用：<code>Integer.valueOf()</code></strong><ul>
<li><code>Integer.valueOf(int i)</code> 方法也使用了享元模式。它内部缓存了-128到127之间的<code>Integer</code>对象。</li>
<li><code>Integer i1 = Integer.valueOf(100);</code></li>
<li><code>Integer i2 = Integer.valueOf(100);</code></li>
<li><code>System.out.println(i1 == i2); // true</code></li>
<li><code>Integer i3 = Integer.valueOf(200);</code></li>
<li><code>Integer i4 = Integer.valueOf(200);</code></li>
<li><code>System.out.println(i3 == i4); // false</code> (因为超出了缓存范围)</li>
<li><code>Long</code>, <code>Short</code>等包装类也有类似的缓存机制。</li>
</ul>
</li>
<li><strong>数据库连接池 &#x2F; 线程池：</strong><ul>
<li>虽然它们更多被看作是“对象池模式”，但其核心思想与享元模式高度一致——<strong>复用昂贵的对象</strong>。</li>
<li>连接池中的数据库连接 (<code>Connection</code>) 就是享元对象。每次需要连接时，从池中获取一个，用完后归还，而不是频繁地创建和关闭物理连接。</li>
</ul>
</li>
<li><strong>文本编辑器中的字符对象：</strong><ul>
<li>一个文本编辑器中可能会有数百万个字符。如果为每个字符都创建一个对象，内存开销会非常大。</li>
<li>使用享元模式，我们可以为每种字符（’a’, ‘b’, ‘c’ …）只创建一个共享的<code>Character</code>对象（内部状态是字符本身）。而每个字符在文档中的位置、字体、大小、颜色等可以作为外部状态，在使用时传入。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="4-行为型模式-Behavioral-Patterns"><a href="#4-行为型模式-Behavioral-Patterns" class="headerlink" title="4. 行为型模式 (Behavioral Patterns)"></a>4. 行为型模式 (Behavioral Patterns)</h2><ul>
<li><strong>核心关注点：</strong> <strong>对象之间的通信、协作与职责分配。</strong></li>
<li><strong>一句话总结：</strong> 这类模式专注于对象之间的交互，通过优化通信方式和职责划分，来降低系统耦合度，使其更易于理解和维护。</li>
<li><strong>通俗比喻：</strong> 就像一个**“高效的公司团队”**如何协作。<ul>
<li>面对一个任务，团队有多种完成方案（比如“快但贵” vs “慢但省”）。领导可以根据情况选择一个<strong>方案</strong>（<strong>策略模式</strong>）来执行。</li>
<li>一项报销审批需要经过“员工提交 -&gt; 经理审批 -&gt; 总监审批 -&gt; 财务打款”这个<strong>流程链</strong>（<strong>责任链模式</strong>）。</li>
<li>当一个重要项目状态更新时（比如“开发完成”），需要自动<strong>通知</strong>所有相关的测试人员和产品经理（<strong>观察者模式</strong>）。</li>
<li>CEO（<strong>中介者模式</strong>）负责协调各个部门（研发、市场、销售）的工作，避免部门之间直接混乱地沟通。</li>
<li>你需要完成一项复杂操作，但不想立即执行，于是你把这个操作写成一张<strong>任务卡</strong>（<strong>命令模式</strong>），交给执行者在合适的时候去处理。</li>
</ul>
</li>
<li><strong>解决什么问题？</strong><ul>
<li>将请求的发送者和接收者解耦。</li>
<li>将算法或行为封装起来，使它们可以动态地替换。</li>
<li>定义对象之间的一对多依赖关系，实现联动更新。</li>
<li>当一个对象的内部状态改变时，允许其改变行为。</li>
</ul>
</li>
</ul>
<h3 id="4-1-策略模式-Strategy-Pattern"><a href="#4-1-策略模式-Strategy-Pattern" class="headerlink" title="4.1 策略模式 (Strategy Pattern)"></a>4.1 策略模式 (Strategy Pattern)</h3><p>策略模式也称为<strong>政策模式 (Policy Pattern)</strong>。</p>
<h4 id="4-1-1-核心思想"><a href="#4-1-1-核心思想" class="headerlink" title="4.1.1 核心思想"></a>4.1.1 核心思想</h4><p><strong>定义一系列的算法，将每一个算法封装起来，并使它们可以相互替换。策略模式使得算法可以独立于使用它的客户端而变化。</strong></p>
<p>换句话-话说，当一件事情有多种不同的处理方式（即“策略”）时，我们不使用硬编码的 <code>if-else</code> 或 <code>switch-case</code> 来选择，而是将这些处理方式抽象成一个共同的接口，每一种具体的方式都作为该接口的一个实现类。然后，环境（Context）类持有一个策略接口的引用，可以随时切换成不同的具体策略来执行任务。</p>
<p><strong>通俗比喻：出行策略</strong></p>
<ul>
<li><strong>环境 (Context):</strong> 你，一个需要从A地到B地的人。</li>
<li><strong>策略接口 (Strategy):</strong> <code>TravelStrategy</code> 接口，定义了一个 <code>goTo()</code> 方法。</li>
<li><strong>具体策略 (ConcreteStrategy):</strong><ul>
<li><code>ByBusStrategy</code> (乘公交)：省钱，但慢。</li>
<li><code>ByTaxiStrategy</code> (打车)：快，但贵。</li>
<li><code>ByBikeStrategy</code> (骑车)：环保，锻炼身体。</li>
</ul>
</li>
<li><strong>客户端操作：</strong> 你（Context）根据当天的情况（时间、预算、天气）来决定采用哪种出行策略。今天赶时间，你就选择 <code>ByTaxiStrategy</code>；今天天气好想锻炼，你就选择 <code>ByBikeStrategy</code>。你的“出行”这个行为，具体如何执行，是由你当前选择的策略决定的。</li>
</ul>
<hr>
<h4 id="4-1-2-主要作用"><a href="#4-1-2-主要作用" class="headerlink" title="4.1.2 主要作用"></a>4.1.2 主要作用</h4><ol>
<li><strong>消除大量的 <code>if-else</code> &#x2F; <code>switch-case</code>：</strong> 这是策略模式最直接的优点。它将分支逻辑的判断转移到了客户端，而将分支逻辑的执行分发到了各个策略类中，使得代码结构更清晰、更易于维护。</li>
<li><strong>遵循开闭原则 (OCP)：</strong> 当需要增加一种新的策略时，只需增加一个新的策略类即可，完全不需要修改环境类（Context）和已有的策略类。这使得系统扩展性极好。</li>
<li><strong>算法的封装与复用：</strong> 每个策略类封装了一个独立的算法，职责单一。这些策略可以被不同的环境类复用。</li>
<li><strong>客户端可以动态切换策略：</strong> 环境类可以在运行时根据需要更换其内部的策略对象，从而改变其行为。</li>
</ol>
<hr>
<h4 id="4-1-3-实现方式（经典结构）"><a href="#4-1-3-实现方式（经典结构）" class="headerlink" title="4.1.3 实现方式（经典结构）"></a>4.1.3 实现方式（经典结构）</h4><p>策略模式包含三个核心角色：</p>
<ol>
<li><strong>Context (环境类)：</strong><ul>
<li>持有一个 <code>Strategy</code> 接口的引用。</li>
<li>它不实现任何具体的算法，而是将工作委托给当前的策略对象。</li>
<li>它提供一个方法给外部调用，并在内部调用策略对象的方法。</li>
</ul>
</li>
<li><strong>Strategy (抽象策略接口&#x2F;类)：</strong><ul>
<li>定义了所有支持的算法的公共接口。<code>Context</code> 使用这个接口来调用具体策略定义的算法。</li>
</ul>
</li>
<li><strong>ConcreteStrategy (具体策略类)：</strong><ul>
<li>实现了 <code>Strategy</code> 接口，封装了具体的算法或行为。</li>
</ul>
</li>
</ol>
<p><strong>代码示例：电商订单根据不同促销活动计算价格</strong></p>
<p><strong>1. Strategy (抽象策略接口)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象策略：促销活动</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span> <span class="comment">// 这是一个函数式接口，可以用lambda表达式简化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PromotionStrategy</span> &#123;</span><br><span class="line">    <span class="comment">// 计算最终价格</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">applyDiscount</span><span class="params">(<span class="type">double</span> originalPrice)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. ConcreteStrategy (具体策略类)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体策略A：无折扣</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoDiscountStrategy</span> <span class="keyword">implements</span> <span class="title class_">PromotionStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">applyDiscount</span><span class="params">(<span class="type">double</span> originalPrice)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> originalPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略B：满200减20</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FullReductionStrategy</span> <span class="keyword">implements</span> <span class="title class_">PromotionStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">applyDiscount</span><span class="params">(<span class="type">double</span> originalPrice)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> originalPrice &gt;= <span class="number">200</span> ? originalPrice - <span class="number">20</span> : originalPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略C：打8折</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EightFoldStrategy</span> <span class="keyword">implements</span> <span class="title class_">PromotionStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">applyDiscount</span><span class="params">(<span class="type">double</span> originalPrice)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> originalPrice * <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. Context (环境类)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 环境类：订单</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> originalPrice;</span><br><span class="line">    <span class="keyword">private</span> PromotionStrategy strategy; <span class="comment">// 持有策略引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(<span class="type">double</span> originalPrice, PromotionStrategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.originalPrice = originalPrice;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许在运行时更换策略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(PromotionStrategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用策略方法计算最终价格</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getFinalPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.applyDiscount(originalPrice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 客户端使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 场景1：618大促，打8折</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(<span class="number">300</span>, <span class="keyword">new</span> <span class="title class_">EightFoldStrategy</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;618 Event, Final Price: &quot;</span> + order1.getFinalPrice()); <span class="comment">// 输出 240.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 场景2：普通活动，满200减20</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(<span class="number">300</span>, <span class="keyword">new</span> <span class="title class_">FullReductionStrategy</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;Normal Event, Final Price: &quot;</span> + order2.getFinalPrice()); <span class="comment">// 输出 280.0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 场景3：无活动</span></span><br><span class="line">        <span class="comment">// 使用Java 8 Lambda表达式，因为我们的策略接口是函数式接口</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(<span class="number">300</span>, price -&gt; price); </span><br><span class="line">        System.out.println(<span class="string">&quot;No Event, Final Price: &quot;</span> + order3.getFinalPrice()); <span class="comment">// 输出 300.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行时切换策略</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- Strategy changes at runtime ---&quot;</span>);</span><br><span class="line">        order2.setStrategy(<span class="keyword">new</span> <span class="title class_">EightFoldStrategy</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;Price changes to 8-fold discount: &quot;</span> + order2.getFinalPrice()); <span class="comment">// 输出 240.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-1-4-实际解决问题-使用场景"><a href="#4-1-4-实际解决问题-使用场景" class="headerlink" title="4.1.4 实际解决问题 &#x2F; 使用场景"></a>4.1.4 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><strong>JDK中的应用：<code>java.util.Comparator</code></strong><ul>
<li>这是策略模式在JDK中最完美的体现。<code>Collections.sort(list, comparator)</code> 或 <code>list.stream().sorted(comparator)</code> 方法中，<code>comparator</code> 对象就是一个<strong>比较策略</strong>。</li>
<li>你可以传入 <code>Comparator.comparing(User::getAge)</code> 按年龄排序，也可以传入 <code>(u1, u2) -&gt; u1.getName().compareTo(u2.getName())</code> 按姓名排序。每一种 <code>Comparator</code> 的实现都是一个具体的排序策略。</li>
</ul>
</li>
<li><strong>Spring框架中的应用：<code>Resource</code> 加载策略</strong><ul>
<li>Spring的<code>ResourceLoader</code>可以根据不同的资源路径前缀（如<code>classpath:</code>, <code>file:</code>, <code>http:</code>）返回不同类型的<code>Resource</code>实现。<code>ClassPathResource</code>, <code>FileSystemResource</code>, <code>UrlResource</code> 等就是不同的<strong>资源加载策略</strong>。</li>
</ul>
</li>
<li><strong><code>ThreadPoolExecutor</code> 的拒绝策略：</strong><ul>
<li>当线程池和任务队列都满了之后，新提交的任务该如何处理？<code>ThreadPoolExecutor</code> 允许你配置一个<code>RejectedExecutionHandler</code>，这就是一个<strong>拒绝策略</strong>接口。</li>
<li>JDK提供了 <code>AbortPolicy</code> (抛异常), <code>CallerRunsPolicy</code> (调用者自己执行), <code>DiscardPolicy</code> (直接丢弃) 等多种具体策略。</li>
</ul>
</li>
<li><strong>业务场景：</strong><ul>
<li><strong>支付方式选择：</strong> 支付宝支付、微信支付、银行卡支付，每种都是一个支付策略。</li>
<li><strong>文件压缩算法：</strong> 可以选择 <code>ZipStrategy</code>, <code>GzipStrategy</code>, <code>RarStrategy</code> 来压缩文件。</li>
<li><strong>数据验证：</strong> 不同的验证规则（如非空验证、邮箱格式验证、手机号格式验证）可以封装成不同的 <code>ValidationStrategy</code>。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-1-5-策略模式-vs-状态模式"><a href="#4-1-5-策略模式-vs-状态模式" class="headerlink" title="4.1.5 策略模式 vs 状态模式"></a>4.1.5 策略模式 vs 状态模式</h4><p>策略模式和状态模式的UML类图几乎完全相同，但它们的<strong>意图</strong>和<strong>行为</strong>有本质区别：</p>
<ul>
<li><strong>策略模式 (Strategy):</strong><ul>
<li><strong>意图：</strong> 提供一组可相互替换的算法，由<strong>外部客户端</strong>决定在特定时刻使用哪一个。</li>
<li><strong>关系：</strong> 策略之间通常是平行的、无关联的。选择哪个策略与环境类（Context）的内部状态无关。</li>
</ul>
</li>
<li><strong>状态模式 (State):</strong><ul>
<li><strong>意图：</strong> 当一个对象的内部状态改变时，允许其改变行为，看起来就像是改变了它的类。</li>
<li><strong>关系：</strong> 状态的切换通常是由<strong>环境类（Context）自身</strong>或<strong>状态对象内部</strong>控制的，不是由客户端决定的。各个状态之间存在着明确的转移关系。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-2-模板方法模式-Template-Method-Pattern"><a href="#4-2-模板方法模式-Template-Method-Pattern" class="headerlink" title="4.2 模板方法模式 (Template Method Pattern)"></a>4.2 模板方法模式 (Template Method Pattern)</h3><h4 id="4-2-1-核心思想"><a href="#4-2-1-核心思想" class="headerlink" title="4.2.1 核心思想"></a>4.2.1 核心思想</h4><p><strong>在一个抽象类中定义一个算法的骨架（即模板方法），而将算法中一些可变的步骤延迟到子类中去实现。模板方法使得子类可以在不改变算法整体结构的情况下，重新定义算法中的某些特定步骤。</strong></p>
<p>换句话说，父类规定了“做一件事情的流程”，比如“第一步 -&gt; 第二步 -&gt; 第三步”，这个流程是固定不变的。但是，“第二步”具体怎么做，父类并不关心，它只定义一个抽象方法，由各个子类根据自己的情况去实现。</p>
<p><strong>通俗比喻：请假流程</strong></p>
<ul>
<li><strong>抽象类 (AbstractClass):</strong> 公司定义的《请假申请流程》模板。</li>
<li><strong>模板方法 (Template Method):</strong> <code>requestLeave()</code> 方法，它规定了流程：<ol>
<li><code>fillForm()</code>: 填写请假单（具体步骤，由子类实现）。</li>
<li><code>submitToManager()</code>: 提交给经理审批（固定步骤，父类实现）。</li>
<li><code>notifyHR()</code>: 通知人力资源部备案（固定步骤，父类实现）。</li>
</ol>
</li>
<li><strong>具体子类 (ConcreteClass):</strong><ul>
<li><code>SickLeaveProcess</code> (病假流程): <code>fillForm()</code> 时，需要附上医院证明。</li>
<li><code>AnnualLeaveProcess</code> (年假流程): <code>fillForm()</code> 时，只需填写起止日期。</li>
</ul>
</li>
<li><strong>流程执行：</strong> 无论是请病假还是年假，都必须遵循公司定义的整体流程。模板方法模式确保了流程的统一性，同时又允许在具体环节上有灵活性。</li>
</ul>
<hr>
<h4 id="4-2-2-主要作用"><a href="#4-2-2-主要作用" class="headerlink" title="4.2.2 主要作用"></a>4.2.2 主要作用</h4><ol>
<li><strong>封装固定算法，提取公共代码：</strong> 将算法中不变的部分封装在父类的模板方法中，避免了代码的重复。</li>
<li><strong>定义框架骨架：</strong> 这是模板方法模式最重要的应用。框架的开发者定义好一个操作的整体流程和标准，而把可定制的部分作为抽象方法或“钩子”方法，留给框架的使用者去实现。这既保证了框架的稳定性，又提供了扩展性。</li>
<li><strong>行为控制反转：</strong> 父类调用子类的操作（通过调用抽象方法），而不是子类调用父类。这是一种典型的“好莱坞原则”——“Don’t call us, we’ll call you.”（别找我们，我们会找你的）。</li>
</ol>
<hr>
<h4 id="4-2-3-实现方式（经典结构）"><a href="#4-2-3-实现方式（经典结构）" class="headerlink" title="4.2.3 实现方式（经典结构）"></a>4.2.3 实现方式（经典结构）</h4><p>模板方法模式的结构非常简单，主要包含两个角色：</p>
<ol>
<li><strong>AbstractClass (抽象类)：</strong><ul>
<li>定义一个<strong>模板方法 (Template Method)</strong>，通常是 <code>final</code> 的，以防止子类重写算法骨架。</li>
<li>模板方法内部调用了一系列<strong>基本方法 (Primitive Methods)</strong>。</li>
<li>基本方法可以是：<ul>
<li><strong>抽象方法 (Abstract Method)：</strong> 必须由子类实现。</li>
<li><strong>具体方法 (Concrete Method)：</strong> 父类已实现，子类可继承或重写。</li>
<li><strong>钩子方法 (Hook Method)：</strong> 父类提供一个空实现或默认实现，子类可以选择性地重写它来“钩入”流程，影响算法的行为。钩子方法通常返回一个 <code>boolean</code> 值。</li>
</ul>
</li>
</ul>
</li>
<li><strong>ConcreteClass (具体子类)：</strong><ul>
<li>继承自 <code>AbstractClass</code>。</li>
<li>实现父类中定义的抽象方法。</li>
<li>按需重写父类的钩子方法。</li>
</ul>
</li>
</ol>
<p><strong>代码示例：制作不同口味的豆浆</strong></p>
<p><strong>1. AbstractClass (抽象类)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类：豆浆制作机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SoyaMilkMaker</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板方法，定义了制作豆浆的完整流程</span></span><br><span class="line">    <span class="comment">// 声明为final，不希望子类覆盖这个流程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span> &#123;</span><br><span class="line">        select(); <span class="comment">// 1. 选材</span></span><br><span class="line">        <span class="keyword">if</span> (customerWantsCondiments()) &#123; <span class="comment">// 3. 钩子方法决定是否添加配料</span></span><br><span class="line">            addCondiments(); <span class="comment">// 2. 添加配料</span></span><br><span class="line">        &#125;</span><br><span class="line">        soak();   <span class="comment">// 4. 浸泡</span></span><br><span class="line">        beat();   <span class="comment">// 5. 打磨</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Soya milk is ready!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 基本方法 ---</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具体方法，所有子类都一样</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Step 1: Selecting fresh soybeans.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法，由子类实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">soak</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Step 3: Soaking soybeans and condiments.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具体方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">beat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Step 4: Beating...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子方法，子类可以重写来改变行为</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">customerWantsCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 默认需要加配料</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. ConcreteClass (具体子类)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体子类A：红枣豆浆</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedBeanSoyaMilkMaker</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilkMaker</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Step 2: Adding red beans as condiments.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体子类B：花生豆浆</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PeanutSoyaMilkMaker</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilkMaker</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Step 2: Adding peanuts as condiments.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体子类C：纯豆浆（利用钩子方法）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PureSoyaMilkMaker</span> <span class="keyword">extends</span> <span class="title class_">SoyaMilkMaker</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 因为钩子返回false，这个方法永远不会被调用，可以空实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">customerWantsCondiments</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 重写钩子，告诉模板方法不要执行addCondiments步骤</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 客户端使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--- Making Red Bean Soya Milk ---&quot;</span>);</span><br><span class="line">        <span class="type">SoyaMilkMaker</span> <span class="variable">redBeanMaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedBeanSoyaMilkMaker</span>();</span><br><span class="line">        redBeanMaker.make();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- Making Peanut Soya Milk ---&quot;</span>);</span><br><span class="line">        <span class="type">SoyaMilkMaker</span> <span class="variable">peanutMaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PeanutSoyaMilkMaker</span>();</span><br><span class="line">        peanutMaker.make();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- Making Pure Soya Milk ---&quot;</span>);</span><br><span class="line">        <span class="type">SoyaMilkMaker</span> <span class="variable">pureMaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PureSoyaMilkMaker</span>();</span><br><span class="line">        pureMaker.make();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-4-实际解决问题-使用场景"><a href="#4-2-4-实际解决问题-使用场景" class="headerlink" title="4.2.4 实际解决问题 &#x2F; 使用场景"></a>4.2.4 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><strong>JDK中的应用：<code>java.util.AbstractList</code> 等抽象集合类</strong><ul>
<li><code>AbstractList</code> 实现了 <code>List</code> 接口中的大部分方法（如 <code>add</code>, <code>iterator</code>, <code>indexOf</code> 等）。</li>
<li>但它将 <code>get(int index)</code> 和 <code>size()</code> 等核心方法定义为<strong>抽象方法</strong>，留给子类（如 <code>ArrayList</code>, <code>LinkedList</code>）去实现。</li>
<li><code>AbstractList</code> 中的 <code>add(E element)</code> 方法就是一个模板方法，它的实现依赖于子类提供的 <code>add(int index, E element)</code> 方法。这样，框架作者为我们写好了大部分通用逻辑，我们只需实现最核心的部分。</li>
</ul>
</li>
<li><strong>Spring框架中的应用：<code>JDBCTemplate</code></strong><ul>
<li>这是模板方法模式最经典的应用之一。</li>
<li><strong>模板方法：</strong> <code>JDBCTemplate</code> 的 <code>execute()</code>, <code>query()</code> 等方法封装了JDBC操作的完整流程：获取连接 -&gt; 创建<code>Statement</code> -&gt; 执行SQL -&gt; 处理结果集 -&gt; 处理异常 -&gt; <strong>释放资源</strong>。</li>
<li><strong>回调（一种更灵活的模板方法变体）：</strong> <code>JDBCTemplate</code> 并没有使用继承，而是通过传入<code>RowMapper</code>, <code>PreparedStatementSetter</code>等<strong>回调接口</strong>的实现，让你来定义“如何处理结果集”和“如何设置SQL参数”这两个可变步骤。这比传统的继承方式更灵活，避免了Java单继承的限制。</li>
</ul>
</li>
<li><strong>Servlet中的<code>doGet</code>&#x2F;<code>doPost</code>方法：</strong><ul>
<li><code>javax.servlet.http.HttpServlet</code> 类中的 <code>service()</code> 方法是一个模板方法。它负责解析HTTP请求，判断是GET、POST还是其他类型的请求，然后调用相应的 <code>doGet()</code>, <code>doPost()</code> 等方法。</li>
<li><code>doGet()</code> 和 <code>doPost()</code> 默认实现是返回一个错误页，它们相当于留给开发者去重写的“钩子”或抽象方法。我们通过继承<code>HttpServlet</code>并重写<code>doGet/doPost</code>来填充自己的业务逻辑。</li>
</ul>
</li>
<li><strong>JUnit单元测试框架：</strong><ul>
<li>一个测试用例的执行流程通常是：<code>@Before</code> -&gt; <code>@Test</code> 方法 -&gt; <code>@After</code>。JUnit框架定义了这个流程（模板），而我们只需要填充 <code>@Test</code> 方法（具体步骤）的内容。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-3-观察者模式-Observer-Pattern"><a href="#4-3-观察者模式-Observer-Pattern" class="headerlink" title="4.3 观察者模式 (Observer Pattern)"></a>4.3 观察者模式 (Observer Pattern)</h3><p>观察者模式也称为<strong>发布-订阅模式 (Publish-Subscribe Pattern)</strong> 或<strong>依赖模式 (Dependents Pattern)</strong>。</p>
<h4 id="4-3-1-核心思想"><a href="#4-3-1-核心思想" class="headerlink" title="4.3.1 核心思想"></a>4.3.1 核心思想</h4><p><strong>定义对象之间一种一对多（One-to-Many）的依赖关系，当一个对象（被观察者&#x2F;主题）的状态发生改变时，所有依赖于它的对象（观察者）都得到通知并被自动更新。</strong></p>
<p>这个模式的核心在于解耦**“事件的产生方（发布者）”<strong>和</strong>“事件的处理方（订阅者）”**。发布者不需要知道谁订阅了它，也不关心订阅者如何处理事件。它只负责在自身状态变化时，向所有订阅者广播“我变了”这个消息。</p>
<p><strong>通俗比喻：微信公众号与粉丝</strong></p>
<ul>
<li><strong>被观察者&#x2F;主题 (Subject):</strong> 微信公众号，如“Java技术前线”。</li>
<li><strong>观察者 (Observer):</strong> 关注了这个公众号的粉丝们（你，我，他…）。</li>
<li><strong>依赖关系：</strong> 粉丝通过“关注”操作，与公众号建立了依赖关系。</li>
<li><strong>事件触发与通知：</strong> 当公众号发布一篇新文章时（状态变化），微信平台会自动将这篇文章推送给所有关注了它的粉丝。</li>
<li><strong>解耦：</strong> 公众号作者完全不需要知道有哪些粉丝，粉丝的微信号是多少。粉丝之间也互不知晓。作者只需发布文章，粉丝即可收到，实现了松耦合的通信。</li>
</ul>
<hr>
<h4 id="4-3-2-主要作用"><a href="#4-3-2-主要作用" class="headerlink" title="4.3.2 主要作用"></a>4.3.2 主要作用</h4><ol>
<li><strong>建立松耦合的交互关系：</strong> 观察者和被观察者之间是抽象耦合的。被观察者只知道它有一系列观察者（都实现了同一个接口），但不知道具体的观察者是谁，属于哪个类。这大大降低了两者之间的依赖。</li>
<li><strong>支持广播通信：</strong> 被观察者可以向任意数量的观察者发送通知，实现了一对多的高效信息广播。</li>
<li><strong>支持事件驱动架构 (EDA)：</strong> 观察者模式是构建事件驱动系统的基础。系统中的组件通过响应事件来执行操作，而不是通过直接的方法调用，这使得系统更加灵活和可扩展。</li>
<li><strong>符合开闭原则：</strong> 当需要增加一个新的观察者来响应事件时，只需创建一个新的观察者类并将其注册到被观察者中即可，完全不需要修改被观察者的代码，也不需要修改任何已有的观察者代码。</li>
</ol>
<hr>
<h4 id="4-3-3-实现方式（经典结构）"><a href="#4-3-3-实现方式（经典结构）" class="headerlink" title="4.3.3 实现方式（经典结构）"></a>4.3.3 实现方式（经典结构）</h4><p>观察者模式通常包含以下角色：</p>
<ol>
<li><strong>Subject (抽象主题&#x2F;被观察者)：</strong><ul>
<li>提供了一个接口，用于<strong>注册 (attach&#x2F;add)</strong>、<strong>移除 (detach&#x2F;remove)</strong> 和 <strong>通知 (notify)</strong> 观察者。</li>
<li>内部通常维护一个观察者对象的集合（如 <code>List</code>）。</li>
</ul>
</li>
<li><strong>ConcreteSubject (具体主题&#x2F;被观察者)：</strong><ul>
<li>实现了 <code>Subject</code> 接口。</li>
<li>它存储了具体的状态。</li>
<li>当其内部状态发生变化时，会调用 <code>notify()</code> 方法通知所有已注册的观察者。</li>
</ul>
</li>
<li><strong>Observer (抽象观察者)：</strong><ul>
<li>定义了一个<strong>更新接口 (update)</strong>，当被观察者状态发生变化时，这个方法会被调用。</li>
</ul>
</li>
<li><strong>ConcreteObserver (具体观察者)：</strong><ul>
<li>实现了 <code>Observer</code> 接口。</li>
<li>在接收到更新通知后，执行具体的响应逻辑。它可以选择性地从主题对象中拉取（pull）所需的状态信息，或者主题在通知时直接推送（push）信息过来。</li>
</ul>
</li>
</ol>
<p><strong>代码示例：一个天气站向不同的显示面板推送天气数据</strong></p>
<p><strong>1. Observer (抽象观察者)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象观察者：所有需要接收天气数据的设备</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WeatherObserver</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. Subject (抽象主题)</strong> - 在简单场景下可以省略，直接实现具体主题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象主题：定义了注册、移除、通知观察者的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">WeatherStationSubject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(WeatherObserver observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(WeatherObserver observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. ConcreteSubject (具体主题)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体主题：天气数据中心</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherDataCenter</span> <span class="keyword">implements</span> <span class="title class_">WeatherStationSubject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;WeatherObserver&gt; observers;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherDataCenter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(WeatherObserver observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(WeatherObserver observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (WeatherObserver observer : observers) &#123;</span><br><span class="line">            <span class="comment">// 推送(push)模式：将数据直接传给观察者</span></span><br><span class="line">            observer.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当天气数据发生变化时，调用此方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMeasurements</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        System.out.println(<span class="string">&quot;\nWeather data changed. Notifying observers...&quot;</span>);</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. ConcreteObserver (具体观察者)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体观察者A：当前状况显示面板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title class_">WeatherObserver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Current Conditions Display: &quot;</span> + temperature + <span class="string">&quot;F degrees, &quot;</span> </span><br><span class="line">                           + humidity + <span class="string">&quot;% humidity.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者B：天气预报显示面板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ForecastDisplay</span> <span class="keyword">implements</span> <span class="title class_">WeatherObserver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Forecast Display: Weather is improving!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 客户端使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherStationClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建被观察者（天气数据中心）</span></span><br><span class="line">        <span class="type">WeatherDataCenter</span> <span class="variable">weatherData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeatherDataCenter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建观察者（显示面板）</span></span><br><span class="line">        <span class="type">WeatherObserver</span> <span class="variable">currentDisplay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CurrentConditionsDisplay</span>();</span><br><span class="line">        <span class="type">WeatherObserver</span> <span class="variable">forecastDisplay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForecastDisplay</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 注册观察者</span></span><br><span class="line">        weatherData.registerObserver(currentDisplay);</span><br><span class="line">        weatherData.registerObserver(forecastDisplay);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 模拟天气变化，被观察者状态改变</span></span><br><span class="line">        weatherData.setMeasurements(<span class="number">80</span>, <span class="number">65</span>, <span class="number">30.4f</span>);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">82</span>, <span class="number">70</span>, <span class="number">29.2f</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 移除一个观察者</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- A display is removed ---&quot;</span>);</span><br><span class="line">        weatherData.removeObserver(forecastDisplay);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">78</span>, <span class="number">90</span>, <span class="number">29.2f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> JDK 9 废弃了内置的<code>java.util.Observable</code>和<code>java.util.Observer</code>，因为<code>Observable</code>是一个类而不是接口，限制了复用，并且其通知机制不是线程安全的。推荐自己实现或使用<code>java.beans.PropertyChangeListener</code>。</p>
<hr>
<h4 id="4-3-4-实际解决问题-使用场景"><a href="#4-3-4-实际解决问题-使用场景" class="headerlink" title="4.3.4 实际解决问题 &#x2F; 使用场景"></a>4.3.4 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><strong>Spring框架的事件驱动模型：</strong><ul>
<li>这是观察者模式在企业级应用中最核心的体现。</li>
<li><strong>Subject:</strong> <code>ApplicationEventPublisher</code> (通常就是 <code>ApplicationContext</code>)。</li>
<li><strong>Observer:</strong> 任何实现了 <code>ApplicationListener</code> 接口的Bean。</li>
<li><strong>Event:</strong> 继承自 <code>ApplicationEvent</code> 的自定义事件类。</li>
<li>当你在代码中调用 <code>applicationContext.publishEvent(new MyCustomEvent(this))</code> 时，所有监听了<code>MyCustomEvent</code>的<code>ApplicationListener</code> Bean的<code>onApplicationEvent()</code>方法都会被自动调用。这被广泛用于模块间的解耦，例如用户注册成功后，发布一个“用户注册事件”，订单模块和积分模块可以分别监听这个事件来创建初始订单或赠送积分。</li>
</ul>
</li>
<li><strong>GUI事件处理：</strong><ul>
<li>几乎所有的GUI框架（如Java Swing, JavaFX, Android）都基于观察者模式。</li>
<li>一个按钮 (<code>JButton</code>) 是<strong>被观察者</strong>。</li>
<li>你写的 <code>ActionListener</code> 是<strong>观察者</strong>。</li>
<li>通过 <code>button.addActionListener(myListener)</code> 来<strong>注册</strong>观察者。</li>
<li>当用户点击按钮时，按钮会“发布”一个<code>ActionEvent</code>事件，所有注册的<code>ActionListener</code>的<code>actionPerformed()</code>方法就会被调用。</li>
</ul>
</li>
<li><strong>消息队列 (MQ)：</strong><ul>
<li>发布-订阅模式是消息队列（如 Kafka, RabbitMQ）的核心模型。</li>
<li><strong>发布者 (Producer)</strong> 将消息发送到一个<strong>主题 (Topic)</strong>，这是被观察者。</li>
<li><strong>订阅者 (Consumer)</strong> 监听这个Topic。</li>
<li>当有新消息到达Topic时，MQ服务器会将其推送给所有订阅了该Topic的消费者。这实现了分布式系统间的异步解耦。</li>
</ul>
</li>
<li><strong>Java Servlet API中的监听器：</strong><ul>
<li>Servlet规范定义了多种监听器，如 <code>ServletContextListener</code> (监听应用上下文的创建和销毁), <code>HttpSessionListener</code> (监听Session的创建和销毁)。这些都是观察者模式的应用，允许你在特定事件发生时执行自定义逻辑。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-4-责任链模式-Chain-of-Responsibility-Pattern"><a href="#4-4-责任链模式-Chain-of-Responsibility-Pattern" class="headerlink" title="4.4 责任链模式 (Chain of Responsibility Pattern)"></a>4.4 责任链模式 (Chain of Responsibility Pattern)</h3><h4 id="4-4-1-核心思想"><a href="#4-4-1-核心思想" class="headerlink" title="4.4.1 核心思想"></a>4.4.1 核心思想</h4><p><strong>为了避免请求的发送者和接收者之间的耦合，将多个接收者对象连接成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</strong></p>
<p>这个模式的核心在于，请求在链上传递，链上的每个节点都有机会处理这个请求。一个节点处理完后，可以选择将请求<strong>继续向后传递</strong>，也可以选择<strong>终止传递</strong>。这使得请求的处理者可以在运行时动态地组合。</p>
<p><strong>通俗比喻：公司报销审批流程</strong></p>
<ul>
<li><strong>请求 (Request):</strong> 你的一张报销单。</li>
<li><strong>处理者 (Handler):</strong> 项目经理、部门总监、财务。</li>
<li><strong>责任链 (Chain):</strong> <code>项目经理 -&gt; 部门总监 -&gt; 财务</code> 这条审批路径。</li>
<li><strong>流程：</strong><ol>
<li>你将报销单提交给项目经理。</li>
<li>项目经理检查金额，如果小于500元，他有权直接批准（<strong>处理并终止传递</strong>），流程结束。</li>
<li>如果金额大于500元但小于5000元，他签上字，然后将报销单<strong>传递给下一位</strong>——部门总监。</li>
<li>部门总监审批后，再<strong>传递给财务</strong>。</li>
<li>财务最终处理打款。</li>
</ol>
</li>
<li><strong>解耦与灵活性：</strong> 你（请求发送者）只需要知道把报销单交给第一个人（项目经理），而不需要关心后面完整的审批链条是怎样的。如果公司调整流程，在部门总监后增加一个副总裁审批，只需要在链中插入一个节点即可，对你完全透明。</li>
</ul>
<hr>
<h4 id="4-4-2-主要作用"><a href="#4-4-2-主要作用" class="headerlink" title="4.4.2 主要作用"></a>4.4.2 主要作用</h4><ol>
<li><strong>降低耦合度：</strong> 请求的发送者无需知道哪个对象会处理它的请求，它只需将请求发送到链的头部。处理者之间也无需知道彼此的存在，只知道自己的下一个节点是谁。</li>
<li><strong>增强了系统的灵活性和可扩展性：</strong> 可以再运行时动态地增加、删除或重新组织链中的处理者，从而改变处理请求的顺序和责任。</li>
<li><strong>单一职责原则：</strong> 每个处理者类只负责处理自己感兴趣的请求或自己职责范围内的工作，职责清晰。</li>
</ol>
<hr>
<h4 id="4-4-3-实现方式（经典结构）"><a href="#4-4-3-实现方式（经典结构）" class="headerlink" title="4.4.3 实现方式（经典结构）"></a>4.4.3 实现方式（经典结构）</h4><p>责任链模式通常包含以下角色：</p>
<ol>
<li><strong>Handler (抽象处理者)：</strong><ul>
<li>定义了一个处理请求的接口，通常包含一个 <code>handleRequest()</code> 方法。</li>
<li>（可选但常用）包含一个指向下一个处理者 (<code>Handler</code>) 的引用。</li>
</ul>
</li>
<li><strong>ConcreteHandler (具体处理者)：</strong><ul>
<li>实现了 <code>Handler</code> 接口。</li>
<li>它判断自己能否处理当前请求。</li>
<li>如果能处理，就进行处理，并决定是否要将请求继续传递给下一个处理者。</li>
<li>如果不能处理，就直接将请求转发给下一个处理者。</li>
</ul>
</li>
<li><strong>Client (客户端)：</strong><ul>
<li>创建并组装责任链。</li>
<li>将请求发送到链的第一个处理者。</li>
</ul>
</li>
</ol>
<p><strong>代码示例：请假审批流程</strong></p>
<p><strong>1. 抽象处理者 (Handler)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象处理者：审批人</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Approver nextApprover; <span class="comment">// 持有下一个处理者的引用</span></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Approver</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置下一个处理者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Approver approver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextApprover = approver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求的抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(LeaveRequest request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 请求类 (Request)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求类：请假条</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeaveRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> days;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeaveRequest</span><span class="params">(<span class="type">int</span> days)</span> &#123; <span class="built_in">this</span>.days = days; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDays</span><span class="params">()</span> &#123; <span class="keyword">return</span> days; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 具体处理者 (ConcreteHandler)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体处理者A：项目经理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProjectManager</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProjectManager</span><span class="params">(String name)</span> &#123; <span class="built_in">super</span>(name); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(LeaveRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getDays() &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Project Manager &quot;</span> + name + <span class="string">&quot; approved the request for &quot;</span> + request.getDays() + <span class="string">&quot; days.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextApprover != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Project Manager &quot;</span> + name + <span class="string">&quot; cannot handle. Passing to the next.&quot;</span>);</span><br><span class="line">            nextApprover.processRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者B：部门总监</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DepartmentDirector</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DepartmentDirector</span><span class="params">(String name)</span> &#123; <span class="built_in">super</span>(name); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(LeaveRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getDays() &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Department Director &quot;</span> + name + <span class="string">&quot; approved the request for &quot;</span> + request.getDays() + <span class="string">&quot; days.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextApprover != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Department Director &quot;</span> + name + <span class="string">&quot; cannot handle. Passing to the next.&quot;</span>);</span><br><span class="line">            nextApprover.processRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理者C：CEO</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CEO</span> <span class="keyword">extends</span> <span class="title class_">Approver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CEO</span><span class="params">(String name)</span> &#123; <span class="built_in">super</span>(name); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(LeaveRequest request)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CEO &quot;</span> + name + <span class="string">&quot; approved the request for &quot;</span> + request.getDays() + <span class="string">&quot; days.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 客户端使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建处理者</span></span><br><span class="line">        <span class="type">Approver</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProjectManager</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="type">Approver</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DepartmentDirector</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        <span class="type">Approver</span> <span class="variable">ceo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CEO</span>(<span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 组装责任链</span></span><br><span class="line">        manager.setNext(director);</span><br><span class="line">        director.setNext(ceo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建并提交请求</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--- Request for 1 day ---&quot;</span>);</span><br><span class="line">        manager.processRequest(<span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="number">1</span>)); <span class="comment">// 项目经理处理</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- Request for 4 days ---&quot;</span>);</span><br><span class="line">        manager.processRequest(<span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="number">4</span>)); <span class="comment">// 部门总监处理</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- Request for 10 days ---&quot;</span>);</span><br><span class="line">        manager.processRequest(<span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="number">10</span>)); <span class="comment">// CEO处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-4-4-纯与不纯的责任链"><a href="#4-4-4-纯与不纯的责任链" class="headerlink" title="4.4.4 纯与不纯的责任链"></a>4.4.4 纯与不纯的责任链</h4><ul>
<li><strong>纯责任链：</strong> 要求一个请求必须被链上的<strong>某一个</strong>处理者处理。处理者要么处理请求，要么把它传递给下一个，自己不能既处理一部分又向下传递。</li>
<li><strong>不纯责任链（更常见）：</strong> 允许一个处理者处理请求的一部分，然后<strong>继续</strong>把它传递给下一个处理者，让后续的处理者可以继续对请求进行处理。这种方式更像是“流水线”或“过滤器”。</li>
</ul>
<hr>
<h4 id="4-4-5-实际解决问题-使用场景"><a href="#4-4-5-实际解决问题-使用场景" class="headerlink" title="4.4.5 实际解决问题 &#x2F; 使用场景"></a>4.4.5 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><strong>Java Servlet的<code>Filter</code>链（最经典案例）：</strong><ul>
<li>这是一个典型的<strong>不纯责任链</strong>。</li>
<li>当一个HTTP请求到达服务器时，它会经过一个由多个<code>Filter</code>组成的链。</li>
<li>每个<code>Filter</code>（如编码过滤器、安全过滤器、日志过滤器）都是一个<strong>处理者</strong>。</li>
<li>在<code>Filter</code>的<code>doFilter()</code>方法中，你可以对<code>request</code>和<code>response</code>进行处理（比如设置字符编码），然后通过调用<code>filterChain.doFilter(request, response)</code>将请求<strong>传递给链中的下一个<code>Filter</code></strong>。</li>
<li>最后一个<code>Filter</code>会将请求传递给目标<code>Servlet</code>。</li>
</ul>
</li>
<li><strong>Spring Security的过滤器链：</strong><ul>
<li>Spring Security通过一系列的过滤器来保护Web请求。例如<code>UsernamePasswordAuthenticationFilter</code>负责处理登录请求，<code>ExceptionTranslationFilter</code>负责处理安全异常，<code>FilterSecurityInterceptor</code>负责进行授权决策。这些过滤器组成了一条责任链，对每个请求进行层层检查和处理。</li>
</ul>
</li>
<li><strong>MyBatis的插件（Plugin）机制：</strong><ul>
<li>MyBatis允许开发者通过插件（<code>Interceptor</code>）来拦截其四大核心对象（<code>Executor</code>, <code>ParameterHandler</code>, <code>ResultSetHandler</code>, <code>StatementHandler</code>）的方法调用。</li>
<li>你可以定义多个<code>Interceptor</code>，MyBatis会将它们组织成一个<strong>拦截器链</strong>。当核心对象的方法被调用时，会依次经过链上所有<code>Interceptor</code>的<code>intercept()</code>方法，这为你提供了在SQL执行的各个阶段进行干预的机会（如分页、数据脱敏等）。</li>
</ul>
</li>
<li><strong>日志框架的级别过滤：</strong><ul>
<li>日志框架（如Log4j）中的<code>Logger</code>可以形成父子关系，构成一个树形结构。当一个<code>Logger</code>记录日志时，如果它没有配置<code>Appender</code>，它会把日志事件传递给它的父<code>Logger</code>，形成一个向上传递的责任链，直到找到一个可以处理该日志的<code>Logger</code>或到达根<code>Logger</code>。</li>
</ul>
</li>
<li><strong>异常处理机制 (try-catch-finally)：</strong><ul>
<li>Java的<code>try-catch</code>块在概念上也类似责任链。当<code>try</code>块中抛出一个异常时，系统会沿着<code>catch</code>块组成的“链”去寻找能够处理该类型异常的<code>catch</code>块。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-5-命令模式-Command-Pattern"><a href="#4-5-命令模式-Command-Pattern" class="headerlink" title="4.5 命令模式 (Command Pattern)"></a>4.5 命令模式 (Command Pattern)</h3><h4 id="4-5-1-核心思想"><a href="#4-5-1-核心思想" class="headerlink" title="4.5.1 核心思想"></a>4.5.1 核心思想</h4><p><strong>将一个请求封装成一个对象，从而可以使用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</strong></p>
<p>这个模式的核心是将“行为的请求者”和“行为的实现者”完全解耦。它们之间通过一个“命令对象”作为中介进行通信。命令对象封装了关于某个操作的所有信息：它知道谁是接收者（Receiver），以及要调用接收者的哪个方法。</p>
<p><strong>通俗比喻：去餐厅点餐</strong></p>
<ul>
<li><strong>客户端 (Client):</strong> 你，点餐的顾客。</li>
<li><strong>调用者 (Invoker):</strong> 服务员。他负责接收你的点餐请求，并传递给后厨。</li>
<li><strong>命令对象 (Command):</strong> 菜单上的每一项或你写下的点餐单，例如“一份宫保鸡丁”。这张单子本身就是一个命令对象。</li>
<li><strong>接收者 (Receiver):</strong> 后厨的厨师。他才是真正执行“做宫保鸡丁”这个动作的人。</li>
<li><strong>流程：</strong><ol>
<li>你（Client）决定要吃什么，然后创建了一个“宫保鸡丁”的命令（点菜）。</li>
<li>你把这个命令交给了服务员（Invoker）。</li>
<li>服务员将点餐单（Command）贴到后厨的板子上（请求排队）。</li>
<li>厨师（Receiver）拿到单子，看到“宫保鸡丁”，就开始炒菜（执行命令）。</li>
</ol>
</li>
<li><strong>解耦：</strong> 你不需要认识厨师，服务员也不需要会炒菜。服务员只负责传递命令。如果厨师换了，对你和服务员都没有影响。如果想“撤销”命令（退菜），服务员可以把单子从板子上拿下来。</li>
</ul>
<hr>
<h4 id="4-5-2-主要作用"><a href="#4-5-2-主要作用" class="headerlink" title="4.5.2 主要作用"></a>4.5.2 主要作用</h4><ol>
<li><strong>解耦请求发送者和接收者：</strong> 调用者 <code>Invoker</code> 和接收者 <code>Receiver</code> 之间没有任何直接的依赖关系。<code>Invoker</code> 只与抽象的 <code>Command</code> 接口交互。</li>
<li><strong>封装请求：</strong> 将请求本身变成一个完整的对象，可以像其他对象一样被传递、存储、序列化。</li>
<li><strong>支持请求排队和调度：</strong> 可以将命令对象放入队列中（如 <code>BlockingQueue</code>），然后由一个工作线程池来依次取出并执行，实现异步处理或任务调度。</li>
<li><strong>支持撤销(Undo)和重做(Redo)操作：</strong> 命令模式是实现撤销&#x2F;重做功能最经典的方案。只需在命令接口中增加一个 <code>undo()</code> 方法，并在命令对象中保存执行前的状态即可。</li>
<li><strong>组合命令：</strong> 可以将多个简单的命令组合成一个复杂的“宏命令 (Macro Command)”，一次性执行一系列操作。</li>
</ol>
<hr>
<h4 id="4-5-3-实现方式（经典结构）"><a href="#4-5-3-实现方式（经典结构）" class="headerlink" title="4.5.3 实现方式（经典结构）"></a>4.5.3 实现方式（经典结构）</h4><p>命令模式通常包含以下角色：</p>
<ol>
<li><strong>Command (抽象命令接口)：</strong><ul>
<li>声明一个执行操作的接口，通常是 <code>execute()</code>。</li>
<li>（可选）声明一个撤销操作的接口 <code>undo()</code>。</li>
</ul>
</li>
<li><strong>ConcreteCommand (具体命令类)：</strong><ul>
<li>实现了 <code>Command</code> 接口。</li>
<li>内部持有一个<strong>接收者 (Receiver)</strong> 对象的引用。</li>
<li><code>execute()</code> 方法的实现是调用接收者的某个具体动作（<code>action()</code>）。</li>
</ul>
</li>
<li><strong>Receiver (接收者)：</strong><ul>
<li>知道如何实施和执行一个请求相关的操作。任何类都可能成为一个接收者，它包含了真正的业务逻辑。</li>
</ul>
</li>
<li><strong>Invoker (调用者)：</strong><ul>
<li>持有一个或多个 <code>Command</code> 对象。</li>
<li>在需要时，调用 <code>Command</code> 对象的 <code>execute()</code> 方法。它不关心命令是如何被执行的。</li>
</ul>
</li>
<li><strong>Client (客户端)：</strong><ul>
<li>创建具体命令 <code>ConcreteCommand</code> 对象，并设置其接收者 <code>Receiver</code>。</li>
<li>将命令对象传递给调用者 <code>Invoker</code>。</li>
</ul>
</li>
</ol>
<p><strong>代码示例：一个智能家居的遥控器</strong></p>
<p><strong>1. Receiver (接收者)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收者：电灯</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Light</span><span class="params">(String location)</span> &#123; <span class="built_in">this</span>.location = location; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123; System.out.println(location + <span class="string">&quot; light is ON.&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123; System.out.println(location + <span class="string">&quot; light is OFF.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收者：电视</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;TV is ON.&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;TV is OFF.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. Command (抽象命令接口)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象命令接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span>; <span class="comment">// 支持撤销</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. ConcreteCommand (具体命令类)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体命令：开灯命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightOnCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LightOnCommand</span><span class="params">(Light light)</span> &#123; <span class="built_in">this</span>.light = light; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123; light.on(); &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span> &#123; light.off(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体命令：关灯命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LightOffCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LightOffCommand</span><span class="params">(Light light)</span> &#123; <span class="built_in">this</span>.light = light; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123; light.off(); &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span> &#123; light.on(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空命令，用于处理遥控器上未设置功能的按钮，避免空指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;No command is assigned.&quot;</span>); &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;No command to undo.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. Invoker (调用者)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用者：遥控器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command[] onCommands;</span><br><span class="line">    <span class="keyword">private</span> Command[] offCommands;</span><br><span class="line">    <span class="keyword">private</span> Command lastCommand; <span class="comment">// 用于撤销</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteControl</span><span class="params">()</span> &#123;</span><br><span class="line">        onCommands = <span class="keyword">new</span> <span class="title class_">Command</span>[<span class="number">7</span>];</span><br><span class="line">        offCommands = <span class="keyword">new</span> <span class="title class_">Command</span>[<span class="number">7</span>];</span><br><span class="line">        <span class="type">Command</span> <span class="variable">noCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NoCommand</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            onCommands[i] = noCommand;</span><br><span class="line">            offCommands[i] = noCommand;</span><br><span class="line">        &#125;</span><br><span class="line">        lastCommand = noCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(<span class="type">int</span> slot, Command onCommand, Command offCommand)</span> &#123;</span><br><span class="line">        onCommands[slot] = onCommand;</span><br><span class="line">        offCommands[slot] = offCommand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onButtonWasPushed</span><span class="params">(<span class="type">int</span> slot)</span> &#123;</span><br><span class="line">        onCommands[slot].execute();</span><br><span class="line">        lastCommand = onCommands[slot];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offButtonWasPushed</span><span class="params">(<span class="type">int</span> slot)</span> &#123;</span><br><span class="line">        offCommands[slot].execute();</span><br><span class="line">        lastCommand = offCommands[slot];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undoButtonWasPushed</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Undo: &quot;</span>);</span><br><span class="line">        lastCommand.undo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. Client (客户端)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建调用者</span></span><br><span class="line">        <span class="type">RemoteControl</span> <span class="variable">remote</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteControl</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 创建接收者</span></span><br><span class="line">        <span class="type">Light</span> <span class="variable">livingRoomLight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>(<span class="string">&quot;Living Room&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 创建具体命令，并绑定接收者</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">livingRoomLightOn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightOnCommand</span>(livingRoomLight);</span><br><span class="line">        <span class="type">Command</span> <span class="variable">livingRoomLightOff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightOffCommand</span>(livingRoomLight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将命令设置到调用者</span></span><br><span class="line">        remote.setCommand(<span class="number">0</span>, livingRoomLightOn, livingRoomLightOff);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 调用者执行操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--- Pushing ON button ---&quot;</span>);</span><br><span class="line">        remote.onButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;--- Pushing OFF button ---&quot;</span>);</span><br><span class="line">        remote.offButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;--- Pushing UNDO button ---&quot;</span>);</span><br><span class="line">        remote.undoButtonWasPushed(); <span class="comment">// 撤销关灯，即开灯</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;--- Pushing ON button again ---&quot;</span>);</span><br><span class="line">        remote.onButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;--- Pushing UNDO button again ---&quot;</span>);</span><br><span class="line">        remote.undoButtonWasPushed(); <span class="comment">// 撤销开灯，即关灯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-5-4-实际解决问题-使用场景"><a href="#4-5-4-实际解决问题-使用场景" class="headerlink" title="4.5.4 实际解决问题 &#x2F; 使用场景"></a>4.5.4 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><strong>JDK中的<code>Runnable</code>接口：</strong><ul>
<li><code>java.lang.Runnable</code> 是命令模式的一个典型实现。</li>
<li><code>Runnable</code> 对象本身就是一个<strong>命令对象</strong>，它的 <code>run()</code> 方法相当于 <code>execute()</code>。</li>
<li><code>Thread</code> 类是<strong>调用者 (Invoker)</strong>。你可以把任何 <code>Runnable</code> 对象传给一个 <code>Thread</code>。</li>
<li>当你调用 <code>thread.start()</code> 时，<code>Thread</code> 会在某个时刻调用 <code>Runnable</code> 的 <code>run()</code> 方法。<code>Thread</code> 完全不知道 <code>run()</code> 方法里会做什么，实现了线程调度与具体任务的解耦。</li>
</ul>
</li>
<li><strong>Spring框架的<code>JDBCTemplate</code>与回调：</strong><ul>
<li>虽然 <code>JDBCTemplate</code> 是模板方法模式的典范，但其回调接口（如 <code>StatementCallback</code>, <code>RowMapper</code>）的设计也蕴含了命令模式的思想。</li>
<li>你创建的<code>StatementCallback</code>匿名内部类或Lambda表达式，就是一个<strong>命令对象</strong>，它封装了你想要在数据库连接上执行的一系列操作。</li>
<li><code>JDBCTemplate</code> 是<strong>调用者</strong>，它负责管理数据库连接、事务等资源，并在合适的时机调用你的回调（命令）的 <code>doInStatement()</code> 方法。</li>
</ul>
</li>
<li><strong>图形界面的菜单项、按钮点击：</strong><ul>
<li>一个菜单项或工具栏按钮（<code>JMenuItem</code>, <code>JButton</code>）可以被看作是<strong>调用者 (Invoker)</strong>。</li>
<li><code>javax.swing.Action</code> 接口是<strong>命令接口</strong>的绝佳例子。它不仅包含了 <code>actionPerformed(ActionEvent e)</code> 方法（相当于<code>execute</code>），还包含了文本、图标、快捷键等元数据。</li>
<li>你可以将一个 <code>Action</code> 对象同时设置给一个菜单项和一个工具栏按钮，它们会共享状态并触发相同的操作，实现了逻辑的复用和解耦。</li>
</ul>
</li>
<li><strong>任务队列和工作流引擎：</strong><ul>
<li>在复杂的业务流程中，可以将每一步操作封装成一个命令对象，然后按照顺序放入一个队列中。</li>
<li>一个或多个工作线程可以从队列中取出命令并执行。这使得流程可以被持久化、可以被重试（如果命令执行失败）、可以被监控。</li>
</ul>
</li>
<li><strong>实现撤销&#x2F;重做：</strong><ul>
<li>任何需要实现Undo&#x2F;Redo功能的编辑器（文本编辑器、图形编辑器），几乎都离不开命令模式。通过一个栈来保存已执行的命令，<code>undo</code> 操作就是从栈顶弹出一个命令并调用其 <code>undo()</code> 方法，<code>redo</code> 操作则需要另一个栈来支持。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-6-迭代器模式-Iterator-Pattern"><a href="#4-6-迭代器模式-Iterator-Pattern" class="headerlink" title="4.6 迭代器模式 (Iterator Pattern)"></a>4.6 迭代器模式 (Iterator Pattern)</h3><p>迭代器模式也称为<strong>游标模式 (Cursor Pattern)</strong>。</p>
<h4 id="4-6-1-核心思想"><a href="#4-6-1-核心思想" class="headerlink" title="4.6.1 核心思想"></a>4.6.1 核心思想</h4><p><strong>提供一种方法来顺序访问一个聚合对象（如列表、集合）中的各个元素，而又不需要暴露该对象的内部表示。</strong></p>
<p>这个模式的核心在于将<strong>遍历聚合对象的职责</strong>从聚合对象本身分离出来，转移到一个独立的“迭代器”对象中。这样做的好处是，客户端无需关心聚合对象的内部结构（是数组、链表还是哈希表），只需要通过统一的迭代器接口即可进行遍历。</p>
<p><strong>通俗比喻：电视遥控器</strong></p>
<ul>
<li><strong>聚合对象 (Aggregate):</strong> 电视机。它内部存储了大量的频道（元素），其存储方式可能非常复杂（比如有线频道、卫星频道、网络频道等）。</li>
<li><strong>迭代器 (Iterator):</strong> 遥控器。</li>
<li><strong>客户端 (Client):</strong> 你，看电视的人。</li>
<li><strong>流程：</strong><ul>
<li>你不需要打开电视机后盖，去了解它的电路板和频道存储芯片是如何工作的。</li>
<li>你只需要使用遥控器这个统一的工具。遥控器上有“下一个频道” (<code>next()</code>) 和“上一个频道” (<code>previous()</code>) 按钮。</li>
<li>你通过遥控器，就可以顺序地（或按需）访问电视机里的所有频道，而完全不用关心这些频道在电视机内部是如何组织的。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-6-2-主要作用"><a href="#4-6-2-主要作用" class="headerlink" title="4.6.2 主要作用"></a>4.6.2 主要作用</h4><ol>
<li><strong>封装内部结构：</strong> 隐藏了聚合对象的复杂内部实现（如数据结构），客户端只能通过迭代器访问，保护了聚合对象的封装性。</li>
<li><strong>提供统一的遍历接口：</strong> 无论聚合对象是 <code>ArrayList</code>、<code>LinkedList</code> 还是 <code>HashSet</code>，客户端都使用相同的 <code>Iterator</code> 接口（<code>hasNext()</code>, <code>next()</code>）进行遍历，使得客户端代码更加通用和可复用。</li>
<li><strong>支持多种遍历方式：</strong> 一个聚合对象可以提供多种不同的迭代器。例如，一个树结构可以提供前序遍历迭代器、中序遍历迭代器和后序遍历迭代器。</li>
<li><strong>简化聚合对象：</strong> 聚合对象本身不再需要承担遍历的职责，其代码可以更专注于自身的业务逻辑（如增、删、改、查）。</li>
</ol>
<hr>
<h4 id="4-6-3-实现方式（经典结构）"><a href="#4-6-3-实现方式（经典结构）" class="headerlink" title="4.6.3 实现方式（经典结构）"></a>4.6.3 实现方式（经典结构）</h4><p>迭代器模式通常包含以下角色：</p>
<ol>
<li><strong>Iterator (抽象迭代器)：</strong><ul>
<li>定义了访问和遍历元素所需的核心接口，通常包括：<ul>
<li><code>hasNext()</code>: 检查是否存在下一个元素。</li>
<li><code>next()</code>: 返回下一个元素，并移动游标。</li>
<li><code>remove()</code>: (可选) 删除迭代器最后一次返回的元素。</li>
</ul>
</li>
</ul>
</li>
<li><strong>ConcreteIterator (具体迭代器)：</strong><ul>
<li>实现了 <code>Iterator</code> 接口。</li>
<li>内部维护着对具体聚合对象的引用以及遍历的当前位置（游标）。</li>
<li>负责实现具体的遍历算法。</li>
</ul>
</li>
<li><strong>Aggregate (抽象聚合)：</strong><ul>
<li>定义了一个创建相应迭代器对象的接口，通常是 <code>createIterator()</code> 或 <code>iterator()</code>。</li>
</ul>
</li>
<li><strong>ConcreteAggregate (具体聚合)：</strong><ul>
<li>实现了 <code>Aggregate</code> 接口。</li>
<li>它持有具体的数据结构（如数组、列表）。</li>
<li><code>createIterator()</code> 方法会返回一个与该聚合对象匹配的 <code>ConcreteIterator</code> 实例。</li>
</ul>
</li>
</ol>
<p><strong>代码示例：自定义一个简单的班级，并为其提供迭代器</strong></p>
<p><strong>1. Aggregate (抽象聚合)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象聚合接口，在Java中通常直接使用Iterable接口</span></span><br><span class="line"><span class="comment">// 我们这里自定义一个</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ClassAggregate</span> &#123;</span><br><span class="line">    ClassIterator <span class="title function_">createIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. Iterator (抽象迭代器)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象迭代器接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ClassIterator</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    Student <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. ConcreteAggregate (具体聚合)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体聚合类：班级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassRoom</span> <span class="keyword">implements</span> <span class="title class_">ClassAggregate</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Student[] students;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录当前学生数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassRoom</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.students = <span class="keyword">new</span> <span class="title class_">Student</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (last &lt; students.length) &#123;</span><br><span class="line">            <span class="built_in">this</span>.students[last] = student;</span><br><span class="line">            last++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStudentAt</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> students[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ClassIterator <span class="title function_">createIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClassRoomIterator</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. ConcreteIterator (具体迭代器)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体迭代器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassRoomIterator</span> <span class="keyword">implements</span> <span class="title class_">ClassIterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ClassRoom classRoom;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassRoomIterator</span><span class="params">(ClassRoom classRoom)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classRoom = classRoom;</span><br><span class="line">        <span class="built_in">this</span>.index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; classRoom.getLength();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasNext()) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> classRoom.getStudentAt(index);</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">return</span> student;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 客户端使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建聚合对象</span></span><br><span class="line">        <span class="type">ClassRoom</span> <span class="variable">classRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassRoom</span>(<span class="number">4</span>);</span><br><span class="line">        classRoom.addStudent(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">        classRoom.addStudent(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">        classRoom.addStudent(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Charlie&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取迭代器</span></span><br><span class="line">        <span class="type">ClassIterator</span> <span class="variable">iterator</span> <span class="operator">=</span> classRoom.createIterator();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用迭代器进行遍历，客户端不关心ClassRoom内部是数组还是其他结构</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;Student Name: &quot;</span> + student.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-6-4-实际解决问题-使用场景"><a href="#4-6-4-实际解决问题-使用场景" class="headerlink" title="4.6.4 实际解决问题 &#x2F; 使用场景"></a>4.6.4 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><p><strong>Java集合框架（最核心、最普遍的应用）：</strong></p>
<ul>
<li><p><code>java.util.Iterator</code> 是<strong>抽象迭代器</strong>。</p>
</li>
<li><p><code>java.lang.Iterable</code> 是<strong>抽象聚合</strong>，所有<code>Collection</code>子接口都继承了它。它只有一个方法 <code>iterator()</code>，用于返回一个<code>Iterator</code>。</p>
</li>
<li><p><code>ArrayList</code>, <code>LinkedList</code>, <code>HashSet</code> 等是<strong>具体聚合</strong>。</p>
</li>
<li><p>每个集合类都提供了一个内部类作为其<strong>具体迭代器</strong>（如 <code>ArrayList</code> 的 <code>Itr</code>），这个迭代器知道如何遍历其宿主集合的数据结构。</p>
</li>
<li><p>正是因为迭代器模式，我们才能写出通用的 <code>for-each</code> 循环，它在编译后就会被转换为使用<code>Iterator</code>的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// for-each 循环是迭代器模式的语法糖</span></span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的代码等价于：</span></span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>数据库查询结果集<code>ResultSet</code>：</strong></p>
<ul>
<li><code>java.sql.ResultSet</code> 在概念上也是一个迭代器。它封装了从数据库返回的行数据（聚合对象），并提供了<code>next()</code>方法来移动到下一行，以及<code>getString()</code>, <code>getInt()</code>等方法来获取当前行的数据。你不需要知道这些数据在数据库驱动内部是如何被缓存和管理的。</li>
</ul>
</li>
<li><p><strong>扫描器<code>Scanner</code>：</strong></p>
<ul>
<li><code>java.util.Scanner</code> 可以看作是针对输入流（<code>InputStream</code>）的迭代器。它提供了<code>hasNextInt()</code>, <code>nextInt()</code>, <code>hasNextLine()</code>, <code>nextLine()</code>等方法，让你能够按需从流中顺序地读取不同类型的数据。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-6-5-迭代器模式的注意事项：Fail-Fast机制"><a href="#4-6-5-迭代器模式的注意事项：Fail-Fast机制" class="headerlink" title="4.6.5 迭代器模式的注意事项：Fail-Fast机制"></a>4.6.5 迭代器模式的注意事项：Fail-Fast机制</h4><p>Java集合框架中的迭代器大多是**快速失败（Fail-Fast）**的。这意味着如果在迭代过程中，聚合对象被**迭代器自身以外的方式**修改了（例如，在<code>for-each</code>循环中直接调用<code>list.remove()</code>），迭代器在下一次调用<code>next()</code>或<code>hasNext()</code>时会立即抛出<code>ConcurrentModificationException</code>异常。</p>
<p>这是通过在迭代器内部维护一个期望的修改计数值（<code>expectedModCount</code>）和在集合内部维护一个实际的修改计数值（<code>modCount</code>）来实现的。每次迭代时检查两者是否相等，不相等则说明集合被外部修改了。</p>
<hr>
<h3 id="4-7-中介者模式-Mediator-Pattern"><a href="#4-7-中介者模式-Mediator-Pattern" class="headerlink" title="4.7 中介者模式 (Mediator Pattern)"></a>4.7 中介者模式 (Mediator Pattern)</h3><h4 id="4-7-1-核心思想"><a href="#4-7-1-核心思想" class="headerlink" title="4.7.1 核心思想"></a>4.7.1 核心思想</h4><p><strong>用一个中介对象（Mediator）来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</strong></p>
<p>这个模式将一个系统中复杂的**网状（Many-to-Many）<strong>依赖关系，转变为一个简单的</strong>星形（One-to-Many）**依赖关系。所有的对象（被称为“同事类”，Colleague）不再直接通信，而是都通过中介者来协调。</p>
<p><strong>通俗比喻：机场控制塔</strong></p>
<ul>
<li><strong>同事类 (Colleague):</strong> 天空中的多架飞机。</li>
<li><strong>中介者 (Mediator):</strong> 机场的控制塔。</li>
<li><strong>问题场景（没有中介者）：</strong> 如果没有控制塔，每架飞机为了安全降落，都必须与其他所有飞机直接通信，以协调航线和降落顺序。这将是一个极其复杂和危险的通信网络。</li>
<li><strong>解决方案（使用中介者）：</strong><ol>
<li>所有飞机都只与控制塔通信。</li>
<li>一架飞机（如<code>Airbus A380</code>）向控制塔请求降落。</li>
<li>控制塔根据当前所有飞机的位置和跑道情况（它掌握全局信息），向<code>A380</code>发出“可以降落”的指令，并可能同时向其他飞机（如<code>Boeing 747</code>）发出“在空中盘旋等待”的指令。</li>
</ol>
</li>
<li><strong>解耦效果：</strong> 任何一架飞机都不需要知道其他飞机的存在，它只需要听从控制塔的调度即可。控制塔集中了所有复杂的协调逻辑。</li>
</ul>
<hr>
<h4 id="4-7-2-主要作用"><a href="#4-7-2-主要作用" class="headerlink" title="4.7.2 主要作用"></a>4.7.2 主要作用</h4><ol>
<li><strong>降低类间耦合：</strong> 将原本错综复杂的网状依赖关系，简化为各个同事类与中介者之间的单一依赖，极大地降低了系统的耦合度。</li>
<li><strong>集中控制交互：</strong> 将对象之间复杂的交互逻辑和通信细节，全部封装在中介者对象中，使得这部分逻辑更易于管理和维护。</li>
<li><strong>提高对象的可复用性：</strong> 同事类因为只依赖中介者，而不依赖其他同事类，所以它们可以被轻松地复用在不同的中介者环境中。</li>
<li><strong>符合单一职责原则：</strong> 同事类只负责自己的业务逻辑，而中介者只负责对象间的协调，各司其职。</li>
</ol>
<hr>
<h4 id="4-7-3-实现方式（经典结构）"><a href="#4-7-3-实现方式（经典结构）" class="headerlink" title="4.7.3 实现方式（经典结构）"></a>4.7.3 实现方式（经典结构）</h4><p>中介者模式通常包含以下角色：</p>
<ol>
<li><strong>Mediator (抽象中介者)：</strong><ul>
<li>定义了同事类与中介者之间通信的接口，通常包括一个用于发送消息的方法。</li>
</ul>
</li>
<li><strong>ConcreteMediator (具体中介者)：</strong><ul>
<li>实现了 <code>Mediator</code> 接口。</li>
<li>它需要知道并维护所有的 <code>ConcreteColleague</code> 对象。</li>
<li>负责实现具体的协调逻辑，接收来自某个同事的消息，并根据消息内容决定向其他同事发送什么指令。</li>
</ul>
</li>
<li><strong>Colleague (抽象同事类)：</strong><ul>
<li>定义了各个同事类共有的接口。</li>
<li>内部持有一个 <code>Mediator</code> 对象的引用。</li>
</ul>
</li>
<li><strong>ConcreteColleague (具体同事类)：</strong><ul>
<li>实现了 <code>Colleague</code> 接口。</li>
<li>每个同事类只知道自己的行为，当需要与其他同事交互时，它会通知中介者。</li>
</ul>
</li>
</ol>
<p><strong>代码示例：一个简单的聊天室</strong></p>
<p><strong>1. Mediator (抽象中介者)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象中介者：聊天室</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChatRoom</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(User fromUser, String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. Colleague (抽象同事类)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象同事类：用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> ChatRoom chatRoom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, ChatRoom chatRoom)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.chatRoom = chatRoom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String message)</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. ConcreteMediator (具体中介者)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体中介者：聊天室实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleChatRoom</span> <span class="keyword">implements</span> <span class="title class_">ChatRoom</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; users;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleChatRoom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.users.add(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(User fromUser, String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 协调逻辑：将消息发送给除了发送者以外的所有人</span></span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            <span class="keyword">if</span> (user != fromUser) &#123;</span><br><span class="line">                user.receive(fromUser.getName() + <span class="string">&quot;: &quot;</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. ConcreteColleague (具体同事类)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体同事类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatUser</span> <span class="keyword">extends</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChatUser</span><span class="params">(String name, ChatRoom chatRoom)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, chatRoom);</span><br><span class="line">        chatRoom.register(<span class="built_in">this</span>); <span class="comment">// 创建时即注册到聊天室</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot; sends: &quot;</span> + message);</span><br><span class="line">        <span class="comment">// 通过中介者发送消息</span></span><br><span class="line">        chatRoom.sendMessage(<span class="built_in">this</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot; receives: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 客户端使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建中介者</span></span><br><span class="line">        <span class="type">ChatRoom</span> <span class="variable">chatRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleChatRoom</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建同事类，并关联到中介者</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">alice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatUser</span>(<span class="string">&quot;Alice&quot;</span>, chatRoom);</span><br><span class="line">        <span class="type">User</span> <span class="variable">bob</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatUser</span>(<span class="string">&quot;Bob&quot;</span>, chatRoom);</span><br><span class="line">        <span class="type">User</span> <span class="variable">charlie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatUser</span>(<span class="string">&quot;Charlie&quot;</span>, chatRoom);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 同事类之间通过中介者进行交互</span></span><br><span class="line">        alice.send(<span class="string">&quot;Hi everyone!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;---&quot;</span>);</span><br><span class="line">        bob.send(<span class="string">&quot;Hello Alice!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Alice sends: Hi everyone!</span><br><span class="line">Bob receives: Alice: Hi everyone!</span><br><span class="line">Charlie receives: Alice: Hi everyone!</span><br><span class="line">---</span><br><span class="line">Bob sends: Hello Alice!</span><br><span class="line">Alice receives: Bob: Hello Alice!</span><br><span class="line">Charlie receives: Bob: Hello Alice!</span><br></pre></td></tr></table></figure>

<p><em>在这个例子中，Alice, Bob, Charlie之间完全不认识，所有的通信都由<code>chatRoom</code>这个中介者来完成。</em></p>
<hr>
<h4 id="4-7-4-中介者模式-vs-观察者模式"><a href="#4-7-4-中介者模式-vs-观察者模式" class="headerlink" title="4.7.4 中介者模式 vs 观察者模式"></a>4.7.4 中介者模式 vs 观察者模式</h4><ul>
<li><strong>观察者模式：</strong> 强调的是一对多的<strong>广播</strong>关系。一个主题（Subject）状态改变，会通知所有观察者（Observer），但观察者之间通常不交互。通信是<strong>单向</strong>的（主题 -&gt; 观察者）。</li>
<li><strong>中介者模式：</strong> 强调的是多对多的<strong>协调</strong>关系。一个同事（Colleague）的改变会通知中介者，中介者根据逻辑可能会通知一个、多个或所有其他同事。通信是<strong>网状和双向</strong>的（同事 &lt;-&gt; 中介者）。</li>
</ul>
<hr>
<h4 id="4-7-5-实际解决问题-使用场景"><a href="#4-7-5-实际解决问题-使用场景" class="headerlink" title="4.7.5 实际解决问题 &#x2F; 使用场景"></a>4.7.5 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><strong><code>java.util.Timer</code> 和 <code>TimerTask</code>：</strong><ul>
<li><code>Timer</code> 类扮演了<strong>中介者</strong>的角色。它负责管理一个线程，并在指定的时间调度执行多个<code>TimerTask</code>。</li>
<li><code>TimerTask</code> 扮演<strong>同事类</strong>的角色。各个<code>TimerTask</code>之间是独立的，它们只关心自己的执行逻辑，而不需要关心其他任务何时执行。所有的调度和线程管理都由<code>Timer</code>这个中介者统一负责。</li>
</ul>
</li>
<li><strong>MVC (Model-View-Controller) 框架：</strong><ul>
<li>在经典的MVC架构中，<code>Controller</code> 扮演了<strong>中介者</strong>的角色。</li>
<li><code>View</code> （视图）和 <code>Model</code> （模型）是<strong>同事类</strong>。</li>
<li>用户在<code>View</code>上的操作（如点击按钮）会发送给<code>Controller</code>。<code>Controller</code>接收到请求后，会去调用<code>Model</code>更新数据，然后<code>Controller</code>再决定将哪个<code>View</code>或哪些数据返回给用户。<code>View</code>和<code>Model</code>之间没有直接的通信。</li>
</ul>
</li>
<li><strong>GUI编程中的对话框 (Dialog)：</strong><ul>
<li>一个复杂的对话框窗口通常是其内部所有控件（如文本框、复选框、按钮）的<strong>中介者</strong>。</li>
<li>例如，当一个复选框被选中时，它会通知对话框。对话框根据这个事件，可能会去启用或禁用一个文本框和一个确定按钮。复选框并不需要直接引用文本框或按钮，所有的协调逻辑都在对话框中。</li>
</ul>
</li>
<li><strong>微服务架构中的API网关 (API Gateway)：</strong><ul>
<li>在概念层面，API网关可以看作是所有微服务的一个<strong>中介者</strong>。外部客户端只与API网关通信，由网关负责请求的路由、组合、认证和分发到后端的各个微服务（同事类）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-8-备忘录模式-Memento-Pattern"><a href="#4-8-备忘录模式-Memento-Pattern" class="headerlink" title="4.8 备忘录模式 (Memento Pattern)"></a>4.8 备忘录模式 (Memento Pattern)</h3><p>备忘录模式也称为<strong>快照模式 (Snapshot Pattern)</strong>。</p>
<h4 id="4-8-1-核心思想"><a href="#4-8-1-核心思想" class="headerlink" title="4.8.1 核心思想"></a>4.8.1 核心思想</h4><p><strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</strong></p>
<p>这个模式的核心在于将对象的<strong>状态存储</strong>与<strong>状态使用者</strong>分离。它允许我们把一个对象在某一时刻的“快照”保存下来，但又不会把对象的内部实现细节暴露给外部。</p>
<p><strong>通俗比喻：游戏存档</strong></p>
<ul>
<li><strong>发起人 (Originator):</strong> 游戏角色。它包含了角色的当前状态（如等级、血量、装备、位置等）。</li>
<li><strong>备忘录 (Memento):</strong> 游戏存档文件。这个文件忠实地记录了角色在存档那一刻的所有状态数据。</li>
<li><strong>负责人 (Caretaker):</strong> 游戏存档管理器（或玩家自己）。它负责<strong>保管</strong>存档文件，但它<strong>不能读取或修改</strong>存档文件的内部内容（比如用记事本打开存档文件是乱码）。它只知道这是一个存档，可以在需要时把它“交还”给游戏。</li>
<li><strong>流程：</strong><ol>
<li>你在打Boss前，决定存档。游戏角色（Originator）创建了一个包含其当前所有状态的存档文件（Memento）。</li>
<li>你将这个存档文件保存在一个插槽里。存档管理器（Caretaker）负责保管这个文件。</li>
<li>不幸的是，你打Boss失败了。</li>
<li>你选择“读档”。存档管理器（Caretaker）把你之前保存的存档文件（Memento）拿出来，交还给游戏角色（Originator）。</li>
<li>游戏角色使用这个存档文件，将自己的所有状态恢复到存档时的那一刻，然后你就可以重新挑战Boss了。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="4-8-2-主要作用"><a href="#4-8-2-主要作用" class="headerlink" title="4.8.2 主要作用"></a>4.8.2 主要作用</h4><ol>
<li><strong>实现状态的保存与恢复：</strong> 这是其最核心的功能，常用于实现撤销&#x2F;重做（Undo&#x2F;Redo）、事务回滚、配置快照等。</li>
<li><strong>保护对象封装性：</strong> 备忘录模式通过将状态封装在<code>Memento</code>对象中，避免了外部对象直接访问<code>Originator</code>的内部私有数据。<code>Caretaker</code>只能持有<code>Memento</code>，但无法访问其内容，维护了<code>Originator</code>的边界。</li>
<li><strong>简化发起人（Originator）：</strong> <code>Originator</code>不需要关心状态的存储和管理细节，它只需负责创建备忘录和从备忘录恢复状态。状态的生命周期管理由<code>Caretaker</code>负责。</li>
</ol>
<hr>
<h4 id="4-8-3-实现方式（经典结构）"><a href="#4-8-3-实现方式（经典结构）" class="headerlink" title="4.8.3 实现方式（经典结构）"></a>4.8.3 实现方式（经典结构）</h4><p>备忘录模式包含三个核心角色：</p>
<ol>
<li><strong>Originator (发起人)：</strong><ul>
<li>是需要被保存状态的那个对象。</li>
<li>它有一个 <code>createMemento()</code> 方法，用于创建一个包含其当前内部状态的 <code>Memento</code> 对象。</li>
<li>它有一个 <code>restoreFromMemento()</code> 方法，用于从一个 <code>Memento</code> 对象中恢复其内部状态。</li>
</ul>
</li>
<li><strong>Memento (备忘录)：</strong><ul>
<li>负责存储 <code>Originator</code> 的内部状态。</li>
<li>为了保护封装性，它的设计很关键：它应该向 <code>Originator</code> 开放所有状态数据（通常通过包级私有或内部类实现），但向 <code>Caretaker</code> 和其他对象隐藏这些数据（只暴露一个空接口或没有getter方法）。</li>
</ul>
</li>
<li><strong>Caretaker (负责人)：</strong><ul>
<li>负责保存和管理 <code>Memento</code> 对象。</li>
<li>它不知道 <code>Memento</code> 的内部结构和内容。</li>
<li>它通常持有一个或多个 <code>Memento</code> 对象（例如，使用一个 <code>Stack</code> 来实现撤销&#x2F;重做）。</li>
</ul>
</li>
</ol>
<p><strong>代码示例：一个简单的文本编辑器</strong></p>
<p><strong>1. Memento (备忘录)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 备忘录类，存储编辑器的状态</span></span><br><span class="line"><span class="comment">// 设计关键：对外部只暴露空接口，而对Originator（同包下）暴露具体状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EditorMemento</span> &#123;</span><br><span class="line">    <span class="comment">// 状态应该是final的，以确保备忘录一旦创建就不会被修改</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数设为包级私有，只有同包的Editor可以创建它</span></span><br><span class="line">    EditorMemento(String content) &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter也设为包级私有</span></span><br><span class="line">    String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. Originator (发起人)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发起人：文本编辑器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Editor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">type</span><span class="params">(String words)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = (<span class="built_in">this</span>.content == <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="built_in">this</span>.content) + words;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建备忘录（存档）</span></span><br><span class="line">    <span class="keyword">public</span> EditorMemento <span class="title function_">createMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Saving state...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EditorMemento</span>(<span class="built_in">this</span>.content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从备忘录恢复（读档）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreFromMemento</span><span class="params">(EditorMemento memento)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Restoring state...&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.content = memento.getContent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. Caretaker (负责人)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 负责人：历史记录管理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">History</span> &#123;</span><br><span class="line">    <span class="comment">// 使用栈来管理历史记录，实现撤销功能</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;EditorMemento&gt; mementos = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(EditorMemento memento)</span> &#123;</span><br><span class="line">        mementos.push(memento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EditorMemento <span class="title function_">undo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mementos.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> mementos.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 客户端使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建负责人和发起人</span></span><br><span class="line">        <span class="type">History</span> <span class="variable">history</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">History</span>();</span><br><span class="line">        <span class="type">Editor</span> <span class="variable">editor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Editor</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 编辑内容并保存状态</span></span><br><span class="line">        editor.type(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">        history.save(editor.createMemento()); <span class="comment">// 第一次存档</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Current content: &quot;</span> + editor.getContent());</span><br><span class="line"></span><br><span class="line">        editor.type(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">        history.save(editor.createMemento()); <span class="comment">// 第二次存档</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Current content: &quot;</span> + editor.getContent());</span><br><span class="line">        </span><br><span class="line">        editor.type(<span class="string">&quot; This is Memento Pattern.&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Current content: &quot;</span> + editor.getContent());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 执行撤销</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- Performing Undo ---&quot;</span>);</span><br><span class="line">        <span class="type">EditorMemento</span> <span class="variable">lastState</span> <span class="operator">=</span> history.undo();</span><br><span class="line">        <span class="keyword">if</span> (lastState != <span class="literal">null</span>) &#123;</span><br><span class="line">            editor.restoreFromMemento(lastState);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;After undo: &quot;</span> + editor.getContent());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- Performing Undo Again ---&quot;</span>);</span><br><span class="line">        <span class="type">EditorMemento</span> <span class="variable">firstState</span> <span class="operator">=</span> history.undo();</span><br><span class="line">        <span class="keyword">if</span> (firstState != <span class="literal">null</span>) &#123;</span><br><span class="line">            editor.restoreFromMemento(firstState);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;After second undo: &quot;</span> + editor.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Saving state...</span><br><span class="line">Current content: Hello, </span><br><span class="line">Saving state...</span><br><span class="line">Current content: Hello, World!</span><br><span class="line">Current content: Hello, World! This is Memento Pattern.</span><br><span class="line"></span><br><span class="line">--- Performing Undo ---</span><br><span class="line">Restoring state...</span><br><span class="line">After undo: Hello, World!</span><br><span class="line"></span><br><span class="line">--- Performing Undo Again ---</span><br><span class="line">Restoring state...</span><br><span class="line">After second undo: Hello, </span><br></pre></td></tr></table></figure>

<p><em>在上面的实现中，通过将<code>Memento</code>的构造函数和getter设为包级私有，确保了只有同包的<code>Editor</code>能访问其内部状态，而<code>History</code>（即使在不同包）也无法访问，从而保护了封装性。</em></p>
<hr>
<h4 id="4-8-4-实际解决问题-使用场景"><a href="#4-8-4-实际解决问题-使用场景" class="headerlink" title="4.8.4 实际解决问题 &#x2F; 使用场景"></a>4.8.4 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><strong>实现撤销&#x2F;重做 (Undo&#x2F;Redo) 功能：</strong><ul>
<li>这是备忘录模式最经典的应用。任何需要撤销操作的软件，如文本编辑器、IDE、绘图软件（Photoshop）、CAD软件等，都使用此模式。<code>Caretaker</code>通常会使用两个栈，一个用于undo，一个用于redo。</li>
</ul>
</li>
<li><strong>数据库事务的<code>SAVEPOINT</code>和<code>ROLLBACK TO SAVEPOINT</code>：</strong><ul>
<li>在数据库中，你可以设置一个保存点（<code>SAVEPOINT</code>），这相当于创建了一个当前事务状态的<strong>备忘录</strong>。如果后续操作出现问题，你可以回滚到这个保存点（<code>ROLLBACK TO SAVEPOINT</code>），这相当于从<strong>备忘录</strong>中恢复状态，而无需回滚整个事务。</li>
</ul>
</li>
<li><strong>游戏存档&#x2F;读档：</strong><ul>
<li>如比喻中所述，游戏在特定时间点（如通过一个关卡、到达一个存档点）创建角色和世界状态的快照，并将其保存。玩家可以从这些快照中恢复游戏进度。</li>
</ul>
</li>
<li><strong>Web应用中的“草稿”功能：</strong><ul>
<li>当用户填写一个复杂的在线表单时，系统可以定时或在用户切换页面时，自动将表单的当前内容保存为一个<strong>备忘录</strong>。如果用户意外关闭浏览器或会话超时，下次回来时可以从备忘录中恢复之前填写的内容。</li>
</ul>
</li>
<li><strong>配置管理：</strong><ul>
<li>在一个系统中，如果配置可以被动态修改，可以使用备忘录模式来保存配置的历史版本。当新配置导致系统出现问题时，可以快速回滚到上一个或某一个稳定的历史版本。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-9-状态模式-State-Pattern"><a href="#4-9-状态模式-State-Pattern" class="headerlink" title="4.9 状态模式 (State Pattern)"></a>4.9 状态模式 (State Pattern)</h3><h4 id="4-9-1-核心思想"><a href="#4-9-1-核心思想" class="headerlink" title="4.9.1 核心思想"></a>4.9.1 核心思想</h4><p><strong>允许一个对象在其内部状态改变时改变它的行为，使对象看起来似乎修改了它的类。</strong></p>
<p>这个模式的核心在于将与特定状态相关的行为局部化，并且将不同状态下的行为分割到不同的<strong>状态类</strong>中。环境类（Context）不再自己处理所有状态下的行为，而是把行为委托给其当前持有的状态对象。当状态发生改变时，环境类会切换其持有的状态对象，从而使其行为也随之改变。</p>
<p><strong>通俗比喻：在线订单的状态流转</strong></p>
<ul>
<li><p><strong>环境 (Context):</strong> 一个电商订单。</p>
</li>
<li><p><strong>状态 (State):</strong> 订单的各种状态，如“待支付”、“已支付”、“已发货”、“已完成”、“已取消”。</p>
</li>
<li><p><strong>行为：</strong> 针对订单的操作，如“支付”、“发货”、“确认收货”、“取消订单”。</p>
</li>
<li><p><strong>问题场景（没有状态模式）：</strong> 在<code>Order</code>类中，<code>pay()</code>方法可能是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status == <span class="string">&quot;待支付&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// ...支付逻辑...</span></span><br><span class="line">        <span class="built_in">this</span>.status = <span class="string">&quot;已支付&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.status == <span class="string">&quot;已支付&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// ...提示已支付，请勿重复操作...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...其他状态下不能支付...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个操作方法里都充满了对<code>status</code>的<code>if-else</code>判断，非常混乱。</p>
</li>
<li><p><strong>解决方案（使用状态模式）：</strong></p>
<ol>
<li>为每种状态创建一个类（<code>PendingPaymentState</code>, <code>PaidState</code>, <code>ShippedState</code>等），它们都实现一个共同的<code>OrderState</code>接口。</li>
<li><code>Order</code>类持有一个<code>OrderState</code>类型的引用，代表当前状态。</li>
<li><code>Order</code>的<code>pay()</code>方法会直接调用<code>currentState.pay()</code>。</li>
<li>在<code>PendingPaymentState</code>中，<code>pay()</code>方法会执行支付逻辑，并将<code>Order</code>的当前状态切换到<code>PaidState</code>。</li>
<li>在<code>PaidState</code>中，<code>pay()</code>方法则会抛出异常或提示“已支付”。</li>
</ol>
</li>
<li><p><strong>效果：</strong> <code>Order</code>类不再有任何<code>if-else</code>。所有与状态相关的逻辑都被封装在了各自的状态类中，职责清晰。</p>
</li>
</ul>
<hr>
<h4 id="4-9-2-主要作用"><a href="#4-9-2-主要作用" class="headerlink" title="4.9.2 主要作用"></a>4.9.2 主要作用</h4><ol>
<li><strong>封装与状态相关的行为：</strong> 将不同状态下的行为封装到不同的状态类中，使得代码结构更加清晰，符合单一职责原则。</li>
<li><strong>消除庞大的条件分支语句：</strong> 极大地简化了环境类（Context），消除了其中用于状态判断的大量<code>if-else</code>或<code>switch-case</code>。</li>
<li><strong>使状态转换变得明确：</strong> 状态的转换逻辑可以显式地定义在状态类的内部，使得状态之间的流转关系一目了然。</li>
<li><strong>符合开闭原则：</strong> 当需要增加一个新的状态时，只需增加一个新的状态类，并修改相关状态的转换逻辑即可，对已有状态类的改动很小。</li>
</ol>
<hr>
<h4 id="4-9-3-实现方式（经典结构）"><a href="#4-9-3-实现方式（经典结构）" class="headerlink" title="4.9.3 实现方式（经典结构）"></a>4.9.3 实现方式（经典结构）</h4><p>状态模式通常包含以下角色：</p>
<ol>
<li><strong>Context (环境类)：</strong><ul>
<li>定义了客户端感兴趣的接口。</li>
<li>内部持有一个 <code>State</code> 接口的引用，代表其当前状态。</li>
<li>它将所有与状态相关的请求都委托给当前的状态对象来处理。</li>
</ul>
</li>
<li><strong>State (抽象状态接口&#x2F;类)：</strong><ul>
<li>定义了一个接口，用于封装与<code>Context</code>的某一特定状态相关的行为。</li>
</ul>
</li>
<li><strong>ConcreteState (具体状态类)：</strong><ul>
<li>实现了 <code>State</code> 接口。</li>
<li>每一个具体状态类都实现了在对应状态下应该有的行为。</li>
<li>它还负责在适当的时候，将<code>Context</code>的当前状态切换到下一个状态。</li>
</ul>
</li>
</ol>
<p><strong>代码示例：一个简单的自动售货机</strong></p>
<p><strong>1. State (抽象状态接口)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象状态：售货机状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VendingMachineState</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertCoin</span><span class="params">()</span>; <span class="comment">// 投币</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pressButton</span><span class="params">()</span>; <span class="comment">// 按下按钮</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span>;   <span class="comment">// 出货</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. Context (环境类)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 环境类：自动售货机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VendingMachine</span> &#123;</span><br><span class="line">    <span class="comment">// 定义所有可能的状态</span></span><br><span class="line">    <span class="keyword">private</span> VendingMachineState noCoinState;</span><br><span class="line">    <span class="keyword">private</span> VendingMachineState hasCoinState;</span><br><span class="line">    <span class="keyword">private</span> VendingMachineState soldState;</span><br><span class="line">    <span class="keyword">private</span> VendingMachineState soldOutState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> VendingMachineState currentState; <span class="comment">// 当前状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 商品库存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VendingMachine</span><span class="params">(<span class="type">int</span> stock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.noCoinState = <span class="keyword">new</span> <span class="title class_">NoCoinState</span>(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.hasCoinState = <span class="keyword">new</span> <span class="title class_">HasCoinState</span>(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.soldState = <span class="keyword">new</span> <span class="title class_">SoldState</span>(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.soldOutState = <span class="keyword">new</span> <span class="title class_">SoldOutState</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.stock = stock;</span><br><span class="line">        <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.currentState = noCoinState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.currentState = soldOutState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 行为委托给当前状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertCoin</span><span class="params">()</span> &#123; currentState.insertCoin(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pressButton</span><span class="params">()</span> &#123; currentState.pressButton(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span> &#123; currentState.dispense(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- Getter &amp; Setter for states ---</span></span><br><span class="line">    <span class="keyword">public</span> VendingMachineState <span class="title function_">getNoCoinState</span><span class="params">()</span> &#123; <span class="keyword">return</span> noCoinState; &#125;</span><br><span class="line">    <span class="keyword">public</span> VendingMachineState <span class="title function_">getHasCoinState</span><span class="params">()</span> &#123; <span class="keyword">return</span> hasCoinState; &#125;</span><br><span class="line">    <span class="keyword">public</span> VendingMachineState <span class="title function_">getSoldState</span><span class="params">()</span> &#123; <span class="keyword">return</span> soldState; &#125;</span><br><span class="line">    <span class="keyword">public</span> VendingMachineState <span class="title function_">getSoldOutState</span><span class="params">()</span> &#123; <span class="keyword">return</span> soldOutState; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCurrentState</span><span class="params">(VendingMachineState state)</span> &#123; <span class="built_in">this</span>.currentState = state; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStock</span><span class="params">()</span> &#123; <span class="keyword">return</span> stock; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            stock--;</span><br><span class="line">            System.out.println(<span class="string">&quot;A product is released.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. ConcreteState (具体状态类)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体状态A：无币状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoCoinState</span> <span class="keyword">implements</span> <span class="title class_">VendingMachineState</span> &#123;</span><br><span class="line">    VendingMachine machine;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NoCoinState</span><span class="params">(VendingMachine machine)</span> &#123; <span class="built_in">this</span>.machine = machine; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertCoin</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Coin inserted.&quot;</span>);</span><br><span class="line">        machine.setCurrentState(machine.getHasCoinState()); <span class="comment">// 状态转换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pressButton</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Please insert a coin first.&quot;</span>); &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Invalid action.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态B：有币状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasCoinState</span> <span class="keyword">implements</span> <span class="title class_">VendingMachineState</span> &#123;</span><br><span class="line">    VendingMachine machine;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HasCoinState</span><span class="params">(VendingMachine machine)</span> &#123; <span class="built_in">this</span>.machine = machine; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertCoin</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Coin already inserted.&quot;</span>); &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pressButton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Button pressed, preparing to dispense...&quot;</span>);</span><br><span class="line">        machine.setCurrentState(machine.getSoldState()); <span class="comment">// 状态转换</span></span><br><span class="line">        machine.dispense(); <span class="comment">// 自动调用下一个状态的出货</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Please press the button first.&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态C：出货状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SoldState</span> <span class="keyword">implements</span> <span class="title class_">VendingMachineState</span> &#123;</span><br><span class="line">    VendingMachine machine;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SoldState</span><span class="params">(VendingMachine machine)</span> &#123; <span class="built_in">this</span>.machine = machine; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertCoin</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Please wait, product is being dispensed.&quot;</span>); &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pressButton</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;Please wait, product is being dispensed.&quot;</span>); &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span> &#123;</span><br><span class="line">        machine.releaseProduct();</span><br><span class="line">        <span class="keyword">if</span> (machine.getStock() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            machine.setCurrentState(machine.getNoCoinState()); <span class="comment">// 状态转换</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Oops, out of stock!&quot;</span>);</span><br><span class="line">            machine.setCurrentState(machine.getSoldOutState()); <span class="comment">// 状态转换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体状态D：售罄状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SoldOutState</span> <span class="keyword">implements</span> <span class="title class_">VendingMachineState</span> &#123;</span><br><span class="line">    <span class="comment">// ... 在此状态下所有操作都无效 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">VendingMachine</span> <span class="variable">machine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VendingMachine</span>(<span class="number">2</span>); <span class="comment">// 初始化2件商品</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;--- Round 1 ---&quot;</span>);</span><br><span class="line">        machine.insertCoin();</span><br><span class="line">        machine.pressButton();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- Round 2 ---&quot;</span>);</span><br><span class="line">        machine.insertCoin();</span><br><span class="line">        machine.pressButton();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- Round 3 (Sold out) ---&quot;</span>);</span><br><span class="line">        machine.insertCoin(); <span class="comment">// 将会提示售罄或无效</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>客户端只需要调用<code>insertCoin()</code>和<code>pressButton()</code>，而售货机内部的状态流转和行为变化都由状态对象自动完成。</em></p>
<hr>
<h4 id="4-9-4-状态模式-vs-策略模式"><a href="#4-9-4-状态模式-vs-策略模式" class="headerlink" title="4.9.4 状态模式 vs 策略模式"></a>4.9.4 状态模式 vs 策略模式</h4><p>这是面试中非常常见的一个对比题，它们的UML图几乎一样，但意图和应用场景不同。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">状态模式 (State)</th>
<th align="left">策略模式 (Strategy)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>意图</strong></td>
<td align="left">管理对象在<strong>不同状态</strong>下的<strong>不同行为</strong>。</td>
<td align="left">提供一组<strong>可替换的算法</strong>，但与对象状态无关。</td>
</tr>
<tr>
<td align="left"><strong>行为的改变者</strong></td>
<td align="left"><strong>环境类(Context)自身</strong>或<strong>状态对象内部</strong>，是自动的。</td>
<td align="left"><strong>外部客户端</strong>，是主动选择的。</td>
</tr>
<tr>
<td align="left"><strong>类间关系</strong></td>
<td align="left">状态类之间通常<strong>相互知晓</strong>，并负责状态的<strong>转移</strong>。</td>
<td align="left">策略类之间通常是<strong>相互独立</strong>、平行的，没有直接联系。</td>
</tr>
<tr>
<td align="left"><strong>对客户端</strong></td>
<td align="left">状态的改变对客户端是<strong>透明</strong>的。</td>
<td align="left">客户端需要<strong>明确知道</strong>存在哪些策略，并负责选择和设置策略。</td>
</tr>
</tbody></table>
<hr>
<h4 id="4-9-5-实际解决问题-使用场景"><a href="#4-9-5-实际解决问题-使用场景" class="headerlink" title="4.9.5 实际解决问题 &#x2F; 使用场景"></a>4.9.5 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><strong>工作流引擎和订单系统：</strong><ul>
<li>任何有明确状态流转图的业务场景，如订单（待付款、待发货、已发货、已完成、已取消）、审批流（草稿、审批中、已驳回、已通过）、帖子状态（草稿、已发布、已删除）等，都非常适合使用状态模式来管理。</li>
</ul>
</li>
<li><strong>网络连接状态管理：</strong><ul>
<li>一个TCP连接有<code>LISTEN</code>, <code>SYN_SENT</code>, <code>ESTABLISHED</code>, <code>FIN_WAIT</code>, <code>CLOSED</code>等多种状态。在不同状态下，对接收到的数据包的处理行为是完全不同的。可以使用状态模式来对TCP连接的状态机进行建模。</li>
</ul>
</li>
<li><strong>游戏开发：</strong><ul>
<li>游戏角色的状态（如站立、行走、跑步、跳跃、攻击、防御）会影响其行为和动画。使用状态模式可以清晰地管理这些状态及其转换。</li>
</ul>
</li>
<li><strong>UI控件的行为：</strong><ul>
<li>一个按钮可能有“正常”、“悬浮”、“点击”、“禁用”等状态，每种状态下的外观和响应行为都不同。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-10-访问者模式-Visitor-Pattern"><a href="#4-10-访问者模式-Visitor-Pattern" class="headerlink" title="4.10 访问者模式 (Visitor Pattern)"></a>4.10 访问者模式 (Visitor Pattern)</h3><h4 id="4-10-1-核心思想"><a href="#4-10-1-核心思想" class="headerlink" title="4.10.1 核心思想"></a>4.10.1 核心思想</h4><p><strong>将作用于某种数据结构中各元素的操作分离开来，封装成一个独立的“访问者”对象。它允许在不改变数据结构的前提下，定义作用于这些元素的新操作。</strong></p>
<p>这个模式的核心在于<strong>双分派（Double Dispatch）</strong>。即一个操作的执行，既依赖于<strong>请求的类型（访问者）</strong>，也依赖于<strong>接收者的类型（被访问的元素）</strong>。</p>
<p><strong>通俗比喻：体检套餐</strong></p>
<ul>
<li><strong>对象结构 (Object Structure):</strong> 一家医院，里面有多个科室（眼科、耳鼻喉科、内科等）。这个结构是相对稳定的。</li>
<li><strong>元素 (Element):</strong> 医院的各个科室，如<code>EyeDepartment</code>, <code>ENTDepartment</code>。</li>
<li><strong>访问者 (Visitor):</strong> 不同的体检套餐，如<code>学生体检套餐</code>, <code>老年人体检套餐</code>。</li>
<li><strong>操作 (Operation):</strong> 在每个科室要做的具体检查项目。</li>
<li><strong>流程：</strong><ol>
<li>一个人（客户端）选择了“学生体检套餐”（一个具体的<code>Visitor</code>）。</li>
<li>他拿着这个套餐单，依次走进医院的各个科室（遍历<code>Object Structure</code>）。</li>
<li>当他走进<strong>眼科</strong>（一个具体的<code>Element</code>）时，眼科医生看到套餐单上写的是“学生体检”，于是给他做了“视力检查”。</li>
<li>当他走进<strong>耳鼻喉科</strong>时，医生也根据“学生体检”的要求，给他做了相应的检查。</li>
<li>如果另一个人选择的是“老年人体检套餐”，当他走进<strong>眼科</strong>时，医生会给他做“眼压、眼底检查”。</li>
</ol>
</li>
<li><strong>效果：</strong> 医院的科室结构（<code>Element</code>）完全没有改变，但通过引入不同的体检套餐（<code>Visitor</code>），我们为这些科室“添加”了不同的检查流程（操作）。如果想新增一种“入职体检套餐”，只需新增一个<code>Visitor</code>类即可，医院结构无需任何改动。</li>
</ul>
<hr>
<h4 id="4-10-2-主要作用"><a href="#4-10-2-主要作用" class="headerlink" title="4.10.2 主要作用"></a>4.10.2 主要作用</h4><ol>
<li><strong>遵循开闭原则（OCP）：</strong> 可以在不修改现有对象结构（元素类）的前提下，为这些类增加新的操作。这对于扩展功能非常有利，特别是当对象结构稳定，但其上的操作经常变化时。</li>
<li><strong>集中相关操作：</strong> 将所有与某个功能相关的行为都集中到一个访问者类中。例如，一个<code>GeneratePdfVisitor</code>可以包含将所有不同类型的元素导出为PDF的逻辑。</li>
<li><strong>分离复杂性：</strong> 将数据结构（元素）和作用于其上的算法（访问者）分离开来，使得两部分都可以独立演进。</li>
</ol>
<hr>
<h4 id="4-10-3-实现方式（经典结构）"><a href="#4-10-3-实现方式（经典结构）" class="headerlink" title="4.10.3 实现方式（经典结构）"></a>4.10.3 实现方式（经典结构）</h4><p>访问者模式的结构相对复杂，包含以下角色：</p>
<ol>
<li><strong>Visitor (抽象访问者)：</strong><ul>
<li>为对象结构中的每一个<code>ConcreteElement</code>类声明一个<code>visit()</code>方法。这个方法的参数就是对应的<code>ConcreteElement</code>对象。</li>
</ul>
</li>
<li><strong>ConcreteVisitor (具体访问者)：</strong><ul>
<li>实现了<code>Visitor</code>接口中声明的每个<code>visit()</code>方法，定义了对每个<code>ConcreteElement</code>的具体操作。</li>
</ul>
</li>
<li><strong>Element (抽象元素)：</strong><ul>
<li>定义一个<code>accept(Visitor visitor)</code>方法，它以一个访问者作为参数。</li>
</ul>
</li>
<li><strong>ConcreteElement (具体元素)：</strong><ul>
<li>实现了<code>Element</code>接口。</li>
<li><code>accept()</code>方法的实现通常是 <code>visitor.visit(this);</code>。这就是<strong>双分派</strong>的关键所在：首先，<code>accept</code>方法的调用是动态绑定的，选择了正确的元素类型；然后，<code>visit</code>方法的调用也是动态绑定的，选择了正确的访问者类型。</li>
</ul>
</li>
<li><strong>ObjectStructure (对象结构)：</strong><ul>
<li>一个能枚举其所有元素的容器，如一个列表或一个组合对象。</li>
<li>它提供一个高层接口，允许访问者访问其所有元素。</li>
</ul>
</li>
</ol>
<p><strong>代码示例：为电脑的不同部件进行操作（如价格计算、硬件检查）</strong></p>
<p><strong>1. Visitor (抽象访问者)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象访问者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ComputerPartVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(CPU cpu)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Memory memory)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Motherboard motherboard)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. Element (抽象元素)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ComputerPart</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(ComputerPartVisitor visitor)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. ConcreteElement (具体元素)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span> <span class="keyword">implements</span> <span class="title class_">ComputerPart</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(ComputerPartVisitor visitor)</span> &#123; visitor.visit(<span class="built_in">this</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> <span class="keyword">implements</span> <span class="title class_">ComputerPart</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(ComputerPartVisitor visitor)</span> &#123; visitor.visit(<span class="built_in">this</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Motherboard</span> <span class="keyword">implements</span> <span class="title class_">ComputerPart</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(ComputerPartVisitor visitor)</span> &#123; visitor.visit(<span class="built_in">this</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. ObjectStructure (对象结构)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象结构：电脑</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> <span class="keyword">implements</span> <span class="title class_">ComputerPart</span> &#123;</span><br><span class="line">    List&lt;ComputerPart&gt; parts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">()</span> &#123;</span><br><span class="line">        parts.add(<span class="keyword">new</span> <span class="title class_">CPU</span>());</span><br><span class="line">        parts.add(<span class="keyword">new</span> <span class="title class_">Memory</span>());</span><br><span class="line">        parts.add(<span class="keyword">new</span> <span class="title class_">Motherboard</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(ComputerPartVisitor visitor)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历所有部件，让访问者访问</span></span><br><span class="line">        <span class="keyword">for</span> (ComputerPart part : parts) &#123;</span><br><span class="line">            part.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Computer visited.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. ConcreteVisitor (具体访问者)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体访问者A：价格计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PriceCalculatorVisitor</span> <span class="keyword">implements</span> <span class="title class_">ComputerPartVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">totalPrice</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(CPU cpu)</span> &#123; totalPrice += <span class="number">1500</span>; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Memory memory)</span> &#123; totalPrice += <span class="number">800</span>; &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Motherboard motherboard)</span> &#123; totalPrice += <span class="number">1200</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTotalPrice</span><span class="params">()</span> &#123; <span class="keyword">return</span> totalPrice; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体访问者B：硬件健康检查器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HealthCheckerVisitor</span> <span class="keyword">implements</span> <span class="title class_">ComputerPartVisitor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(CPU cpu)</span> &#123; System.out.println(<span class="string">&quot;Checking CPU health: OK&quot;</span>); &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Memory memory)</span> &#123; System.out.println(<span class="string">&quot;Checking Memory health: OK&quot;</span>); &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Motherboard motherboard)</span> &#123; System.out.println(<span class="string">&quot;Checking Motherboard health: OK&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6. 客户端使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建对象结构</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 需求1：计算电脑总价</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--- Calculating Price ---&quot;</span>);</span><br><span class="line">        <span class="type">PriceCalculatorVisitor</span> <span class="variable">priceVisitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriceCalculatorVisitor</span>();</span><br><span class="line">        computer.accept(priceVisitor);</span><br><span class="line">        System.out.println(<span class="string">&quot;Total Price: &quot;</span> + priceVisitor.getTotalPrice());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n--- Checking Health ---&quot;</span>);</span><br><span class="line">        <span class="comment">// 需求2：检查硬件健康状况（新增的功能）</span></span><br><span class="line">        <span class="type">HealthCheckerVisitor</span> <span class="variable">healthVisitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HealthCheckerVisitor</span>();</span><br><span class="line">        computer.accept(healthVisitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>客户端通过创建不同的<code>Visitor</code>，就能对<code>Computer</code>这个稳定的数据结构执行完全不同的操作，而无需修改<code>CPU</code>, <code>Memory</code>等任何硬件类。</em></p>
<hr>
<h4 id="4-10-4-访问者模式的优缺点"><a href="#4-10-4-访问者模式的优缺点" class="headerlink" title="4.10.4 访问者模式的优缺点"></a>4.10.4 访问者模式的优缺点</h4><ul>
<li><strong>优点：</strong><ul>
<li><strong>良好的扩展性：</strong> 增加新的操作非常简单，只需增加一个新的访问者类。</li>
<li><strong>集中管理相关行为：</strong> 将与特定功能相关的代码集中在一个访问者中，而不是分散在各个元素类里。</li>
<li><strong>分离数据结构和算法：</strong> 使数据结构和作用于其上的操作解耦。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>增加新的元素类困难：</strong> 这是访问者模式最大的缺点。每当在对象结构中增加一个新的<code>ConcreteElement</code>类，就必须在所有<code>Visitor</code>接口和所有<code>ConcreteVisitor</code>类中增加相应的<code>visit()</code>方法。这严重违反了开闭原则。</li>
<li><strong>破坏封装：</strong> 访问者模式通常需要元素类暴露一些高层接口或数据给访问者使用，这可能破坏了元素类的封装性。</li>
<li><strong>实现复杂：</strong> 模式本身涉及多个角色和两次动态分派，理解和实现起来相对复杂。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-10-5-适用场景"><a href="#4-10-5-适用场景" class="headerlink" title="4.10.5 适用场景"></a>4.10.5 适用场景</h4><p>由于其“增加新元素困难”的巨大缺点，访问者模式的使用场景非常有限。它只适用于以下情况：</p>
<ol>
<li><strong>数据结构相对稳定，但作用于其上的操作经常变化。</strong> 这是使用访问者模式的<strong>前提</strong>。如果数据结构也频繁变动，那么这个模式将是一场灾难。</li>
<li><strong>对象结构中包含多种类型的对象，而你希望对这些对象实施一些依赖于其具体类型的操作。</strong></li>
<li><strong>需要对一个组合结构（Composite Pattern）中的所有节点进行某种操作。</strong> 访问者模式可以与组合模式结合使用，遍历复杂的树形结构。</li>
</ol>
<hr>
<h4 id="4-10-6-实际解决问题-使用场景"><a href="#4-10-6-实际解决问题-使用场景" class="headerlink" title="4.10.6 实际解决问题 &#x2F; 使用场景"></a>4.10.6 实际解决问题 &#x2F; 使用场景</h4><ol>
<li><strong>编译器中的应用：</strong><ul>
<li>这是访问者模式最经典的用例。编译器在将源代码转换为机器码的过程中，会先生成一个<strong>抽象语法树 (AST)</strong>。</li>
<li>AST 就是一个非常稳定的<strong>对象结构</strong>，由各种节点（如<code>VariableDeclarationNode</code>, <code>AssignmentNode</code>, <code>IfStatementNode</code>）组成。</li>
<li>编译器的后续步骤，如<strong>类型检查</strong>、<strong>变量分配</strong>、<strong>代码优化</strong>、<strong>目标代码生成</strong>等，都可以作为不同的<strong>访问者</strong>。每个访问者遍历AST，并对不同类型的节点执行相应的操作。</li>
</ul>
</li>
<li><strong><code>javax.lang.model</code> API：</strong><ul>
<li>在Java的注解处理器（Annotation Processor）中，<code>javax.lang.model.element.ElementVisitor</code> 就是一个典型的<strong>访问者</strong>接口。</li>
<li><code>Element</code>代表程序的一个元素（如包、类、方法、字段），它有<code>TypeElement</code>, <code>ExecutableElement</code>等多种具体实现。</li>
<li>你可以实现自己的<code>ElementVisitor</code>，通过<code>element.accept(myVisitor, ...)</code>来对不同的程序元素执行自定义的逻辑，例如在编译时生成代码。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-11-解释器模式-Interpreter-Pattern"><a href="#4-11-解释器模式-Interpreter-Pattern" class="headerlink" title="4.11 解释器模式 (Interpreter Pattern)"></a>4.11 解释器模式 (Interpreter Pattern)</h3><h4 id="4-11-1-核心思想"><a href="#4-11-1-核心思想" class="headerlink" title="4.11.1 核心思想"></a>4.11.1 核心思想</h4><p><strong>给定一种语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</strong></p>
<p>这个模式的核心在于为一个简单的“领域特定语言 (DSL, Domain-Specific Language)”构建一个解释器。它通过将语言的每一条语法规则表示为一个类，然后将一个句子表示成一个由这些类的实例构成的<strong>抽象语法树 (Abstract Syntax Tree, AST)</strong>，最后通过调用树的根节点的<code>interpret()</code>方法来完成对整个句子的解释。</p>
<p><strong>通俗比喻：解析一个简单的数学表达式，如 <code>a + b - c</code></strong></p>
<ul>
<li><p><strong>语言：</strong> 简单的加减法运算。</p>
</li>
<li><p><strong>文法规则：</strong></p>
<ul>
<li>表达式可以是一个<strong>数值</strong>（终结符表达式）。</li>
<li>表达式可以是<strong>另一个表达式</strong> + <strong>一个数值</strong>（非终结符表达式）。</li>
<li>表达式可以是<strong>另一个表达式</strong> - <strong>一个数值</strong>（非终结符表达式）。</li>
</ul>
</li>
<li><p><strong>抽象语法树 (AST)：</strong> 对于 <code>a + b - c</code>，可以构建一棵树：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    - (SubtractExpression)</span><br><span class="line">   / \</span><br><span class="line">  +   c (VarExpression)</span><br><span class="line"> / \</span><br><span class="line">a   b (VarExpression)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解释器：</strong> 树上的每个节点都是一个“解释器”对象。当我们调用根节点 <code>-</code> 的 <code>interpret()</code> 方法时，它会递归地调用其子节点 <code>+</code> 和 <code>c</code> 的 <code>interpret()</code> 方法，而 <code>+</code> 又会调用 <code>a</code> 和 <code>b</code> 的 <code>interpret()</code> 方法，最终计算出整个表达式的值。</p>
</li>
</ul>
<hr>
<h4 id="4-11-2-主要作用"><a href="#4-11-2-主要作用" class="headerlink" title="4.11.2 主要作用"></a>4.11.2 主要作用</h4><ol>
<li><strong>易于改变和扩展文法：</strong> 当语言的文法规则需要改变或增加时，由于每条规则都对应一个类，所以可以通过增加、修改或删除相应的类来实现，相对比较方便。</li>
<li><strong>实现领域特定语言（DSL）：</strong> 为某个特定领域的问题提供一种简单的、声明式的语言，让非程序员也能理解和使用。</li>
</ol>
<hr>
<h4 id="4-11-3-实现方式（经典结构）"><a href="#4-11-3-实现方式（经典结构）" class="headerlink" title="4.11.3 实现方式（经典结构）"></a>4.11.3 实现方式（经典结构）</h4><p>解释器模式通常包含以下角色：</p>
<ol>
<li><strong>Context (上下文环境)：</strong><ul>
<li>包含解释器之外的一些全局信息，通常是一个 <code>Map</code>，用于存储变量及其对应的值。</li>
</ul>
</li>
<li><strong>AbstractExpression (抽象表达式)：</strong><ul>
<li>声明一个抽象的 <code>interpret(Context context)</code> 方法，所有具体表达式类都需要实现它。</li>
</ul>
</li>
<li><strong>TerminalExpression (终结符表达式)：</strong><ul>
<li>实现了 <code>AbstractExpression</code> 接口。</li>
<li>它代表了文法中的“终结符”，即不可再分的基本元素，如一个常量或一个变量。</li>
<li><code>interpret()</code> 方法通常是直接从上下文中获取值。</li>
</ul>
</li>
<li><strong>NonterminalExpression (非终结符表达式)：</strong><ul>
<li>实现了 <code>AbstractExpression</code> 接口。</li>
<li>它代表了文法中的“非终结符”，即由其他表达式（终结符或非终结符）组合而成的复合规则，如加法、减法等。</li>
<li>它通常包含对其他 <code>AbstractExpression</code> 对象的引用。</li>
<li><code>interpret()</code> 方法会递归地调用其持有的表达式的 <code>interpret()</code> 方法。</li>
</ul>
</li>
</ol>
<p><strong>代码示例：一个简单的加减法解释器</strong></p>
<p><strong>1. Context (上下文环境)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上下文，用于存储变量的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExpressionContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; variables = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String <span class="keyword">var</span>, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        variables.put(<span class="keyword">var</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(String <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> variables.get(<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. AbstractExpression (抽象表达式)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象表达式接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(ExpressionContext context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. TerminalExpression (终结符表达式)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 终结符表达式：变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VarExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VarExpression</span><span class="params">(String key)</span> &#123; <span class="built_in">this</span>.key = key; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(ExpressionContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> context.get(key); <span class="comment">// 直接从上下文中取值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. NonterminalExpression (非终结符表达式)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非终结符表达式：加法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Expression left;</span><br><span class="line">    <span class="keyword">private</span> Expression right;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddExpression</span><span class="params">(Expression left, Expression right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(ExpressionContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归调用左右子表达式的interpret方法</span></span><br><span class="line">        <span class="keyword">return</span> left.interpret(context) + right.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非终结符表达式：减法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubtractExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Expression left;</span><br><span class="line">    <span class="keyword">private</span> Expression right;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubtractExpression</span><span class="params">(Expression left, Expression right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(ExpressionContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left.interpret(context) - right.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 客户端使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 计算表达式: a + b - c</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 设置上下文（变量的值）</span></span><br><span class="line">        <span class="type">ExpressionContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExpressionContext</span>();</span><br><span class="line">        context.put(<span class="string">&quot;a&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        context.put(<span class="string">&quot;b&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        context.put(<span class="string">&quot;c&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 手动构建抽象语法树 (AST)</span></span><br><span class="line">        <span class="comment">// a + b</span></span><br><span class="line">        <span class="type">Expression</span> <span class="variable">addExpr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddExpression</span>(<span class="keyword">new</span> <span class="title class_">VarExpression</span>(<span class="string">&quot;a&quot;</span>), <span class="keyword">new</span> <span class="title class_">VarExpression</span>(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">        <span class="comment">// (a + b) - c</span></span><br><span class="line">        <span class="type">Expression</span> <span class="variable">finalExpr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubtractExpression</span>(addExpr, <span class="keyword">new</span> <span class="title class_">VarExpression</span>(<span class="string">&quot;c&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 调用解释方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> finalExpr.interpret(context);</span><br><span class="line">        System.out.println(<span class="string">&quot;Result of &#x27;a + b - c&#x27; is: &quot;</span> + result); <span class="comment">// 输出 25</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-11-4-解释器模式的优缺点"><a href="#4-11-4-解释器模式的优缺点" class="headerlink" title="4.11.4 解释器模式的优缺点"></a>4.11.4 解释器模式的优缺点</h4><ul>
<li><strong>优点：</strong><ul>
<li><strong>高扩展性：</strong> 增加新的语法规则（如乘法、除法）非常容易，只需增加一个新的<code>NonterminalExpression</code>子类即可。</li>
<li><strong>实现简单：</strong> 对于简单的文法，用解释器模式实现比用专业的解析工具（如ANTLR）要简单得多。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li><strong>性能问题：</strong> 由于大量使用递归调用和创建大量的小对象，对于复杂的句子，解释器的执行效率可能很低。</li>
<li><strong>维护困难：</strong> 当文法规则变得非常复杂时，会产生大量的类，导致系统难以维护。</li>
<li><strong>适用场景狭窄：</strong> 只适用于文法非常简单、且执行效率不是首要考虑因素的场景。对于任何稍微复杂的语言，都应该使用更专业的工具。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-11-5-实际解决问题-使用场景"><a href="#4-11-5-实际解决问题-使用场景" class="headerlink" title="4.11.5 实际解决问题 &#x2F; 使用场景"></a>4.11.5 实际解决问题 &#x2F; 使用场景</h4><p>由于其缺点，解释器模式在主流框架和业务开发中非常罕见。但在某些特定领域，其思想仍然有所体现：</p>
<ol>
<li><strong>Spring表达式语言 (SpEL - Spring Expression Language)：</strong><ul>
<li>SpEL允许你在XML配置或注解中编写表达式，如<code>#{bean.property &gt; 10}</code>。Spring内部有一个强大的表达式解析器来解释和执行这些语句。这个解析器虽然比我们手写的复杂得多（它使用了专业的解析技术），但其核心思想——将表达式解析成一个AST并进行求值——与解释器模式是一致的。</li>
</ul>
</li>
<li><strong>正则表达式引擎 (<code>java.util.regex.Pattern</code>)：</strong><ul>
<li>正则表达式本身就是一种微型语言。<code>Pattern.compile(regex)</code>方法会将正则表达式字符串编译成一个内部的、高效的状态机或语法树（<code>Pattern</code>对象）。然后<code>Matcher</code>对象利用这个编译好的结构来匹配输入字符串。这在概念上也是解释器模式的应用。</li>
</ul>
</li>
<li><strong>各种模板引擎（如Thymeleaf, FreeMarker）：</strong><ul>
<li>模板引擎解析带有特殊标签（如<code>${user.name}</code>）的模板文件，将其转换成一个内部的文档树，然后通过“解释”这个树，将数据填充进去，最终生成HTML。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="5-现代Java开发中的其他重要模式"><a href="#5-现代Java开发中的其他重要模式" class="headerlink" title="5. 现代Java开发中的其他重要模式"></a>5. 现代Java开发中的其他重要模式</h2><h3 id="5-1-并发编程模式-Concurrency-Patterns"><a href="#5-1-并发编程模式-Concurrency-Patterns" class="headerlink" title="5.1 并发编程模式 (Concurrency Patterns)"></a>5.1 并发编程模式 (Concurrency Patterns)</h3><h4 id="5-1-1-Future-Promise模式-CompletableFuture"><a href="#5-1-1-Future-Promise模式-CompletableFuture" class="headerlink" title="5.1.1 Future &#x2F; Promise模式 (CompletableFuture)"></a>5.1.1 Future &#x2F; Promise模式 (<code>CompletableFuture</code>)</h4><h5 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h5><p>该模式的核心在于将一个<strong>耗时的操作</strong>（如网络请求、数据库查询、复杂计算）<strong>异步执行</strong>，并立即返回一个“凭证”（<code>Future</code>），这个凭证在未来某个时刻会持有操作的真实结果。调用者无需阻塞等待操作完成，可以继续做其他事情。</p>
<ul>
<li><strong><code>Future</code> (未来凭证):</strong> 是一个只读的容器，代表了异步操作的未来结果。它的主要问题是，获取结果的<code>get()</code>方法是<strong>阻塞</strong>的，而且它本身不提供非阻塞地处理结果的机制（如回调）。</li>
<li><strong><code>Promise</code> &#x2F; <code>CompletableFuture</code> (可完成的未来凭증):</strong> 这是<code>Future</code>的演进。它不仅是一个未来结果的凭证，更是一个<strong>承诺 (Promise)</strong>。它承诺在未来会有一个结果，并且允许你注册<strong>回调函数 (Callback)</strong>，当结果可用时，这些回调函数会被<strong>自动执行</strong>。这实现了从“拉（Pull）”模式（主动阻塞<code>get()</code>去拉结果）到“推（Push）”模式（结果准备好后主动推送给回调函数）的转变。</li>
</ul>
<p><strong>通俗比喻：去快餐店点餐</strong></p>
<ul>
<li><strong>传统同步调用：</strong> 你在柜台点餐，然后就一直站在那里，死死地等着，直到餐点做好拿到手，你才能离开去做别的事。—— <strong>主线程阻塞</strong>。</li>
<li><strong>传统<code>Future</code>模式：</strong> 你在柜台点餐，店员给了你一个取餐小票（<code>Future</code>）。你可以离开柜台，但为了拿到餐，你还是得时不时地回去看，或者干脆在取餐口一直等（调用<code>future.get()</code>）。—— <strong>获取结果时阻塞</strong>。</li>
<li><strong><code>CompletableFuture</code>模式：</strong> 你在柜台点餐，店员给了你一个<strong>震动取餐器</strong>（<code>CompletableFuture</code>）。你完全可以回到座位上玩手机、聊天。当你的餐点做好时，取餐器会震动并闪光（<strong>结果完成，自动触发回调</strong>），这时你才需要去取餐。</li>
</ul>
<hr>
<h5 id="2-主要作用与好处"><a href="#2-主要作用与好处" class="headerlink" title="2. 主要作用与好处"></a>2. 主要作用与好处</h5><ol>
<li><strong>非阻塞，提高系统吞吐量：</strong> 将耗时的I&#x2F;O操作或计算任务交给其他线程处理，主线程（如服务器的请求处理线程）可以被立即释放，去处理更多的请求，从而极大地提高了应用的响应能力和吞吐量。</li>
<li><strong>告别“回调地狱 (Callback Hell)”：</strong> 通过链式调用（Fluent API），可以将一系列异步操作串联起来，形成一个清晰、声明式的处理流水线（Pipeline），代码可读性远超层层嵌套的传统回调。</li>
<li><strong>强大的组合能力：</strong> 可以轻松地将多个异步操作组合起来，例如等待两个操作都完成后合并其结果（<code>thenCombine</code>），或者等待多个操作中的任意一个完成（<code>anyOf</code>）。</li>
<li><strong>优雅的异常处理：</strong> 提供了<code>exceptionally</code>和<code>handle</code>等方法，可以在异步流水线中专门处理可能出现的异常，代码更加健壮。</li>
</ol>
<hr>
<h5 id="3-核心用法与代码示例"><a href="#3-核心用法与代码示例" class="headerlink" title="3. 核心用法与代码示例"></a>3. 核心用法与代码示例</h5><p><strong>a. 创建异步任务</strong></p>
<p>最常用的方法是<code>supplyAsync</code>（有返回值）和<code>runAsync</code>（无返回值）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用默认线程池 (ForkJoinPool.commonPool())</span></span><br><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 模拟一个耗时的网络请求</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, Async World!&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用自定义线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">CompletableFuture&lt;Void&gt; futureRun = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Running a task without return value.&quot;</span>);</span><br><span class="line">&#125;, executor);</span><br></pre></td></tr></table></figure>

<p><strong>b. 链式处理结果 (核心)</strong></p>
<p>这是<code>CompletableFuture</code>最强大的地方，它有一系列的<code>thenXxx</code>方法。</p>
<ul>
<li><code>thenApply(Function)</code>: 当<code>Future</code>完成后，将其结果作为输入，应用一个函数进行<strong>转换</strong>，返回一个新的<code>CompletableFuture</code>。</li>
<li><code>thenAccept(Consumer)</code>: 当<code>Future</code>完成后，将其结果作为输入，进行<strong>消费</strong>（如打印、保存），不返回值。</li>
<li><code>thenRun(Runnable)</code>: 当<code>Future</code>完成后，执行一个<code>Runnable</code>任务，不关心结果。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; processingFuture = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;123&quot;</span>)</span><br><span class="line">    .thenApply(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Step 1: Got string &#x27;&quot;</span> + s + <span class="string">&quot;&#x27;, parsing to integer.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(s);</span><br><span class="line">    &#125;)</span><br><span class="line">    .thenApply(i -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Step 2: Got integer &quot;</span> + i + <span class="string">&quot;, multiplying by 10.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i * <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">processingFuture.thenAccept(result -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Step 3 (Final): Consuming the final result: &quot;</span> + result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>c. 组合多个<code>CompletableFuture</code></strong></p>
<ul>
<li><code>thenCombine(other, BiFunction)</code>: 将两个独立的<code>Future</code>的结果合并。</li>
<li><code>allOf(futures...)</code>: 等待所有给定的<code>Future</code>都完成。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; userFuture = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt; ageFuture = CompletableFuture.supplyAsync(() -&gt; <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; combinedFuture = userFuture.thenCombine(ageFuture, (user, age) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> user + <span class="string">&quot; is &quot;</span> + age + <span class="string">&quot; years old.&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(combinedFuture.join()); <span class="comment">// .join()是简化的get(), 不抛出受检异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待多个任务全部完成</span></span><br><span class="line">CompletableFuture.allOf(userFuture, ageFuture, processingFuture).join();</span><br><span class="line">System.out.println(<span class="string">&quot;All tasks are completed.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>d. 异常处理</strong></p>
<ul>
<li><code>exceptionally(Function)</code>: 当任何一个前置阶段出现异常时，会跳过后续的<code>thenApply/Accept</code>，直接进入<code>exceptionally</code>块进行恢复。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; errorFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Oops, something went wrong!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Success&quot;</span>;</span><br><span class="line">&#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Caught exception: &quot;</span> + ex.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Default Value&quot;</span>; <span class="comment">// 提供一个默认值作为恢复</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Result from exceptional future: &quot;</span> + errorFuture.join());</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-实际解决问题-使用场景"><a href="#4-实际解决问题-使用场景" class="headerlink" title="4. 实际解决问题 &#x2F; 使用场景"></a>4. 实际解决问题 &#x2F; 使用场景</h5><ul>
<li><strong>微服务API聚合：</strong><ul>
<li>一个前端页面需要的数据可能来自多个独立的微服务（如用户服务、商品服务、库存服务）。使用<code>CompletableFuture</code>，可以<strong>并行</strong>调用这三个服务的API，然后使用<code>thenCombine</code>或<code>allOf</code>将结果聚合起来，最后统一返回给前端。这能极大地缩短API的响应时间。</li>
</ul>
</li>
<li><strong>高并发I&#x2F;O密集型应用：</strong><ul>
<li>在Web服务器中，处理一个请求可能需要读写数据库、调用外部HTTP API、访问文件系统等。这些都是耗时的I&#x2F;O操作。通过将这些操作异步化，可以释放请求处理线程，使其能够服务于更多的并发请求，显著提升服务器的吞吐能力。Spring WebFlux等响应式框架的底层就大量运用了类似的思想。</li>
</ul>
</li>
<li><strong>并行化数据处理：</strong><ul>
<li>当需要对一个大数据集进行复杂的转换或计算时，可以将其拆分成多个子任务，为每个子任务创建一个<code>CompletableFuture</code>，提交到线程池中并行处理，最后使用<code>allOf</code>等待所有任务完成并汇总结果。</li>
</ul>
</li>
<li><strong>超时控制：</strong><ul>
<li>在Java 9及以上版本，<code>CompletableFuture</code>提供了<code>orTimeout()</code>方法。当调用一个可能耗时过长的外部服务时，可以使用它来设置一个超时时间，如果超时未返回结果，则会抛出<code>TimeoutException</code>，避免了线程的无限期等待。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-1-2-生产者-消费者模式-BlockingQueue"><a href="#5-1-2-生产者-消费者模式-BlockingQueue" class="headerlink" title="5.1.2 生产者-消费者模式 (BlockingQueue)"></a>5.1.2 生产者-消费者模式 (<code>BlockingQueue</code>)</h4><h5 id="1-核心思想-1"><a href="#1-核心思想-1" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h5><p>该模式由三部分组成：</p>
<ol>
<li><strong>生产者 (Producer):</strong> 负责创建数据（或任务）的线程。</li>
<li><strong>消费者 (Consumer):</strong> 负责处理数据的线程。</li>
<li><strong>缓冲区 (Buffer):</strong> 一个共享的、有容量限制的内存区域，用于临时存储生产者创建的数据，供消费者使用。</li>
</ol>
<p><strong>核心逻辑：</strong> 生产者将数据放入缓冲区，消费者从缓冲区取出数据。两者不直接通信，而是通过缓冲区这个“中介”进行解耦。</p>
<p><strong>解决的问题：</strong></p>
<ul>
<li><strong>解耦：</strong> 生产者和消费者完全解耦。生产者不需要知道谁是消费者，也不关心数据何时被消费。消费者同样不关心数据由谁生产。</li>
<li><strong>平衡速度差异（削峰填谷）：</strong> 当生产者的生产速度与消费者的消费速度不匹配时，缓冲区起到了至关重要的<strong>缓冲</strong>作用。<ul>
<li>如果生产者速度快于消费者，缓冲区可以防止数据丢失，让生产者继续生产，直到缓冲区满。</li>
<li>如果消费者速度快于生产者，缓冲区可以确保消费者在有数据时能立即获取，而不是空等，直到缓冲区空。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-Java中的实现利器：BlockingQueue"><a href="#2-Java中的实现利器：BlockingQueue" class="headerlink" title="2. Java中的实现利器：BlockingQueue"></a>2. Java中的实现利器：<code>BlockingQueue</code></h5><p>在Java中，<code>java.util.concurrent.BlockingQueue</code> 接口是实现生产者-消费者模式的完美工具。它是一个线程安全的队列，并提供了阻塞式的<code>put()</code>和<code>take()</code>方法，极大地简化了并发控制的复杂性。</p>
<p><strong><code>BlockingQueue</code> 的核心特性：</strong></p>
<ul>
<li><strong>线程安全：</strong> 无需手动加锁，其内部已经实现了所有必要的同步机制。</li>
<li><strong>阻塞插入 <code>put(E e)</code>：</strong> 如果队列已满，调用<code>put</code>方法的生产者线程会被<strong>自动阻塞</strong>，直到队列中有空间可用。</li>
<li><strong>阻塞获取 <code>take()</code>：</strong> 如果队列为空，调用<code>take</code>方法的消费者线程会被<strong>自动阻塞</strong>，直到队列中有新的元素被放入。</li>
</ul>
<p><strong>常用的<code>BlockingQueue</code>实现：</strong></p>
<ul>
<li><strong><code>ArrayBlockingQueue</code>：</strong> 基于<strong>数组</strong>实现的有界阻塞队列。创建时必须指定容量。内部使用一个锁，性能相对一般。</li>
<li><strong><code>LinkedBlockingQueue</code>：</strong> 基于<strong>链表</strong>实现的阻塞队列。可以是有界的（如果创建时指定容量），也可以是无界的（默认<code>Integer.MAX_VALUE</code>）。它内部使用<strong>两个锁</strong>（一个用于<code>put</code>，一个用于<code>take</code>），在生产者和消费者并发度都很高的情况下，性能通常优于<code>ArrayBlockingQueue</code>。</li>
<li><strong><code>SynchronousQueue</code>：</strong> 一个不存储元素的阻塞队列。每个<code>put</code>操作必须等待一个<code>take</code>操作，反之亦然。它非常适合实现**“手递手”**的直接交付场景。</li>
</ul>
<hr>
<h5 id="3-代码示例"><a href="#3-代码示例" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><p>下面是一个使用<code>LinkedBlockingQueue</code>实现的经典生产者-消费者示例。</p>
<p><strong>a. 缓冲区&#x2F;共享资源</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这个模式中，BlockingQueue本身就是缓冲区</span></span><br><span class="line"><span class="comment">// 我们可以在一个地方集中管理它</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>); <span class="comment">// 容量为10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>b. 生产者 (Producer)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> random.nextInt(<span class="number">100</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Producer: Producing data -&gt; &quot;</span> + data);</span><br><span class="line">                <span class="comment">// 阻塞式放入数据，如果队列满了会自动等待</span></span><br><span class="line">                queue.put(data); </span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>); <span class="comment">// 模拟生产耗时</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            System.out.println(<span class="string">&quot;Producer was interrupted.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>c. 消费者 (Consumer)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="comment">// 阻塞式获取数据，如果队列空了会自动等待</span></span><br><span class="line">                <span class="type">Integer</span> <span class="variable">data</span> <span class="operator">=</span> queue.take(); </span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer: Consuming data &lt;- &quot;</span> + data);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">// 模拟消费耗时</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer was interrupted.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>d. 启动客户端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个生产者和两个消费者</span></span><br><span class="line">        <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(queue);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(queue);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(queue);</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        executor.execute(producer);</span><br><span class="line">        executor.execute(consumer1);</span><br><span class="line">        executor.execute(consumer2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行10秒后停止</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        executor.shutdownNow(); <span class="comment">// 中断所有线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>在这个例子中，生产者的速度（500ms一个）快于单个消费者的速度（1000ms一个），但由于有两个消费者，系统的整体处理能力得到了平衡。<code>BlockingQueue</code>优雅地处理了所有的同步和等待问题。</em></p>
<hr>
<h5 id="4-实际解决问题-使用场景-1"><a href="#4-实际解决问题-使用场景-1" class="headerlink" title="4. 实际解决问题 &#x2F; 使用场景"></a>4. 实际解决问题 &#x2F; 使用场景</h5><ul>
<li><strong>线程池的工作原理：</strong><ul>
<li>Java的<code>ThreadPoolExecutor</code>本身就是生产者-消费者模式的一个完美实现。</li>
<li><strong>生产者：</strong> 提交任务的线程（主线程或其他工作线程），通过调用<code>executor.execute(task)</code>或<code>executor.submit(task)</code>来生产任务。</li>
<li><strong>缓冲区：</strong> <code>ThreadPoolExecutor</code>构造函数中传入的<code>BlockingQueue</code>，用于存储待执行的任务。</li>
<li><strong>消费者：</strong> 线程池中的工作线程。它们不断地从<code>BlockingQueue</code>中<code>take()</code>任务来执行。</li>
</ul>
</li>
<li><strong>日志系统（异步日志）：</strong><ul>
<li>为了提高应用性能，高性能的日志框架（如Log4j 2, Logback）通常支持异步日志。</li>
<li><strong>生产者：</strong> 业务线程，调用<code>logger.info(&quot;message&quot;)</code>。这个调用不会直接写文件，而是将日志事件（一个对象）放入一个<code>BlockingQueue</code>中。</li>
<li><strong>消费者：</strong> 一个专门的日志写出线程，它从队列中取出日志事件，并批量地写入到磁盘文件中。</li>
<li>这样做的好处是，业务线程的日志记录操作变得非常快（只是一个内存操作），避免了因磁盘I&#x2F;O而产生的阻塞。</li>
</ul>
</li>
<li><strong>消息队列（MQ）的客户端与服务端交互：</strong><ul>
<li>在概念层面，消息队列系统（如RabbitMQ, Kafka）就是生产者-消费者模式在分布式环境下的宏观体现。</li>
<li><strong>生产者：</strong> 发送消息的应用。</li>
<li><strong>缓冲区：</strong> MQ服务器中的队列（Queue）或主题（Topic）。</li>
<li><strong>消费者：</strong> 接收并处理消息的应用。</li>
</ul>
</li>
<li><strong>数据采集与处理系统：</strong><ul>
<li>一个线程负责从网络或传感器快速采集数据（生产者），并将数据放入队列。</li>
<li>另一个或多个线程负责从队列中取出数据进行复杂的分析、计算和存储（消费者）。这使得数据采集的实时性不会被后续的慢速处理所影响。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-1-3-线程池模式-ExecutorService"><a href="#5-1-3-线程池模式-ExecutorService" class="headerlink" title="5.1.3 线程池模式 (ExecutorService)"></a>5.1.3 线程池模式 (<code>ExecutorService</code>)</h4><h5 id="1-核心思想-2"><a href="#1-核心思想-2" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h5><p><strong>预先创建一组线程并将其放入一个“池”中进行管理。当有任务需要执行时，不是为每个任务都创建一个新线程，而是从池中取出一个空闲的线程来执行任务。任务执行完毕后，该线程并不会被销毁，而是被归还到池中，等待执行下一个任务。</strong></p>
<p>这个模式的核心在于<strong>线程复用</strong>。它将<strong>任务的提交</strong>与<strong>任务的执行</strong>解耦，由线程池来统一负责线程的创建、销毁、调度和管理。</p>
<p><strong>解决的问题：</strong></p>
<ul>
<li><strong>降低资源消耗：</strong> 线程是一种昂贵的系统资源。频繁地创建和销毁线程会带来巨大的开销。通过复用线程，可以显著降低这种开销。</li>
<li><strong>提高响应速度：</strong> 当任务到达时，无需等待新线程的创建，可以直接使用池中的已有线程，从而缩短了任务的等待时间。</li>
<li><strong>提高线程的可管理性：</strong> 线程池提供了一种统一管理和监控线程的机制。可以控制并发线程的数量，防止因创建过多线程而耗尽系统资源（如内存溢出），从而使系统更加健壮。</li>
</ul>
<hr>
<h5 id="2-Java中的实现：Executor-框架"><a href="#2-Java中的实现：Executor-框架" class="headerlink" title="2. Java中的实现：Executor 框架"></a>2. Java中的实现：<code>Executor</code> 框架</h5><p>Java的<code>java.util.concurrent</code>包提供了一个强大的<code>Executor</code>框架来实现线程池。</p>
<ul>
<li><strong><code>Executor</code>：</strong> 顶层接口，只定义了一个<code>execute(Runnable command)</code>方法，用于提交任务。</li>
<li><strong><code>ExecutorService</code>：</strong> <code>Executor</code>的子接口，提供了更丰富的生命周期管理方法（如<code>shutdown()</code>, <code>isTerminated()</code>），并支持提交有返回值的任务（<code>submit(Callable&lt;T&gt; task)</code>）。</li>
<li><strong><code>ThreadPoolExecutor</code>：</strong> <code>ExecutorService</code>最核心、最常用的实现类。它提供了非常灵活的配置，可以定制线程池的各种行为。</li>
<li><strong><code>Executors</code>：</strong> 一个工厂类，提供了一些便捷的静态方法来创建几种常见的线程池。<strong>（注意：在生产环境中，阿里巴巴《Java开发手册》强烈推荐使用<code>ThreadPoolExecutor</code>的构造函数来手动创建线程池，而不是使用<code>Executors</code>，因为<code>Executors</code>创建的线程池可能存在资源耗尽的风险。）</strong></li>
</ul>
<hr>
<h5 id="3-ThreadPoolExecutor-的核心参数"><a href="#3-ThreadPoolExecutor-的核心参数" class="headerlink" title="3. ThreadPoolExecutor 的核心参数"></a>3. <code>ThreadPoolExecutor</code> 的核心参数</h5><p>理解这几个参数是掌握线程池的关键：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> corePoolSize,      // 核心线程数</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maximumPoolSize,   // 最大线程数</span></span><br><span class="line"><span class="params">    <span class="type">long</span> keepAliveTime,    // 非核心线程的空闲存活时间</span></span><br><span class="line"><span class="params">    TimeUnit unit,         // 存活时间的单位</span></span><br><span class="line"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue, // 任务队列</span></span><br><span class="line"><span class="params">    ThreadFactory threadFactory, // 线程工厂</span></span><br><span class="line"><span class="params">    RejectedExecutionHandler handler // 拒绝策略</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p><strong>工作流程：</strong></p>
<ol>
<li>当一个新任务提交时，如果当前运行的线程数小于<code>corePoolSize</code>，线程池会创建一个新线程来执行任务，即使池中有空闲线程。</li>
<li>如果当前运行的线程数已经达到<code>corePoolSize</code>，新任务会被放入<code>workQueue</code>任务队列中等待。</li>
<li>如果<code>workQueue</code>也满了，并且当前运行的线程数小于<code>maximumPoolSize</code>，线程池会创建<strong>新的非核心线程</strong>来执行任务。</li>
<li>如果当前运行的线程数已经达到<code>maximumPoolSize</code>，并且<code>workQueue</code>也满了，那么新提交的任务会根据<strong>拒绝策略 (<code>handler</code>)</strong> 来处理。</li>
<li>当一个线程空闲时间超过<code>keepAliveTime</code>时，如果当前线程数大于<code>corePoolSize</code>，那么这个空闲的非核心线程就会被销毁。</li>
</ol>
<hr>
<h5 id="4-代码示例：手动创建并使用线程池"><a href="#4-代码示例：手动创建并使用线程池" class="headerlink" title="4. 代码示例：手动创建并使用线程池"></a>4. 代码示例：手动创建并使用线程池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// CPU核心数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">coreCount</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 推荐的手动创建方式</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            coreCount,                         <span class="comment">// 核心线程数</span></span><br><span class="line">            coreCount * <span class="number">2</span>,                     <span class="comment">// 最大线程数</span></span><br><span class="line">            <span class="number">60L</span>,                               <span class="comment">// 空闲线程存活时间</span></span><br><span class="line">            TimeUnit.SECONDS,                  <span class="comment">// 时间单位</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100</span>),    <span class="comment">// 任务队列</span></span><br><span class="line">            Executors.defaultThreadFactory(),  <span class="comment">// 线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">// 拒绝策略：由提交任务的线程自己执行</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 提交10个任务</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 提交Runnable任务 (无返回值)</span></span><br><span class="line">                executor.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Executing task &quot;</span> + taskId + <span class="string">&quot; by thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 提交Callable任务 (有返回值)</span></span><br><span class="line">                Future&lt;String&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;Result of task &quot;</span> + taskId;</span><br><span class="line">                &#125;);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 通过Future获取结果</span></span><br><span class="line">                <span class="comment">// System.out.println(future.get()); // 注意：get()是阻塞的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 平滑关闭线程池：不再接收新任务，但会等待已提交的任务执行完毕</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Shutting down executor...&quot;</span>);</span><br><span class="line">            executor.shutdown();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// executor.shutdownNow(); // 立即关闭，会尝试中断正在执行的任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-常见的线程池类型-通过Executors工厂创建"><a href="#5-常见的线程池类型-通过Executors工厂创建" class="headerlink" title="5. 常见的线程池类型 (通过Executors工厂创建)"></a>5. 常见的线程池类型 (通过<code>Executors</code>工厂创建)</h5><ul>
<li><strong><code>newFixedThreadPool(int nThreads)</code>：</strong><ul>
<li><strong>特点：</strong> 创建一个<strong>固定大小</strong>的线程池。<code>corePoolSize</code>和<code>maximumPoolSize</code>相等。</li>
<li><strong>工作队列：</strong> <code>LinkedBlockingQueue</code>（无界）。</li>
<li><strong>适用场景：</strong> 适用于负载比较平稳、可预测的场景，可以控制并发线程数。</li>
<li><strong>风险：</strong> 任务队列是无界的，如果任务堆积过多，可能导致内存溢出。</li>
</ul>
</li>
<li><strong><code>newSingleThreadExecutor()</code>：</strong><ul>
<li><strong>特点：</strong> 创建一个只包含<strong>单个线程</strong>的线程池。</li>
<li><strong>工作队列：</strong> <code>LinkedBlockingQueue</code>（无界）。</li>
<li><strong>适用场景：</strong> 适用于需要保证所有任务<strong>按顺序执行</strong>的场景。</li>
<li><strong>风险：</strong> 同<code>FixedThreadPool</code>，任务堆积可能导致内存溢出。</li>
</ul>
</li>
<li><strong><code>newCachedThreadPool()</code>：</strong><ul>
<li><strong>特点：</strong> 创建一个<strong>可缓存</strong>的线程池。<code>corePoolSize</code>为0，<code>maximumPoolSize</code>为<code>Integer.MAX_VALUE</code>。</li>
<li><strong>工作队列：</strong> <code>SynchronousQueue</code>（不存储元素）。</li>
<li><strong>工作流程：</strong> 当有新任务时，会尝试复用空闲线程，如果没有则立即创建新线程。空闲线程超过60秒会被回收。</li>
<li><strong>适用场景：</strong> 适用于执行大量、耗时短的异步任务。</li>
<li><strong>风险：</strong> <code>maximumPoolSize</code>是无界的，如果任务提交速度过快，可能导致创建大量线程，耗尽系统资源。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="6-实际解决问题-使用场景"><a href="#6-实际解决问题-使用场景" class="headerlink" title="6. 实际解决问题 &#x2F; 使用场景"></a>6. 实际解决问题 &#x2F; 使用场景</h5><ul>
<li><strong>Web服务器：</strong><ul>
<li>像Tomcat、Jetty这样的Web容器，其核心就是一个线程池。每当有一个HTTP请求进来，容器就会从线程池中取出一个线程来处理这个请求，处理完毕后归还。这保证了服务器能够高效地处理高并发的请求。</li>
</ul>
</li>
<li><strong>异步任务处理：</strong><ul>
<li>在任何需要执行后台任务或异步操作的场景，都应该使用线程池。例如：<ul>
<li>用户注册后，异步发送欢迎邮件和短信。</li>
<li>下单后，异步更新库存、生成物流信息。</li>
<li>定时任务调度（<code>ScheduledThreadPoolExecutor</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>并行计算：</strong><ul>
<li>对于可以被分解为多个独立子任务的计算密集型问题（如大数据处理、图像渲染），可以使用线程池来并行执行这些子任务，充分利用多核CPU的计算能力，缩短总计算时间。<code>Fork/Join</code>框架就是基于线程池思想的更高级应用。</li>
</ul>
</li>
<li><strong>资源池化管理：</strong><ul>
<li>线程池的思想也被广泛应用于其他昂贵资源的管理，如<strong>数据库连接池</strong>（如HikariCP, Druid）。连接池预先创建并维护一定数量的数据库连接，业务代码需要时从池中借用，用完后归还，避免了频繁建立和关闭数据库物理连接的巨大开销。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-1-4-读写锁模式-ReadWriteLock"><a href="#5-1-4-读写锁模式-ReadWriteLock" class="headerlink" title="5.1.4 读写锁模式 (ReadWriteLock)"></a>5.1.4 读写锁模式 (<code>ReadWriteLock</code>)</h4><h5 id="1-核心思想-3"><a href="#1-核心思想-3" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h5><p>该模式将对共享资源的访问分为两类：<strong>读操作</strong>和<strong>写操作</strong>。它遵循以下规则来管理并发访问：</p>
<ol>
<li><strong>读-读不互斥 (允许多个读者)：</strong> 多个线程可以同时读取共享资源，彼此之间不会阻塞。</li>
<li><strong>读-写互斥：</strong> 当一个线程正在进行读操作时，其他试图进行写操作的线程必须等待。</li>
<li><strong>写-写互斥：</strong> 当一个线程正在进行写操作时，其他任何线程（无论是读还是写）都必须等待。</li>
</ol>
<p><strong>核心目标：</strong> 在保证数据一致性的前提下，通过允许多个读线程并发执行，来提高系统的<strong>读性能</strong>。它是一种比传统互斥锁（如<code>synchronized</code>或<code>ReentrantLock</code>）更细粒度的锁机制。</p>
<p><strong>通俗比喻：在图书馆里看书和写书</strong></p>
<ul>
<li><strong>共享资源：</strong> 图书馆里的一本书。</li>
<li><strong>读操作：</strong> 看书。</li>
<li><strong>写操作：</strong> 在书上做笔记或修改内容。</li>
<li><strong>规则：</strong><ul>
<li>很多人可以同时看同一本书，互不影响（<strong>读-读不互斥</strong>）。</li>
<li>当有人在书上写字时，为了避免其他人看到不完整或错误的内容，这个人会告诉大家“请等我写完再看”（<strong>写-读互斥</strong>）。同时，其他人也不能在这时写字（<strong>写-写互斥</strong>）。</li>
<li>当有人在看书时，如果另一个人想来写字，为了保证看书的人能读到一致的版本，写字的人必须等待所有看书的人都看完离开后才能开始写（<strong>读-写互斥</strong>）。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-Java中的实现：ReadWriteLock-接口"><a href="#2-Java中的实现：ReadWriteLock-接口" class="headerlink" title="2. Java中的实现：ReadWriteLock 接口"></a>2. Java中的实现：<code>ReadWriteLock</code> 接口</h5><p>Java的<code>java.util.concurrent.locks.ReadWriteLock</code>接口是读写锁模式的抽象。它提供了两个核心方法：</p>
<ul>
<li><code>Lock readLock()</code>: 返回一个用于<strong>读操作</strong>的锁。</li>
<li><code>Lock writeLock()</code>: 返回一个用于<strong>写操作</strong>的锁。</li>
</ul>
<p>这两个方法返回的<code>Lock</code>对象与我们熟悉的<code>ReentrantLock</code>一样，都有<code>lock()</code>, <code>unlock()</code>, <code>tryLock()</code>等方法。</p>
<p>最常用的实现类是 <strong><code>java.util.concurrent.locks.ReentrantReadWriteLock</code></strong>。</p>
<hr>
<h5 id="3-代码示例-1"><a href="#3-代码示例-1" class="headerlink" title="3. 代码示例"></a>3. 代码示例</h5><p>下面是一个使用<code>ReentrantReadWriteLock</code>实现的线程安全的缓存示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取读锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">    <span class="comment">// 获取写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作：使用写锁</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        writeLock.lock(); <span class="comment">// 获取写锁，此时其他读写线程都会被阻塞</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is writing data for key: &quot;</span> + key);</span><br><span class="line">            <span class="comment">// 模拟写操作耗时</span></span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; Thread.currentThread().interrupt(); &#125;</span><br><span class="line">            <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock(); <span class="comment">// 必须在finally块中释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读操作：使用读锁</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        readLock.lock(); <span class="comment">// 获取读锁，其他读线程可以继续获取读锁，但写线程会被阻塞</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is reading data for key: &quot;</span> + key);</span><br><span class="line">            <span class="comment">// 模拟读操作耗时</span></span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">100</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; Thread.currentThread().interrupt(); &#125;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock(); <span class="comment">// 必须在finally块中释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空操作：也是写操作，使用写锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试客户端：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Cache&lt;String, String&gt; cache = <span class="keyword">new</span> <span class="title class_">Cache</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动一个写线程</span></span><br><span class="line">        executor.submit(() -&gt; &#123;</span><br><span class="line">            cache.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动多个读线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                cache.get(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动另一个写线程</span></span><br><span class="line">        executor.submit(() -&gt; &#123;</span><br><span class="line">            cache.put(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动更多的读线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                cache.get(<span class="string">&quot;key2&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>观察输出：</strong> 你会发现多个“reading data”的日志可以几乎同时打印出来，证明了读操作是并发的。而“writing data”的日志出现时，其他所有的读写操作都会被暂停，证明了写操作是独占的。</li>
</ul>
<hr>
<h5 id="4-锁的升降级"><a href="#4-锁的升降级" class="headerlink" title="4. 锁的升降级"></a>4. 锁的升降级</h5><p><code>ReentrantReadWriteLock</code>支持<strong>锁降级</strong>，但<strong>不支持锁升级</strong>。</p>
<ul>
<li><p><strong>锁降级（支持）：</strong> 一个线程在持有<strong>写锁</strong>的情况下，可以继续获取<strong>读锁</strong>，然后释放写锁。这个过程是安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">writeLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ... 修改数据 ...</span></span><br><span class="line">    readLock.lock(); <span class="comment">// 锁降级：在释放写锁前获取读锁</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    writeLock.unlock(); <span class="comment">// 释放写锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此后，该线程仍然持有读锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ... 使用数据（只读）...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    readLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>用途：</em> 在更新完数据后，如果需要立即读取更新后的共享数据，并且不希望在释放写锁和获取读锁的间隙被其他写线程抢占，就可以使用锁降级。</p>
</li>
<li><p><strong>锁升级（不支持）：</strong> 一个线程在持有<strong>读锁</strong>的情况下，<strong>不能</strong>直接获取<strong>写锁</strong>。这样做会造成死锁。因为如果多个读线程都试图升级为写锁，它们会互相等待对方释放读锁，从而永远无法成功。如果需要写，必须先释放读锁，再去竞争写锁。</p>
</li>
</ul>
<hr>
<h5 id="5-适用场景"><a href="#5-适用场景" class="headerlink" title="5. 适用场景"></a>5. 适用场景</h5><p>读写锁模式的适用前提是：<strong>读操作的频率远高于写操作</strong>。如果读写频率相当，或者写操作非常频繁，那么使用读写锁带来的性能提升可能很小，甚至因为其内部更复杂的同步机制而导致性能略有下降。在这种情况下，使用简单的<code>synchronized</code>或<code>ReentrantLock</code>可能更合适。</p>
<p><strong>典型应用场景：</strong></p>
<ol>
<li><strong>内存缓存系统：</strong> 正如代码示例所示，缓存通常是“一次写入，多次读取”。使用读写锁可以极大地提高缓存的并发读取性能。<code>ConcurrentHashMap</code>的内部实现虽然更复杂，但也蕴含了类似的为读操作优化的思想。</li>
<li><strong>配置中心：</strong> 系统配置信息通常在启动时加载，或在运行时偶尔被修改（写操作），但会被业务代码频繁地读取（读操作）。</li>
<li><strong>共享的数据结构：</strong> 任何被多个线程共享、且读多写少的数据结构，如一个全局的用户列表、商品目录等。</li>
<li><strong>文件系统：</strong> 操作系统在处理文件访问时，也采用了类似读写锁的机制。允许多个进程同时以只读方式打开同一个文件，但只允许一个进程以写入方式打开。</li>
</ol>
<hr>
<h3 id="5-2-企业级与架构模式-Enterprise-Architectural-Patterns"><a href="#5-2-企业级与架构模式-Enterprise-Architectural-Patterns" class="headerlink" title="5.2 企业级与架构模式 (Enterprise &amp; Architectural Patterns)"></a>5.2 企业级与架构模式 (Enterprise &amp; Architectural Patterns)</h3><h4 id="5-2-1-MVC模式-Model-View-Controller"><a href="#5-2-1-MVC模式-Model-View-Controller" class="headerlink" title="5.2.1 MVC模式 (Model-View-Controller)"></a>5.2.1 MVC模式 (Model-View-Controller)</h4><p>MVC（模型-视图-控制器）是一种将应用程序划分为三个相互关联的部分的软件架构模式。其核心目标是<strong>分离关注点 (Separation of Concerns)</strong>，即把业务逻辑、数据展示和用户输入控制分离开来，以提高代码的可维护性、可扩展性和可复用性。</p>
<h5 id="1-核心组成部分"><a href="#1-核心组成部分" class="headerlink" title="1. 核心组成部分"></a>1. 核心组成部分</h5><ol>
<li><strong>Model (模型)：</strong><ul>
<li><strong>职责：</strong> 代表应用程序的<strong>核心业务逻辑</strong>和<strong>数据状态</strong>。它是应用的主体，包含了数据以及操作数据的所有业务规则。</li>
<li><strong>特点：</strong><ul>
<li><strong>与表现层无关：</strong> 模型不关心数据将如何被展示。它只是持有数据并提供操作数据的方法。</li>
<li><strong>状态变更通知：</strong> 当模型的数据发生变化时，它会通知相关的视图进行更新。这通常通过实现<strong>观察者模式</strong>来完成，模型是被观察者，视图是观察者。</li>
<li><strong>示例：</strong> 在一个电商应用中，<code>Product</code>、<code>Order</code>、<code>User</code>等JavaBean对象，以及操作这些对象的<code>ProductService</code>、<code>OrderService</code>等业务服务类，都属于模型的范畴。</li>
</ul>
</li>
</ul>
</li>
<li><strong>View (视图)：</strong><ul>
<li><strong>职责：</strong> 负责<strong>展示数据</strong>给用户，并向用户提供交互界面。它是用户能看到和与之交互的一切。</li>
<li><strong>特点：</strong><ul>
<li><strong>被动：</strong> 视图本身不包含任何业务逻辑。它只是从模型中获取数据并将其呈现出来。</li>
<li><strong>数据展示：</strong> 可以有多种不同的视图来展示同一个模型的数据。例如，同一份销售数据可以被展示为表格、柱状图或饼图。</li>
<li><strong>示例：</strong> 在Web应用中，视图通常是HTML页面，由JSP、Thymeleaf、FreeMarker等模板引擎渲染生成。在桌面应用中，视图是窗口、按钮、文本框等GUI组件。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Controller (控制器)：</strong><ul>
<li><strong>职责：</strong> 充当模型和视图之间的<strong>协调者</strong>。它接收来自用户的输入（通过视图），并决定如何处理这些输入。</li>
<li><strong>特点：</strong><ul>
<li><strong>接收用户输入：</strong> 它是用户请求的入口点。</li>
<li><strong>调用模型：</strong> 根据用户输入，调用模型层的方法来更新数据或执行业务逻辑。</li>
<li><strong>选择视图：</strong> 在模型处理完毕后，控制器选择一个合适的视图来响应该请求，并将更新后的模型数据传递给视图进行展示。</li>
<li><strong>示例：</strong> 在Spring MVC中，用<code>@Controller</code>或<code>@RestController</code>注解的类就是控制器。它里面的方法（如用<code>@GetMapping</code>注解的方法）接收HTTP请求，调用Service层，最后返回一个视图名或JSON数据。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2. 工作流程"></a>2. 工作流程</h5><ol>
<li><strong>请求到达：</strong> 用户通过浏览器发起一个HTTP请求（如点击一个链接）。</li>
<li><strong>控制器接收：</strong> 请求首先被<strong>控制器 (Controller)</strong> 接收。</li>
<li><strong>控制器调用模型：</strong> 控制器解析请求，并调用相应的<strong>模型 (Model)</strong> 来处理业务逻辑（如查询数据库、更新状态）。</li>
<li><strong>模型处理并返回数据：</strong> 模型执行业务逻辑，并可能更新其内部数据状态。处理完成后，将结果返回给控制器。</li>
<li><strong>控制器选择视图：</strong> 控制器根据处理结果，选择一个合适的<strong>视图 (View)</strong> 来展示数据。它通常会将模型数据放入一个请求作用域或类似的地方，以便视图能够访问。</li>
<li><strong>视图渲染：</strong> 视图从模型中获取数据，并使用这些数据来渲染最终的HTML页面。</li>
<li><strong>响应返回：</strong> 最终渲染好的页面被作为HTTP响应返回给用户的浏览器。</li>
</ol>
<hr>
<h5 id="3-MVC模式的优点"><a href="#3-MVC模式的优点" class="headerlink" title="3. MVC模式的优点"></a>3. MVC模式的优点</h5><ol>
<li><strong>低耦合：</strong> 模型、视图和控制器三层之间的职责清晰，相互独立。模型不知道视图的存在，视图和控制器也只通过抽象接口与模型交互，这大大降低了层与层之间的耦合度。</li>
<li><strong>高可维护性与可扩展性：</strong> 由于职责分离，修改其中一层通常不会影响到其他层。例如，更换UI界面（修改视图）不需要改变业务逻辑（模型），增加新的业务功能也只需修改模型和控制器。</li>
<li><strong>支持团队并行开发：</strong> 前端开发者可以专注于视图层的开发，后端开发者可以专注于模型和控制器层的开发，两组人可以并行工作，提高了开发效率。</li>
<li><strong>高可复用性：</strong> 一个模型可以被多个不同的视图复用，以不同的方式展示数据。</li>
</ol>
<hr>
<h5 id="4-MVC模式的变体"><a href="#4-MVC模式的变体" class="headerlink" title="4. MVC模式的变体"></a>4. MVC模式的变体</h5><p>随着前端技术的发展，MVC模式也演化出了多种变体，如MVP (Model-View-Presenter) 和 MVVM (Model-View-ViewModel)。</p>
<ul>
<li><strong>MVP：</strong> <code>Presenter</code>取代了<code>Controller</code>，它与<code>View</code>的交互更加紧密，通常通过接口进行双向通信。<code>Presenter</code>负责所有的UI逻辑，使得<code>View</code>变得极其“薄”（只负责渲染和事件转发），更利于单元测试。</li>
<li><strong>MVVM：</strong> 在前端框架（如Vue, React）中非常流行。<code>ViewModel</code>通过数据绑定的方式将<code>View</code>和<code>Model</code>连接起来。当<code>ViewModel</code>的数据变化时，<code>View</code>会自动更新，反之亦然。这进一步减少了手动操作DOM的代码。</li>
</ul>
<hr>
<h5 id="5-Spring-MVC"><a href="#5-Spring-MVC" class="headerlink" title="5. Spring MVC"></a>5. Spring MVC</h5><p>Spring MVC是MVC模式在Java Web领域最经典、最流行的实现框架。</p>
<ul>
<li><strong>Model:</strong><ul>
<li><strong>数据模型：</strong> POJO（Plain Old Java Object），如<code>User</code>, <code>Product</code>。</li>
<li><strong>业务模型：</strong> Service层（<code>@Service</code>）和Repository&#x2F;DAO层（<code>@Repository</code>），负责处理业务逻辑和数据持久化。</li>
</ul>
</li>
<li><strong>View:</strong><ul>
<li>JSP, Thymeleaf, FreeMarker等模板文件。</li>
<li><code>ViewResolver</code>（视图解析器）负责将控制器返回的逻辑视图名解析为物理视图。</li>
<li>对于RESTful API，视图可以是JSON或XML，由<code>HttpMessageConverter</code>自动转换。</li>
</ul>
</li>
<li><strong>Controller:</strong><ul>
<li>用<code>@Controller</code>或<code>@RestController</code>注解的类。</li>
<li><code>DispatcherServlet</code>是Spring MVC的<strong>前端控制器 (Front Controller)</strong>，它负责接收所有请求，并将其分发给相应的<code>@Controller</code>处理。<code>DispatcherServlet</code>本身也是控制器模式的一种体现。</li>
</ul>
</li>
</ul>
<p><strong>示例代码片段 (Spring MVC):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Controller</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService; <span class="comment">// 依赖Model中的业务逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id, Model model)</span> &#123; <span class="comment">// Model是Spring MVC提供的，用于传递数据</span></span><br><span class="line">        <span class="comment">// 1. 调用模型层处理业务</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findById(id);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 将数据放入模型</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 返回逻辑视图名</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;userProfile&quot;</span>; <span class="comment">// Spring会去找名为 userProfile.html或.jsp的视图文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// View (Thymeleaf模板: userProfile.html)</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns:th=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;User Profile&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Name: &lt;span th:text=<span class="string">&quot;$&#123;user.name&#125;&quot;</span>&gt;John Doe&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Email: &lt;span th:text=<span class="string">&quot;$&#123;user.email&#125;&quot;</span>&gt;john.doe<span class="meta">@example</span>.com&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>这个例子清晰地展示了Controller如何协调Model和View来完成一次请求。</p>
<hr>
<h4 id="5-2-2-DAO模式-Data-Access-Object"><a href="#5-2-2-DAO模式-Data-Access-Object" class="headerlink" title="5.2.2 DAO模式 (Data Access Object)"></a>5.2.2 DAO模式 (Data Access Object)</h4><p>DAO（数据访问对象）模式是一种结构型模式，它将<strong>数据持久化逻辑</strong>（如与数据库的交互）从<strong>业务逻辑</strong>中分离出来。它提供了一个抽象接口，用于访问底层数据存储（如数据库、文件系统、LDAP等），而无需暴露数据存储的具体实现细节。</p>
<h5 id="1-核心思想-4"><a href="#1-核心思想-4" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h5><p>为每一种需要持久化的业务实体（如<code>User</code>, <code>Product</code>, <code>Order</code>）创建一个对应的DAO接口和实现类。业务逻辑层（如Service层）不直接与数据库API（如JDBC, Hibernate, MyBatis）交互，而是通过调用DAO接口的方法来完成对数据的<strong>增、删、改、查 (CRUD)</strong> 操作。</p>
<p><strong>传统方式 vs DAO模式：</strong></p>
<ul>
<li><p><strong>传统方式（耦合）：</strong> 在<code>UserService</code>中直接编写JDBC代码来查询和更新<code>user</code>表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 直接在这里写JDBC连接、PreparedStatement、ResultSet处理等代码...</span></span><br><span class="line">        <span class="comment">// 非常混乱，且与业务逻辑耦合</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>DAO模式（解耦）：</strong></p>
<ol>
<li>创建一个<code>UserDAO</code>接口，定义<code>findById(long id)</code>等方法。</li>
<li>创建一个<code>UserDAOImpl</code>类，实现<code>UserDAO</code>接口，并在内部封装所有JDBC代码。</li>
<li><code>UserService</code>只依赖于<code>UserDAO</code>接口。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserService (业务逻辑层)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDAO userDAO; <span class="comment">// 依赖DAO接口</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 将数据访问委托给DAO</span></span><br><span class="line">        <span class="keyword">return</span> userDAO.findById(id); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserDAO (数据访问接口)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDAO</span> &#123;</span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserDAOImpl (数据访问实现)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDAOImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDAO</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里封装所有底层的JDBC或MyBatis/Hibernate代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-主要作用"><a href="#2-主要作用" class="headerlink" title="2. 主要作用"></a>2. 主要作用</h5><ol>
<li><strong>分离关注点 (SoC)：</strong> 将数据访问的复杂性与业务逻辑的复杂性分离开来。业务层专注于实现业务规则，而DAO层专注于如何与数据源交互。</li>
<li><strong>提高可维护性：</strong> 数据访问逻辑集中在DAO实现类中，当数据库表结构或SQL语句需要修改时，只需要修改相应的DAO类，而不会影响到业务逻辑层。</li>
<li><strong>提高可移植性与灵活性：</strong> 这是DAO模式最大的优点。如果决定将底层数据存储从MySQL更换为Oracle，或者将持久化技术从JDBC更换为MyBatis，你只需要提供一个新的DAO实现类（如<code>UserMyBatisDAOImpl</code>）即可，而<code>UserService</code>等业务代码完全不需要改动。这与<strong>依赖倒置原则</strong>和<strong>面向接口编程</strong>的思想完全一致。</li>
<li><strong>提高可测试性：</strong> 在对业务层进行单元测试时，可以轻松地传入一个DAO的<strong>模拟实现 (Mock DAO)</strong>，从而在不连接真实数据库的情况下测试业务逻辑的正确性。</li>
</ol>
<hr>
<h5 id="3-DAO模式的组成部分"><a href="#3-DAO模式的组成部分" class="headerlink" title="3. DAO模式的组成部分"></a>3. DAO模式的组成部分</h5><ol>
<li><strong>业务对象 (Business Object &#x2F; Model)：</strong><ul>
<li>代表应用中的实体，通常是一个POJO（Plain Old Java Object），如<code>User</code>类。它只包含数据和getter&#x2F;setter方法。</li>
</ul>
</li>
<li><strong>DAO接口 (DAO Interface)：</strong><ul>
<li>定义了针对业务对象的所有持久化操作，如<code>createUser()</code>, <code>findUserById()</code>, <code>updateUser()</code>, <code>deleteUser()</code>。</li>
</ul>
</li>
<li><strong>DAO实现类 (DAO Implementation)：</strong><ul>
<li>实现了DAO接口。它包含了与特定数据源进行交互的具体逻辑。例如，<code>UserJdbcDAOImpl</code>会使用JDBC API，而<code>UserHibernateDAOImpl</code>会使用Hibernate API。</li>
</ul>
</li>
<li><strong>数据传输对象 (DTO - Data Transfer Object) (可选)：</strong><ul>
<li>有时，DAO方法返回的数据可能不是一个完整的业务对象，而是一个包含多个对象信息的组合体，或者只是业务对象的部分字段。在这种情况下，可以使用DTO来封装这些数据，以便在层与层之间高效地传输。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="4-在现代Java框架中的演进"><a href="#4-在现代Java框架中的演进" class="headerlink" title="4. 在现代Java框架中的演进"></a>4. 在现代Java框架中的演进</h5><p>在现代框架如Spring和MyBatis中，DAO模式的概念得到了保留，但其实现方式被大大简化了。</p>
<p><strong>与MyBatis的结合</strong></p>
<p>MyBatis通过<strong>Mapper接口</strong>极大地简化了DAO的实现。</p>
<ul>
<li><strong>DAO接口 -&gt; Mapper接口：</strong> 你只需要定义一个Mapper接口（如<code>UserMapper</code>），并在接口方法上使用注解（或在XML文件中）来声明对应的SQL语句。</li>
<li><strong>DAO实现类 -&gt; 动态代理：</strong> 你<strong>完全不需要</strong>编写DAO的实现类。MyBatis会根据Mapper接口，在运行时通过<strong>动态代理</strong>自动生成一个实现类。这个代理对象会负责执行SQL、映射结果集等所有底层工作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserMapper.java (相当于DAO接口)</span></span><br><span class="line"><span class="meta">@Mapper</span> <span class="comment">// 告诉MyBatis这是一个Mapper接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Insert(&quot;INSERT INTO users(name, email) VALUES(#&#123;name&#125;, #&#123;email&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Service中使用</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper; <span class="comment">// 直接注入Mapper接口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>与Spring Data JPA的结合</strong></p>
<p>Spring Data JPA将DAO模式的简化推向了极致。</p>
<ul>
<li><strong>DAO接口 -&gt; Repository接口：</strong> 你只需要定义一个Repository接口，并继承Spring Data JPA提供的<code>JpaRepository&lt;EntityType, IDType&gt;</code>。</li>
<li><strong>DAO实现类 -&gt; 自动生成：</strong> <code>JpaRepository</code>已经预定义了所有常见的CRUD方法（如<code>save()</code>, <code>findById()</code>, <code>findAll()</code>, <code>deleteById()</code>）。你<strong>完全不需要</strong>为这些基本操作编写任何实现代码或SQL语句。Spring Data JPA会在运行时为你自动生成实现。</li>
<li>对于复杂的查询，你只需按照<strong>约定的命名规则</strong>在Repository接口中定义方法即可，Spring Data JPA会自动为你生成对应的JPQL查询。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserRepository.java (相当于DAO接口)</span></span><br><span class="line"><span class="comment">// 只需要定义接口，无需实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// Spring Data JPA会根据方法名自动生成查询</span></span><br><span class="line">    User <span class="title function_">findByEmail</span><span class="params">(String email)</span>;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByNameAndStatus</span><span class="params">(String name, String status)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Service中使用</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 直接注入Repository接口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findByEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findByEmail(email);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>尽管现代框架极大地简化了DAO的实现，但DAO模式的核心思想——<strong>将数据访问逻辑与业务逻辑分离</strong>——仍然是构建分层、可维护应用的基础。在Spring生态中，我们用<code>@Repository</code>注解来标记DAO层&#x2F;Repository层的组件，这正是DAO模式思想的体现。</p>
<hr>
<h4 id="5-2-3-空对象模式-Null-Object-Pattern"><a href="#5-2-3-空对象模式-Null-Object-Pattern" class="headerlink" title="5.2.3 空对象模式 (Null Object Pattern)"></a>5.2.3 空对象模式 (Null Object Pattern)</h4><h5 id="1-核心思想-5"><a href="#1-核心思想-5" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h5><p><strong>用一个实现了期望接口、但方法体为空的“空对象”来替代<code>null</code>引用。</strong></p>
<p>这个模式的核心在于，当一个方法可能返回<code>null</code>时，我们不直接返回<code>null</code>，而是返回一个特殊的“空对象”实例。这个空对象与真实对象实现了相同的接口，但其所有方法都是无害的“空操作”（do-nothing）。这样，客户端在获取到这个对象后，无需进行<code>if (obj != null)</code>的检查，可以直接调用其方法，而不会引发<code>NullPointerException</code>。</p>
<p><strong>传统方式 vs 空对象模式：</strong></p>
<ul>
<li><p><strong>传统方式（需要检查<code>null</code>）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> animalFactory.getAnimal(<span class="string">&quot;cat&quot;</span>); <span class="comment">// 可能返回null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次调用前都必须检查null，否则可能抛出NPE</span></span><br><span class="line"><span class="keyword">if</span> (animal != <span class="literal">null</span>) &#123;</span><br><span class="line">    animal.makeSound();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>空对象模式（无需检查<code>null</code>）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> animalFactory.getAnimal(<span class="string">&quot;dinosaur&quot;</span>); <span class="comment">// 工厂返回一个NullAnimal实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无需检查，直接调用。NullAnimal的makeSound()是空方法，不会做任何事。</span></span><br><span class="line">animal.makeSound(); </span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-主要作用-1"><a href="#2-主要作用-1" class="headerlink" title="2. 主要作用"></a>2. 主要作用</h5><ol>
<li><strong>避免<code>NullPointerException</code>：</strong> 这是该模式最直接、最主要的好处。通过消除<code>null</code>引用，从根本上减少了<code>NPE</code>的发生几率。</li>
<li><strong>简化客户端代码：</strong> 客户端代码不再需要充斥着大量的<code>if (obj != null)</code>检查，使得代码更加简洁、流畅、可读性更高。</li>
<li><strong>提供默认行为：</strong> 空对象可以提供一种无害的、默认的“空行为”，这比简单地什么都不做（如果返回<code>null</code>）要更具表现力。</li>
</ol>
<hr>
<h5 id="3-实现方式（经典结构）"><a href="#3-实现方式（经典结构）" class="headerlink" title="3. 实现方式（经典结构）"></a>3. 实现方式（经典结构）</h5><p>空对象模式的结构非常简单：</p>
<ol>
<li><strong>AbstractObject (抽象对象&#x2F;接口)：</strong> 定义了真实对象和空对象都需要实现的共同接口。</li>
<li><strong>RealObject (真实对象)：</strong> 实现了<code>AbstractObject</code>接口，包含了真实的业务逻辑。</li>
<li><strong>NullObject (空对象)：</strong><ul>
<li>也实现了<code>AbstractObject</code>接口。</li>
<li>它的所有方法都是“空实现”，即方法体为空，或者返回一个无害的默认值（如 <code>0</code>, <code>false</code>, 空字符串, 空集合）。</li>
<li>通常，空对象应该被设计为<strong>单例</strong>，因为它的状态是固定的，无需创建多个实例。</li>
</ul>
</li>
</ol>
<p><strong>代码示例：一个简单的动物工厂</strong></p>
<p><strong>a. AbstractObject (抽象对象&#x2F;接口)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象对象接口：动物</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>b. RealObject (真实对象)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真实对象：狗</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof! Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实对象：猫</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Cat&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Meow!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>c. NullObject (空对象)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空对象：代表不存在的动物</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NullAnimal</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 设计为单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">NullAnimal</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullAnimal</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NullAnimal</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> NullAnimal <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回一个无害的默认值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Not an animal&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 空操作，什么也不做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>d. 工厂类 (用于返回对象)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title function_">getAnimal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;dog&quot;</span>.equalsIgnoreCase(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;cat&quot;</span>.equalsIgnoreCase(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找不到，返回空对象实例，而不是null</span></span><br><span class="line">        <span class="keyword">return</span> NullAnimal.getInstance(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>e. 客户端使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> AnimalFactory.getAnimal(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        System.out.print(dog.getName() + <span class="string">&quot; says: &quot;</span>);</span><br><span class="line">        dog.makeSound(); <span class="comment">// 输出: Dog says: Woof! Woof!</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">unknown</span> <span class="operator">=</span> AnimalFactory.getAnimal(<span class="string">&quot;lion&quot;</span>);</span><br><span class="line">        System.out.print(unknown.getName() + <span class="string">&quot; says: &quot;</span>);</span><br><span class="line">        <span class="comment">// 无需检查null，直接调用，不会抛出NPE，也不会有任何输出</span></span><br><span class="line">        unknown.makeSound(); </span><br><span class="line">        System.out.println(<span class="string">&quot;[No sound]&quot;</span>); <span class="comment">// 输出: Not an animal says: [No sound]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-与Java-8-Optional-的对比"><a href="#4-与Java-8-Optional-的对比" class="headerlink" title="4. 与Java 8 Optional 的对比"></a>4. 与Java 8 <code>Optional</code> 的对比</h5><p>Java 8引入的<code>java.util.Optional</code>类提供了另一种处理<code>null</code>的优秀方式。它与空对象模式有相似的目标，但实现思想不同。</p>
<ul>
<li><strong>空对象模式：</strong><ul>
<li><strong>目标：</strong> 让客户端<strong>感觉不到</strong><code>null</code>的存在，可以像对待真实对象一样对待空对象。</li>
<li><strong>用法：</strong> 客户端代码保持不变，无需修改调用方式。</li>
<li><strong>适用场景：</strong> 当“什么都不做”是一个合理的默认行为时。</li>
</ul>
</li>
<li><strong><code>Optional</code>：</strong><ul>
<li><strong>目标：</strong> 明确地、显式地提醒API使用者“这里可能没有值”，强迫调用者去处理“空”的情况。</li>
<li><strong>用法：</strong> 改变了API的签名（返回<code>Optional&lt;T&gt;</code>而不是<code>T</code>），并提供了<code>isPresent()</code>, <code>ifPresent()</code>, <code>orElse()</code>, <code>orElseGet()</code>等方法来处理。</li>
<li><strong>适用场景：</strong> 当“空”是一种需要被明确处理的业务情况，而不是简单地忽略时。</li>
</ul>
</li>
</ul>
<p><strong>选择建议：</strong></p>
<ul>
<li>如果一个方法返回<code>null</code>，而调用者通常需要根据<code>null</code>来执行一些特殊的、不同于正常流程的逻辑，那么使用<code>Optional</code>更合适，因为它能清晰地表达这种可能性。</li>
<li>如果一个方法返回<code>null</code>，而调用者在大多数情况下只是想跳过后续操作（即“什么都不做”），那么使用空对象模式可以让代码更简洁。</li>
</ul>
<hr>
<h5 id="5-实际解决问题-使用场景"><a href="#5-实际解决问题-使用场景" class="headerlink" title="5. 实际解决问题 &#x2F; 使用场景"></a>5. 实际解决问题 &#x2F; 使用场景</h5><ol>
<li><strong>日志系统：</strong><ul>
<li>当日志级别被设置为<code>INFO</code>时，如果代码中调用了<code>logger.debug(&quot;message&quot;)</code>，日志框架内部并不会返回一个<code>null</code> Logger，而是可能使用一个<strong>空日志记录器 (Null Logger)</strong>。这个空记录器实现了<code>Logger</code>接口，但其<code>debug</code>方法是空的，直接返回，从而以极低的性能开销跳过了日志记录，也避免了<code>null</code>检查。</li>
</ul>
</li>
<li><strong>策略模式中的默认策略：</strong><ul>
<li>在使用策略模式时，如果没有为Context指定任何策略，可以为其设置一个<strong>空策略 (Null Strategy)</strong>。这个空策略实现了策略接口，但其执行方法是空的。这比在Context中检查策略是否为<code>null</code>要优雅。</li>
</ul>
</li>
<li><strong>链式调用中的安全终止：</strong><ul>
<li>在一个返回<code>this</code>的链式API中，如果某个环节出现问题需要终止后续调用，可以返回一个<strong>空对象</strong>实例。这个空对象也实现了同样的接口，但所有方法都直接返回<code>this</code>（空对象自身），这样后续的链式调用虽然语法上成立，但实际上不会产生任何效果。</li>
</ul>
</li>
<li><strong>GUI编程：</strong><ul>
<li>当一个事件没有绑定任何监听器时，系统内部可以认为它绑定了一个<strong>空监听器 (Null Listener)</strong>，而不是一个<code>null</code>引用。当事件触发时，直接调用空监听器的方法，避免了每次触发事件前都要检查监听器是否为<code>null</code>。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-2-4-熔断器模式-Circuit-Breaker-Pattern"><a href="#5-2-4-熔断器模式-Circuit-Breaker-Pattern" class="headerlink" title="5.2.4 熔断器模式 (Circuit Breaker Pattern)"></a>5.2.4 熔断器模式 (Circuit Breaker Pattern)</h4><h5 id="1-核心思想-6"><a href="#1-核心思想-6" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h5><p>熔断器模式源于电子工程中的“断路器”（或“保险丝”）。在软件系统中，它像一个代理，包裹了对一个可能失败的操作的调用（通常是远程服务调用）。它监控该操作的失败次数，当失败次数在一定时间内达到阈值时，熔断器会“跳闸”（或“熔断”），并在接下来的预设时间内，<strong>阻止所有后续的调用直接访问该服务</strong>，而是立即返回一个错误或降级结果。经过这段时间后，熔断器会进入“半开”状态，尝试放行少量请求去探测服务是否恢复。如果成功，则关闭熔断器，恢复正常调用；如果失败，则继续保持熔断状态。</p>
<p><strong>核心目的：</strong> 防止一个已经出现故障或响应缓慢的服务，被持续的请求所“压垮”，同时也防止调用方因为等待这个故障服务而耗尽自身资源（如线程、连接），从而避免<strong>级联故障 (Cascading Failures)</strong> 的发生。</p>
<p><strong>通俗比喻：智能的电路保险丝</strong></p>
<ul>
<li><strong>传统调用：</strong> 就像没有保险丝的电路，一个电器短路了，整个房子的电路可能会烧毁。</li>
<li><strong>熔断器模式：</strong><ol>
<li><strong>闭合 (Closed) 状态：</strong> 保险丝是好的，电流（请求）正常通过。</li>
<li><strong>跳闸 -&gt; 开启 (Open) 状态：</strong> 电路中电流过大（服务调用连续失败），保险丝“啪”的一声断了。此时，所有试图通过这个电路的电流（请求）都被阻止了。</li>
<li><strong>自动修复 -&gt; 半开 (Half-Open) 状态：</strong> 过了一会儿，智能保险丝会尝试自己连接一下，放一小股电流（一个探测请求）过去试试。</li>
<li><strong>结果判断：</strong><ul>
<li>如果小电流通过了（探测请求成功），说明问题解决了，保险丝完全恢复连接，回到<strong>闭合</strong>状态。</li>
<li>如果小电流还是不通（探测请求失败），说明问题还在，保险丝立刻再次断开，回到<strong>开启</strong>状态，并开始新一轮的等待。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h5 id="2-熔断器的三种状态"><a href="#2-熔断器的三种状态" class="headerlink" title="2. 熔断器的三种状态"></a>2. 熔断器的三种状态</h5><ul>
<li><strong>Closed (闭合)：</strong><ul>
<li>熔断器关闭，所有请求都可以正常地访问被保护的服务。</li>
<li>内部维护一个失败计数器。如果请求成功，计数器清零；如果请求失败，计数器加一。</li>
<li>当失败次数在指定时间窗口内达到阈值时，熔断器状态切换到 <strong>Open</strong>。</li>
</ul>
</li>
<li><strong>Open (开启)：</strong><ul>
<li>熔断器打开，所有对该服务的请求都会被<strong>立即拒绝</strong>（快速失败），不会去真正调用服务。</li>
<li>此时会启动一个超时计时器。</li>
<li>调用方可以执行一个<strong>降级逻辑 (Fallback)</strong>，例如返回一个默认值、从缓存中获取数据或返回一个友好的错误提示。</li>
<li>当超时时间到达后，熔断器状态切换到 <strong>Half-Open</strong>。</li>
</ul>
</li>
<li><strong>Half-Open (半开)：</strong><ul>
<li>熔断器处于一种探测状态。它会允许<strong>下一个</strong>（或少量）请求通过，去访问被保护的服务。</li>
<li><strong>如果这个探测请求成功：</strong> 熔断器认为服务已经恢复，状态切换回 <strong>Closed</strong>，并重置失败计数器。</li>
<li><strong>如果这个探测请求失败：</strong> 熔断器认为服务尚未恢复，状态立即切换回 <strong>Open</strong>，并重置超时计时器，开始新一轮的“熔断-等待”。</li>
</ul>
</li>
</ul>
<p>​                <img src="https://martinfowler.com/bliki/images/circuitBreaker/state.png" alt="Circuit Breaker State Diagram"><br>​                                           <em>(图片来源: Martin Fowler’s blog)</em></p>
<hr>
<h5 id="3-主要作用与好处"><a href="#3-主要作用与好处" class="headerlink" title="3. 主要作用与好处"></a>3. 主要作用与好处</h5><ol>
<li><strong>防止级联故障：</strong> 核心作用。通过快速失败，避免了故障在系统间的蔓延。一个下游服务的故障不会拖垮所有上游服务。</li>
<li><strong>快速失败 (Fail-Fast)：</strong> 在服务不可用时，客户端无需经历漫长的超时等待，可以立即得到响应，从而改善用户体验。</li>
<li><strong>服务自动恢复：</strong> 熔断器通过半开状态的自动探测机制，可以在服务恢复后自动“闭合”，无需人工干预，提高了系统的弹性和自愈能力。</li>
<li><strong>提供优雅降级：</strong> 在熔断开启时，可以执行预设的降级逻辑，为用户提供一个有损但可用的服务，而不是一个冷冰冰的错误页面。</li>
</ol>
<hr>
<h5 id="4-Java中的实现"><a href="#4-Java中的实现" class="headerlink" title="4. Java中的实现"></a>4. Java中的实现</h5><p>在Java生态中，我们通常不自己从零实现熔断器，而是使用成熟的第三方库。</p>
<p><strong>a. Hystrix (Netflix, 已进入维护模式)</strong></p>
<p>Hystrix是Netflix开源的、曾经非常流行的熔断器库。虽然现在官方已不再积极开发新功能，但其设计思想影响深远。</p>
<ul>
<li><strong>核心概念：</strong> 通过<code>HystrixCommand</code>或<code>HystrixObservableCommand</code>来包裹服务调用。</li>
<li><strong>功能：</strong> 不仅提供熔断，还集成了<strong>服务隔离（通过线程池或信号量）、请求缓存、请求合并</strong>等多种服务保护功能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hystrix 示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetUserServiceCommand</span> <span class="keyword">extends</span> <span class="title class_">HystrixCommand</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GetUserServiceCommand</span><span class="params">(<span class="type">long</span> userId)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;UserServiceGroup&quot;</span>));</span><br><span class="line">        <span class="built_in">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> User <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 真正的服务调用</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://user-service/users/&quot;</span> + userId, User.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> User <span class="title function_">getFallback</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 降级逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Executing fallback for user: &quot;</span> + userId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(userId, <span class="string">&quot;Default User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetUserServiceCommand</span>(<span class="number">123</span>).execute();</span><br></pre></td></tr></table></figure>

<p><strong>b. Resilience4j (轻量级，当前主流)</strong></p>
<p>Resilience4j是目前Java社区中最推荐的容错库之一。它是一个轻量级、模块化的库，只关注容错，不包含Hystrix那样的线程池隔离等功能，因此可以与<code>CompletableFuture</code>、RxJava等异步工具更好地结合。</p>
<ul>
<li><strong>核心概念：</strong> 通过函数式编程的方式来“装饰”你的方法调用。</li>
<li><strong>模块化：</strong> 提供了<code>CircuitBreaker</code>, <code>RateLimiter</code>（限流）, <code>Bulkhead</code>（舱壁隔离）, <code>Retry</code>（重试）, <code>Cache</code>等多个独立的模块。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Resilience4j 示例</span></span><br><span class="line"><span class="comment">// 1. 创建熔断器配置</span></span><br><span class="line"><span class="type">CircuitBreakerConfig</span> <span class="variable">config</span> <span class="operator">=</span> CircuitBreakerConfig.custom()</span><br><span class="line">    .failureRateThreshold(<span class="number">50</span>) <span class="comment">// 失败率阈值</span></span><br><span class="line">    .waitDurationInOpenState(Duration.ofSeconds(<span class="number">10</span>)) <span class="comment">// 熔断开启后等待时间</span></span><br><span class="line">    .permittedNumberOfCallsInHalfOpenState(<span class="number">2</span>) <span class="comment">// 半开状态允许的探测请求数</span></span><br><span class="line">    .slidingWindowSize(<span class="number">10</span>) <span class="comment">// 滑动窗口大小</span></span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建熔断器实例</span></span><br><span class="line"><span class="type">CircuitBreakerRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> CircuitBreakerRegistry.of(config);</span><br><span class="line"><span class="type">CircuitBreaker</span> <span class="variable">circuitBreaker</span> <span class="operator">=</span> registry.circuitBreaker(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 装饰你的服务调用</span></span><br><span class="line">Supplier&lt;User&gt; decoratedSupplier = CircuitBreaker</span><br><span class="line">    .decorateSupplier(circuitBreaker, () -&gt; restTemplate.getForObject(<span class="string">&quot;http://user-service/users/123&quot;</span>, User.class));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 定义降级逻辑并调用</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> Try.ofSupplier(decoratedSupplier)</span><br><span class="line">               .recover(throwable -&gt; <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">123L</span>, <span class="string">&quot;Default User&quot;</span>))</span><br><span class="line">               .get();</span><br></pre></td></tr></table></figure>

<p><strong>c. Sentinel (阿里巴巴开源)</strong></p>
<p>Sentinel是阿里巴巴开源的，面向分布式服务架构的流量控制组件。它不仅包含熔断降级，更侧重于<strong>流量控制、削峰填谷、系统负载保护</strong>。功能非常强大，配置灵活，并提供了实时监控的控制台。</p>
<hr>
<h5 id="5-实际解决问题-使用场景-1"><a href="#5-实际解决问题-使用场景-1" class="headerlink" title="5. 实际解决问题 &#x2F; 使用场景"></a>5. 实际解决问题 &#x2F; 使用场景</h5><ol>
<li><strong>微服务间的RPC调用：</strong> 这是最典型的场景。服务A调用服务B时，应该用熔断器包裹对服务B的调用。当服务B不可用时，服务A的熔断器会打开，避免请求堆积，并可以执行降级逻辑（如返回缓存数据）。</li>
<li><strong>对第三方API的调用：</strong> 调用外部的、不稳定的第三方服务（如天气API、支付网关）时，必须使用熔断器来保护自己的系统，防止被第三方服务的故障所影响。</li>
<li><strong>数据库访问：</strong> 虽然不那么常见，但如果数据库连接成为瓶颈或数据库偶尔出现抖动，也可以在DAO层之上使用熔断器。当数据库连接池耗尽或查询超时时，可以快速失败并降级，而不是让大量线程阻塞在等待数据库连接上。</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/10/27/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/JVM/" rel="prev" title="JVM">
                  <i class="fa fa-angle-left"></i> JVM
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
