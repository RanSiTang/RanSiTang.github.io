<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="一、Redis入门与核心概念1. Redis是什么？Redis（Remote Dictionary Server，远程字典服务器）是一个开源的、基于内存的、使用C语言编写的、高性能的键值（Key-Value）数据库。它通常被看作是一个数据结构服务器，因为值的类型可以是字符串、哈希、列表、集合、有序集合等多种丰富的类型。 1.1 NoSQL数据库、KV数据库、内存数据库这三个术语从不同维度描述了Re">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://example.com/2025/10/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/Redis/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="一、Redis入门与核心概念1. Redis是什么？Redis（Remote Dictionary Server，远程字典服务器）是一个开源的、基于内存的、使用C语言编写的、高性能的键值（Key-Value）数据库。它通常被看作是一个数据结构服务器，因为值的类型可以是字符串、哈希、列表、集合、有序集合等多种丰富的类型。 1.1 NoSQL数据库、KV数据库、内存数据库这三个术语从不同维度描述了Re">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-25T03:25:45.000Z">
<meta property="article:modified_time" content="2025-10-26T05:42:01.897Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/10/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/Redis/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/10/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/Redis/","path":"2025/10/25/数据库与持久化/Redis/","title":"Redis"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redis | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81Redis%E5%85%A5%E9%97%A8%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">一、Redis入门与核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Redis%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1. Redis是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81KV%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text">1.1 NoSQL数据库、KV数据库、内存数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Redis%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-text">1.2 Redis的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Redis-vs-MySQL"><span class="nav-text">1.3 Redis vs MySQL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Redis%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">2. Redis的典型应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E7%BC%93%E5%AD%98"><span class="nav-text">2.1 缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%EF%BC%88Session-Sharing%EF%BC%89"><span class="nav-text">2.2 分布式会话（Session Sharing）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E8%AE%A1%E6%95%B0%E5%99%A8%E3%80%81%E6%8E%92%E8%A1%8C%E6%A6%9C"><span class="nav-text">2.3 计数器、排行榜</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%EF%BC%88%E7%B2%89%E4%B8%9D%E3%80%81%E5%85%B3%E6%B3%A8%E3%80%81%E5%85%B1%E5%90%8C%E5%A5%BD%E5%8F%8B%EF%BC%89"><span class="nav-text">2.4 社交网络（粉丝、关注、共同好友）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88Pub-Sub%E3%80%81Stream%EF%BC%89"><span class="nav-text">2.5 消息队列（Pub&#x2F;Sub、Stream）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-text">2.6 分布式锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Redis%E7%9A%84%E5%BA%95%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-text">3. Redis的底层模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="nav-text">3.1 单线程模型：为什么这么快？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">3.2 单线程模型的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-Redis-6-0%E4%B9%8B%E5%90%8E%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">3.3 Redis 6.0之后的多线程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="nav-text">二、环境搭建与基础操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Redis%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="nav-text">1. Redis的安装与配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-Docker%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="nav-text">1.1 Docker快速安装（推荐）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Linux-Windows-macOS%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85"><span class="nav-text">1.2 Linux&#x2F;Windows&#x2F;macOS下的安装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-Linux-%E4%BB%A5Ubuntu-Debian%E4%B8%BA%E4%BE%8B"><span class="nav-text">1.2.1 Linux (以Ubuntu&#x2F;Debian为例)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-macOS"><span class="nav-text">1.2.2 macOS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-Windows-%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%94%A8%E4%BA%8E%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83"><span class="nav-text">1.2.3 Windows (不推荐用于生产环境)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-redis-conf%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%A7%A3%E8%AF%BB"><span class="nav-text">1.3 redis.conf核心配置项解读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Redis%E5%AE%A2%E6%88%B7%E7%AB%AFredis-cli"><span class="nav-text">2. Redis客户端redis-cli</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E8%BF%9E%E6%8E%A5Redis%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">2.1 连接Redis服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5"><span class="nav-text">2.2 常用命令实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-raw-%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">2.3 --raw 参数的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E6%9B%B4%E5%A4%9Aredis-cli%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="nav-text">2.4 更多redis-cli实用技巧</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3"><span class="nav-text">三、核心数据结构详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-String-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">1. String (字符串)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">1.1 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9ASDS%EF%BC%88%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span class="nav-text">1.2 内部编码&#x2F;底层实现：SDS（简单动态字符串）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-text">1.3 常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">1.4 应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-List-%E5%88%97%E8%A1%A8"><span class="nav-text">2. List (列表)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">2.1 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9Aziplist-%E6%88%96-quicklist"><span class="nav-text">2.2 内部编码&#x2F;底层实现：ziplist 或 quicklist</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-text">2.3 常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">2.4 应用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Hash-%E5%93%88%E5%B8%8C-%E5%AD%97%E5%85%B8"><span class="nav-text">3. Hash (哈希&#x2F;字典)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">3.1 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9Aziplist-%E6%88%96-hashtable"><span class="nav-text">3.2 内部编码&#x2F;底层实现：ziplist 或 hashtable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-text">3.3 常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">3.4 应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Set-%E9%9B%86%E5%90%88"><span class="nav-text">4. Set (集合)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">4.1 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9Aintset-%E6%88%96-hashtable"><span class="nav-text">4.2 内部编码&#x2F;底层实现：intset 或 hashtable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-text">4.3 常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">4.4 应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Sorted-Set-ZSet-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="nav-text">5. Sorted Set (ZSet, 有序集合)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">5.1 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9Aziplist-%E6%88%96-skiplist-hashtable"><span class="nav-text">5.2 底层实现：ziplist 或 skiplist + hashtable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-text">5.3 常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">5.4 应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%85%B6%E4%BB%96%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">6. 其他高级数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-Bitmap-%E4%BD%8D%E5%9B%BE"><span class="nav-text">6.1 Bitmap (位图)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-HyperLogLog"><span class="nav-text">6.2 HyperLogLog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-Geospatial-%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4"><span class="nav-text">6.3 Geospatial (地理空间)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81Java%E5%AE%9E%E6%88%98%E9%9B%86%E6%88%90-Java%E5%BC%80%E5%8F%91%E8%80%85%E6%A0%B8%E5%BF%83"><span class="nav-text">四、Java实战集成 (Java开发者核心)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Redis%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%89%E5%9E%8B"><span class="nav-text">1. Redis客户端选型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-Jedis"><span class="nav-text">1.1 Jedis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Lettuce"><span class="nav-text">1.2 Lettuce</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Redisson"><span class="nav-text">1.3 Redisson</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="nav-text">1.4 总结对比表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Spring-Boot-%E9%9B%86%E6%88%90-Redis"><span class="nav-text">2. Spring Boot 集成 Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%BC%95%E5%85%A5-spring-boot-starter-data-redis"><span class="nav-text">2.1 引入 spring-boot-starter-data-redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-application-yml-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3"><span class="nav-text">2.2 application.yml 配置详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-RedisTemplate-%E4%B8%8E-StringRedisTemplate"><span class="nav-text">2.3 RedisTemplate 与 StringRedisTemplate</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E5%B8%B8%E7%94%A8-API-%E7%A4%BA%E4%BE%8B"><span class="nav-text">2.4 常用 API 示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="nav-text">3. 序列化机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E9%BB%98%E8%AE%A4JDK%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">3.1 默认JDK序列化的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E4%BD%BF%E7%94%A8-Jackson-JSON-%E6%88%96-Protobuf-Kryo-%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="nav-text">3.2 使用 Jackson (JSON) 或 Protobuf&#x2F;Kryo 进行序列化配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E4%BD%BF%E7%94%A8-Jackson-JSON-%E2%80%94%E2%80%94-%E5%85%BC%E9%A1%BE%E5%8F%AF%E8%AF%BB%E6%80%A7%E4%B8%8E%E6%80%A7%E8%83%BD"><span class="nav-text">3.2.1 使用 Jackson (JSON) —— 兼顾可读性与性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E4%BD%BF%E7%94%A8-Protobuf-Kryo-%E2%80%94%E2%80%94-%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4%E6%80%A7%E8%83%BD"><span class="nav-text">3.2.2 使用 Protobuf &#x2F; Kryo —— 追求极致性能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E6%80%BB%E7%BB%93%E4%B8%8E%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5"><span class="nav-text">4.3 总结与选择策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81Redis%E8%BF%9B%E9%98%B6%E5%8A%9F%E8%83%BD"><span class="nav-text">五、Redis进阶功能</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BA%8B%E5%8A%A1-Transaction"><span class="nav-text">1. 事务 (Transaction)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-MULTI-EXEC-DISCARD-WATCH"><span class="nav-text">1.1 MULTI, EXEC, DISCARD, WATCH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Redis%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90"><span class="nav-text">1.2 Redis事务的ACID特性分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-WATCH-%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-text">1.3 WATCH 实现乐观锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85-Pub-Sub"><span class="nav-text">2. 发布&#x2F;订阅 (Pub&#x2F;Sub)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="nav-text">2.1 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4"><span class="nav-text">2.2 核心命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">2.3 应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E7%BC%BA%E7%82%B9"><span class="nav-text">2.4 缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Pipeline-%E7%AE%A1%E9%81%93"><span class="nav-text">3. Pipeline (管道)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="nav-text">3.1 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E4%B8%8E%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">3.2 与事务的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Java%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%AD%E7%9A%84Pipeline%E5%BA%94%E7%94%A8"><span class="nav-text">3.3 Java客户端中的Pipeline应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-Jedis-%E4%B8%AD%E7%9A%84-Pipeline"><span class="nav-text">3.3.1 Jedis 中的 Pipeline</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-Spring-Data-Redis-RedisTemplate-%E4%B8%AD%E7%9A%84-Pipeline"><span class="nav-text">3.3.2 Spring Data Redis (RedisTemplate) 中的 Pipeline</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Lua%E8%84%9A%E6%9C%AC"><span class="nav-text">4. Lua脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-EVAL-%E5%92%8C-EVALSHA"><span class="nav-text">4.1 EVAL 和 EVALSHA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Lua%E8%84%9A%E6%9C%AC"><span class="nav-text">4.2 为什么需要Lua脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84Lua%E8%84%9A%E6%9C%AC%E6%A1%88%E4%BE%8B"><span class="nav-text">4.3 编写简单的Lua脚本案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E5%AE%89%E5%85%A8%E7%9A%84CAS%E6%93%8D%E4%BD%9C%EF%BC%88%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%EF%BC%89"><span class="nav-text">4.3.1 安全的CAS操作（库存扣减）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%E5%AE%89%E5%85%A8%E5%9C%B0%E9%87%8A%E6%94%BE%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-text">4.3.2 安全地释放分布式锁</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6-%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BF%9D%E9%9A%9C"><span class="nav-text">六、持久化机制 (数据安全保障)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-RDB-Redis-Database"><span class="nav-text">1. RDB (Redis Database)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A%E5%BF%AB%E7%85%A7-Snapshot"><span class="nav-text">1.1 工作原理：快照 (Snapshot)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="nav-text">1.2 触发方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90"><span class="nav-text">1.3 优缺点分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-AOF-Append-Only-File"><span class="nav-text">2. AOF (Append Only File)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A%E5%91%BD%E4%BB%A4%E8%BF%BD%E5%8A%A0"><span class="nav-text">2.1 工作原理：命令追加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-appendfsync%E7%AD%96%E7%95%A5"><span class="nav-text">2.2 appendfsync策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-AOF%E9%87%8D%E5%86%99-Rewrite-%E6%9C%BA%E5%88%B6"><span class="nav-text">2.3 AOF重写 (Rewrite) 机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90"><span class="nav-text">2.4 优缺点分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-RDB-%E4%B8%8E-AOF-%E7%9A%84%E6%8A%89%E6%8B%A9"><span class="nav-text">3. RDB 与 AOF 的抉择</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F%EF%BC%88%E6%8E%A8%E8%8D%90%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="nav-text">3.1 生产环境如何选择？（推荐混合使用）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Redis-4-0%E5%90%8E%E7%9A%84%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">3.2 Redis 4.0后的混合持久化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%9A%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%8E%E6%89%A9%E5%B1%95"><span class="nav-text">七、企业级特性：高可用与扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-Master-Slave-Replication"><span class="nav-text">1. 主从复制 (Master-Slave Replication)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95"><span class="nav-text">1.1 配置方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="nav-text">1.2 核心原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6-Full-Resynchronization"><span class="nav-text">1.2.1 全量复制 (Full Resynchronization)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E5%A2%9E%E9%87%8F%E5%A4%8D%E5%88%B6-Partial-Resynchronization"><span class="nav-text">1.2.2 增量复制 (Partial Resynchronization)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E4%BD%9C%E7%94%A8"><span class="nav-text">1.3 作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Sentinel-%E5%93%A8%E5%85%B5-%E6%A8%A1%E5%BC%8F"><span class="nav-text">2. Sentinel (哨兵) 模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8A%9F%E8%83%BD"><span class="nav-text">2.1 功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">2.2 工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Java%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E6%95%B4%E5%90%88Sentinel"><span class="nav-text">2.3 Java客户端如何整合Sentinel</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Cluster-%E9%9B%86%E7%BE%A4-%E6%A8%A1%E5%BC%8F"><span class="nav-text">3. Cluster (集群) 模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87-Sharding-%E6%A8%A1%E5%9E%8B%EF%BC%9A%E5%93%88%E5%B8%8C%E6%A7%BD-Hash-Slot"><span class="nav-text">3.1 数据分片 (Sharding) 模型：哈希槽 (Hash Slot)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Gossip%E5%8D%8F%E8%AE%AE%E4%B8%8E%E8%8A%82%E7%82%B9%E9%80%9A%E4%BF%A1"><span class="nav-text">3.2 Gossip协议与节点通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-redis-cli-%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E9%9B%86%E7%BE%A4"><span class="nav-text">3.3 redis-cli 创建和管理集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-Cluster%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-text">3.4 Cluster模式下的限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-Java%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E6%95%B4%E5%90%88Cluster"><span class="nav-text">3.5 Java客户端如何整合Cluster</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">八、企业级开发设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1"><span class="nav-text">1. 缓存设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="nav-text">1.1 缓存更新策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-Cache-Aside-%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F-%E2%80%94%E2%80%94-%E6%9C%80%E5%B8%B8%E7%94%A8"><span class="nav-text">1.1.1 Cache-Aside (旁路缓存模式) —— 最常用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-Read-Write-Through-%E8%AF%BB-%E5%86%99%E7%A9%BF%E9%80%8F%E6%A8%A1%E5%BC%8F"><span class="nav-text">1.1.2 Read&#x2F;Write Through (读&#x2F;写穿透模式)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-Write-Back-%E5%9B%9E%E5%86%99-%E5%86%99%E5%90%8E%E6%A8%A1%E5%BC%8F"><span class="nav-text">1.1.3 Write-Back (回写&#x2F;写后模式)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E7%BC%93%E5%AD%98%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">1.2 缓存三大问题与解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-Cache-Penetration"><span class="nav-text">1.2.1 缓存穿透 (Cache Penetration)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-Cache-Breakdown"><span class="nav-text">1.2.2 缓存击穿 (Cache Breakdown)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-Cache-Avalanche"><span class="nav-text">1.2.3 缓存雪崩 (Cache Avalanche)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-text">2. 分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-SETNX%E5%AE%9E%E7%8E%B0%E7%9A%84-Naive-%E9%94%81%E5%8F%8A%E5%85%B6%E9%97%AE%E9%A2%98"><span class="nav-text">2.1 SETNX实现的 Naive 锁及其问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-SET-key-value-NX-PX-timeout-%E5%8E%9F%E5%AD%90%E5%91%BD%E4%BB%A4%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.2 SET key value NX PX timeout 原子命令实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E9%94%81%E7%9A%84-Owner-%E6%A0%87%E8%AF%86%E4%B8%8E-LUA-%E8%84%9A%E6%9C%AC%E5%AE%89%E5%85%A8%E9%87%8A%E6%94%BE"><span class="nav-text">2.3 锁的 Owner 标识与 LUA 脚本安全释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-Redisson-RLock-%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E4%B8%8E%E7%9C%8B%E9%97%A8%E7%8B%97-Watchdog-%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86"><span class="nav-text">2.4 Redisson RLock 的可重入锁与看门狗 (Watchdog) 机制原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-RedLock%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="nav-text">2.5 RedLock算法思想</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%85%B6%E4%BB%96%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">3. 其他设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E9%99%90%E6%B5%81%E5%99%A8-Rate-Limiter"><span class="nav-text">3.1 限流器 (Rate Limiter)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E7%AE%80%E5%8D%95%E8%AE%A1%E6%95%B0%E5%99%A8%E9%99%90%E6%B5%81-INCR-EXPIRE"><span class="nav-text">3.1.1 简单计数器限流 (INCR + EXPIRE)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81-ZSet%E5%AE%9E%E7%8E%B0"><span class="nav-text">3.1.2 滑动窗口限流 (ZSet实现)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97-Delayed-Queue"><span class="nav-text">3.2 延迟队列 (Delayed Queue)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">九、性能优化与最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="nav-text">1. 内存优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%90%88%E7%90%86%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">1.1 合理选择数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%A6%82%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%EF%BC%89"><span class="nav-text">1.1.1 存储对象（如用户信息）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E5%AD%98%E5%82%A8%E5%A4%A7%E9%87%8F%E6%95%B4%E6%95%B0ID"><span class="nav-text">1.1.2 存储大量整数ID</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-maxmemory-%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5-LRU-LFU-etc"><span class="nav-text">1.2 maxmemory 与内存淘汰策略 (LRU, LFU, etc.)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-maxmemory"><span class="nav-text">1.2.1 maxmemory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5-maxmemory-policy"><span class="nav-text">1.2.2 内存淘汰策略 (maxmemory-policy)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E8%AD%A6%E6%83%95%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="nav-text">1.3 警惕内存碎片</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">2. 命令使用最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E9%81%BF%E5%85%8D%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4"><span class="nav-text">2.1 避免慢查询命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E4%BD%BF%E7%94%A8-SCAN-HSCAN-SSCAN-ZSCAN-%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3"><span class="nav-text">2.2 使用 SCAN &#x2F; HSCAN &#x2F; SSCAN &#x2F; ZSCAN 进行迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%96%84%E7%94%A8-MSET-MGET-Pipeline"><span class="nav-text">2.3 批量操作善用 MSET&#x2F;MGET&#x2F;Pipeline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-Key-Value%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="nav-text">2.4 Key&#x2F;Value设计规范</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-Key-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="nav-text">2.4.1 Key 命名规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-Value-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="nav-text">2.4.2 Value 设计规范</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96"><span class="nav-text">3. 客户端优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E4%BD%BF%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-text">3.1 使用连接池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E9%95%BF%E8%BF%9E%E6%8E%A5-vs-%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="nav-text">3.2 长连接 vs 短连接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E3%80%81%E8%BF%90%E7%BB%B4%E4%B8%8E%E7%9B%91%E6%8E%A7"><span class="nav-text">十、运维与监控</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87"><span class="nav-text">1. 核心监控指标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-INFO-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="nav-text">1.1 INFO 命令详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E9%87%8D%E7%82%B9%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87%E4%B8%8E%E8%A7%A3%E8%AF%BB"><span class="nav-text">1.2 重点监控指标与解读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-Troubleshooting"><span class="nav-text">2. 常见问题排查 (Troubleshooting)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Big-Key-%E5%A4%A7Key-%E9%97%AE%E9%A2%98"><span class="nav-text">2.1 Big Key (大Key) 问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E4%BB%80%E4%B9%88%E6%98%AFBig-Key%EF%BC%9F"><span class="nav-text">2.1.1 什么是Big Key？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-Big-Key%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="nav-text">2.1.2 Big Key的危害</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0Big-Key%EF%BC%9F"><span class="nav-text">2.1.3 如何发现Big Key？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Big-Key%EF%BC%9F"><span class="nav-text">2.1.4 如何处理Big Key？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Hot-Key-%E7%83%AD%E7%82%B9Key-%E9%97%AE%E9%A2%98"><span class="nav-text">2.2 Hot Key (热点Key) 问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0Hot-Key%EF%BC%9F"><span class="nav-text">2.2.1 如何发现Hot Key？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Hot-Key%EF%BC%9F"><span class="nav-text">2.2.2 如何处理Hot Key？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E8%BF%9E%E6%8E%A5%E6%95%B0%E5%BC%82%E5%B8%B8"><span class="nav-text">2.3 连接数异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E7%8E%B0%E8%B1%A1"><span class="nav-text">2.3.1 现象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="nav-text">2.3.2 原因分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="nav-text">2.3.3 如何处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Redis%E5%AE%89%E5%85%A8"><span class="nav-text">3. Redis安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E8%AE%BE%E7%BD%AE%E5%A4%8D%E6%9D%82%E5%AF%86%E7%A0%81-requirepass"><span class="nav-text">3.1 设置复杂密码 (requirepass)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E7%A6%81%E7%94%A8%E6%88%96%E9%87%8D%E5%91%BD%E5%90%8D%E5%8D%B1%E9%99%A9%E5%91%BD%E4%BB%A4-rename-command"><span class="nav-text">3.2 禁用或重命名危险命令 (rename-command)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E7%BB%91%E5%AE%9AIP-bind-%E4%B8%8E%E9%98%B2%E7%81%AB%E5%A2%99%E7%AD%96%E7%95%A5"><span class="nav-text">3.3 绑定IP (bind) 与防火墙策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E7%BB%91%E5%AE%9AIP-bind"><span class="nav-text">3.3.1 绑定IP (bind)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E9%98%B2%E7%81%AB%E5%A2%99%E7%AD%96%E7%95%A5"><span class="nav-text">3.3.2 防火墙策略</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Redis | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-25 11:25:45" itemprop="dateCreated datePublished" datetime="2025-10-25T11:25:45+08:00">2025-10-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-26 13:42:01" itemprop="dateModified" datetime="2025-10-26T13:42:01+08:00">2025-10-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">数据库与持久化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="一、Redis入门与核心概念"><a href="#一、Redis入门与核心概念" class="headerlink" title="一、Redis入门与核心概念"></a>一、Redis入门与核心概念</h1><h2 id="1-Redis是什么？"><a href="#1-Redis是什么？" class="headerlink" title="1. Redis是什么？"></a>1. Redis是什么？</h2><p>Redis（<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver，远程字典服务器）是一个开源的、基于<strong>内存</strong>的、使用C语言编写的、高性能的<strong>键值（Key-Value）数据库</strong>。它通常被看作是一个数据结构服务器，因为值的类型可以是字符串、哈希、列表、集合、有序集合等多种丰富的类型。</p>
<h3 id="1-1-NoSQL数据库、KV数据库、内存数据库"><a href="#1-1-NoSQL数据库、KV数据库、内存数据库" class="headerlink" title="1.1 NoSQL数据库、KV数据库、内存数据库"></a>1.1 NoSQL数据库、KV数据库、内存数据库</h3><p>这三个术语从不同维度描述了Redis的核心特征：</p>
<ul>
<li><strong>NoSQL数据库 (Not Only SQL)</strong><ul>
<li><strong>定义</strong>：与传统的关系型数据库不同，NoSQL数据库不保证遵循严格的ACID（原子性、一致性、隔离性、持久性）原则，而是更侧重于性能、可扩展性和数据模型的灵活性（非结构化）。</li>
<li><strong>Redis的体现</strong>：Redis的数据之间没有复杂的关系，易于横向扩展（通过集群），并且提供了灵活的键值模型，非常适合需要快速读写的场景，而不是处理复杂关系查询的场景。</li>
</ul>
</li>
<li><strong>KV数据库 (Key-Value)</strong><ul>
<li><strong>定义</strong>：一种最简单的数据库模型，数据以键值对的形式存储。通过一个唯一的键（Key），可以快速地存储、查询、更新或删除对应的值（Value）。</li>
<li><strong>Redis的体现</strong>：这是Redis最根本的数据模型。但Redis的强大之处在于，它的Value不仅仅是简单的字符串，而是<strong>丰富的数据结构</strong>，这使得它超越了普通的KV存储，能够在服务端直接对数据进行复杂操作。<ul>
<li>例如：你可以把一个用户的ID作为Key，一个<code>Hash</code>结构作为Value来存储该用户的姓名、年龄、邮箱等多个字段信息。</li>
</ul>
</li>
</ul>
</li>
<li><strong>内存数据库 (In-Memory)</strong><ul>
<li><strong>定义</strong>：将所有数据都存储在计算机内存（RAM）中的数据库。由于内存的读写速度远快于磁盘（通常是几个数量级的差距），内存数据库能提供极高的性能。  </li>
<li><strong>Redis的体现</strong>：Redis是典型的内存数据库。它的所有读写操作都在内存中完成，这也是Redis能达到每秒数十万次读写（QPS）的关键原因。当然，为了防止断电等意外导致数据丢失，Redis也提供了<strong>持久化</strong>机制，可以将内存中的数据定期或实时地写入磁盘。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-Redis的特性"><a href="#1-2-Redis的特性" class="headerlink" title="1.2 Redis的特性"></a>1.2 Redis的特性</h3><ul>
<li><strong>高性能</strong>：<ul>
<li><strong>纯内存操作</strong>：所有操作基于内存，速度极快。</li>
<li><strong>单线程模型</strong>：Redis 6.0之前，核心网络模型采用单线程处理客户端请求，避免了多线程上下文切换和锁竞争带来的开销。</li>
<li><strong>I&#x2F;O多路复用</strong>：采用<code>epoll</code>、<code>kqueue</code>等I&#x2F;O多路复用技术，使其单线程也能高效处理大量的并发连接。可以理解为：一个服务员（线程）高效地同时照看很多张桌子（连接），只要有桌子需要服务（I&#x2F;O事件发生），他马上过去处理。</li>
</ul>
</li>
<li><strong>丰富的数据结构</strong>：<ul>
<li>这是Redis区别于Memcached等其他KV存储的重要特征。它内置了String, List, Hash, Set, ZSet等结构，使得开发者可以直接在服务端完成很多复杂操作，而无需将数据取回客户端再处理。这大大减少了网络开销，简化了应用逻辑。</li>
</ul>
</li>
<li><strong>持久化 (Persistence)</strong>：<ul>
<li>支持**RDB（快照）<strong>和</strong>AOF（追加日志）**两种持久化方式，可以在服务器重启后恢复数据。4.0版本后还支持混合持久化。</li>
</ul>
</li>
<li><strong>高可用与可扩展性 (High Availability &amp; Scalability)</strong>：<ul>
<li><strong>主从复制 (Replication)</strong>：实现数据备份和读写分离。</li>
<li><strong>哨兵模式 (Sentinel)</strong>：自动监控主节点状态，在主节点宕机时实现自动故障转移。</li>
<li><strong>集群模式 (Cluster)</strong>：通过数据分片（Sharding）实现横向扩展，将数据分布到多个节点上，突破单机内存和性能瓶颈。</li>
</ul>
</li>
<li><strong>其他功能</strong>：<ul>
<li>支持<strong>事务</strong>（但非严格ACID）。</li>
<li>支持**发布&#x2F;订阅（Pub&#x2F;Sub）**模式，可用于构建消息系统。</li>
<li>支持<strong>Lua脚本</strong>，可以将多个命令打包成一个原子操作，减少网络延迟。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-Redis-vs-MySQL"><a href="#1-3-Redis-vs-MySQL" class="headerlink" title="1.3 Redis vs MySQL"></a>1.3 Redis vs MySQL</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Redis</th>
<th align="left">MySQL (代表关系型数据库)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据模型</strong></td>
<td align="left">丰富数据结构 (String, List, Hash, Set, ZSet等)</td>
<td align="left">结构化的二维表 (行和列)</td>
</tr>
<tr>
<td align="left"><strong>存储介质</strong></td>
<td align="left">主要在内存，可持久化到磁盘</td>
<td align="left">主要在磁盘</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">极高</td>
<td align="left">相对较低（磁盘I&#x2F;O是瓶颈）</td>
</tr>
<tr>
<td align="left"><strong>持久化</strong></td>
<td align="left">支持 RDB 和 AOF</td>
<td align="left">支持，ACID保证数据可靠</td>
</tr>
<tr>
<td align="left"><strong>高可用</strong></td>
<td align="left">主从复制、哨兵、集群</td>
<td align="left">主从复制、集群等成熟方案</td>
</tr>
<tr>
<td align="left"><strong>应用场景</strong></td>
<td align="left">缓存、分布式锁、排行榜、计数器、消息队列等</td>
<td align="left">业务数据的持久化存储、事务性操作、复杂查询</td>
</tr>
</tbody></table>
<p><strong>典型架构组合</strong>：</p>
<p>在Java后端应用中，最常见的组合是 <strong>MySQL + Redis</strong>。MySQL作为最终的数据存储（Source of Truth），Redis作为其前端的高性能缓存和功能扩展。用户的请求优先访问Redis，如果Redis中没有数据（Cache Miss），再去查询MySQL，并将结果写回Redis，以便下次快速访问。</p>
<hr>
<h2 id="2-Redis的典型应用场景"><a href="#2-Redis的典型应用场景" class="headerlink" title="2. Redis的典型应用场景"></a>2. Redis的典型应用场景</h2><h4 id="2-1-缓存"><a href="#2-1-缓存" class="headerlink" title="2.1 缓存"></a>2.1 缓存</h4><ul>
<li><strong>场景描述</strong>：当应用的用户量和并发量上来后，数据库往往成为性能瓶颈。频繁地读取相同的数据（如热点新闻、商品详情）会给数据库带来巨大压力。</li>
<li><strong>Redis解决方案</strong>：将热点数据存储在Redis中（作为缓存层），绝大部分请求将直接从Redis获取数据，而无需访问后端数据库。这大大降低了数据库的压力，并极大地提升了应用的响应速度。<ul>
<li><strong>数据缓存</strong>：缓存数据库中的记录，通常以JSON格式存储。</li>
<li><strong>页面缓存</strong>：缓存渲染好的HTML页面片段。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-分布式会话（Session-Sharing）"><a href="#2-2-分布式会话（Session-Sharing）" class="headerlink" title="2.2 分布式会话（Session Sharing）"></a>2.2 分布式会话（Session Sharing）</h4><ul>
<li><strong>场景描述</strong>：在分布式或集群环境下，应用被部署在多台服务器上。如果Session存储在单台服务器的内存中，负载均衡器将用户的下一个请求转发到另一台服务器时，就会导致Session丢失，用户需要重新登录。</li>
<li><strong>Redis解决方案</strong>：将所有服务器的Session数据集中存储在Redis中。无论用户的请求被哪台服务器处理，都可以通过同一个Session ID从Redis中获取到一致的会话信息。</li>
</ul>
<hr>
<h4 id="2-3-计数器、排行榜"><a href="#2-3-计数器、排行榜" class="headerlink" title="2.3 计数器、排行榜"></a>2.3 计数器、排行榜</h4><ul>
<li><strong>场景描述</strong>：需要实时统计和展示一些动态变化的数字，如文章阅读量、视频点赞数、商品销量榜、游戏积分榜等。关系型数据库在应对高并发的计数更新时，行锁的开销很大，性能较差。</li>
<li><strong>Redis解决方案</strong>：利用Redis原子性的、纳秒级的内存操作来实现。</li>
</ul>
<hr>
<h4 id="2-4-社交网络（粉丝、关注、共同好友）"><a href="#2-4-社交网络（粉丝、关注、共同好友）" class="headerlink" title="2.4 社交网络（粉丝、关注、共同好友）"></a>2.4 社交网络（粉丝、关注、共同好友）</h4><ul>
<li><strong>场景描述</strong>：在社交应用中，需要快速计算用户之间的关系，如A关注了B，A和C的共同关注是谁等。在关系型数据库中，这些操作通常需要复杂的<code>JOIN</code>查询，效率低下。</li>
<li><strong>Redis解决方案</strong>：利用Set集合的特性（无序、唯一）可以非常自然地模拟用户关系。</li>
</ul>
<hr>
<h4 id="2-5-消息队列（Pub-Sub、Stream）"><a href="#2-5-消息队列（Pub-Sub、Stream）" class="headerlink" title="2.5 消息队列（Pub&#x2F;Sub、Stream）"></a>2.5 消息队列（Pub&#x2F;Sub、Stream）</h4><ul>
<li><strong>场景描述</strong>：在系统架构中，为了解耦和异步处理，常常需要消息队列。例如，用户下单后，需要触发发送邮件、更新库存、通知物流等一系列后续操作，这些操作可以异步执行，从而快速响应用户。</li>
<li><strong>Redis解决方案</strong>：Redis提供了多种实现消息队列的机制，可以满足从简单到复杂的不同需求。</li>
</ul>
<hr>
<h4 id="2-6-分布式锁"><a href="#2-6-分布式锁" class="headerlink" title="2.6 分布式锁"></a>2.6 分布式锁</h4><ul>
<li><strong>场景描述</strong>：在分布式系统中，多个服务实例需要竞争访问同一个共享资源（如秒杀场景下的商品库存）。需要一种机制来保证同一时刻只有一个实例能够操作该资源，防止数据不一致。</li>
<li><strong>Redis解决方案</strong>：利用Redis命令的原子性（如<code>SETNX</code>）来模拟锁的获取和释放。</li>
</ul>
<hr>
<h2 id="3-Redis的底层模型"><a href="#3-Redis的底层模型" class="headerlink" title="3. Redis的底层模型"></a>3. Redis的底层模型</h2><p>Redis的核心网络模型在版本6.0之前一直以<strong>单线程</strong>著称。这个设计选择常常让人疑惑：在一个多核CPU普及的时代，为什么一个高性能的数据库会选择单线程？</p>
<h4 id="3-1-单线程模型：为什么这么快？"><a href="#3-1-单线程模型：为什么这么快？" class="headerlink" title="3.1 单线程模型：为什么这么快？"></a>3.1 单线程模型：为什么这么快？</h4><p>Redis的“单线程”指的是其<strong>处理网络请求和执行命令的核心模块是单线程的</strong>。而像持久化（RDB、AOF）、异步删除等耗时操作，Redis会使用后台线程（background threads）或子进程来处理，以避免阻塞主线程。</p>
<p>Redis单线程模型之所以能达到极高的性能，主要归功于以下三点：</p>
<p><strong>1. 纯内存操作 (Pure In-Memory Operations)</strong></p>
<ul>
<li><strong>根本原因</strong>：这是Redis速度快的根本。所有的数据都存储在内存中，而内存的读写速度比磁盘快几个数量级（通常是纳秒 vs 毫秒）。这意味着数据库的主要瓶颈——磁盘I&#x2F;O——在Redis的常规操作中完全不存在。相比之下，像MySQL这样的数据库，即使有缓存，大部分数据仍在磁盘上，查询不可避免地会涉及慢速的磁盘读写。</li>
</ul>
<p><strong>2. I&#x2F;O多路复用 (I&#x2F;O Multiplexing)</strong></p>
<ul>
<li><strong>核心技术</strong>：这是单线程模型能够高效处理并发连接的关键。Redis使用了<code>epoll</code>（在Linux下）或类似的系统调用（如<code>kqueue</code>、<code>select</code>）。</li>
<li><strong>工作方式</strong>：<ul>
<li><strong>传统模型</strong>：一个线程处理一个连接，或者使用线程池。当连接不活跃时，线程会处于阻塞等待状态，浪费CPU资源，且线程间的上下文切换开销巨大。</li>
<li><strong>Redis模型</strong>：Redis将所有客户端连接都注册到一个事件处理器（即I&#x2F;O多路复用程序）中。这个单线程的主循环会不断地轮询这些连接，问：“谁准备好了？”<ul>
<li>当某个连接有数据可读（例如，客户端发送了一个<code>SET</code>命令），主线程就去读取数据、执行命令。</li>
<li>当需要向某个连接写数据时，主线程就将数据写入。</li>
</ul>
</li>
</ul>
</li>
<li><strong>优势</strong>：通过I&#x2F;O多路复用，单个线程可以无阻塞地处理成千上万个并发连接，避免了创建和销毁线程以及线程上下文切换所带来的巨大开销。</li>
</ul>
<p><strong>3. 避免了多线程的上下文切换和锁竞争</strong></p>
<ul>
<li><strong>无锁竞争</strong>：由于所有命令都在一个线程中串行执行，因此天然不存在多线程环境下对共享资源的竞争问题（如同时修改同一个key）。这使得Redis的数据操作无需加锁，大大简化了实现，并消除了锁操作带来的性能开销。</li>
<li><strong>无上下文切换</strong>：单线程模型避免了在多个线程之间进行CPU上下文切换的成本。在并发量极高的情况下，这部分开销不容小觑。</li>
</ul>
<blockquote>
<p><strong>小结</strong>：Redis的快，是因为它<strong>扬长避短</strong>。它将所有操作都放在了速度飞快的内存里，并用I&#x2F;O多路复用技术让它的单线程专注于处理实际的计算任务，而不是把时间浪费在等待I&#x2F;O和线程切换上。</p>
</blockquote>
<hr>
<h4 id="3-2-单线程模型的优缺点"><a href="#3-2-单线程模型的优缺点" class="headerlink" title="3.2 单线程模型的优缺点"></a>3.2 单线程模型的优缺点</h4><p><strong>优点 (Advantages):</strong></p>
<ol>
<li><strong>实现简单，易于维护</strong>：代码逻辑清晰，避免了处理复杂的线程同步和死锁问题。</li>
<li><strong>天然的原子性</strong>：由于所有命令串行执行，单个命令的操作是原子性的，无需担心并发导致的数据错乱。</li>
<li><strong>高性能</strong>：没有锁竞争和上下文切换的开销。</li>
<li><strong>可预测性</strong>：执行顺序是确定的，便于排查问题。</li>
</ol>
<p><strong>缺点 (Disadvantages):</strong></p>
<ol>
<li><strong>无法利用多核CPU</strong>：这是最主要的缺点。单线程意味着Redis实例只能利用一个CPU核心来进行命令处理。对于计算密集型的操作，无法通过增加CPU核心来提升性能。<ul>
<li><strong>解决方案</strong>：在单台服务器上部署多个Redis实例（每个实例绑定一个CPU核心），或者直接使用Redis集群（Cluster）来横向扩展。</li>
</ul>
</li>
<li><strong>耗时命令会阻塞所有请求</strong>：因为所有命令是排队执行的，如果一个命令执行时间过长（例如，对一个包含数百万成员的Set执行<code>SMEMBERS</code>，或者使用了<code>KEYS *</code>），它会阻塞后面所有的请求，导致整个服务“卡顿”。<ul>
<li><strong>警示</strong>：这是Redis开发中必须遵守的铁律——<strong>永远不要使用可能导致阻塞的慢命令</strong>。应使用<code>SCAN</code>、<code>HSCAN</code>等命令进行增量迭代。</li>
</ul>
</li>
<li><strong>单点性能瓶颈</strong>：单个线程的QPS（每秒查询率）终究是有上限的，它受限于CPU主频。</li>
</ol>
<hr>
<h4 id="3-3-Redis-6-0之后的多线程"><a href="#3-3-Redis-6-0之后的多线程" class="headerlink" title="3.3 Redis 6.0之后的多线程"></a>3.3 Redis 6.0之后的多线程</h4><p>为了改进单线程模型无法利用多核CPU的缺点，Redis从<strong>6.0版本</strong>开始引入了<strong>多线程</strong>。</p>
<ul>
<li><strong>但请注意</strong>：Redis的多线程<strong>并非</strong>用于执行命令，而是用于<strong>处理网络I&#x2F;O</strong>（读取请求和写回响应）。</li>
<li><strong>工作流程</strong>：<ol>
<li>主线程接收连接，并将读取任务分发给I&#x2F;O线程。</li>
<li>I&#x2F;O线程并行地从Socket中读取客户端请求，然后将解析好的命令交给主线程。</li>
<li><strong>主线程依然是单线程，串行地执行命令。</strong></li>
<li>主线程执行完命令后，将响应结果再分发给I&#x2F;O线程。</li>
<li>I&#x2F;O线程并行地将响应写回到各自的客户端Socket。</li>
</ol>
</li>
<li><strong>结论</strong>：Redis 6.0的多线程优化的是<strong>网络I&#x2F;O的瓶颈</strong>，尤其是在高并发、大数据包的场景下，能显著提升吞吐量。但其<strong>命令执行的核心仍然是单线程的</strong>，从而保留了原有模型的简单、无锁、原子性等所有优点。</li>
</ul>
<hr>
<h1 id="二、环境搭建与基础操作"><a href="#二、环境搭建与基础操作" class="headerlink" title="二、环境搭建与基础操作"></a>二、环境搭建与基础操作</h1><h2 id="1-Redis的安装与配置"><a href="#1-Redis的安装与配置" class="headerlink" title="1. Redis的安装与配置"></a>1. Redis的安装与配置</h2><h3 id="1-1-Docker快速安装（推荐）"><a href="#1-1-Docker快速安装（推荐）" class="headerlink" title="1.1 Docker快速安装（推荐）"></a>1.1 Docker快速安装（推荐）</h3><p>对于开发者来说，使用Docker是安装和管理Redis最方便、最快捷的方式，它可以隔离环境，避免与宿主机系统产生冲突。</p>
<p><strong>步骤：</strong></p>
<ol>
<li><p><strong>拉取Redis镜像</strong><br>从Docker Hub上拉取官方的Redis镜像。通常建议指定版本号，例如<code>7.0</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:7.0</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动一个基本的Redis容器</strong><br>这是一个最简单的启动方式，适合快速测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --name my-redis: 给容器命名为my-redis</span></span><br><span class="line"><span class="comment"># -d: 后台运行 (detached mode)</span></span><br><span class="line"><span class="comment"># -p 6379:6379: 将宿主机的6379端口映射到容器的6379端口</span></span><br><span class="line">docker run --name my-redis -d -p 6379:6379 redis:7.0</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动并挂载自定义配置文件和数据目录（生产推荐）</strong><br>为了持久化数据和自定义配置，你应该将配置文件和数据目录挂载到宿主机上。</p>
<ul>
<li><p>首先，在宿主机上创建一个目录和配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /mydata/redis/conf</span><br><span class="line"><span class="built_in">mkdir</span> -p /mydata/redis/data</span><br><span class="line"><span class="comment"># 创建一个空的或从官方拷贝一个redis.conf文件</span></span><br><span class="line"><span class="built_in">touch</span> /mydata/redis/conf/redis.conf </span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑 <code>/mydata/redis/conf/redis.conf</code>，例如，添加密码：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> 在redis.conf中添加或修改</span><br><span class="line">requirepass your<span class="built_in">_</span>password</span><br><span class="line">appendonly yes                                                                                               </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用挂载方式启动容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name my-redis-pro \</span><br><span class="line">  -p 6379:6379 \</span><br><span class="line">  -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">  -v /mydata/redis/data:/data \</span><br><span class="line">  redis:7.0 \</span><br><span class="line">  redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf</code>: 将宿主机的配置文件挂载到容器内。</li>
<li><code>-v /mydata/redis/data:/data</code>: 将宿主机的数据目录挂载到容器的持久化数据目录。</li>
<li><code>redis-server /etc/redis/redis.conf</code>: 容器启动后，用指定的配置文件启动Redis服务。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>连接测试</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it my-redis-pro redis-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果设置了密码</span></span><br><span class="line">&gt; AUTH your_password</span><br><span class="line">&gt; PING</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="1-2-Linux-Windows-macOS下的安装"><a href="#1-2-Linux-Windows-macOS下的安装" class="headerlink" title="1.2 Linux&#x2F;Windows&#x2F;macOS下的安装"></a>1.2 Linux&#x2F;Windows&#x2F;macOS下的安装</h3><h4 id="1-2-1-Linux-以Ubuntu-Debian为例"><a href="#1-2-1-Linux-以Ubuntu-Debian为例" class="headerlink" title="1.2.1 Linux (以Ubuntu&#x2F;Debian为例)"></a>1.2.1 Linux (以Ubuntu&#x2F;Debian为例)</h4><ul>
<li><p>使用<code>apt</code>包管理器安装，非常方便，但版本可能不是最新的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install redis-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动和管理Redis服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start redis-server</span><br><span class="line"><span class="comment"># 设置开机自启</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> redis-server</span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status redis-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件路径通常在 <code>/etc/redis/redis.conf</code>。</p>
</li>
</ul>
<hr>
<h4 id="1-2-2-macOS"><a href="#1-2-2-macOS" class="headerlink" title="1.2.2 macOS"></a>1.2.2 macOS</h4><ul>
<li><p>推荐使用<code>Homebrew</code>进行安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动和管理Redis服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">brew services start redis</span><br><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">brew services stop redis</span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">brew services restart redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件路径通常在 <code>/usr/local/etc/redis.conf</code> (Intel芯片) 或 <code>/opt/homebrew/etc/redis.conf</code> (Apple M系列芯片)。</p>
</li>
</ul>
<hr>
<h4 id="1-2-3-Windows-不推荐用于生产环境"><a href="#1-2-3-Windows-不推荐用于生产环境" class="headerlink" title="1.2.3 Windows (不推荐用于生产环境)"></a>1.2.3 Windows (不推荐用于生产环境)</h4><ul>
<li>Windows官方不直接支持Redis。但可以从Microsoft的归档<a target="_blank" rel="noopener" href="https://github.com/microsoftarchive/redis/releases">GitHub release页面</a>下载MSOpenTech的编译版本（版本较旧）。</li>
<li>更好的方式是在Windows上使用 <strong>WSL (Windows Subsystem for Linux)</strong>，然后在WSL的Linux环境中按照Linux的方式安装和运行Redis。这是目前在Windows上进行Redis开发的主流方式。</li>
</ul>
<hr>
<h3 id="1-3-redis-conf核心配置项解读"><a href="#1-3-redis-conf核心配置项解读" class="headerlink" title="1.3 redis.conf核心配置项解读"></a>1.3 <code>redis.conf</code>核心配置项解读</h3><p><code>redis.conf</code>是Redis的配置文件，包含了大量的配置选项。以下是必须了解和关注的核心配置项：</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left">默认值</th>
<th align="left">描述与建议</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>bind 127.0.0.1</code></strong></td>
<td align="left"><code>127.0.0.1 -::1</code></td>
<td align="left"><strong>[安全]</strong> 绑定的IP地址。默认只允许本地连接。<strong>生产环境</strong>应修改为内网IP地址，如<code>bind 192.168.1.100</code>。如果想允许任何IP访问，可以设置为<code>bind 0.0.0.0</code>，但<strong>极不推荐</strong>，必须配合防火墙和强密码。</td>
</tr>
<tr>
<td align="left"><strong><code>port 6379</code></strong></td>
<td align="left"><code>6379</code></td>
<td align="left"><strong>[连接]</strong> Redis监听的端口号。可以根据需要修改。</td>
</tr>
<tr>
<td align="left"><strong><code>requirepass foobared</code></strong></td>
<td align="left">(注释掉)</td>
<td align="left"><strong>[安全]</strong> 设置客户端连接密码。<strong>强烈建议在生产环境中开启</strong>并设置一个复杂的密码。例如：<code>requirepass YourComplexPassword</code>。</td>
</tr>
<tr>
<td align="left"><strong><code>daemonize yes</code></strong></td>
<td align="left"><code>no</code></td>
<td align="left"><strong>[运行模式]</strong> 是否以守护进程（后台）模式运行。<code>yes</code>表示后台运行，<code>no</code>表示前台运行（日志会直接打印在终端）。通过<code>systemctl</code>或<code>brew services</code>启动时，这个值通常会被覆盖，不用手动改。</td>
</tr>
<tr>
<td align="left"><strong><code>logfile &quot;&quot;</code></strong></td>
<td align="left"><code>&quot;&quot;</code></td>
<td align="left"><strong>[日志]</strong> 日志文件的路径。如果<code>daemonize</code>为<code>yes</code>，则必须指定一个日志文件路径。例如：<code>logfile /var/log/redis/redis-server.log</code>。</td>
</tr>
<tr>
<td align="left"><strong><code>databases 16</code></strong></td>
<td align="left"><code>16</code></td>
<td align="left"><strong>[数据库]</strong> Redis支持多个数据库，编号从0到15。客户端可以通过<code>SELECT</code>命令切换数据库。<strong>不推荐使用多DB</strong>，因为它们共享同一个线程和内存，隔离性差。在集群模式下，只支持<code>db 0</code>。现代开发更倾向于为不同业务启动不同的Redis实例。</td>
</tr>
<tr>
<td align="left"><strong><code>save &lt;seconds&gt; &lt;changes&gt;</code></strong></td>
<td align="left"><code>save 900 1</code><br><code>save 300 10</code><br><code>save 60 10000</code></td>
<td align="left"><strong>[持久化-RDB]</strong> RDB快照的触发条件。<code>save 900 1</code>表示在900秒内，如果至少有1个key发生变化，则触发一次快照。可以配置多条规则。</td>
</tr>
<tr>
<td align="left"><strong><code>appendonly no</code></strong></td>
<td align="left"><code>no</code></td>
<td align="left"><strong>[持久化-AOF]</strong> 是否开启AOF持久化。<code>yes</code>表示开启。<strong>生产环境强烈建议开启</strong>以获得更高的数据安全性。</td>
</tr>
<tr>
<td align="left"><strong><code>appendfsync everysec</code></strong></td>
<td align="left"><code>everysec</code></td>
<td align="left"><strong>[持久化-AOF]</strong> AOF的同步策略。<code>everysec</code>（每秒同步一次，推荐，兼顾性能和安全）、<code>always</code>（每个命令都同步，最安全但最慢）、<code>no</code>（由操作系统决定何时同步）。</td>
</tr>
<tr>
<td align="left"><strong><code>maxmemory &lt;bytes&gt;</code></strong></td>
<td align="left">(无限制)</td>
<td align="left"><strong>[内存管理]</strong> <strong>极其重要！</strong> 设置Redis实例能使用的最大内存。例如<code>maxmemory 2gb</code>。当内存达到上限时，会根据<code>maxmemory-policy</code>执行淘汰策略。<strong>生产环境必须设置</strong>，防止Redis耗尽服务器所有内存。</td>
</tr>
<tr>
<td align="left"><strong><code>maxmemory-policy noeviction</code></strong></td>
<td align="left"><code>noeviction</code></td>
<td align="left"><strong>[内存管理]</strong> 内存淘汰策略。<code>noeviction</code>（默认，内存满时写操作会报错）、<code>volatile-lru</code>（在设置了过期时间的key中，淘汰最近最少使用的，<strong>推荐用于缓存</strong>）、<code>allkeys-lru</code>（在所有key中淘汰最近最少使用的）。还有<code>lfu</code>、<code>random</code>等策略。</td>
</tr>
<tr>
<td align="left"><strong><code>protected-mode yes</code></strong></td>
<td align="left"><code>yes</code></td>
<td align="left"><strong>[安全]</strong> 保护模式。当此项为<code>yes</code>且没有设置<code>bind</code>和<code>requirepass</code>时，Redis只接受本地回环连接（<code>127.0.0.1</code>）。这是防止Redis在未做任何安全配置的情况下暴露在公网上的一个安全机制。</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-Redis客户端redis-cli"><a href="#2-Redis客户端redis-cli" class="headerlink" title="2. Redis客户端redis-cli"></a>2. Redis客户端<code>redis-cli</code></h2><p><code>redis-cli</code>（Redis Command Line Interface）是Redis自带的、功能强大的官方命令行客户端。它是与Redis服务器进行交互、调试问题、执行管理任务最直接、最重要的工具。</p>
<h3 id="2-1-连接Redis服务器"><a href="#2-1-连接Redis服务器" class="headerlink" title="2.1 连接Redis服务器"></a>2.1 连接Redis服务器</h3><p><code>redis-cli</code>提供了灵活的参数来连接到不同的Redis实例。</p>
<ol>
<li><p><strong>连接本地默认实例</strong><br>如果Redis服务器运行在本地（<code>127.0.0.1</code>）且端口是默认的<code>6379</code>，直接输入命令即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>连接远程服务器或指定端口</strong><br>使用 <code>-h</code> (host) 和 <code>-p</code> (port) 参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接到 IP 为 192.168.1.100，端口为 6380 的Redis服务器</span></span><br><span class="line">redis-cli -h 192.168.1.100 -p 6380</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用密码连接</strong><br>如果Redis服务器设置了密码（<code>requirepass</code>），有两种方式连接：</p>
<ul>
<li><p><strong>方式一：使用 <code>-a</code> (authenticate) 参数</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.1.100 -p 6379 -a your_password</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方式二：连接后再使用 <code>AUTH</code> 命令</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.1.100 -p 6379</span><br><span class="line">192.168.1.100:6379&gt; AUTH your_password</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>选择数据库</strong><br>使用 <code>-n</code> 参数选择要操作的数据库（默认是<code>db 0</code>）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接并直接进入 5 号数据库</span></span><br><span class="line">redis-cli -n 5</span><br><span class="line">127.0.0.1:6379[5]&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>综合示例</strong>：连接到<code>192.168.1.100:6379</code>，使用密码<code>mysecret</code>，并操作<code>2</code>号数据库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.1.100 -p 6379 -a mysecret -n 2</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-常用命令实践"><a href="#2-2-常用命令实践" class="headerlink" title="2.2 常用命令实践"></a>2.2 常用命令实践</h3><p>以下是在<code>redis-cli</code>中进行日常开发和调试时最常用的一些基础命令。</p>
<ul>
<li><p><strong><code>PING</code></strong></p>
<ul>
<li><p><strong>用途</strong>：检查客户端与服务器的连接是否正常。如果服务器正常，会返回<code>PONG</code>。这是最基本的连通性测试命令。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PING</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>SET key value</code></strong></p>
<ul>
<li><p><strong>用途</strong>：设置一个键值对。如果key已经存在，它的值会被覆盖。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET user:1:name &quot;Alice&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>GET key</code></strong></p>
<ul>
<li><p><strong>用途</strong>：获取指定key的值。如果key不存在，返回 <code>(nil)</code>。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GET user:1:name</span><br><span class="line">&quot;Alice&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GET non<span class="built_in">_</span>existent<span class="built_in">_</span>key</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>KEYS pattern</code></strong></p>
<ul>
<li><p><strong>用途</strong>：查找所有符合给定模式 <code>pattern</code> 的 key。<code>*</code> 匹配任意多个字符，<code>?</code> 匹配单个字符。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; KEYS user:*</span><br><span class="line">1) &quot;user:1:name&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>⚠️ 严重警告：生产环境严禁使用！</strong><br><code>KEYS</code> 命令是一个<strong>阻塞式</strong>操作。它会遍历数据库中所有的key来进行模式匹配。如果你的Redis中有数百万甚至上千万的key，这个命令会导致Redis服务器<strong>卡顿数秒甚至更长时间</strong>，期间无法处理任何其他请求，造成严重的性能问题。在生产环境中，应使用<code>SCAN</code>命令进行安全的迭代查找。</p>
</li>
</ul>
</li>
<li><p><strong><code>FLUSHDB</code></strong></p>
<ul>
<li><p><strong>用途</strong>：清空<strong>当前</strong>数据库中的所有key。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; GET user:1:name</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>FLUSHALL</code></strong></p>
<ul>
<li><p><strong>用途</strong>：清空<strong>所有</strong>数据库（db0, db1, …, db15）中的所有key。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; FLUSHALL</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>⚠️ 操作警告</strong>：<code>FLUSHDB</code> 和 <code>FLUSHALL</code> 都是<strong>极其危险且不可逆</strong>的操作。请只在开发和测试环境中用于重置数据，<strong>绝对不要在生产环境随意执行</strong>。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-raw-参数的使用"><a href="#2-3-raw-参数的使用" class="headerlink" title="2.3 --raw 参数的使用"></a>2.3 <code>--raw</code> 参数的使用</h3><ul>
<li><p><strong>问题背景</strong>：当你在Redis中存储了包含中文或非ASCII字符的值时，直接使用 <code>redis-cli</code> 的 <code>GET</code> 命令，默认会以十六进制编码的形式显示结果，可读性很差。</p>
</li>
<li><p><strong>实践对比</strong>：</p>
<ol>
<li><p><strong>不使用 <code>--raw</code>（默认行为）</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; SET greeting <span class="string">&quot;你好，Redis！&quot;</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GET greeting</span><br><span class="line"><span class="string">&quot;\xe4\xbd\xa0\xe5\xa5\xbd\xef\xbc\x8cRedis\xef\xbc\x81&quot;</span> </span><br></pre></td></tr></table></figure>

<p>这个结果是UTF-8编码的十六进制表示，完全无法直接阅读。</p>
</li>
<li><p><strong>使用 <code>--raw</code> 参数</strong><br>启动<code>redis-cli</code>时加上<code>--raw</code>参数，它会告诉客户端以原始的、未经转义的格式输出结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli --raw</span><br><span class="line">127.0.0.1:6379&gt; GET greeting</span><br><span class="line">你好，Redis！</span><br></pre></td></tr></table></figure>

<p>可以看到，结果现在是人类可读的。</p>
</li>
</ol>
</li>
<li><p><strong>结论</strong>：当需要查看或处理包含非英文字符（如中文、日文、表情符号等）的数据时，记得使用<code>redis-cli --raw</code>来获得更好的体验。</p>
</li>
</ul>
<hr>
<h3 id="2-4-更多redis-cli实用技巧"><a href="#2-4-更多redis-cli实用技巧" class="headerlink" title="2.4 更多redis-cli实用技巧"></a>2.4 更多<code>redis-cli</code>实用技巧</h3><ul>
<li><p><strong><code>--scan</code> 和 <code>--pattern</code></strong>: <code>KEYS</code>命令的安全替代品。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从游标0开始，扫描匹配 user:* 模式的key，每次最多返回100个</span></span><br><span class="line">redis-cli --scan --pattern <span class="string">&quot;user:*&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>MONITOR</code></strong>: 实时监控Redis服务器正在执行的命令，是绝佳的调试工具。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli monitor</span><br><span class="line">OK</span><br><span class="line">1637842938.123456 [0 127.0.0.1:54321] <span class="string">&quot;SET&quot;</span> <span class="string">&quot;mykey&quot;</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">1637842940.654321 [0 127.0.0.1:54321] <span class="string">&quot;GET&quot;</span> <span class="string">&quot;mykey&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>--bigkeys</code></strong>: 采样分析键空间，找出占用内存大的”大Key”，有助于性能优化。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --bigkeys</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="三、核心数据结构详解"><a href="#三、核心数据结构详解" class="headerlink" title="三、核心数据结构详解"></a>三、核心数据结构详解</h1><h2 id="1-String-字符串"><a href="#1-String-字符串" class="headerlink" title="1. String (字符串)"></a>1. String (字符串)</h2><h3 id="1-1-是什么"><a href="#1-1-是什么" class="headerlink" title="1.1 是什么"></a>1.1 是什么</h3><p><code>String</code> 是 Redis 中最基本、最常见的数据类型。它是一个键（Key）对应一个值（Value）的结构。虽然名为“字符串”，但它的值不仅可以是普通的文本字符串，还可以是数字（整数或浮点数），甚至是二进制数据（如序列化后的对象、图片文件等）。</p>
<p>一个 <code>String</code>类型的 value 最大可以存储 <strong>512MB</strong> 的数据。</p>
<hr>
<h3 id="1-2-内部编码-底层实现：SDS（简单动态字符串）"><a href="#1-2-内部编码-底层实现：SDS（简单动态字符串）" class="headerlink" title="1.2 内部编码&#x2F;底层实现：SDS（简单动态字符串）"></a>1.2 内部编码&#x2F;底层实现：SDS（简单动态字符串）</h3><p>Redis并没有直接使用C语言原生的字符串（以<code>\0</code>结尾的字符数组），而是自己构建了一种名为**简单动态字符串（Simple Dynamic String, SDS）**的数据结构。这样做带来了巨大的优势：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">C语言字符串 (<code>char*</code>)</th>
<th align="left">Redis SDS</th>
<th align="left">优势说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>获取长度</strong></td>
<td align="left">遍历整个字符串，时间复杂度O(N)</td>
<td align="left">直接读取<code>len</code>属性，时间复杂度O(1)</td>
<td align="left"><strong>高效</strong>：频繁获取字符串长度时性能极高。</td>
</tr>
<tr>
<td align="left"><strong>缓冲区溢出</strong></td>
<td align="left">容易发生。拼接字符串时若未分配足够内存，会写坏相邻内存。</td>
<td align="left"><strong>杜绝</strong>。SDS在修改时会先检查空间是否足够，不足则自动扩容。</td>
<td align="left"><strong>安全</strong>：从根本上防止了缓冲区溢出风险。</td>
</tr>
<tr>
<td align="left"><strong>内存重分配</strong></td>
<td align="left">每次增长或缩短字符串，都需要重新分配内存。</td>
<td align="left">采用<strong>空间预分配</strong>和<strong>惰性空间释放</strong>策略。</td>
<td align="left"><strong>高效</strong>：<br> - <strong>预分配</strong>：扩容时，分配比实际需要更多的空间，减少后续修改时的重分配次数。<br> - <strong>惰性释放</strong>：缩短字符串时，多余的空间并不立即回收，而是记录在<code>free</code>属性中，以备将来使用。</td>
</tr>
<tr>
<td align="left"><strong>二进制安全</strong></td>
<td align="left">不是。因为以<code>\0</code>作为结尾符，字符串中间不能包含<code>\0</code>。</td>
<td align="left"><strong>是</strong>。SDS通过<code>len</code>属性判断字符串长度，而非<code>\0</code>。</td>
<td align="left"><strong>灵活</strong>：可以存储任意二进制数据，如图片、音频、序列化对象（Protobuf, JSON）等。</td>
</tr>
</tbody></table>
<p><strong>简单来说，SDS为Redis的String类型提供了高效、安全、灵活的底层支持。</strong></p>
<hr>
<h3 id="1-3-常用命令"><a href="#1-3-常用命令" class="headerlink" title="1.3 常用命令"></a>1.3 常用命令</h3><ul>
<li><p><strong><code>SET key value [EX seconds | PX milliseconds]</code></strong>: 设置一个键值对。可以附加<code>EX</code>（秒）或<code>PX</code>（毫秒）参数来指定过期时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET username &quot;Alice&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>GET key</code></strong>: 获取指定key的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GET username</span><br><span class="line">&quot;Alice&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>INCR key</code> &#x2F; <code>DECR key</code></strong>: 将key中储存的数字值增一或减一。如果key不存在，则先初始化为0再执行操作。<strong>此操作是原子性的</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET page_views 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; INCR page_views</span><br><span class="line">(integer) 101</span><br></pre></td></tr></table></figure>

<ul>
<li>相关的还有 <code>INCRBY key increment</code> 和 <code>DECRBY key decrement</code>，用于增加或减少指定的整数值。</li>
</ul>
</li>
<li><p><strong><code>MSET key value [key value ...]</code></strong>: 同时设置一个或多个键值对。</p>
</li>
<li><p><strong><code>MGET key [key ...]</code></strong>: 获取所有（一个或多个）给定key的值。</p>
<ul>
<li><code>MSET</code>&#x2F;<code>MGET</code>是原子操作吗？<code>MSET</code>是原子性的，<code>MGET</code>不是。但它们都能<strong>极大地减少网络往返时间(RTT)</strong>，在需要批量操作时性能远高于多次<code>SET</code>&#x2F;<code>GET</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MSET user:1:name &quot;Tom&quot; user:2:name &quot;Jerry&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MGET user:1:name user:2:name</span><br><span class="line">1) &quot;Tom&quot;</span><br><span class="line">2) &quot;Jerry&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>SETEX key seconds value</code></strong>: <code>SET</code> + <code>EXPIRE</code>的原子组合，设置key的值并指定其过期时间（单位：秒）。非常适合用于缓存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETEX verification_code:138xxxx1234 60 &quot;9527&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; TTL verification_code:138xxxx1234  # TTL命令查看剩余生存时间</span><br><span class="line">(integer) 58 </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>SETNX key value</code></strong>: <code>SET if Not eXists</code>的缩写。只有在key不存在时，才设置key的值。<strong>是实现分布式锁的基础</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETNX lock:product:1001 &quot;processing&quot;</span><br><span class="line">(integer) 1  # 第一次设置，成功</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SETNX lock:product:1001 &quot;processing&quot;</span><br><span class="line">(integer) 0  # 第二次设置，因为key已存在，所以失败</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 应用场景</h3><ol>
<li><strong>缓存（Cache）</strong><ul>
<li><strong>描述</strong>：这是Redis最广泛的用途。将数据库中读取的热点数据（如用户信息、商品详情）序列化成JSON字符串后，存入Redis。下次请求时先查Redis，若命中则直接返回，无需查询数据库。</li>
<li><strong>实现</strong>：使用 <code>SETEX</code> 或 <code>SET</code> + <code>EXPIRE</code> 来缓存数据并设置合理的过期时间。</li>
<li><strong>示例</strong>：<code>SETEX product:1001 3600 &#39;{&quot;id&quot;:1001, &quot;name&quot;:&quot;iPhone 15&quot;, &quot;price&quot;:5999}&#39;</code></li>
</ul>
</li>
<li><strong>计数器（Counter）</strong><ul>
<li><strong>描述</strong>：利用<code>INCR</code>的原子性，可以非常高效地实现各种计数需求，如网站PV&#x2F;UV、用户点赞数、分享数等，避免了关系型数据库在高并发下因行锁导致的性能问题。</li>
<li><strong>实现</strong>：对代表计数器的key执行 <code>INCR</code> 或 <code>INCRBY</code> 命令。</li>
<li><strong>示例</strong>：用户访问文章详情页时，执行 <code>INCR article:view_count:post123</code>。</li>
</ul>
</li>
<li><strong>分布式ID生成（Distributed ID Generation）</strong><ul>
<li><strong>描述</strong>：在分布式系统中，需要一个全局唯一的ID生成服务。可以利用Redis的<code>INCR</code>原子自增特性来生成趋势递增的全局ID。</li>
<li><strong>实现</strong>：设置一个全局的ID生成器key，每次需要ID时调用<code>INCR</code>获取。为了提高性能，可以结合<code>INCRBY</code>一次性获取一个ID段（如1000个），在应用内存中使用，用完后再去Redis获取下一段。</li>
<li><strong>示例</strong>：<code>INCR global_order_id</code> 返回一个新的、唯一的订单ID。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-List-列表"><a href="#2-List-列表" class="headerlink" title="2. List (列表)"></a>2. List (列表)</h2><h3 id="2-1-是什么"><a href="#2-1-是什么" class="headerlink" title="2.1 是什么"></a>2.1 是什么</h3><p>Redis的 <code>List</code> 类型是一个<strong>有序的字符串集合</strong>，其元素可以重复。它在概念上类似于Java中的 <code>LinkedList</code>。因为其元素是有序的，所以你可以从列表的头部（左边）或尾部（右边）添加或弹出元素。</p>
<p><code>List</code> 的主要特性是：</p>
<ul>
<li><strong>有序</strong>：元素按插入顺序排序。</li>
<li><strong>可重复</strong>：一个列表中可以包含多个相同的元素。</li>
<li><strong>两端操作</strong>：支持对列表两端进行高效的 <code>PUSH</code> 和 <code>POP</code> 操作。</li>
</ul>
<p>一个 <code>List</code> 最多可以包含 2³² - 1 个元素（超过40亿个）。</p>
<hr>
<h3 id="2-2-内部编码-底层实现：ziplist-或-quicklist"><a href="#2-2-内部编码-底层实现：ziplist-或-quicklist" class="headerlink" title="2.2 内部编码&#x2F;底层实现：ziplist 或 quicklist"></a>2.2 内部编码&#x2F;底层实现：<code>ziplist</code> 或 <code>quicklist</code></h3><p>Redis为了在性能和内存使用之间取得平衡，对 <code>List</code> 的底层实现进行了优化。在Redis 3.2版本之前，它会在 <code>ziplist</code> 和 <code>linkedlist</code> 之间转换。</p>
<ul>
<li><strong><code>ziplist</code> (压缩列表)</strong>：<ul>
<li><strong>本质</strong>：一块连续的内存空间。它不是真正的链表，而是将所有元素和元数据（如前一个元素的长度、当前元素的长度）紧凑地存储在一起。</li>
<li><strong>优点</strong>：非常节省内存，尤其是在列表元素较少或每个元素都很小的情况下。</li>
<li><strong>缺点</strong>：由于是连续内存，每次修改（插入或删除）都可能引发连锁更新（Cascading Update），即后续元素需要整体移动。当列表很大时，修改操作的性能会下降。</li>
</ul>
</li>
<li><strong><code>linkedlist</code> (双向链表)</strong>：<ul>
<li><strong>本质</strong>：标准的双向链表结构，每个节点包含元素值以及指向前一个和后一个节点的指针。</li>
<li><strong>优点</strong>：在列表两端增删元素的时间复杂度是 O(1)，非常高效，不受列表长度影响。</li>
<li><strong>缺点</strong>：每个节点都需要额外的指针空间（<code>prev</code>, <code>next</code>），内存开销比 <code>ziplist</code> 大。</li>
</ul>
</li>
</ul>
<p>**Redis 3.2及以后版本：<code>quicklist</code> **</p>
<p>为了进一步优化，Redis 3.2 引入了 <code>quicklist</code> 作为 <code>List</code> 的唯一底层实现。</p>
<ul>
<li><strong><code>quicklist</code> 是 <code>ziplist</code> 和 <code>linkedlist</code> 的混合体</strong>，它是一个由 <code>ziplist</code> 构成的双向链表。</li>
<li><strong>结构</strong>：一个 <code>quicklist</code> 就是一个链表，但它的每个节点（<code>quicklistNode</code>）不再是单个元素，而是一个 <code>ziplist</code>，这个 <code>ziplist</code> 里包含了多个元素。</li>
<li><strong>优势</strong>：<ul>
<li><strong>空间效率</strong>：结合了 <code>ziplist</code> 的空间紧凑性。</li>
<li><strong>操作效率</strong>：保留了 <code>linkedlist</code> 在两端快速插入&#x2F;删除的优点。</li>
<li><strong>避免了 <code>ziplist</code> 的主要缺点</strong>：修改只影响节点内的 <code>ziplist</code>，不会导致大规模的数据移动。</li>
</ul>
</li>
</ul>
<p>你可以通过配置项 <code>list-max-ziplist-size</code> 和 <code>list-compress-depth</code> 来控制 <code>quicklist</code> 中每个 <code>ziplist</code> 的大小和压缩深度。</p>
<hr>
<h3 id="2-3-常用命令"><a href="#2-3-常用命令" class="headerlink" title="2.3 常用命令"></a>2.3 常用命令</h3><ul>
<li><p><strong><code>LPUSH key element [element ...]</code> &#x2F; <code>RPUSH key element [element ...]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：从列表的左边（头部）或右边（尾部）插入一个或多个元素。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LPUSH tasks &quot;task3&quot; &quot;task2&quot; &quot;task1&quot;  # 注意插入顺序</span><br><span class="line">(integer) 3</span><br><span class="line"># 此时列表为: [&quot;task1&quot;, &quot;task2&quot;, &quot;task3&quot;]</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; RPUSH tasks &quot;task4&quot;</span><br><span class="line">(integer) 4</span><br><span class="line"># 此时列表为: [&quot;task1&quot;, &quot;task2&quot;, &quot;task3&quot;, &quot;task4&quot;]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>LPOP key</code> &#x2F; <code>RPOP key</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：从列表的左边（头部）或右边（尾部）移除并返回一个元素。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LPOP tasks</span><br><span class="line">&quot;task1&quot;</span><br><span class="line"># 此时列表为: [&quot;task2&quot;, &quot;task3&quot;, &quot;task4&quot;]</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; RPOP tasks</span><br><span class="line">&quot;task4&quot;</span><br><span class="line"># 此时列表为: [&quot;task2&quot;, &quot;task3&quot;]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>LRANGE key start stop</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：获取列表中指定范围内的元素。这是一个<strong>只读</strong>操作。索引从0开始，<code>-1</code>表示最后一个元素。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LRANGE tasks 0 -1  # 获取所有元素</span><br><span class="line">1) &quot;task2&quot;</span><br><span class="line">2) &quot;task3&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LRANGE tasks 0 0  # 获取第一个元素</span><br><span class="line">1) &quot;task2&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>BLPOP key [key ...] timeout</code> &#x2F; <code>BRPOP key [key ...] timeout</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：<code>LPOP</code>&#x2F;<code>RPOP</code>的<strong>阻塞版本</strong>。如果列表中没有元素，客户端会阻塞等待，直到有新元素被推入或超时。<code>timeout</code>为0表示无限期等待。</p>
</li>
<li><p><strong>这是实现消息队列的关键命令</strong>，它避免了客户端在循环中不断轮询，极大地降低了CPU和网络开销。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 在一个客户端执行，此时&#x27;new_tasks&#x27;为空</span><br><span class="line">127.0.0.1:6379&gt; BLPOP new_tasks 0</span><br><span class="line"># (客户端会在此处阻塞，等待...)</span><br><span class="line"></span><br><span class="line"># 在另一个客户端执行</span><br><span class="line">127.0.0.1:6379&gt; LPUSH new_tasks &quot;urgent_task&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"># 第一个客户端会立即解除阻塞，并返回结果</span><br><span class="line">1) &quot;new_tasks&quot;</span><br><span class="line">2) &quot;urgent_task&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>LLEN key</code></strong>: 返回列表的长度。</p>
</li>
<li><p><strong><code>LTRIM key start stop</code></strong>: 对列表进行修剪，只保留指定范围内的元素。常用于实现“最新的N个项目”。</p>
</li>
</ul>
<hr>
<h4 id="2-4-应用场景"><a href="#2-4-应用场景" class="headerlink" title="2.4 应用场景"></a>2.4 应用场景</h4><ol>
<li><strong>消息队列&#x2F;任务队列（Message&#x2F;Task Queue）</strong><ul>
<li><strong>描述</strong>：这是List最经典的应用。利用<code>LPUSH</code>和<code>RPOP</code>（或相反）可以实现一个简单的先进先出（FIFO）队列，用于系统解耦和异步处理任务。</li>
<li><strong>实现</strong>：<ul>
<li><strong>生产者</strong>：使用 <code>LPUSH</code> 将任务（如订单ID、邮件发送请求）放入队列。</li>
<li><strong>消费者</strong>：使用 <code>BRPOP</code> 阻塞式地等待并获取任务进行处理。</li>
</ul>
</li>
<li><strong>优点</strong>：实现简单，性能高。</li>
<li><strong>缺点</strong>：这是一个<strong>简单的消息队列</strong>，不具备专业消息中间件（如Kafka, RabbitMQ）的ACK（消息确认）机制。如果消费者在处理任务时崩溃，该任务就永久丢失了。</li>
</ul>
</li>
<li><strong>文章列表&#x2F;动态订阅（Timeline Feed）</strong><ul>
<li><strong>描述</strong>：展示用户发布的最新文章、微博时间线、最新评论等。</li>
<li><strong>实现</strong>：<ul>
<li>当用户发布新内容时，使用 <code>LPUSH</code> 将其ID添加到对应的列表中。<code>LPUSH</code>确保了最新的内容总是在列表的最前面。</li>
<li>使用 <code>LRANGE</code> 进行分页查询。例如，<code>LRANGE user:123:feed 0 9</code> 获取第一页的10条动态。</li>
<li>为了防止列表无限增长，可以结合 <code>LTRIM</code> 命令，只保留最新的N条记录。例如，每次<code>LPUSH</code>后都执行 <code>LTRIM user:123:feed 0 999</code>，使列表最多只保留1000条动态。</li>
</ul>
</li>
</ul>
</li>
<li><strong>实现栈（Stack）</strong><ul>
<li><strong>描述</strong>：栈是后进先出（LIFO）的数据结构。</li>
<li><strong>实现</strong>：使用 <code>LPUSH</code> 进行入栈，<code>LPOP</code> 进行出栈，即可完美模拟一个栈。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-Hash-哈希-字典"><a href="#3-Hash-哈希-字典" class="headerlink" title="3. Hash (哈希&#x2F;字典)"></a>3. Hash (哈希&#x2F;字典)</h2><h3 id="3-1-是什么"><a href="#3-1-是什么" class="headerlink" title="3.1 是什么"></a>3.1 是什么</h3><p>Redis的 <code>Hash</code> 类型是一个<strong>键值对集合</strong>，它是一个 String 类型的 <strong>field</strong> 和 <strong>value</strong> 的映射表。你可以把它看作是<strong>一个存在于Redis Key内部的Map</strong>。</p>
<p>它非常适合用来存储对象。相比于将整个对象序列化成JSON字符串后存入一个普通的 <code>String</code> Key，使用 <code>Hash</code> 可以让你对对象中的<strong>单个字段进行独立的读写操作</strong>，而无需获取和重写整个对象。</p>
<p><strong>结构示意</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Key (e.g., &quot;user:1001&quot;)  </span><br><span class="line">  |</span><br><span class="line">  +-- field1 (&quot;name&quot;)  -&gt; value1 (&quot;Alice&quot;)</span><br><span class="line">  +-- field2 (&quot;age&quot;)   -&gt; value2 (&quot;25&quot;)</span><br><span class="line">  +-- field3 (&quot;city&quot;)  -&gt; value3 (&quot;New York&quot;)</span><br></pre></td></tr></table></figure>

<p>在Java中，这可以类比于 <code>Map&lt;String, Map&lt;String, String&gt;&gt;</code>。</p>
<hr>
<h3 id="3-2-内部编码-底层实现：ziplist-或-hashtable"><a href="#3-2-内部编码-底层实现：ziplist-或-hashtable" class="headerlink" title="3.2 内部编码&#x2F;底层实现：ziplist 或 hashtable"></a>3.2 内部编码&#x2F;底层实现：<code>ziplist</code> 或 <code>hashtable</code></h3><p>与 <code>List</code> 类似，Redis为了优化内存使用，<code>Hash</code> 类型也采用了两种内部编码，并会在满足特定条件时自动转换：</p>
<ul>
<li><strong><code>ziplist</code> (压缩列表)</strong>：<ul>
<li><strong>何时使用</strong>：当哈希对象中保存的键值对数量较少，并且每个键值对的键和值都比较短时。</li>
<li><strong>存储方式</strong>：<code>field1</code>, <code>value1</code>, <code>field2</code>, <code>value2</code>, … 依次存放在一个连续的内存块中。</li>
<li><strong>优点</strong>：极其节省内存。</li>
<li><strong>缺点</strong>：每次查找、新增或删除操作都需要遍历这个列表，时间复杂度为 O(N)。当元素增多时，性能会下降。</li>
</ul>
</li>
<li><strong><code>hashtable</code> (哈希表)</strong>：<ul>
<li><strong>何时使用</strong>：当 <code>ziplist</code> 不再满足条件时，Redis会自动将底层结构转换为标准的哈希表。</li>
<li><strong>存储方式</strong>：与Java中的 <code>HashMap</code> 类似，通过哈希函数计算<code>field</code>的哈希值，解决哈希冲突，实现快速查找。</li>
<li><strong>优点</strong>：读写操作的平均时间复杂度为 O(1)，性能非常高。</li>
<li><strong>缺点</strong>：相比 <code>ziplist</code>，会占用更多的内存。</li>
</ul>
</li>
</ul>
<p><strong>转换触发条件</strong>（两个条件任意一个被破坏即转换）：</p>
<ol>
<li>哈希中元素（field-value对）的个数超过了 <code>hash-max-ziplist-entries</code> 配置的值（默认为512）。</li>
<li>哈希中任意一个 <code>value</code> 的长度超过了 <code>hash-max-ziplist-value</code> 配置的值（默认为64字节）。</li>
</ol>
<blockquote>
<p><strong>实践提示</strong>：你可以使用 <code>OBJECT ENCODING &lt;key&gt;</code> 命令来查看一个 <code>Hash</code> Key 当前的内部编码。</p>
</blockquote>
<hr>
<h3 id="3-3-常用命令"><a href="#3-3-常用命令" class="headerlink" title="3.3 常用命令"></a>3.3 常用命令</h3><ul>
<li><p><strong><code>HSET key field value [field value ...]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：设置哈希中一个或多个字段的值。如果字段已存在，则覆盖其值。如果哈希本身不存在，会先创建。</p>
</li>
<li><p><strong>注意</strong>：在Redis 4.0及以上版本，<code>HSET</code>可以同时设置多个字段，这使得 <code>HMSET</code> 成为历史。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HSET user:1001 name &quot;Bob&quot; age 30</span><br><span class="line">(integer) 2 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>HGET key field</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：获取哈希中指定字段的值。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HGET user:1001 name</span><br><span class="line">&quot;Bob&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>HGETALL key</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：获取哈希中所有的字段和值。返回一个包含字段和值的列表。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HGETALL user:1001</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;Bob&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;30&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>⚠️ 性能警告</strong>：当哈希中字段非常多时（成千上万），<code>HGETALL</code> 是一个<strong>慢操作</strong>，可能会阻塞Redis。在生产环境中，应优先使用 <code>HSCAN</code> 进行迭代获取。</p>
</li>
</ul>
</li>
<li><p><strong><code>HINCRBY key field increment</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：为哈希中指定字段的整数值增加指定的增量。<strong>此操作是原子性的</strong>。非常适合用于统计。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HINCRBY user:1001 login_count 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY user:1001 login_count 1</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>HMGET key field [field ...]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：获取哈希中一个或多个给定字段的值。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HMGET user:1001 name age email</span><br><span class="line">1) &quot;Bob&quot;</span><br><span class="line">2) &quot;30&quot;</span><br><span class="line">3) (nil)  # email字段不存在</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>HMSET key field value [field value ...]</code></strong>: <strong>(已废弃)</strong></p>
<ul>
<li>在旧版本中用于一次性设置多个字段。现在应直接使用 <code>HSET</code>。</li>
</ul>
</li>
<li><p><strong><code>HEXISTS key field</code></strong>: 判断哈希中是否存在指定的字段。</p>
</li>
<li><p><strong><code>HDEL key field [field ...]</code></strong>: 删除哈希中一个或多个字段。</p>
</li>
<li><p><strong><code>HLEN key</code></strong>: 获取哈希中字段的数量。</p>
</li>
</ul>
<hr>
<h3 id="3-4-应用场景"><a href="#3-4-应用场景" class="headerlink" title="3.4 应用场景"></a>3.4 应用场景</h3><p><strong>核心场景：存储对象（如用户信息、商品信息、购物车）</strong></p>
<p>这是 <code>Hash</code> 最经典的用途。让我们对比一下使用 <code>String</code> (存储JSON) 和 <code>Hash</code> 存储用户信息的区别：</p>
<p><strong>场景</strong>：存储一个用户对象，包含ID, name, age, city。</p>
<ul>
<li><strong>方案一：使用 <code>String</code> + JSON</strong><ul>
<li><strong>存储</strong>: <code>SET user:1001 &#39;{&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:25,&quot;city&quot;:&quot;New York&quot;}&#39;</code></li>
<li><strong>问题</strong>: 如果只想修改用户的年龄，你需要：<ol>
<li><code>GET user:1001</code> -&gt; 获得整个JSON字符串。</li>
<li>在你的Java应用中，将JSON反序列化为<code>User</code>对象。</li>
<li>修改对象的<code>age</code>属性。</li>
<li>将修改后的对象序列化回JSON字符串。</li>
<li><code>SET user:1001 &#39;{&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:26,&quot;city&quot;:&quot;New York&quot;}&#39;</code> -&gt; 将整个字符串写回Redis。</li>
</ol>
</li>
<li><strong>缺点</strong>：操作繁琐，网络开销大，序列化&#x2F;反序列化有性能损耗。</li>
</ul>
</li>
<li><strong>方案二：使用 <code>Hash</code> (推荐)</strong><ul>
<li><strong>存储</strong>: <code>HSET user:1001 name &quot;Alice&quot; age 25 city &quot;New York&quot;</code></li>
<li><strong>优势</strong>: 如果只想修改用户的年龄，你只需要一步：<ol>
<li><code>HSET user:1001 age 26</code></li>
</ol>
</li>
<li><strong>优点</strong>：<ol>
<li><strong>直观且易于管理</strong>：数据在Redis中结构化存储，可读性好。</li>
<li><strong>操作高效</strong>：只操作需要的字段，减少了网络流量和应用端的计算。</li>
<li><strong>节省内存</strong>：对于小对象，<code>ziplist</code>编码比一个等效的JSON字符串更节省内存。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>其他应用场景</strong>:</p>
<ul>
<li><strong>购物车</strong>：可以用一个哈希来表示一个用户的购物车。Key为<code>cart:userId</code>，<code>field</code>为商品ID，<code>value</code>为商品数量。<ul>
<li>添加商品：<code>HINCRBY cart:1001 product:A102 1</code></li>
<li>减少商品：<code>HINCRBY cart:1001 product:A102 -1</code></li>
<li>获取购物车所有商品：<code>HGETALL cart:1001</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-Set-集合"><a href="#4-Set-集合" class="headerlink" title="4. Set (集合)"></a>4. Set (集合)</h2><h3 id="4-1-是什么"><a href="#4-1-是什么" class="headerlink" title="4.1 是什么"></a>4.1 是什么</h3><p>Redis的 <code>Set</code> 类型是一个<strong>无序的、不重复的</strong>字符串集合。当你需要存储一个列表数据，又不希望出现重复数据时，<code>Set</code> 是一个非常好的选择。在概念上，它类似于Java中的 <code>java.util.Set</code>。</p>
<p><code>Set</code> 的核心特性：</p>
<ul>
<li><strong>无序性</strong>：<code>Set</code> 中的元素是无序的，你不能像 <code>List</code> 那样通过索引来获取元素。</li>
<li><strong>唯一性</strong>：<code>Set</code> 中不允许有重复的成员。向一个 <code>Set</code> 添加已存在的成员，该成员不会被再次添加，命令会返回0。</li>
<li><strong>集合操作</strong>：<code>Set</code> 提供了强大的集合间操作能力，如交集、并集、差集，这些操作在服务端完成，效率极高。</li>
</ul>
<p>一个 <code>Set</code> 最多可以包含 2³² - 1 个成员。</p>
<hr>
<h3 id="4-2-内部编码-底层实现：intset-或-hashtable"><a href="#4-2-内部编码-底层实现：intset-或-hashtable" class="headerlink" title="4.2 内部编码&#x2F;底层实现：intset 或 hashtable"></a>4.2 内部编码&#x2F;底层实现：<code>intset</code> 或 <code>hashtable</code></h3><p><code>Set</code> 的底层实现同样是根据存储的数据类型和数量动态选择的，以优化内存使用：</p>
<ul>
<li><strong><code>intset</code> (整数集合)</strong>：<ul>
<li><strong>何时使用</strong>：当集合中<strong>所有元素都是整数</strong>，并且元素的数量没有超过 <code>set-max-intset-entries</code> 配置的值（默认为512）时，Redis会使用 <code>intset</code> 来存储。</li>
<li><strong>结构</strong>：<code>intset</code> 是一个特殊编码的、有序的整数数组，它在内存上是连续的，非常节省空间。</li>
<li><strong>优点</strong>：极致的内存效率。</li>
<li><strong>缺点</strong>：因为是有序的，插入时可能需要移动元素。</li>
</ul>
</li>
<li><strong><code>hashtable</code> (哈希表)</strong>：<ul>
<li><strong>何时使用</strong>：当 <code>Set</code> 的存储不满足 <code>intset</code> 的条件时（例如，添加了一个非整数的字符串元素，或者元素数量超过了阈值），Redis会自动将其转换为 <code>hashtable</code>。</li>
<li><strong>结构</strong>：与 <code>Hash</code> 类型的底层 <code>hashtable</code> 类似，<code>Set</code> 的成员作为哈希表的键（key），而哈希表的值（value）则统一为一个虚拟的 <code>null</code> 值。</li>
<li><strong>优点</strong>：添加、删除、查找成员的平均时间复杂度都是 O(1)。</li>
<li><strong>缺点</strong>：比 <code>intset</code> 占用更多的内存。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>自动转换</strong>：这个转换过程对用户是透明的。比如一个<code>intset</code>，当你向其中<code>SADD</code>一个字符串”hello”时，它会自动升级为<code>hashtable</code>。</p>
</blockquote>
<hr>
<h3 id="4-3-常用命令"><a href="#4-3-常用命令" class="headerlink" title="4.3 常用命令"></a>4.3 常用命令</h3><ul>
<li><p><strong><code>SADD key member [member ...]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：向集合中添加一个或多个成员。返回成功添加的新成员数量。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SADD tags:post:1 &quot;redis&quot; &quot;database&quot; &quot;nosql&quot;</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SADD tags:post:1 &quot;redis&quot; &quot;cache&quot;</span><br><span class="line">(integer) 1  # &quot;redis&quot;已存在，只有&quot;cache&quot;被成功添加</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>SMEMBERS key</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：返回集合中的所有成员。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SMEMBERS tags:post:1</span><br><span class="line">1) &quot;nosql&quot;</span><br><span class="line">2) &quot;database&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">4) &quot;cache&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>⚠️ 性能警告</strong>：与 <code>HGETALL</code> 和 <code>KEYS</code> 类似，当集合非常大时，<code>SMEMBERS</code> 是一个慢命令，会阻塞Redis。在生产环境中，应使用 <code>SSCAN</code> 进行迭代获取。</p>
</li>
</ul>
</li>
<li><p><strong><code>SISMEMBER key member</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：判断一个成员是否是集合的成员。是则返回1，否则返回0。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SISMEMBER tags:post:1 &quot;redis&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER tags:post:1 &quot;java&quot;</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>SINTER / SUNION / SDIFF</code> (交集&#x2F;并集&#x2F;差集)</strong>:</p>
<ul>
<li><p><strong>这是Set的“杀手级”功能</strong>，非常适合进行关系运算。</p>
</li>
<li><p><strong><code>SINTER key [key ...]</code></strong>: 返回所有给定集合的<strong>交集</strong>。</p>
</li>
<li><p><strong><code>SUNION key [key ...]</code></strong>: 返回所有给定集合的<strong>并集</strong>。</p>
</li>
<li><p><strong><code>SDIFF key [key ...]</code></strong>: 返回第一个集合与其他集合的<strong>差集</strong>。</p>
</li>
<li><p><strong>实践</strong>（假设有两个用户喜欢的音乐集合）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SADD music:user:A &quot;JayChou&quot; &quot;TaylorSwift&quot; &quot;JJLin&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; SADD music:user:B &quot;JayChou&quot; &quot;EasonChan&quot; &quot;JJLin&quot;</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"># 交集：两人共同喜欢的歌手</span><br><span class="line">127.0.0.1:6379&gt; SINTER music:user:A music:user:B</span><br><span class="line">1) &quot;JayChou&quot;</span><br><span class="line">2) &quot;JJLin&quot;</span><br><span class="line"></span><br><span class="line"># 并集：两人喜欢的所有不重复的歌手</span><br><span class="line">127.0.0.1:6379&gt; SUNION music:user:A music:user:B</span><br><span class="line">1) &quot;TaylorSwift&quot;</span><br><span class="line">2) &quot;EasonChan&quot;</span><br><span class="line">3) &quot;JayChou&quot;</span><br><span class="line">4) &quot;JJLin&quot;</span><br><span class="line"></span><br><span class="line"># 差集：A喜欢但B不喜欢的歌手</span><br><span class="line">127.0.0.1:6379&gt; SDIFF music:user:A music:user:B</span><br><span class="line">1) &quot;TaylorSwift&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有 <code>SINTERSTORE</code>, <code>SUNIONSTORE</code>, <code>SDIFFSTORE</code> 命令，可以将计算结果保存到一个新的Set中，方便后续使用。</p>
</li>
</ul>
</li>
<li><p><strong><code>SPOP key [count]</code></strong>: 随机移除并返回集合中一个或多个成员。</p>
</li>
<li><p><strong><code>SRANDMEMBER key [count]</code></strong>: 随机返回集合中一个或多个成员，但<strong>不移除</strong>它们。</p>
</li>
<li><p><strong><code>SCARD key</code></strong>: 返回集合的基数（成员数量）。</p>
</li>
</ul>
<hr>
<h3 id="4-4-应用场景"><a href="#4-4-应用场景" class="headerlink" title="4.4 应用场景"></a>4.4 应用场景</h3><ol>
<li><strong>标签系统（Tagging）</strong><ul>
<li><strong>描述</strong>：为文章、用户、商品等对象打上标签。</li>
<li><strong>实现</strong>：为每个对象创建一个Set，Key为 <code>tags:&lt;object_type&gt;:&lt;object_id&gt;</code>，成员为标签名。<ul>
<li><code>SADD tags:post:123 &quot;redis&quot; &quot;nosql&quot; &quot;database&quot;</code>：给第123号文章打上三个标签。</li>
</ul>
</li>
<li><strong>扩展</strong>：可以很容易地找出具有共同标签的对象。例如，要找同时有 “redis” 和 “database” 标签的文章，可以通过对标签的倒排索引进行交集运算。</li>
</ul>
</li>
<li><strong>共同好友&#x2F;关注（Common Friends&#x2F;Followers）</strong><ul>
<li><strong>描述</strong>：在社交网络中，计算两个用户之间的共同好友或共同关注。</li>
<li><strong>实现</strong>：为每个用户创建一个Set，存储其好友或关注的ID列表。<ul>
<li><code>SADD friends:userA userB userC userD</code></li>
<li><code>SADD friends:userB userA userC userE</code></li>
<li>要计算<code>userA</code>和<code>userB</code>的共同好友，只需执行：<code>SINTER friends:userA friends:userB</code>。这个操作在Redis中执行得极快，远胜于在关系型数据库中进行复杂的<code>JOIN</code>查询。</li>
</ul>
</li>
</ul>
</li>
<li><strong>抽奖系统&#x2F;随机事件（Lottery）</strong><ul>
<li><strong>描述</strong>：从一个参与者池中随机抽取一个或多个中奖者，并确保每个参与者只能参与一次。</li>
<li><strong>实现</strong>：<ol>
<li><strong>参与</strong>：使用 <code>SADD lottery_participants &lt;user_id&gt;</code> 将参与用户ID加入集合。<code>SADD</code>的唯一性保证了用户不会重复参与。</li>
<li><strong>开奖</strong>：<ul>
<li><strong>不放回抽奖</strong>（抽一个少一个）：使用 <code>SPOP lottery_participants 5</code> 随机弹出5个中奖者。</li>
<li><strong>可重复中奖或仅查看</strong>：使用 <code>SRANDMEMBER lottery_participants 5</code> 随机选出5个“幸运儿”，但他们仍在奖池中。</li>
</ul>
</li>
</ol>
</li>
<li><strong>统计参与人数</strong>：使用 <code>SCARD lottery_participants</code> 快速获取总参与人数。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="5-Sorted-Set-ZSet-有序集合"><a href="#5-Sorted-Set-ZSet-有序集合" class="headerlink" title="5. Sorted Set (ZSet, 有序集合)"></a>5. Sorted Set (ZSet, 有序集合)</h2><h3 id="5-1-是什么"><a href="#5-1-是什么" class="headerlink" title="5.1 是什么"></a>5.1 是什么</h3><p><code>Sorted Set</code>（有序集合），简称 <code>ZSet</code>，是 <code>Set</code> 的一个升级版。它同样是一个<strong>不允许重复成员</strong>的字符串集合，但与 <code>Set</code> 不同的是，<code>ZSet</code> 的每个成员都会关联一个<strong>双精度浮点数类型的分数（score）</strong>。Redis正是通过这个分数来为集合中的成员进行<strong>从小到大</strong>的排序。</p>
<p><code>ZSet</code> 的核心特性：</p>
<ul>
<li><strong>唯一性</strong>：和 <code>Set</code> 一样，成员（member）是唯一的。</li>
<li><strong>有序性</strong>：每个成员都有一个分数（score），<code>ZSet</code> 内部会根据分数自动排序。如果分数相同，则按成员的字典序排序。</li>
<li><strong>高效访问</strong>：<code>ZSet</code> 既能像 <code>Set</code> 一样快速判断成员是否存在，也能像 <code>List</code> 一样通过排名（rank）快速获取成员。</li>
</ul>
<p>可以把它看作是Java中的 <code>java.util.TreeMap</code> 或者 <code>SortedSet</code>，其中成员是key，分数是用于排序的值。</p>
<hr>
<h3 id="5-2-底层实现：ziplist-或-skiplist-hashtable"><a href="#5-2-底层实现：ziplist-或-skiplist-hashtable" class="headerlink" title="5.2 底层实现：ziplist 或 skiplist + hashtable"></a>5.2 底层实现：<code>ziplist</code> 或 <code>skiplist</code> + <code>hashtable</code></h3><p><code>ZSet</code>的底层实现是Redis数据结构设计的精髓体现，它也采用了两种编码方式，并会自动转换：</p>
<ul>
<li><strong><code>ziplist</code> (压缩列表)</strong>：<ul>
<li><strong>何时使用</strong>：当有序集合的成员数量较少，并且每个成员和分数都比较小时。</li>
<li><strong>结构</strong>：在 <code>ziplist</code> 内部，成员（member）和分数（score）成对存放，并按分数从小到大排序。</li>
<li><strong>优点</strong>：非常节省内存。</li>
<li><strong>缺点</strong>：查找和修改操作的时间复杂度是 O(N)，性能随元素增多而下降。</li>
</ul>
</li>
<li><strong><code>skiplist</code> (跳表) + <code>hashtable</code> (哈希表)</strong>：<ul>
<li><strong>何时使用</strong>：当不满足 <code>ziplist</code> 的条件时（成员数量超过 <code>zset-max-ziplist-entries</code> 或成员长度超过 <code>zset-max-ziplist-value</code>），<code>ZSet</code> 会转换成这种复杂但高效的结构。</li>
<li><strong>这是 <code>ZSet</code> 的标准实现，也是其高性能的关键</strong>。<ul>
<li><strong><code>skiplist</code> (跳表)</strong>：一种概率性数据结构，可以看作是多层链表。它通过层级结构，实现了平均 O(logN) 的查找、插入、删除复杂度，性能媲美平衡树，但实现更简单。在 <code>ZSet</code> 中，跳表负责<strong>按分数排序</strong>，支持高效的范围查询。</li>
<li><strong><code>hashtable</code> (哈希表)</strong>：哈希表存储了<strong>成员到分数的映射</strong>。它负责以 O(1) 的时间复杂度快速查找指定成员的分数（<code>ZSCORE</code> 命令）或判断成员是否存在。</li>
</ul>
</li>
<li><strong>协同工作</strong>：<code>skiplist</code> 和 <code>hashtable</code> 通过指针共享成员和分数，两者共同维护 <code>ZSet</code> 的数据。<code>skiplist</code>保证了有序性，<code>hashtable</code>保证了高效的单点查询。这种组合使得<code>ZSet</code>在各种操作上都表现出色。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-3-常用命令"><a href="#5-3-常用命令" class="headerlink" title="5.3 常用命令"></a>5.3 常用命令</h3><ul>
<li><p><strong><code>ZADD key score member [score member ...]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：向有序集合添加一个或多个成员，或者更新已存在成员的分数。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD game:rank 1500 &quot;Alice&quot; 2200 &quot;Bob&quot; 1800 &quot;Charlie&quot;</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"># 更新Alice的分数</span><br><span class="line">127.0.0.1:6379&gt; ZADD game:rank 1650 &quot;Alice&quot;</span><br><span class="line">(integer) 0  # 因为Alice是更新，不是新增，所以返回0</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>ZRANGE key start stop [WITHSCORES]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：按分数<strong>从小到大</strong>（升序）返回指定排名范围内的成员。<code>start</code>和<code>stop</code>是排名索引（从0开始）。</p>
</li>
<li><p><strong><code>WITHSCORES</code></strong> 选项可以同时返回成员和其分数。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 获取排名前3的玩家</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE game:rank 0 2 WITHSCORES</span><br><span class="line">1) &quot;Alice&quot;</span><br><span class="line">2) &quot;1650&quot;</span><br><span class="line">3) &quot;Charlie&quot;</span><br><span class="line">4) &quot;1800&quot;</span><br><span class="line">5) &quot;Bob&quot;</span><br><span class="line">6) &quot;2200&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>ZREVRANGE key start stop [WITHSCORES]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：与 <code>ZRANGE</code> 相反，按分数<strong>从大到小</strong>（降序）返回排名范围内的成员。<strong>这是实现排行榜的关键命令</strong>。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 获取积分榜TOP 3</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE game:rank 0 2 WITHSCORES</span><br><span class="line">1) &quot;Bob&quot;</span><br><span class="line">2) &quot;2200&quot;</span><br><span class="line">3) &quot;Charlie&quot;</span><br><span class="line">4) &quot;1800&quot;</span><br><span class="line">5) &quot;Alice&quot;</span><br><span class="line">6) &quot;1650&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>ZRANK key member</code> &#x2F; <code>ZREVRANK key member</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：返回成员在有序集合中的排名（<code>ZRANK</code>是升序排名，<code>ZREVRANK</code>是降序排名），排名从0开始。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 查询Alice在积分榜（降序）中的排名</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK game:rank &quot;Alice&quot;</span><br><span class="line">(integer) 2  # 排名第3，索引为2</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>ZSCORE key member</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：返回成员的分数。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZSCORE game:rank &quot;Bob&quot;</span><br><span class="line">&quot;2200&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>ZRANGEBYSCORE key min max [WITHSCORES]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：按分数范围返回成员。<code>min</code>和<code>max</code>是分数。可以使用 <code>(</code> 表示不包含边界值。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 获取分数在[1800, 2500]之间的所有玩家</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE game:rank 1800 2500 WITHSCORES</span><br><span class="line">1) &quot;Charlie&quot;</span><br><span class="line">2) &quot;1800&quot;</span><br><span class="line">3) &quot;Bob&quot;</span><br><span class="line">4) &quot;2200&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>ZINCRBY key increment member</code></strong>: 为成员的分数增加<code>increment</code>，原子操作。</p>
</li>
<li><p><strong><code>ZCARD key</code></strong>: 返回有序集合的成员数量。</p>
</li>
<li><p><strong><code>ZCOUNT key min max</code></strong>: 返回分数在<code>min</code>和<code>max</code>之间的成员数量。</p>
</li>
<li><p><strong><code>ZREM key member [member ...]</code></strong>: 移除一个或多个成员。</p>
</li>
</ul>
<hr>
<h3 id="5-4-应用场景"><a href="#5-4-应用场景" class="headerlink" title="5.4 应用场景"></a>5.4 应用场景</h3><ol>
<li><p><strong>排行榜（Leaderboard）</strong></p>
<ul>
<li><strong>描述</strong>：这是 <code>ZSet</code> 最经典、最完美的应用场景。例如游戏积分榜、商品销量榜、热搜榜等。</li>
<li><strong>实现</strong>：<ul>
<li>使用 <code>ZADD</code> 更新用户积分：<code>ZADD sales_board 202310 iphone15</code>。</li>
<li>使用 <code>ZREVRANGE</code> 获取TOP N榜单：<code>ZREVRANGE sales_board 0 9 WITHSCORES</code>。</li>
<li>使用 <code>ZREVRANK</code> 查询某个用户的排名。</li>
<li>使用 <code>ZINCRBY</code> 累加用户的积分&#x2F;销量，例如 <code>ZINCRBY user_scores 100 user_A</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>延迟队列（Delayed Queue）</strong></p>
<ul>
<li><p><strong>描述</strong>：需要将任务推迟到未来的某个特定时间点执行。例如，订单创建30分钟后自动取消未支付的订单。</p>
</li>
<li><p><strong>实现</strong>：</p>
<ul>
<li><p><strong>生产者</strong>：使用 <code>ZADD</code> 将任务加入队列。<strong><code>member</code></strong> 是任务的唯一标识（如订单ID），<strong><code>score</code></strong> 是任务的<strong>执行时间戳</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 当前时间戳是 1700000000，30分钟后是 1700001800</span><br><span class="line">ZADD delayed_tasks 1700001800 &quot;order:123&quot; </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>消费者</strong>：一个后台轮询进程，不断地执行以下操作：</p>
<ol>
<li>使用 <code>ZRANGEBYSCORE delayed_tasks 0 &lt;current_timestamp&gt; LIMIT 0 1</code> 查询分数小于等于当前时间戳的第一个任务（即已到期的任务）。</li>
<li>如果查询到任务，尝试使用 <code>ZREM</code> 命令从队列中删除它。<code>ZREM</code> 返回1表示抢占成功。</li>
<li>抢占成功的消费者开始执行任务。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>优点</strong>：利用 <code>ZSet</code> 的排序特性，可以非常高效地获取到期任务。</p>
</li>
</ul>
</li>
<li><p><strong>范围查找（Range Queries）</strong></p>
<ul>
<li><strong>描述</strong>：需要根据某个权重、分数或时间戳来查找一个范围内的项目。</li>
<li><strong>实现</strong>：利用 <code>ZRANGEBYSCORE</code> 或 <code>ZREVRANGEBYSCORE</code>。</li>
<li><strong>示例</strong>：<ul>
<li>查找工资在5000到10000之间的员工。</li>
<li>在一个论坛中，实现“按点赞数筛选帖子”。Key是<code>post_votes</code>，member是帖子ID，score是点赞数。用户想看点赞数超过100的帖子，就可以用<code>ZRANGEBYSCORE post_votes 100 +inf</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="6-其他高级数据结构"><a href="#6-其他高级数据结构" class="headerlink" title="6. 其他高级数据结构"></a>6. 其他高级数据结构</h2><h3 id="6-1-Bitmap-位图"><a href="#6-1-Bitmap-位图" class="headerlink" title="6.1 Bitmap (位图)"></a>6.1 Bitmap (位图)</h3><ul>
<li><p><strong>是什么</strong>：<br><code>Bitmap</code> 本身并不是一种独立的数据结构，它是在 <strong><code>String</code> 类型</strong>上实现的一系列位操作。你可以把一个 <code>String</code> 看作是一个无限大的 <code>bit</code> 数组，每个 <code>bit</code> 只有 <code>0</code> 和 <code>1</code> 两种状态。<code>Bitmap</code> 就是通过直接操作这些位来进行存储和计算。</p>
<p>它的最大优势是<strong>极度节省内存</strong>。例如，要记录1亿用户的签到状态，如果用<code>Set</code>或<code>Hash</code>，每个用户ID都需要占用存储空间。而使用<code>Bitmap</code>，只需要 <code>100,000,000 bit ≈ 12.5 MB</code> 的空间即可。</p>
</li>
<li><p><strong>核心命令</strong>：</p>
<ul>
<li><p><strong><code>SETBIT key offset value</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：将 <code>key</code> 对应的 <code>Bitmap</code> 在指定 <code>offset</code> (偏移量&#x2F;索引) 上的位设置为 <code>value</code> (0或1)。<code>offset</code> 可以非常大。</p>
</li>
<li><p><strong>实践</strong>（用户签到）：假设用户ID是整数。用户<code>1001</code>在2023年12月5日签到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Key可以是 &#x27;signin:2023-12-05&#x27;</span><br><span class="line"># offset 可以是用户ID</span><br><span class="line">127.0.0.1:6379&gt; SETBIT signin:2023-12-05 1001 1</span><br><span class="line">(integer) 0  # 返回该位原来的值</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>GETBIT key offset</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：获取指定 <code>offset</code> 上的位的值。</p>
</li>
<li><p><strong>实践</strong>：判断用户 <code>1001</code> 今天是否签到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GETBIT signin:2023-12-05 1001</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>BITCOUNT key [start end]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：统计 <code>Bitmap</code> 中值为 <code>1</code> 的位的数量。可以指定字节范围进行统计。</p>
</li>
<li><p><strong>实践</strong>：统计今天有多少人签到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BITCOUNT signin:2023-12-05</span><br><span class="line">(integer) 12345  # 假设有12345人签到</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>BITOP operation destkey key [key ...]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：对一个或多个 <code>Bitmap</code> 进行位运算（AND, OR, XOR, NOT），并将结果保存到 <code>destkey</code>。</p>
</li>
<li><p><strong>实践</strong>：计算最近3天都连续签到的用户。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BITOP AND consecutive_3days signin:2023-12-03 signin:2023-12-04 signin:2023-12-05</span><br><span class="line"># 之后用BITCOUNT统计consecutive_3days即可得到连续签到人数</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li><strong>用户签到&#x2F;打卡</strong>：用日期作为Key，用户ID作为offset。</li>
<li><strong>在线状态统计</strong>：用一个 <code>online_users</code> 的Key，用户ID作为offset。用户上线时<code>SETBIT 1</code>，下线时<code>SETBIT 0</code>。</li>
<li><strong>用户画像&#x2F;标签</strong>：例如，<code>user:has_car</code>，<code>user:is_male</code> 等二值状态的标签。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-2-HyperLogLog"><a href="#6-2-HyperLogLog" class="headerlink" title="6.2 HyperLogLog"></a>6.2 HyperLogLog</h3><ul>
<li><p><strong>是什么</strong>：<br><code>HyperLogLog</code> (HLL) 是一种<strong>概率性数据结构</strong>，它用于进行<strong>基数估算（Cardinality Estimation）</strong>。通俗地说，就是用极小的内存空间来估算一个集合中不重复元素的数量。</p>
<p>例如，要统计一个网站一天的独立访客数（UV），如果用<code>Set</code>，每个访客ID都要存储，当UV达到千万级时，内存消耗巨大。而HLL只需要固定的 <strong>12KB</strong> 内存，就可以估算出高达 2⁶⁴ 个元素的基数，且标准误差仅为 <strong>0.81%</strong>。</p>
</li>
<li><p><strong>核心命令</strong>：</p>
<ul>
<li><p><strong><code>PFADD key element [element ...]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：向 <code>HyperLogLog</code> 添加一个或多个元素。类似于 <code>SADD</code>，但它不精确存储元素本身。</p>
</li>
<li><p><strong>实践</strong>：记录访问页面的用户ID。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Key可以是 &#x27;uv:page:/home:2023-12-05&#x27;</span><br><span class="line">127.0.0.1:6379&gt; PFADD uv:page:/home:2023-12-05 &quot;user_A&quot; &quot;user_B&quot; &quot;user_A&quot;</span><br><span class="line">(integer) 1 # 返回1表示内部的估计值发生了变化</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>PFCOUNT key [key ...]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：返回一个或多个 <code>HyperLogLog</code> 的基数估算值。如果指定多个key，则返回它们的并集的基数估算值。</p>
</li>
<li><p><strong>实践</strong>：获取首页今天的UV。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PFCOUNT uv:page:/home:2023-12-05</span><br><span class="line">(integer) 2 # 估算出的不重复用户数为2</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>PFMERGE destkey sourcekey [sourcekey ...]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：将多个 <code>HyperLogLog</code> 合并成一个，用于计算并集的基数。</p>
</li>
<li><p><strong>实践</strong>：计算整个网站今天的总UV。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PFMERGE uv:website:2023-12-05 uv:page:/home:2023-12-05 uv:page:/product:2023-12-05</span><br><span class="line">PFCOUNT uv:website:2023-12-05</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li><strong>UV统计</strong>：网站、App的日活、月活等不重复用户数的统计。</li>
<li><strong>大数据去重</strong>：在海量数据处理中，快速估算不重复元素的数量。</li>
<li>任何<strong>不需要精确数字</strong>，但对内存消耗非常敏感的基数统计场景。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-3-Geospatial-地理空间"><a href="#6-3-Geospatial-地理空间" class="headerlink" title="6.3 Geospatial (地理空间)"></a>6.3 Geospatial (地理空间)</h3><ul>
<li><p><strong>是什么</strong>：<br>Redis <code>Geospatial</code> 是在 <strong><code>Sorted Set</code> (ZSet)</strong> 类型上实现的一套地理位置处理功能。它通过 <strong>Geohash</strong> 算法，将二维的经纬度坐标编码成一个一维的分数（score），然后存储在<code>ZSet</code>中。这使得在<code>ZSet</code>上进行范围查找（<code>ZRANGEBYSCORE</code>）就等同于在地理上进行邻近搜索。</p>
</li>
<li><p><strong>核心命令</strong>：</p>
<ul>
<li><p><strong><code>GEOADD key longitude latitude member [longitude latitude member ...]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：将一个或多个地理位置（经度、纬度、成员名）添加到指定的key中。</p>
</li>
<li><p><strong>实践</strong>：添加几个商家位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 注意：经度(longitude)在前，纬度(latitude)在后</span><br><span class="line">127.0.0.1:6379&gt; GEOADD merchants 116.404269 39.913164 &quot;tiananmen&quot; 116.417359 39.907409 &quot;wangfujing&quot;</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>GEODIST key member1 member2 [unit]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：计算两个成员之间的直线距离。<code>unit</code>可以是 <code>m</code> (米), <code>km</code> (千米), <code>mi</code> (英里), <code>ft</code> (英尺)。默认是米。</p>
</li>
<li><p><strong>实践</strong>：计算天安门到王府井的距离。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEODIST merchants &quot;tiananmen&quot; &quot;wangfujing&quot; km</span><br><span class="line">&quot;1.2725&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>GEORADIUS key longitude latitude radius unit [WITHDIST] [WITHCOORD] [COUNT count] [ASC|DESC]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：<strong>核心功能</strong>。以给定的经纬度为中心，找出指定半径内的所有成员。</p>
</li>
<li><p><strong>选项</strong>：</p>
<ul>
<li><code>WITHDIST</code>: 同时返回成员与中心点的距离。</li>
<li><code>WITHCOORD</code>: 同时返回成员的经纬度。</li>
<li><code>COUNT count</code>: 限定返回结果的数量。</li>
<li><code>ASC|DESC</code>: 按距离升序或降序排序。</li>
</ul>
</li>
<li><p><strong>实践</strong>：查找离天安门2公里内的商家，最多返回5个，并显示距离。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEORADIUS merchants 116.404269 39.913164 2 km WITHDIST COUNT 5 ASC</span><br><span class="line">1) 1) &quot;tiananmen&quot;</span><br><span class="line">   2) &quot;0.0000&quot;</span><br><span class="line">2) 1) &quot;wangfujing&quot;</span><br><span class="line">   2) &quot;1.2725&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>GEORADIUSBYMEMBER</code></strong>: 与<code>GEORADIUS</code>类似，但中心点不是经纬度，而是已存在的成员。</p>
</li>
<li><p><strong><code>GEOHASH</code></strong>: 返回一个或多个成员的Geohash字符串。</p>
</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li><strong>附近的人&#x2F;地点</strong>：社交应用中的“附近的人”，外卖App中的“附近的商家”。</li>
<li><strong>打车应用</strong>：计算乘客与附近车辆的距离，进行订单匹配。</li>
<li><strong>位置打卡</strong>：判断用户当前位置是否在某个指定区域内。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="四、Java实战集成-Java开发者核心"><a href="#四、Java实战集成-Java开发者核心" class="headerlink" title="四、Java实战集成 (Java开发者核心)"></a>四、Java实战集成 (Java开发者核心)</h1><h2 id="1-Redis客户端选型"><a href="#1-Redis客户端选型" class="headerlink" title="1. Redis客户端选型"></a>1. Redis客户端选型</h2><p>在Java生态中，与Redis交互的主流客户端有Jedis、Lettuce和Redisson。它们各有优劣，选择哪个取决于你的项目需求、技术栈以及对并发模型和功能丰富度的要求。</p>
<h3 id="1-1-Jedis"><a href="#1-1-Jedis" class="headerlink" title="1.1 Jedis"></a>1.1 Jedis</h3><ul>
<li><p><strong>简介</strong>：Jedis是早期非常流行的Redis Java客户端，API设计直观，与Redis原生命令高度相似，学习成本低。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li><p><strong>线程不安全</strong>：Jedis的实例不是线程安全的。在多线程环境中使用时，必须通过<strong>连接池</strong>（如<code>JedisPool</code>）来为每个线程分配一个独立的Jedis实例。使用完毕后，必须将实例归还给连接池，否则会造成连接泄漏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource()) &#123;</span><br><span class="line">    jedis.set(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>同步阻塞I&#x2F;O (BIO)</strong>：Jedis的通信模型是同步阻塞的。当一个线程发送命令后，它会一直阻塞等待Redis的响应。在高并发场景下，这会消耗大量线程资源，如果线程池耗尽，系统吞吐量会急剧下降。</p>
</li>
<li><p><strong>功能相对基础</strong>：主要提供Redis原生命令的封装，对于分布式锁、集合等高级功能的实现需要开发者自己手动封装，较为繁琐且容易出错。</p>
</li>
<li><p><strong>不支持异步</strong>：没有原生的异步API。</p>
</li>
</ul>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>API简洁，与Redis命令一一对应，上手快。</li>
<li>轻量，引入的依赖少。</li>
<li>在简单的、非高并发的场景下表现良好。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>同步阻塞模型在并发高时性能瓶颈明显。</li>
<li>连接池模式下，频繁地借用和归还连接有一定开销。</li>
<li>需要手动管理连接，容易出错。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li>项目并发量不高，或者对Redis的性能要求不是极致。</li>
<li>团队希望快速上手，熟悉Redis原生命令。</li>
<li>老项目维护，已经在使用Jedis。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-Lettuce"><a href="#1-2-Lettuce" class="headerlink" title="1.2 Lettuce"></a>1.2 Lettuce</h3><ul>
<li><strong>简介</strong>：Lettuce是一个可伸缩的、线程安全的、基于<strong>Netty</strong>的先进Redis客户端。<strong>Spring Boot 2.x 之后默认集成的就是Lettuce</strong>。</li>
<li><strong>特点</strong>：<ul>
<li><strong>线程安全</strong>：Lettuce的连接实例（<code>RedisConnection</code>）是线程安全的。多个线程可以<strong>共享同一个连接实例</strong>来并发地发送命令，而无需使用连接池。这大大减少了连接数和线程开销。</li>
<li><strong>异步非阻塞I&#x2F;O (NIO)</strong>：底层基于Netty实现，采用异步和事件驱动模型。发送命令后，可以立即返回一个<code>CompletableFuture</code>，不会阻塞当前线程。这使得Lettuce能用较少的线程处理极高的并发量，吞吐量远超Jedis。</li>
<li><strong>支持同步、异步和响应式(Reactive)编程</strong>：<ul>
<li><strong>同步API</strong>：Lettuce也提供了一套同步API，用法与Jedis类似，但其底层仍然是异步执行。</li>
<li><strong>异步API</strong>：返回<code>CompletableFuture</code>，可以方便地进行链式调用和组合。</li>
<li><strong>响应式API</strong>：与Project Reactor等响应式框架无缝集成，是构建响应式应用的绝佳选择。</li>
</ul>
</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>性能卓越，吞吐量高，资源占用少。</li>
<li>线程安全，简化了并发编程。</li>
<li>一套API支持多种编程模型，非常灵活。</li>
<li>Spring Boot官方推荐和默认集成，生态支持好。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>API比Jedis稍复杂，尤其是在使用异步和响应式时，有一定学习曲线。</li>
<li>基于Netty，引入的依赖相对较重。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li><strong>绝大多数新项目，尤其是高并发的互联网应用</strong>。</li>
<li>Spring Boot项目（天然集成）。</li>
<li>需要使用异步或响应式编程模型的项目。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-Redisson"><a href="#1-3-Redisson" class="headerlink" title="1.3 Redisson"></a>1.3 Redisson</h3><ul>
<li><strong>简介</strong>：Redisson不仅仅是一个Redis客户端，它更是一个基于Redis的<strong>分布式Java对象和服务框架</strong>。它的目标是让开发者像使用本地Java对象一样使用Redis。</li>
<li><strong>特点</strong>：<ul>
<li><strong>高级功能封装</strong>：Redisson最大的亮点是提供了大量开箱即用的<strong>分布式对象和服务</strong>。你无需关心底层实现细节，可以直接使用：<ul>
<li><strong>可重入锁 (RLock)</strong>、公平锁、读写锁、红锁等多种分布式锁实现。</li>
<li>分布式集合，如<code>RMap</code>, <code>RSet</code>, <code>RList</code>，它们的接口与<code>java.util.Map</code>, <code>java.util.Set</code>, <code>java.util.List</code>几乎完全一致。</li>
<li>分布式原子类，如<code>RAtomicLong</code>。</li>
<li>分布式信号量、倒计时门闩 (<code>RCountDownLatch</code>) 等。</li>
</ul>
</li>
<li><strong>线程安全与异步</strong>：与Lettuce一样，底层基于Netty，也是线程安全的，并提供同步和异步API。</li>
<li><strong>看门狗机制 (Watchdog)</strong>：它的分布式锁实现包含一个“看门狗”机制，能自动为即将过期的锁续期，有效防止了业务处理时间过长导致锁被自动释放的问题，大大提升了分布式锁的可靠性。</li>
<li><strong>与主流框架集成</strong>：提供了对Spring、JCache等规范的集成支持。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>功能极其丰富，大大降低了开发分布式应用的门槛。</li>
<li>分布式锁的实现非常完善和健壮，是业内公认的标杆。</li>
<li>API设计对Java开发者非常友好，面向对象。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>相对“重”，引入了较多依赖和封装，学习成本比前两者更高。</li>
<li>封装层次较深，对于简单的KV操作，性能可能略低于Lettuce和Jedis，但在复杂场景下，其带来的开发效率提升远超这点性能差异。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li>需要大量使用<strong>分布式锁</strong>、<strong>分布式集合</strong>等高级分布式功能的复杂系统。</li>
<li>希望以面向对象的方式操作Redis，简化开发。</li>
<li>对分布式工具的可靠性要求非常高。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-4-总结对比表"><a href="#1-4-总结对比表" class="headerlink" title="1.4 总结对比表"></a>1.4 总结对比表</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Jedis</th>
<th align="left">Lettuce</th>
<th align="left">Redisson</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>线程安全</strong></td>
<td align="left"><strong>不安全</strong> (需用连接池)</td>
<td align="left"><strong>安全</strong> (可共享连接)</td>
<td align="left"><strong>安全</strong> (可共享连接)</td>
</tr>
<tr>
<td align="left"><strong>I&#x2F;O模型</strong></td>
<td align="left">同步阻塞 (BIO)</td>
<td align="left">异步非阻塞 (NIO)</td>
<td align="left">异步非阻塞 (NIO)</td>
</tr>
<tr>
<td align="left"><strong>编程模型</strong></td>
<td align="left">同步</td>
<td align="left"><strong>同步、异步、响应式</strong></td>
<td align="left">同步、异步</td>
</tr>
<tr>
<td align="left"><strong>性能&#x2F;吞吐量</strong></td>
<td align="left">一般</td>
<td align="left"><strong>极高</strong></td>
<td align="left">很高</td>
</tr>
<tr>
<td align="left"><strong>功能丰富度</strong></td>
<td align="left">基础 (原生命令)</td>
<td align="left">中等 (原生命令+异步)</td>
<td align="left"><strong>极高</strong> (分布式对象&#x2F;服务)</td>
</tr>
<tr>
<td align="left"><strong>分布式锁</strong></td>
<td align="left">需手动实现，易出错</td>
<td align="left">需手动实现</td>
<td align="left"><strong>内置完善实现 (RLock)</strong></td>
</tr>
<tr>
<td align="left"><strong>学习成本</strong></td>
<td align="left"><strong>低</strong></td>
<td align="left">中</td>
<td align="left">高</td>
</tr>
<tr>
<td align="left"><strong>Spring Boot集成</strong></td>
<td align="left">需手动切换和配置</td>
<td align="left"><strong>2.x后默认集成</strong></td>
<td align="left">需单独引入starter</td>
</tr>
<tr>
<td align="left"><strong>核心优势</strong></td>
<td align="left">简单、轻量</td>
<td align="left"><strong>高性能、高吞吐</strong></td>
<td align="left"><strong>功能强大、易用的分布式工具</strong></td>
</tr>
</tbody></table>
<p><strong>如何选择？</strong></p>
<ul>
<li><strong>简单场景&#x2F;老项目</strong>：如果只是做简单的KV缓存，并发不高，<code>Jedis</code> 足够用。</li>
<li><strong>新项目&#x2F;高并发</strong>：<strong>首选 <code>Lettuce</code></strong>。它是Spring Boot的默认选择，性能优异，能满足绝大部分需求。</li>
<li><strong>复杂分布式场景</strong>：当你需要可靠的分布式锁、分布式集合等高级功能时，<strong>强烈推荐 <code>Redisson</code></strong>。它能让你把精力集中在业务逻辑上，而不是花费大量时间去造轮子和踩坑。</li>
</ul>
<p>在实际项目中，甚至可以<strong>组合使用</strong>：主体使用Spring Boot集成的<code>RedisTemplate</code>（底层是Lettuce）进行常规操作，当需要分布式锁时，单独引入<code>Redisson</code>来使用它的<code>RLock</code>。</p>
<hr>
<h2 id="2-Spring-Boot-集成-Redis"><a href="#2-Spring-Boot-集成-Redis" class="headerlink" title="2. Spring Boot 集成 Redis"></a>2. Spring Boot 集成 Redis</h2><p>Spring Boot通过<code>spring-boot-starter-data-redis</code>为Redis提供了强大的自动化配置和便捷的API，使得在Spring应用中使用Redis变得异常简单。</p>
<h3 id="2-1-引入-spring-boot-starter-data-redis"><a href="#2-1-引入-spring-boot-starter-data-redis" class="headerlink" title="2.1 引入 spring-boot-starter-data-redis"></a>2.1 引入 <code>spring-boot-starter-data-redis</code></h3><p>要在你的Spring Boot项目中使用Redis，首先需要在<code>pom.xml</code>（Maven项目）或<code>build.gradle</code>（Gradle项目）中添加相应的依赖。</p>
<p><strong>Maven (<code>pom.xml</code>):</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个<code>starter</code>会做几件重要的事情：</p>
<ol>
<li><strong>引入核心依赖</strong>：包括<code>spring-data-redis</code>和默认的Redis客户端<code>Lettuce</code>。</li>
<li><strong>自动化配置</strong>：自动配置<code>RedisConnectionFactory</code>、<code>RedisTemplate</code>等核心Bean。你只需要在配置文件中提供Redis的连接信息即可。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：<code>spring-boot-starter-data-redis</code>默认使用<code>Lettuce</code>作为客户端。如果你想换回<code>Jedis</code>，需要先在<code>pom.xml</code>中排除<code>lettuce-core</code>，再引入<code>jedis</code>依赖。但不推荐这样做，除非有特殊理由。</p>
</blockquote>
<hr>
<h3 id="2-2-application-yml-配置详解"><a href="#2-2-application-yml-配置详解" class="headerlink" title="2.2 application.yml 配置详解"></a>2.2 <code>application.yml</code> 配置详解</h3><p>在<code>application.yml</code>或<code>application.properties</code>中，你可以对Redis进行详细的配置。以下是一个包含常用配置项的<code>yml</code>示例及其详解：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment"># Redis服务器地址</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="comment"># Redis服务器端口</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment"># Redis服务器连接密码（默认为空）</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">your_password</span></span><br><span class="line">    <span class="comment"># 使用的数据库索引（默认为0）</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">3000ms</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 连接池配置 (基于Lettuce) ---</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="comment"># 连接池中的最大连接数（-1表示不限制）</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment"># 连接池中的最大空闲连接数</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment"># 连接池中的最小空闲连接数</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 当连接池耗尽时，获取连接的最大等待时间（-1表示无限等待）</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">-1ms</span></span><br></pre></td></tr></table></figure>

<p><strong>核心配置项解读</strong>：</p>
<ul>
<li><strong><code>host</code>, <code>port</code>, <code>password</code>, <code>database</code></strong>: 最基础的连接信息。</li>
<li><strong><code>timeout</code></strong>: 客户端连接Redis服务器以及读写操作的超时时间。如果网络状况不佳或Redis负载高，适当调高此值可以避免不必要的超时异常。</li>
<li><strong><code>lettuce.pool</code></strong>: <strong>非常重要</strong>的连接池配置。虽然Lettuce的连接是线程安全的，可以被多线程共享，但对于高并发的阻塞式调用（比如<code>RedisTemplate</code>的同步操作），使用连接池可以提供更好的性能和资源管理。<ul>
<li><code>max-active</code>: 池中允许存在的最大连接数。当所有连接都在使用时，新的请求需要等待。这是控制并发资源的关键。</li>
<li><code>max-idle</code>: 池中允许保持的最大空闲连接数。超过此数量的空闲连接会被释放。</li>
<li><code>min-idle</code>: 池中必须保持的最小空闲连接数。即使没有请求，池中也会保留这个数量的连接，以备不时之需。</li>
<li><code>max-wait</code>: 当池中没有可用连接时，请求线程的最大等待时间。超过此时间会抛出异常。设置为<code>-1</code>表示无限等待，<strong>生产环境要谨慎，可能导致线程堆积</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-RedisTemplate-与-StringRedisTemplate"><a href="#2-3-RedisTemplate-与-StringRedisTemplate" class="headerlink" title="2.3 RedisTemplate 与 StringRedisTemplate"></a>2.3 <code>RedisTemplate</code> 与 <code>StringRedisTemplate</code></h3><p>Spring Data Redis提供了两个核心的模板类来与Redis交互：<code>RedisTemplate</code>和<code>StringRedisTemplate</code>。</p>
<ul>
<li><strong><code>RedisTemplate&lt;K, V&gt;</code></strong>:<ul>
<li><strong>定位</strong>：这是一个<strong>泛型</strong>的、功能最全的模板类，可以操作任何类型的Key和Value。</li>
<li><strong>序列化</strong>：它需要你为其指定<strong>序列化器 (Serializer)</strong>。默认情况下，它使用<strong>JDK的序列化器 (<code>JdkSerializationRedisSerializer</code>)</strong>。</li>
<li><strong>JDK序列化的问题</strong>：<ol>
<li><strong>可读性差</strong>：序列化后的内容是一串二进制，无法在<code>redis-cli</code>中直接阅读。</li>
<li><strong>体积大</strong>：序列化后的字节数组通常比JSON等格式要大。</li>
<li><strong>语言强相关</strong>：只能被Java应用反序列化，与其他语言的系统交互困难。</li>
</ol>
</li>
<li><strong>生产推荐</strong>：在生产环境中，我们通常会自定义<code>RedisTemplate</code>的序列化方式，例如使用<code>Jackson2JsonRedisSerializer</code>（存储为JSON）或<code>GenericJackson2JsonRedisSerializer</code>。</li>
</ul>
</li>
<li><strong><code>StringRedisTemplate</code></strong>:<ul>
<li><strong>定位</strong>：是<code>RedisTemplate&lt;String, String&gt;</code>的一个<strong>特化</strong>子类。它专门用于处理Key和Value都是<strong>字符串</strong>的场景。</li>
<li><strong>序列化</strong>：它已经预先配置好了使用<code>StringRedisSerializer</code>。这意味着它存入Redis的数据是<strong>纯字符串</strong>，具有<strong>极好的可读性</strong>，并且可以与任何语言的客户端无缝交互。</li>
<li><strong>何时使用</strong>：<ol>
<li>当你明确知道你的缓存数据（Key和Value）都是字符串时。</li>
<li>当你需要将一个对象缓存为JSON字符串时，可以手动将对象序列化为JSON，然后用<code>StringRedisTemplate</code>存取。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>总结与选择</strong>：</p>
<table>
<thead>
<tr>
<th align="left">模板类</th>
<th align="left">Key序列化器</th>
<th align="left">Value序列化器</th>
<th align="left">默认序列化</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">推荐场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>RedisTemplate</code></strong></td>
<td align="left">泛型 (K)</td>
<td align="left">泛型 (V)</td>
<td align="left">JDK序列化</td>
<td align="left">灵活，可操作任意对象</td>
<td align="left">默认配置不佳，需自定义</td>
<td align="left">存储复杂Java对象，且已配置好JSON等序列化器</td>
</tr>
<tr>
<td align="left"><strong><code>StringRedisTemplate</code></strong></td>
<td align="left"><code>StringRedisSerializer</code></td>
<td align="left"><code>StringRedisSerializer</code></td>
<td align="left">字符串</td>
<td align="left"><strong>可读性好，跨语言</strong></td>
<td align="left">只能处理字符串KV</td>
<td align="left"><strong>日常开发首选</strong>，特别是缓存JSON字符串</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>最佳实践</strong>：在项目中配置一个使用JSON序列化器的<code>RedisTemplate</code> Bean，同时直接使用Spring Boot自动配置好的<code>StringRedisTemplate</code>。根据场景选择合适的模板。</p>
</blockquote>
<hr>
<h4 id="2-4-常用-API-示例"><a href="#2-4-常用-API-示例" class="headerlink" title="2.4 常用 API 示例"></a>2.4 常用 API 示例</h4><p><code>RedisTemplate</code>和<code>StringRedisTemplate</code>的API设计非常优雅，它们将不同数据结构的操作分装到各自的<code>Operations</code>接口中。</p>
<p><strong>获取操作对象</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作String</span></span><br><span class="line">ValueOperations&lt;String, Object&gt; valueOps = redisTemplate.opsForValue();</span><br><span class="line">ValueOperations&lt;String, String&gt; stringValueOps = stringRedisTemplate.opsForValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作Hash</span></span><br><span class="line">HashOperations&lt;String, Object, Object&gt; hashOps = redisTemplate.opsForHash();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作List</span></span><br><span class="line">ListOperations&lt;String, Object&gt; listOps = redisTemplate.opsForList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作Set</span></span><br><span class="line">SetOperations&lt;String, Object&gt; setOps = redisTemplate.opsForSet();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作ZSet</span></span><br><span class="line">ZSetOperations&lt;String, Object&gt; zSetOps = redisTemplate.opsForZSet();</span><br></pre></td></tr></table></figure>

<p><strong>实战示例 (<code>StringRedisTemplate</code>)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDemoService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. String 操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 设置值并指定10分钟过期</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:name&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:name&quot;</span>); <span class="comment">// &quot;Alice&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除key</span></span><br><span class="line">        stringRedisTemplate.delete(<span class="string">&quot;user:name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Hash 操作 (常用于存储对象)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:1001&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:1001&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;30&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取单个字段</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> (String) stringRedisTemplate.opsForHash().get(<span class="string">&quot;user:1001&quot;</span>, <span class="string">&quot;age&quot;</span>); <span class="comment">// &quot;30&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有字段</span></span><br><span class="line">        Map&lt;Object, Object&gt; userFields = stringRedisTemplate.opsForHash().entries(<span class="string">&quot;user:1001&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. List 操作 (简单消息队列)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 生产者：从左边推入任务</span></span><br><span class="line">        stringRedisTemplate.opsForList().leftPush(<span class="string">&quot;task:queue&quot;</span>, <span class="string">&quot;task1&quot;</span>);</span><br><span class="line">        stringRedisTemplate.opsForList().leftPush(<span class="string">&quot;task:queue&quot;</span>, <span class="string">&quot;task2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者：从右边弹出任务</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">task</span> <span class="operator">=</span> stringRedisTemplate.opsForList().rightPop(<span class="string">&quot;task:queue&quot;</span>); <span class="comment">// &quot;task1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. Set 操作 (标签)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForSet().add(<span class="string">&quot;tags:post:123&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;spring&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断成员是否存在</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(<span class="string">&quot;tags:post:123&quot;</span>, <span class="string">&quot;java&quot;</span>); <span class="comment">// true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取所有成员</span></span><br><span class="line">        Set&lt;String&gt; tags = stringRedisTemplate.opsForSet().members(<span class="string">&quot;tags:post:123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. ZSet 操作 (排行榜)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZSet</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(<span class="string">&quot;game:rank&quot;</span>, <span class="string">&quot;PlayerA&quot;</span>, <span class="number">1500</span>);</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(<span class="string">&quot;game:rank&quot;</span>, <span class="string">&quot;PlayerB&quot;</span>, <span class="number">2200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取排行榜TOP N (降序)</span></span><br><span class="line">        Set&lt;String&gt; topPlayers = stringRedisTemplate.opsForZSet().reverseRange(<span class="string">&quot;game:rank&quot;</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-序列化机制"><a href="#3-序列化机制" class="headerlink" title="3. 序列化机制"></a>3. 序列化机制</h2><p>在Java应用中，当我们要将一个Java对象存入Redis时（通常是存入<code>String</code>或<code>Hash</code>的Value中），需要先将这个对象转换成二进制数据流，这个过程就是<strong>序列化(Serialization)</strong>。反之，从Redis中取出数据再转换回Java对象，就是<strong>反序列化(Deserialization)</strong>。</p>
<p>Spring Data Redis的<code>RedisTemplate</code>通过<code>RedisSerializer</code>接口来完成这个过程。选择合适的序列化器对应用性能和可维护性有巨大影响。</p>
<h3 id="3-1-默认JDK序列化的问题"><a href="#3-1-默认JDK序列化的问题" class="headerlink" title="3.1 默认JDK序列化的问题"></a>3.1 默认JDK序列化的问题</h3><p>Spring的<code>RedisTemplate&lt;Object, Object&gt;</code>默认使用的序列化器是<code>JdkSerializationRedisSerializer</code>。它虽然能处理任何实现了<code>java.io.Serializable</code>接口的Java对象，但在生产实践中，我们通常会避免使用它，主要有以下几个核心问题：</p>
<ol>
<li><p><strong>可读性极差</strong>：</p>
<ul>
<li><p>JDK序列化产生的是纯二进制数据。当你在<code>redis-cli</code>中<code>GET</code>一个key时，你会看到一串乱码（如 <code>\xac\xed\x00\x05t\x00\x04name...</code>），完全无法直接阅读和调试。</p>
</li>
<li><p><strong>示例</strong>：一个简单的<code>User</code>对象，序列化后在Redis中可能是这样的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GET user:1001</span><br><span class="line">&quot;\xac\xed\x00\x05sr\x00\x1ccom.example.demo.User\x02...\x00\x04name...t\x00\x05Alice&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>序列化后体积过大</strong>：</p>
<ul>
<li>JDK序列化结果中包含了大量的类型信息、类路径、版本号等元数据，这导致最终的字节数组体积相对较大，浪费Redis宝贵的内存资源和网络带宽。</li>
</ul>
</li>
<li><p><strong>语言强相关性，跨平台性差</strong>：</p>
<ul>
<li>JDK序列化是Java特有的机制。一个被JDK序列化的对象，只有Java应用能够正确地反序列化回来。如果你的系统需要与Python、Go、Node.js等其他语言的服务共享缓存数据，这将成为一个巨大的障碍。</li>
</ul>
</li>
<li><p><strong>性能问题</strong>：</p>
<ul>
<li>相比于专门为性能优化的序列化框架（如Kryo、Protobuf），JDK序列化的性能和效率都比较低。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-2-使用-Jackson-JSON-或-Protobuf-Kryo-进行序列化配置"><a href="#3-2-使用-Jackson-JSON-或-Protobuf-Kryo-进行序列化配置" class="headerlink" title="3.2 使用 Jackson (JSON) 或 Protobuf&#x2F;Kryo 进行序列化配置"></a>3.2 使用 Jackson (JSON) 或 Protobuf&#x2F;Kryo 进行序列化配置</h3><p>为了解决JDK序列化的问题，我们通常会选择更现代、更高效的序列化方案。</p>
<h4 id="3-2-1-使用-Jackson-JSON-——-兼顾可读性与性能"><a href="#3-2-1-使用-Jackson-JSON-——-兼顾可读性与性能" class="headerlink" title="3.2.1 使用 Jackson (JSON) —— 兼顾可读性与性能"></a>3.2.1 使用 Jackson (JSON) —— 兼顾可读性与性能</h4><p>将对象序列化为JSON字符串是最常用、最推荐的方案，因为它在可读性、性能和跨平台性之间取得了完美的平衡。Spring Boot生态中，<code>Jackson</code>是处理JSON的标配。</p>
<ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>可读性好</strong>：JSON是人类可读的文本格式，便于在<code>redis-cli</code>或可视化工具中直接查看和调试。</li>
<li><strong>跨语言</strong>：JSON是事实上的数据交换标准，任何语言都有成熟的库来处理它。</li>
<li><strong>生态成熟</strong>：与Spring无缝集成，注解丰富（<code>@JsonIgnore</code>, <code>@JsonFormat</code>等），易于定制。</li>
</ul>
</li>
<li><p><strong>如何配置</strong>：<br>你需要创建一个配置类，自定义一个<code>RedisTemplate&lt;String, Object&gt;</code>的Bean，并为其设置JSON序列化器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值</span></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jacksonSerializer = <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="comment">// 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span></span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">// 指定序列化输入的类型，类必须是非final修饰的，final修饰的类会抛出异常</span></span><br><span class="line">        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jacksonSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String 的序列化</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringSerializer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jacksonSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jacksonSerializer);</span><br><span class="line">        </span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键代码解读</strong>：<ul>
<li><code>Jackson2JsonRedisSerializer</code>: Spring Data Redis提供的基于Jackson的序列化器。</li>
<li><code>om.activateDefaultTyping(...)</code>: <strong>非常重要</strong>。这行代码会在JSON中加入<code>@class</code>属性，记录对象的完整类名（如<code>&quot;com.example.User&quot;</code>）。这样在反序列化时，即使你使用的是<code>Object.class</code>，Jackson也能知道应该将其转换成哪个具体的子类。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-2-使用-Protobuf-Kryo-——-追求极致性能"><a href="#3-2-2-使用-Protobuf-Kryo-——-追求极致性能" class="headerlink" title="3.2.2 使用 Protobuf &#x2F; Kryo —— 追求极致性能"></a>3.2.2 使用 Protobuf &#x2F; Kryo —— 追求极致性能</h4><p>当你的应用对性能和内存占用要求达到极致，并且可以牺牲一些可读性时，可以考虑使用性能更强的二进制序列化框架。</p>
<ul>
<li><strong>Protobuf (Protocol Buffers)</strong><ul>
<li><strong>简介</strong>：Google开发的语言无关、平台无关、可扩展的序列化数据结构的方法。</li>
<li><strong>优点</strong>：<ul>
<li><strong>性能极高</strong>：序列化和反序列化速度非常快。</li>
<li><strong>体积超小</strong>：采用二进制编码，序列化后体积远小于JSON。</li>
<li><strong>强类型与向前&#x2F;向后兼容</strong>：需要预先定义<code>.proto</code>文件来描述数据结构，提供了严格的类型检查和良好的版本兼容性。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>需要维护<code>.proto</code>文件，增加了开发步骤。</li>
<li>二进制格式，不可读。</li>
</ul>
</li>
<li><strong>适用场景</strong>：微服务之间的高性能RPC通信、对数据大小和编解码速度有苛刻要求的场景。</li>
</ul>
</li>
<li><strong>Kryo</strong><ul>
<li><strong>简介</strong>：一个快速、高效的Java对象序列化框架。</li>
<li><strong>优点</strong>：<ul>
<li><strong>性能顶级</strong>：通常被认为是Java生态中最快的序列化框架之一。</li>
<li><strong>体积小</strong>：序列化结果紧凑。</li>
<li><strong>API简单</strong>：无需像Protobuf那样预先定义IDL文件。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>语言相关</strong>：主要服务于Java，跨语言支持不如Protobuf。</li>
<li><strong>线程不安全</strong>：Kryo实例不是线程安全的，需要通过池化或<code>ThreadLocal</code>来管理。</li>
</ul>
</li>
<li><strong>适用场景</strong>：纯Java环境，需要极致序列化性能的应用。</li>
</ul>
</li>
</ul>
<p><strong>如何配置 (以Kryo为例)</strong>：</p>
<p>你需要自定义一个<code>KryoRedisSerializer</code>，并在<code>RedisConfig</code>中使用它。由于Kryo的配置相对复杂（需要处理线程安全和类注册），通常会封装一个工具类。</p>
<hr>
<h3 id="4-3-总结与选择策略"><a href="#4-3-总结与选择策略" class="headerlink" title="4.3 总结与选择策略"></a>4.3 总结与选择策略</h3><table>
<thead>
<tr>
<th align="left">序列化方案</th>
<th align="left">性能</th>
<th align="left">体积</th>
<th align="left">可读性</th>
<th align="left">跨语言</th>
<th align="left">额外工作</th>
<th align="left">推荐度</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>JDK (默认)</strong></td>
<td align="left">低</td>
<td align="left">大</td>
<td align="left">❌ 无</td>
<td align="left">❌ 仅Java</td>
<td align="left">无</td>
<td align="left">⭐ (不推荐)</td>
</tr>
<tr>
<td align="left"><strong>Jackson (JSON)</strong></td>
<td align="left">良好</td>
<td align="left">中</td>
<td align="left">✅ <strong>极好</strong></td>
<td align="left">✅ <strong>极好</strong></td>
<td align="left">简单配置</td>
<td align="left">⭐⭐⭐⭐⭐ (<strong>通用首选</strong>)</td>
</tr>
<tr>
<td align="left"><strong>Protobuf</strong></td>
<td align="left">✅ <strong>极高</strong></td>
<td align="left">✅ <strong>极小</strong></td>
<td align="left">❌ 无</td>
<td align="left">✅ <strong>极好</strong></td>
<td align="left">需维护.proto文件</td>
<td align="left">⭐⭐⭐⭐ (高性能跨语言场景)</td>
</tr>
<tr>
<td align="left"><strong>Kryo</strong></td>
<td align="left">✅ <strong>极高</strong></td>
<td align="left">✅ <strong>极小</strong></td>
<td align="left">❌ 无</td>
<td align="left">❌ 弱</td>
<td align="left">需处理线程安全</td>
<td align="left">⭐⭐⭐ (纯Java高性能场景)</td>
</tr>
</tbody></table>
<p><strong>最终建议</strong>：</p>
<p>对于绝大多数Java后端应用，<strong>使用Jackson将对象序列化为JSON是最佳实践</strong>。它在各方面都表现均衡，特别是其出色的可读性和跨平台能力，能为开发和维护带来巨大便利。只有在遇到明确的性能瓶颈时，再考虑迁移到Kryo或Protobuf。</p>
<hr>
<h1 id="五、Redis进阶功能"><a href="#五、Redis进阶功能" class="headerlink" title="五、Redis进阶功能"></a>五、Redis进阶功能</h1><h2 id="1-事务-Transaction"><a href="#1-事务-Transaction" class="headerlink" title="1. 事务 (Transaction)"></a>1. 事务 (Transaction)</h2><p>Redis的事务提供了一种将多个命令打包、一次性、按序执行的机制。在事务执行期间，服务器不会中断事务去执行其他客户端的命令，从而保证了这组命令执行的“原子性”（此原子性非ACID中的原子性，后文详述）。</p>
<h3 id="1-1-MULTI-EXEC-DISCARD-WATCH"><a href="#1-1-MULTI-EXEC-DISCARD-WATCH" class="headerlink" title="1.1 MULTI, EXEC, DISCARD, WATCH"></a>1.1 <code>MULTI</code>, <code>EXEC</code>, <code>DISCARD</code>, <code>WATCH</code></h3><p>这四个命令是Redis事务的核心。</p>
<ul>
<li><strong><code>MULTI</code></strong>:<ul>
<li><strong>作用</strong>：标记一个事务块的开始。</li>
<li><strong>行为</strong>：当客户端发送<code>MULTI</code>命令后，服务器返回<code>OK</code>，然后该客户端进入一个特殊模式。在此模式下，后续发送的所有命令都不会立即执行，而是被放入一个<strong>命令队列</strong>中。服务器对每个入队的命令回复<code>QUEUED</code>。</li>
</ul>
</li>
<li><strong><code>EXEC</code></strong>:<ul>
<li><strong>作用</strong>：原子性地执行所有在<code>MULTI</code>后入队的命令。</li>
<li><strong>行为</strong>：客户端发送<code>EXEC</code>后，Redis会按顺序执行队列中的所有命令。执行完毕后，一次性返回所有命令的执行结果，其顺序与命令入队顺序一致。执行后，客户端连接恢复到正常状态。</li>
</ul>
</li>
<li><strong><code>DISCARD</code></strong>:<ul>
<li><strong>作用</strong>：取消事务，放弃执行事务块内的所有命令。</li>
<li><strong>行为</strong>：客户端在<code>MULTI</code>和<code>EXEC</code>之间发送<code>DISCARD</code>，服务器会清空该客户端的命令队列，然后客户端连接恢复正常。</li>
</ul>
</li>
<li><strong><code>WATCH key [key ...]</code></strong>:<ul>
<li><strong>作用</strong>：一个<strong>乐观锁</strong>命令，用于在事务执行前监视一个或多个key。</li>
<li><strong>行为</strong>：如果在<code>WATCH</code>执行之后，<code>EXEC</code>执行之前，任何被<code>WATCH</code>的key被<strong>其他客户端</strong>修改了，那么整个事务将被取消，<code>EXEC</code>会返回一个<code>nil</code>来表示事务执行失败。</li>
</ul>
</li>
</ul>
<p><strong>基本事务流程示例</strong>：</p>
<p>假设有一个需求：将用户A的账户余额减10，同时将用户B的账户余额加10。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 正常执行</span><br><span class="line">127.0.0.1:6379&gt; MSET account:A 100 account:B 50</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY account:A 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY account:B 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) (integer) 90   # DECRBY的结果</span><br><span class="line">2) (integer) 60   # INCRBY的结果</span><br><span class="line"></span><br><span class="line"># 使用DISCARD放弃事务</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY account:A 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DISCARD</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; GET account:A</span><br><span class="line">&quot;90&quot;  # 余额未变，因为事务被取消了</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-2-Redis事务的ACID特性分析"><a href="#1-2-Redis事务的ACID特性分析" class="headerlink" title="1.2 Redis事务的ACID特性分析"></a>1.2 Redis事务的ACID特性分析</h3><p>传统关系型数据库的事务严格遵循ACID原则，但Redis的事务在实现上有所不同，特别是<strong>不保证原子性</strong>。</p>
<ul>
<li><p><strong>A - 原子性 (Atomicity)</strong>: <strong>不完全支持</strong></p>
<ul>
<li><p>Redis的事务<strong>不支持回滚 (Rollback)</strong>。</p>
</li>
<li><p><strong>语法错误</strong>：如果在入队时，命令本身存在语法错误（如<code>SETT</code>写成了<code>SETT</code>），Redis会拒绝执行整个事务，<code>EXEC</code>时会返回错误。从这个角度看，它有一定原子性。</p>
</li>
<li><p><strong>运行时错误</strong>：如果在<code>EXEC</code>执行期间，某个命令发生错误（例如，对一个字符串执行<code>INCR</code>操作），<strong>Redis不会停止，而是会继续执行后续的命令</strong>。已经执行成功的命令不会被回滚。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET mykey &quot;hello&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; INCR mykey  # 这将导致一个运行时错误</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; SET anotherkey &quot;world&quot;</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) (error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">2) OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GET anotherkey</span><br><span class="line">&quot;world&quot;  # &#x27;anotherkey&#x27; 依然被成功设置了</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结论</strong>：Redis事务是“打包执行”，要么全不执行（语法错误），要么按顺序执行但不保证全部成功（运行时错误），做不到“要么全成功，要么全失败”。</p>
</li>
</ul>
</li>
<li><p><strong>C - 一致性 (Consistency)</strong>: <strong>部分保证</strong></p>
<ul>
<li>Redis通过运行时错误（如类型错误）来保证数据库本身不会因为错误命令而进入不一致的状态。</li>
<li>但是，<strong>业务逻辑上的一致性需要由调用者来保证</strong>。例如，在上面的转账例子中，如果因为某种原因只执行了<code>DECRBY</code>而<code>INCRBY</code>失败，Redis本身是“一致”的，但业务上资金就凭空消失了。</li>
</ul>
</li>
<li><p><strong>I - 隔离性 (Isolation)</strong>: <strong>支持</strong></p>
<ul>
<li>这是Redis事务<strong>保证得最好</strong>的特性。由于Redis是单线程模型，当一个事务通过<code>EXEC</code>执行时，Redis会以串行的方式不间断地执行完所有命令。在此期间，不会有任何其他客户端的命令插入进来。</li>
</ul>
</li>
<li><p><strong>D - 持久性 (Durability)</strong>: <strong>取决于配置</strong></p>
<ul>
<li>持久性不是事务本身的特性，而是由Redis的持久化策略（RDB和AOF）决定的。如果Redis没有开启任何持久化，那么事务执行后一旦服务器宕机，数据就会丢失。如果开启了AOF并配置为<code>always</code>，那么持久性最高。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-WATCH-实现乐观锁"><a href="#1-3-WATCH-实现乐观锁" class="headerlink" title="1.3 WATCH 实现乐观锁"></a>1.3 <code>WATCH</code> 实现乐观锁</h3><p><code>WATCH</code>命令是实现**乐观锁 (Optimistic Locking)<strong>和</strong>CAS (Check-And-Set)**行为的关键。</p>
<ul>
<li><p><strong>为什么需要<code>WATCH</code>？</strong><br><code>MULTI/EXEC</code>只能保证事务执行期间的隔离性，但无法保证从“读取数据”到“准备执行事务”这个阶段的数据一致性。</p>
<ul>
<li><p><strong>场景</strong>：更新商品库存。</p>
<ol>
<li>客户端A读取库存为10。</li>
<li>客户端B也读取库存为10，并立即下单，将库存更新为9。</li>
<li>客户端A此时基于它过时的信息（库存还是10）进行计算，然后<code>MULTI/EXEC</code>将库存也更新为9。</li>
</ol>
<ul>
<li><strong>问题</strong>：两个用户都下单成功，但库存只减了1，导致数据不一致。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>WATCH</code> 的解决方案</strong>：<br><code>WATCH</code>通过在事务执行前检查关键数据是否被修改，来解决上述问题。</p>
<p><strong>流程</strong>：</p>
<ol>
<li>客户端A：<code>WATCH stock:1001</code></li>
<li>客户端A：<code>GET stock:1001</code> (得到 “10”)</li>
<li><strong>此时，客户端B执行 <code>DECR stock:1001</code>，将库存变为 “9”</strong>。</li>
<li>客户端A：基于它到的”10”计算，准备将库存设为9。</li>
<li>客户端A：<code>MULTI</code></li>
<li>客户端A：<code>SET stock:1001 9</code></li>
<li>客户端A：<code>EXEC</code> -&gt; <strong>返回 <code>(nil)</code></strong></li>
</ol>
<ul>
<li><strong>结果</strong>：因为被<code>WATCH</code>的<code>stock:1001</code>在<code>MULTI</code>之前被客户端B修改了，所以客户端A的事务被自动取消。</li>
<li><strong>应用层逻辑</strong>：客户端A的应用代码在接收到<code>nil</code>响应后，就应该知道发生了冲突，此时应该<strong>重试</strong>整个流程（重新<code>WATCH</code>、<code>GET</code>、计算、<code>EXEC</code>）。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>总结</strong>：<code>WATCH</code>实现了一种“先检查，再执行”的乐观锁机制。它假设数据冲突是小概率事件，不预先加锁，而是在提交时检查数据是否被篡改。如果被篡改，就放弃本次操作并重试。这比悲观锁（在操作前就加锁）在多数情况下有更高的并发性能。</p>
</blockquote>
<hr>
<h2 id="2-发布-订阅-Pub-Sub"><a href="#2-发布-订阅-Pub-Sub" class="headerlink" title="2. 发布&#x2F;订阅 (Pub&#x2F;Sub)"></a>2. 发布&#x2F;订阅 (Pub&#x2F;Sub)</h2><h3 id="2-1-是什么-1"><a href="#2-1-是什么-1" class="headerlink" title="2.1 是什么"></a>2.1 是什么</h3><p>发布&#x2F;订阅（Publish&#x2F;Subscribe）是一种<strong>消息通信模式</strong>，它允许消息的发送者（发布者，Publisher）与消息的接收者（订阅者，Subscriber）进行解耦。</p>
<ul>
<li><strong>发布者 (Publisher)</strong>：将消息发送到一个特定的“频道”（Channel），而不关心谁会接收这个消息。</li>
<li><strong>订阅者 (Subscriber)</strong>：对一个或多个“频道”表示兴趣，并只接收发送到这些频道的消息。</li>
<li><strong>频道 (Channel)</strong>：作为发布者和订阅者之间的中介，传递消息。</li>
</ul>
<p>这种模式就像一个广播电台。广播员（发布者）向某个频率（频道）播送节目，听众（订阅者）将收音机调到该频率就能收听。广播员不知道谁在听，听众也不知道广播员是谁，他们只通过频率进行关联。</p>
<hr>
<h3 id="2-2-核心命令"><a href="#2-2-核心命令" class="headerlink" title="2.2 核心命令"></a>2.2 核心命令</h3><ul>
<li><p><strong><code>PUBLISH channel message</code></strong>:</p>
<ul>
<li><p><strong>作用</strong>：将 <code>message</code> 发布到指定的 <code>channel</code>。</p>
</li>
<li><p><strong>返回值</strong>：接收到此消息的订阅者数量。如果没有订阅者，返回0，消息会被直接丢弃。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 发布一条新闻到 &#x27;news:sports&#x27; 频道</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH news:sports &quot;Team A won the championship!&quot;</span><br><span class="line">(integer) 1  # 表示有1个订阅者收到了消息</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>SUBSCRIBE channel [channel ...]</code></strong>:</p>
<ul>
<li><p><strong>作用</strong>：订阅一个或多个指定的频道。</p>
</li>
<li><p><strong>行为</strong>：这是一个<strong>阻塞式命令</strong>。客户端执行<code>SUBSCRIBE</code>后，会进入订阅模式，不能再执行其他普通命令（除了<code>SUBSCRIBE</code>, <code>UNSUBSCRIBE</code>等），它会一直等待并接收来自所订阅频道的消息。</p>
</li>
<li><p><strong>实践</strong>（需要两个<code>redis-cli</code>窗口）：</p>
<ul>
<li><p><strong>窗口 A (订阅者)</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE news:sports</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;news:sports&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 客户端在此处阻塞等待...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>窗口 B (发布者)</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH news:sports <span class="string">&quot;Match starting in 5 mins&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>窗口 A 会立即收到消息</strong>:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;news:sports&quot;</span><br><span class="line">3) &quot;Match starting in 5 mins&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>PSUBSCRIBE pattern [pattern ...]</code></strong>:</p>
<ul>
<li><p><strong>作用</strong>：<strong>模式订阅</strong>。可以订阅匹配特定模式的所有频道。模式使用glob风格的通配符，如 <code>*</code> (匹配任意多个字符) 和 <code>?</code> (匹配单个字符)。</p>
</li>
<li><p><strong>实践</strong>：订阅所有以 <code>news:</code> 开头的频道。</p>
<ul>
<li><p><strong>窗口 A (订阅者)</strong>:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PSUBSCRIBE news:*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;psubscribe&quot;</span><br><span class="line">2) &quot;news:*&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>窗口 B (发布者)</strong>:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBLISH news:tech &quot;Redis 8.0 is coming&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>窗口 A 收到消息</strong>（注意返回格式不同，包含了匹配的模式和实际的频道名）：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;news:*&quot;</span><br><span class="line">3) &quot;news:tech&quot;</span><br><span class="line">4) &quot;Redis 8.0 is coming&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>UNSUBSCRIBE [channel ...]</code></strong> &#x2F; <strong><code>PUNSUBSCRIBE [pattern ...]</code></strong>: 取消订阅。如果不带参数，则取消所有订阅。</p>
</li>
</ul>
<hr>
<h3 id="2-3-应用场景"><a href="#2-3-应用场景" class="headerlink" title="2.3 应用场景"></a>2.3 应用场景</h3><ol>
<li><strong>实时通知与消息推送</strong>：<ul>
<li><strong>描述</strong>：Web应用中，当某个事件发生时（如用户收到新私信、订单状态更新），后端可以向一个用户专属的频道发布消息。前端通过WebSocket与一个订阅了该频道的服务保持长连接，从而实时接收并展示通知。</li>
<li><strong>示例</strong>：后端执行 <code>PUBLISH notifications:user123 &#39;{&quot;type&quot;:&quot;new_message&quot;, &quot;from&quot;:&quot;Alice&quot;}&#39;</code>。</li>
</ul>
</li>
<li><strong>简单的实时聊天室</strong>：<ul>
<li><strong>描述</strong>：每个聊天室可以是一个频道。所有进入聊天室的用户都订阅该频道。当一个用户发送消息时，后端将其<code>PUBLISH</code>到该频道，所有订阅者都会收到这条消息。</li>
</ul>
</li>
<li><strong>服务间的简单解耦</strong>：<ul>
<li><strong>描述</strong>：当一个服务完成某个任务后，可以发布一个事件通知，其他关心此事件的服务可以订阅并做出响应。例如，订单服务完成下单后发布<code>order:created</code>事件，库存服务和物流服务可以订阅此事件来各自执行扣减库存和创建运单的操作。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-4-缺点"><a href="#2-4-缺点" class="headerlink" title="2.4 缺点"></a>2.4 缺点</h3><p>Redis的Pub&#x2F;Sub是一个非常轻量级的实现，它<strong>不保证消息的可靠性</strong>，这使其与专业的MOM（Message-Oriented Middleware，如Kafka、RabbitMQ）有本质区别。</p>
<ol>
<li><strong>消息丢失 (No Persistence)</strong>：<ul>
<li><strong>发后即忘 (Fire and Forget)</strong>：如果消息发布时，没有任何客户端订阅该频道，那么这条消息会<strong>被立即丢弃</strong>，永远丢失。</li>
<li><strong>离线丢失</strong>：如果一个订阅者客户端中途断线，它将<strong>错过在断线期间发布的所有消息</strong>。重新连接后，它只能接收到新的消息。</li>
</ul>
</li>
<li><strong>无ACK机制 (No Acknowledgement)</strong>：<ul>
<li>发布者不知道消息是否被订阅者成功接收或处理。如果订阅者在处理消息时崩溃，这条消息对该订阅者来说就相当于丢失了，无法进行重试。</li>
</ul>
</li>
<li><strong>无消息堆积和回溯能力</strong>：<ul>
<li>Pub&#x2F;Sub没有像Kafka那样的消息缓冲区。它不能存储历史消息，订阅者无法获取在它订阅之前发布的消息。</li>
</ul>
</li>
</ol>
<p><strong>结论</strong>：</p>
<p>Redis Pub&#x2F;Sub非常适合那些<strong>对消息可靠性要求不高</strong>，允许少量消息丢失，但追求<strong>实时性</strong>和<strong>简单性</strong>的场景。对于需要确保每条消息都被处理的业务场景（如订单、支付），<strong>绝对不能使用Pub&#x2F;Sub</strong>。在这种情况下，应该选择更可靠的方案，如<strong>Redis 5.0 之后引入的 <code>Stream</code> 数据结构</strong>，或者专业的MQ产品。</p>
<hr>
<h2 id="3-Pipeline-管道"><a href="#3-Pipeline-管道" class="headerlink" title="3. Pipeline (管道)"></a>3. Pipeline (管道)</h2><h3 id="3-1-是什么-1"><a href="#3-1-是什么-1" class="headerlink" title="3.1 是什么"></a>3.1 是什么</h3><p><code>Pipeline</code> 是一种<strong>客户端-服务器通信优化技术</strong>。它允许客户端将多个Redis命令打包在一起，一次性地发送给服务器，然后一次性地接收所有命令的响应。</p>
<p><strong>工作流程对比</strong>：</p>
<ul>
<li><p><strong>常规模式 (Without Pipeline)</strong>:</p>
<ol>
<li>客户端发送命令1 -&gt; 服务器接收、执行、返回响应1</li>
<li>客户端接收响应1，然后发送命令2 -&gt; 服务器接收、执行、返回响应2</li>
<li>客户端接收响应2，然后发送命令3 -&gt; 服务器接收、执行、返回响应3</li>
</ol>
<ul>
<li><strong>特点</strong>：每个命令的执行都包含一次完整的“请求-响应”网络来回，即<strong>网络往返时间 (Round Trip Time, RTT)</strong>。如果RTT是1毫秒，执行1000个命令就需要1000毫-秒。</li>
</ul>
</li>
<li><p><strong>管道模式 (With Pipeline)</strong>:</p>
<ol>
<li>客户端将命令1, 2, 3…N 打包，<strong>一次性全部发送</strong>给服务器。</li>
<li>服务器接收到命令后，按顺序执行它们，并将所有响应缓存起来。</li>
<li>服务器将所有响应打包，<strong>一次性全部返回</strong>给客户端。</li>
</ol>
<ul>
<li><strong>特点</strong>：N个命令的执行只包含<strong>一次</strong>网络RTT。如果RTT是1毫秒，执行1000个命令的总网络耗时仍然约等于1毫秒，性能提升极其显著。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>核心思想</strong>：<code>Pipeline</code> 的关键在于<strong>显著减少了因网络延迟造成的性能开销</strong>。它并不会加快Redis服务器执行命令本身的速度，但它将多次网络交互的成本压缩为了一次。</p>
</blockquote>
<hr>
<h3 id="3-2-与事务的区别"><a href="#3-2-与事务的区别" class="headerlink" title="3.2 与事务的区别"></a>3.2 与事务的区别</h3><p><code>Pipeline</code> 和 <code>Transaction</code> (事务) 看起来很像（都是打包执行一批命令），但它们在目的和保证上有着本质的区别。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Pipeline (管道)</th>
<th align="left">Transaction (MULTI&#x2F;EXEC)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心目的</strong></td>
<td align="left"><strong>性能优化</strong>：减少网络RTT</td>
<td align="left"><strong>原子性保证</strong>：确保一批命令作为一个整体执行，不被其他命令打断</td>
</tr>
<tr>
<td align="left"><strong>原子性</strong></td>
<td align="left"><strong>不保证</strong>。命令之间可能会被其他客户端的命令穿插执行。</td>
<td align="left"><strong>保证</strong>。<code>EXEC</code>时，所有命令会作为一个不可分割的单元被执行。</td>
</tr>
<tr>
<td align="left"><strong>命令执行</strong></td>
<td align="left">客户端发送后，服务器<strong>立即</strong>开始按序执行（只要接收到）。</td>
<td align="left">命令先入队（返回<code>QUEUED</code>），直到<code>EXEC</code>时才<strong>一次性</strong>执行。</td>
</tr>
<tr>
<td align="left"><strong>回滚能力</strong></td>
<td align="left">无。</td>
<td align="left">无。但如果命令入队时有语法错误，整个事务会失败。</td>
</tr>
<tr>
<td align="left"><strong>客户端行为</strong></td>
<td align="left">客户端将命令写入缓冲区，然后一次性<code>flush</code>。</td>
<td align="left">客户端发送<code>MULTI</code>，然后逐个发送命令，最后发送<code>EXEC</code>。</td>
</tr>
</tbody></table>
<p><strong>一个关键的场景区别</strong>：</p>
<ul>
<li><strong>场景A：需要连续对1000个不同的key进行<code>INCR</code>操作。</strong><ul>
<li>这些操作之间没有依赖关系，也不需要原子性。</li>
<li><strong>最佳选择</strong>：使用<code>Pipeline</code>。这会将1000次网络交互压缩为1次，性能提升巨大。</li>
</ul>
</li>
<li><strong>场景B：需要从账户A减款，同时给账户B增款。</strong><ul>
<li>这两个操作必须作为一个整体成功或失败，不能被其他操作打断。</li>
<li><strong>最佳选择</strong>：使用<code>MULTI/EXEC</code>事务。这保证了在<code>DECRBY</code>和<code>INCRBY</code>之间，不会有其他客户端的操作插进来，保证了业务逻辑的隔离性。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>总结</strong>：<code>Pipeline</code> 是为了**“快”<strong>，<code>Transaction</code> 是为了</strong>“稳”**。它们可以结合使用，即在<code>MULTI/EXEC</code>块中使用<code>Pipeline</code>来发送命令，但这种情况比较少见，因为事务内的命令本身就是打包执行的。</p>
</blockquote>
<hr>
<h3 id="3-3-Java客户端中的Pipeline应用"><a href="#3-3-Java客户端中的Pipeline应用" class="headerlink" title="3.3 Java客户端中的Pipeline应用"></a>3.3 Java客户端中的Pipeline应用</h3><p>主流的Java Redis客户端都支持<code>Pipeline</code>。以下是<code>Jedis</code>和<code>Spring Data Redis (RedisTemplate)</code>中的应用示例。</p>
<h4 id="3-3-1-Jedis-中的-Pipeline"><a href="#3-3-1-Jedis-中的-Pipeline" class="headerlink" title="3.3.1 Jedis 中的 Pipeline"></a>3.3.1 Jedis 中的 Pipeline</h4><p><code>Jedis</code>提供了非常直观的<code>Pipeline</code> API。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisPipelineDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>)) &#123;</span><br><span class="line">            <span class="comment">// 1. 获取Pipeline对象</span></span><br><span class="line">            <span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 在Pipeline中发送命令</span></span><br><span class="line">            <span class="comment">// 注意：这些命令并不会立即执行，调用返回的是一个Response对象</span></span><br><span class="line">            pipeline.set(<span class="string">&quot;user:1:name&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">            Response&lt;String&gt; nameResponse = pipeline.get(<span class="string">&quot;user:1:name&quot;</span>);</span><br><span class="line">            pipeline.incr(<span class="string">&quot;counter&quot;</span>);</span><br><span class="line">            Response&lt;String&gt; counterResponse = pipeline.get(<span class="string">&quot;counter&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 执行Pipeline</span></span><br><span class="line">            <span class="comment">// sync()方法会发送所有命令并等待所有响应</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Executing pipeline...&quot;</span>);</span><br><span class="line">            pipeline.sync(); </span><br><span class="line">            System.out.println(<span class="string">&quot;Pipeline executed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 从Response对象中获取结果</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> nameResponse.get();</span><br><span class="line">            <span class="type">long</span> <span class="variable">counter</span> <span class="operator">=</span> Long.parseLong(counterResponse.get());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Name: &quot;</span> + name);       <span class="comment">// Output: Name: Alice</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Counter: &quot;</span> + counter); <span class="comment">// Output: Counter: 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-3-2-Spring-Data-Redis-RedisTemplate-中的-Pipeline"><a href="#3-3-2-Spring-Data-Redis-RedisTemplate-中的-Pipeline" class="headerlink" title="3.3.2 Spring Data Redis (RedisTemplate) 中的 Pipeline"></a>3.3.2 Spring Data Redis (<code>RedisTemplate</code>) 中的 Pipeline</h4><p><code>RedisTemplate</code>通过<code>executePipelined</code>方法来支持管道操作。这个方法使用<code>RedisCallback</code>函数式接口，将所有在<code>doInRedis</code>回调中执行的Redis操作都放入一个<code>Pipeline</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisPipelineService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchSetAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用executePipelined执行管道操作</span></span><br><span class="line">        <span class="comment">// 返回的List包含了管道中每个命令的执行结果</span></span><br><span class="line">        List&lt;Object&gt; results = stringRedisTemplate.executePipelined(</span><br><span class="line">            (RedisCallback&lt;Object&gt;) connection -&gt; &#123;</span><br><span class="line">                <span class="comment">// 在这个回调中执行的所有命令都会被放入Pipeline</span></span><br><span class="line">                <span class="comment">// 注意：这里使用的是底层的connection对象，API更原始</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 1. 设置多个key</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;pipe:key:&quot;</span> + i;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;value&quot;</span> + i;</span><br><span class="line">                    connection.stringCommands().set(key.getBytes(), value.getBytes());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 获取多个key</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;pipe:key:&quot;</span> + i;</span><br><span class="line">                    connection.stringCommands().get(key.getBytes());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这个回调不需要返回任何东西，返回null即可</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印管道执行结果</span></span><br><span class="line">        <span class="comment">// results列表的顺序与命令执行顺序一致</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Pipeline results: &quot;</span> + results);</span><br><span class="line">        <span class="comment">// [true, true, true, true, true, &quot;value0&quot;, &quot;value1&quot;, &quot;value2&quot;, &quot;value3&quot;, &quot;value4&quot;]</span></span><br><span class="line">        <span class="comment">// 前5个是SET的结果，后5个是GET的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>：在<code>RedisTemplate</code>的<code>executePipelined</code>中，你需要使用更底层的<code>connection</code>对象和其<code>...Commands()</code>方法，并且需要手动处理字节数组的转换，这比直接使用<code>opsFor...()</code>要繁琐一些。但带来的性能提升是值得的。</li>
</ul>
<p><strong>何时使用 Pipeline？</strong></p>
<p>当你需要连续执行大量Redis命令，并且这些命令之间没有严格的依赖关系时（即后一个命令不依赖于前一个命令的执行结果），就应该毫不犹豫地使用<code>Pipeline</code>。最典型的场景就是<strong>批量写入</strong>或<strong>批量读取</strong>数据。</p>
<hr>
<h2 id="4-Lua脚本"><a href="#4-Lua脚本" class="headerlink" title="4. Lua脚本"></a>4. Lua脚本</h2><p>从Redis 2.6版本开始，通过内置的Lua解释器，Redis允许用户使用Lua语言编写脚本，并在Redis服务器端原子性地执行。</p>
<h3 id="4-1-EVAL-和-EVALSHA"><a href="#4-1-EVAL-和-EVALSHA" class="headerlink" title="4.1 EVAL 和 EVALSHA"></a>4.1 <code>EVAL</code> 和 <code>EVALSHA</code></h3><p>这两个是执行Lua脚本的核心命令。</p>
<ul>
<li><p><strong><code>EVAL script numkeys key [key ...] arg [arg ...]</code></strong>:</p>
<ul>
<li><p><strong>作用</strong>：执行一段Lua脚本字符串。</p>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>script</code>: Lua脚本的字符串内容。</li>
<li><code>numkeys</code>: 告诉Redis，接下来的参数中有多少个是Key。这是一个强制性要求，用于让Redis了解哪些参数是键，方便在集群模式下正确地将脚本路由到对应的节点。</li>
<li><code>key [key ...]</code>: 脚本中要操作的Redis Key，数量必须与<code>numkeys</code>一致。在Lua脚本中，通过<code>KEYS[1]</code>, <code>KEYS[2]</code>等来访问。</li>
<li><code>arg [arg ...]</code>: 传递给脚本的额外参数。在Lua脚本中，通过<code>ARGV[1]</code>, <code>ARGV[2]</code>等来访问。</li>
</ul>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 一个简单的脚本：获取第一个key的值，并与第一个arg比较</span><br><span class="line">127.0.0.1:6379&gt; EVAL &quot;return redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1]&quot; 1 mykey myvalue</span><br><span class="line">(integer) 1  # 假设mykey的值是myvalue</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>EVALSHA sha1 numkeys key [key ...] arg [arg ...]</code></strong>:</p>
<ul>
<li><p><strong>作用</strong>：执行一个已经缓存在Redis服务器上的脚本。</p>
</li>
<li><p><strong><code>sha1</code></strong>: 脚本内容的SHA1校验和。</p>
</li>
<li><p><strong>工作流程</strong>：</p>
<ol>
<li>Redis服务器在第一次执行<code>EVAL</code>时，会将该脚本的SHA1哈希值和脚本内容缓存起来。</li>
<li>客户端可以后续使用<code>EVALSHA</code>命令，只发送这个简短的SHA1哈希值来执行同一个脚本，而无需每次都发送完整的脚本内容。</li>
<li><strong>好处</strong>：极大地减少了网络带宽的占用，特别是对于长脚本。</li>
</ol>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 1. 客户端先计算脚本的SHA1值 (假设为 &quot;6b1bf486c81ceb7eff1c7987ade1c0953a116813&quot;)</span><br><span class="line"></span><br><span class="line"># 2. 尝试用EVALSHA执行</span><br><span class="line">127.0.0.1:6379&gt; EVALSHA 6b1bf486c81ceb7eff1c7987ade1c0953a116813 1 mykey myvalue</span><br><span class="line"></span><br><span class="line"># 3. 如果服务器返回 &quot;NOSCRIPT No matching script. Please use EVAL.&quot; 错误，</span><br><span class="line">#    说明服务器上没有缓存这个脚本。此时客户端再用EVAL执行一次，让服务器缓存它。</span><br><span class="line">#    之后就可以一直使用EVALSHA了。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>SCRIPT LOAD script</code></strong>: 此命令可以主动将一个脚本加载到缓存中并返回其SHA1值，而不立即执行它。</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-2-为什么需要Lua脚本"><a href="#4-2-为什么需要Lua脚本" class="headerlink" title="4.2 为什么需要Lua脚本"></a>4.2 为什么需要Lua脚本</h3><p>Lua脚本主要解决了两大痛点：</p>
<ol>
<li><strong>保证原子性 (Atomicity)</strong><ul>
<li><strong>问题</strong>：很多复杂的业务逻辑需要“先读、再改、后写”多个步骤。例如，更新库存时，需要先<code>GET</code>当前库存，在客户端计算新库存，再<code>SET</code>回去。在这个过程中，可能会有其他客户端修改库存，导致数据不一致。虽然<code>WATCH/MULTI/EXEC</code>可以实现乐观锁，但它需要客户端进行重试，增加了复杂性。</li>
<li><strong>Lua解决方案</strong>：Redis保证<strong>整个Lua脚本的执行是原子性的</strong>。当一个脚本在执行时，Redis服务器不会执行任何其他命令或脚本，直到当前脚本执行完毕。这就像一个更强大、更灵活的事务，将多个操作封装在一个不可分割的单元中，从根本上杜绝了竞态条件。</li>
</ul>
</li>
<li><strong>减少网络开销 (Reduce Network Overhead)</strong><ul>
<li><strong>问题</strong>：对于一些需要多次与Redis交互的复杂操作，每次命令都需要一次网络往返（RTT）。这在高延迟的网络环境下会严重影响性能。虽然<code>Pipeline</code>可以解决部分问题，但<code>Pipeline</code>中的命令之间不能有逻辑依赖。</li>
<li><strong>Lua解决方案</strong>：将复杂的逻辑封装在一个Lua脚本中，客户端只需要发送一次脚本执行请求。所有的计算和数据操作都在Redis服务器端完成，将多次网络交互压缩为一次。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>总结</strong>：Lua脚本 &#x3D; <strong>原子性</strong> + <strong>高性能</strong>。它提供了一种在服务端自定义原子命令的能力。</p>
</blockquote>
<h3 id="4-3-编写简单的Lua脚本案例"><a href="#4-3-编写简单的Lua脚本案例" class="headerlink" title="4.3 编写简单的Lua脚本案例"></a>4.3 编写简单的Lua脚本案例</h3><p>在Lua脚本中，你可以通过<code>redis.call()</code>函数来调用Redis的原生命令。</p>
<h4 id="4-3-1-安全的CAS操作（库存扣减）"><a href="#4-3-1-安全的CAS操作（库存扣减）" class="headerlink" title="4.3.1 安全的CAS操作（库存扣减）"></a>4.3.1 安全的CAS操作（库存扣减）</h4><p><strong>需求</strong>：扣减商品库存。只有当当前库存大于等于要扣减的数量时，才执行扣减，否则返回失败。</p>
<ul>
<li><p><strong>不使用Lua的痛点</strong>：<code>GET</code>库存 -&gt; 在客户端判断 -&gt; <code>DECRBY</code>库存。这三步非原子，有并发问题。</p>
</li>
<li><p><strong>使用Lua脚本</strong>：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 脚本: decrement_stock.lua</span></span><br><span class="line"><span class="keyword">local</span> current_stock = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>])) <span class="comment">-- 获取当前库存</span></span><br><span class="line"><span class="keyword">local</span> decrement_amount = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>]) <span class="comment">-- 获取要扣减的数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> current_stock &gt;= decrement_amount <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 库存充足，执行扣减并返回新库存</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;decrby&#x27;</span>, KEYS[<span class="number">1</span>], decrement_amount) </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 库存不足，返回0或-1表示失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>执行</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 假设库存键是 stock:product:1001，当前值为10</span><br><span class="line">127.0.0.1:6379&gt; SET stock:product:1001 10</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"># 尝试扣减5个</span><br><span class="line">127.0.0.1:6379&gt; EVAL &quot;...&quot; 1 stock:product:1001 5</span><br><span class="line">(integer) 5  # 成功，返回新库存5</span><br><span class="line"></span><br><span class="line"># 再次尝试扣减8个</span><br><span class="line">127.0.0.1:6379&gt; EVAL &quot;...&quot; 1 stock:product:1001 8</span><br><span class="line">(integer) 0  # 失败，因为5 &lt; 8</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原子性保证</strong>：从<code>get</code>到<code>decrby</code>的整个逻辑都在Redis服务端一次性完成，不会被任何其他命令打断。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-3-2-安全地释放分布式锁"><a href="#4-3-2-安全地释放分布式锁" class="headerlink" title="4.3.2 安全地释放分布式锁"></a>4.3.2 安全地释放分布式锁</h4><p><strong>需求</strong>：释放一个分布式锁。为了防止误删其他客户端持有的锁，必须先判断锁的值是否与自己加锁时设置的唯一ID匹配。</p>
<ul>
<li><p><strong>不使用Lua的痛点</strong>：<code>GET</code>锁的值 -&gt; 在客户端判断是否匹配 -&gt; <code>DEL</code>锁。这两步非原子，可能在<code>GET</code>和<code>DEL</code>之间锁恰好过期并被其他客户端获取，导致误删。</p>
</li>
<li><p><strong>使用Lua脚本</strong>：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 脚本: unlock.lua</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 锁存在且是自己的，执行删除</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 锁不存在或不是自己的，返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>执行</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 假设锁的key是 &#x27;my_lock&#x27;，客户端A加锁时设置的唯一值是 &#x27;client_A_uuid&#x27;</span><br><span class="line">127.0.0.1:6379&gt; SET my_lock &quot;client_A_uuid&quot; NX PX 30000</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"># 客户端A释放锁</span><br><span class="line">127.0.0.1:6379&gt; EVAL &quot;...&quot; 1 my_lock &quot;client_A_uuid&quot;</span><br><span class="line">(integer) 1  # 成功删除，返回1</span><br><span class="line"></span><br><span class="line"># 客户端B尝试释放客户端A的锁</span><br><span class="line">127.0.0.1:6379&gt; EVAL &quot;...&quot; 1 my_lock &quot;client_B_uuid&quot;</span><br><span class="line">(integer) 0  # 失败，因为值不匹配，返回0</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原子性保证</strong>：“判断”和“删除”这两个动作被捆绑在一起，成为了一个原子的<code>unlock</code>操作。这是实现高可用分布式锁的标准做法。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="六、持久化机制-数据安全保障"><a href="#六、持久化机制-数据安全保障" class="headerlink" title="六、持久化机制 (数据安全保障)"></a>六、持久化机制 (数据安全保障)</h1><h2 id="1-RDB-Redis-Database"><a href="#1-RDB-Redis-Database" class="headerlink" title="1. RDB (Redis Database)"></a>1. RDB (Redis Database)</h2><h3 id="1-1-工作原理：快照-Snapshot"><a href="#1-1-工作原理：快照-Snapshot" class="headerlink" title="1.1 工作原理：快照 (Snapshot)"></a>1.1 工作原理：快照 (Snapshot)</h3><p>RDB持久化是指在<strong>指定的时间间隔内</strong>，将Redis在内存中的**某一时刻的数据集快照（snapshot）**写入到磁盘上的一个二进制文件（默认为<code>dump.rdb</code>）中。</p>
<p>想象一下给你的电脑系统拍一张“快照”，这张快照记录了那一刻所有文件的状态。RDB做的就是类似的事情，它记录了某个时间点上Redis内存里所有Key-Value的数据。</p>
<hr>
<h3 id="1-2-触发方式"><a href="#1-2-触发方式" class="headerlink" title="1.2 触发方式"></a>1.2 触发方式</h3><p>RDB的触发主要分为手动触发和自动触发。</p>
<ul>
<li><p><strong>手动触发</strong>：</p>
<ul>
<li><strong><code>SAVE</code></strong>:<ul>
<li><strong>行为</strong>：这是一个<strong>阻塞式</strong>命令。当执行<code>SAVE</code>时，Redis主进程会亲自执行RDB持久化过程，期间<strong>不会响应任何其他客户端的命令</strong>，直到RDB文件创建完毕。</li>
<li><strong>使用场景</strong>：基本<strong>不用于生产环境</strong>，因为它会严重阻塞服务。通常只在维护、迁移或没有客户端连接时使用。</li>
</ul>
</li>
<li><strong><code>BGSAVE</code> (Background Save)</strong>:<ul>
<li><strong>行为</strong>：这是一个<strong>非阻塞式</strong>命令，也是<strong>默认的、推荐的方式</strong>。当执行<code>BGSAVE</code>时，Redis主进程会<code>fork()</code>出一个<strong>子进程</strong>。子进程负责将内存数据写入到临时的RDB文件中，写完后再替换掉旧的<code>dump.rdb</code>文件。主进程则可以继续处理客户端的请求。</li>
<li><strong><code>fork()</code>的魔力</strong>：<code>fork()</code>利用了操作系统的写时复制（Copy-on-Write, COW）机制。子进程创建时，与主进程共享同一份内存数据。只有当主进程需要修改某个数据页时，操作系统才会复制这个数据页，让主进程修改副本，而子进程仍然读取旧的、未修改的数据页。这保证了子进程能拿到一个一致性的数据快照，同时对主进程性能影响降到最低。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>自动触发</strong>：</p>
<ul>
<li><p>在<code>redis.conf</code>中通过<code>save</code>配置项来设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">save 900 1      # 900秒内，如果至少有1个key被修改，则触发BGSAVE</span><br><span class="line">save 300 10     # 300秒内，如果至少有10个key被修改，则触发BGSAVE</span><br><span class="line">save 60 10000   # 60秒内，如果至少有10000个key被修改，则触发BGSAVE</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>工作原理</strong>：Redis服务器会周期性地检查距离上次<code>BGSAVE</code>过去了多久，以及期间有多少次写操作，如果满足任何一条<code>save</code>规则，就会自动触发一次<code>BGSAVE</code>。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-优缺点分析"><a href="#1-3-优缺点分析" class="headerlink" title="1.3 优缺点分析"></a>1.3 优缺点分析</h3><p><strong>优点</strong>：</p>
<ol>
<li><strong>性能好，对主进程影响小</strong>：<code>BGSAVE</code>使用子进程进行持久化，主进程可以继续服务，性能影响主要在<code>fork()</code>的瞬间。</li>
<li><strong>恢复速度快</strong>：RDB文件是一个紧凑的二进制文件，存储了某一时刻的全量数据。在Redis启动时，直接加载这个文件即可，恢复速度远快于AOF。</li>
<li><strong>文件体积小</strong>：经过压缩的二进制格式，文件体积比文本格式的AOF小很多，便于备份和传输。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><strong>数据丢失风险高</strong>：RDB是间隔性地进行持久化。如果在上一次<code>BGSAVE</code>之后，下一次<code>BGSAVE</code>之前，Redis服务器发生故障，那么这期间所有被修改的数据都将<strong>全部丢失</strong>。这个时间间隔可能长达数分钟。</li>
<li><strong><code>fork()</code>的开销</strong>：虽然<code>fork()</code>很快，但如果Redis实例的内存非常大（几十GB），<code>fork()</code>的过程依然会消耗一定时间，并可能导致服务器在<code>fork()</code>瞬间出现短暂的卡顿。</li>
</ol>
<hr>
<h2 id="2-AOF-Append-Only-File"><a href="#2-AOF-Append-Only-File" class="headerlink" title="2. AOF (Append Only File)"></a>2. AOF (Append Only File)</h2><h3 id="2-1-工作原理：命令追加"><a href="#2-1-工作原理：命令追加" class="headerlink" title="2.1 工作原理：命令追加"></a>2.1 工作原理：命令追加</h3><p>AOF持久化记录的不是数据快照，而是<strong>每一个写命令</strong>。当Redis服务器执行一个写命令（如<code>SET</code>, <code>INCR</code>）时，它会将这个命令以协议文本的格式追加到AOF文件的末尾。</p>
<p>当Redis重启时，它会<strong>从头到尾重新执行一遍AOF文件中保存的所有写命令</strong>，从而将数据恢复到宕机前的状态。</p>
<hr>
<h3 id="2-2-appendfsync策略"><a href="#2-2-appendfsync策略" class="headerlink" title="2.2 appendfsync策略"></a>2.2 <code>appendfsync</code>策略</h3><p>AOF的核心在于何时将内存缓冲区中的命令写入到磁盘上的AOF文件。这由<code>appendfsync</code>配置项决定，它提供了三种策略：</p>
<ul>
<li><strong><code>always</code></strong>:<ul>
<li><strong>行为</strong>：每个写命令执行完毕后，都立即调用<code>fsync()</code>将命令同步到磁盘。</li>
<li><strong>优点</strong>：<strong>数据最安全</strong>，理论上最多只会丢失一个事件循环内的数据。</li>
<li><strong>缺点</strong>：<strong>性能最差</strong>。每次写操作都会引发一次磁盘I&#x2F;O，严重影响Redis的QPS。</li>
</ul>
</li>
<li><strong><code>everysec</code> (默认)</strong>:<ul>
<li><strong>行为</strong>：每个写命令执行完毕后，先将命令写入操作系统的文件缓冲区，然后由一个后台线程<strong>每秒</strong>调用一次<code>fsync()</code>将缓冲区内容同步到磁盘。</li>
<li><strong>优点</strong>：在性能和数据安全之间取得了<strong>最佳平衡</strong>。即使服务器宕机，最多也只会丢失<strong>最近一秒钟</strong>的数据。</li>
<li><strong>缺点</strong>：在极端情况下（一秒内宕机），仍有少量数据丢失的风险。</li>
</ul>
</li>
<li><strong><code>no</code></strong>:<ul>
<li><strong>行为</strong>：Redis只负责将命令写入文件缓冲区，何时同步到磁盘完全由<strong>操作系统决定</strong>。在Linux上，这通常意味着每30秒左右同步一次。</li>
<li><strong>优点</strong>：<strong>性能最好</strong>，几乎没有额外的I&#x2F;O开销。</li>
<li><strong>缺点</strong>：<strong>数据最不安全</strong>，宕机时可能丢失大量数据。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-AOF重写-Rewrite-机制"><a href="#2-3-AOF重写-Rewrite-机制" class="headerlink" title="2.3 AOF重写 (Rewrite) 机制"></a>2.3 AOF重写 (Rewrite) 机制</h3><p>随着时间的推移，AOF文件会因为记录了大量的写命令而变得越来越大。例如，对一个计数器执行100次<code>INCR</code>，AOF文件中会记录100条<code>INCR</code>命令，而实际上最终只需要一条<code>SET counter 100</code>即可。</p>
<p>AOF重写就是为了解决这个问题，它的作用是**“瘦身”AOF文件**。</p>
<ul>
<li><strong>工作原理</strong>：<ol>
<li>Redis触发AOF重写时（手动<code>BGREWRITEAOF</code>或自动触发），会<code>fork()</code>一个<strong>子进程</strong>。</li>
<li>子进程<strong>不读取旧的AOF文件</strong>，而是直接遍历当前内存中的数据集。</li>
<li>对于每一个Key，子进程会用<strong>一条最精简的命令</strong>（如<code>SET</code>, <code>HMSET</code>, <code>SADD</code>等）来生成一个新的、临时的AOF文件，这个新文件就代表了当前内存数据的状态。</li>
<li>在子进程重写期间，主进程接收到的新写命令，会同时写入“AOF缓冲区”和“AOF重写缓冲区”。</li>
<li>子进程完成重写后，通知主进程。主进程将“AOF重写缓冲区”中的增量命令追加到新的AOF文件末尾。</li>
<li>最后，主进程用新的AOF文件替换掉旧的AOF文件。</li>
</ol>
</li>
<li><strong>优点</strong>：重写过程在后台进行，不阻塞主进程。重写后的AOF文件体积大大减小，加快了数据恢复速度。</li>
</ul>
<hr>
<h3 id="2-4-优缺点分析"><a href="#2-4-优缺点分析" class="headerlink" title="2.4 优缺点分析"></a>2.4 优缺点分析</h3><p><strong>优点</strong>：</p>
<ol>
<li><strong>数据安全性高</strong>：使用<code>everysec</code>策略，最多只会丢失1秒的数据。</li>
<li><strong>文件可读</strong>：AOF文件是协议文本，可读性好，便于分析和修复。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><strong>文件体积大</strong>：相比RDB，AOF文件通常更大（除非经过重写）。</li>
<li><strong>恢复速度慢</strong>：恢复时需要逐条执行命令，速度比直接加载RDB慢。</li>
<li><strong>性能开销</strong>：即使是<code>everysec</code>，每秒一次的<code>fsync</code>对磁盘I&#x2F;O仍有一定压力。</li>
</ol>
<hr>
<h2 id="3-RDB-与-AOF-的抉择"><a href="#3-RDB-与-AOF-的抉择" class="headerlink" title="3. RDB 与 AOF 的抉择"></a>3. RDB 与 AOF 的抉择</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">RDB</th>
<th align="left">AOF</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据安全性</strong></td>
<td align="left">低 (分钟级丢失)</td>
<td align="left">高 (秒级丢失)</td>
</tr>
<tr>
<td align="left"><strong>恢复速度</strong></td>
<td align="left">快</td>
<td align="left">慢</td>
</tr>
<tr>
<td align="left"><strong>文件大小</strong></td>
<td align="left">小 (二进制压缩)</td>
<td align="left">大 (文本，需重写)</td>
</tr>
<tr>
<td align="left"><strong>性能影响</strong></td>
<td align="left">低 (<code>fork</code>瞬间)</td>
<td align="left">相对高 (持续I&#x2F;O)</td>
</tr>
</tbody></table>
<h3 id="3-1-生产环境如何选择？（推荐混合使用）"><a href="#3-1-生产环境如何选择？（推荐混合使用）" class="headerlink" title="3.1 生产环境如何选择？（推荐混合使用）"></a>3.1 生产环境如何选择？（推荐混合使用）</h3><p>在Redis 4.0之前，生产环境的最佳实践是<strong>同时开启RDB和AOF</strong>。</p>
<ul>
<li><p><strong>配置</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 60 1000</span><br><span class="line">appendonly yes</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>工作方式</strong>：</p>
<ul>
<li><strong>数据恢复</strong>：当Redis重启时，它会<strong>优先使用AOF文件</strong>来恢复数据，因为AOF的数据通常比RDB更完整。</li>
<li><strong>数据备份</strong>：RDB文件因为体积小、传输快，非常适合用于<strong>日常备份、主从复制的全量同步</strong>等场景。</li>
</ul>
</li>
<li><p><strong>好处</strong>：结合了两者的优点，既能保证较高的数据安全性（AOF），又能方便地进行数据备份和快速的主从同步（RDB）。</p>
</li>
</ul>
<hr>
<h3 id="3-2-Redis-4-0后的混合持久化"><a href="#3-2-Redis-4-0后的混合持久化" class="headerlink" title="3.2 Redis 4.0后的混合持久化"></a>3.2 Redis 4.0后的混合持久化</h3><p>为了解决AOF恢复速度慢的问题，Redis 4.0引入了<strong>混合持久化 (Mixed Persistence)</strong>。</p>
<ul>
<li><p><strong>开启方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>工作原理</strong>：<br>当触发AOF重写时，新的AOF文件将由两部分组成：</p>
<ol>
<li><strong>第一部分</strong>：一个<strong>RDB格式的数据块</strong>，包含了重写开始时内存数据的全量快照。</li>
<li><strong>第二部分</strong>：<strong>AOF格式的增量命令</strong>，包含了重写期间新产生的写命令。</li>
</ol>
</li>
<li><p><strong>数据恢复</strong>：当Redis重启时，</p>
<ol>
<li>先加载文件头部的RDB部分，快速恢复基础数据。</li>
<li>再加载文件尾部的AOF部分，应用增量命令。</li>
</ol>
</li>
<li><p><strong>优点</strong>：<strong>集RDB和AOF的优点于一身</strong>。既保证了AOF的高数据安全性，又利用了RDB的快速恢复能力。这是目前<strong>生产环境的首选持久化方案</strong>。</p>
</li>
</ul>
<hr>
<h1 id="七、企业级特性：高可用与扩展"><a href="#七、企业级特性：高可用与扩展" class="headerlink" title="七、企业级特性：高可用与扩展"></a>七、企业级特性：高可用与扩展</h1><h2 id="1-主从复制-Master-Slave-Replication"><a href="#1-主从复制-Master-Slave-Replication" class="headerlink" title="1. 主从复制 (Master-Slave Replication)"></a>1. 主从复制 (Master-Slave Replication)</h2><p>主从复制是指将一台Redis服务器（称为<strong>主节点 Master</strong>）的数据，实时、异步地复制到其他一台或多台Redis服务器（称为<strong>从节点 Slave</strong>）上。</p>
<ul>
<li><strong>数据流向</strong>：数据流是<strong>单向的</strong>，只能从Master流向Slave。</li>
<li><strong>读写规则</strong>：默认情况下，Master节点负责处理<strong>读和写</strong>操作，而Slave节点只负责处理<strong>读</strong>操作。对Slave节点的任何写操作都会被拒绝。</li>
</ul>
<h3 id="1-1-配置方法"><a href="#1-1-配置方法" class="headerlink" title="1.1 配置方法"></a>1.1 配置方法</h3><p>配置主从复制非常简单，主要有两种方式：</p>
<ul>
<li><p><strong>方式一：在<code>redis.conf</code>中配置（永久生效）</strong><br>在<strong>从节点</strong>的<code>redis.conf</code>文件中，添加或修改以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">replicaof 192.168.1.100 6379</span><br><span class="line"></span><br><span class="line"># 如果Master设置了密码，还需配置</span><br><span class="line">masterauth &lt;master-password&gt;</span><br></pre></td></tr></table></figure>

<p>修改配置后，重启从节点服务，它就会自动去连接Master并开始复制。</p>
</li>
<li><p><strong>方式二：使用<code>REPLICAOF</code>命令（临时生效）</strong><br>在<strong>从节点</strong>的<code>redis-cli</code>中，直接执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; REPLICAOF 192.168.1.100 6379</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>这种方式在从节点重启后会失效。如果要取消复制，变回Master，执行<code>REPLICAOF no one</code>。</p>
</li>
</ul>
<h3 id="1-2-核心原理"><a href="#1-2-核心原理" class="headerlink" title="1.2 核心原理"></a>1.2 核心原理</h3><p>主从复制的过程可以分为两个阶段：<strong>全量复制</strong>（首次同步）和<strong>增量复制</strong>（持续同步）。</p>
<h4 id="1-2-1-全量复制-Full-Resynchronization"><a href="#1-2-1-全量复制-Full-Resynchronization" class="headerlink" title="1.2.1 全量复制 (Full Resynchronization)"></a>1.2.1 全量复制 (Full Resynchronization)</h4><p>当一个Slave节点第一次连接到一个Master节点时，或者在断线重连后无法进行增量复制时，就会触发全量复制。</p>
<p><strong>步骤详解</strong>：</p>
<ol>
<li><strong>连接建立与协商</strong>：<ul>
<li>Slave发送<code>PSYNC ? -1</code>命令给Master，表示请求全量同步。</li>
<li>Master收到请求，确认这是一个全量同步请求。</li>
</ul>
</li>
<li><strong>Master生成RDB</strong>：<ul>
<li>Master执行<code>BGSAVE</code>命令，在后台<code>fork()</code>一个子进程来生成一个RDB快照文件。</li>
<li>在生成RDB期间，Master接收到的所有新的写命令，都会被缓存在一个**复制缓冲区（Replication Buffer）**中。</li>
</ul>
</li>
<li><strong>Master发送RDB</strong>：<ul>
<li>RDB文件生成后，Master将其发送给Slave。</li>
</ul>
</li>
<li><strong>Slave加载RDB</strong>：<ul>
<li>Slave接收到RDB文件后，会先<strong>清空自己当前的所有数据</strong>。</li>
<li>然后，Slave加载RDB文件，将数据恢复到Master执行<code>BGSAVE</code>时的状态。</li>
</ul>
</li>
<li><strong>Master发送缓冲区命令</strong>：<ul>
<li>RDB发送完毕后，Master会将第2步中缓存在<strong>复制缓冲区</strong>里的所有写命令，发送给Slave。</li>
</ul>
</li>
<li><strong>Slave执行缓冲区命令</strong>：<ul>
<li>Slave执行这些来自缓冲区的写命令，使其数据状态与Master完全一致。</li>
</ul>
</li>
</ol>
<p>至此，全量复制完成，Slave进入持续的增量复制阶段。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>全量复制是一个<strong>重操作</strong>。Master生成RDB和Slave加载RDB都比较耗时，并且会消耗大量的CPU、内存和网络带宽资源。</li>
</ul>
<hr>
<h4 id="1-2-2-增量复制-Partial-Resynchronization"><a href="#1-2-2-增量复制-Partial-Resynchronization" class="headerlink" title="1.2.2 增量复制 (Partial Resynchronization)"></a>1.2.2 增量复制 (Partial Resynchronization)</h4><p>在全量复制完成后，主从之间会通过一个TCP长连接来维持同步。Master上执行的任何写命令，都会被实时地、异步地发送给所有Slave节点。</p>
<p><strong>核心机制</strong>：</p>
<p>为了支持断线重连后的增量复制，Redis引入了三个关键概念：</p>
<ul>
<li><strong>复制积压缓冲区 (Replication Backlog)</strong>:<ul>
<li>这是一个在Master节点上维护的<strong>固定大小的环形缓冲区</strong>（默认为1MB）。</li>
<li>它记录了Master最近执行的写命令。当Master将命令发送给Slave时，也会将这些命令写入这个缓冲区。</li>
<li>这个缓冲区对所有Slave共享。</li>
</ul>
</li>
<li><strong>复制偏移量 (Replication Offset)</strong>:<ul>
<li>Master和每个Slave都各自维护一个复制偏移量。</li>
<li>Master每次向缓冲区写入N个字节的数据，自己的偏移量就增加N。</li>
<li>Slave每次接收到N个字节的数据，自己的偏移量也增加N。</li>
<li>正常情况下，Master和Slave的偏移量应该是同步增长的。</li>
</ul>
</li>
<li><strong>服务器运行ID (Run ID)</strong>:<ul>
<li>每个Redis实例启动时都会生成一个唯一的、随机的40位字符串作为其运行ID。</li>
<li>用于在断线重连时，识别对方是否还是原来的那个实例。</li>
</ul>
</li>
</ul>
<p><strong>断线重连后的增量复制流程</strong>：</p>
<ol>
<li>Slave与Master断开连接。</li>
<li>Slave重新连接上Master。</li>
<li>Slave发送<code>PSYNC &lt;master_run_id&gt; &lt;slave_offset + 1&gt;</code>命令，将自己之前记录的Master的<code>run_id</code>和自己的<code>offset</code>发送给Master。</li>
<li>Master收到请求后：<ul>
<li><strong>检查<code>run_id</code></strong>：如果<code>run_id</code>不匹配，说明Master已经重启，需要进行<strong>全量复制</strong>。</li>
<li><strong>检查<code>offset</code></strong>：如果<code>run_id</code>匹配，Master会检查Slave请求的<code>offset</code>是否还在自己的<strong>复制积压缓冲区</strong>内。<ul>
<li><strong>如果在</strong>：说明断线时间不长，缺失的命令还在缓冲区里。Master会返回<code>+CONTINUE</code>，然后将从Slave的<code>offset</code>到当前<code>offset</code>之间的所有命令发送给Slave。这就完成了<strong>增量复制</strong>。</li>
<li><strong>如果不在</strong>：说明断线时间太长，缺失的命令已经被新的命令覆盖了。Master无法补全数据，只能返回<code>-ERR</code>，并触发一次<strong>全量复制</strong>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>优化提示</strong>：如果网络抖动频繁，可以适当调大<code>repl-backlog-size</code>配置，以增加增量复制成功的概率，避免昂贵的全量复制。</p>
</blockquote>
<hr>
<h3 id="1-3-作用"><a href="#1-3-作用" class="headerlink" title="1.3 作用"></a>1.3 作用</h3><ol>
<li><strong>读写分离 (Read&#x2F;Write Splitting)</strong><ul>
<li><strong>目的</strong>：分担Master的读压力，提升整个Redis系统的吞吐量。</li>
<li><strong>架构</strong>：Master节点专注于处理写请求和少量的读请求，而将大量的读请求分发到多个Slave节点上。</li>
<li><strong>注意点</strong>：主从复制是<strong>异步</strong>的，这意味着在某个瞬间，Slave上的数据可能略微落后于Master（通常是毫秒级）。对于那些对数据一致性要求极高的读请求，仍然需要访问Master。</li>
</ul>
</li>
<li><strong>数据备份 (Data Backup)</strong><ul>
<li>Slave节点是Master节点的一个实时热备份。当Master节点因为硬件故障、进程崩溃等原因宕机时，Slave节点上依然保留着几乎所有的数据（最多丢失1秒，取决于AOF配置），可以作为数据恢复的来源。</li>
</ul>
</li>
<li><strong>高可用 (High Availability)</strong><ul>
<li>主从复制是实现Redis高可用的基础。当Master宕机时，可以<strong>手动</strong>或通过<strong>哨兵(Sentinel)自动</strong>将其中一个Slave节点提升（promote）为新的Master，从而继续对外提供写服务，保证了服务的连续性。这被称为<strong>故障转移 (Failover)</strong>。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-Sentinel-哨兵-模式"><a href="#2-Sentinel-哨兵-模式" class="headerlink" title="2. Sentinel (哨兵) 模式"></a>2. Sentinel (哨兵) 模式</h2><p><code>Sentinel</code> 是Redis官方推荐的高可用性（High Availability, HA）解决方案。它是一个特殊的Redis进程，其主要任务是<strong>监控一组Redis主从实例</strong>，并在主节点（Master）出现故障时，<strong>自动地将一个从节点（Slave）提升为新的主节点</strong>，从而保证系统的持续可用。</p>
<h3 id="2-1-功能"><a href="#2-1-功能" class="headerlink" title="2.1 功能"></a>2.1 功能</h3><p>Sentinel提供了以下三大核心功能：</p>
<ol>
<li><strong>监控 (Monitoring)</strong><ul>
<li>Sentinel会持续地向它所监控的所有Redis实例（包括Master和Slaves）发送<code>PING</code>命令，以检查它们是否处于正常工作状态。</li>
<li>如果一个实例在配置的<code>down-after-milliseconds</code>时间内没有有效响应，Sentinel会将其标记为<strong>主观下线 (Subjectively Down, SDOWN)</strong>。</li>
</ul>
</li>
<li><strong>通知 (Notification)</strong><ul>
<li>当被监控的Redis实例出现问题时（如被标记为主观下线或客观下线），Sentinel可以通过API将这些事件通知给管理员或其他应用程序。</li>
</ul>
</li>
<li><strong>自动故障转移 (Automatic Failover)</strong><ul>
<li><strong>这是Sentinel最核心的功能</strong>。当一个Master被标记为**客观下线 (Objectively Down, ODOWN)**后，Sentinel集群会自动开始故障转移流程。</li>
<li>它会在所有Slave中选举出一个最合适的节点，将其提升为新的Master。</li>
<li>然后，它会配置其他Slave节点去复制（<code>REPLICAOF</code>）这个新的Master。</li>
<li>同时，它还会通知客户端，告知它们新的Master地址。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-2-工作原理"><a href="#2-2-工作原理" class="headerlink" title="2.2 工作原理"></a>2.2 工作原理</h3><p>Sentinel通常以一个<strong>集群</strong>的形式部署（推荐至少3个或更多的奇数个实例），以避免自身单点故障，并能通过“投票”机制达成共识。</p>
<p><strong>核心概念</strong>：</p>
<ul>
<li><strong>主观下线 (SDOWN)</strong>：单个Sentinel实例认为一个Redis节点已经下线。这只是它自己的判断，可能是因为网络分区导致它与该节点失联。</li>
<li><strong>客观下线 (ODOWN)</strong>：当<strong>足够数量</strong>的Sentinel实例（达到配置的<code>quorum</code>法定人数）都认为一个Master节点已经主观下线时，该Master节点就会被标记为客观下线。这是发起故障转移的前提。</li>
</ul>
<p><strong>工作流程</strong>：</p>
<ol>
<li><strong>监控与主观下线</strong>：<ul>
<li>每个Sentinel实例以每秒一次的频率向所有被监控的Redis实例（Master, Slaves）以及其他Sentinel实例发送<code>PING</code>命令。</li>
<li>如果一个实例在<code>down-after-milliseconds</code>内没有响应，该Sentinel将其标记为<code>SDOWN</code>。</li>
</ul>
</li>
<li><strong>确认客观下线</strong>：<ul>
<li>当一个Sentinel将Master标记为<code>SDOWN</code>后，它会向Sentinel集群中的其他Sentinel实例发送<code>SENTINEL is-master-down-by-addr</code>命令，询问它们是否也认为该Master下线了。</li>
<li>当收到足够数量（&gt;&#x3D; <code>quorum</code>）的其他Sentinel确认后，该Sentinel就会将Master标记为<code>ODOWN</code>。</li>
</ul>
</li>
<li><strong>选举Leader Sentinel</strong>：<ul>
<li>一旦Master被确认为<code>ODOWN</code>，所有Sentinel实例会开始一次<strong>Leader选举</strong>，以选出一个“领导者”来负责执行接下来的故障转移。</li>
<li>选举算法基于<strong>Raft协议</strong>的变种：<ul>
<li>每个Sentinel都想成为Leader。它会向其他Sentinel发送请求，要求投票给自己。</li>
<li>每个Sentinel在一个选举周期（epoch）中只有一票。它会把票投给第一个向它请求的Sentinel。</li>
<li>当一个Sentinel获得了超过半数（N&#x2F;2 + 1）的选票时，它就成功当选为Leader。</li>
</ul>
</li>
<li>这个选举过程保证了在任何一个时刻，只有一个Sentinel在执行故障转移。</li>
</ul>
</li>
<li><strong>故障切换流程 (由Leader Sentinel执行)</strong>：<ul>
<li><strong>a. 挑选新Master</strong>：Leader Sentinel会从所有Slave节点中，按照一套优先级规则挑选出一个最合适的节点作为新的Master。<ul>
<li><strong>规则1：优先级</strong>。选择<code>replica-priority</code>（或<code>slave-priority</code>）配置值最低的Slave（值越小优先级越高，0表示不参与选举）。</li>
<li><strong>规则2：复制偏移量</strong>。如果优先级相同，选择复制偏移量（replication offset）最大的Slave，因为它的数据最接近旧Master。</li>
<li><strong>规则3：运行ID</strong>。如果前两者都相同，选择运行ID（run id）最小的Slave。</li>
</ul>
</li>
<li><strong>b. 提升为Master</strong>：Leader Sentinel向被选中的Slave发送<code>REPLICAOF no one</code>命令，使其转变为新的Master。</li>
<li><strong>c. 配置其他Slaves</strong>：Leader Sentinel向剩余的其他Slave节点发送<code>REPLICAOF &lt;new_master_ip&gt; &lt;new_master_port&gt;</code>命令，让它们去复制新的Master。</li>
<li><strong>d. 监控新Master</strong>：Leader Sentinel会持续监控这个新提升的Master，直到它正常工作。</li>
<li><strong>e. 处理旧Master</strong>：如果旧的Master后来恢复了，Sentinel会向它发送<code>REPLICAOF</code>命令，使其成为新Master的一个Slave。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-3-Java客户端如何整合Sentinel"><a href="#2-3-Java客户端如何整合Sentinel" class="headerlink" title="2.3 Java客户端如何整合Sentinel"></a>2.3 Java客户端如何整合Sentinel</h3><p>在Sentinel模式下，Master的地址是会动态变化的。因此，客户端<strong>不能再直接硬编码Master的IP和端口</strong>。客户端需要连接到Sentinel集群，由Sentinel来告知当前Master的地址。</p>
<p><strong><code>spring-boot-starter-data-redis</code> (Lettuce) 整合Sentinel</strong>：</p>
<p>在<code>application.yml</code>中，不再配置<code>host</code>和<code>port</code>，而是配置<code>sentinel</code>相关信息。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment"># 不再配置host和port</span></span><br><span class="line">    <span class="comment"># host: 127.0.0.1</span></span><br><span class="line">    <span class="comment"># port: 6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">your_redis_password</span> <span class="comment"># Redis实例的密码</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">3000ms</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="comment"># Master的名称，这个名称是在sentinel.conf中配置的</span></span><br><span class="line">      <span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># Sentinel集群的节点地址列表，格式为 host:port</span></span><br><span class="line">      <span class="comment"># 客户端会连接这些Sentinel来获取Master信息</span></span><br><span class="line">      <span class="attr">nodes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span><span class="string">:26379</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.102</span><span class="string">:26379</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.103</span><span class="string">:26379</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment"># 如果Sentinel也设置了密码</span></span><br><span class="line">      <span class="comment"># password: your_sentinel_password</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>工作原理</strong>：</p>
<ol>
<li><strong>启动时</strong>：Spring Boot应用启动时，<code>RedisConnectionFactory</code>会连接到<code>spring.redis.sentinel.nodes</code>列表中的一个Sentinel节点。</li>
<li><strong>获取Master地址</strong>：它向Sentinel发送<code>SENTINEL get-master-addr-by-name &lt;master-name&gt;</code>命令，获取当前<code>mymaster</code>这个逻辑组的Master节点的实际IP和端口。</li>
<li><strong>建立连接</strong>：客户端使用获取到的地址，建立到Master的连接池。</li>
<li><strong>订阅事件</strong>：客户端会订阅Sentinel上关于Master切换的事件（如<code>+switch-master</code>）。</li>
<li><strong>故障转移时</strong>：当Sentinel完成故障转移后，会发布一个<code>+switch-master</code>事件，通知所有客户端新的Master地址。</li>
<li><strong>自动切换</strong>：客户端收到这个通知后，会自动断开与旧Master的连接，并使用新地址建立与新Master的连接池。整个过程对上层应用代码是<strong>完全透明的</strong>。</li>
</ol>
<blockquote>
<p><strong>总结</strong>：通过配置Sentinel，Java应用实现了对Redis故障的自动感知和无缝切换。开发者只需要像平常一样使用<code>RedisTemplate</code>，而底层的连接管理和故障转移全部由客户端库和Sentinel协作完成。</p>
</blockquote>
<hr>
<h2 id="3-Cluster-集群-模式"><a href="#3-Cluster-集群-模式" class="headerlink" title="3. Cluster (集群) 模式"></a>3. Cluster (集群) 模式</h2><p>当单个Redis实例的内存容量或并发处理能力达到上限时（即使使用了主从+哨兵），就需要将数据<strong>水平扩展（Scale Out）到多个节点上。Redis Cluster就是为此而生的官方分布式解决方案，它通过数据分片</strong>实现了性能和存储能力的线性扩展。</p>
<p>一个Redis集群通常由<strong>多个主节点（Master）构成，每个主节点可以有一个或多个从节点（Slave）</strong>，用于高可用。</p>
<h3 id="3-1-数据分片-Sharding-模型：哈希槽-Hash-Slot"><a href="#3-1-数据分片-Sharding-模型：哈希槽-Hash-Slot" class="headerlink" title="3.1 数据分片 (Sharding) 模型：哈希槽 (Hash Slot)"></a>3.1 数据分片 (Sharding) 模型：哈希槽 (Hash Slot)</h3><p>Redis Cluster并没有采用传统的一致性哈希算法，而是引入了一个更简单、更易于管理的概念——<strong>哈希槽 (Hash Slot)</strong>。</p>
<ul>
<li><strong>什么是哈希槽</strong>：<ul>
<li>整个Redis集群被虚拟地划分为 <strong>16384</strong> 个哈希槽（编号从 0 到 16383）。</li>
<li>每个主节点（Master）负责处理这些哈希槽的一个子集。例如，在一个3主节点的集群中：<ul>
<li>Node A 负责 0 - 5500</li>
<li>Node B 负责 5501 - 11000</li>
<li>Node C 负责 11001 - 16383</li>
</ul>
</li>
<li>这个槽位的分布信息，存储在<strong>每一个</strong>集群节点上。</li>
</ul>
</li>
<li><strong>Key如何映射到槽</strong>：<ol>
<li>当客户端要对一个Key（如 <code>user:1001</code>）进行操作时，集群会使用 <code>CRC16</code> 算法计算这个Key的哈希值。</li>
<li>然后，将这个哈希值对 16384 取模，得到一个 0 到 16383 之间的槽位编号。<br><code>slot = CRC16(key) % 16384</code></li>
<li>集群根据这个槽位编号，就能确定应该由哪个主节点来处理这个Key。</li>
</ol>
</li>
<li><strong>Hash Tags</strong>：<ul>
<li>默认情况下，像 <code>user:1001:name</code> 和 <code>user:1001:age</code> 这样的Key，会被哈希到不同的槽位，从而分布在不同节点上。</li>
<li>这会导致一些需要操作多个Key的命令（如<code>MGET</code>, <code>MSET</code>, 事务, Lua脚本）无法执行，因为它们要求所有操作的Key必须在同一个节点上。</li>
<li>为了解决这个问题，Redis引入了<code>Hash Tags</code>。如果一个Key中包含<code>{...}</code>，那么只有<code>{}</code>中的部分会被用来计算哈希槽。</li>
<li><strong>示例</strong>：<code>{user:1001}:name</code> 和 <code>{user:1001}:age</code>，因为它们<code>{}</code>中的内容相同，所以一定会被分配到同一个哈希槽，也就在同一个节点上。这使得对它们进行批量操作成为可能。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-2-Gossip协议与节点通信"><a href="#3-2-Gossip协议与节点通信" class="headerlink" title="3.2 Gossip协议与节点通信"></a>3.2 Gossip协议与节点通信</h3><p>Redis集群中的各个节点是如何知道彼此的存在、健康状况以及槽位分布信息的呢？答案是<strong>Gossip协议</strong>。</p>
<ul>
<li><strong>Gossip协议</strong>：<ul>
<li>这是一种去中心化的、最终一致性的信息传播协议。每个节点都会定期地、随机地向其他几个节点发送消息，交换彼此所知的集群状态信息。</li>
<li>通过这种“闲聊”式的信息交换，最终整个集群的所有节点都会拥有相同的、完整的集群状态视图。</li>
</ul>
</li>
<li><strong>节点间的通信</strong>：<ul>
<li>每个节点都维护着一个TCP长连接，用于正常的命令请求和响应。</li>
<li>此外，每个节点还会额外开放一个端口（通常是<code>客户端端口 + 10000</code>，如6379 -&gt; 16379），这个端口专门用于节点间的Gossip通信，被称为<strong>集群总线（Cluster Bus）</strong>。</li>
<li>节点通过集群总线交换的信息包括：节点ID、IP和端口、健康状态（是否宕机）、负责的哈希槽等。</li>
</ul>
</li>
<li><strong>故障检测</strong>：<ul>
<li>与Sentinel类似，集群内部也有一套故障检测机制。当一个节点发现另一个节点长时间没有响应<code>PING</code>时，会将其标记为<code>PFAIL</code>（Possible Fail，可能下线）。</li>
<li>然后，它会通过Gossip协议将这个信息广播出去，询问其他节点的看法。</li>
<li>当集群中超过半数的主节点都认为某节点<code>PFAIL</code>时，该节点就会被标记为<code>FAIL</code>（确定下线），并触发故障转移流程。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-3-redis-cli-创建和管理集群"><a href="#3-3-redis-cli-创建和管理集群" class="headerlink" title="3.3 redis-cli 创建和管理集群"></a>3.3 <code>redis-cli</code> 创建和管理集群</h3><p>Redis 5.0 之后，<code>redis-cli</code>提供了非常便捷的集群管理工具。</p>
<p><strong>创建集群示例（3主3从）</strong>：</p>
<ol>
<li><p><strong>准备配置文件和实例</strong>：</p>
<ul>
<li><p>创建6个不同的<code>redis.conf</code>文件（如7000.conf, 7001.conf … 7005.conf）。</p>
</li>
<li><p>每个配置文件中必须开启集群模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-7000.conf # 自动生成的集群状态文件</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>分别启动这6个Redis实例。</p>
</li>
</ul>
</li>
<li><p><strong>使用<code>redis-cli</code>创建集群</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --cluster-replicas 1 表示为每个主节点创建一个从节点</span></span><br><span class="line">redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 \</span><br><span class="line">                         127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \</span><br><span class="line">                         --cluster-replicas 1</span><br></pre></td></tr></table></figure>

<p><code>redis-cli</code>会自动规划主从关系，分配哈希槽，然后将配置应用到所有节点。</p>
</li>
</ol>
<p><strong>常用管理命令</strong>：</p>
<ul>
<li><code>redis-cli --cluster check &lt;any_node_ip&gt;:&lt;port&gt;</code>: 检查集群状态。</li>
<li><code>redis-cli --cluster info &lt;any_node_ip&gt;:&lt;port&gt;</code>: 查看集群信息。</li>
<li><code>redis-cli --cluster reshard &lt;any_node_ip&gt;:&lt;port&gt;</code>: <strong>在线</strong>重新分配哈希槽（扩容或缩容时使用）。</li>
<li><code>redis-cli --cluster add-node &lt;new_node_ip&gt;:&lt;port&gt; &lt;existing_node_ip&gt;:&lt;port&gt;</code>: 添加新节点。</li>
<li><code>redis-cli --cluster del-node &lt;any_node_ip&gt;:&lt;port&gt; &lt;node_id_to_delete&gt;</code>: 删除节点。</li>
</ul>
<hr>
<h3 id="3-4-Cluster模式下的限制"><a href="#3-4-Cluster模式下的限制" class="headerlink" title="3.4 Cluster模式下的限制"></a>3.4 Cluster模式下的限制</h3><ol>
<li><strong>多键操作的限制</strong>：<ul>
<li><strong>核心限制</strong>：所有参与多键操作的Key（如<code>MGET</code>, <code>MSET</code>, <code>DEL</code>多个key, 事务, Lua脚本）<strong>必须位于同一个哈希槽</strong>。</li>
<li><strong>原因</strong>：这些命令不是分布式的。Redis服务器在执行命令时，不会跨节点去聚合数据。</li>
<li><strong>解决方案</strong>：使用<strong>Hash Tags</strong>来强制将相关的Key分配到同一个槽。</li>
</ul>
</li>
<li><strong>数据库选择</strong>：<ul>
<li>集群模式下<strong>只支持使用数据库0 (<code>db 0</code>)</strong>。不支持<code>SELECT</code>命令。</li>
</ul>
</li>
<li><strong>客户端重定向 (Redirection)</strong>：<ul>
<li>如果客户端连接到了一个错误的节点（即Key所在的槽不由该节点负责），服务器不会代理请求，而是会返回一个<code>MOVED</code>或<code>ASK</code>重定向错误。<ul>
<li><code>MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</code>: 表示这个槽<strong>永久地</strong>移动到了新的节点。智能客户端会更新本地的槽位映射表，并用新地址重试命令。</li>
<li><code>ASK &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</code>: 表示这个槽<strong>临时地</strong>需要到指定节点去查询（通常发生在槽位迁移过程中）。客户端下次对该Key的请求仍然会先发往旧节点。</li>
</ul>
</li>
<li>这意味着，客户端必须是“集群感知”的，能够处理这些重定向。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-5-Java客户端如何整合Cluster"><a href="#3-5-Java客户端如何整合Cluster" class="headerlink" title="3.5 Java客户端如何整合Cluster"></a>3.5 Java客户端如何整合Cluster</h3><p>与Sentinel类似，客户端需要配置集群的节点信息，由客户端库来处理槽位计算和重定向。</p>
<p><strong><code>spring-boot-starter-data-redis</code> (Lettuce) 整合Cluster</strong>：</p>
<p>在<code>application.yml</code>中，配置<code>cluster</code>节点列表。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment"># 不再配置host/port/sentinel</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">your_redis_password</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">3000ms</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">cluster:</span></span><br><span class="line">      <span class="comment"># 集群节点列表，不需要全部列出，客户端会自动发现其他节点</span></span><br><span class="line">      <span class="comment"># 建议至少提供2-3个节点，以防单点故障</span></span><br><span class="line">      <span class="attr">nodes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.10</span><span class="string">:7000</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.10</span><span class="string">:7001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span><span class="string">:7002</span></span><br><span class="line">      <span class="comment"># 当集群进行重定向时，客户端可以跟随的最大重定向次数</span></span><br><span class="line">      <span class="attr">max-redirects:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>工作原理</strong>：</p>
<ol>
<li><strong>启动时</strong>：应用启动时，客户端会连接到<code>nodes</code>列表中的一个节点。</li>
<li><strong>获取槽位映射</strong>：客户端向该节点发送<code>CLUSTER SLOTS</code>命令，获取整个集群的槽位分布信息，并在内存中构建一个“槽位 -&gt; 节点”的映射表。</li>
<li><strong>命令执行</strong>：<ul>
<li>当应用执行一个Redis命令时（如<code>redisTemplate.opsForValue().set(&quot;mykey&quot;, &quot;value&quot;)</code>），客户端会先在<strong>本地</strong>计算<code>mykey</code>的哈希槽。</li>
<li>根据内存中的映射表，找到负责该槽的节点。</li>
<li>直接向正确的节点发送命令。</li>
</ul>
</li>
<li><strong>处理重定向</strong>：<ul>
<li>如果因为集群状态变更（如槽位迁移），客户端的映射表过时了，它可能会收到<code>MOVED</code>或<code>ASK</code>响应。</li>
<li>收到<code>MOVED</code>后，客户端会立即更新本地的槽位映射表，并向新地址重发命令。</li>
<li>这个过程对上层应用代码是<strong>完全透明的</strong>。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>总结</strong>：Redis Cluster通过哈希槽实现了数据的分布式存储和负载均衡。客户端通过维护一份槽位映射表来智能地路由请求，并能自动处理集群的重定向，从而实现了对分布式Redis的无缝访问。这是构建大规模、高并发Redis服务的终极解决方案。</p>
</blockquote>
<hr>
<h1 id="八、企业级开发设计模式"><a href="#八、企业级开发设计模式" class="headerlink" title="八、企业级开发设计模式"></a>八、企业级开发设计模式</h1><h2 id="1-缓存设计"><a href="#1-缓存设计" class="headerlink" title="1. 缓存设计"></a>1. 缓存设计</h2><p>在大多数系统中，引入缓存（如Redis）是为了<strong>提升读性能</strong>和<strong>保护后端数据库</strong>。如何设计缓存的读写逻辑以及如何应对极端情况尤为重要。</p>
<h3 id="1-1-缓存更新策略"><a href="#1-1-缓存更新策略" class="headerlink" title="1.1 缓存更新策略"></a>1.1 缓存更新策略</h3><p>缓存更新策略定义了数据如何在缓存和数据库之间保持同步。</p>
<h4 id="1-1-1-Cache-Aside-旁路缓存模式-——-最常用"><a href="#1-1-1-Cache-Aside-旁路缓存模式-——-最常用" class="headerlink" title="1.1.1 Cache-Aside (旁路缓存模式) —— 最常用"></a>1.1.1 Cache-Aside (旁路缓存模式) —— 最常用</h4><ul>
<li><strong>这是在实际开发中应用最广泛的模式</strong>。它的核心思想是，应用程序<strong>自己</strong>来维护缓存和数据库的读写。</li>
<li><strong>读操作流程 (Read)</strong>:<ol>
<li>应用先从<strong>缓存</strong>中读取数据。</li>
<li>如果缓存<strong>命中 (Hit)</strong>，则直接返回数据。</li>
<li>如果缓存<strong>未命中 (Miss)</strong>：<br>a. 应用从<strong>数据库</strong>中读取数据。<br>b. 将从数据库中读到的数据<strong>写入缓存</strong>。<br>c. 返回数据。</li>
</ol>
</li>
<li><strong>写操作流程 (Write)</strong>:<ul>
<li><strong>更新操作</strong>: <strong>先更新数据库，再删除缓存</strong>。</li>
<li><strong>为什么是删除缓存，而不是更新缓存？</strong><ul>
<li><strong>懒加载 (Lazy Loading)</strong>：删除缓存后，下次读取时会自然地从数据库加载最新数据到缓存中。如果业务场景是写多读少，更新缓存的开销可能是不必要的。</li>
<li><strong>保证数据一致性</strong>：考虑两个并发的写操作，A和B。如果A先更新了缓存，B后更新了缓存，但A后更新了数据库，B先更新了数据库，就会导致缓存是B的值，而数据库是A的值，产生不一致。而“删除缓存”能有效降低这种不一致的概率。</li>
</ul>
</li>
<li><strong>先更新数据库，还是先删除缓存？</strong><ul>
<li><strong>结论</strong>：<strong>先更新数据库，再删除缓存</strong>。</li>
<li><strong>原因（对比）</strong>：<ul>
<li><strong>先删缓存，再更新数据库</strong>：在并发下，请求A删除缓存后，还没来得及更新数据库，请求B过来读，发现缓存没有，就去读数据库的<strong>旧值</strong>并写入缓存。之后请求A才完成数据库更新。这导致缓存中存储的是<strong>脏数据</strong>。</li>
<li><strong>先更新数据库，再删缓存</strong>：在并发下，请求A更新完数据库后，还没来得-及删除缓存，请求B过来读，读到的是缓存中的<strong>旧值</strong>。虽然有短暂的不一致，但当请求A完成缓存删除后，下一次读请求就会从数据库加载新值，缓存最终会恢复一致。这种短暂的不一致在大多数业务场景下是可以接受的。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-2-Read-Write-Through-读-写穿透模式"><a href="#1-1-2-Read-Write-Through-读-写穿透模式" class="headerlink" title="1.1.2 Read&#x2F;Write Through (读&#x2F;写穿透模式)"></a>1.1.2 Read&#x2F;Write Through (读&#x2F;写穿透模式)</h4><ul>
<li><strong>核心思想</strong>：应用程序<strong>只与缓存交互</strong>，由<strong>缓存服务自己</strong>来负责与数据库的同步。应用程序感觉不到后端数据库的存在。</li>
<li><strong>读操作 (Read-Through)</strong>：应用向缓存请求数据，如果缓存没有，由<strong>缓存服务</strong>负责从数据库加载，并返回给应用。</li>
<li><strong>写操作 (Write-Through)</strong>：应用将数据写入缓存，由<strong>缓存服务</strong>负责将数据同步写入数据库。</li>
<li><strong>优点</strong>：应用逻辑简单，数据一致性高（缓存和数据库同步更新）。</li>
<li><strong>缺点</strong>：需要缓存服务本身提供这种能力（如某些商业缓存产品），Redis本身不直接支持。实现复杂，且写操作性能较低（因为要等待缓存和数据库都写完）。</li>
</ul>
<hr>
<h4 id="1-1-3-Write-Back-回写-写后模式"><a href="#1-1-3-Write-Back-回写-写后模式" class="headerlink" title="1.1.3 Write-Back (回写&#x2F;写后模式)"></a>1.1.3 Write-Back (回写&#x2F;写后模式)</h4><ul>
<li><strong>核心思想</strong>：所有写操作都<strong>只写入缓存</strong>，并立即返回。缓存服务会<strong>异步地、批量地</strong>将更新后的数据刷回（flush）数据库。</li>
<li><strong>优点</strong>：<strong>写性能极高</strong>，因为无需等待慢速的数据库I&#x2F;O。</li>
<li><strong>缺点</strong>：<strong>数据一致性差</strong>。如果缓存服务在数据刷回数据库前宕机，这部分数据将<strong>永久丢失</strong>。</li>
<li><strong>应用场景</strong>：对写性能要求极高，但对数据一致性和可靠性要求不高的场景，如日志记录、统计数据上报等。</li>
</ul>
<hr>
<h3 id="1-2-缓存三大问题与解决方案"><a href="#1-2-缓存三大问题与解决方案" class="headerlink" title="1.2 缓存三大问题与解决方案"></a>1.2 缓存三大问题与解决方案</h3><h4 id="1-2-1-缓存穿透-Cache-Penetration"><a href="#1-2-1-缓存穿透-Cache-Penetration" class="headerlink" title="1.2.1 缓存穿透 (Cache Penetration)"></a>1.2.1 缓存穿透 (Cache Penetration)</h4><ul>
<li><strong>现象</strong>：<br>查询一个<strong>数据库和缓存中都绝对不存在</strong>的数据。<ul>
<li>流程：请求 -&gt; 查缓存（未命中）-&gt; 查数据库（也未命中）-&gt; 返回空。</li>
<li><strong>危害</strong>：如果大量请求都查询这种不存在的数据（例如，恶意攻击者用大量不存在的用户ID来请求用户信息），这些请求会全部穿透缓存，直接打到数据库上，可能导致数据库崩溃。</li>
</ul>
</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>a. 缓存空对象 (Cache Nulls)</strong><ul>
<li><strong>做法</strong>：当从数据库查询一个数据为空时，<strong>仍然将这个“空结果”缓存起来</strong>，但为其设置一个较短的过期时间（如几十秒或几分钟）。</li>
<li><strong>优点</strong>：实现简单，效果好。</li>
<li><strong>缺点</strong>：会占用一定的缓存空间；可能存在短暂的数据不一致（在空对象过期时间内，数据库中恰好插入了新数据）。</li>
</ul>
</li>
<li><strong>b. 布隆过滤器 (Bloom Filter)</strong><ul>
<li><strong>做法</strong>：在访问缓存之前，使用布隆过滤器先进行一次快速判断。布隆过滤器是一种高效的、概率性的数据结构，它可以<strong>明确地告诉你“一个元素一定不存在”</strong>。</li>
<li><strong>流程</strong>：<ol>
<li>将数据库中所有可能存在的数据（如所有商品ID）都提前加载到布隆过滤器中。</li>
<li>当一个请求来时，先去布隆过滤器查询。</li>
<li>如果布隆过滤器说“不存在”，则直接返回空，<strong>根本不会去查缓存和数据库</strong>。</li>
<li>如果布隆过滤器说“可能存在”（因为它有误判率），则继续走后续的缓存和数据库查询流程。</li>
</ol>
</li>
<li><strong>优点</strong>：在第一层就拦截了大量无效请求，效率极高。</li>
<li><strong>缺点</strong>：存在误判率（会把不存在的误判为存在，但绝不会把存在的误判为不存在）；实现相对复杂。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-2-缓存击穿-Cache-Breakdown"><a href="#1-2-2-缓存击穿-Cache-Breakdown" class="headerlink" title="1.2.2 缓存击穿 (Cache Breakdown)"></a>1.2.2 缓存击穿 (Cache Breakdown)</h4><ul>
<li><strong>现象</strong>：<br>一个<strong>热点Key (Hot Key)</strong>，在它<strong>失效的瞬间</strong>，恰好有大量的并发请求同时涌入。<ul>
<li>流程：这些并发请求 -&gt; 查缓存（都未命中）-&gt; <strong>同时涌向数据库</strong>去加载数据 -&gt; <strong>同时回写缓存</strong>。</li>
<li><strong>危害</strong>：瞬时的大量数据库请求可能压垮数据库。这就像在一个点上把缓存层“击穿”了。</li>
</ul>
</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>a. 互斥锁 &#x2F; 分布式锁</strong><ul>
<li><strong>做法</strong>：当缓存未命中时，不是所有线程都去查数据库。而是让第一个去查数据库的线程<strong>获取一个锁</strong>（如基于Redis的<code>SETNX</code>实现的分布式锁）。</li>
<li><strong>流程</strong>：<ol>
<li>其他线程在发现缓存未命中后，也去尝试获取锁。</li>
<li>获取锁失败的线程，则<strong>休眠一小段时间后重试</strong>（再次查询缓存，而不是直接查数据库）。</li>
<li>获取锁成功的线程，去数据库查询数据，然后将数据写入缓存，最后<strong>释放锁</strong>。</li>
<li>其他线程在重试时，就能从缓存中读到数据了。</li>
</ol>
</li>
<li><strong>优点</strong>：只允许一个线程去重建缓存，有效保护了数据库。</li>
<li><strong>缺点</strong>：实现复杂，引入了锁增加了系统开销，可能会降低一些吞吐量。</li>
</ul>
</li>
<li><strong>b. 热点数据永不过期</strong><ul>
<li><strong>做法</strong>：对于极度热点的Key，可以考虑不设置过期时间，或者在一个后台线程中<strong>异步地</strong>为其续期或更新。</li>
<li><strong>优点</strong>：从逻辑上根除了缓存失效的问题。</li>
<li><strong>缺点</strong>：需要额外维护，且要处理数据更新的问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-3-缓存雪崩-Cache-Avalanche"><a href="#1-2-3-缓存雪崩-Cache-Avalanche" class="headerlink" title="1.2.3 缓存雪崩 (Cache Avalanche)"></a>1.2.3 缓存雪崩 (Cache Avalanche)</h4><ul>
<li><strong>现象</strong>：<br><strong>大量的Key在同一时刻集体失效</strong>，或者<strong>Redis服务自身宕机</strong>。<ul>
<li><strong>集体失效</strong>：例如，在系统启动时，你为一批缓存设置了相同的过期时间（如1小时）。1小时后，这些缓存同时失效，导致大量请求直接打向数据库。</li>
<li><strong>Redis宕机</strong>：所有请求都无法访问缓存，全部涌向数据库。</li>
<li><strong>危害</strong>：数据库在短时间内承受巨大压力，可能导致崩溃，从而引发整个系统的连锁反应，即“雪崩”。</li>
</ul>
</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>a. 针对“集体失效”：过期时间加随机值</strong><ul>
<li><strong>做法</strong>：在设置缓存的过期时间时，不要使用固定的值，而是在基础时间上<strong>增加一个小的随机数</strong>。</li>
<li><strong>示例</strong>：<code>expire_time = base_time + random(0, 300)</code>，让过期时间分布在1小时到1小时5分钟之间。</li>
<li><strong>优点</strong>：实现简单，有效避免了Key在同一时刻集体失效。</li>
</ul>
</li>
<li><strong>b. 针对“Redis宕机”：构建高可用集群</strong><ul>
<li><strong>做法</strong>：使用Redis主从+哨兵，或Redis Cluster来保证缓存服务的高可用。当一个节点宕机后，能自动切换，保证服务不中断。</li>
</ul>
</li>
<li><strong>c. 通用方案：多级缓存</strong><ul>
<li><strong>做法</strong>：引入多级缓存体系，如 <code>Nginx缓存/本地缓存(Caffeine/Guava Cache) + Redis缓存</code>。即使Redis层挂了，本地缓存还能顶住一部分流量。</li>
</ul>
</li>
<li><strong>d. 通用方案：限流与降级</strong><ul>
<li><strong>做法</strong>：这是最后的保险丝。在缓存层和数据库层之间加入<strong>限流组件</strong>（如<code>Sentinel</code>、<code>Hystrix</code>）。当检测到访问数据库的请求量激增时，进行限流，只放行少量请求去访问数据库，对于其他请求则直接返回一个友好的错误提示或一个兜底的默认值（降级）。</li>
<li><strong>优点</strong>：保证在最坏的情况下，数据库不被压垮，核心服务得以幸存。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-分布式锁"><a href="#2-分布式锁" class="headerlink" title="2. 分布式锁"></a>2. 分布式锁</h2><p>在分布式系统中，多个服务实例（或多个线程）需要同时访问同一个共享资源时，为了防止并发导致的数据错乱，就需要一种跨JVM的互斥机制。分布式锁就是为了解决这个问题而生的。Redis因其高性能和原子操作，成为实现分布式锁最常用的工具之一。</p>
<h3 id="2-1-SETNX实现的-Naive-锁及其问题"><a href="#2-1-SETNX实现的-Naive-锁及其问题" class="headerlink" title="2.1 SETNX实现的 Naive 锁及其问题"></a>2.1 <code>SETNX</code>实现的 Naive 锁及其问题</h3><p>最早期、最朴素的分布式锁实现方式是利用<code>SETNX</code>（<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists）命令。</p>
<ul>
<li><p><strong>加锁逻辑</strong>:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX lock_key 1</span><br></pre></td></tr></table></figure>

<p><code>SETNX</code>是原子操作。如果<code>lock_key</code>不存在，则设置成功，返回1，表示获取锁成功。如果已存在，则设置失败，返回0，表示获取锁失败。</p>
</li>
<li><p><strong>解锁逻辑</strong>:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL lock_key</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>问题：死锁 (Deadlock)</strong><br>这是一个<strong>致命问题</strong>。考虑以下场景：</p>
<ol>
<li>客户端A执行<code>SETNX</code>成功获取了锁。</li>
<li>客户端A在执行业务逻辑时，<strong>发生了崩溃或宕机</strong>，没来得及执行<code>DEL lock_key</code>。</li>
<li><strong>结果</strong>：这个锁将<strong>永远不会被释放</strong>，其他所有需要获取该锁的客户端都将被永久阻塞，造成死锁。</li>
</ol>
</li>
<li><p><strong>改进：加锁后设置过期时间</strong><br>为了解决死锁问题，一个自然的想法是为锁设置一个过期时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (jedis.setnx(<span class="string">&quot;lock_key&quot;</span>, <span class="string">&quot;1&quot;</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 加锁和设置过期时间，非原子操作</span></span><br><span class="line">    jedis.expire(<span class="string">&quot;lock_key&quot;</span>, <span class="number">30</span>); </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ... 业务逻辑 ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        jedis.del(<span class="string">&quot;lock_key&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>新问题：非原子性</strong><br><code>SETNX</code>和<code>EXPIRE</code>是<strong>两个独立的命令</strong>。如果在<code>SETNX</code>执行成功后，客户端在执行<code>EXPIRE</code>之前崩溃了，<strong>死锁问题依然存在</strong>。</p>
</li>
</ul>
<hr>
<h3 id="2-2-SET-key-value-NX-PX-timeout-原子命令实现"><a href="#2-2-SET-key-value-NX-PX-timeout-原子命令实现" class="headerlink" title="2.2 SET key value NX PX timeout 原子命令实现"></a>2.2 <code>SET key value NX PX timeout</code> 原子命令实现</h3><p>为了解决<code>SETNX</code>+<code>EXPIRE</code>的非原子性问题，Redis 2.6.12版本之后，对<code>SET</code>命令进行了扩展，提供了一个原子性的加锁+设置过期时间的选项。</p>
<ul>
<li><p><strong>原子加锁命令</strong>:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock_key random_value NX PX 30000</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lock_key</code>: 锁的名称。</li>
<li><code>random_value</code>: 一个随机的、唯一的字符串，用于标识锁的持有者。</li>
<li><code>NX</code>: 等同于<code>SETNX</code>，只有当key不存在时才设置。</li>
<li><code>PX 30000</code>: 设置锁的过期时间为30000毫秒（30秒）。<code>EX</code>表示秒。</li>
</ul>
</li>
<li><p><strong>优点</strong>：这个命令将“加锁”和“设置过期时间”这两个操作<strong>合并成了一个原子操作</strong>，彻底解决了因中途崩溃导致的死锁问题。这是目前实现分布式锁的<strong>标准加锁方式</strong>。</p>
</li>
</ul>
<hr>
<h3 id="2-3-锁的-Owner-标识与-LUA-脚本安全释放"><a href="#2-3-锁的-Owner-标识与-LUA-脚本安全释放" class="headerlink" title="2.3 锁的 Owner 标识与 LUA 脚本安全释放"></a>2.3 锁的 Owner 标识与 LUA 脚本安全释放</h3><p>虽然加锁问题解决了，但解锁操作<code>DEL lock_key</code>依然存在风险。</p>
<ul>
<li><p><strong>解锁的问题：误删他人锁</strong></p>
<ol>
<li>客户端A获取了锁，过期时间为30秒。</li>
<li>客户端A因为某些原因（如GC、网络延迟）执行业务逻辑超过了30秒，<strong>锁被Redis自动释放</strong>。</li>
<li>客户端B此时发现锁已释放，立即执行<code>SET ... NX PX ...</code>成功获取了锁。</li>
<li>客户端A此时终于执行完业务，然后执行<code>DEL lock_key</code>。</li>
<li><strong>结果</strong>：客户端A<strong>删除了客户端B持有的锁</strong>，导致并发安全问题。</li>
</ol>
</li>
<li><p><strong>解决方案：锁的 Owner 标识</strong><br>在加锁时，<code>value</code>不再是简单的”1”，而是一个<strong>唯一的客户端标识</strong>（如UUID、线程ID等）。在解锁时，必须先<code>GET</code>锁的值，判断是否与自己的标识匹配，如果匹配，才能<code>DEL</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">myId</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="keyword">if</span> (myId.equals(jedis.get(<span class="string">&quot;lock_key&quot;</span>))) &#123;</span><br><span class="line">    jedis.del(<span class="string">&quot;lock_key&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>新问题：解锁的非原子性</strong><br>“判断”和“删除”是两个操作，非原子。在并发下，可能在<code>GET</code>和<code>DEL</code>之间，锁恰好过期并被其他客户端获取，导致<code>GET</code>时是自己的锁，<code>DEL</code>时却删了别人的锁。</p>
</li>
<li><p><strong>终极解决方案：使用Lua脚本安全释放</strong><br>为了保证“判断”和“删除”的原子性，必须使用Lua脚本。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- unlock.lua</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>KEYS[1]</code>: 锁的key。</li>
<li><code>ARGV[1]</code>: 加锁时设置的唯一客户端标识。</li>
<li><strong>原子性保证</strong>：Redis保证整个Lua脚本的执行是原子的。脚本会先检查锁的持有者是否是自己，如果是，才执行删除。这两个步骤作为一个整体完成，杜绝了误删的可能。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>阶段性总结</strong>：一个可靠的Redis分布式锁 &#x3D; <code>SET ... NX PX ...</code> (原子加锁) + <code>Lua脚本</code> (原子解锁)。</p>
</blockquote>
<hr>
<h3 id="2-4-Redisson-RLock-的可重入锁与看门狗-Watchdog-机制原理"><a href="#2-4-Redisson-RLock-的可重入锁与看门狗-Watchdog-机制原理" class="headerlink" title="2.4 Redisson RLock 的可重入锁与看门狗 (Watchdog) 机制原理"></a>2.4 Redisson <code>RLock</code> 的可重入锁与看门狗 (Watchdog) 机制原理</h3><p>虽然我们知道了如何实现一个可靠的分布式锁，但自己封装仍然繁琐且易出错。<code>Redisson</code>对这一切做了完美的封装，并提供了更多高级功能。</p>
<ul>
<li><strong>可重入性 (Reentrancy)</strong><ul>
<li><strong>问题</strong>：同一个线程如果已经持有了锁，当它在方法内部再次尝试获取同一个锁时，如果锁是不可重入的，就会造成死锁（自己锁死自己）。</li>
<li><strong>Redisson实现</strong>：Redisson使用<code>Hash</code>结构来存储锁。<ul>
<li><code>Key</code>: 锁的名称。</li>
<li><code>Field</code>: 客户端的唯一ID（<code>UUID:threadId</code>）。</li>
<li><code>Value</code>: 一个计数器，表示该线程重入的次数。</li>
</ul>
</li>
<li><strong>加锁流程 (<code>RLock.lock()</code>)</strong>：<ol>
<li>尝试<code>HSET</code>加锁。</li>
<li>如果成功，则加锁成功，计数器为1。</li>
<li>如果失败（锁已被持有），则检查<code>Field</code>是否是自己的ID。</li>
<li>如果是自己的ID，则执行<code>HINCRBY</code>将计数器加1，实现<strong>可重入</strong>。</li>
<li>如果不是自己的ID，则订阅一个channel，<strong>阻塞等待</strong>锁释放的通知。</li>
</ol>
</li>
</ul>
</li>
<li><strong>看门狗 (Watchdog) 机制</strong><ul>
<li><strong>问题</strong>：锁的过期时间应该设置多久？太短，业务可能没执行完锁就过期了；太长，如果客户端宕机，锁要等很久才释放。</li>
<li><strong>Redisson解决方案</strong>：看门狗是一个<strong>后台线程</strong>。<ol>
<li>当一个线程成功获取锁后，如果<strong>没有明确指定锁的过期时间</strong>（即调用<code>lock()</code>而不是<code>lock(leaseTime, unit)</code>），Redisson会默认设置一个30秒的过期时间，并启动看门狗。</li>
<li>看门狗会<strong>每隔10秒</strong>（<code>lockWatchdogTimeout / 3</code>）检查一下持有锁的客户端是否还存活。</li>
<li>如果客户端还活着，看门狗就会<strong>自动将锁的过期时间重置为30秒</strong>（“续命”）。</li>
<li>当客户端执行完业务并释放锁时，看门狗任务会被取消。</li>
</ol>
</li>
<li><strong>优点</strong>：只要客户端不宕机，锁就永远不会因为超时而自动释放，有效避免了业务未执行完锁就过期的问题。如果客户端宕机，锁最多在30秒后也会被自动释放。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-5-RedLock算法思想"><a href="#2-5-RedLock算法思想" class="headerlink" title="2.5 RedLock算法思想"></a>2.5 RedLock算法思想</h3><p><code>RedLock</code>是由Redis的作者antirez提出的，用于解决<strong>Redis单点故障</strong>问题的<strong>多实例分布式锁算法</strong>。</p>
<ul>
<li><strong>问题背景</strong>：<ul>
<li>我们前面讨论的锁都是基于单个Redis实例（或主从&#x2F;哨兵模式）。</li>
<li>在主从模式下，如果Master节点在持有锁后，数据还没来得及同步到Slave就宕机了。此时Sentinel将Slave提升为新Master，但新Master上并没有这个锁。其他客户端就可以在新Master上获取到同一个锁，导致两个客户端同时持有锁，破坏了互斥性。</li>
</ul>
</li>
<li><strong>RedLock算法思想</strong>：<ol>
<li>假设有N个<strong>完全独立</strong>的Redis Master节点（例如，5个）。</li>
<li><strong>获取锁</strong>：<br>a. 客户端记录当前时间戳。<br>b. 客户端<strong>依次</strong>尝试从这N个节点获取锁（使用相同的key和唯一value），并且为每个节点的请求设置一个很短的超时时间（如几十毫秒），远小于锁的有效时间。<br>c. 客户端计算获取锁所花费的时间，并检查是否从**大多数（N&#x2F;2 + 1）*<em>的节点上成功获取了锁。<br>d. 如果同时满足“获取了多数锁”和“花费时间小于锁的有效时间”，则认为*<em>获取锁成功</em></em>。</li>
<li><strong>释放锁</strong>：客户端向<strong>所有</strong>N个Redis节点发送解锁命令（Lua脚本），无论当初是否从该节点获取过锁。</li>
</ol>
</li>
<li><strong>争议与结论</strong>：<ul>
<li>RedLock在理论上比单实例锁更安全，因为它避免了单点故障。</li>
<li>但它也受到了很多分布式系统专家的批评，认为其假设过于理想（如节点时钟同步），实现复杂，且在某些网络分区场景下依然可能失效。</li>
<li><strong>在绝大多数业务场景下，使用基于哨兵或集群模式的Redisson分布式锁已经足够健壮和可靠。</strong> RedLock更像是一个理论探讨，实际生产中很少使用。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-其他设计模式"><a href="#3-其他设计模式" class="headerlink" title="3. 其他设计模式"></a>3. 其他设计模式</h2><h3 id="3-1-限流器-Rate-Limiter"><a href="#3-1-限流器-Rate-Limiter" class="headerlink" title="3.1 限流器 (Rate Limiter)"></a>3.1 限流器 (Rate Limiter)</h3><p>限流器是保护服务不被过多请求冲垮的关键组件，常用于API接口访问频率控制、防止恶意攻击等场景。</p>
<h4 id="3-1-1-简单计数器限流-INCR-EXPIRE"><a href="#3-1-1-简单计数器限流-INCR-EXPIRE" class="headerlink" title="3.1.1 简单计数器限流 (INCR + EXPIRE)"></a>3.1.1 简单计数器限流 (<code>INCR</code> + <code>EXPIRE</code>)</h4><ul>
<li><p><strong>思想</strong>：在<strong>固定的时间窗口</strong>内，限制请求的总数。</p>
</li>
<li><p><strong>实现</strong>：</p>
<ol>
<li>当一个请求到来时，使用<code>INCR</code>命令对一个代表当前时间窗口的Key（如<code>rate_limit:&lt;api&gt;:&lt;user_id&gt;:&lt;timestamp&gt;</code>）进行自增。</li>
<li>如果这是该时间窗口内的第一个请求（<code>INCR</code>返回1），则为这个Key设置一个等于时间窗口长度的过期时间（<code>EXPIRE</code>）。</li>
<li>判断<code>INCR</code>返回的计数值是否超过了设定的阈值。如果超过，则拒绝该请求；否则，允许请求。</li>
</ol>
</li>
<li><p><strong>Lua脚本实现（保证原子性）</strong>:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 脚本: rate_limit.lua</span></span><br><span class="line"><span class="comment">-- KEYS[1]: a unique key for the time window, e.g., &quot;rate_limit:api:/users:127.0.0.1&quot;</span></span><br><span class="line"><span class="comment">-- ARGV[1]: the limit threshold (e.g., 100)</span></span><br><span class="line"><span class="comment">-- ARGV[2]: the window size in seconds (e.g., 60)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> current = redis.call(<span class="string">&#x27;incr&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">tonumber</span>(current) == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- First request in this window, set the expiration time</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">tonumber</span>(current) &gt; <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- Limit exceeded</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- Limit not exceeded</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点</strong>：实现简单，性能高。</p>
</li>
<li><p><strong>缺点</strong>：存在<strong>临界突刺问题</strong>。例如，限流规则是“每分钟不超过100次”。攻击者可以在第59秒发送100个请求，然后在第1分01秒再发送100个请求。在中间这2秒内，系统实际承受了200个请求，可能会超出系统的处理能力。</p>
</li>
</ul>
<hr>
<h4 id="3-1-2-滑动窗口限流-ZSet实现"><a href="#3-1-2-滑动窗口限流-ZSet实现" class="headerlink" title="3.1.2 滑动窗口限流 (ZSet实现)"></a>3.1.2 滑动窗口限流 (ZSet实现)</h4><ul>
<li><p><strong>思想</strong>：为了解决简单计数器的临界突刺问题，滑动窗口限流维持了一个<strong>动态变化的时间窗口</strong>。它只计算“从现在开始，往前推一个时间窗口”内的请求总数。</p>
</li>
<li><p><strong>实现 (使用<code>ZSet</code>)</strong>:</p>
<ol>
<li><code>ZSet</code>的Key代表要限流的资源（如<code>rate_limit_zset:&lt;api&gt;:&lt;user_id&gt;</code>）。</li>
<li><code>ZSet</code>的**<code>member</code><strong>是每次请求的</strong>唯一标识**（如UUID或毫秒时间戳+随机数），保证成员不重复。</li>
<li><code>ZSet</code>的**<code>score</code><strong>是该请求发生的</strong>毫秒时间戳**。</li>
<li><strong>限流逻辑</strong>：<br>a. 当一个新请求到来时，首先使用<code>ZREMRANGEBYSCORE</code>命令，<strong>移除所有“窗口之外”的旧请求</strong>。窗口的起始时间是<code>当前时间戳 - 窗口大小</code>。<br>b. 然后，使用<code>ZCARD</code>命令获取当前<code>ZSet</code>中的成员数量（即当前窗口内的请求数），判断是否超过阈值。<br>c. 如果未超过阈值，则使用<code>ZADD</code>将当前请求（<code>member</code>&#x3D;唯一ID, <code>score</code>&#x3D;当前时间戳）加入<code>ZSet</code>，并允许请求通过。<br>d. 如果已超过阈值，则拒绝请求。</li>
</ol>
</li>
<li><p><strong>Lua脚本实现（保证原子性）</strong>:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 脚本: sliding_window_rate_limit.lua</span></span><br><span class="line"><span class="comment">-- KEYS[1]: the zset key, e.g., &quot;rate_limit_zset:api:/users:127.0.0.1&quot;</span></span><br><span class="line"><span class="comment">-- ARGV[1]: the window size in milliseconds (e.g., 60000)</span></span><br><span class="line"><span class="comment">-- ARGV[2]: the limit threshold (e.g., 100)</span></span><br><span class="line"><span class="comment">-- ARGV[3]: the current timestamp in milliseconds</span></span><br><span class="line"><span class="comment">-- ARGV[4]: a unique value for the current request</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> window_start = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>]) - <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1. Remove requests outside the window</span></span><br><span class="line">redis.call(<span class="string">&#x27;zremrangebyscore&#x27;</span>, KEYS[<span class="number">1</span>], <span class="string">&#x27;-inf&#x27;</span>, window_start)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. Get the current count in the window</span></span><br><span class="line"><span class="keyword">local</span> current_count = redis.call(<span class="string">&#x27;zcard&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> current_count &lt; <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>]) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3. Add the new request and allow it</span></span><br><span class="line">    redis.call(<span class="string">&#x27;zadd&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">3</span>], ARGV[<span class="number">4</span>])</span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>, KEYS[<span class="number">1</span>], <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])/<span class="number">1000</span> + <span class="number">1</span>) <span class="comment">-- Set an expiration to clean up inactive keys</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="comment">-- Allowed</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 4. Limit exceeded, reject</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="comment">-- Rejected</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点</strong>：限流逻辑更加平滑和精确，解决了临界突刺问题。</p>
</li>
<li><p><strong>缺点</strong>：实现更复杂，且<code>ZSet</code>会存储每次请求的记录，当请求量巨大时，内存占用会比简单计数器高。</p>
</li>
</ul>
<hr>
<h3 id="3-2-延迟队列-Delayed-Queue"><a href="#3-2-延迟队列-Delayed-Queue" class="headerlink" title="3.2 延迟队列 (Delayed Queue)"></a>3.2 延迟队列 (Delayed Queue)</h3><ul>
<li><p><strong>思想</strong>：一种特殊的消息队列，生产者将消息发送到队列时，可以指定该消息在<strong>未来某个特定的时间点</strong>才能被消费者消费。</p>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li><strong>订单超时未支付自动取消</strong>：用户下单后，将一个“取消订单”的任务放入延迟队列，延迟时间为30分钟。</li>
<li><strong>用户注册后，24小时后发送引导邮件</strong>。</li>
<li><strong>定时任务调度</strong>：在未来的某个时间点执行一个特定任务。</li>
</ul>
</li>
<li><p><strong>实现 (使用<code>ZSet</code>)</strong>:<br><code>ZSet</code>是实现延迟队列的完美数据结构。</p>
<ol>
<li><code>ZSet</code>的Key作为队列的名称（如<code>delayed_queue</code>）。</li>
<li><code>ZSet</code>的**<code>member</code><strong>是需要被处理的</strong>任务内容**（如订单ID的字符串，或一个包含任务详情的JSON字符串）。</li>
<li><code>ZSet</code>的**<code>score</code><strong>是该任务的</strong>执行时间戳**（未来的某个时间点）。</li>
</ol>
</li>
<li><p><strong>生产者逻辑 (添加任务)</strong>:<br>使用<code>ZADD</code>命令将任务加入队列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 当前时间戳是 1700000000，30分钟后是 1700001800</span><br><span class="line"># 将一个取消订单的任务放入队列，30分钟后执行</span><br><span class="line">127.0.0.1:6379&gt; ZADD delayed_queue 1700001800 &#x27;&#123;&quot;task&quot;:&quot;cancel_order&quot;, &quot;orderId&quot;:&quot;12345&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>消费者逻辑 (获取并处理任务)</strong>:<br>消费者是一个<strong>后台轮询进程</strong>，它不断地执行以下操作：</p>
<ol>
<li><p><strong>拉取到期任务</strong>：使用<code>ZRANGEBYSCORE</code>命令，查询<code>ZSet</code>中所有<code>score</code>小于等于<strong>当前时间戳</strong>的任务。为了避免一次性拉取过多任务导致内存压力，通常会加上<code>LIMIT 0 1</code>，表示只拉取第一个到期的任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 假设当前时间戳是 1700001805</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE delayed_queue 0 1700001805 WITHSCORES LIMIT 0 1</span><br><span class="line">1) &quot;&#123;\&quot;task\&quot;:\&quot;cancel_order\&quot;, \&quot;orderId\&quot;:\&quot;12345\&quot;&#125;&quot;</span><br><span class="line">2) &quot;1700001800&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>保证原子性（防止多消费者重复执行）</strong>:</p>
<ul>
<li><p>当一个消费者拉取到一个任务后，必须立即将其从<code>ZSet</code>中删除，以防止其他消费者也拉取到同一个任务。</p>
</li>
<li><p>“拉取”和“删除”这两个操作不是原子的，需要使用<code>ZREM</code>。</p>
</li>
<li><p><strong>最佳实践</strong>：使用Lua脚本将“拉取并删除”封装成一个原子操作。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 脚本: fetch_and_remove_delayed_task.lua</span></span><br><span class="line"><span class="comment">-- KEYS[1]: a zset key</span></span><br><span class="line"><span class="comment">-- ARGV[1]: current timestamp</span></span><br><span class="line"><span class="keyword">local</span> tasks = redis.call(<span class="string">&#x27;zrangebyscore&#x27;</span>, KEYS[<span class="number">1</span>], <span class="number">0</span>, ARGV[<span class="number">1</span>], <span class="string">&#x27;LIMIT&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> #tasks &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> redis.call(<span class="string">&#x27;zrem&#x27;</span>, KEYS[<span class="number">1</span>], tasks[<span class="number">1</span>]) == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> tasks[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>执行任务</strong>：消费者获取到任务内容后，解析并执行相应的业务逻辑。</p>
</li>
</ol>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>实现简单、优雅。</li>
<li>利用<code>ZSet</code>的排序特性，拉取到期任务的效率非常高（O(logN + M)，其中M是拉取的任务数）。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>需要一个独立的、可靠的轮询进程来消费任务。</li>
<li>如果消费者在执行任务时崩溃，任务可能会丢失（除非有额外的ACK和重试机制，但这会使实现变得复杂，此时更推荐使用Redis Stream或专业MQ）。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="九、性能优化与最佳实践"><a href="#九、性能优化与最佳实践" class="headerlink" title="九、性能优化与最佳实践"></a>九、性能优化与最佳实践</h1><h2 id="1-内存优化"><a href="#1-内存优化" class="headerlink" title="1. 内存优化"></a>1. 内存优化</h2><h3 id="1-1-合理选择数据结构"><a href="#1-1-合理选择数据结构" class="headerlink" title="1.1 合理选择数据结构"></a>1.1 合理选择数据结构</h3><p>选择正确的数据结构是Redis内存优化的第一步，也是最重要的一步。不恰当的数据结构选择会导致内存的极大浪费。</p>
<p><strong>核心原则：用专门的结构做专门的事，用更紧凑的编码。</strong></p>
<h4 id="1-1-1-存储对象（如用户信息）"><a href="#1-1-1-存储对象（如用户信息）" class="headerlink" title="1.1.1 存储对象（如用户信息）"></a>1.1.1 存储对象（如用户信息）</h4><ul>
<li><strong>场景</strong>：存储一个包含多个字段的用户对象（ID, name, age, city）。</li>
<li><strong>不推荐的方案：为每个字段创建一个String Key</strong><ul>
<li><code>SET user:1001:name &quot;Alice&quot;</code></li>
<li><code>SET user:1001:age &quot;25&quot;</code></li>
<li><strong>问题</strong>：每个Key本身都会占用额外的元数据空间（用于存储Key本身、过期时间、类型等）。当对象字段多、对象数量大时，这种开销会非常可观。</li>
</ul>
</li>
<li><strong>方案一：String + JSON</strong><ul>
<li><code>SET user:1001 &#39;{&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:25,&quot;city&quot;:&quot;New York&quot;}&#39;</code></li>
<li><strong>优点</strong>：简单，可读性好。</li>
<li><strong>缺点</strong>：更新单个字段需要读出整个JSON、反序列化、修改、再序列化、写回，操作复杂且开销大。</li>
</ul>
</li>
<li><strong>推荐方案：使用 <code>Hash</code></strong><ul>
<li><code>HSET user:1001 name &quot;Alice&quot; age 25 city &quot;New York&quot;</code></li>
<li><strong>优点</strong>：<ol>
<li><strong>内存效率</strong>：当<code>Hash</code>中的字段数量和大小满足<code>ziplist</code>编码条件时，其内存占用远小于多个独立的String Key，也通常小于一个等效的JSON字符串。</li>
<li><strong>操作效率</strong>：可以独立更新单个字段（<code>HSET</code>），无需操作整个对象。</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-2-存储大量整数ID"><a href="#1-1-2-存储大量整数ID" class="headerlink" title="1.1.2 存储大量整数ID"></a>1.1.2 存储大量整数ID</h4><ul>
<li><strong>场景</strong>：记录一篇文章的所有点赞用户ID。</li>
<li><strong>不推荐的方案：使用 <code>List</code> 或 <code>String</code></strong><ul>
<li><code>List</code>允许重复，需要应用层去重。</li>
<li><code>String</code>拼接字符串，操作复杂，性能差。</li>
</ul>
</li>
<li><strong>方案一：使用 <code>Set</code></strong><ul>
<li><code>SADD post:123:likes 1001 1002 1003</code></li>
<li><strong>优点</strong>：自动去重，语义清晰。</li>
<li><strong>底层编码</strong>：如果所有用户ID都是整数，且数量不多，Redis会使用<code>intset</code>编码，非常节省内存。</li>
</ul>
</li>
<li><strong>方案二：使用 <code>Bitmap</code></strong><ul>
<li><code>SETBIT post:123:likes 1001 1</code></li>
<li><strong>优点</strong>：<strong>极致的内存节省</strong>。如果用户ID是连续或分布密集的整数，Bitmap的内存优势巨大。1亿个用户ID只需要约12.5MB空间。</li>
<li><strong>缺点</strong>：只适用于ID为数字的场景，且ID的稀疏分布可能导致空间浪费（例如，只有一个ID为1亿的用户，也会分配12.5MB空间）。</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>存储结构化对象 -&gt; 优先考虑<code>Hash</code>。</li>
<li>存储唯一标识的集合 -&gt; 优先考虑<code>Set</code>。如果标识是整数且对内存要求极致 -&gt; 考虑<code>Bitmap</code>。</li>
<li>需要排序 -&gt; <code>ZSet</code>或<code>List</code>。</li>
<li>海量数据去重统计 -&gt; <code>HyperLogLog</code>。</li>
</ul>
<hr>
<h3 id="1-2-maxmemory-与内存淘汰策略-LRU-LFU-etc"><a href="#1-2-maxmemory-与内存淘汰策略-LRU-LFU-etc" class="headerlink" title="1.2 maxmemory 与内存淘汰策略 (LRU, LFU, etc.)"></a>1.2 <code>maxmemory</code> 与内存淘汰策略 (LRU, LFU, etc.)</h3><h4 id="1-2-1-maxmemory"><a href="#1-2-1-maxmemory" class="headerlink" title="1.2.1 maxmemory"></a>1.2.1 <code>maxmemory</code></h4><ul>
<li><p><strong>是什么</strong>：<code>maxmemory</code>是<code>redis.conf</code>中的一个<strong>极其重要</strong>的配置项，它用于设置Redis实例能够使用的<strong>最大内存上限</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maxmemory &lt;bytes&gt;</span><br><span class="line"># 例如：</span><br><span class="line">maxmemory 2gb</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>为什么必须设置</strong>：</p>
<ul>
<li>如果不设置，在64位系统上Redis会默认使用服务器的所有可用内存。一旦物理内存耗尽，操作系统会开始使用虚拟内存（Swap），这会导致Redis的性能急剧下降（因为磁盘I&#x2F;O远慢于内存I&#x2F;O），甚至可能被操作系统OOM Killer（Out of Memory Killer）杀死。</li>
<li><strong>在生产环境中，必须为Redis设置一个合理的<code>maxmemory</code>值</strong>，通常是物理内存的60%-80%，为操作系统和其他进程留出余地。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-2-内存淘汰策略-maxmemory-policy"><a href="#1-2-2-内存淘汰策略-maxmemory-policy" class="headerlink" title="1.2.2 内存淘汰策略 (maxmemory-policy)"></a>1.2.2 内存淘汰策略 (<code>maxmemory-policy</code>)</h4><ul>
<li>当Redis的内存使用达到<code>maxmemory</code>上限时，就需要通过一种策略来删除一些Key，为新的数据腾出空间。这就是<strong>内存淘汰策略</strong>。</li>
<li>Redis 8.0 提供了多种策略，主要分为以下几类：<ul>
<li><strong>禁止淘汰</strong>：<ul>
<li><code>noeviction</code> (默认策略): 当内存满时，任何可能导致内存增加的写命令（如<code>SET</code>, <code>LPUSH</code>）都会返回错误。读命令不受影响。<strong>这种策略适合那些数据不能被丢弃的场景，但需要应用层做好异常处理。</strong></li>
</ul>
</li>
<li><strong>基于LRU (Least Recently Used - 最近最少使用)</strong>：<ul>
<li><code>volatile-lru</code>: 从<strong>设置了过期时间</strong>的Key中，淘汰最近最少使用的。<strong>这是缓存场景最常用的策略之一。</strong></li>
<li><code>allkeys-lru</code>: 从<strong>所有</strong>Key中，淘汰最近最少使用的。</li>
</ul>
</li>
<li><strong>基于LFU (Least Frequently Used - 最不经常使用)</strong> (Redis 4.0+):<ul>
<li><code>volatile-lfu</code>: 从<strong>设置了过期时间</strong>的Key中，淘汰使用频率最低的。</li>
<li><code>allkeys-lfu</code>: 从<strong>所有</strong>Key中，淘汰使用频率最低的。</li>
<li><strong>LRU vs LFU</strong>：LRU关注的是“最近有没有被访问”，而LFU关注的是“历史访问频率”。对于某些偶然被访问一次但之后不再使用的Key，LFU能比LRU更有效地将其淘汰，通常认为LFU在缓存场景中比LRU更优。</li>
</ul>
</li>
<li><strong>其他策略</strong>：<ul>
<li><code>volatile-ttl</code>: 从<strong>设置了过期时间</strong>的Key中，淘汰剩余生存时间（TTL）最短的。</li>
<li><code>volatile-random</code>: 从<strong>设置了过期时间</strong>的Key中，随机淘汰。</li>
<li><code>allkeys-random</code>: 从<strong>所有</strong>Key中，随机淘汰。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>如何选择？</strong></p>
<ul>
<li><strong>通用缓存场景</strong>：优先推荐<code>allkeys-lfu</code>或<code>volatile-lfu</code>。如果Redis版本低于4.0，则使用<code>allkeys-lru</code>或<code>volatile-lru</code>。</li>
<li><strong>数据需严格持久化</strong>：如果Redis不仅仅是缓存，还用作数据库，应使用<code>noeviction</code>，并做好内存监控和容量规划。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：Redis的LRU和LFU都是<strong>近似算法</strong>，而非精确实现。它们通过对少量Key进行采样来找出近似的“最老”或“最不常用”的Key，这样做是为了在保证淘汰效果的同时，不牺牲性能。</p>
</blockquote>
<hr>
<h3 id="1-3-警惕内存碎片"><a href="#1-3-警惕内存碎片" class="headerlink" title="1.3 警惕内存碎片"></a>1.3 警惕内存碎片</h3><ul>
<li><p><strong>什么是内存碎片</strong>：<br>内存碎片是指操作系统内存分配器（如jemalloc）中存在一些<strong>无法被利用的、不连续的小块空闲内存</strong>。Redis删除Key后，释放的内存不一定能立即被新的、大小不匹配的数据重用，久而久之就形成了碎片。</p>
</li>
<li><p><strong>如何监控</strong>：<br>通过<code>INFO memory</code>命令可以查看内存碎片率：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INFO memory</span><br><span class="line">...</span><br><span class="line">used_memory: 104857600  # Redis从操作系统分配的总内存</span><br><span class="line">used_memory_rss: 115343360 # Redis进程实际占用的物理内存</span><br><span class="line">mem_fragmentation_ratio: 1.10</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mem_fragmentation_ratio</code> &#x3D; <code>used_memory_rss</code> &#x2F; <code>used_memory</code>。</li>
<li><strong><code>&gt; 1.0</code></strong>: 表示存在内存碎片。通常<code>1.0</code>到<code>1.5</code>之间是比较健康的。</li>
<li><strong><code>&gt; 1.5</code></strong>: 表示碎片率较高，需要引起关注。</li>
<li><strong><code>&lt; 1.0</code></strong>: 表示Redis的内存已经被换出到磁盘（Swap），这是一个<strong>非常危险的信号</strong>，性能会急剧下降。</li>
</ul>
</li>
<li><p><strong>如何处理内存碎片</strong>：</p>
<ol>
<li><p><strong>重启大法</strong>：重启Redis实例是最简单粗暴的解决方法。操作系统会回收所有内存，碎片自然消失。这可以通过主从切换等高可用方案实现平滑重启。</p>
</li>
<li><p><strong>内置的碎片整理功能 (Redis 4.0+)</strong>：Redis 4.0引入了在线的内存碎片整理功能。</p>
<ul>
<li><p><strong>开启自动整理</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activedefrag yes</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>手动触发</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MEMORY PURGE</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原理</strong>：它会在后台线程中，将数据从一个内存位置拷贝到另一个连续的内存位置，然后释放原来的碎片空间。</p>
</li>
<li><p><strong>注意</strong>：在线碎片整理会消耗一定的CPU资源，需要根据业务负载情况谨慎开启和配置相关参数（如<code>active-defrag-ignore-bytes</code>, <code>active-defrag-cycle-min</code>等）。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="2-命令使用最佳实践"><a href="#2-命令使用最佳实践" class="headerlink" title="2. 命令使用最佳实践"></a>2. 命令使用最佳实践</h2><h3 id="2-1-避免慢查询命令"><a href="#2-1-避免慢查询命令" class="headerlink" title="2.1 避免慢查询命令"></a>2.1 避免慢查询命令</h3><p>Redis是单线程模型，一个慢查询命令会阻塞后续所有命令的执行，导致整个服务“卡顿”。因此，<strong>坚决避免在生产环境中使用时间复杂度为O(N)或更高的命令</strong>，特别是当N可能变得非常大时。</p>
<ul>
<li><strong><code>KEYS pattern</code></strong><ul>
<li><strong>危害</strong>：<code>KEYS</code>会遍历Redis中<strong>所有</strong>的Key来进行模式匹配。如果Key的数量达到百万、千万级别，这个操作会持续数秒甚至更久，是Redis性能的第一杀手。</li>
<li><strong>替代方案</strong>：使用<code>SCAN</code>命令进行增量迭代扫描。</li>
</ul>
</li>
<li><strong><code>HGETALL key</code></strong><ul>
<li><strong>危害</strong>：当一个Hash中包含大量字段（fields）时（例如，成千上万个），<code>HGETALL</code>会一次性返回所有字段和值，这会消耗大量的服务器内存和网络带宽，并可能导致阻塞。</li>
<li><strong>替代方案</strong>：<ul>
<li>使用<code>HSCAN</code>进行增量迭代。</li>
<li>如果确实需要获取多个字段，使用<code>HMGET</code>按需获取。</li>
<li>从设计上避免在单个Hash中存储过多字段。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>SMEMBERS key</code></strong><ul>
<li><strong>危害</strong>：与<code>HGETALL</code>类似，当一个Set中包含大量成员时，<code>SMEMBERS</code>会一次性返回所有成员，造成性能问题。</li>
<li><strong>替代方案</strong>：使用<code>SSCAN</code>进行增量迭代。</li>
</ul>
</li>
<li><strong>其他需要警惕的O(N)命令</strong>：<ul>
<li><code>LRANGE key 0 -1</code>: 获取List中的所有元素。</li>
<li><code>SINTER</code>&#x2F;<code>SUNION</code>&#x2F;<code>SDIFF</code>: 集合操作虽然在服务端高效，但如果参与计算的集合非常大，计算过程也会相当耗时。</li>
<li><code>FLUSHALL</code>&#x2F;<code>FLUSHDB</code>: 清空数据库是阻塞操作，虽然快，但在生产环境需要极度谨慎。</li>
</ul>
</li>
</ul>
<p><strong>如何发现慢查询？</strong></p>
<ul>
<li>使用<code>slowlog get [count]</code>命令查看Redis记录的慢查询日志。</li>
<li>使用<code>MONITOR</code>命令实时监控命令执行情况（只在开发或调试环境使用）。</li>
</ul>
<hr>
<h3 id="2-2-使用-SCAN-HSCAN-SSCAN-ZSCAN-进行迭代"><a href="#2-2-使用-SCAN-HSCAN-SSCAN-ZSCAN-进行迭代" class="headerlink" title="2.2 使用 SCAN &#x2F; HSCAN &#x2F; SSCAN &#x2F; ZSCAN 进行迭代"></a>2.2 使用 <code>SCAN</code> &#x2F; <code>HSCAN</code> &#x2F; <code>SSCAN</code> &#x2F; <code>ZSCAN</code> 进行迭代</h3><p><code>SCAN</code>及其家族的命令是为了解决<code>KEYS</code>等全量遍历命令的阻塞问题而设计的。它们通过**游标 (cursor)*<em>的方式进行*<em>无锁的、增量式的迭代</em></em>。</p>
<ul>
<li><p><strong>工作原理</strong>：</p>
<ol>
<li>你第一次调用<code>SCAN</code>时，将游标<code>cursor</code>设为0。</li>
<li>Redis会从内部数据结构中返回一小部分元素，同时返回一个<strong>新的游标</strong>。</li>
<li>你下一次调用<code>SCAN</code>时，传入上一次返回的新游标。</li>
<li>重复这个过程，直到Redis返回的游标为<code>0</code>，表示整个迭代过程结束。</li>
</ol>
</li>
<li><p><strong>核心命令</strong>：</p>
<ul>
<li><code>SCAN cursor [MATCH pattern] [COUNT count]</code></li>
<li><code>HSCAN key cursor [MATCH pattern] [COUNT count]</code></li>
<li><code>SSCAN key cursor [MATCH pattern] [COUNT count]</code></li>
<li><code>ZSCAN key cursor [MATCH pattern] [COUNT count]</code></li>
</ul>
</li>
<li><p><strong>参数说明</strong>：</p>
<ul>
<li><code>cursor</code>: 游标。</li>
<li><code>MATCH pattern</code>: 可选参数，用于匹配模式，功能类似<code>KEYS</code>的<code>pattern</code>。</li>
<li><code>COUNT count</code>: 可选参数，<strong>提示</strong>Redis每次迭代期望返回的元素数量，但<strong>不保证</strong>精确。它主要影响扫描工作的粒度。</li>
</ul>
</li>
<li><p><strong>实践示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 第一次扫描</span><br><span class="line">127.0.0.1:6379&gt; SCAN 0 MATCH user:* COUNT 100</span><br><span class="line">1) &quot;17&quot;  # 新的游标</span><br><span class="line">2) 1) &quot;user:1&quot;</span><br><span class="line">   2) &quot;user:2&quot;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line"># 第二次扫描，使用上一次返回的游标&quot;17&quot;</span><br><span class="line">127.0.0.1:6379&gt; SCAN 17 MATCH user:* COUNT 100</span><br><span class="line">1) &quot;0&quot;  # 返回游标为0，表示扫描结束</span><br><span class="line">2) 1) &quot;user:99&quot;</span><br><span class="line">   2) &quot;user:100&quot;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>非阻塞</strong>：<code>SCAN</code>的每次调用耗时都很短，不会阻塞服务器。</li>
<li><strong>增量迭代</strong>：将一次大的计算分散到多次小的计算中。</li>
<li><strong>保证完整性</strong>：<code>SCAN</code>能保证在整个迭代周期内，从迭代开始时就存在的元素，一定会被遍历到至少一次。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-批量操作善用-MSET-MGET-Pipeline"><a href="#2-3-批量操作善用-MSET-MGET-Pipeline" class="headerlink" title="2.3 批量操作善用 MSET&#x2F;MGET&#x2F;Pipeline"></a>2.3 批量操作善用 <code>MSET</code>&#x2F;<code>MGET</code>&#x2F;Pipeline</h3><p>减少网络RTT（往返时间）是Redis客户端优化的关键。</p>
<ul>
<li><p><strong><code>MSET</code>&#x2F;<code>MGET</code></strong>:</p>
<ul>
<li><strong>场景</strong>：当需要一次性设置或获取多个<strong>无关联</strong>的String类型的Key时。</li>
<li><strong>示例</strong>：获取用户1、2、3的姓名。<ul>
<li><strong>不推荐</strong>：<code>GET user:1:name</code>, <code>GET user:2:name</code>, <code>GET user:3:name</code> (3次RTT)</li>
<li><strong>推荐</strong>：<code>MGET user:1:name user:2:name user:3:name</code> (1次RTT)</li>
</ul>
</li>
<li><strong>优点</strong>：简单直接，将多次网络请求合并为一次。</li>
</ul>
</li>
<li><p><strong>Pipeline (管道)</strong>:</p>
<ul>
<li><p><strong>场景</strong>：当需要执行一连串<strong>不同类型</strong>或<strong>有逻辑关联但无需立即知道结果</strong>的命令时。</p>
</li>
<li><p><strong>示例</strong>：为一个新用户初始化数据：设置姓名、增加积分、加入某个集合。</p>
<p>text</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用Pipeline一次性发送</span><br><span class="line">SET user:new:name &quot;Bob&quot;</span><br><span class="line">INCRBY user:new:score 100</span><br><span class="line">SADD active_users &quot;user:new&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点</strong>：比<code>MSET</code>&#x2F;<code>MGET</code>更通用，可以打包任何命令。极大地提升了批量操作的吞吐量。</p>
</li>
</ul>
</li>
</ul>
<p><strong>选择策略</strong>：</p>
<ul>
<li>批量读写String -&gt; 优先<code>MGET</code>&#x2F;<code>MSET</code>。</li>
<li>批量执行不同类型的命令，或对一个Key进行连续操作 -&gt; 使用<code>Pipeline</code>。</li>
</ul>
<hr>
<h3 id="2-4-Key-Value设计规范"><a href="#2-4-Key-Value设计规范" class="headerlink" title="2.4 Key&#x2F;Value设计规范"></a>2.4 Key&#x2F;Value设计规范</h3><p>良好的命名规范可以极大地提升系统的可读性、可维护性和问题排查效率。</p>
<h4 id="2-4-1-Key-命名规范"><a href="#2-4-1-Key-命名规范" class="headerlink" title="2.4.1 Key 命名规范"></a>2.4.1 Key 命名规范</h4><ul>
<li><strong>可读性与可管理性</strong>：Key的命名应该清晰、有意义，能自解释。</li>
<li><strong>统一的分隔符</strong>：推荐使用冒号<code>:</code>来分隔不同的业务层级。<ul>
<li><strong>格式</strong>：<code>业务名:子业务名:唯一标识</code></li>
<li><strong>示例</strong>：<ul>
<li><code>user:info:1001</code> (存储用户1001的信息)</li>
<li><code>order:detail:20231225_A001</code> (存储某个订单的详情)</li>
<li><code>session:web:xyzabc123</code> (存储Web会话)</li>
</ul>
</li>
</ul>
</li>
<li><strong>简洁性</strong>：在保证可读性的前提下，Key的名称不宜过长，因为Key本身也占用内存。例如，用<code>u</code>代替<code>user</code>，用<code>o</code>代替<code>order</code>，但这需要在团队内部达成共识。</li>
<li><strong>避免包含特殊字符</strong>：避免使用空格、换行符等可能引起问题的字符。</li>
</ul>
<hr>
<h4 id="2-4-2-Value-设计规范"><a href="#2-4-2-Value-设计规范" class="headerlink" title="2.4.2 Value 设计规范"></a>2.4.2 Value 设计规范</h4><ul>
<li><strong>避免Big Key</strong>：<ul>
<li><strong>定义</strong>：一个Key对应的Value过大。通常String类型的Value超过10KB，或者Hash&#x2F;Set&#x2F;List&#x2F;ZSet中的元素数量超过5000个，就可以认为是Big Key。</li>
<li><strong>危害</strong>：<ul>
<li><strong>网络阻塞</strong>：读写Big Key会占用大量网络带宽。</li>
<li><strong>命令阻塞</strong>：对Big Key的操作（如<code>HGETALL</code>）会阻塞Redis。</li>
<li><strong>内存分配不均</strong>：在集群模式下，一个Big Key会导致某个节点的内存使用远超其他节点。</li>
<li><strong>删除困难</strong>：删除一个Big Key也可能导致阻塞（Redis 4.0后有<code>UNLINK</code>异步删除可以缓解）。</li>
</ul>
</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>拆分</strong>：将一个大的对象或集合拆分成多个小的。例如，一个包含100万个元素的Set，可以拆分成200个每个包含5000个元素的Set (<code>myset:1</code>, <code>myset:2</code>, …)。</li>
</ul>
</li>
</ul>
</li>
<li><strong>选择合适的序列化方式</strong>：<ul>
<li>如前所述，避免使用JDK序列化。优先选择JSON（可读性好）或Protobuf&#x2F;Kryo（性能极致）。</li>
</ul>
</li>
<li><strong>控制Value的生命周期</strong>：<ul>
<li>为所有作为缓存使用的Key<strong>设置合理的过期时间 (<code>EXPIRE</code>)</strong>。这是防止内存泄漏、保证数据新鲜度的重要手段。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-客户端优化"><a href="#3-客户端优化" class="headerlink" title="3. 客户端优化"></a>3. 客户端优化</h2><h3 id="3-1-使用连接池"><a href="#3-1-使用连接池" class="headerlink" title="3.1 使用连接池"></a>3.1 使用连接池</h3><ul>
<li><p><strong>为什么需要连接池？</strong><br>Redis客户端与服务器之间的连接建立和断开是需要消耗资源的。</p>
<ol>
<li><strong>TCP连接开销</strong>：每次连接都需要进行TCP的三次握手，断开需要四次挥手。在高并发场景下，频繁地创建和销毁连接会产生巨大的网络开销和系统调用开销，严重影响性能。</li>
<li><strong>身份验证开销</strong>：如果Redis设置了密码，每次连接后都需要进行<code>AUTH</code>身份验证，这也是一个开销。</li>
</ol>
</li>
<li><p><strong>连接池的工作原理</strong>：<br>连接池通过**“池化”**技术，预先创建并维护一定数量的Redis连接。当应用程序需要与Redis交互时：</p>
<ol>
<li>从连接池中<strong>借用 (borrow)</strong> 一个已经建立好的、空闲的连接。</li>
<li>使用这个连接执行Redis命令。</li>
<li>执行完毕后，将这个连接<strong>归还 (return)</strong> 到连接池中，而不是直接关闭它。</li>
</ol>
</li>
<li><p><strong>优点</strong>：</p>
<ol>
<li><strong>复用连接</strong>：避免了频繁创建和销毁连接的开销，显著提升了应用的性能和响应速度。</li>
<li><strong>资源控制</strong>：可以对连接数量进行统一管理和限制，防止应用无限制地创建连接，耗尽客户端或服务器的资源（如文件句柄）。</li>
<li><strong>连接管理</strong>：连接池通常会提供连接的有效性检查、空闲连接的自动回收、连接的保活（Keep-alive）等功能，提升了连接的稳定性和可靠性。</li>
</ol>
</li>
<li><p><strong>在Java中的实现</strong>：</p>
<ul>
<li><p><strong>Jedis</strong>：<code>Jedis</code>客户端是<strong>线程不安全</strong>的，因此在多线程环境下<strong>必须</strong>使用连接池（如<code>JedisPool</code>）来管理<code>Jedis</code>实例。每个线程从池中获取一个<code>Jedis</code>实例，使用完毕后归还。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置JedisPool</span></span><br><span class="line"><span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">poolConfig.setMaxTotal(<span class="number">10</span>); <span class="comment">// 最大连接数</span></span><br><span class="line">poolConfig.setMaxIdle(<span class="number">5</span>);   <span class="comment">// 最大空闲连接数</span></span><br><span class="line"><span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig, <span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource()) &#123;</span><br><span class="line">    jedis.set(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Lettuce</strong>：<code>Lettuce</code>客户端的连接是<strong>线程安全</strong>的，它基于Netty，可以在多个线程之间共享一个连接。但在高并发的<strong>同步阻塞</strong>调用场景下，单个连接可能会成为瓶颈。因此，<code>Lettuce</code>也提供了基于<code>commons-pool2</code>的连接池支持，Spring Boot的<code>spring-boot-starter-data-redis</code>默认就为<code>Lettuce</code>配置了连接池。这使得多个线程可以同时从池中获取连接，进行并发的阻塞操作。</p>
</li>
<li><p><strong>Redisson</strong>：<code>Redisson</code>内置了自己实现的连接池，同样用于管理到Redis节点的连接。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>最佳实践</strong>：无论使用哪种客户端，<strong>在生产环境中都应该配置和使用连接池</strong>。根据应用的QPS和并发模型，合理配置连接池的参数（如<code>maxTotal</code>, <code>maxIdle</code>, <code>maxWaitMillis</code>）至关重要。</p>
</blockquote>
<hr>
<h3 id="3-2-长连接-vs-短连接"><a href="#3-2-长连接-vs-短连接" class="headerlink" title="3.2 长连接 vs 短连接"></a>3.2 长连接 vs 短连接</h3><p>这个概念与连接池密切相关，但更侧重于连接的生命周期。</p>
<ul>
<li><strong>短连接 (Short-lived Connection)</strong>:<ul>
<li><strong>模式</strong>：每次需要与Redis交互时，都创建一个新的连接；操作完成后，立即关闭连接。</li>
<li><strong>优点</strong>：实现简单，对连接的管理负担小。</li>
<li><strong>缺点</strong>：<ul>
<li><strong>性能极差</strong>：如上所述，频繁的TCP握手、挥手和身份验证会带来巨大的性能开销。</li>
<li><strong>容易达到上限</strong>：在短时间内大量创建连接，可能会耗尽客户端或服务器的端口资源或文件句柄。</li>
</ul>
</li>
<li><strong>适用场景</strong>：只适用于那些<strong>极低频率</strong>的、偶尔执行一次的后台任务或脚本，<strong>绝对不适用于在线业务系统</strong>。</li>
</ul>
</li>
<li><strong>长连接 (Long-lived Connection)</strong>:<ul>
<li><strong>模式</strong>：客户端在应用启动时就与Redis建立连接，并在整个应用生命周期内保持这个连接（或连接池中的连接），反复使用它来执行命令。</li>
<li><strong>优点</strong>：<ul>
<li><strong>高性能</strong>：消除了连接建立和断开的开销。</li>
<li><strong>快速响应</strong>：请求可以直接通过已有的连接发送，延迟更低。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>资源占用</strong>：连接会持续占用客户端和服务器的资源。</li>
<li><strong>连接维护</strong>：需要处理连接可能因为网络问题、服务器重启等原因而中断的情况。需要有心跳检测（Heartbeat）和自动重连机制来保证连接的可用性。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<strong>绝大多数正常的应用场景</strong>，特别是在线服务、高并发系统。</li>
</ul>
</li>
</ul>
<p><strong>结论与连接池的关系</strong>：</p>
<p><strong>连接池本质上就是一种管理长连接的机制</strong>。它通过池化技术，使得长连接能够被安全、高效地在多个线程间共享和复用，同时提供了自动重连和健康检查等功能，解决了手动管理长连接的复杂性。</p>
<p>因此，在现代Redis客户端开发中，我们讨论的不再是“要不要用长连接”，而是**“如何通过连接池来高效、稳定地管理这些长连接”**。</p>
<p><strong>客户端优化总结</strong>：</p>
<ol>
<li><strong>始终使用连接池</strong>：这是确保Redis应用性能和稳定性的基础。</li>
<li><strong>理解你所用客户端的线程模型</strong>：<ul>
<li>对于Jedis（线程不安全），连接池是实现多线程访问的<strong>必要条件</strong>。</li>
<li>对于Lettuce（线程安全），连接池是提升<strong>同步阻塞调用</strong>并发能力的<strong>优化手段</strong>。</li>
</ul>
</li>
<li><strong>合理配置连接池参数</strong>：根据压测结果和业务预估，精细调整连接池的大小和超时时间，找到性能和资源消耗的平衡点。一个过大或过小的连接池都可能导致性能问题。</li>
<li><strong>监控连接池状态</strong>：通过JMX等方式监控连接池的活跃连接数、空闲连接数、等待线程数等指标，可以帮助你发现潜在的瓶颈或连接泄漏问题。</li>
</ol>
<hr>
<h1 id="十、运维与监控"><a href="#十、运维与监控" class="headerlink" title="十、运维与监控"></a>十、运维与监控</h1><h2 id="1-核心监控指标"><a href="#1-核心监控指标" class="headerlink" title="1. 核心监控指标"></a>1. 核心监控指标</h2><h3 id="1-1-INFO-命令详解"><a href="#1-1-INFO-命令详解" class="headerlink" title="1.1 INFO 命令详解"></a>1.1 <code>INFO</code> 命令详解</h3><p><code>INFO</code>命令是获取Redis服务器当前状态和各种统计信息最重要、最全面的入口。它返回的信息非常丰富，被分成了不同的部分（section）。</p>
<p>执行<code>INFO</code>命令，可以获取所有信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INFO</span><br></pre></td></tr></table></figure>

<p>也可以指定一个部分，只获取该部分的信息，这在监控脚本中更高效：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INFO memory</span><br></pre></td></tr></table></figure>

<p>以下是作为开发者和运维人员必须重点关注的几个核心部分：</p>
<p><strong>1. <code>memory</code> Section (内存相关)</strong></p>
<p>这是<strong>最重要</strong>的监控部分，因为它直接关系到Redis的性能和稳定性。</p>
<ul>
<li><strong><code>used_memory</code></strong>: <strong>Redis数据实际占用的内存大小（字节）</strong>。这是<code>maxmemory</code>所限制的部分。监控这个值可以了解内存使用量的增长趋势。</li>
<li><strong><code>used_memory_human</code></strong>: 以更易读的格式（如KB, MB, GB）显示<code>used_memory</code>。</li>
<li><strong><code>used_memory_rss</code></strong>: <strong>Redis进程从操作系统角度实际占用的物理内存大小（字节）</strong>。这个值通常<strong>大于</strong><code>used_memory</code>，因为包含了内存碎片和管理开销。</li>
<li><strong><code>mem_fragmentation_ratio</code></strong>: <strong>内存碎片率</strong> (<code>used_memory_rss / used_memory</code>)。<ul>
<li><code>&gt; 1.0</code> 表示存在内存碎片。通常<code>1.0 - 1.5</code>是健康的。</li>
<li><code>&gt; 1.5</code> 表示碎片严重，需要关注。</li>
<li><code>&lt; 1.0</code> 表示内存已被换出到磁盘（Swap），是<strong>严重性能问题的警报</strong>。</li>
</ul>
</li>
<li><strong><code>maxmemory</code></strong>: 配置的最大内存限制。</li>
<li><strong><code>maxmemory_policy</code></strong>: 配置的内存淘汰策略。</li>
</ul>
<p><strong>2. <code>stats</code> Section (通用统计)</strong></p>
<p>这部分提供了关于服务器运行的各种通用统计数据。</p>
<ul>
<li><strong><code>total_connections_received</code></strong>: 服务器自启动以来接收的总连接数。</li>
<li><strong><code>total_commands_processed</code></strong>: 服务器自启动以来处理的总命令数。</li>
<li><strong><code>instantaneous_ops_per_sec</code></strong>: <strong>瞬时QPS（每秒处理的命令数）</strong>。这是衡量Redis当前负载的核心指标。</li>
<li><strong><code>keyspace_hits</code></strong>: <strong>缓存命中次数</strong>。</li>
<li><strong><code>keyspace_misses</code></strong>: <strong>缓存未命中次数</strong>。</li>
<li><strong><code>rejected_connections</code></strong>: 因达到<code>maxclients</code>限制而被拒绝的连接数。如果这个值持续增长，说明需要调高<code>maxclients</code>或排查连接泄漏。</li>
<li><strong><code>expired_keys</code></strong>: 因过期而被自动删除的key的数量。</li>
<li><strong><code>evicted_keys</code></strong>: 因内存达到<code>maxmemory</code>而被淘汰策略删除的key的数量。如果这个值持续增长，说明内存不足，需要扩容或优化。</li>
</ul>
<p><strong>3. <code>replication</code> Section (主从复制相关)</strong></p>
<p>在主从架构中，这部分信息对于监控复制状态至关重要。</p>
<ul>
<li><strong>在Master节点上</strong>:<ul>
<li><code>role:master</code></li>
<li><code>connected_slaves</code>: 连接的从节点数量。</li>
<li><code>slaveX: ip=..., port=..., state=online, offset=..., lag=...</code>: 每个从节点的详细信息。<ul>
<li><code>state</code>: 必须是<code>online</code>才正常。</li>
<li><code>offset</code>: 从节点的复制偏移量。</li>
<li><code>lag</code>: <strong>主从延迟（秒）</strong>。如果这个值过大，说明主从同步存在问题。</li>
</ul>
</li>
</ul>
</li>
<li><strong>在Slave节点上</strong>:<ul>
<li><code>role:slave</code></li>
<li><code>master_host</code> &#x2F; <code>master_port</code>: 主节点的地址和端口。</li>
<li><code>master_link_status</code>: <strong>主从连接状态</strong>，必须是<code>up</code>才正常。如果是<code>down</code>，说明与主节点的连接断开了。</li>
<li><code>master_sync_in_progress</code>: 是否正在进行全量同步。<code>1</code>表示正在同步，此时Slave可能无法提供服务。</li>
</ul>
</li>
</ul>
<p><strong>4. <code>keyspace</code> Section (键空间统计)</strong></p>
<p>这部分提供了每个数据库中Key的数量和设置了过期时间的Key的数量。</p>
<ul>
<li><code>db0: keys=1234,expires=56,avg_ttl=...</code>:<ul>
<li><code>keys</code>: 数据库<code>db0</code>中的总Key数量。</li>
<li><code>expires</code>: <code>db0</code>中设置了过期时间的Key的数量。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-重点监控指标与解读"><a href="#1-2-重点监控指标与解读" class="headerlink" title="1.2 重点监控指标与解读"></a>1.2 重点监控指标与解读</h3><p>除了从<code>INFO</code>命令中获取，以下几个指标是日常监控大盘上必须展示的核心数据。</p>
<ul>
<li><strong><code>used_memory</code> (内存占用)</strong><ul>
<li><strong>监控目的</strong>：跟踪内存使用情况，进行容量规划，预防内存耗尽。</li>
<li><strong>告警阈值</strong>：当<code>used_memory</code>接近<code>maxmemory</code>的**80%-90%**时，应触发告警。</li>
<li><strong>关联指标</strong>：<ul>
<li><code>evicted_keys</code>: 如果此值持续增长，说明内存已满，正在频繁淘汰数据。</li>
<li><code>mem_fragmentation_ratio</code>: 监控碎片情况。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>connected_clients</code> (客户端连接数)</strong><ul>
<li><strong>监控目的</strong>：了解当前有多少客户端正在连接Redis，排查连接泄漏问题。</li>
<li><strong>告警阈值</strong>：当<code>connected_clients</code>接近<code>maxclients</code>（默认10000）配置时，应触发告警。</li>
<li><strong>关联指标</strong>：<ul>
<li><code>rejected_connections</code>: 如果此值增长，说明连接池已满，新的连接被拒绝。</li>
<li><code>blocked_clients</code>: 正在执行阻塞命令（如<code>BLPOP</code>, <code>BRPOP</code>）的客户端数量。如果此值过高，可能表示消费者处理能力不足。</li>
</ul>
</li>
</ul>
</li>
<li><strong>缓存命中率 (Cache Hit Rate)</strong><ul>
<li><strong>计算公式</strong>: <code>Hit Rate = keyspace_hits / (keyspace_hits + keyspace_misses)</code></li>
<li><strong>监控目的</strong>：这是衡量<strong>缓存有效性</strong>的最关键指标。一个高命中率（通常&gt;90%或95%）表明缓存工作良好，有效地为后端数据库抵挡了流量。</li>
<li><strong>告警阈值</strong>：当命中率在一段时间内<strong>持续低于某个阈值</strong>（如80%），或发生<strong>突降</strong>时，应触发告警。</li>
<li><strong>问题排查</strong>：命中率低可能意味着：<ul>
<li>缓存容量不足，导致热点数据被频繁淘汰。</li>
<li>缓存雪崩或大量穿透发生。</li>
<li>业务逻辑中存在不合理的缓存使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>其他重要监控项</strong>：</p>
<ul>
<li><strong><code>instantaneous_ops_per_sec</code> (QPS)</strong>: 监控Redis的负载情况，判断是否有流量突增。</li>
<li><strong>CPU使用率</strong>: Redis是CPU敏感型应用。如果CPU使用率持续过高（特别是单核跑满），可能是有慢查询或计算密集型命令（如复杂的Lua脚本）。</li>
<li><strong>主从延迟 (<code>lag</code>)</strong>: 在主从架构下，必须监控主从延迟，确保读写分离的数据一致性在可接受范围内。</li>
</ul>
<p><strong>监控工具</strong>：</p>
<ul>
<li><strong>Prometheus + Grafana</strong>: 业界标准。使用<code>redis-exporter</code>采集Redis的<code>INFO</code>等指标，由Prometheus存储，再通过Grafana进行可视化展示和告警。</li>
<li><strong>RedisInsight</strong>: Redis官方提供的免费可视化管理工具，能直观地展示各种监控指标。</li>
<li><strong>商业监控平台</strong>: 如Datadog, New Relic等也提供了完善的Redis监控方案。</li>
</ul>
<hr>
<h2 id="2-常见问题排查-Troubleshooting"><a href="#2-常见问题排查-Troubleshooting" class="headerlink" title="2. 常见问题排查 (Troubleshooting)"></a>2. 常见问题排查 (Troubleshooting)</h2><h3 id="2-1-Big-Key-大Key-问题"><a href="#2-1-Big-Key-大Key-问题" class="headerlink" title="2.1 Big Key (大Key) 问题"></a>2.1 Big Key (大Key) 问题</h3><h4 id="2-1-1-什么是Big-Key？"><a href="#2-1-1-什么是Big-Key？" class="headerlink" title="2.1.1 什么是Big Key？"></a>2.1.1 什么是Big Key？</h4><p>Big Key（也叫大Key）并不是指Key的名称很长，而是指<strong>Key对应的Value过大</strong>。它没有一个绝对的标准，通常根据业务场景和Redis的性能表现来判断：</p>
<ul>
<li><strong>String类型</strong>: Value的体积超过<strong>10KB</strong>。</li>
<li><strong>集合类型 (List, Hash, Set, ZSet)</strong>: 集合中的元素数量过多，例如超过<strong>5000</strong>个。</li>
</ul>
<hr>
<h4 id="2-1-2-Big-Key的危害"><a href="#2-1-2-Big-Key的危害" class="headerlink" title="2.1.2 Big Key的危害"></a>2.1.2 Big Key的危害</h4><ul>
<li><strong>网络阻塞</strong>: 客户端在读写Big Key时，会占用大量的网络带宽，导致其他请求的响应时间变慢。</li>
<li><strong>命令阻塞</strong>: 对Big Key的操作（如<code>HGETALL</code>, <code>SMEMBERS</code>, <code>DEL</code>）会消耗较长的CPU时间，阻塞Redis主线程，导致QPS下降。</li>
<li><strong>内存分配不均</strong>: 在集群模式下，一个Big Key会导致某个节点的内存使用远超其他节点，造成数据倾斜，难以进行负载均衡。</li>
<li><strong>迁移困难</strong>: 在集群扩容或缩容进行槽位迁移时，迁移一个Big Key会非常耗时，甚至可能导致迁移失败。</li>
<li><strong>过期&#x2F;淘汰效率低</strong>: 删除一个Big Key本身就是一个耗时操作。Redis 4.0之前的<code>DEL</code>是同步阻塞的，4.0之后引入的<code>UNLINK</code>可以异步删除，但仍会给后台线程带来压力。</li>
</ul>
<hr>
<h4 id="2-1-3-如何发现Big-Key？"><a href="#2-1-3-如何发现Big-Key？" class="headerlink" title="2.1.3 如何发现Big Key？"></a>2.1.3 如何发现Big Key？</h4><ul>
<li><strong><code>redis-cli --bigkeys</code></strong><ul>
<li><strong>方法</strong>: 这是Redis自带的工具，它会对整个数据库进行采样扫描，找出每种数据类型中“最大”的Key。</li>
<li><strong>命令</strong>: <code>redis-cli -h &lt;host&gt; -p &lt;port&gt; -a &lt;password&gt; --bigkeys</code></li>
<li><strong>优点</strong>: 简单方便，无需额外工具。</li>
<li><strong>缺点</strong>: 只是采样分析，结果不一定完全精确；扫描过程对线上服务有一定性能影响，建议在从节点或业务低峰期执行。</li>
</ul>
</li>
<li><strong><code>MEMORY USAGE key</code> 命令</strong><ul>
<li><strong>方法</strong>: 可以精确地计算出单个Key在内存中的占用大小（字节）。</li>
<li><strong>命令</strong>: <code>MEMORY USAGE my_big_hash_key</code></li>
<li><strong>缺点</strong>: 只能对已知的Key进行检查，无法主动发现未知的Big Key。</li>
</ul>
</li>
<li><strong>使用第三方分析工具</strong><ul>
<li>例如 <code>redis-rdb-tools</code>，它可以离线分析RDB快照文件，找出所有Key的大小分布，生成详细的报告，对线上服务无任何影响。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-4-如何处理Big-Key？"><a href="#2-1-4-如何处理Big-Key？" class="headerlink" title="2.1.4 如何处理Big Key？"></a>2.1.4 如何处理Big Key？</h4><p>核心思想是**“拆分”**。</p>
<ul>
<li><strong>对于String类型</strong>: 将一个大的JSON字符串或对象，拆分成多个小的String或一个<code>Hash</code>结构。<ul>
<li><strong>不推荐</strong>: <code>SET user:1 &#39;{&quot;info&quot;:{...}, &quot;posts&quot;: [...], &quot;friends&quot;: [...]}&#39;</code></li>
<li><strong>推荐</strong>:<ul>
<li><code>HSET user:info:1 name &quot;Alice&quot; age 25 ...</code></li>
<li><code>LPUSH user:posts:1 &quot;post_id_1&quot; &quot;post_id_2&quot; ...</code></li>
<li><code>SADD user:friends:1 &quot;friend_id_1&quot; &quot;friend_id_2&quot; ...</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>对于集合类型</strong>: 将一个大的集合拆分成多个小的集合。<ul>
<li><strong>场景</strong>: 存储一个用户的所有粉丝（可能有几百万）。</li>
<li><strong>不推荐</strong>: <code>SADD user:followers:1 &lt;all_follower_ids&gt;</code></li>
<li><strong>推荐 (分片)</strong>:<ul>
<li>通过用户ID取模或其他哈希算法，将粉丝分到不同的Key中。</li>
<li><code>SADD user:followers:1:0 &quot;follower_id_A&quot;</code> (假设ID_A哈希到第0片)</li>
<li><code>SADD user:followers:1:1 &quot;follower_id_B&quot;</code> (假设ID_B哈希到第1片)</li>
<li>当需要获取所有粉丝时，需要遍历所有分片Key。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-Hot-Key-热点Key-问题"><a href="#2-2-Hot-Key-热点Key-问题" class="headerlink" title="2.2 Hot Key (热点Key) 问题"></a>2.2 Hot Key (热点Key) 问题</h3><h4 id="2-2-1-如何发现Hot-Key？"><a href="#2-2-1-如何发现Hot-Key？" class="headerlink" title="2.2.1 如何发现Hot Key？"></a>2.2.1 如何发现Hot Key？</h4><ul>
<li><strong>预估</strong>: 根据业务场景提前预估哪些Key可能成为热点，例如秒杀活动的商品、热门新闻&#x2F;视频等。</li>
<li><strong>客户端统计</strong>: 在应用服务的客户端进行埋点，收集和统计所有对Redis的请求，找出访问频率最高的Key。</li>
<li><strong><code>MONITOR</code> 命令</strong> (仅限开发&#x2F;测试环境):<ul>
<li><code>redis-cli monitor</code>可以实时打印出所有到达Redis的命令。通过分析输出，可以直观地发现被频繁访问的Key。<strong>严禁在生产环境长时间使用</strong>。</li>
</ul>
</li>
<li><strong><code>hotkeys</code> 功能 (Redis 4.0+)</strong>:<ul>
<li>Redis 4.0在<code>redis.conf</code>中提供了一个<code>hotkeys-max-scan-keys</code>参数和<code>hotkeys</code>选项，配合<code>maxmemory-policy</code>为<code>LFU</code>时，可以通过<code>redis-cli --hotkeys</code>命令来发现热点Key。这是一种服务端原生的探测方式。</li>
</ul>
</li>
<li><strong>第三方监控系统</strong>: 借助Prometheus + Grafana等监控系统，对命令进行分析，或使用商业的Redis监控平台。</li>
</ul>
<hr>
<h4 id="2-2-2-如何处理Hot-Key？"><a href="#2-2-2-如何处理Hot-Key？" class="headerlink" title="2.2.2 如何处理Hot Key？"></a>2.2.2 如何处理Hot Key？</h4><p>核心思想是**“分散”<strong>和</strong>“冗余”**。</p>
<ul>
<li><strong>a. 使用本地缓存 (多级缓存)</strong><ul>
<li><strong>方法</strong>: 在应用服务内部使用本地缓存（如Caffeine, Guava Cache）来缓存热点Key的数据。</li>
<li><strong>流程</strong>: 请求先访问本地缓存，如果命中，则直接返回，根本不会请求Redis。</li>
<li><strong>优点</strong>: 效果最好，能将绝大部分对热点Key的请求拦截在应用服务内部，大大降低Redis的压力。</li>
<li><strong>缺点</strong>: 增加了架构的复杂性；需要处理本地缓存与Redis之间的数据一致性问题。</li>
</ul>
</li>
<li><strong>b. Key的复制与加盐</strong><ul>
<li><strong>方法</strong>: 将一个热点Key复制成多个副本，并将请求流量分散到这些副本上。</li>
<li><strong>示例</strong>:<ul>
<li>原始热点Key: <code>hot_product:123</code></li>
<li>复制为: <code>hot_product:123:copy1</code>, <code>hot_product:123:copy2</code>, <code>hot_product:123:copy3</code> …</li>
<li>当客户端要读取数据时，随机选择一个副本Key进行访问。例如 <code>hot_product:123:copy&lt;random(1,N)&gt;</code>。</li>
</ul>
</li>
<li><strong>数据同步</strong>: 当数据更新时，需要同时更新所有副本Key。</li>
<li><strong>优点</strong>: 能有效将读流量均摊到Redis集群的不同节点上（因为不同的副本Key会被哈希到不同槽）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-连接数异常"><a href="#2-3-连接数异常" class="headerlink" title="2.3 连接数异常"></a>2.3 连接数异常</h3><h4 id="2-3-1-现象"><a href="#2-3-1-现象" class="headerlink" title="2.3.1 现象"></a>2.3.1 现象</h4><ul>
<li>客户端报错，提示“无法从连接池获取连接”（<code>Could not get a resource from the pool</code>）。</li>
<li>监控显示Redis的<code>connected_clients</code>指标非常高，接近或达到<code>maxclients</code>的限制。</li>
<li><code>INFO stats</code>中的<code>rejected_connections</code>持续增加。</li>
</ul>
<hr>
<h4 id="2-3-2-原因分析"><a href="#2-3-2-原因分析" class="headerlink" title="2.3.2 原因分析"></a>2.3.2 原因分析</h4><ul>
<li><p><strong>a. 连接泄漏 (Connection Leak)</strong></p>
<ul>
<li><p><strong>最常见的原因</strong>。客户端从连接池中借用了连接，但在使用完毕后<strong>没有归还</strong>。</p>
</li>
<li><p><strong>排查 (以Jedis为例)</strong>: 检查代码中所有使用<code>jedisPool.getResource()</code>的地方，是否都正确地放在了<code>try-with-resources</code>语句块中，或者在<code>finally</code>块中调用了<code>jedis.close()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource()) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="comment">// try-with-resources会自动调用close()</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>b. 连接池配置不合理</strong></p>
<ul>
<li><code>maxTotal</code> (最大连接数) 设置得过小，无法满足业务高峰期的并发请求量，导致大量线程等待获取连接。</li>
<li><code>maxWaitMillis</code> (最大等待时间) 设置得过短，导致线程在还未等到空闲连接时就超时报错。</li>
</ul>
</li>
<li><p><strong>c. 慢查询阻塞</strong></p>
<ul>
<li>应用中存在慢查询命令，导致持有连接的线程长时间被阻塞，无法及时归还连接。这会<strong>连锁反应</strong>，导致连接池中的连接被快速耗尽。</li>
</ul>
</li>
<li><p><strong>d. 客户端并发过高</strong></p>
<ul>
<li>业务流量突增，应用的并发请求量超过了连接池的处理能力。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-3-3-如何处理"><a href="#2-3-3-如何处理" class="headerlink" title="2.3.3 如何处理"></a>2.3.3 如何处理</h4><ol>
<li><strong>排查代码</strong>：仔细审查代码，确保所有连接都被正确地创建和释放。这是首要步骤。</li>
<li><strong>优化连接池配置</strong>：根据应用的QPS和响应时间，通过压力测试来确定一个合理的<code>maxTotal</code>和<code>maxWaitMillis</code>值。</li>
<li><strong>排查并优化慢查询</strong>：使用<code>slowlog</code>找到慢查询，并用<code>SCAN</code>等命令进行替换，或优化数据结构。</li>
<li><strong>业务限流</strong>：如果确认是业务流量过高，应在应用入口处增加限流措施，保护后端服务。</li>
<li><strong>监控</strong>：对连接池的<strong>活跃连接数（active）</strong>、**空闲连接数（idle）<strong>和</strong>等待线程数（waiters）**进行监控，可以快速定位连接池是否成为瓶颈。</li>
</ol>
<hr>
<h2 id="3-Redis安全"><a href="#3-Redis安全" class="headerlink" title="3. Redis安全"></a>3. Redis安全</h2><p>由于Redis的速度极快，如果不加任何安全防护就将其暴露在公网上，它可能会在几秒钟内被黑客攻破，导致数据泄露、数据被篡改或被用作攻击跳板。因此，必须采取多层安全措施。</p>
<h3 id="3-1-设置复杂密码-requirepass"><a href="#3-1-设置复杂密码-requirepass" class="headerlink" title="3.1 设置复杂密码 (requirepass)"></a>3.1 设置复杂密码 (<code>requirepass</code>)</h3><ul>
<li><p><strong>是什么</strong>：<br><code>requirepass</code>是<code>redis.conf</code>中最基础也是最重要的安全配置项。它为Redis服务器设置了一个连接密码。客户端在执行任何命令之前，都必须先使用<code>AUTH &lt;password&gt;</code>命令进行身份验证。</p>
</li>
<li><p><strong>如何配置</strong>：<br>在<code>redis.conf</code>文件中，找到并取消注释<code>requirepass</code>行，并设置一个<strong>复杂、随机、长字符串</strong>作为密码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># requirepass foobared  &lt;-- 默认是注释掉的</span><br><span class="line"></span><br><span class="line"># 修改为：</span><br><span class="line">requirepass &quot;YourVeryComplex_and_Random-Password123!@#&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>为什么必须是复杂密码</strong>：<br>Redis的单线程模型虽然在处理正常命令时高效，但也意味着它在应对密码暴力破解时非常脆弱。一个简单的密码可以在短时间内被轻易猜解。因此，密码的复杂度和长度至关重要。</p>
</li>
<li><p><strong>客户端连接</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-cli连接</span></span><br><span class="line">redis-cli -a <span class="string">&quot;YourVeryComplex_and_Random-Password123!@#&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者连接后再认证</span></span><br><span class="line">redis-cli</span><br><span class="line">&gt; AUTH <span class="string">&quot;YourVeryComplex_and_Random-Password123!@#&quot;</span></span><br></pre></td></tr></table></figure>

<p>Java客户端（如Jedis, Lettuce）在配置连接时也需要提供这个密码。</p>
</li>
</ul>
<hr>
<h3 id="3-2-禁用或重命名危险命令-rename-command"><a href="#3-2-禁用或重命名危险命令-rename-command" class="headerlink" title="3.2 禁用或重命名危险命令 (rename-command)"></a>3.2 禁用或重命名危险命令 (<code>rename-command</code>)</h3><ul>
<li><p><strong>什么是危险命令</strong>：<br>某些Redis命令具有强大的功能，如果被误用或被恶意利用，可能会对服务器造成灾难性后果。这些命令包括：</p>
<ul>
<li><code>FLUSHALL</code>: 清空所有数据库的所有数据。</li>
<li><code>FLUSHDB</code>: 清空当前数据库的所有数据。</li>
<li><code>KEYS</code>: 阻塞式地遍历所有Key，可能导致服务卡死。</li>
<li><code>CONFIG</code>: 可以动态地读取和修改服务器配置，包括<code>requirepass</code>等敏感项。</li>
<li><code>SHUTDOWN</code>: 关闭Redis服务器。</li>
<li><code>DEBUG</code>: 调试命令，可能导致服务器崩溃。</li>
</ul>
</li>
<li><p><strong>如何处理</strong>：<br>通过<code>rename-command</code>配置项，可以将这些危险命令重命名为一个非常复杂、无人知晓的字符串，从而达到“禁用”的效果。也可以直接将其重命名为空字符串<code>&quot;&quot;</code>来彻底禁用。</p>
</li>
<li><p><strong>如何配置</strong>：<br>在<code>redis.conf</code>文件中添加配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 将FLUSHALL重命名为一个随机的、只有管理员知道的命令</span><br><span class="line">rename-command FLUSHALL &quot;CMD_FLUSHALL_aBcXyZ123&quot;</span><br><span class="line"></span><br><span class="line"># 将CONFIG命令彻底禁用</span><br><span class="line">rename-command CONFIG &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 将KEYS重命名，提醒开发者不要使用</span><br><span class="line">rename-command KEYS &quot;KEYS_DO_NOT_USE_IN_PROD&quot;</span><br></pre></td></tr></table></figure>

<p>修改配置并重启Redis后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; FLUSHALL</span><br><span class="line">(error) ERR unknown command `FLUSHALL`</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; CMD_FLUSHALL_aBcXyZ123</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>最佳实践</strong>：<br>在生产环境中，强烈建议禁用或重命名上述所有危险命令，只将重命名后的命令告知给必要的运维或DBA人员。</p>
</li>
</ul>
<hr>
<h3 id="3-3-绑定IP-bind-与防火墙策略"><a href="#3-3-绑定IP-bind-与防火墙策略" class="headerlink" title="3.3 绑定IP (bind) 与防火墙策略"></a>3.3 绑定IP (<code>bind</code>) 与防火墙策略</h3><p>这是从网络层面进行访问控制，是防止未授权访问的最有效手段之一。</p>
<h4 id="3-3-1-绑定IP-bind"><a href="#3-3-1-绑定IP-bind" class="headerlink" title="3.3.1 绑定IP (bind)"></a>3.3.1 绑定IP (<code>bind</code>)</h4><ul>
<li><p><strong>是什么</strong>：<br><code>bind</code>配置项用于指定Redis服务器监听哪个网络接口的连接请求。</p>
</li>
<li><p><strong>如何配置</strong>：</p>
<ul>
<li><p><strong>最安全（默认）</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1 -::1</span><br></pre></td></tr></table></figure>

<p>这表示Redis只接受来自**本机（localhost）**的连接。这是最安全的配置，适用于Redis与应用程序部署在同一台服务器上的情况。</p>
</li>
<li><p><strong>内网访问</strong>:<br>如果你的应用服务器和Redis服务器在同一个内网中，但不在同一台机器上，应该将<code>bind</code>设置为Redis服务器的<strong>内网IP地址</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 192.168.1.100 127.0.0.1</span><br></pre></td></tr></table></figure>

<p>这样，Redis就只会接受来自<code>192.168.1.100</code>和本机<code>127.0.0.1</code>的连接请求。</p>
</li>
<li><p><strong>极不推荐</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># bind 0.0.0.0  或直接注释掉bind配置</span><br></pre></td></tr></table></figure>

<p>这表示Redis将监听<strong>所有</strong>网络接口，包括公网。<strong>绝对不要在未做任何其他安全防护的情况下这样配置</strong>，这相当于将你的Redis完全暴露在互联网上。</p>
</li>
</ul>
</li>
<li><p><strong>保护模式 (<code>protected-mode</code>)</strong></p>
<ul>
<li>Redis 3.2之后引入了<code>protected-mode yes</code>（默认开启）作为一道额外的防线。</li>
<li>当<code>protected-mode</code>为<code>yes</code>时，如果<strong>没有</strong>配置<code>bind</code>，也<strong>没有</strong>设置<code>requirepass</code>，那么Redis将只接受来自本机的连接。这可以防止新手在无意中将一个没有任何防护的Redis暴露在公网上。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-3-2-防火墙策略"><a href="#3-3-2-防火墙策略" class="headerlink" title="3.3.2 防火墙策略"></a>3.3.2 防火墙策略</h4><ul>
<li><p><strong>是什么</strong>：<br>即使<code>bind</code>配置正确，使用防火墙（如Linux的<code>iptables</code>&#x2F;<code>firewalld</code>，或云服务商的安全组）来限制对Redis端口（默认为6379）的访问，是一种更可靠、更底层的网络安全策略。</p>
</li>
<li><p><strong>如何配置 (以iptables为例)</strong>：<br>配置防火墙规则，只允许特定的、可信的IP地址或IP段来访问Redis的6379端口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 默认拒绝所有对6379端口的访问</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 6379 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 只允许应用服务器的IP（例如192.168.1.200）访问</span></span><br><span class="line">iptables -I INPUT -s 192.168.1.200 -p tcp --dport 6379 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 允许本机访问</span></span><br><span class="line">iptables -I INPUT -s 127.0.0.1 -p tcp --dport 6379 -j ACCEPT</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>云环境</strong>：<br>在AWS、阿里云、腾讯云等云平台上，应该使用**安全组（Security Group）**规则。为你的Redis实例创建一个安全组，并在入站规则中，只允许来自你的应用服务器所在安全组或特定内网IP的流量访问TCP 6379端口。</p>
</li>
</ul>
<p><strong>总结：多层防御</strong></p>
<p>一个安全的Redis部署应该结合使用以上所有策略，形成多层防御体系：</p>
<ol>
<li><strong>网络层</strong>：使用防火墙&#x2F;安全组，将Redis置于受信任的内网环境中。</li>
<li><strong>配置层</strong>：使用<code>bind</code>命令，将Redis绑定到内网IP。</li>
<li><strong>认证层</strong>：使用<code>requirepass</code>设置一个强密码。</li>
<li><strong>命令层</strong>：使用<code>rename-command</code>禁用危险命令。</li>
<li><strong>权限层</strong>（非Redis原生）：以<strong>非root用户</strong>运行Redis服务，限制其文件系统权限。</li>
</ol>
<p>遵循这些实践，可以最大限度地保护你的Redis实例免受未授权访问和恶意攻击。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E4%BA%8C%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/" rel="prev" title="二、服务器架构">
                  <i class="fa fa-angle-left"></i> 二、服务器架构
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
