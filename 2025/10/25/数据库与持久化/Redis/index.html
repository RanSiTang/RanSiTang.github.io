<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="一、Redis入门与核心概念1. Redis是什么？Redis（Remote Dictionary Server，远程字典服务器）是一个开源的、基于内存的、使用C语言编写的、高性能的键值（Key-Value）数据库。它通常被看作是一个数据结构服务器，因为值的类型可以是字符串、哈希、列表、集合、有序集合等多种丰富的类型。 1.1 NoSQL数据库、KV数据库、内存数据库这三个术语从不同维度描述了Re">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://example.com/2025/10/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/Redis/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="一、Redis入门与核心概念1. Redis是什么？Redis（Remote Dictionary Server，远程字典服务器）是一个开源的、基于内存的、使用C语言编写的、高性能的键值（Key-Value）数据库。它通常被看作是一个数据结构服务器，因为值的类型可以是字符串、哈希、列表、集合、有序集合等多种丰富的类型。 1.1 NoSQL数据库、KV数据库、内存数据库这三个术语从不同维度描述了Re">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-25T03:25:45.000Z">
<meta property="article:modified_time" content="2025-10-25T12:47:12.591Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/10/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/Redis/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/10/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/Redis/","path":"2025/10/25/数据库与持久化/Redis/","title":"Redis"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redis | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81Redis%E5%85%A5%E9%97%A8%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">一、Redis入门与核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Redis%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1. Redis是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81KV%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text">1.1 NoSQL数据库、KV数据库、内存数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Redis%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-text">1.2 Redis的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Redis-vs-MySQL"><span class="nav-text">1.3 Redis vs MySQL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Redis%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">2. Redis的典型应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E7%BC%93%E5%AD%98"><span class="nav-text">2.1 缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%EF%BC%88Session-Sharing%EF%BC%89"><span class="nav-text">2.2 分布式会话（Session Sharing）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E8%AE%A1%E6%95%B0%E5%99%A8%E3%80%81%E6%8E%92%E8%A1%8C%E6%A6%9C"><span class="nav-text">2.3 计数器、排行榜</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%EF%BC%88%E7%B2%89%E4%B8%9D%E3%80%81%E5%85%B3%E6%B3%A8%E3%80%81%E5%85%B1%E5%90%8C%E5%A5%BD%E5%8F%8B%EF%BC%89"><span class="nav-text">2.4 社交网络（粉丝、关注、共同好友）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88Pub-Sub%E3%80%81Stream%EF%BC%89"><span class="nav-text">2.5 消息队列（Pub&#x2F;Sub、Stream）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-text">2.6 分布式锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Redis%E7%9A%84%E5%BA%95%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-text">3. Redis的底层模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="nav-text">3.1 单线程模型：为什么这么快？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">3.2 单线程模型的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-Redis-6-0%E4%B9%8B%E5%90%8E%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">3.3 Redis 6.0之后的多线程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="nav-text">二、环境搭建与基础操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Redis%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="nav-text">1. Redis的安装与配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-Docker%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="nav-text">1.1 Docker快速安装（推荐）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Linux-Windows-macOS%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85"><span class="nav-text">1.2 Linux&#x2F;Windows&#x2F;macOS下的安装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-Linux-%E4%BB%A5Ubuntu-Debian%E4%B8%BA%E4%BE%8B"><span class="nav-text">1.2.1 Linux (以Ubuntu&#x2F;Debian为例)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-macOS"><span class="nav-text">1.2.2 macOS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-Windows-%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%94%A8%E4%BA%8E%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83"><span class="nav-text">1.2.3 Windows (不推荐用于生产环境)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-redis-conf%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%A7%A3%E8%AF%BB"><span class="nav-text">1.3 redis.conf核心配置项解读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Redis%E5%AE%A2%E6%88%B7%E7%AB%AFredis-cli"><span class="nav-text">2. Redis客户端redis-cli</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E8%BF%9E%E6%8E%A5Redis%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">2.1 连接Redis服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AE%9E%E8%B7%B5"><span class="nav-text">2.2 常用命令实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-raw-%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">2.3 --raw 参数的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E6%9B%B4%E5%A4%9Aredis-cli%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="nav-text">2.4 更多redis-cli实用技巧</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3"><span class="nav-text">三、核心数据结构详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-String-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">1. String (字符串)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">1.1 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9ASDS%EF%BC%88%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span class="nav-text">1.2 内部编码&#x2F;底层实现：SDS（简单动态字符串）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-text">1.3 常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">1.4 应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-List-%E5%88%97%E8%A1%A8"><span class="nav-text">2. List (列表)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">2.1 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9Aziplist-%E6%88%96-quicklist"><span class="nav-text">2.2 内部编码&#x2F;底层实现：ziplist 或 quicklist</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-text">2.3 常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">2.4 应用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Hash-%E5%93%88%E5%B8%8C-%E5%AD%97%E5%85%B8"><span class="nav-text">3. Hash (哈希&#x2F;字典)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">3.1 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9Aziplist-%E6%88%96-hashtable"><span class="nav-text">3.2 内部编码&#x2F;底层实现：ziplist 或 hashtable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-text">3.3 常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">3.4 应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Set-%E9%9B%86%E5%90%88"><span class="nav-text">4. Set (集合)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">4.1 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9Aintset-%E6%88%96-hashtable"><span class="nav-text">4.2 内部编码&#x2F;底层实现：intset 或 hashtable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-text">4.3 常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">4.4 应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Sorted-Set-ZSet-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="nav-text">5. Sorted Set (ZSet, 有序集合)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">5.1 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9Aziplist-%E6%88%96-skiplist-hashtable"><span class="nav-text">5.2 底层实现：ziplist 或 skiplist + hashtable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-text">5.3 常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">5.4 应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%85%B6%E4%BB%96%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">6. 其他高级数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-Bitmap-%E4%BD%8D%E5%9B%BE"><span class="nav-text">6.1 Bitmap (位图)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-HyperLogLog"><span class="nav-text">6.2 HyperLogLog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-Geospatial-%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4"><span class="nav-text">6.3 Geospatial (地理空间)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81Java%E5%AE%9E%E6%88%98%E9%9B%86%E6%88%90-Java%E5%BC%80%E5%8F%91%E8%80%85%E6%A0%B8%E5%BF%83"><span class="nav-text">四、Java实战集成 (Java开发者核心)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Redis%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%89%E5%9E%8B"><span class="nav-text">1. Redis客户端选型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-Jedis"><span class="nav-text">1.1 Jedis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Lettuce"><span class="nav-text">1.2 Lettuce</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Redisson"><span class="nav-text">1.3 Redisson</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="nav-text">1.4 总结对比表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Spring-Boot-%E9%9B%86%E6%88%90-Redis"><span class="nav-text">2. Spring Boot 集成 Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%BC%95%E5%85%A5-spring-boot-starter-data-redis"><span class="nav-text">2.1 引入 spring-boot-starter-data-redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-application-yml-%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3"><span class="nav-text">2.2 application.yml 配置详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-RedisTemplate-%E4%B8%8E-StringRedisTemplate"><span class="nav-text">2.3 RedisTemplate 与 StringRedisTemplate</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E5%B8%B8%E7%94%A8-API-%E7%A4%BA%E4%BE%8B"><span class="nav-text">2.4 常用 API 示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="nav-text">3. 序列化机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E9%BB%98%E8%AE%A4JDK%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">3.1 默认JDK序列化的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E4%BD%BF%E7%94%A8-Jackson-JSON-%E6%88%96-Protobuf-Kryo-%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="nav-text">3.2 使用 Jackson (JSON) 或 Protobuf&#x2F;Kryo 进行序列化配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E4%BD%BF%E7%94%A8-Jackson-JSON-%E2%80%94%E2%80%94-%E5%85%BC%E9%A1%BE%E5%8F%AF%E8%AF%BB%E6%80%A7%E4%B8%8E%E6%80%A7%E8%83%BD"><span class="nav-text">3.2.1 使用 Jackson (JSON) —— 兼顾可读性与性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E4%BD%BF%E7%94%A8-Protobuf-Kryo-%E2%80%94%E2%80%94-%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4%E6%80%A7%E8%83%BD"><span class="nav-text">3.2.2 使用 Protobuf &#x2F; Kryo —— 追求极致性能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E6%80%BB%E7%BB%93%E4%B8%8E%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5"><span class="nav-text">4.3 总结与选择策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81Redis%E8%BF%9B%E9%98%B6%E5%8A%9F%E8%83%BD"><span class="nav-text">五、Redis进阶功能</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BA%8B%E5%8A%A1-Transaction"><span class="nav-text">1. 事务 (Transaction)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-MULTI-EXEC-DISCARD-WATCH"><span class="nav-text">1.1 MULTI, EXEC, DISCARD, WATCH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Redis%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90"><span class="nav-text">1.2 Redis事务的ACID特性分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-WATCH-%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-text">1.3 WATCH 实现乐观锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85-Pub-Sub"><span class="nav-text">2. 发布&#x2F;订阅 (Pub&#x2F;Sub)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="nav-text">2.1 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4"><span class="nav-text">2.2 核心命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">2.3 应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E7%BC%BA%E7%82%B9"><span class="nav-text">2.4 缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Pipeline-%E7%AE%A1%E9%81%93"><span class="nav-text">3. Pipeline (管道)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="nav-text">3.1 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E4%B8%8E%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">3.2 与事务的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Java%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%AD%E7%9A%84Pipeline%E5%BA%94%E7%94%A8"><span class="nav-text">3.3 Java客户端中的Pipeline应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-Jedis-%E4%B8%AD%E7%9A%84-Pipeline"><span class="nav-text">3.3.1 Jedis 中的 Pipeline</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-Spring-Data-Redis-RedisTemplate-%E4%B8%AD%E7%9A%84-Pipeline"><span class="nav-text">3.3.2 Spring Data Redis (RedisTemplate) 中的 Pipeline</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Lua%E8%84%9A%E6%9C%AC"><span class="nav-text">4. Lua脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-EVAL-%E5%92%8C-EVALSHA"><span class="nav-text">4.1 EVAL 和 EVALSHA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Lua%E8%84%9A%E6%9C%AC"><span class="nav-text">4.2 为什么需要Lua脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84Lua%E8%84%9A%E6%9C%AC%E6%A1%88%E4%BE%8B"><span class="nav-text">4.3 编写简单的Lua脚本案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E5%AE%89%E5%85%A8%E7%9A%84CAS%E6%93%8D%E4%BD%9C%EF%BC%88%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%EF%BC%89"><span class="nav-text">4.3.1 安全的CAS操作（库存扣减）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%E5%AE%89%E5%85%A8%E5%9C%B0%E9%87%8A%E6%94%BE%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-text">4.3.2 安全地释放分布式锁</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6-%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BF%9D%E9%9A%9C"><span class="nav-text">六、持久化机制 (数据安全保障)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-RDB-Redis-Database"><span class="nav-text">1. RDB (Redis Database)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-AOF-Append-Only-File"><span class="nav-text">2. AOF (Append Only File)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-RDB-%E4%B8%8E-AOF-%E7%9A%84%E6%8A%89%E6%8B%A9"><span class="nav-text">3. RDB 与 AOF 的抉择</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%9A%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%8E%E6%89%A9%E5%B1%95"><span class="nav-text">七、企业级特性：高可用与扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-Master-Slave-Replication"><span class="nav-text">1. 主从复制 (Master-Slave Replication)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Sentinel-%E5%93%A8%E5%85%B5-%E6%A8%A1%E5%BC%8F"><span class="nav-text">2. Sentinel (哨兵) 模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Cluster-%E9%9B%86%E7%BE%A4-%E6%A8%A1%E5%BC%8F"><span class="nav-text">3. Cluster (集群) 模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">八、企业级开发设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1"><span class="nav-text">1. 缓存设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-text">2. 分布式锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%85%B6%E4%BB%96%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">3. 其他设计模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">九、性能优化与最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="nav-text">1. 内存优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">2. 命令使用最佳实践</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96"><span class="nav-text">3. 客户端优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E3%80%81%E8%BF%90%E7%BB%B4%E4%B8%8E%E7%9B%91%E6%8E%A7"><span class="nav-text">十、运维与监控</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87"><span class="nav-text">1. 核心监控指标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-Troubleshooting"><span class="nav-text">2. 常见问题排查 (Troubleshooting)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Redis%E5%AE%89%E5%85%A8"><span class="nav-text">3. Redis安全</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Redis | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-10-25 11:25:45 / 修改时间：20:47:12" itemprop="dateCreated datePublished" datetime="2025-10-25T11:25:45+08:00">2025-10-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">数据库与持久化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="一、Redis入门与核心概念"><a href="#一、Redis入门与核心概念" class="headerlink" title="一、Redis入门与核心概念"></a>一、Redis入门与核心概念</h1><h2 id="1-Redis是什么？"><a href="#1-Redis是什么？" class="headerlink" title="1. Redis是什么？"></a>1. Redis是什么？</h2><p>Redis（<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver，远程字典服务器）是一个开源的、基于<strong>内存</strong>的、使用C语言编写的、高性能的<strong>键值（Key-Value）数据库</strong>。它通常被看作是一个数据结构服务器，因为值的类型可以是字符串、哈希、列表、集合、有序集合等多种丰富的类型。</p>
<h3 id="1-1-NoSQL数据库、KV数据库、内存数据库"><a href="#1-1-NoSQL数据库、KV数据库、内存数据库" class="headerlink" title="1.1 NoSQL数据库、KV数据库、内存数据库"></a>1.1 NoSQL数据库、KV数据库、内存数据库</h3><p>这三个术语从不同维度描述了Redis的核心特征：</p>
<ul>
<li><strong>NoSQL数据库 (Not Only SQL)</strong><ul>
<li><strong>定义</strong>：与传统的关系型数据库不同，NoSQL数据库不保证遵循严格的ACID（原子性、一致性、隔离性、持久性）原则，而是更侧重于性能、可扩展性和数据模型的灵活性（非结构化）。</li>
<li><strong>Redis的体现</strong>：Redis的数据之间没有复杂的关系，易于横向扩展（通过集群），并且提供了灵活的键值模型，非常适合需要快速读写的场景，而不是处理复杂关系查询的场景。</li>
</ul>
</li>
<li><strong>KV数据库 (Key-Value)</strong><ul>
<li><strong>定义</strong>：一种最简单的数据库模型，数据以键值对的形式存储。通过一个唯一的键（Key），可以快速地存储、查询、更新或删除对应的值（Value）。</li>
<li><strong>Redis的体现</strong>：这是Redis最根本的数据模型。但Redis的强大之处在于，它的Value不仅仅是简单的字符串，而是<strong>丰富的数据结构</strong>，这使得它超越了普通的KV存储，能够在服务端直接对数据进行复杂操作。<ul>
<li>例如：你可以把一个用户的ID作为Key，一个<code>Hash</code>结构作为Value来存储该用户的姓名、年龄、邮箱等多个字段信息。</li>
</ul>
</li>
</ul>
</li>
<li><strong>内存数据库 (In-Memory)</strong><ul>
<li><strong>定义</strong>：将所有数据都存储在计算机内存（RAM）中的数据库。由于内存的读写速度远快于磁盘（通常是几个数量级的差距），内存数据库能提供极高的性能。  </li>
<li><strong>Redis的体现</strong>：Redis是典型的内存数据库。它的所有读写操作都在内存中完成，这也是Redis能达到每秒数十万次读写（QPS）的关键原因。当然，为了防止断电等意外导致数据丢失，Redis也提供了<strong>持久化</strong>机制，可以将内存中的数据定期或实时地写入磁盘。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-Redis的特性"><a href="#1-2-Redis的特性" class="headerlink" title="1.2 Redis的特性"></a>1.2 Redis的特性</h3><ul>
<li><strong>高性能</strong>：<ul>
<li><strong>纯内存操作</strong>：所有操作基于内存，速度极快。</li>
<li><strong>单线程模型</strong>：Redis 6.0之前，核心网络模型采用单线程处理客户端请求，避免了多线程上下文切换和锁竞争带来的开销。</li>
<li><strong>I&#x2F;O多路复用</strong>：采用<code>epoll</code>、<code>kqueue</code>等I&#x2F;O多路复用技术，使其单线程也能高效处理大量的并发连接。可以理解为：一个服务员（线程）高效地同时照看很多张桌子（连接），只要有桌子需要服务（I&#x2F;O事件发生），他马上过去处理。</li>
</ul>
</li>
<li><strong>丰富的数据结构</strong>：<ul>
<li>这是Redis区别于Memcached等其他KV存储的重要特征。它内置了String, List, Hash, Set, ZSet等结构，使得开发者可以直接在服务端完成很多复杂操作，而无需将数据取回客户端再处理。这大大减少了网络开销，简化了应用逻辑。</li>
</ul>
</li>
<li><strong>持久化 (Persistence)</strong>：<ul>
<li>支持**RDB（快照）<strong>和</strong>AOF（追加日志）**两种持久化方式，可以在服务器重启后恢复数据。4.0版本后还支持混合持久化。</li>
</ul>
</li>
<li><strong>高可用与可扩展性 (High Availability &amp; Scalability)</strong>：<ul>
<li><strong>主从复制 (Replication)</strong>：实现数据备份和读写分离。</li>
<li><strong>哨兵模式 (Sentinel)</strong>：自动监控主节点状态，在主节点宕机时实现自动故障转移。</li>
<li><strong>集群模式 (Cluster)</strong>：通过数据分片（Sharding）实现横向扩展，将数据分布到多个节点上，突破单机内存和性能瓶颈。</li>
</ul>
</li>
<li><strong>其他功能</strong>：<ul>
<li>支持<strong>事务</strong>（但非严格ACID）。</li>
<li>支持**发布&#x2F;订阅（Pub&#x2F;Sub）**模式，可用于构建消息系统。</li>
<li>支持<strong>Lua脚本</strong>，可以将多个命令打包成一个原子操作，减少网络延迟。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-Redis-vs-MySQL"><a href="#1-3-Redis-vs-MySQL" class="headerlink" title="1.3 Redis vs MySQL"></a>1.3 Redis vs MySQL</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Redis</th>
<th align="left">MySQL (代表关系型数据库)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据模型</strong></td>
<td align="left">丰富数据结构 (String, List, Hash, Set, ZSet等)</td>
<td align="left">结构化的二维表 (行和列)</td>
</tr>
<tr>
<td align="left"><strong>存储介质</strong></td>
<td align="left">主要在内存，可持久化到磁盘</td>
<td align="left">主要在磁盘</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">极高</td>
<td align="left">相对较低（磁盘I&#x2F;O是瓶颈）</td>
</tr>
<tr>
<td align="left"><strong>持久化</strong></td>
<td align="left">支持 RDB 和 AOF</td>
<td align="left">支持，ACID保证数据可靠</td>
</tr>
<tr>
<td align="left"><strong>高可用</strong></td>
<td align="left">主从复制、哨兵、集群</td>
<td align="left">主从复制、集群等成熟方案</td>
</tr>
<tr>
<td align="left"><strong>应用场景</strong></td>
<td align="left">缓存、分布式锁、排行榜、计数器、消息队列等</td>
<td align="left">业务数据的持久化存储、事务性操作、复杂查询</td>
</tr>
</tbody></table>
<p><strong>典型架构组合</strong>：</p>
<p>在Java后端应用中，最常见的组合是 <strong>MySQL + Redis</strong>。MySQL作为最终的数据存储（Source of Truth），Redis作为其前端的高性能缓存和功能扩展。用户的请求优先访问Redis，如果Redis中没有数据（Cache Miss），再去查询MySQL，并将结果写回Redis，以便下次快速访问。</p>
<hr>
<h2 id="2-Redis的典型应用场景"><a href="#2-Redis的典型应用场景" class="headerlink" title="2. Redis的典型应用场景"></a>2. Redis的典型应用场景</h2><h4 id="2-1-缓存"><a href="#2-1-缓存" class="headerlink" title="2.1 缓存"></a>2.1 缓存</h4><ul>
<li><strong>场景描述</strong>：当应用的用户量和并发量上来后，数据库往往成为性能瓶颈。频繁地读取相同的数据（如热点新闻、商品详情）会给数据库带来巨大压力。</li>
<li><strong>Redis解决方案</strong>：将热点数据存储在Redis中（作为缓存层），绝大部分请求将直接从Redis获取数据，而无需访问后端数据库。这大大降低了数据库的压力，并极大地提升了应用的响应速度。<ul>
<li><strong>数据缓存</strong>：缓存数据库中的记录，通常以JSON格式存储。</li>
<li><strong>页面缓存</strong>：缓存渲染好的HTML页面片段。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-分布式会话（Session-Sharing）"><a href="#2-2-分布式会话（Session-Sharing）" class="headerlink" title="2.2 分布式会话（Session Sharing）"></a>2.2 分布式会话（Session Sharing）</h4><ul>
<li><strong>场景描述</strong>：在分布式或集群环境下，应用被部署在多台服务器上。如果Session存储在单台服务器的内存中，负载均衡器将用户的下一个请求转发到另一台服务器时，就会导致Session丢失，用户需要重新登录。</li>
<li><strong>Redis解决方案</strong>：将所有服务器的Session数据集中存储在Redis中。无论用户的请求被哪台服务器处理，都可以通过同一个Session ID从Redis中获取到一致的会话信息。</li>
</ul>
<hr>
<h4 id="2-3-计数器、排行榜"><a href="#2-3-计数器、排行榜" class="headerlink" title="2.3 计数器、排行榜"></a>2.3 计数器、排行榜</h4><ul>
<li><strong>场景描述</strong>：需要实时统计和展示一些动态变化的数字，如文章阅读量、视频点赞数、商品销量榜、游戏积分榜等。关系型数据库在应对高并发的计数更新时，行锁的开销很大，性能较差。</li>
<li><strong>Redis解决方案</strong>：利用Redis原子性的、纳秒级的内存操作来实现。</li>
</ul>
<hr>
<h4 id="2-4-社交网络（粉丝、关注、共同好友）"><a href="#2-4-社交网络（粉丝、关注、共同好友）" class="headerlink" title="2.4 社交网络（粉丝、关注、共同好友）"></a>2.4 社交网络（粉丝、关注、共同好友）</h4><ul>
<li><strong>场景描述</strong>：在社交应用中，需要快速计算用户之间的关系，如A关注了B，A和C的共同关注是谁等。在关系型数据库中，这些操作通常需要复杂的<code>JOIN</code>查询，效率低下。</li>
<li><strong>Redis解决方案</strong>：利用Set集合的特性（无序、唯一）可以非常自然地模拟用户关系。</li>
</ul>
<hr>
<h4 id="2-5-消息队列（Pub-Sub、Stream）"><a href="#2-5-消息队列（Pub-Sub、Stream）" class="headerlink" title="2.5 消息队列（Pub&#x2F;Sub、Stream）"></a>2.5 消息队列（Pub&#x2F;Sub、Stream）</h4><ul>
<li><strong>场景描述</strong>：在系统架构中，为了解耦和异步处理，常常需要消息队列。例如，用户下单后，需要触发发送邮件、更新库存、通知物流等一系列后续操作，这些操作可以异步执行，从而快速响应用户。</li>
<li><strong>Redis解决方案</strong>：Redis提供了多种实现消息队列的机制，可以满足从简单到复杂的不同需求。</li>
</ul>
<hr>
<h4 id="2-6-分布式锁"><a href="#2-6-分布式锁" class="headerlink" title="2.6 分布式锁"></a>2.6 分布式锁</h4><ul>
<li><strong>场景描述</strong>：在分布式系统中，多个服务实例需要竞争访问同一个共享资源（如秒杀场景下的商品库存）。需要一种机制来保证同一时刻只有一个实例能够操作该资源，防止数据不一致。</li>
<li><strong>Redis解决方案</strong>：利用Redis命令的原子性（如<code>SETNX</code>）来模拟锁的获取和释放。</li>
</ul>
<hr>
<h2 id="3-Redis的底层模型"><a href="#3-Redis的底层模型" class="headerlink" title="3. Redis的底层模型"></a>3. Redis的底层模型</h2><p>Redis的核心网络模型在版本6.0之前一直以<strong>单线程</strong>著称。这个设计选择常常让人疑惑：在一个多核CPU普及的时代，为什么一个高性能的数据库会选择单线程？</p>
<h4 id="3-1-单线程模型：为什么这么快？"><a href="#3-1-单线程模型：为什么这么快？" class="headerlink" title="3.1 单线程模型：为什么这么快？"></a>3.1 单线程模型：为什么这么快？</h4><p>Redis的“单线程”指的是其<strong>处理网络请求和执行命令的核心模块是单线程的</strong>。而像持久化（RDB、AOF）、异步删除等耗时操作，Redis会使用后台线程（background threads）或子进程来处理，以避免阻塞主线程。</p>
<p>Redis单线程模型之所以能达到极高的性能，主要归功于以下三点：</p>
<p><strong>1. 纯内存操作 (Pure In-Memory Operations)</strong></p>
<ul>
<li><strong>根本原因</strong>：这是Redis速度快的根本。所有的数据都存储在内存中，而内存的读写速度比磁盘快几个数量级（通常是纳秒 vs 毫秒）。这意味着数据库的主要瓶颈——磁盘I&#x2F;O——在Redis的常规操作中完全不存在。相比之下，像MySQL这样的数据库，即使有缓存，大部分数据仍在磁盘上，查询不可避免地会涉及慢速的磁盘读写。</li>
</ul>
<p><strong>2. I&#x2F;O多路复用 (I&#x2F;O Multiplexing)</strong></p>
<ul>
<li><strong>核心技术</strong>：这是单线程模型能够高效处理并发连接的关键。Redis使用了<code>epoll</code>（在Linux下）或类似的系统调用（如<code>kqueue</code>、<code>select</code>）。</li>
<li><strong>工作方式</strong>：<ul>
<li><strong>传统模型</strong>：一个线程处理一个连接，或者使用线程池。当连接不活跃时，线程会处于阻塞等待状态，浪费CPU资源，且线程间的上下文切换开销巨大。</li>
<li><strong>Redis模型</strong>：Redis将所有客户端连接都注册到一个事件处理器（即I&#x2F;O多路复用程序）中。这个单线程的主循环会不断地轮询这些连接，问：“谁准备好了？”<ul>
<li>当某个连接有数据可读（例如，客户端发送了一个<code>SET</code>命令），主线程就去读取数据、执行命令。</li>
<li>当需要向某个连接写数据时，主线程就将数据写入。</li>
</ul>
</li>
</ul>
</li>
<li><strong>优势</strong>：通过I&#x2F;O多路复用，单个线程可以无阻塞地处理成千上万个并发连接，避免了创建和销毁线程以及线程上下文切换所带来的巨大开销。</li>
</ul>
<p><strong>3. 避免了多线程的上下文切换和锁竞争</strong></p>
<ul>
<li><strong>无锁竞争</strong>：由于所有命令都在一个线程中串行执行，因此天然不存在多线程环境下对共享资源的竞争问题（如同时修改同一个key）。这使得Redis的数据操作无需加锁，大大简化了实现，并消除了锁操作带来的性能开销。</li>
<li><strong>无上下文切换</strong>：单线程模型避免了在多个线程之间进行CPU上下文切换的成本。在并发量极高的情况下，这部分开销不容小觑。</li>
</ul>
<blockquote>
<p><strong>小结</strong>：Redis的快，是因为它<strong>扬长避短</strong>。它将所有操作都放在了速度飞快的内存里，并用I&#x2F;O多路复用技术让它的单线程专注于处理实际的计算任务，而不是把时间浪费在等待I&#x2F;O和线程切换上。</p>
</blockquote>
<hr>
<h4 id="3-2-单线程模型的优缺点"><a href="#3-2-单线程模型的优缺点" class="headerlink" title="3.2 单线程模型的优缺点"></a>3.2 单线程模型的优缺点</h4><p><strong>优点 (Advantages):</strong></p>
<ol>
<li><strong>实现简单，易于维护</strong>：代码逻辑清晰，避免了处理复杂的线程同步和死锁问题。</li>
<li><strong>天然的原子性</strong>：由于所有命令串行执行，单个命令的操作是原子性的，无需担心并发导致的数据错乱。</li>
<li><strong>高性能</strong>：没有锁竞争和上下文切换的开销。</li>
<li><strong>可预测性</strong>：执行顺序是确定的，便于排查问题。</li>
</ol>
<p><strong>缺点 (Disadvantages):</strong></p>
<ol>
<li><strong>无法利用多核CPU</strong>：这是最主要的缺点。单线程意味着Redis实例只能利用一个CPU核心来进行命令处理。对于计算密集型的操作，无法通过增加CPU核心来提升性能。<ul>
<li><strong>解决方案</strong>：在单台服务器上部署多个Redis实例（每个实例绑定一个CPU核心），或者直接使用Redis集群（Cluster）来横向扩展。</li>
</ul>
</li>
<li><strong>耗时命令会阻塞所有请求</strong>：因为所有命令是排队执行的，如果一个命令执行时间过长（例如，对一个包含数百万成员的Set执行<code>SMEMBERS</code>，或者使用了<code>KEYS *</code>），它会阻塞后面所有的请求，导致整个服务“卡顿”。<ul>
<li><strong>警示</strong>：这是Redis开发中必须遵守的铁律——<strong>永远不要使用可能导致阻塞的慢命令</strong>。应使用<code>SCAN</code>、<code>HSCAN</code>等命令进行增量迭代。</li>
</ul>
</li>
<li><strong>单点性能瓶颈</strong>：单个线程的QPS（每秒查询率）终究是有上限的，它受限于CPU主频。</li>
</ol>
<hr>
<h4 id="3-3-Redis-6-0之后的多线程"><a href="#3-3-Redis-6-0之后的多线程" class="headerlink" title="3.3 Redis 6.0之后的多线程"></a>3.3 Redis 6.0之后的多线程</h4><p>为了改进单线程模型无法利用多核CPU的缺点，Redis从<strong>6.0版本</strong>开始引入了<strong>多线程</strong>。</p>
<ul>
<li><strong>但请注意</strong>：Redis的多线程<strong>并非</strong>用于执行命令，而是用于<strong>处理网络I&#x2F;O</strong>（读取请求和写回响应）。</li>
<li><strong>工作流程</strong>：<ol>
<li>主线程接收连接，并将读取任务分发给I&#x2F;O线程。</li>
<li>I&#x2F;O线程并行地从Socket中读取客户端请求，然后将解析好的命令交给主线程。</li>
<li><strong>主线程依然是单线程，串行地执行命令。</strong></li>
<li>主线程执行完命令后，将响应结果再分发给I&#x2F;O线程。</li>
<li>I&#x2F;O线程并行地将响应写回到各自的客户端Socket。</li>
</ol>
</li>
<li><strong>结论</strong>：Redis 6.0的多线程优化的是<strong>网络I&#x2F;O的瓶颈</strong>，尤其是在高并发、大数据包的场景下，能显著提升吞吐量。但其<strong>命令执行的核心仍然是单线程的</strong>，从而保留了原有模型的简单、无锁、原子性等所有优点。</li>
</ul>
<hr>
<h1 id="二、环境搭建与基础操作"><a href="#二、环境搭建与基础操作" class="headerlink" title="二、环境搭建与基础操作"></a>二、环境搭建与基础操作</h1><h2 id="1-Redis的安装与配置"><a href="#1-Redis的安装与配置" class="headerlink" title="1. Redis的安装与配置"></a>1. Redis的安装与配置</h2><h3 id="1-1-Docker快速安装（推荐）"><a href="#1-1-Docker快速安装（推荐）" class="headerlink" title="1.1 Docker快速安装（推荐）"></a>1.1 Docker快速安装（推荐）</h3><p>对于开发者来说，使用Docker是安装和管理Redis最方便、最快捷的方式，它可以隔离环境，避免与宿主机系统产生冲突。</p>
<p><strong>步骤：</strong></p>
<ol>
<li><p><strong>拉取Redis镜像</strong><br>从Docker Hub上拉取官方的Redis镜像。通常建议指定版本号，例如<code>7.0</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:7.0</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动一个基本的Redis容器</strong><br>这是一个最简单的启动方式，适合快速测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --name my-redis: 给容器命名为my-redis</span></span><br><span class="line"><span class="comment"># -d: 后台运行 (detached mode)</span></span><br><span class="line"><span class="comment"># -p 6379:6379: 将宿主机的6379端口映射到容器的6379端口</span></span><br><span class="line">docker run --name my-redis -d -p 6379:6379 redis:7.0</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动并挂载自定义配置文件和数据目录（生产推荐）</strong><br>为了持久化数据和自定义配置，你应该将配置文件和数据目录挂载到宿主机上。</p>
<ul>
<li><p>首先，在宿主机上创建一个目录和配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /mydata/redis/conf</span><br><span class="line"><span class="built_in">mkdir</span> -p /mydata/redis/data</span><br><span class="line"><span class="comment"># 创建一个空的或从官方拷贝一个redis.conf文件</span></span><br><span class="line"><span class="built_in">touch</span> /mydata/redis/conf/redis.conf </span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑 <code>/mydata/redis/conf/redis.conf</code>，例如，添加密码：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> 在redis.conf中添加或修改</span><br><span class="line">requirepass your<span class="built_in">_</span>password</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用挂载方式启动容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name my-redis-pro \</span><br><span class="line">  -p 6379:6379 \</span><br><span class="line">  -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">  -v /mydata/redis/data:/data \</span><br><span class="line">  redis:7.0 \</span><br><span class="line">  redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf</code>: 将宿主机的配置文件挂载到容器内。</li>
<li><code>-v /mydata/redis/data:/data</code>: 将宿主机的数据目录挂载到容器的持久化数据目录。</li>
<li><code>redis-server /etc/redis/redis.conf</code>: 容器启动后，用指定的配置文件启动Redis服务。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>连接测试</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it my-redis-pro redis-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果设置了密码</span></span><br><span class="line">&gt; AUTH your_password</span><br><span class="line">&gt; PING</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="1-2-Linux-Windows-macOS下的安装"><a href="#1-2-Linux-Windows-macOS下的安装" class="headerlink" title="1.2 Linux&#x2F;Windows&#x2F;macOS下的安装"></a>1.2 Linux&#x2F;Windows&#x2F;macOS下的安装</h3><h4 id="1-2-1-Linux-以Ubuntu-Debian为例"><a href="#1-2-1-Linux-以Ubuntu-Debian为例" class="headerlink" title="1.2.1 Linux (以Ubuntu&#x2F;Debian为例)"></a>1.2.1 Linux (以Ubuntu&#x2F;Debian为例)</h4><ul>
<li><p>使用<code>apt</code>包管理器安装，非常方便，但版本可能不是最新的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install redis-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动和管理Redis服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start redis-server</span><br><span class="line"><span class="comment"># 设置开机自启</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> redis-server</span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status redis-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件路径通常在 <code>/etc/redis/redis.conf</code>。</p>
</li>
</ul>
<hr>
<h4 id="1-2-2-macOS"><a href="#1-2-2-macOS" class="headerlink" title="1.2.2 macOS"></a>1.2.2 macOS</h4><ul>
<li><p>推荐使用<code>Homebrew</code>进行安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动和管理Redis服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">brew services start redis</span><br><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">brew services stop redis</span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">brew services restart redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件路径通常在 <code>/usr/local/etc/redis.conf</code> (Intel芯片) 或 <code>/opt/homebrew/etc/redis.conf</code> (Apple M系列芯片)。</p>
</li>
</ul>
<hr>
<h4 id="1-2-3-Windows-不推荐用于生产环境"><a href="#1-2-3-Windows-不推荐用于生产环境" class="headerlink" title="1.2.3 Windows (不推荐用于生产环境)"></a>1.2.3 Windows (不推荐用于生产环境)</h4><ul>
<li>Windows官方不直接支持Redis。但可以从Microsoft的归档<a target="_blank" rel="noopener" href="https://github.com/microsoftarchive/redis/releases">GitHub release页面</a>下载MSOpenTech的编译版本（版本较旧）。</li>
<li>更好的方式是在Windows上使用 <strong>WSL (Windows Subsystem for Linux)</strong>，然后在WSL的Linux环境中按照Linux的方式安装和运行Redis。这是目前在Windows上进行Redis开发的主流方式。</li>
</ul>
<hr>
<h3 id="1-3-redis-conf核心配置项解读"><a href="#1-3-redis-conf核心配置项解读" class="headerlink" title="1.3 redis.conf核心配置项解读"></a>1.3 <code>redis.conf</code>核心配置项解读</h3><p><code>redis.conf</code>是Redis的配置文件，包含了大量的配置选项。以下是作为Java后端开发者必须了解和关注的核心配置项：</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left">默认值</th>
<th align="left">描述与建议</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>bind 127.0.0.1</code></strong></td>
<td align="left"><code>127.0.0.1 -::1</code></td>
<td align="left"><strong>[安全]</strong> 绑定的IP地址。默认只允许本地连接。<strong>生产环境</strong>应修改为内网IP地址，如<code>bind 192.168.1.100</code>。如果想允许任何IP访问，可以设置为<code>bind 0.0.0.0</code>，但<strong>极不推荐</strong>，必须配合防火墙和强密码。</td>
</tr>
<tr>
<td align="left"><strong><code>port 6379</code></strong></td>
<td align="left"><code>6379</code></td>
<td align="left"><strong>[连接]</strong> Redis监听的端口号。可以根据需要修改。</td>
</tr>
<tr>
<td align="left"><strong><code>requirepass foobared</code></strong></td>
<td align="left">(注释掉)</td>
<td align="left"><strong>[安全]</strong> 设置客户端连接密码。<strong>强烈建议在生产环境中开启</strong>并设置一个复杂的密码。例如：<code>requirepass YourComplexPassword</code>。</td>
</tr>
<tr>
<td align="left"><strong><code>daemonize yes</code></strong></td>
<td align="left"><code>no</code></td>
<td align="left"><strong>[运行模式]</strong> 是否以守护进程（后台）模式运行。<code>yes</code>表示后台运行，<code>no</code>表示前台运行（日志会直接打印在终端）。通过<code>systemctl</code>或<code>brew services</code>启动时，这个值通常会被覆盖，不用手动改。</td>
</tr>
<tr>
<td align="left"><strong><code>logfile &quot;&quot;</code></strong></td>
<td align="left"><code>&quot;&quot;</code></td>
<td align="left"><strong>[日志]</strong> 日志文件的路径。如果<code>daemonize</code>为<code>yes</code>，则必须指定一个日志文件路径。例如：<code>logfile /var/log/redis/redis-server.log</code>。</td>
</tr>
<tr>
<td align="left"><strong><code>databases 16</code></strong></td>
<td align="left"><code>16</code></td>
<td align="left"><strong>[数据库]</strong> Redis支持多个数据库，编号从0到15。客户端可以通过<code>SELECT</code>命令切换数据库。<strong>不推荐使用多DB</strong>，因为它们共享同一个线程和内存，隔离性差。在集群模式下，只支持<code>db 0</code>。现代开发更倾向于为不同业务启动不同的Redis实例。</td>
</tr>
<tr>
<td align="left"><strong><code>save &lt;seconds&gt; &lt;changes&gt;</code></strong></td>
<td align="left"><code>save 900 1</code><br><code>save 300 10</code><br><code>save 60 10000</code></td>
<td align="left"><strong>[持久化-RDB]</strong> RDB快照的触发条件。<code>save 900 1</code>表示在900秒内，如果至少有1个key发生变化，则触发一次快照。可以配置多条规则。</td>
</tr>
<tr>
<td align="left"><strong><code>appendonly no</code></strong></td>
<td align="left"><code>no</code></td>
<td align="left"><strong>[持久化-AOF]</strong> 是否开启AOF持久化。<code>yes</code>表示开启。<strong>生产环境强烈建议开启</strong>以获得更高的数据安全性。</td>
</tr>
<tr>
<td align="left"><strong><code>appendfsync everysec</code></strong></td>
<td align="left"><code>everysec</code></td>
<td align="left"><strong>[持久化-AOF]</strong> AOF的同步策略。<code>everysec</code>（每秒同步一次，推荐，兼顾性能和安全）、<code>always</code>（每个命令都同步，最安全但最慢）、<code>no</code>（由操作系统决定何时同步）。</td>
</tr>
<tr>
<td align="left"><strong><code>maxmemory &lt;bytes&gt;</code></strong></td>
<td align="left">(无限制)</td>
<td align="left"><strong>[内存管理]</strong> <strong>极其重要！</strong> 设置Redis实例能使用的最大内存。例如<code>maxmemory 2gb</code>。当内存达到上限时，会根据<code>maxmemory-policy</code>执行淘汰策略。<strong>生产环境必须设置</strong>，防止Redis耗尽服务器所有内存。</td>
</tr>
<tr>
<td align="left"><strong><code>maxmemory-policy noeviction</code></strong></td>
<td align="left"><code>noeviction</code></td>
<td align="left"><strong>[内存管理]</strong> 内存淘汰策略。<code>noeviction</code>（默认，内存满时写操作会报错）、<code>volatile-lru</code>（在设置了过期时间的key中，淘汰最近最少使用的，<strong>推荐用于缓存</strong>）、<code>allkeys-lru</code>（在所有key中淘汰最近最少使用的）。还有<code>lfu</code>、<code>random</code>等策略。</td>
</tr>
<tr>
<td align="left"><strong><code>protected-mode yes</code></strong></td>
<td align="left"><code>yes</code></td>
<td align="left"><strong>[安全]</strong> 保护模式。当此项为<code>yes</code>且没有设置<code>bind</code>和<code>requirepass</code>时，Redis只接受本地回环连接（<code>127.0.0.1</code>）。这是防止Redis在未做任何安全配置的情况下暴露在公网上的一个安全机制。</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-Redis客户端redis-cli"><a href="#2-Redis客户端redis-cli" class="headerlink" title="2. Redis客户端redis-cli"></a>2. Redis客户端<code>redis-cli</code></h2><p><code>redis-cli</code>（Redis Command Line Interface）是Redis自带的、功能强大的官方命令行客户端。它是你与Redis服务器进行交互、调试问题、执行管理任务最直接、最重要的工具。</p>
<h3 id="2-1-连接Redis服务器"><a href="#2-1-连接Redis服务器" class="headerlink" title="2.1 连接Redis服务器"></a>2.1 连接Redis服务器</h3><p><code>redis-cli</code>提供了灵活的参数来连接到不同的Redis实例。</p>
<ol>
<li><p><strong>连接本地默认实例</strong><br>如果Redis服务器运行在本地（<code>127.0.0.1</code>）且端口是默认的<code>6379</code>，直接输入命令即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>连接远程服务器或指定端口</strong><br>使用 <code>-h</code> (host) 和 <code>-p</code> (port) 参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接到 IP 为 192.168.1.100，端口为 6380 的Redis服务器</span></span><br><span class="line">redis-cli -h 192.168.1.100 -p 6380</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用密码连接</strong><br>如果Redis服务器设置了密码（<code>requirepass</code>），有两种方式连接：</p>
<ul>
<li><p><strong>方式一：使用 <code>-a</code> (authenticate) 参数</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.1.100 -p 6379 -a your_password</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方式二：连接后再使用 <code>AUTH</code> 命令</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.1.100 -p 6379</span><br><span class="line">192.168.1.100:6379&gt; AUTH your_password</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>选择数据库</strong><br>使用 <code>-n</code> 参数选择要操作的数据库（默认是<code>db 0</code>）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接并直接进入 5 号数据库</span></span><br><span class="line">redis-cli -n 5</span><br><span class="line">127.0.0.1:6379[5]&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>综合示例</strong>：连接到<code>192.168.1.100:6379</code>，使用密码<code>mysecret</code>，并操作<code>2</code>号数据库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.1.100 -p 6379 -a mysecret -n 2</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-常用命令实践"><a href="#2-2-常用命令实践" class="headerlink" title="2.2 常用命令实践"></a>2.2 常用命令实践</h3><p>以下是在<code>redis-cli</code>中进行日常开发和调试时最常用的一些基础命令。</p>
<ul>
<li><p><strong><code>PING</code></strong></p>
<ul>
<li><p><strong>用途</strong>：检查客户端与服务器的连接是否正常。如果服务器正常，会返回<code>PONG</code>。这是最基本的连通性测试命令。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PING</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>SET key value</code></strong></p>
<ul>
<li><p><strong>用途</strong>：设置一个键值对。如果key已经存在，它的值会被覆盖。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET user:1:name &quot;Alice&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>GET key</code></strong></p>
<ul>
<li><p><strong>用途</strong>：获取指定key的值。如果key不存在，返回 <code>(nil)</code>。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GET user:1:name</span><br><span class="line">&quot;Alice&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GET non<span class="built_in">_</span>existent<span class="built_in">_</span>key</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>KEYS pattern</code></strong></p>
<ul>
<li><p><strong>用途</strong>：查找所有符合给定模式 <code>pattern</code> 的 key。<code>*</code> 匹配任意多个字符，<code>?</code> 匹配单个字符。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; KEYS user:*</span><br><span class="line">1) &quot;user:1:name&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>⚠️ 严重警告：生产环境严禁使用！</strong><br><code>KEYS</code> 命令是一个<strong>阻塞式</strong>操作。它会遍历数据库中所有的key来进行模式匹配。如果你的Redis中有数百万甚至上千万的key，这个命令会导致Redis服务器<strong>卡顿数秒甚至更长时间</strong>，期间无法处理任何其他请求，造成严重的性能问题。在生产环境中，应使用<code>SCAN</code>命令进行安全的迭代查找。</p>
</li>
</ul>
</li>
<li><p><strong><code>FLUSHDB</code></strong></p>
<ul>
<li><p><strong>用途</strong>：清空<strong>当前</strong>数据库中的所有key。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; GET user:1:name</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>FLUSHALL</code></strong></p>
<ul>
<li><p><strong>用途</strong>：清空<strong>所有</strong>数据库（db0, db1, …, db15）中的所有key。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; FLUSHALL</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>⚠️ 操作警告</strong>：<code>FLUSHDB</code> 和 <code>FLUSHALL</code> 都是<strong>极其危险且不可逆</strong>的操作。请只在开发和测试环境中用于重置数据，<strong>绝对不要在生产环境随意执行</strong>。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-raw-参数的使用"><a href="#2-3-raw-参数的使用" class="headerlink" title="2.3 --raw 参数的使用"></a>2.3 <code>--raw</code> 参数的使用</h3><ul>
<li><p><strong>问题背景</strong>：当你在Redis中存储了包含中文或非ASCII字符的值时，直接使用 <code>redis-cli</code> 的 <code>GET</code> 命令，默认会以十六进制编码的形式显示结果，可读性很差。</p>
</li>
<li><p><strong>实践对比</strong>：</p>
<ol>
<li><p><strong>不使用 <code>--raw</code>（默认行为）</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; SET greeting <span class="string">&quot;你好，Redis！&quot;</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GET greeting</span><br><span class="line"><span class="string">&quot;\xe4\xbd\xa0\xe5\xa5\xbd\xef\xbc\x8cRedis\xef\xbc\x81&quot;</span> </span><br></pre></td></tr></table></figure>

<p>这个结果是UTF-8编码的十六进制表示，完全无法直接阅读。</p>
</li>
<li><p><strong>使用 <code>--raw</code> 参数</strong><br>启动<code>redis-cli</code>时加上<code>--raw</code>参数，它会告诉客户端以原始的、未经转义的格式输出结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli --raw</span><br><span class="line">127.0.0.1:6379&gt; GET greeting</span><br><span class="line">你好，Redis！</span><br></pre></td></tr></table></figure>

<p>可以看到，结果现在是人类可读的。</p>
</li>
</ol>
</li>
<li><p><strong>结论</strong>：当需要查看或处理包含非英文字符（如中文、日文、表情符号等）的数据时，记得使用<code>redis-cli --raw</code>来获得更好的体验。</p>
</li>
</ul>
<hr>
<h3 id="2-4-更多redis-cli实用技巧"><a href="#2-4-更多redis-cli实用技巧" class="headerlink" title="2.4 更多redis-cli实用技巧"></a>2.4 更多<code>redis-cli</code>实用技巧</h3><ul>
<li><p><strong><code>--scan</code> 和 <code>--pattern</code></strong>: <code>KEYS</code>命令的安全替代品。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从游标0开始，扫描匹配 user:* 模式的key，每次最多返回100个</span></span><br><span class="line">redis-cli --scan --pattern <span class="string">&quot;user:*&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>MONITOR</code></strong>: 实时监控Redis服务器正在执行的命令，是绝佳的调试工具。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli monitor</span><br><span class="line">OK</span><br><span class="line">1637842938.123456 [0 127.0.0.1:54321] <span class="string">&quot;SET&quot;</span> <span class="string">&quot;mykey&quot;</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">1637842940.654321 [0 127.0.0.1:54321] <span class="string">&quot;GET&quot;</span> <span class="string">&quot;mykey&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>--bigkeys</code></strong>: 采样分析键空间，找出占用内存大的”大Key”，有助于性能优化。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --bigkeys</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="三、核心数据结构详解"><a href="#三、核心数据结构详解" class="headerlink" title="三、核心数据结构详解"></a>三、核心数据结构详解</h1><p><em>(每一节都应包含：是什么、内部编码&#x2F;底层实现、常用命令、应用场景)</em></p>
<h2 id="1-String-字符串"><a href="#1-String-字符串" class="headerlink" title="1. String (字符串)"></a>1. String (字符串)</h2><h3 id="1-1-是什么"><a href="#1-1-是什么" class="headerlink" title="1.1 是什么"></a>1.1 是什么</h3><p><code>String</code> 是 Redis 中最基本、最常见的数据类型。它是一个键（Key）对应一个值（Value）的结构。虽然名为“字符串”，但它的值不仅可以是普通的文本字符串，还可以是数字（整数或浮点数），甚至是二进制数据（如序列化后的对象、图片文件等）。</p>
<p>一个 <code>String</code>类型的 value 最大可以存储 <strong>512MB</strong> 的数据。</p>
<hr>
<h3 id="1-2-内部编码-底层实现：SDS（简单动态字符串）"><a href="#1-2-内部编码-底层实现：SDS（简单动态字符串）" class="headerlink" title="1.2 内部编码&#x2F;底层实现：SDS（简单动态字符串）"></a>1.2 内部编码&#x2F;底层实现：SDS（简单动态字符串）</h3><p>Redis并没有直接使用C语言原生的字符串（以<code>\0</code>结尾的字符数组），而是自己构建了一种名为**简单动态字符串（Simple Dynamic String, SDS）**的数据结构。这样做带来了巨大的优势：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">C语言字符串 (<code>char*</code>)</th>
<th align="left">Redis SDS</th>
<th align="left">优势说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>获取长度</strong></td>
<td align="left">遍历整个字符串，时间复杂度O(N)</td>
<td align="left">直接读取<code>len</code>属性，时间复杂度O(1)</td>
<td align="left"><strong>高效</strong>：频繁获取字符串长度时性能极高。</td>
</tr>
<tr>
<td align="left"><strong>缓冲区溢出</strong></td>
<td align="left">容易发生。拼接字符串时若未分配足够内存，会写坏相邻内存。</td>
<td align="left"><strong>杜绝</strong>。SDS在修改时会先检查空间是否足够，不足则自动扩容。</td>
<td align="left"><strong>安全</strong>：从根本上防止了缓冲区溢出风险。</td>
</tr>
<tr>
<td align="left"><strong>内存重分配</strong></td>
<td align="left">每次增长或缩短字符串，都需要重新分配内存。</td>
<td align="left">采用<strong>空间预分配</strong>和<strong>惰性空间释放</strong>策略。</td>
<td align="left"><strong>高效</strong>：<br> - <strong>预分配</strong>：扩容时，分配比实际需要更多的空间，减少后续修改时的重分配次数。<br> - <strong>惰性释放</strong>：缩短字符串时，多余的空间并不立即回收，而是记录在<code>free</code>属性中，以备将来使用。</td>
</tr>
<tr>
<td align="left"><strong>二进制安全</strong></td>
<td align="left">不是。因为以<code>\0</code>作为结尾符，字符串中间不能包含<code>\0</code>。</td>
<td align="left"><strong>是</strong>。SDS通过<code>len</code>属性判断字符串长度，而非<code>\0</code>。</td>
<td align="left"><strong>灵活</strong>：可以存储任意二进制数据，如图片、音频、序列化对象（Protobuf, JSON）等。</td>
</tr>
</tbody></table>
<p><strong>简单来说，SDS为Redis的String类型提供了高效、安全、灵活的底层支持。</strong></p>
<hr>
<h3 id="1-3-常用命令"><a href="#1-3-常用命令" class="headerlink" title="1.3 常用命令"></a>1.3 常用命令</h3><ul>
<li><p><strong><code>SET key value [EX seconds | PX milliseconds]</code></strong>: 设置一个键值对。可以附加<code>EX</code>（秒）或<code>PX</code>（毫秒）参数来指定过期时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET username &quot;Alice&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>GET key</code></strong>: 获取指定key的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GET username</span><br><span class="line">&quot;Alice&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>INCR key</code> &#x2F; <code>DECR key</code></strong>: 将key中储存的数字值增一或减一。如果key不存在，则先初始化为0再执行操作。<strong>此操作是原子性的</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET page_views 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; INCR page_views</span><br><span class="line">(integer) 101</span><br></pre></td></tr></table></figure>

<ul>
<li>相关的还有 <code>INCRBY key increment</code> 和 <code>DECRBY key decrement</code>，用于增加或减少指定的整数值。</li>
</ul>
</li>
<li><p><strong><code>MSET key value [key value ...]</code></strong>: 同时设置一个或多个键值对。</p>
</li>
<li><p><strong><code>MGET key [key ...]</code></strong>: 获取所有（一个或多个）给定key的值。</p>
<ul>
<li><code>MSET</code>&#x2F;<code>MGET</code>是原子操作吗？<code>MSET</code>是原子性的，<code>MGET</code>不是。但它们都能<strong>极大地减少网络往返时间(RTT)</strong>，在需要批量操作时性能远高于多次<code>SET</code>&#x2F;<code>GET</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MSET user:1:name &quot;Tom&quot; user:2:name &quot;Jerry&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MGET user:1:name user:2:name</span><br><span class="line">1) &quot;Tom&quot;</span><br><span class="line">2) &quot;Jerry&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>SETEX key seconds value</code></strong>: <code>SET</code> + <code>EXPIRE</code>的原子组合，设置key的值并指定其过期时间（单位：秒）。非常适合用于缓存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETEX verification_code:138xxxx1234 60 &quot;9527&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; TTL verification_code:138xxxx1234  # TTL命令查看剩余生存时间</span><br><span class="line">(integer) 58 </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>SETNX key value</code></strong>: <code>SET if Not eXists</code>的缩写。只有在key不存在时，才设置key的值。<strong>是实现分布式锁的基础</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETNX lock:product:1001 &quot;processing&quot;</span><br><span class="line">(integer) 1  # 第一次设置，成功</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SETNX lock:product:1001 &quot;processing&quot;</span><br><span class="line">(integer) 0  # 第二次设置，因为key已存在，所以失败</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 应用场景</h3><ol>
<li><strong>缓存（Cache）</strong><ul>
<li><strong>描述</strong>：这是Redis最广泛的用途。将数据库中读取的热点数据（如用户信息、商品详情）序列化成JSON字符串后，存入Redis。下次请求时先查Redis，若命中则直接返回，无需查询数据库。</li>
<li><strong>实现</strong>：使用 <code>SETEX</code> 或 <code>SET</code> + <code>EXPIRE</code> 来缓存数据并设置合理的过期时间。</li>
<li><strong>示例</strong>：<code>SETEX product:1001 3600 &#39;{&quot;id&quot;:1001, &quot;name&quot;:&quot;iPhone 15&quot;, &quot;price&quot;:5999}&#39;</code></li>
</ul>
</li>
<li><strong>计数器（Counter）</strong><ul>
<li><strong>描述</strong>：利用<code>INCR</code>的原子性，可以非常高效地实现各种计数需求，如网站PV&#x2F;UV、用户点赞数、分享数等，避免了关系型数据库在高并发下因行锁导致的性能问题。</li>
<li><strong>实现</strong>：对代表计数器的key执行 <code>INCR</code> 或 <code>INCRBY</code> 命令。</li>
<li><strong>示例</strong>：用户访问文章详情页时，执行 <code>INCR article:view_count:post123</code>。</li>
</ul>
</li>
<li><strong>分布式ID生成（Distributed ID Generation）</strong><ul>
<li><strong>描述</strong>：在分布式系统中，需要一个全局唯一的ID生成服务。可以利用Redis的<code>INCR</code>原子自增特性来生成趋势递增的全局ID。</li>
<li><strong>实现</strong>：设置一个全局的ID生成器key，每次需要ID时调用<code>INCR</code>获取。为了提高性能，可以结合<code>INCRBY</code>一次性获取一个ID段（如1000个），在应用内存中使用，用完后再去Redis获取下一段。</li>
<li><strong>示例</strong>：<code>INCR global_order_id</code> 返回一个新的、唯一的订单ID。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-List-列表"><a href="#2-List-列表" class="headerlink" title="2. List (列表)"></a>2. List (列表)</h2><h3 id="2-1-是什么"><a href="#2-1-是什么" class="headerlink" title="2.1 是什么"></a>2.1 是什么</h3><p>Redis的 <code>List</code> 类型是一个<strong>有序的字符串集合</strong>，其元素可以重复。它在概念上类似于Java中的 <code>LinkedList</code>。因为其元素是有序的，所以你可以从列表的头部（左边）或尾部（右边）添加或弹出元素。</p>
<p><code>List</code> 的主要特性是：</p>
<ul>
<li><strong>有序</strong>：元素按插入顺序排序。</li>
<li><strong>可重复</strong>：一个列表中可以包含多个相同的元素。</li>
<li><strong>两端操作</strong>：支持对列表两端进行高效的 <code>PUSH</code> 和 <code>POP</code> 操作。</li>
</ul>
<p>一个 <code>List</code> 最多可以包含 2³² - 1 个元素（超过40亿个）。</p>
<hr>
<h3 id="2-2-内部编码-底层实现：ziplist-或-quicklist"><a href="#2-2-内部编码-底层实现：ziplist-或-quicklist" class="headerlink" title="2.2 内部编码&#x2F;底层实现：ziplist 或 quicklist"></a>2.2 内部编码&#x2F;底层实现：<code>ziplist</code> 或 <code>quicklist</code></h3><p>Redis为了在性能和内存使用之间取得平衡，对 <code>List</code> 的底层实现进行了优化。在Redis 3.2版本之前，它会在 <code>ziplist</code> 和 <code>linkedlist</code> 之间转换。</p>
<ul>
<li><strong><code>ziplist</code> (压缩列表)</strong>：<ul>
<li><strong>本质</strong>：一块连续的内存空间。它不是真正的链表，而是将所有元素和元数据（如前一个元素的长度、当前元素的长度）紧凑地存储在一起。</li>
<li><strong>优点</strong>：非常节省内存，尤其是在列表元素较少或每个元素都很小的情况下。</li>
<li><strong>缺点</strong>：由于是连续内存，每次修改（插入或删除）都可能引发连锁更新（Cascading Update），即后续元素需要整体移动。当列表很大时，修改操作的性能会下降。</li>
</ul>
</li>
<li><strong><code>linkedlist</code> (双向链表)</strong>：<ul>
<li><strong>本质</strong>：标准的双向链表结构，每个节点包含元素值以及指向前一个和后一个节点的指针。</li>
<li><strong>优点</strong>：在列表两端增删元素的时间复杂度是 O(1)，非常高效，不受列表长度影响。</li>
<li><strong>缺点</strong>：每个节点都需要额外的指针空间（<code>prev</code>, <code>next</code>），内存开销比 <code>ziplist</code> 大。</li>
</ul>
</li>
</ul>
<p>**Redis 3.2及以后版本：<code>quicklist</code> **</p>
<p>为了进一步优化，Redis 3.2 引入了 <code>quicklist</code> 作为 <code>List</code> 的唯一底层实现。</p>
<ul>
<li><strong><code>quicklist</code> 是 <code>ziplist</code> 和 <code>linkedlist</code> 的混合体</strong>，它是一个由 <code>ziplist</code> 构成的双向链表。</li>
<li><strong>结构</strong>：一个 <code>quicklist</code> 就是一个链表，但它的每个节点（<code>quicklistNode</code>）不再是单个元素，而是一个 <code>ziplist</code>，这个 <code>ziplist</code> 里包含了多个元素。</li>
<li><strong>优势</strong>：<ul>
<li><strong>空间效率</strong>：结合了 <code>ziplist</code> 的空间紧凑性。</li>
<li><strong>操作效率</strong>：保留了 <code>linkedlist</code> 在两端快速插入&#x2F;删除的优点。</li>
<li><strong>避免了 <code>ziplist</code> 的主要缺点</strong>：修改只影响节点内的 <code>ziplist</code>，不会导致大规模的数据移动。</li>
</ul>
</li>
</ul>
<p>你可以通过配置项 <code>list-max-ziplist-size</code> 和 <code>list-compress-depth</code> 来控制 <code>quicklist</code> 中每个 <code>ziplist</code> 的大小和压缩深度。</p>
<hr>
<h3 id="2-3-常用命令"><a href="#2-3-常用命令" class="headerlink" title="2.3 常用命令"></a>2.3 常用命令</h3><ul>
<li><p><strong><code>LPUSH key element [element ...]</code> &#x2F; <code>RPUSH key element [element ...]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：从列表的左边（头部）或右边（尾部）插入一个或多个元素。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LPUSH tasks &quot;task3&quot; &quot;task2&quot; &quot;task1&quot;  # 注意插入顺序</span><br><span class="line">(integer) 3</span><br><span class="line"># 此时列表为: [&quot;task1&quot;, &quot;task2&quot;, &quot;task3&quot;]</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; RPUSH tasks &quot;task4&quot;</span><br><span class="line">(integer) 4</span><br><span class="line"># 此时列表为: [&quot;task1&quot;, &quot;task2&quot;, &quot;task3&quot;, &quot;task4&quot;]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>LPOP key</code> &#x2F; <code>RPOP key</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：从列表的左边（头部）或右边（尾部）移除并返回一个元素。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LPOP tasks</span><br><span class="line">&quot;task1&quot;</span><br><span class="line"># 此时列表为: [&quot;task2&quot;, &quot;task3&quot;, &quot;task4&quot;]</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; RPOP tasks</span><br><span class="line">&quot;task4&quot;</span><br><span class="line"># 此时列表为: [&quot;task2&quot;, &quot;task3&quot;]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>LRANGE key start stop</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：获取列表中指定范围内的元素。这是一个<strong>只读</strong>操作。索引从0开始，<code>-1</code>表示最后一个元素。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LRANGE tasks 0 -1  # 获取所有元素</span><br><span class="line">1) &quot;task2&quot;</span><br><span class="line">2) &quot;task3&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LRANGE tasks 0 0  # 获取第一个元素</span><br><span class="line">1) &quot;task2&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>BLPOP key [key ...] timeout</code> &#x2F; <code>BRPOP key [key ...] timeout</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：<code>LPOP</code>&#x2F;<code>RPOP</code>的<strong>阻塞版本</strong>。如果列表中没有元素，客户端会阻塞等待，直到有新元素被推入或超时。<code>timeout</code>为0表示无限期等待。</p>
</li>
<li><p><strong>这是实现消息队列的关键命令</strong>，它避免了客户端在循环中不断轮询，极大地降低了CPU和网络开销。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 在一个客户端执行，此时&#x27;new_tasks&#x27;为空</span><br><span class="line">127.0.0.1:6379&gt; BLPOP new_tasks 0</span><br><span class="line"># (客户端会在此处阻塞，等待...)</span><br><span class="line"></span><br><span class="line"># 在另一个客户端执行</span><br><span class="line">127.0.0.1:6379&gt; LPUSH new_tasks &quot;urgent_task&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"># 第一个客户端会立即解除阻塞，并返回结果</span><br><span class="line">1) &quot;new_tasks&quot;</span><br><span class="line">2) &quot;urgent_task&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>LLEN key</code></strong>: 返回列表的长度。</p>
</li>
<li><p><strong><code>LTRIM key start stop</code></strong>: 对列表进行修剪，只保留指定范围内的元素。常用于实现“最新的N个项目”。</p>
</li>
</ul>
<hr>
<h4 id="2-4-应用场景"><a href="#2-4-应用场景" class="headerlink" title="2.4 应用场景"></a>2.4 应用场景</h4><ol>
<li><strong>消息队列&#x2F;任务队列（Message&#x2F;Task Queue）</strong><ul>
<li><strong>描述</strong>：这是List最经典的应用。利用<code>LPUSH</code>和<code>RPOP</code>（或相反）可以实现一个简单的先进先出（FIFO）队列，用于系统解耦和异步处理任务。</li>
<li><strong>实现</strong>：<ul>
<li><strong>生产者</strong>：使用 <code>LPUSH</code> 将任务（如订单ID、邮件发送请求）放入队列。</li>
<li><strong>消费者</strong>：使用 <code>BRPOP</code> 阻塞式地等待并获取任务进行处理。</li>
</ul>
</li>
<li><strong>优点</strong>：实现简单，性能高。</li>
<li><strong>缺点</strong>：这是一个<strong>简单的消息队列</strong>，不具备专业消息中间件（如Kafka, RabbitMQ）的ACK（消息确认）机制。如果消费者在处理任务时崩溃，该任务就永久丢失了。</li>
</ul>
</li>
<li><strong>文章列表&#x2F;动态订阅（Timeline Feed）</strong><ul>
<li><strong>描述</strong>：展示用户发布的最新文章、微博时间线、最新评论等。</li>
<li><strong>实现</strong>：<ul>
<li>当用户发布新内容时，使用 <code>LPUSH</code> 将其ID添加到对应的列表中。<code>LPUSH</code>确保了最新的内容总是在列表的最前面。</li>
<li>使用 <code>LRANGE</code> 进行分页查询。例如，<code>LRANGE user:123:feed 0 9</code> 获取第一页的10条动态。</li>
<li>为了防止列表无限增长，可以结合 <code>LTRIM</code> 命令，只保留最新的N条记录。例如，每次<code>LPUSH</code>后都执行 <code>LTRIM user:123:feed 0 999</code>，使列表最多只保留1000条动态。</li>
</ul>
</li>
</ul>
</li>
<li><strong>实现栈（Stack）</strong><ul>
<li><strong>描述</strong>：栈是后进先出（LIFO）的数据结构。</li>
<li><strong>实现</strong>：使用 <code>LPUSH</code> 进行入栈，<code>LPOP</code> 进行出栈，即可完美模拟一个栈。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-Hash-哈希-字典"><a href="#3-Hash-哈希-字典" class="headerlink" title="3. Hash (哈希&#x2F;字典)"></a>3. Hash (哈希&#x2F;字典)</h2><h3 id="3-1-是什么"><a href="#3-1-是什么" class="headerlink" title="3.1 是什么"></a>3.1 是什么</h3><p>Redis的 <code>Hash</code> 类型是一个<strong>键值对集合</strong>，它是一个 String 类型的 <strong>field</strong> 和 <strong>value</strong> 的映射表。你可以把它看作是<strong>一个存在于Redis Key内部的Map</strong>。</p>
<p>它非常适合用来存储对象。相比于将整个对象序列化成JSON字符串后存入一个普通的 <code>String</code> Key，使用 <code>Hash</code> 可以让你对对象中的<strong>单个字段进行独立的读写操作</strong>，而无需获取和重写整个对象。</p>
<p><strong>结构示意</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Key (e.g., &quot;user:1001&quot;)  </span><br><span class="line">  |</span><br><span class="line">  +-- field1 (&quot;name&quot;)  -&gt; value1 (&quot;Alice&quot;)</span><br><span class="line">  +-- field2 (&quot;age&quot;)   -&gt; value2 (&quot;25&quot;)</span><br><span class="line">  +-- field3 (&quot;city&quot;)  -&gt; value3 (&quot;New York&quot;)</span><br></pre></td></tr></table></figure>

<p>在Java中，这可以类比于 <code>Map&lt;String, Map&lt;String, String&gt;&gt;</code>。</p>
<hr>
<h3 id="3-2-内部编码-底层实现：ziplist-或-hashtable"><a href="#3-2-内部编码-底层实现：ziplist-或-hashtable" class="headerlink" title="3.2 内部编码&#x2F;底层实现：ziplist 或 hashtable"></a>3.2 内部编码&#x2F;底层实现：<code>ziplist</code> 或 <code>hashtable</code></h3><p>与 <code>List</code> 类似，Redis为了优化内存使用，<code>Hash</code> 类型也采用了两种内部编码，并会在满足特定条件时自动转换：</p>
<ul>
<li><strong><code>ziplist</code> (压缩列表)</strong>：<ul>
<li><strong>何时使用</strong>：当哈希对象中保存的键值对数量较少，并且每个键值对的键和值都比较短时。</li>
<li><strong>存储方式</strong>：<code>field1</code>, <code>value1</code>, <code>field2</code>, <code>value2</code>, … 依次存放在一个连续的内存块中。</li>
<li><strong>优点</strong>：极其节省内存。</li>
<li><strong>缺点</strong>：每次查找、新增或删除操作都需要遍历这个列表，时间复杂度为 O(N)。当元素增多时，性能会下降。</li>
</ul>
</li>
<li><strong><code>hashtable</code> (哈希表)</strong>：<ul>
<li><strong>何时使用</strong>：当 <code>ziplist</code> 不再满足条件时，Redis会自动将底层结构转换为标准的哈希表。</li>
<li><strong>存储方式</strong>：与Java中的 <code>HashMap</code> 类似，通过哈希函数计算<code>field</code>的哈希值，解决哈希冲突，实现快速查找。</li>
<li><strong>优点</strong>：读写操作的平均时间复杂度为 O(1)，性能非常高。</li>
<li><strong>缺点</strong>：相比 <code>ziplist</code>，会占用更多的内存。</li>
</ul>
</li>
</ul>
<p><strong>转换触发条件</strong>（两个条件任意一个被破坏即转换）：</p>
<ol>
<li>哈希中元素（field-value对）的个数超过了 <code>hash-max-ziplist-entries</code> 配置的值（默认为512）。</li>
<li>哈希中任意一个 <code>value</code> 的长度超过了 <code>hash-max-ziplist-value</code> 配置的值（默认为64字节）。</li>
</ol>
<blockquote>
<p><strong>实践提示</strong>：你可以使用 <code>OBJECT ENCODING &lt;key&gt;</code> 命令来查看一个 <code>Hash</code> Key 当前的内部编码。</p>
</blockquote>
<hr>
<h3 id="3-3-常用命令"><a href="#3-3-常用命令" class="headerlink" title="3.3 常用命令"></a>3.3 常用命令</h3><ul>
<li><p><strong><code>HSET key field value [field value ...]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：设置哈希中一个或多个字段的值。如果字段已存在，则覆盖其值。如果哈希本身不存在，会先创建。</p>
</li>
<li><p><strong>注意</strong>：在Redis 4.0及以上版本，<code>HSET</code>可以同时设置多个字段，这使得 <code>HMSET</code> 成为历史。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HSET user:1001 name &quot;Bob&quot; age 30</span><br><span class="line">(integer) 2 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>HGET key field</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：获取哈希中指定字段的值。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HGET user:1001 name</span><br><span class="line">&quot;Bob&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>HGETALL key</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：获取哈希中所有的字段和值。返回一个包含字段和值的列表。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HGETALL user:1001</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;Bob&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;30&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>⚠️ 性能警告</strong>：当哈希中字段非常多时（成千上万），<code>HGETALL</code> 是一个<strong>慢操作</strong>，可能会阻塞Redis。在生产环境中，应优先使用 <code>HSCAN</code> 进行迭代获取。</p>
</li>
</ul>
</li>
<li><p><strong><code>HINCRBY key field increment</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：为哈希中指定字段的整数值增加指定的增量。<strong>此操作是原子性的</strong>。非常适合用于统计。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HINCRBY user:1001 login_count 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY user:1001 login_count 1</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>HMGET key field [field ...]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：获取哈希中一个或多个给定字段的值。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HMGET user:1001 name age email</span><br><span class="line">1) &quot;Bob&quot;</span><br><span class="line">2) &quot;30&quot;</span><br><span class="line">3) (nil)  # email字段不存在</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>HMSET key field value [field value ...]</code></strong>: <strong>(已废弃)</strong></p>
<ul>
<li>在旧版本中用于一次性设置多个字段。现在应直接使用 <code>HSET</code>。</li>
</ul>
</li>
<li><p><strong><code>HEXISTS key field</code></strong>: 判断哈希中是否存在指定的字段。</p>
</li>
<li><p><strong><code>HDEL key field [field ...]</code></strong>: 删除哈希中一个或多个字段。</p>
</li>
<li><p><strong><code>HLEN key</code></strong>: 获取哈希中字段的数量。</p>
</li>
</ul>
<hr>
<h3 id="3-4-应用场景"><a href="#3-4-应用场景" class="headerlink" title="3.4 应用场景"></a>3.4 应用场景</h3><p><strong>核心场景：存储对象（如用户信息、商品信息、购物车）</strong></p>
<p>这是 <code>Hash</code> 最经典的用途。让我们对比一下使用 <code>String</code> (存储JSON) 和 <code>Hash</code> 存储用户信息的区别：</p>
<p><strong>场景</strong>：存储一个用户对象，包含ID, name, age, city。</p>
<ul>
<li><strong>方案一：使用 <code>String</code> + JSON</strong><ul>
<li><strong>存储</strong>: <code>SET user:1001 &#39;{&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:25,&quot;city&quot;:&quot;New York&quot;}&#39;</code></li>
<li><strong>问题</strong>: 如果只想修改用户的年龄，你需要：<ol>
<li><code>GET user:1001</code> -&gt; 获得整个JSON字符串。</li>
<li>在你的Java应用中，将JSON反序列化为<code>User</code>对象。</li>
<li>修改对象的<code>age</code>属性。</li>
<li>将修改后的对象序列化回JSON字符串。</li>
<li><code>SET user:1001 &#39;{&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:26,&quot;city&quot;:&quot;New York&quot;}&#39;</code> -&gt; 将整个字符串写回Redis。</li>
</ol>
</li>
<li><strong>缺点</strong>：操作繁琐，网络开销大，序列化&#x2F;反序列化有性能损耗。</li>
</ul>
</li>
<li><strong>方案二：使用 <code>Hash</code> (推荐)</strong><ul>
<li><strong>存储</strong>: <code>HSET user:1001 name &quot;Alice&quot; age 25 city &quot;New York&quot;</code></li>
<li><strong>优势</strong>: 如果只想修改用户的年龄，你只需要一步：<ol>
<li><code>HSET user:1001 age 26</code></li>
</ol>
</li>
<li><strong>优点</strong>：<ol>
<li><strong>直观且易于管理</strong>：数据在Redis中结构化存储，可读性好。</li>
<li><strong>操作高效</strong>：只操作需要的字段，减少了网络流量和应用端的计算。</li>
<li><strong>节省内存</strong>：对于小对象，<code>ziplist</code>编码比一个等效的JSON字符串更节省内存。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>其他应用场景</strong>:</p>
<ul>
<li><strong>购物车</strong>：可以用一个哈希来表示一个用户的购物车。Key为<code>cart:userId</code>，<code>field</code>为商品ID，<code>value</code>为商品数量。<ul>
<li>添加商品：<code>HINCRBY cart:1001 product:A102 1</code></li>
<li>减少商品：<code>HINCRBY cart:1001 product:A102 -1</code></li>
<li>获取购物车所有商品：<code>HGETALL cart:1001</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-Set-集合"><a href="#4-Set-集合" class="headerlink" title="4. Set (集合)"></a>4. Set (集合)</h2><h3 id="4-1-是什么"><a href="#4-1-是什么" class="headerlink" title="4.1 是什么"></a>4.1 是什么</h3><p>Redis的 <code>Set</code> 类型是一个<strong>无序的、不重复的</strong>字符串集合。当你需要存储一个列表数据，又不希望出现重复数据时，<code>Set</code> 是一个非常好的选择。在概念上，它类似于Java中的 <code>java.util.Set</code>。</p>
<p><code>Set</code> 的核心特性：</p>
<ul>
<li><strong>无序性</strong>：<code>Set</code> 中的元素是无序的，你不能像 <code>List</code> 那样通过索引来获取元素。</li>
<li><strong>唯一性</strong>：<code>Set</code> 中不允许有重复的成员。向一个 <code>Set</code> 添加已存在的成员，该成员不会被再次添加，命令会返回0。</li>
<li><strong>集合操作</strong>：<code>Set</code> 提供了强大的集合间操作能力，如交集、并集、差集，这些操作在服务端完成，效率极高。</li>
</ul>
<p>一个 <code>Set</code> 最多可以包含 2³² - 1 个成员。</p>
<hr>
<h3 id="4-2-内部编码-底层实现：intset-或-hashtable"><a href="#4-2-内部编码-底层实现：intset-或-hashtable" class="headerlink" title="4.2 内部编码&#x2F;底层实现：intset 或 hashtable"></a>4.2 内部编码&#x2F;底层实现：<code>intset</code> 或 <code>hashtable</code></h3><p><code>Set</code> 的底层实现同样是根据存储的数据类型和数量动态选择的，以优化内存使用：</p>
<ul>
<li><strong><code>intset</code> (整数集合)</strong>：<ul>
<li><strong>何时使用</strong>：当集合中<strong>所有元素都是整数</strong>，并且元素的数量没有超过 <code>set-max-intset-entries</code> 配置的值（默认为512）时，Redis会使用 <code>intset</code> 来存储。</li>
<li><strong>结构</strong>：<code>intset</code> 是一个特殊编码的、有序的整数数组，它在内存上是连续的，非常节省空间。</li>
<li><strong>优点</strong>：极致的内存效率。</li>
<li><strong>缺点</strong>：因为是有序的，插入时可能需要移动元素。</li>
</ul>
</li>
<li><strong><code>hashtable</code> (哈希表)</strong>：<ul>
<li><strong>何时使用</strong>：当 <code>Set</code> 的存储不满足 <code>intset</code> 的条件时（例如，添加了一个非整数的字符串元素，或者元素数量超过了阈值），Redis会自动将其转换为 <code>hashtable</code>。</li>
<li><strong>结构</strong>：与 <code>Hash</code> 类型的底层 <code>hashtable</code> 类似，<code>Set</code> 的成员作为哈希表的键（key），而哈希表的值（value）则统一为一个虚拟的 <code>null</code> 值。</li>
<li><strong>优点</strong>：添加、删除、查找成员的平均时间复杂度都是 O(1)。</li>
<li><strong>缺点</strong>：比 <code>intset</code> 占用更多的内存。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>自动转换</strong>：这个转换过程对用户是透明的。比如一个<code>intset</code>，当你向其中<code>SADD</code>一个字符串”hello”时，它会自动升级为<code>hashtable</code>。</p>
</blockquote>
<hr>
<h3 id="4-3-常用命令"><a href="#4-3-常用命令" class="headerlink" title="4.3 常用命令"></a>4.3 常用命令</h3><ul>
<li><p><strong><code>SADD key member [member ...]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：向集合中添加一个或多个成员。返回成功添加的新成员数量。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SADD tags:post:1 &quot;redis&quot; &quot;database&quot; &quot;nosql&quot;</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SADD tags:post:1 &quot;redis&quot; &quot;cache&quot;</span><br><span class="line">(integer) 1  # &quot;redis&quot;已存在，只有&quot;cache&quot;被成功添加</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>SMEMBERS key</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：返回集合中的所有成员。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SMEMBERS tags:post:1</span><br><span class="line">1) &quot;nosql&quot;</span><br><span class="line">2) &quot;database&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">4) &quot;cache&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>⚠️ 性能警告</strong>：与 <code>HGETALL</code> 和 <code>KEYS</code> 类似，当集合非常大时，<code>SMEMBERS</code> 是一个慢命令，会阻塞Redis。在生产环境中，应使用 <code>SSCAN</code> 进行迭代获取。</p>
</li>
</ul>
</li>
<li><p><strong><code>SISMEMBER key member</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：判断一个成员是否是集合的成员。是则返回1，否则返回0。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SISMEMBER tags:post:1 &quot;redis&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER tags:post:1 &quot;java&quot;</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>SINTER / SUNION / SDIFF</code> (交集&#x2F;并集&#x2F;差集)</strong>:</p>
<ul>
<li><p><strong>这是Set的“杀手级”功能</strong>，非常适合进行关系运算。</p>
</li>
<li><p><strong><code>SINTER key [key ...]</code></strong>: 返回所有给定集合的<strong>交集</strong>。</p>
</li>
<li><p><strong><code>SUNION key [key ...]</code></strong>: 返回所有给定集合的<strong>并集</strong>。</p>
</li>
<li><p><strong><code>SDIFF key [key ...]</code></strong>: 返回第一个集合与其他集合的<strong>差集</strong>。</p>
</li>
<li><p><strong>实践</strong>（假设有两个用户喜欢的音乐集合）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SADD music:user:A &quot;JayChou&quot; &quot;TaylorSwift&quot; &quot;JJLin&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; SADD music:user:B &quot;JayChou&quot; &quot;EasonChan&quot; &quot;JJLin&quot;</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"># 交集：两人共同喜欢的歌手</span><br><span class="line">127.0.0.1:6379&gt; SINTER music:user:A music:user:B</span><br><span class="line">1) &quot;JayChou&quot;</span><br><span class="line">2) &quot;JJLin&quot;</span><br><span class="line"></span><br><span class="line"># 并集：两人喜欢的所有不重复的歌手</span><br><span class="line">127.0.0.1:6379&gt; SUNION music:user:A music:user:B</span><br><span class="line">1) &quot;TaylorSwift&quot;</span><br><span class="line">2) &quot;EasonChan&quot;</span><br><span class="line">3) &quot;JayChou&quot;</span><br><span class="line">4) &quot;JJLin&quot;</span><br><span class="line"></span><br><span class="line"># 差集：A喜欢但B不喜欢的歌手</span><br><span class="line">127.0.0.1:6379&gt; SDIFF music:user:A music:user:B</span><br><span class="line">1) &quot;TaylorSwift&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有 <code>SINTERSTORE</code>, <code>SUNIONSTORE</code>, <code>SDIFFSTORE</code> 命令，可以将计算结果保存到一个新的Set中，方便后续使用。</p>
</li>
</ul>
</li>
<li><p><strong><code>SPOP key [count]</code></strong>: 随机移除并返回集合中一个或多个成员。</p>
</li>
<li><p><strong><code>SRANDMEMBER key [count]</code></strong>: 随机返回集合中一个或多个成员，但<strong>不移除</strong>它们。</p>
</li>
<li><p><strong><code>SCARD key</code></strong>: 返回集合的基数（成员数量）。</p>
</li>
</ul>
<hr>
<h3 id="4-4-应用场景"><a href="#4-4-应用场景" class="headerlink" title="4.4 应用场景"></a>4.4 应用场景</h3><ol>
<li><strong>标签系统（Tagging）</strong><ul>
<li><strong>描述</strong>：为文章、用户、商品等对象打上标签。</li>
<li><strong>实现</strong>：为每个对象创建一个Set，Key为 <code>tags:&lt;object_type&gt;:&lt;object_id&gt;</code>，成员为标签名。<ul>
<li><code>SADD tags:post:123 &quot;redis&quot; &quot;nosql&quot; &quot;database&quot;</code>：给第123号文章打上三个标签。</li>
</ul>
</li>
<li><strong>扩展</strong>：可以很容易地找出具有共同标签的对象。例如，要找同时有 “redis” 和 “database” 标签的文章，可以通过对标签的倒排索引进行交集运算。</li>
</ul>
</li>
<li><strong>共同好友&#x2F;关注（Common Friends&#x2F;Followers）</strong><ul>
<li><strong>描述</strong>：在社交网络中，计算两个用户之间的共同好友或共同关注。</li>
<li><strong>实现</strong>：为每个用户创建一个Set，存储其好友或关注的ID列表。<ul>
<li><code>SADD friends:userA userB userC userD</code></li>
<li><code>SADD friends:userB userA userC userE</code></li>
<li>要计算<code>userA</code>和<code>userB</code>的共同好友，只需执行：<code>SINTER friends:userA friends:userB</code>。这个操作在Redis中执行得极快，远胜于在关系型数据库中进行复杂的<code>JOIN</code>查询。</li>
</ul>
</li>
</ul>
</li>
<li><strong>抽奖系统&#x2F;随机事件（Lottery）</strong><ul>
<li><strong>描述</strong>：从一个参与者池中随机抽取一个或多个中奖者，并确保每个参与者只能参与一次。</li>
<li><strong>实现</strong>：<ol>
<li><strong>参与</strong>：使用 <code>SADD lottery_participants &lt;user_id&gt;</code> 将参与用户ID加入集合。<code>SADD</code>的唯一性保证了用户不会重复参与。</li>
<li><strong>开奖</strong>：<ul>
<li><strong>不放回抽奖</strong>（抽一个少一个）：使用 <code>SPOP lottery_participants 5</code> 随机弹出5个中奖者。</li>
<li><strong>可重复中奖或仅查看</strong>：使用 <code>SRANDMEMBER lottery_participants 5</code> 随机选出5个“幸运儿”，但他们仍在奖池中。</li>
</ul>
</li>
</ol>
</li>
<li><strong>统计参与人数</strong>：使用 <code>SCARD lottery_participants</code> 快速获取总参与人数。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="5-Sorted-Set-ZSet-有序集合"><a href="#5-Sorted-Set-ZSet-有序集合" class="headerlink" title="5. Sorted Set (ZSet, 有序集合)"></a>5. Sorted Set (ZSet, 有序集合)</h2><h3 id="5-1-是什么"><a href="#5-1-是什么" class="headerlink" title="5.1 是什么"></a>5.1 是什么</h3><p><code>Sorted Set</code>（有序集合），简称 <code>ZSet</code>，是 <code>Set</code> 的一个升级版。它同样是一个<strong>不允许重复成员</strong>的字符串集合，但与 <code>Set</code> 不同的是，<code>ZSet</code> 的每个成员都会关联一个<strong>双精度浮点数类型的分数（score）</strong>。Redis正是通过这个分数来为集合中的成员进行<strong>从小到大</strong>的排序。</p>
<p><code>ZSet</code> 的核心特性：</p>
<ul>
<li><strong>唯一性</strong>：和 <code>Set</code> 一样，成员（member）是唯一的。</li>
<li><strong>有序性</strong>：每个成员都有一个分数（score），<code>ZSet</code> 内部会根据分数自动排序。如果分数相同，则按成员的字典序排序。</li>
<li><strong>高效访问</strong>：<code>ZSet</code> 既能像 <code>Set</code> 一样快速判断成员是否存在，也能像 <code>List</code> 一样通过排名（rank）快速获取成员。</li>
</ul>
<p>可以把它看作是Java中的 <code>java.util.TreeMap</code> 或者 <code>SortedSet</code>，其中成员是key，分数是用于排序的值。</p>
<hr>
<h3 id="5-2-底层实现：ziplist-或-skiplist-hashtable"><a href="#5-2-底层实现：ziplist-或-skiplist-hashtable" class="headerlink" title="5.2 底层实现：ziplist 或 skiplist + hashtable"></a>5.2 底层实现：<code>ziplist</code> 或 <code>skiplist</code> + <code>hashtable</code></h3><p><code>ZSet</code>的底层实现是Redis数据结构设计的精髓体现，它也采用了两种编码方式，并会自动转换：</p>
<ul>
<li><strong><code>ziplist</code> (压缩列表)</strong>：<ul>
<li><strong>何时使用</strong>：当有序集合的成员数量较少，并且每个成员和分数都比较小时。</li>
<li><strong>结构</strong>：在 <code>ziplist</code> 内部，成员（member）和分数（score）成对存放，并按分数从小到大排序。</li>
<li><strong>优点</strong>：非常节省内存。</li>
<li><strong>缺点</strong>：查找和修改操作的时间复杂度是 O(N)，性能随元素增多而下降。</li>
</ul>
</li>
<li><strong><code>skiplist</code> (跳表) + <code>hashtable</code> (哈希表)</strong>：<ul>
<li><strong>何时使用</strong>：当不满足 <code>ziplist</code> 的条件时（成员数量超过 <code>zset-max-ziplist-entries</code> 或成员长度超过 <code>zset-max-ziplist-value</code>），<code>ZSet</code> 会转换成这种复杂但高效的结构。</li>
<li><strong>这是 <code>ZSet</code> 的标准实现，也是其高性能的关键</strong>。<ul>
<li><strong><code>skiplist</code> (跳表)</strong>：一种概率性数据结构，可以看作是多层链表。它通过层级结构，实现了平均 O(logN) 的查找、插入、删除复杂度，性能媲美平衡树，但实现更简单。在 <code>ZSet</code> 中，跳表负责<strong>按分数排序</strong>，支持高效的范围查询。</li>
<li><strong><code>hashtable</code> (哈希表)</strong>：哈希表存储了<strong>成员到分数的映射</strong>。它负责以 O(1) 的时间复杂度快速查找指定成员的分数（<code>ZSCORE</code> 命令）或判断成员是否存在。</li>
</ul>
</li>
<li><strong>协同工作</strong>：<code>skiplist</code> 和 <code>hashtable</code> 通过指针共享成员和分数，两者共同维护 <code>ZSet</code> 的数据。<code>skiplist</code>保证了有序性，<code>hashtable</code>保证了高效的单点查询。这种组合使得<code>ZSet</code>在各种操作上都表现出色。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-3-常用命令"><a href="#5-3-常用命令" class="headerlink" title="5.3 常用命令"></a>5.3 常用命令</h3><ul>
<li><p><strong><code>ZADD key score member [score member ...]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：向有序集合添加一个或多个成员，或者更新已存在成员的分数。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD game:rank 1500 &quot;Alice&quot; 2200 &quot;Bob&quot; 1800 &quot;Charlie&quot;</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"># 更新Alice的分数</span><br><span class="line">127.0.0.1:6379&gt; ZADD game:rank 1650 &quot;Alice&quot;</span><br><span class="line">(integer) 0  # 因为Alice是更新，不是新增，所以返回0</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>ZRANGE key start stop [WITHSCORES]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：按分数<strong>从小到大</strong>（升序）返回指定排名范围内的成员。<code>start</code>和<code>stop</code>是排名索引（从0开始）。</p>
</li>
<li><p><strong><code>WITHSCORES</code></strong> 选项可以同时返回成员和其分数。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 获取排名前3的玩家</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE game:rank 0 2 WITHSCORES</span><br><span class="line">1) &quot;Alice&quot;</span><br><span class="line">2) &quot;1650&quot;</span><br><span class="line">3) &quot;Charlie&quot;</span><br><span class="line">4) &quot;1800&quot;</span><br><span class="line">5) &quot;Bob&quot;</span><br><span class="line">6) &quot;2200&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>ZREVRANGE key start stop [WITHSCORES]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：与 <code>ZRANGE</code> 相反，按分数<strong>从大到小</strong>（降序）返回排名范围内的成员。<strong>这是实现排行榜的关键命令</strong>。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 获取积分榜TOP 3</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE game:rank 0 2 WITHSCORES</span><br><span class="line">1) &quot;Bob&quot;</span><br><span class="line">2) &quot;2200&quot;</span><br><span class="line">3) &quot;Charlie&quot;</span><br><span class="line">4) &quot;1800&quot;</span><br><span class="line">5) &quot;Alice&quot;</span><br><span class="line">6) &quot;1650&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>ZRANK key member</code> &#x2F; <code>ZREVRANK key member</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：返回成员在有序集合中的排名（<code>ZRANK</code>是升序排名，<code>ZREVRANK</code>是降序排名），排名从0开始。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 查询Alice在积分榜（降序）中的排名</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK game:rank &quot;Alice&quot;</span><br><span class="line">(integer) 2  # 排名第3，索引为2</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>ZSCORE key member</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：返回成员的分数。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZSCORE game:rank &quot;Bob&quot;</span><br><span class="line">&quot;2200&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>ZRANGEBYSCORE key min max [WITHSCORES]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：按分数范围返回成员。<code>min</code>和<code>max</code>是分数。可以使用 <code>(</code> 表示不包含边界值。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 获取分数在[1800, 2500]之间的所有玩家</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE game:rank 1800 2500 WITHSCORES</span><br><span class="line">1) &quot;Charlie&quot;</span><br><span class="line">2) &quot;1800&quot;</span><br><span class="line">3) &quot;Bob&quot;</span><br><span class="line">4) &quot;2200&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>ZINCRBY key increment member</code></strong>: 为成员的分数增加<code>increment</code>，原子操作。</p>
</li>
<li><p><strong><code>ZCARD key</code></strong>: 返回有序集合的成员数量。</p>
</li>
<li><p><strong><code>ZCOUNT key min max</code></strong>: 返回分数在<code>min</code>和<code>max</code>之间的成员数量。</p>
</li>
<li><p><strong><code>ZREM key member [member ...]</code></strong>: 移除一个或多个成员。</p>
</li>
</ul>
<hr>
<h3 id="5-4-应用场景"><a href="#5-4-应用场景" class="headerlink" title="5.4 应用场景"></a>5.4 应用场景</h3><ol>
<li><p><strong>排行榜（Leaderboard）</strong></p>
<ul>
<li><strong>描述</strong>：这是 <code>ZSet</code> 最经典、最完美的应用场景。例如游戏积分榜、商品销量榜、热搜榜等。</li>
<li><strong>实现</strong>：<ul>
<li>使用 <code>ZADD</code> 更新用户积分：<code>ZADD sales_board 202310 iphone15</code>。</li>
<li>使用 <code>ZREVRANGE</code> 获取TOP N榜单：<code>ZREVRANGE sales_board 0 9 WITHSCORES</code>。</li>
<li>使用 <code>ZREVRANK</code> 查询某个用户的排名。</li>
<li>使用 <code>ZINCRBY</code> 累加用户的积分&#x2F;销量，例如 <code>ZINCRBY user_scores 100 user_A</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>延迟队列（Delayed Queue）</strong></p>
<ul>
<li><p><strong>描述</strong>：需要将任务推迟到未来的某个特定时间点执行。例如，订单创建30分钟后自动取消未支付的订单。</p>
</li>
<li><p><strong>实现</strong>：</p>
<ul>
<li><p><strong>生产者</strong>：使用 <code>ZADD</code> 将任务加入队列。<strong><code>member</code></strong> 是任务的唯一标识（如订单ID），<strong><code>score</code></strong> 是任务的<strong>执行时间戳</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 当前时间戳是 1700000000，30分钟后是 1700001800</span><br><span class="line">ZADD delayed_tasks 1700001800 &quot;order:123&quot; </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>消费者</strong>：一个后台轮询进程，不断地执行以下操作：</p>
<ol>
<li>使用 <code>ZRANGEBYSCORE delayed_tasks 0 &lt;current_timestamp&gt; LIMIT 0 1</code> 查询分数小于等于当前时间戳的第一个任务（即已到期的任务）。</li>
<li>如果查询到任务，尝试使用 <code>ZREM</code> 命令从队列中删除它。<code>ZREM</code> 返回1表示抢占成功。</li>
<li>抢占成功的消费者开始执行任务。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>优点</strong>：利用 <code>ZSet</code> 的排序特性，可以非常高效地获取到期任务。</p>
</li>
</ul>
</li>
<li><p><strong>范围查找（Range Queries）</strong></p>
<ul>
<li><strong>描述</strong>：需要根据某个权重、分数或时间戳来查找一个范围内的项目。</li>
<li><strong>实现</strong>：利用 <code>ZRANGEBYSCORE</code> 或 <code>ZREVRANGEBYSCORE</code>。</li>
<li><strong>示例</strong>：<ul>
<li>查找工资在5000到10000之间的员工。</li>
<li>在一个论坛中，实现“按点赞数筛选帖子”。Key是<code>post_votes</code>，member是帖子ID，score是点赞数。用户想看点赞数超过100的帖子，就可以用<code>ZRANGEBYSCORE post_votes 100 +inf</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="6-其他高级数据结构"><a href="#6-其他高级数据结构" class="headerlink" title="6. 其他高级数据结构"></a>6. 其他高级数据结构</h2><h3 id="6-1-Bitmap-位图"><a href="#6-1-Bitmap-位图" class="headerlink" title="6.1 Bitmap (位图)"></a>6.1 Bitmap (位图)</h3><ul>
<li><p><strong>是什么</strong>：<br><code>Bitmap</code> 本身并不是一种独立的数据结构，它是在 <strong><code>String</code> 类型</strong>上实现的一系列位操作。你可以把一个 <code>String</code> 看作是一个无限大的 <code>bit</code> 数组，每个 <code>bit</code> 只有 <code>0</code> 和 <code>1</code> 两种状态。<code>Bitmap</code> 就是通过直接操作这些位来进行存储和计算。</p>
<p>它的最大优势是<strong>极度节省内存</strong>。例如，要记录1亿用户的签到状态，如果用<code>Set</code>或<code>Hash</code>，每个用户ID都需要占用存储空间。而使用<code>Bitmap</code>，只需要 <code>100,000,000 bit ≈ 12.5 MB</code> 的空间即可。</p>
</li>
<li><p><strong>核心命令</strong>：</p>
<ul>
<li><p><strong><code>SETBIT key offset value</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：将 <code>key</code> 对应的 <code>Bitmap</code> 在指定 <code>offset</code> (偏移量&#x2F;索引) 上的位设置为 <code>value</code> (0或1)。<code>offset</code> 可以非常大。</p>
</li>
<li><p><strong>实践</strong>（用户签到）：假设用户ID是整数。用户<code>1001</code>在2023年12月5日签到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Key可以是 &#x27;signin:2023-12-05&#x27;</span><br><span class="line"># offset 可以是用户ID</span><br><span class="line">127.0.0.1:6379&gt; SETBIT signin:2023-12-05 1001 1</span><br><span class="line">(integer) 0  # 返回该位原来的值</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>GETBIT key offset</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：获取指定 <code>offset</code> 上的位的值。</p>
</li>
<li><p><strong>实践</strong>：判断用户 <code>1001</code> 今天是否签到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GETBIT signin:2023-12-05 1001</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>BITCOUNT key [start end]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：统计 <code>Bitmap</code> 中值为 <code>1</code> 的位的数量。可以指定字节范围进行统计。</p>
</li>
<li><p><strong>实践</strong>：统计今天有多少人签到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BITCOUNT signin:2023-12-05</span><br><span class="line">(integer) 12345  # 假设有12345人签到</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>BITOP operation destkey key [key ...]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：对一个或多个 <code>Bitmap</code> 进行位运算（AND, OR, XOR, NOT），并将结果保存到 <code>destkey</code>。</p>
</li>
<li><p><strong>实践</strong>：计算最近3天都连续签到的用户。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BITOP AND consecutive_3days signin:2023-12-03 signin:2023-12-04 signin:2023-12-05</span><br><span class="line"># 之后用BITCOUNT统计consecutive_3days即可得到连续签到人数</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li><strong>用户签到&#x2F;打卡</strong>：用日期作为Key，用户ID作为offset。</li>
<li><strong>在线状态统计</strong>：用一个 <code>online_users</code> 的Key，用户ID作为offset。用户上线时<code>SETBIT 1</code>，下线时<code>SETBIT 0</code>。</li>
<li><strong>用户画像&#x2F;标签</strong>：例如，<code>user:has_car</code>，<code>user:is_male</code> 等二值状态的标签。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-2-HyperLogLog"><a href="#6-2-HyperLogLog" class="headerlink" title="6.2 HyperLogLog"></a>6.2 HyperLogLog</h3><ul>
<li><p><strong>是什么</strong>：<br><code>HyperLogLog</code> (HLL) 是一种<strong>概率性数据结构</strong>，它用于进行<strong>基数估算（Cardinality Estimation）</strong>。通俗地说，就是用极小的内存空间来估算一个集合中不重复元素的数量。</p>
<p>例如，要统计一个网站一天的独立访客数（UV），如果用<code>Set</code>，每个访客ID都要存储，当UV达到千万级时，内存消耗巨大。而HLL只需要固定的 <strong>12KB</strong> 内存，就可以估算出高达 2⁶⁴ 个元素的基数，且标准误差仅为 <strong>0.81%</strong>。</p>
</li>
<li><p><strong>核心命令</strong>：</p>
<ul>
<li><p><strong><code>PFADD key element [element ...]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：向 <code>HyperLogLog</code> 添加一个或多个元素。类似于 <code>SADD</code>，但它不精确存储元素本身。</p>
</li>
<li><p><strong>实践</strong>：记录访问页面的用户ID。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Key可以是 &#x27;uv:page:/home:2023-12-05&#x27;</span><br><span class="line">127.0.0.1:6379&gt; PFADD uv:page:/home:2023-12-05 &quot;user_A&quot; &quot;user_B&quot; &quot;user_A&quot;</span><br><span class="line">(integer) 1 # 返回1表示内部的估计值发生了变化</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>PFCOUNT key [key ...]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：返回一个或多个 <code>HyperLogLog</code> 的基数估算值。如果指定多个key，则返回它们的并集的基数估算值。</p>
</li>
<li><p><strong>实践</strong>：获取首页今天的UV。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PFCOUNT uv:page:/home:2023-12-05</span><br><span class="line">(integer) 2 # 估算出的不重复用户数为2</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>PFMERGE destkey sourcekey [sourcekey ...]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：将多个 <code>HyperLogLog</code> 合并成一个，用于计算并集的基数。</p>
</li>
<li><p><strong>实践</strong>：计算整个网站今天的总UV。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PFMERGE uv:website:2023-12-05 uv:page:/home:2023-12-05 uv:page:/product:2023-12-05</span><br><span class="line">PFCOUNT uv:website:2023-12-05</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li><strong>UV统计</strong>：网站、App的日活、月活等不重复用户数的统计。</li>
<li><strong>大数据去重</strong>：在海量数据处理中，快速估算不重复元素的数量。</li>
<li>任何<strong>不需要精确数字</strong>，但对内存消耗非常敏感的基数统计场景。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-3-Geospatial-地理空间"><a href="#6-3-Geospatial-地理空间" class="headerlink" title="6.3 Geospatial (地理空间)"></a>6.3 Geospatial (地理空间)</h3><ul>
<li><p><strong>是什么</strong>：<br>Redis <code>Geospatial</code> 是在 <strong><code>Sorted Set</code> (ZSet)</strong> 类型上实现的一套地理位置处理功能。它通过 <strong>Geohash</strong> 算法，将二维的经纬度坐标编码成一个一维的分数（score），然后存储在<code>ZSet</code>中。这使得在<code>ZSet</code>上进行范围查找（<code>ZRANGEBYSCORE</code>）就等同于在地理上进行邻近搜索。</p>
</li>
<li><p><strong>核心命令</strong>：</p>
<ul>
<li><p><strong><code>GEOADD key longitude latitude member [longitude latitude member ...]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：将一个或多个地理位置（经度、纬度、成员名）添加到指定的key中。</p>
</li>
<li><p><strong>实践</strong>：添加几个商家位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 注意：经度(longitude)在前，纬度(latitude)在后</span><br><span class="line">127.0.0.1:6379&gt; GEOADD merchants 116.404269 39.913164 &quot;tiananmen&quot; 116.417359 39.907409 &quot;wangfujing&quot;</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>GEODIST key member1 member2 [unit]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：计算两个成员之间的直线距离。<code>unit</code>可以是 <code>m</code> (米), <code>km</code> (千米), <code>mi</code> (英里), <code>ft</code> (英尺)。默认是米。</p>
</li>
<li><p><strong>实践</strong>：计算天安门到王府井的距离。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEODIST merchants &quot;tiananmen&quot; &quot;wangfujing&quot; km</span><br><span class="line">&quot;1.2725&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>GEORADIUS key longitude latitude radius unit [WITHDIST] [WITHCOORD] [COUNT count] [ASC|DESC]</code></strong>:</p>
<ul>
<li><p><strong>用途</strong>：<strong>核心功能</strong>。以给定的经纬度为中心，找出指定半径内的所有成员。</p>
</li>
<li><p><strong>选项</strong>：</p>
<ul>
<li><code>WITHDIST</code>: 同时返回成员与中心点的距离。</li>
<li><code>WITHCOORD</code>: 同时返回成员的经纬度。</li>
<li><code>COUNT count</code>: 限定返回结果的数量。</li>
<li><code>ASC|DESC</code>: 按距离升序或降序排序。</li>
</ul>
</li>
<li><p><strong>实践</strong>：查找离天安门2公里内的商家，最多返回5个，并显示距离。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEORADIUS merchants 116.404269 39.913164 2 km WITHDIST COUNT 5 ASC</span><br><span class="line">1) 1) &quot;tiananmen&quot;</span><br><span class="line">   2) &quot;0.0000&quot;</span><br><span class="line">2) 1) &quot;wangfujing&quot;</span><br><span class="line">   2) &quot;1.2725&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>GEORADIUSBYMEMBER</code></strong>: 与<code>GEORADIUS</code>类似，但中心点不是经纬度，而是已存在的成员。</p>
</li>
<li><p><strong><code>GEOHASH</code></strong>: 返回一个或多个成员的Geohash字符串。</p>
</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li><strong>附近的人&#x2F;地点</strong>：社交应用中的“附近的人”，外卖App中的“附近的商家”。</li>
<li><strong>打车应用</strong>：计算乘客与附近车辆的距离，进行订单匹配。</li>
<li><strong>位置打卡</strong>：判断用户当前位置是否在某个指定区域内。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="四、Java实战集成-Java开发者核心"><a href="#四、Java实战集成-Java开发者核心" class="headerlink" title="四、Java实战集成 (Java开发者核心)"></a>四、Java实战集成 (Java开发者核心)</h1><h2 id="1-Redis客户端选型"><a href="#1-Redis客户端选型" class="headerlink" title="1. Redis客户端选型"></a>1. Redis客户端选型</h2><p>在Java生态中，与Redis交互的主流客户端有Jedis、Lettuce和Redisson。它们各有优劣，选择哪个取决于你的项目需求、技术栈以及对并发模型和功能丰富度的要求。</p>
<h3 id="1-1-Jedis"><a href="#1-1-Jedis" class="headerlink" title="1.1 Jedis"></a>1.1 Jedis</h3><ul>
<li><p><strong>简介</strong>：Jedis是早期非常流行的Redis Java客户端，API设计直观，与Redis原生命令高度相似，学习成本低。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li><p><strong>线程不安全</strong>：Jedis的实例不是线程安全的。在多线程环境中使用时，必须通过<strong>连接池</strong>（如<code>JedisPool</code>）来为每个线程分配一个独立的Jedis实例。使用完毕后，必须将实例归还给连接池，否则会造成连接泄漏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource()) &#123;</span><br><span class="line">    jedis.set(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>同步阻塞I&#x2F;O (BIO)</strong>：Jedis的通信模型是同步阻塞的。当一个线程发送命令后，它会一直阻塞等待Redis的响应。在高并发场景下，这会消耗大量线程资源，如果线程池耗尽，系统吞吐量会急剧下降。</p>
</li>
<li><p><strong>功能相对基础</strong>：主要提供Redis原生命令的封装，对于分布式锁、集合等高级功能的实现需要开发者自己手动封装，较为繁琐且容易出错。</p>
</li>
<li><p><strong>不支持异步</strong>：没有原生的异步API。</p>
</li>
</ul>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>API简洁，与Redis命令一一对应，上手快。</li>
<li>轻量，引入的依赖少。</li>
<li>在简单的、非高并发的场景下表现良好。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>同步阻塞模型在并发高时性能瓶颈明显。</li>
<li>连接池模式下，频繁地借用和归还连接有一定开销。</li>
<li>需要手动管理连接，容易出错。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li>项目并发量不高，或者对Redis的性能要求不是极致。</li>
<li>团队希望快速上手，熟悉Redis原生命令。</li>
<li>老项目维护，已经在使用Jedis。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-Lettuce"><a href="#1-2-Lettuce" class="headerlink" title="1.2 Lettuce"></a>1.2 Lettuce</h3><ul>
<li><strong>简介</strong>：Lettuce是一个可伸缩的、线程安全的、基于<strong>Netty</strong>的先进Redis客户端。<strong>Spring Boot 2.x 之后默认集成的就是Lettuce</strong>。</li>
<li><strong>特点</strong>：<ul>
<li><strong>线程安全</strong>：Lettuce的连接实例（<code>RedisConnection</code>）是线程安全的。多个线程可以<strong>共享同一个连接实例</strong>来并发地发送命令，而无需使用连接池。这大大减少了连接数和线程开销。</li>
<li><strong>异步非阻塞I&#x2F;O (NIO)</strong>：底层基于Netty实现，采用异步和事件驱动模型。发送命令后，可以立即返回一个<code>CompletableFuture</code>，不会阻塞当前线程。这使得Lettuce能用较少的线程处理极高的并发量，吞吐量远超Jedis。</li>
<li><strong>支持同步、异步和响应式(Reactive)编程</strong>：<ul>
<li><strong>同步API</strong>：Lettuce也提供了一套同步API，用法与Jedis类似，但其底层仍然是异步执行。</li>
<li><strong>异步API</strong>：返回<code>CompletableFuture</code>，可以方便地进行链式调用和组合。</li>
<li><strong>响应式API</strong>：与Project Reactor等响应式框架无缝集成，是构建响应式应用的绝佳选择。</li>
</ul>
</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>性能卓越，吞吐量高，资源占用少。</li>
<li>线程安全，简化了并发编程。</li>
<li>一套API支持多种编程模型，非常灵活。</li>
<li>Spring Boot官方推荐和默认集成，生态支持好。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>API比Jedis稍复杂，尤其是在使用异步和响应式时，有一定学习曲线。</li>
<li>基于Netty，引入的依赖相对较重。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li><strong>绝大多数新项目，尤其是高并发的互联网应用</strong>。</li>
<li>Spring Boot项目（天然集成）。</li>
<li>需要使用异步或响应式编程模型的项目。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-Redisson"><a href="#1-3-Redisson" class="headerlink" title="1.3 Redisson"></a>1.3 Redisson</h3><ul>
<li><strong>简介</strong>：Redisson不仅仅是一个Redis客户端，它更是一个基于Redis的<strong>分布式Java对象和服务框架</strong>。它的目标是让开发者像使用本地Java对象一样使用Redis。</li>
<li><strong>特点</strong>：<ul>
<li><strong>高级功能封装</strong>：Redisson最大的亮点是提供了大量开箱即用的<strong>分布式对象和服务</strong>。你无需关心底层实现细节，可以直接使用：<ul>
<li><strong>可重入锁 (RLock)</strong>、公平锁、读写锁、红锁等多种分布式锁实现。</li>
<li>分布式集合，如<code>RMap</code>, <code>RSet</code>, <code>RList</code>，它们的接口与<code>java.util.Map</code>, <code>java.util.Set</code>, <code>java.util.List</code>几乎完全一致。</li>
<li>分布式原子类，如<code>RAtomicLong</code>。</li>
<li>分布式信号量、倒计时门闩 (<code>RCountDownLatch</code>) 等。</li>
</ul>
</li>
<li><strong>线程安全与异步</strong>：与Lettuce一样，底层基于Netty，也是线程安全的，并提供同步和异步API。</li>
<li><strong>看门狗机制 (Watchdog)</strong>：它的分布式锁实现包含一个“看门狗”机制，能自动为即将过期的锁续期，有效防止了业务处理时间过长导致锁被自动释放的问题，大大提升了分布式锁的可靠性。</li>
<li><strong>与主流框架集成</strong>：提供了对Spring、JCache等规范的集成支持。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>功能极其丰富，大大降低了开发分布式应用的门槛。</li>
<li>分布式锁的实现非常完善和健壮，是业内公认的标杆。</li>
<li>API设计对Java开发者非常友好，面向对象。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>相对“重”，引入了较多依赖和封装，学习成本比前两者更高。</li>
<li>封装层次较深，对于简单的KV操作，性能可能略低于Lettuce和Jedis，但在复杂场景下，其带来的开发效率提升远超这点性能差异。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li>需要大量使用<strong>分布式锁</strong>、<strong>分布式集合</strong>等高级分布式功能的复杂系统。</li>
<li>希望以面向对象的方式操作Redis，简化开发。</li>
<li>对分布式工具的可靠性要求非常高。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-4-总结对比表"><a href="#1-4-总结对比表" class="headerlink" title="1.4 总结对比表"></a>1.4 总结对比表</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Jedis</th>
<th align="left">Lettuce</th>
<th align="left">Redisson</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>线程安全</strong></td>
<td align="left"><strong>不安全</strong> (需用连接池)</td>
<td align="left"><strong>安全</strong> (可共享连接)</td>
<td align="left"><strong>安全</strong> (可共享连接)</td>
</tr>
<tr>
<td align="left"><strong>I&#x2F;O模型</strong></td>
<td align="left">同步阻塞 (BIO)</td>
<td align="left">异步非阻塞 (NIO)</td>
<td align="left">异步非阻塞 (NIO)</td>
</tr>
<tr>
<td align="left"><strong>编程模型</strong></td>
<td align="left">同步</td>
<td align="left"><strong>同步、异步、响应式</strong></td>
<td align="left">同步、异步</td>
</tr>
<tr>
<td align="left"><strong>性能&#x2F;吞吐量</strong></td>
<td align="left">一般</td>
<td align="left"><strong>极高</strong></td>
<td align="left">很高</td>
</tr>
<tr>
<td align="left"><strong>功能丰富度</strong></td>
<td align="left">基础 (原生命令)</td>
<td align="left">中等 (原生命令+异步)</td>
<td align="left"><strong>极高</strong> (分布式对象&#x2F;服务)</td>
</tr>
<tr>
<td align="left"><strong>分布式锁</strong></td>
<td align="left">需手动实现，易出错</td>
<td align="left">需手动实现</td>
<td align="left"><strong>内置完善实现 (RLock)</strong></td>
</tr>
<tr>
<td align="left"><strong>学习成本</strong></td>
<td align="left"><strong>低</strong></td>
<td align="left">中</td>
<td align="left">高</td>
</tr>
<tr>
<td align="left"><strong>Spring Boot集成</strong></td>
<td align="left">需手动切换和配置</td>
<td align="left"><strong>2.x后默认集成</strong></td>
<td align="left">需单独引入starter</td>
</tr>
<tr>
<td align="left"><strong>核心优势</strong></td>
<td align="left">简单、轻量</td>
<td align="left"><strong>高性能、高吞吐</strong></td>
<td align="left"><strong>功能强大、易用的分布式工具</strong></td>
</tr>
</tbody></table>
<p><strong>如何选择？</strong></p>
<ul>
<li><strong>简单场景&#x2F;老项目</strong>：如果只是做简单的KV缓存，并发不高，<code>Jedis</code> 足够用。</li>
<li><strong>新项目&#x2F;高并发</strong>：<strong>首选 <code>Lettuce</code></strong>。它是Spring Boot的默认选择，性能优异，能满足绝大部分需求。</li>
<li><strong>复杂分布式场景</strong>：当你需要可靠的分布式锁、分布式集合等高级功能时，<strong>强烈推荐 <code>Redisson</code></strong>。它能让你把精力集中在业务逻辑上，而不是花费大量时间去造轮子和踩坑。</li>
</ul>
<p>在实际项目中，甚至可以<strong>组合使用</strong>：主体使用Spring Boot集成的<code>RedisTemplate</code>（底层是Lettuce）进行常规操作，当需要分布式锁时，单独引入<code>Redisson</code>来使用它的<code>RLock</code>。</p>
<hr>
<h2 id="2-Spring-Boot-集成-Redis"><a href="#2-Spring-Boot-集成-Redis" class="headerlink" title="2. Spring Boot 集成 Redis"></a>2. Spring Boot 集成 Redis</h2><p>Spring Boot通过<code>spring-boot-starter-data-redis</code>为Redis提供了强大的自动化配置和便捷的API，使得在Spring应用中使用Redis变得异常简单。</p>
<h3 id="2-1-引入-spring-boot-starter-data-redis"><a href="#2-1-引入-spring-boot-starter-data-redis" class="headerlink" title="2.1 引入 spring-boot-starter-data-redis"></a>2.1 引入 <code>spring-boot-starter-data-redis</code></h3><p>要在你的Spring Boot项目中使用Redis，首先需要在<code>pom.xml</code>（Maven项目）或<code>build.gradle</code>（Gradle项目）中添加相应的依赖。</p>
<p><strong>Maven (<code>pom.xml</code>):</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个<code>starter</code>会做几件重要的事情：</p>
<ol>
<li><strong>引入核心依赖</strong>：包括<code>spring-data-redis</code>和默认的Redis客户端<code>Lettuce</code>。</li>
<li><strong>自动化配置</strong>：自动配置<code>RedisConnectionFactory</code>、<code>RedisTemplate</code>等核心Bean。你只需要在配置文件中提供Redis的连接信息即可。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：<code>spring-boot-starter-data-redis</code>默认使用<code>Lettuce</code>作为客户端。如果你想换回<code>Jedis</code>，需要先在<code>pom.xml</code>中排除<code>lettuce-core</code>，再引入<code>jedis</code>依赖。但不推荐这样做，除非有特殊理由。</p>
</blockquote>
<hr>
<h3 id="2-2-application-yml-配置详解"><a href="#2-2-application-yml-配置详解" class="headerlink" title="2.2 application.yml 配置详解"></a>2.2 <code>application.yml</code> 配置详解</h3><p>在<code>application.yml</code>或<code>application.properties</code>中，你可以对Redis进行详细的配置。以下是一个包含常用配置项的<code>yml</code>示例及其详解：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment"># Redis服务器地址</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="comment"># Redis服务器端口</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment"># Redis服务器连接密码（默认为空）</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">your_password</span></span><br><span class="line">    <span class="comment"># 使用的数据库索引（默认为0）</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">3000ms</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 连接池配置 (基于Lettuce) ---</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="comment"># 连接池中的最大连接数（-1表示不限制）</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment"># 连接池中的最大空闲连接数</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment"># 连接池中的最小空闲连接数</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 当连接池耗尽时，获取连接的最大等待时间（-1表示无限等待）</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">-1ms</span></span><br></pre></td></tr></table></figure>

<p><strong>核心配置项解读</strong>：</p>
<ul>
<li><strong><code>host</code>, <code>port</code>, <code>password</code>, <code>database</code></strong>: 最基础的连接信息。</li>
<li><strong><code>timeout</code></strong>: 客户端连接Redis服务器以及读写操作的超时时间。如果网络状况不佳或Redis负载高，适当调高此值可以避免不必要的超时异常。</li>
<li><strong><code>lettuce.pool</code></strong>: <strong>非常重要</strong>的连接池配置。虽然Lettuce的连接是线程安全的，可以被多线程共享，但对于高并发的阻塞式调用（比如<code>RedisTemplate</code>的同步操作），使用连接池可以提供更好的性能和资源管理。<ul>
<li><code>max-active</code>: 池中允许存在的最大连接数。当所有连接都在使用时，新的请求需要等待。这是控制并发资源的关键。</li>
<li><code>max-idle</code>: 池中允许保持的最大空闲连接数。超过此数量的空闲连接会被释放。</li>
<li><code>min-idle</code>: 池中必须保持的最小空闲连接数。即使没有请求，池中也会保留这个数量的连接，以备不时之需。</li>
<li><code>max-wait</code>: 当池中没有可用连接时，请求线程的最大等待时间。超过此时间会抛出异常。设置为<code>-1</code>表示无限等待，<strong>生产环境要谨慎，可能导致线程堆积</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-RedisTemplate-与-StringRedisTemplate"><a href="#2-3-RedisTemplate-与-StringRedisTemplate" class="headerlink" title="2.3 RedisTemplate 与 StringRedisTemplate"></a>2.3 <code>RedisTemplate</code> 与 <code>StringRedisTemplate</code></h3><p>Spring Data Redis提供了两个核心的模板类来与Redis交互：<code>RedisTemplate</code>和<code>StringRedisTemplate</code>。</p>
<ul>
<li><strong><code>RedisTemplate&lt;K, V&gt;</code></strong>:<ul>
<li><strong>定位</strong>：这是一个<strong>泛型</strong>的、功能最全的模板类，可以操作任何类型的Key和Value。</li>
<li><strong>序列化</strong>：它需要你为其指定<strong>序列化器 (Serializer)</strong>。默认情况下，它使用<strong>JDK的序列化器 (<code>JdkSerializationRedisSerializer</code>)</strong>。</li>
<li><strong>JDK序列化的问题</strong>：<ol>
<li><strong>可读性差</strong>：序列化后的内容是一串二进制，无法在<code>redis-cli</code>中直接阅读。</li>
<li><strong>体积大</strong>：序列化后的字节数组通常比JSON等格式要大。</li>
<li><strong>语言强相关</strong>：只能被Java应用反序列化，与其他语言的系统交互困难。</li>
</ol>
</li>
<li><strong>生产推荐</strong>：在生产环境中，我们通常会自定义<code>RedisTemplate</code>的序列化方式，例如使用<code>Jackson2JsonRedisSerializer</code>（存储为JSON）或<code>GenericJackson2JsonRedisSerializer</code>。</li>
</ul>
</li>
<li><strong><code>StringRedisTemplate</code></strong>:<ul>
<li><strong>定位</strong>：是<code>RedisTemplate&lt;String, String&gt;</code>的一个<strong>特化</strong>子类。它专门用于处理Key和Value都是<strong>字符串</strong>的场景。</li>
<li><strong>序列化</strong>：它已经预先配置好了使用<code>StringRedisSerializer</code>。这意味着它存入Redis的数据是<strong>纯字符串</strong>，具有<strong>极好的可读性</strong>，并且可以与任何语言的客户端无缝交互。</li>
<li><strong>何时使用</strong>：<ol>
<li>当你明确知道你的缓存数据（Key和Value）都是字符串时。</li>
<li>当你需要将一个对象缓存为JSON字符串时，可以手动将对象序列化为JSON，然后用<code>StringRedisTemplate</code>存取。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>总结与选择</strong>：</p>
<table>
<thead>
<tr>
<th align="left">模板类</th>
<th align="left">Key序列化器</th>
<th align="left">Value序列化器</th>
<th align="left">默认序列化</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">推荐场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>RedisTemplate</code></strong></td>
<td align="left">泛型 (K)</td>
<td align="left">泛型 (V)</td>
<td align="left">JDK序列化</td>
<td align="left">灵活，可操作任意对象</td>
<td align="left">默认配置不佳，需自定义</td>
<td align="left">存储复杂Java对象，且已配置好JSON等序列化器</td>
</tr>
<tr>
<td align="left"><strong><code>StringRedisTemplate</code></strong></td>
<td align="left"><code>StringRedisSerializer</code></td>
<td align="left"><code>StringRedisSerializer</code></td>
<td align="left">字符串</td>
<td align="left"><strong>可读性好，跨语言</strong></td>
<td align="left">只能处理字符串KV</td>
<td align="left"><strong>日常开发首选</strong>，特别是缓存JSON字符串</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>最佳实践</strong>：在项目中配置一个使用JSON序列化器的<code>RedisTemplate</code> Bean，同时直接使用Spring Boot自动配置好的<code>StringRedisTemplate</code>。根据场景选择合适的模板。</p>
</blockquote>
<hr>
<h4 id="2-4-常用-API-示例"><a href="#2-4-常用-API-示例" class="headerlink" title="2.4 常用 API 示例"></a>2.4 常用 API 示例</h4><p><code>RedisTemplate</code>和<code>StringRedisTemplate</code>的API设计非常优雅，它们将不同数据结构的操作分装到各自的<code>Operations</code>接口中。</p>
<p><strong>获取操作对象</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作String</span></span><br><span class="line">ValueOperations&lt;String, Object&gt; valueOps = redisTemplate.opsForValue();</span><br><span class="line">ValueOperations&lt;String, String&gt; stringValueOps = stringRedisTemplate.opsForValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作Hash</span></span><br><span class="line">HashOperations&lt;String, Object, Object&gt; hashOps = redisTemplate.opsForHash();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作List</span></span><br><span class="line">ListOperations&lt;String, Object&gt; listOps = redisTemplate.opsForList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作Set</span></span><br><span class="line">SetOperations&lt;String, Object&gt; setOps = redisTemplate.opsForSet();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作ZSet</span></span><br><span class="line">ZSetOperations&lt;String, Object&gt; zSetOps = redisTemplate.opsForZSet();</span><br></pre></td></tr></table></figure>

<p><strong>实战示例 (<code>StringRedisTemplate</code>)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDemoService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. String 操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 设置值并指定10分钟过期</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:name&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:name&quot;</span>); <span class="comment">// &quot;Alice&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除key</span></span><br><span class="line">        stringRedisTemplate.delete(<span class="string">&quot;user:name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Hash 操作 (常用于存储对象)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:1001&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:1001&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;30&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取单个字段</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> (String) stringRedisTemplate.opsForHash().get(<span class="string">&quot;user:1001&quot;</span>, <span class="string">&quot;age&quot;</span>); <span class="comment">// &quot;30&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有字段</span></span><br><span class="line">        Map&lt;Object, Object&gt; userFields = stringRedisTemplate.opsForHash().entries(<span class="string">&quot;user:1001&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. List 操作 (简单消息队列)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 生产者：从左边推入任务</span></span><br><span class="line">        stringRedisTemplate.opsForList().leftPush(<span class="string">&quot;task:queue&quot;</span>, <span class="string">&quot;task1&quot;</span>);</span><br><span class="line">        stringRedisTemplate.opsForList().leftPush(<span class="string">&quot;task:queue&quot;</span>, <span class="string">&quot;task2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者：从右边弹出任务</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">task</span> <span class="operator">=</span> stringRedisTemplate.opsForList().rightPop(<span class="string">&quot;task:queue&quot;</span>); <span class="comment">// &quot;task1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. Set 操作 (标签)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForSet().add(<span class="string">&quot;tags:post:123&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;spring&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断成员是否存在</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> stringRedisTemplate.opsForSet().isMember(<span class="string">&quot;tags:post:123&quot;</span>, <span class="string">&quot;java&quot;</span>); <span class="comment">// true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取所有成员</span></span><br><span class="line">        Set&lt;String&gt; tags = stringRedisTemplate.opsForSet().members(<span class="string">&quot;tags:post:123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. ZSet 操作 (排行榜)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZSet</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(<span class="string">&quot;game:rank&quot;</span>, <span class="string">&quot;PlayerA&quot;</span>, <span class="number">1500</span>);</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(<span class="string">&quot;game:rank&quot;</span>, <span class="string">&quot;PlayerB&quot;</span>, <span class="number">2200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取排行榜TOP N (降序)</span></span><br><span class="line">        Set&lt;String&gt; topPlayers = stringRedisTemplate.opsForZSet().reverseRange(<span class="string">&quot;game:rank&quot;</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-序列化机制"><a href="#3-序列化机制" class="headerlink" title="3. 序列化机制"></a>3. 序列化机制</h2><p>在Java应用中，当我们要将一个Java对象存入Redis时（通常是存入<code>String</code>或<code>Hash</code>的Value中），需要先将这个对象转换成二进制数据流，这个过程就是<strong>序列化(Serialization)</strong>。反之，从Redis中取出数据再转换回Java对象，就是<strong>反序列化(Deserialization)</strong>。</p>
<p>Spring Data Redis的<code>RedisTemplate</code>通过<code>RedisSerializer</code>接口来完成这个过程。选择合适的序列化器对应用性能和可维护性有巨大影响。</p>
<h3 id="3-1-默认JDK序列化的问题"><a href="#3-1-默认JDK序列化的问题" class="headerlink" title="3.1 默认JDK序列化的问题"></a>3.1 默认JDK序列化的问题</h3><p>Spring的<code>RedisTemplate&lt;Object, Object&gt;</code>默认使用的序列化器是<code>JdkSerializationRedisSerializer</code>。它虽然能处理任何实现了<code>java.io.Serializable</code>接口的Java对象，但在生产实践中，我们通常会避免使用它，主要有以下几个核心问题：</p>
<ol>
<li><p><strong>可读性极差</strong>：</p>
<ul>
<li><p>JDK序列化产生的是纯二进制数据。当你在<code>redis-cli</code>中<code>GET</code>一个key时，你会看到一串乱码（如 <code>\xac\xed\x00\x05t\x00\x04name...</code>），完全无法直接阅读和调试。</p>
</li>
<li><p><strong>示例</strong>：一个简单的<code>User</code>对象，序列化后在Redis中可能是这样的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GET user:1001</span><br><span class="line">&quot;\xac\xed\x00\x05sr\x00\x1ccom.example.demo.User\x02...\x00\x04name...t\x00\x05Alice&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>序列化后体积过大</strong>：</p>
<ul>
<li>JDK序列化结果中包含了大量的类型信息、类路径、版本号等元数据，这导致最终的字节数组体积相对较大，浪费Redis宝贵的内存资源和网络带宽。</li>
</ul>
</li>
<li><p><strong>语言强相关性，跨平台性差</strong>：</p>
<ul>
<li>JDK序列化是Java特有的机制。一个被JDK序列化的对象，只有Java应用能够正确地反序列化回来。如果你的系统需要与Python、Go、Node.js等其他语言的服务共享缓存数据，这将成为一个巨大的障碍。</li>
</ul>
</li>
<li><p><strong>性能问题</strong>：</p>
<ul>
<li>相比于专门为性能优化的序列化框架（如Kryo、Protobuf），JDK序列化的性能和效率都比较低。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-2-使用-Jackson-JSON-或-Protobuf-Kryo-进行序列化配置"><a href="#3-2-使用-Jackson-JSON-或-Protobuf-Kryo-进行序列化配置" class="headerlink" title="3.2 使用 Jackson (JSON) 或 Protobuf&#x2F;Kryo 进行序列化配置"></a>3.2 使用 Jackson (JSON) 或 Protobuf&#x2F;Kryo 进行序列化配置</h3><p>为了解决JDK序列化的问题，我们通常会选择更现代、更高效的序列化方案。</p>
<h4 id="3-2-1-使用-Jackson-JSON-——-兼顾可读性与性能"><a href="#3-2-1-使用-Jackson-JSON-——-兼顾可读性与性能" class="headerlink" title="3.2.1 使用 Jackson (JSON) —— 兼顾可读性与性能"></a>3.2.1 使用 Jackson (JSON) —— 兼顾可读性与性能</h4><p>将对象序列化为JSON字符串是最常用、最推荐的方案，因为它在可读性、性能和跨平台性之间取得了完美的平衡。Spring Boot生态中，<code>Jackson</code>是处理JSON的标配。</p>
<ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>可读性好</strong>：JSON是人类可读的文本格式，便于在<code>redis-cli</code>或可视化工具中直接查看和调试。</li>
<li><strong>跨语言</strong>：JSON是事实上的数据交换标准，任何语言都有成熟的库来处理它。</li>
<li><strong>生态成熟</strong>：与Spring无缝集成，注解丰富（<code>@JsonIgnore</code>, <code>@JsonFormat</code>等），易于定制。</li>
</ul>
</li>
<li><p><strong>如何配置</strong>：<br>你需要创建一个配置类，自定义一个<code>RedisTemplate&lt;String, Object&gt;</code>的Bean，并为其设置JSON序列化器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值</span></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jacksonSerializer = <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="comment">// 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span></span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">// 指定序列化输入的类型，类必须是非final修饰的，final修饰的类会抛出异常</span></span><br><span class="line">        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jacksonSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String 的序列化</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringSerializer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jacksonSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jacksonSerializer);</span><br><span class="line">        </span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键代码解读</strong>：<ul>
<li><code>Jackson2JsonRedisSerializer</code>: Spring Data Redis提供的基于Jackson的序列化器。</li>
<li><code>om.activateDefaultTyping(...)</code>: <strong>非常重要</strong>。这行代码会在JSON中加入<code>@class</code>属性，记录对象的完整类名（如<code>&quot;com.example.User&quot;</code>）。这样在反序列化时，即使你使用的是<code>Object.class</code>，Jackson也能知道应该将其转换成哪个具体的子类。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-2-使用-Protobuf-Kryo-——-追求极致性能"><a href="#3-2-2-使用-Protobuf-Kryo-——-追求极致性能" class="headerlink" title="3.2.2 使用 Protobuf &#x2F; Kryo —— 追求极致性能"></a>3.2.2 使用 Protobuf &#x2F; Kryo —— 追求极致性能</h4><p>当你的应用对性能和内存占用要求达到极致，并且可以牺牲一些可读性时，可以考虑使用性能更强的二进制序列化框架。</p>
<ul>
<li><strong>Protobuf (Protocol Buffers)</strong><ul>
<li><strong>简介</strong>：Google开发的语言无关、平台无关、可扩展的序列化数据结构的方法。</li>
<li><strong>优点</strong>：<ul>
<li><strong>性能极高</strong>：序列化和反序列化速度非常快。</li>
<li><strong>体积超小</strong>：采用二进制编码，序列化后体积远小于JSON。</li>
<li><strong>强类型与向前&#x2F;向后兼容</strong>：需要预先定义<code>.proto</code>文件来描述数据结构，提供了严格的类型检查和良好的版本兼容性。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>需要维护<code>.proto</code>文件，增加了开发步骤。</li>
<li>二进制格式，不可读。</li>
</ul>
</li>
<li><strong>适用场景</strong>：微服务之间的高性能RPC通信、对数据大小和编解码速度有苛刻要求的场景。</li>
</ul>
</li>
<li><strong>Kryo</strong><ul>
<li><strong>简介</strong>：一个快速、高效的Java对象序列化框架。</li>
<li><strong>优点</strong>：<ul>
<li><strong>性能顶级</strong>：通常被认为是Java生态中最快的序列化框架之一。</li>
<li><strong>体积小</strong>：序列化结果紧凑。</li>
<li><strong>API简单</strong>：无需像Protobuf那样预先定义IDL文件。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>语言相关</strong>：主要服务于Java，跨语言支持不如Protobuf。</li>
<li><strong>线程不安全</strong>：Kryo实例不是线程安全的，需要通过池化或<code>ThreadLocal</code>来管理。</li>
</ul>
</li>
<li><strong>适用场景</strong>：纯Java环境，需要极致序列化性能的应用。</li>
</ul>
</li>
</ul>
<p><strong>如何配置 (以Kryo为例)</strong>：</p>
<p>你需要自定义一个<code>KryoRedisSerializer</code>，并在<code>RedisConfig</code>中使用它。由于Kryo的配置相对复杂（需要处理线程安全和类注册），通常会封装一个工具类。</p>
<hr>
<h3 id="4-3-总结与选择策略"><a href="#4-3-总结与选择策略" class="headerlink" title="4.3 总结与选择策略"></a>4.3 总结与选择策略</h3><table>
<thead>
<tr>
<th align="left">序列化方案</th>
<th align="left">性能</th>
<th align="left">体积</th>
<th align="left">可读性</th>
<th align="left">跨语言</th>
<th align="left">额外工作</th>
<th align="left">推荐度</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>JDK (默认)</strong></td>
<td align="left">低</td>
<td align="left">大</td>
<td align="left">❌ 无</td>
<td align="left">❌ 仅Java</td>
<td align="left">无</td>
<td align="left">⭐ (不推荐)</td>
</tr>
<tr>
<td align="left"><strong>Jackson (JSON)</strong></td>
<td align="left">良好</td>
<td align="left">中</td>
<td align="left">✅ <strong>极好</strong></td>
<td align="left">✅ <strong>极好</strong></td>
<td align="left">简单配置</td>
<td align="left">⭐⭐⭐⭐⭐ (<strong>通用首选</strong>)</td>
</tr>
<tr>
<td align="left"><strong>Protobuf</strong></td>
<td align="left">✅ <strong>极高</strong></td>
<td align="left">✅ <strong>极小</strong></td>
<td align="left">❌ 无</td>
<td align="left">✅ <strong>极好</strong></td>
<td align="left">需维护.proto文件</td>
<td align="left">⭐⭐⭐⭐ (高性能跨语言场景)</td>
</tr>
<tr>
<td align="left"><strong>Kryo</strong></td>
<td align="left">✅ <strong>极高</strong></td>
<td align="left">✅ <strong>极小</strong></td>
<td align="left">❌ 无</td>
<td align="left">❌ 弱</td>
<td align="left">需处理线程安全</td>
<td align="left">⭐⭐⭐ (纯Java高性能场景)</td>
</tr>
</tbody></table>
<p><strong>最终建议</strong>：</p>
<p>对于绝大多数Java后端应用，<strong>使用Jackson将对象序列化为JSON是最佳实践</strong>。它在各方面都表现均衡，特别是其出色的可读性和跨平台能力，能为开发和维护带来巨大便利。只有在遇到明确的性能瓶颈时，再考虑迁移到Kryo或Protobuf。</p>
<hr>
<h1 id="五、Redis进阶功能"><a href="#五、Redis进阶功能" class="headerlink" title="五、Redis进阶功能"></a>五、Redis进阶功能</h1><h2 id="1-事务-Transaction"><a href="#1-事务-Transaction" class="headerlink" title="1. 事务 (Transaction)"></a>1. 事务 (Transaction)</h2><p>Redis的事务提供了一种将多个命令打包、一次性、按序执行的机制。在事务执行期间，服务器不会中断事务去执行其他客户端的命令，从而保证了这组命令执行的“原子性”（此原子性非ACID中的原子性，后文详述）。</p>
<h3 id="1-1-MULTI-EXEC-DISCARD-WATCH"><a href="#1-1-MULTI-EXEC-DISCARD-WATCH" class="headerlink" title="1.1 MULTI, EXEC, DISCARD, WATCH"></a>1.1 <code>MULTI</code>, <code>EXEC</code>, <code>DISCARD</code>, <code>WATCH</code></h3><p>这四个命令是Redis事务的核心。</p>
<ul>
<li><strong><code>MULTI</code></strong>:<ul>
<li><strong>作用</strong>：标记一个事务块的开始。</li>
<li><strong>行为</strong>：当客户端发送<code>MULTI</code>命令后，服务器返回<code>OK</code>，然后该客户端进入一个特殊模式。在此模式下，后续发送的所有命令都不会立即执行，而是被放入一个<strong>命令队列</strong>中。服务器对每个入队的命令回复<code>QUEUED</code>。</li>
</ul>
</li>
<li><strong><code>EXEC</code></strong>:<ul>
<li><strong>作用</strong>：原子性地执行所有在<code>MULTI</code>后入队的命令。</li>
<li><strong>行为</strong>：客户端发送<code>EXEC</code>后，Redis会按顺序执行队列中的所有命令。执行完毕后，一次性返回所有命令的执行结果，其顺序与命令入队顺序一致。执行后，客户端连接恢复到正常状态。</li>
</ul>
</li>
<li><strong><code>DISCARD</code></strong>:<ul>
<li><strong>作用</strong>：取消事务，放弃执行事务块内的所有命令。</li>
<li><strong>行为</strong>：客户端在<code>MULTI</code>和<code>EXEC</code>之间发送<code>DISCARD</code>，服务器会清空该客户端的命令队列，然后客户端连接恢复正常。</li>
</ul>
</li>
<li><strong><code>WATCH key [key ...]</code></strong>:<ul>
<li><strong>作用</strong>：一个<strong>乐观锁</strong>命令，用于在事务执行前监视一个或多个key。</li>
<li><strong>行为</strong>：如果在<code>WATCH</code>执行之后，<code>EXEC</code>执行之前，任何被<code>WATCH</code>的key被<strong>其他客户端</strong>修改了，那么整个事务将被取消，<code>EXEC</code>会返回一个<code>nil</code>来表示事务执行失败。</li>
</ul>
</li>
</ul>
<p><strong>基本事务流程示例</strong>：</p>
<p>假设有一个需求：将用户A的账户余额减10，同时将用户B的账户余额加10。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 正常执行</span><br><span class="line">127.0.0.1:6379&gt; MSET account:A 100 account:B 50</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY account:A 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY account:B 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) (integer) 90   # DECRBY的结果</span><br><span class="line">2) (integer) 60   # INCRBY的结果</span><br><span class="line"></span><br><span class="line"># 使用DISCARD放弃事务</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY account:A 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DISCARD</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; GET account:A</span><br><span class="line">&quot;90&quot;  # 余额未变，因为事务被取消了</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-2-Redis事务的ACID特性分析"><a href="#1-2-Redis事务的ACID特性分析" class="headerlink" title="1.2 Redis事务的ACID特性分析"></a>1.2 Redis事务的ACID特性分析</h3><p>传统关系型数据库的事务严格遵循ACID原则，但Redis的事务在实现上有所不同，特别是<strong>不保证原子性</strong>。</p>
<ul>
<li><p><strong>A - 原子性 (Atomicity)</strong>: <strong>不完全支持</strong></p>
<ul>
<li><p>Redis的事务<strong>不支持回滚 (Rollback)</strong>。</p>
</li>
<li><p><strong>语法错误</strong>：如果在入队时，命令本身存在语法错误（如<code>SETT</code>写成了<code>SETT</code>），Redis会拒绝执行整个事务，<code>EXEC</code>时会返回错误。从这个角度看，它有一定原子性。</p>
</li>
<li><p><strong>运行时错误</strong>：如果在<code>EXEC</code>执行期间，某个命令发生错误（例如，对一个字符串执行<code>INCR</code>操作），<strong>Redis不会停止，而是会继续执行后续的命令</strong>。已经执行成功的命令不会被回滚。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET mykey &quot;hello&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; INCR mykey  # 这将导致一个运行时错误</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; SET anotherkey &quot;world&quot;</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) (error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">2) OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GET anotherkey</span><br><span class="line">&quot;world&quot;  # &#x27;anotherkey&#x27; 依然被成功设置了</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结论</strong>：Redis事务是“打包执行”，要么全不执行（语法错误），要么按顺序执行但不保证全部成功（运行时错误），做不到“要么全成功，要么全失败”。</p>
</li>
</ul>
</li>
<li><p><strong>C - 一致性 (Consistency)</strong>: <strong>部分保证</strong></p>
<ul>
<li>Redis通过运行时错误（如类型错误）来保证数据库本身不会因为错误命令而进入不一致的状态。</li>
<li>但是，<strong>业务逻辑上的一致性需要由调用者来保证</strong>。例如，在上面的转账例子中，如果因为某种原因只执行了<code>DECRBY</code>而<code>INCRBY</code>失败，Redis本身是“一致”的，但业务上资金就凭空消失了。</li>
</ul>
</li>
<li><p><strong>I - 隔离性 (Isolation)</strong>: <strong>支持</strong></p>
<ul>
<li>这是Redis事务<strong>保证得最好</strong>的特性。由于Redis是单线程模型，当一个事务通过<code>EXEC</code>执行时，Redis会以串行的方式不间断地执行完所有命令。在此期间，不会有任何其他客户端的命令插入进来。</li>
</ul>
</li>
<li><p><strong>D - 持久性 (Durability)</strong>: <strong>取决于配置</strong></p>
<ul>
<li>持久性不是事务本身的特性，而是由Redis的持久化策略（RDB和AOF）决定的。如果Redis没有开启任何持久化，那么事务执行后一旦服务器宕机，数据就会丢失。如果开启了AOF并配置为<code>always</code>，那么持久性最高。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-WATCH-实现乐观锁"><a href="#1-3-WATCH-实现乐观锁" class="headerlink" title="1.3 WATCH 实现乐观锁"></a>1.3 <code>WATCH</code> 实现乐观锁</h3><p><code>WATCH</code>命令是实现**乐观锁 (Optimistic Locking)<strong>和</strong>CAS (Check-And-Set)**行为的关键。</p>
<ul>
<li><p><strong>为什么需要<code>WATCH</code>？</strong><br><code>MULTI/EXEC</code>只能保证事务执行期间的隔离性，但无法保证从“读取数据”到“准备执行事务”这个阶段的数据一致性。</p>
<ul>
<li><p><strong>场景</strong>：更新商品库存。</p>
<ol>
<li>客户端A读取库存为10。</li>
<li>客户端B也读取库存为10，并立即下单，将库存更新为9。</li>
<li>客户端A此时基于它过时的信息（库存还是10）进行计算，然后<code>MULTI/EXEC</code>将库存也更新为9。</li>
</ol>
<ul>
<li><strong>问题</strong>：两个用户都下单成功，但库存只减了1，导致数据不一致。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>WATCH</code> 的解决方案</strong>：<br><code>WATCH</code>通过在事务执行前检查关键数据是否被修改，来解决上述问题。</p>
<p><strong>流程</strong>：</p>
<ol>
<li>客户端A：<code>WATCH stock:1001</code></li>
<li>客户端A：<code>GET stock:1001</code> (得到 “10”)</li>
<li><strong>此时，客户端B执行 <code>DECR stock:1001</code>，将库存变为 “9”</strong>。</li>
<li>客户端A：基于它到的”10”计算，准备将库存设为9。</li>
<li>客户端A：<code>MULTI</code></li>
<li>客户端A：<code>SET stock:1001 9</code></li>
<li>客户端A：<code>EXEC</code> -&gt; <strong>返回 <code>(nil)</code></strong></li>
</ol>
<ul>
<li><strong>结果</strong>：因为被<code>WATCH</code>的<code>stock:1001</code>在<code>MULTI</code>之前被客户端B修改了，所以客户端A的事务被自动取消。</li>
<li><strong>应用层逻辑</strong>：客户端A的应用代码在接收到<code>nil</code>响应后，就应该知道发生了冲突，此时应该<strong>重试</strong>整个流程（重新<code>WATCH</code>、<code>GET</code>、计算、<code>EXEC</code>）。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>总结</strong>：<code>WATCH</code>实现了一种“先检查，再执行”的乐观锁机制。它假设数据冲突是小概率事件，不预先加锁，而是在提交时检查数据是否被篡改。如果被篡改，就放弃本次操作并重试。这比悲观锁（在操作前就加锁）在多数情况下有更高的并发性能。</p>
</blockquote>
<hr>
<h2 id="2-发布-订阅-Pub-Sub"><a href="#2-发布-订阅-Pub-Sub" class="headerlink" title="2. 发布&#x2F;订阅 (Pub&#x2F;Sub)"></a>2. 发布&#x2F;订阅 (Pub&#x2F;Sub)</h2><h3 id="2-1-是什么-1"><a href="#2-1-是什么-1" class="headerlink" title="2.1 是什么"></a>2.1 是什么</h3><p>发布&#x2F;订阅（Publish&#x2F;Subscribe）是一种<strong>消息通信模式</strong>，它允许消息的发送者（发布者，Publisher）与消息的接收者（订阅者，Subscriber）进行解耦。</p>
<ul>
<li><strong>发布者 (Publisher)</strong>：将消息发送到一个特定的“频道”（Channel），而不关心谁会接收这个消息。</li>
<li><strong>订阅者 (Subscriber)</strong>：对一个或多个“频道”表示兴趣，并只接收发送到这些频道的消息。</li>
<li><strong>频道 (Channel)</strong>：作为发布者和订阅者之间的中介，传递消息。</li>
</ul>
<p>这种模式就像一个广播电台。广播员（发布者）向某个频率（频道）播送节目，听众（订阅者）将收音机调到该频率就能收听。广播员不知道谁在听，听众也不知道广播员是谁，他们只通过频率进行关联。</p>
<hr>
<h3 id="2-2-核心命令"><a href="#2-2-核心命令" class="headerlink" title="2.2 核心命令"></a>2.2 核心命令</h3><ul>
<li><p><strong><code>PUBLISH channel message</code></strong>:</p>
<ul>
<li><p><strong>作用</strong>：将 <code>message</code> 发布到指定的 <code>channel</code>。</p>
</li>
<li><p><strong>返回值</strong>：接收到此消息的订阅者数量。如果没有订阅者，返回0，消息会被直接丢弃。</p>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 发布一条新闻到 &#x27;news:sports&#x27; 频道</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH news:sports &quot;Team A won the championship!&quot;</span><br><span class="line">(integer) 1  # 表示有1个订阅者收到了消息</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>SUBSCRIBE channel [channel ...]</code></strong>:</p>
<ul>
<li><p><strong>作用</strong>：订阅一个或多个指定的频道。</p>
</li>
<li><p><strong>行为</strong>：这是一个<strong>阻塞式命令</strong>。客户端执行<code>SUBSCRIBE</code>后，会进入订阅模式，不能再执行其他普通命令（除了<code>SUBSCRIBE</code>, <code>UNSUBSCRIBE</code>等），它会一直等待并接收来自所订阅频道的消息。</p>
</li>
<li><p><strong>实践</strong>（需要两个<code>redis-cli</code>窗口）：</p>
<ul>
<li><p><strong>窗口 A (订阅者)</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE news:sports</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;news:sports&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 客户端在此处阻塞等待...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>窗口 B (发布者)</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH news:sports <span class="string">&quot;Match starting in 5 mins&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>窗口 A 会立即收到消息</strong>:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;news:sports&quot;</span><br><span class="line">3) &quot;Match starting in 5 mins&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>PSUBSCRIBE pattern [pattern ...]</code></strong>:</p>
<ul>
<li><p><strong>作用</strong>：<strong>模式订阅</strong>。可以订阅匹配特定模式的所有频道。模式使用glob风格的通配符，如 <code>*</code> (匹配任意多个字符) 和 <code>?</code> (匹配单个字符)。</p>
</li>
<li><p><strong>实践</strong>：订阅所有以 <code>news:</code> 开头的频道。</p>
<ul>
<li><p><strong>窗口 A (订阅者)</strong>:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PSUBSCRIBE news:*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;psubscribe&quot;</span><br><span class="line">2) &quot;news:*&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>窗口 B (发布者)</strong>:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBLISH news:tech &quot;Redis 8.0 is coming&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>窗口 A 收到消息</strong>（注意返回格式不同，包含了匹配的模式和实际的频道名）：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;news:*&quot;</span><br><span class="line">3) &quot;news:tech&quot;</span><br><span class="line">4) &quot;Redis 8.0 is coming&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>UNSUBSCRIBE [channel ...]</code></strong> &#x2F; <strong><code>PUNSUBSCRIBE [pattern ...]</code></strong>: 取消订阅。如果不带参数，则取消所有订阅。</p>
</li>
</ul>
<hr>
<h3 id="2-3-应用场景"><a href="#2-3-应用场景" class="headerlink" title="2.3 应用场景"></a>2.3 应用场景</h3><ol>
<li><strong>实时通知与消息推送</strong>：<ul>
<li><strong>描述</strong>：Web应用中，当某个事件发生时（如用户收到新私信、订单状态更新），后端可以向一个用户专属的频道发布消息。前端通过WebSocket与一个订阅了该频道的服务保持长连接，从而实时接收并展示通知。</li>
<li><strong>示例</strong>：后端执行 <code>PUBLISH notifications:user123 &#39;{&quot;type&quot;:&quot;new_message&quot;, &quot;from&quot;:&quot;Alice&quot;}&#39;</code>。</li>
</ul>
</li>
<li><strong>简单的实时聊天室</strong>：<ul>
<li><strong>描述</strong>：每个聊天室可以是一个频道。所有进入聊天室的用户都订阅该频道。当一个用户发送消息时，后端将其<code>PUBLISH</code>到该频道，所有订阅者都会收到这条消息。</li>
</ul>
</li>
<li><strong>服务间的简单解耦</strong>：<ul>
<li><strong>描述</strong>：当一个服务完成某个任务后，可以发布一个事件通知，其他关心此事件的服务可以订阅并做出响应。例如，订单服务完成下单后发布<code>order:created</code>事件，库存服务和物流服务可以订阅此事件来各自执行扣减库存和创建运单的操作。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-4-缺点"><a href="#2-4-缺点" class="headerlink" title="2.4 缺点"></a>2.4 缺点</h3><p>Redis的Pub&#x2F;Sub是一个非常轻量级的实现，它<strong>不保证消息的可靠性</strong>，这使其与专业的MOM（Message-Oriented Middleware，如Kafka、RabbitMQ）有本质区别。</p>
<ol>
<li><strong>消息丢失 (No Persistence)</strong>：<ul>
<li><strong>发后即忘 (Fire and Forget)</strong>：如果消息发布时，没有任何客户端订阅该频道，那么这条消息会<strong>被立即丢弃</strong>，永远丢失。</li>
<li><strong>离线丢失</strong>：如果一个订阅者客户端中途断线，它将<strong>错过在断线期间发布的所有消息</strong>。重新连接后，它只能接收到新的消息。</li>
</ul>
</li>
<li><strong>无ACK机制 (No Acknowledgement)</strong>：<ul>
<li>发布者不知道消息是否被订阅者成功接收或处理。如果订阅者在处理消息时崩溃，这条消息对该订阅者来说就相当于丢失了，无法进行重试。</li>
</ul>
</li>
<li><strong>无消息堆积和回溯能力</strong>：<ul>
<li>Pub&#x2F;Sub没有像Kafka那样的消息缓冲区。它不能存储历史消息，订阅者无法获取在它订阅之前发布的消息。</li>
</ul>
</li>
</ol>
<p><strong>结论</strong>：</p>
<p>Redis Pub&#x2F;Sub非常适合那些<strong>对消息可靠性要求不高</strong>，允许少量消息丢失，但追求<strong>实时性</strong>和<strong>简单性</strong>的场景。对于需要确保每条消息都被处理的业务场景（如订单、支付），<strong>绝对不能使用Pub&#x2F;Sub</strong>。在这种情况下，应该选择更可靠的方案，如<strong>Redis 5.0 之后引入的 <code>Stream</code> 数据结构</strong>，或者专业的MQ产品。</p>
<hr>
<h2 id="3-Pipeline-管道"><a href="#3-Pipeline-管道" class="headerlink" title="3. Pipeline (管道)"></a>3. Pipeline (管道)</h2><h3 id="3-1-是什么-1"><a href="#3-1-是什么-1" class="headerlink" title="3.1 是什么"></a>3.1 是什么</h3><p><code>Pipeline</code> 是一种<strong>客户端-服务器通信优化技术</strong>。它允许客户端将多个Redis命令打包在一起，一次性地发送给服务器，然后一次性地接收所有命令的响应。</p>
<p><strong>工作流程对比</strong>：</p>
<ul>
<li><p><strong>常规模式 (Without Pipeline)</strong>:</p>
<ol>
<li>客户端发送命令1 -&gt; 服务器接收、执行、返回响应1</li>
<li>客户端接收响应1，然后发送命令2 -&gt; 服务器接收、执行、返回响应2</li>
<li>客户端接收响应2，然后发送命令3 -&gt; 服务器接收、执行、返回响应3</li>
</ol>
<ul>
<li><strong>特点</strong>：每个命令的执行都包含一次完整的“请求-响应”网络来回，即<strong>网络往返时间 (Round Trip Time, RTT)</strong>。如果RTT是1毫秒，执行1000个命令就需要1000毫-秒。</li>
</ul>
</li>
<li><p><strong>管道模式 (With Pipeline)</strong>:</p>
<ol>
<li>客户端将命令1, 2, 3…N 打包，<strong>一次性全部发送</strong>给服务器。</li>
<li>服务器接收到命令后，按顺序执行它们，并将所有响应缓存起来。</li>
<li>服务器将所有响应打包，<strong>一次性全部返回</strong>给客户端。</li>
</ol>
<ul>
<li><strong>特点</strong>：N个命令的执行只包含<strong>一次</strong>网络RTT。如果RTT是1毫秒，执行1000个命令的总网络耗时仍然约等于1毫秒，性能提升极其显著。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>核心思想</strong>：<code>Pipeline</code> 的关键在于<strong>显著减少了因网络延迟造成的性能开销</strong>。它并不会加快Redis服务器执行命令本身的速度，但它将多次网络交互的成本压缩为了一次。</p>
</blockquote>
<hr>
<h3 id="3-2-与事务的区别"><a href="#3-2-与事务的区别" class="headerlink" title="3.2 与事务的区别"></a>3.2 与事务的区别</h3><p><code>Pipeline</code> 和 <code>Transaction</code> (事务) 看起来很像（都是打包执行一批命令），但它们在目的和保证上有着本质的区别。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Pipeline (管道)</th>
<th align="left">Transaction (MULTI&#x2F;EXEC)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心目的</strong></td>
<td align="left"><strong>性能优化</strong>：减少网络RTT</td>
<td align="left"><strong>原子性保证</strong>：确保一批命令作为一个整体执行，不被其他命令打断</td>
</tr>
<tr>
<td align="left"><strong>原子性</strong></td>
<td align="left"><strong>不保证</strong>。命令之间可能会被其他客户端的命令穿插执行。</td>
<td align="left"><strong>保证</strong>。<code>EXEC</code>时，所有命令会作为一个不可分割的单元被执行。</td>
</tr>
<tr>
<td align="left"><strong>命令执行</strong></td>
<td align="left">客户端发送后，服务器<strong>立即</strong>开始按序执行（只要接收到）。</td>
<td align="left">命令先入队（返回<code>QUEUED</code>），直到<code>EXEC</code>时才<strong>一次性</strong>执行。</td>
</tr>
<tr>
<td align="left"><strong>回滚能力</strong></td>
<td align="left">无。</td>
<td align="left">无。但如果命令入队时有语法错误，整个事务会失败。</td>
</tr>
<tr>
<td align="left"><strong>客户端行为</strong></td>
<td align="left">客户端将命令写入缓冲区，然后一次性<code>flush</code>。</td>
<td align="left">客户端发送<code>MULTI</code>，然后逐个发送命令，最后发送<code>EXEC</code>。</td>
</tr>
</tbody></table>
<p><strong>一个关键的场景区别</strong>：</p>
<ul>
<li><strong>场景A：需要连续对1000个不同的key进行<code>INCR</code>操作。</strong><ul>
<li>这些操作之间没有依赖关系，也不需要原子性。</li>
<li><strong>最佳选择</strong>：使用<code>Pipeline</code>。这会将1000次网络交互压缩为1次，性能提升巨大。</li>
</ul>
</li>
<li><strong>场景B：需要从账户A减款，同时给账户B增款。</strong><ul>
<li>这两个操作必须作为一个整体成功或失败，不能被其他操作打断。</li>
<li><strong>最佳选择</strong>：使用<code>MULTI/EXEC</code>事务。这保证了在<code>DECRBY</code>和<code>INCRBY</code>之间，不会有其他客户端的操作插进来，保证了业务逻辑的隔离性。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>总结</strong>：<code>Pipeline</code> 是为了**“快”<strong>，<code>Transaction</code> 是为了</strong>“稳”**。它们可以结合使用，即在<code>MULTI/EXEC</code>块中使用<code>Pipeline</code>来发送命令，但这种情况比较少见，因为事务内的命令本身就是打包执行的。</p>
</blockquote>
<hr>
<h3 id="3-3-Java客户端中的Pipeline应用"><a href="#3-3-Java客户端中的Pipeline应用" class="headerlink" title="3.3 Java客户端中的Pipeline应用"></a>3.3 Java客户端中的Pipeline应用</h3><p>主流的Java Redis客户端都支持<code>Pipeline</code>。以下是<code>Jedis</code>和<code>Spring Data Redis (RedisTemplate)</code>中的应用示例。</p>
<h4 id="3-3-1-Jedis-中的-Pipeline"><a href="#3-3-1-Jedis-中的-Pipeline" class="headerlink" title="3.3.1 Jedis 中的 Pipeline"></a>3.3.1 Jedis 中的 Pipeline</h4><p><code>Jedis</code>提供了非常直观的<code>Pipeline</code> API。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisPipelineDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>)) &#123;</span><br><span class="line">            <span class="comment">// 1. 获取Pipeline对象</span></span><br><span class="line">            <span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 在Pipeline中发送命令</span></span><br><span class="line">            <span class="comment">// 注意：这些命令并不会立即执行，调用返回的是一个Response对象</span></span><br><span class="line">            pipeline.set(<span class="string">&quot;user:1:name&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">            Response&lt;String&gt; nameResponse = pipeline.get(<span class="string">&quot;user:1:name&quot;</span>);</span><br><span class="line">            pipeline.incr(<span class="string">&quot;counter&quot;</span>);</span><br><span class="line">            Response&lt;String&gt; counterResponse = pipeline.get(<span class="string">&quot;counter&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 执行Pipeline</span></span><br><span class="line">            <span class="comment">// sync()方法会发送所有命令并等待所有响应</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Executing pipeline...&quot;</span>);</span><br><span class="line">            pipeline.sync(); </span><br><span class="line">            System.out.println(<span class="string">&quot;Pipeline executed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 从Response对象中获取结果</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> nameResponse.get();</span><br><span class="line">            <span class="type">long</span> <span class="variable">counter</span> <span class="operator">=</span> Long.parseLong(counterResponse.get());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Name: &quot;</span> + name);       <span class="comment">// Output: Name: Alice</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Counter: &quot;</span> + counter); <span class="comment">// Output: Counter: 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-3-2-Spring-Data-Redis-RedisTemplate-中的-Pipeline"><a href="#3-3-2-Spring-Data-Redis-RedisTemplate-中的-Pipeline" class="headerlink" title="3.3.2 Spring Data Redis (RedisTemplate) 中的 Pipeline"></a>3.3.2 Spring Data Redis (<code>RedisTemplate</code>) 中的 Pipeline</h4><p><code>RedisTemplate</code>通过<code>executePipelined</code>方法来支持管道操作。这个方法使用<code>RedisCallback</code>函数式接口，将所有在<code>doInRedis</code>回调中执行的Redis操作都放入一个<code>Pipeline</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisPipelineService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchSetAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用executePipelined执行管道操作</span></span><br><span class="line">        <span class="comment">// 返回的List包含了管道中每个命令的执行结果</span></span><br><span class="line">        List&lt;Object&gt; results = stringRedisTemplate.executePipelined(</span><br><span class="line">            (RedisCallback&lt;Object&gt;) connection -&gt; &#123;</span><br><span class="line">                <span class="comment">// 在这个回调中执行的所有命令都会被放入Pipeline</span></span><br><span class="line">                <span class="comment">// 注意：这里使用的是底层的connection对象，API更原始</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 1. 设置多个key</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;pipe:key:&quot;</span> + i;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;value&quot;</span> + i;</span><br><span class="line">                    connection.stringCommands().set(key.getBytes(), value.getBytes());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 获取多个key</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;pipe:key:&quot;</span> + i;</span><br><span class="line">                    connection.stringCommands().get(key.getBytes());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这个回调不需要返回任何东西，返回null即可</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印管道执行结果</span></span><br><span class="line">        <span class="comment">// results列表的顺序与命令执行顺序一致</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Pipeline results: &quot;</span> + results);</span><br><span class="line">        <span class="comment">// [true, true, true, true, true, &quot;value0&quot;, &quot;value1&quot;, &quot;value2&quot;, &quot;value3&quot;, &quot;value4&quot;]</span></span><br><span class="line">        <span class="comment">// 前5个是SET的结果，后5个是GET的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>：在<code>RedisTemplate</code>的<code>executePipelined</code>中，你需要使用更底层的<code>connection</code>对象和其<code>...Commands()</code>方法，并且需要手动处理字节数组的转换，这比直接使用<code>opsFor...()</code>要繁琐一些。但带来的性能提升是值得的。</li>
</ul>
<p><strong>何时使用 Pipeline？</strong></p>
<p>当你需要连续执行大量Redis命令，并且这些命令之间没有严格的依赖关系时（即后一个命令不依赖于前一个命令的执行结果），就应该毫不犹豫地使用<code>Pipeline</code>。最典型的场景就是<strong>批量写入</strong>或<strong>批量读取</strong>数据。</p>
<hr>
<h2 id="4-Lua脚本"><a href="#4-Lua脚本" class="headerlink" title="4. Lua脚本"></a>4. Lua脚本</h2><p>从Redis 2.6版本开始，通过内置的Lua解释器，Redis允许用户使用Lua语言编写脚本，并在Redis服务器端原子性地执行。</p>
<h3 id="4-1-EVAL-和-EVALSHA"><a href="#4-1-EVAL-和-EVALSHA" class="headerlink" title="4.1 EVAL 和 EVALSHA"></a>4.1 <code>EVAL</code> 和 <code>EVALSHA</code></h3><p>这两个是执行Lua脚本的核心命令。</p>
<ul>
<li><p><strong><code>EVAL script numkeys key [key ...] arg [arg ...]</code></strong>:</p>
<ul>
<li><p><strong>作用</strong>：执行一段Lua脚本字符串。</p>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>script</code>: Lua脚本的字符串内容。</li>
<li><code>numkeys</code>: 告诉Redis，接下来的参数中有多少个是Key。这是一个强制性要求，用于让Redis了解哪些参数是键，方便在集群模式下正确地将脚本路由到对应的节点。</li>
<li><code>key [key ...]</code>: 脚本中要操作的Redis Key，数量必须与<code>numkeys</code>一致。在Lua脚本中，通过<code>KEYS[1]</code>, <code>KEYS[2]</code>等来访问。</li>
<li><code>arg [arg ...]</code>: 传递给脚本的额外参数。在Lua脚本中，通过<code>ARGV[1]</code>, <code>ARGV[2]</code>等来访问。</li>
</ul>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 一个简单的脚本：获取第一个key的值，并与第一个arg比较</span><br><span class="line">127.0.0.1:6379&gt; EVAL &quot;return redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1]&quot; 1 mykey myvalue</span><br><span class="line">(integer) 1  # 假设mykey的值是myvalue</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>EVALSHA sha1 numkeys key [key ...] arg [arg ...]</code></strong>:</p>
<ul>
<li><p><strong>作用</strong>：执行一个已经缓存在Redis服务器上的脚本。</p>
</li>
<li><p><strong><code>sha1</code></strong>: 脚本内容的SHA1校验和。</p>
</li>
<li><p><strong>工作流程</strong>：</p>
<ol>
<li>Redis服务器在第一次执行<code>EVAL</code>时，会将该脚本的SHA1哈希值和脚本内容缓存起来。</li>
<li>客户端可以后续使用<code>EVALSHA</code>命令，只发送这个简短的SHA1哈希值来执行同一个脚本，而无需每次都发送完整的脚本内容。</li>
<li><strong>好处</strong>：极大地减少了网络带宽的占用，特别是对于长脚本。</li>
</ol>
</li>
<li><p><strong>实践</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 1. 客户端先计算脚本的SHA1值 (假设为 &quot;6b1bf486c81ceb7eff1c7987ade1c0953a116813&quot;)</span><br><span class="line"></span><br><span class="line"># 2. 尝试用EVALSHA执行</span><br><span class="line">127.0.0.1:6379&gt; EVALSHA 6b1bf486c81ceb7eff1c7987ade1c0953a116813 1 mykey myvalue</span><br><span class="line"></span><br><span class="line"># 3. 如果服务器返回 &quot;NOSCRIPT No matching script. Please use EVAL.&quot; 错误，</span><br><span class="line">#    说明服务器上没有缓存这个脚本。此时客户端再用EVAL执行一次，让服务器缓存它。</span><br><span class="line">#    之后就可以一直使用EVALSHA了。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>SCRIPT LOAD script</code></strong>: 此命令可以主动将一个脚本加载到缓存中并返回其SHA1值，而不立即执行它。</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-2-为什么需要Lua脚本"><a href="#4-2-为什么需要Lua脚本" class="headerlink" title="4.2 为什么需要Lua脚本"></a>4.2 为什么需要Lua脚本</h3><p>Lua脚本主要解决了两大痛点：</p>
<ol>
<li><strong>保证原子性 (Atomicity)</strong><ul>
<li><strong>问题</strong>：很多复杂的业务逻辑需要“先读、再改、后写”多个步骤。例如，更新库存时，需要先<code>GET</code>当前库存，在客户端计算新库存，再<code>SET</code>回去。在这个过程中，可能会有其他客户端修改库存，导致数据不一致。虽然<code>WATCH/MULTI/EXEC</code>可以实现乐观锁，但它需要客户端进行重试，增加了复杂性。</li>
<li><strong>Lua解决方案</strong>：Redis保证<strong>整个Lua脚本的执行是原子性的</strong>。当一个脚本在执行时，Redis服务器不会执行任何其他命令或脚本，直到当前脚本执行完毕。这就像一个更强大、更灵活的事务，将多个操作封装在一个不可分割的单元中，从根本上杜绝了竞态条件。</li>
</ul>
</li>
<li><strong>减少网络开销 (Reduce Network Overhead)</strong><ul>
<li><strong>问题</strong>：对于一些需要多次与Redis交互的复杂操作，每次命令都需要一次网络往返（RTT）。这在高延迟的网络环境下会严重影响性能。虽然<code>Pipeline</code>可以解决部分问题，但<code>Pipeline</code>中的命令之间不能有逻辑依赖。</li>
<li><strong>Lua解决方案</strong>：将复杂的逻辑封装在一个Lua脚本中，客户端只需要发送一次脚本执行请求。所有的计算和数据操作都在Redis服务器端完成，将多次网络交互压缩为一次。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>总结</strong>：Lua脚本 &#x3D; <strong>原子性</strong> + <strong>高性能</strong>。它提供了一种在服务端自定义原子命令的能力。</p>
</blockquote>
<h3 id="4-3-编写简单的Lua脚本案例"><a href="#4-3-编写简单的Lua脚本案例" class="headerlink" title="4.3 编写简单的Lua脚本案例"></a>4.3 编写简单的Lua脚本案例</h3><p>在Lua脚本中，你可以通过<code>redis.call()</code>函数来调用Redis的原生命令。</p>
<h4 id="4-3-1-安全的CAS操作（库存扣减）"><a href="#4-3-1-安全的CAS操作（库存扣减）" class="headerlink" title="4.3.1 安全的CAS操作（库存扣减）"></a>4.3.1 安全的CAS操作（库存扣减）</h4><p><strong>需求</strong>：扣减商品库存。只有当当前库存大于等于要扣减的数量时，才执行扣减，否则返回失败。</p>
<ul>
<li><p><strong>不使用Lua的痛点</strong>：<code>GET</code>库存 -&gt; 在客户端判断 -&gt; <code>DECRBY</code>库存。这三步非原子，有并发问题。</p>
</li>
<li><p><strong>使用Lua脚本</strong>：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 脚本: decrement_stock.lua</span></span><br><span class="line"><span class="keyword">local</span> current_stock = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>])) <span class="comment">-- 获取当前库存</span></span><br><span class="line"><span class="keyword">local</span> decrement_amount = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>]) <span class="comment">-- 获取要扣减的数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> current_stock &gt;= decrement_amount <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 库存充足，执行扣减并返回新库存</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;decrby&#x27;</span>, KEYS[<span class="number">1</span>], decrement_amount) </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 库存不足，返回0或-1表示失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>执行</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 假设库存键是 stock:product:1001，当前值为10</span><br><span class="line">127.0.0.1:6379&gt; SET stock:product:1001 10</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"># 尝试扣减5个</span><br><span class="line">127.0.0.1:6379&gt; EVAL &quot;...&quot; 1 stock:product:1001 5</span><br><span class="line">(integer) 5  # 成功，返回新库存5</span><br><span class="line"></span><br><span class="line"># 再次尝试扣减8个</span><br><span class="line">127.0.0.1:6379&gt; EVAL &quot;...&quot; 1 stock:product:1001 8</span><br><span class="line">(integer) 0  # 失败，因为5 &lt; 8</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原子性保证</strong>：从<code>get</code>到<code>decrby</code>的整个逻辑都在Redis服务端一次性完成，不会被任何其他命令打断。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-3-2-安全地释放分布式锁"><a href="#4-3-2-安全地释放分布式锁" class="headerlink" title="4.3.2 安全地释放分布式锁"></a>4.3.2 安全地释放分布式锁</h4><p><strong>需求</strong>：释放一个分布式锁。为了防止误删其他客户端持有的锁，必须先判断锁的值是否与自己加锁时设置的唯一ID匹配。</p>
<ul>
<li><p><strong>不使用Lua的痛点</strong>：<code>GET</code>锁的值 -&gt; 在客户端判断是否匹配 -&gt; <code>DEL</code>锁。这两步非原子，可能在<code>GET</code>和<code>DEL</code>之间锁恰好过期并被其他客户端获取，导致误删。</p>
</li>
<li><p><strong>使用Lua脚本</strong>：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 脚本: unlock.lua</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 锁存在且是自己的，执行删除</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 锁不存在或不是自己的，返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>执行</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 假设锁的key是 &#x27;my_lock&#x27;，客户端A加锁时设置的唯一值是 &#x27;client_A_uuid&#x27;</span><br><span class="line">127.0.0.1:6379&gt; SET my_lock &quot;client_A_uuid&quot; NX PX 30000</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"># 客户端A释放锁</span><br><span class="line">127.0.0.1:6379&gt; EVAL &quot;...&quot; 1 my_lock &quot;client_A_uuid&quot;</span><br><span class="line">(integer) 1  # 成功删除，返回1</span><br><span class="line"></span><br><span class="line"># 客户端B尝试释放客户端A的锁</span><br><span class="line">127.0.0.1:6379&gt; EVAL &quot;...&quot; 1 my_lock &quot;client_B_uuid&quot;</span><br><span class="line">(integer) 0  # 失败，因为值不匹配，返回0</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原子性保证</strong>：“判断”和“删除”这两个动作被捆绑在一起，成为了一个原子的<code>unlock</code>操作。这是实现高可用分布式锁的标准做法。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="六、持久化机制-数据安全保障"><a href="#六、持久化机制-数据安全保障" class="headerlink" title="六、持久化机制 (数据安全保障)"></a>六、持久化机制 (数据安全保障)</h1><h2 id="1-RDB-Redis-Database"><a href="#1-RDB-Redis-Database" class="headerlink" title="1. RDB (Redis Database)"></a>1. RDB (Redis Database)</h2><ul>
<li>工作原理：快照 (Snapshot)</li>
<li>触发方式：<code>SAVE</code> vs <code>BGSAVE</code></li>
<li>优缺点分析</li>
</ul>
<h2 id="2-AOF-Append-Only-File"><a href="#2-AOF-Append-Only-File" class="headerlink" title="2. AOF (Append Only File)"></a>2. AOF (Append Only File)</h2><ul>
<li>工作原理：命令追加</li>
<li><code>appendfsync</code>策略：<code>always</code>, <code>everysec</code>, <code>no</code></li>
<li>AOF重寫 (rewrite) 机制</li>
<li>优缺点分析</li>
</ul>
<h2 id="3-RDB-与-AOF-的抉择"><a href="#3-RDB-与-AOF-的抉择" class="headerlink" title="3. RDB 与 AOF 的抉择"></a>3. RDB 与 AOF 的抉择</h2><ul>
<li>生产环境如何选择？（推荐混合使用）</li>
<li>Redis 4.0后的混合持久化</li>
</ul>
<h1 id="七、企业级特性：高可用与扩展"><a href="#七、企业级特性：高可用与扩展" class="headerlink" title="七、企业级特性：高可用与扩展"></a>七、企业级特性：高可用与扩展</h1><h2 id="1-主从复制-Master-Slave-Replication"><a href="#1-主从复制-Master-Slave-Replication" class="headerlink" title="1. 主从复制 (Master-Slave Replication)"></a>1. 主从复制 (Master-Slave Replication)</h2><ul>
<li>配置方法与原理</li>
<li>全量复制 vs 增量复制</li>
<li>作用：读写分离、数据备份</li>
</ul>
<h2 id="2-Sentinel-哨兵-模式"><a href="#2-Sentinel-哨兵-模式" class="headerlink" title="2. Sentinel (哨兵) 模式"></a>2. Sentinel (哨兵) 模式</h2><ul>
<li>功能：监控、自动故障转移 (Failover)、通知</li>
<li>工作原理：选举Leader、故障切换流程</li>
<li>Java客户端如何整合Sentinel</li>
</ul>
<h2 id="3-Cluster-集群-模式"><a href="#3-Cluster-集群-模式" class="headerlink" title="3. Cluster (集群) 模式"></a>3. Cluster (集群) 模式</h2><ul>
<li>数据分片 (Sharding) 模型：哈希槽 (Hash Slot)</li>
<li>Gossip协议与节点通信</li>
<li><code>redis-cli</code> 创建和管理集群</li>
<li>Cluster模式下的限制 (例如：<code>mget</code>跨槽问题)</li>
<li>Java客户端如何整合Cluster</li>
</ul>
<h1 id="八、企业级开发设计模式"><a href="#八、企业级开发设计模式" class="headerlink" title="八、企业级开发设计模式"></a>八、企业级开发设计模式</h1><h2 id="1-缓存设计"><a href="#1-缓存设计" class="headerlink" title="1. 缓存设计"></a>1. 缓存设计</h2><ul>
<li>缓存更新策略：Cache-Aside (旁路缓存)、Read&#x2F;Write Through、Write Back</li>
<li><strong>缓存三大问题与解决方案</strong><ul>
<li><strong>缓存穿透</strong>：布隆过滤器 (Bloom Filter)、缓存空对象</li>
<li><strong>缓存击穿</strong>：互斥锁&#x2F;分布式锁</li>
<li><strong>缓存雪崩</strong>：过期时间加随机值、多级缓存、限流降级</li>
</ul>
</li>
</ul>
<h2 id="2-分布式锁"><a href="#2-分布式锁" class="headerlink" title="2. 分布式锁"></a>2. 分布式锁</h2><ul>
<li><code>SETNX</code>实现的 naive 锁及其问题 (死锁)</li>
<li><code>SET key value NX PX timeout</code> 原子命令实现</li>
<li>锁的 owner 标识与 LUA 脚本安全释放</li>
<li>Redisson <code>RLock</code> 的可重入锁与看门狗 (Watchdog) 机制原理</li>
<li>RedLock算法思想</li>
</ul>
<h2 id="3-其他设计模式"><a href="#3-其他设计模式" class="headerlink" title="3. 其他设计模式"></a>3. 其他设计模式</h2><ul>
<li><strong>限流器</strong>：<code>INCR</code>+<code>EXPIRE</code>实现的简单限流、滑动窗口限流 (ZSet实现)</li>
<li><strong>延迟队列</strong>：使用 ZSet 的 <code>score</code>作为执行时间</li>
</ul>
<h1 id="九、性能优化与最佳实践"><a href="#九、性能优化与最佳实践" class="headerlink" title="九、性能优化与最佳实践"></a>九、性能优化与最佳实践</h1><h2 id="1-内存优化"><a href="#1-内存优化" class="headerlink" title="1. 内存优化"></a>1. 内存优化</h2><ul>
<li>合理选择数据结构</li>
<li><code>maxmemory</code> 与内存淘汰策略 (LRU, LFU, etc.)</li>
<li>警惕内存碎片</li>
</ul>
<h2 id="2-命令使用最佳实践"><a href="#2-命令使用最佳实践" class="headerlink" title="2. 命令使用最佳实践"></a>2. 命令使用最佳实践</h2><ul>
<li>避免慢查询命令：<code>KEYS</code>, <code>HGETALL</code> (大数据量), <code>SMEMBERS</code></li>
<li>使用 <code>SCAN</code> &#x2F; <code>HSCAN</code> &#x2F; <code>SSCAN</code> &#x2F; <code>ZSCAN</code> 进行迭代</li>
<li>批量操作善用 <code>MSET</code>&#x2F;<code>MGET</code>&#x2F;Pipeline</li>
<li>Key&#x2F;Value设计规范</li>
</ul>
<h2 id="3-客户端优化"><a href="#3-客户端优化" class="headerlink" title="3. 客户端优化"></a>3. 客户端优化</h2><ul>
<li>使用连接池</li>
<li>长连接 vs 短连接</li>
</ul>
<h1 id="十、运维与监控"><a href="#十、运维与监控" class="headerlink" title="十、运维与监控"></a>十、运维与监控</h1><h2 id="1-核心监控指标"><a href="#1-核心监控指标" class="headerlink" title="1. 核心监控指标"></a>1. 核心监控指标</h2><ul>
<li><code>INFO</code> 命令详解 (<code>memory</code>, <code>stats</code>, <code>replication</code>, <code>keyspace</code>)</li>
<li><code>used_memory</code> (内存占用)、<code>connected_clients</code> (连接数)、<code>keyspace_hits/misses</code> (命中率)</li>
</ul>
<h2 id="2-常见问题排查-Troubleshooting"><a href="#2-常见问题排查-Troubleshooting" class="headerlink" title="2. 常见问题排查 (Troubleshooting)"></a>2. 常见问题排查 (Troubleshooting)</h2><ul>
<li>Big Key (大Key) 问题发现与处理</li>
<li>Hot Key (热点Key) 问题发现与处理</li>
<li>连接数异常</li>
</ul>
<h2 id="3-Redis安全"><a href="#3-Redis安全" class="headerlink" title="3. Redis安全"></a>3. Redis安全</h2><ul>
<li>设置复杂密码 (<code>requirepass</code>)</li>
<li>禁用或重命名危险命令 (<code>rename-command</code>)</li>
<li>绑定IP (<code>bind</code>) 与防火墙策略</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/10/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E4%BA%8C%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84/" rel="prev" title="二、服务器架构">
                  <i class="fa fa-angle-left"></i> 二、服务器架构
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
