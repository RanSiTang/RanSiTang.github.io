<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="五、SpringSecurity1. 入门与核心概念1.1 为什么需要 Spring Security？在构建任何一个严肃的Web应用时，安全（Security）永远是第一道防线，而不是一个可有可无的附加功能。无论是保护用户数据，还是防止系统被恶意攻击，一个健全的安全机制都是必不可少的。 那么，为什么我们不自己写安全逻辑，而要选择像 Spring Security 这样重量级的框架呢？  1.1.">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring全家桶-SpringSecurity">
<meta property="og:url" content="http://example.com/2025/10/06/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringSecurity/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="五、SpringSecurity1. 入门与核心概念1.1 为什么需要 Spring Security？在构建任何一个严肃的Web应用时，安全（Security）永远是第一道防线，而不是一个可有可无的附加功能。无论是保护用户数据，还是防止系统被恶意攻击，一个健全的安全机制都是必不可少的。 那么，为什么我们不自己写安全逻辑，而要选择像 Spring Security 这样重量级的框架呢？  1.1.">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-06T07:43:07.000Z">
<meta property="article:modified_time" content="2025-10-17T03:09:49.367Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/10/06/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringSecurity/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/10/06/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringSecurity/","path":"2025/10/06/主流框架与工具库/Spring全家桶/Spring全家桶-SpringSecurity/","title":"Spring全家桶-SpringSecurity"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Spring全家桶-SpringSecurity | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81SpringSecurity"><span class="nav-text">五、SpringSecurity</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%85%A5%E9%97%A8%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">1. 入门与核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Spring-Security%EF%BC%9F"><span class="nav-text">1.1 为什么需要 Spring Security？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E5%AE%89%E5%85%A8%E6%8E%A7%E5%88%B6%E7%9A%84%E9%99%B7%E9%98%B1"><span class="nav-text">1.1.1 自己实现安全控制的陷阱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-Spring-Security-%E8%A7%A3%E5%86%B3%E7%9A%84%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98"><span class="nav-text">1.1.2 Spring Security 解决的核心问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-Spring-Security%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF"><span class="nav-text">1.1.3 Spring Security核心优势</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Spring-Security-%E7%AE%80%E4%BB%8B%E4%B8%8E%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88"><span class="nav-text">1.2 Spring Security 简介与架构概览</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A%E5%9F%BA%E4%BA%8E-Servlet-%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="nav-text">1.2.1 核心思想：基于 Servlet 过滤器的责任链模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E5%AE%8F%E8%A7%82%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%BB%8E%E8%AF%B7%E6%B1%82%E5%85%A5%E5%8F%A3%E5%88%B0%E5%AE%89%E5%85%A8%E5%A4%84%E7%90%86"><span class="nav-text">1.2.2 宏观架构：从请求入口到安全处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%EF%BC%9ASecurityContextHolder"><span class="nav-text">1.2.3 状态管理：SecurityContextHolder</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="nav-text">1.3 核心组件详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-SecurityFilterChain"><span class="nav-text">1.3.1 SecurityFilterChain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-%E6%A0%B8%E5%BF%83%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A6%82%E8%A7%88"><span class="nav-text">1.3.2 核心过滤器概览</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-SecurityContextHolderFilter"><span class="nav-text">1. SecurityContextHolderFilter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-CsrfFilter"><span class="nav-text">2. CsrfFilter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-UsernamePasswordAuthenticationFilter"><span class="nav-text">3. UsernamePasswordAuthenticationFilter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-BasicAuthenticationFilter"><span class="nav-text">4. BasicAuthenticationFilter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-AuthorizationFilter"><span class="nav-text">5. AuthorizationFilter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-ExceptionTranslationFilter"><span class="nav-text">6. ExceptionTranslationFilter</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3-Authentication"><span class="nav-text">1.3.3 Authentication</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-4-GrantedAuthority"><span class="nav-text">1.3.4 GrantedAuthority</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-5-UserDetails-UserDetailsService"><span class="nav-text">1.3.5 UserDetails &amp; UserDetailsService</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-6-PasswordEncoder"><span class="nav-text">1.3.6 PasswordEncoder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-7-SecurityContext-SecurityContextHolder"><span class="nav-text">1.3.7 SecurityContext &amp; SecurityContextHolder</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E7%AC%AC%E4%B8%80%E4%B8%AA-Spring-Security-%E5%BA%94%E7%94%A8%EF%BC%88%E2%80%9DHello-Security%E2%80%9D%EF%BC%89"><span class="nav-text">1.4 第一个 Spring Security 应用（”Hello Security”）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%88%9B%E5%BB%BA-Spring-Boot-%E9%A1%B9%E7%9B%AE"><span class="nav-text">第一步：创建 Spring Boot 项目</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-Controller"><span class="nav-text">第二步：创建一个简单的 Controller</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%A7%82%E5%AF%9F%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="nav-text">第三步：启动并观察默认行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E8%BF%9B%E8%A1%8C%E6%9C%80%E7%AE%80-Java-%E9%85%8D%E7%BD%AE"><span class="nav-text">第四步：进行最简 Java 配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E6%AD%A5%EF%BC%9A%E5%86%8D%E6%AC%A1%E6%B5%8B%E8%AF%95"><span class="nav-text">第五步：再次测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%AE%A4%E8%AF%81%EF%BC%88Authentication%EF%BC%89"><span class="nav-text">2. 认证（Authentication）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-text">2.1 认证流程详解（重点）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E5%AE%8F%E8%A7%82%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-text">2.1.1 宏观流程图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4%E5%88%86%E8%A7%A3"><span class="nav-text">2.1.2 详细步骤分解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC-1-%E6%AD%A5-UsernamePasswordAuthenticationFilter-%E6%8B%A6%E6%88%AA%E8%AF%B7%E6%B1%82"><span class="nav-text">第 1 步: UsernamePasswordAuthenticationFilter 拦截请求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC-2-%E6%AD%A5-%E8%B0%83%E7%94%A8-AuthenticationManager"><span class="nav-text">第 2 步: 调用 AuthenticationManager</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC-3-%E6%AD%A5-%E7%AC%AC-4-%E6%AD%A5-AuthenticationManager-%E7%9A%84%E5%AE%9E%E7%8E%B0-ProviderManager"><span class="nav-text">第 3 步 &amp; 第 4 步: AuthenticationManager 的实现 ProviderManager</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC-5-%E6%AD%A5-AuthenticationProvider-%E6%89%A7%E8%A1%8C%E6%A0%B8%E5%BF%83%E8%AE%A4%E8%AF%81"><span class="nav-text">第 5 步: AuthenticationProvider 执行核心认证</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC-10-%E6%AD%A5-%E8%BF%94%E5%9B%9E%E8%AE%A4%E8%AF%81%E7%BB%93%E6%9E%9C"><span class="nav-text">第 10 步: 返回认证结果</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC-11-%E6%AD%A5-%E7%AC%AC-12-%E6%AD%A5-%E5%90%8E%E7%BB%AD%E5%A4%84%E7%90%86"><span class="nav-text">第 11 步 &amp; 第 12 步: 后续处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-UserDetailsService-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.2 UserDetailsService 自定义实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%EF%BC%9F"><span class="nav-text">2.2.1 为什么需要自定义？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4-%E4%BB%A5-MP-%E4%B8%BA%E4%BE%8B"><span class="nav-text">2.2.2 实现步骤 (以 MP 为例)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%88%9B%E5%BB%BA-UserDetailsService-%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-text">3. 创建 UserDetailsService 的实现类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E8%BF%9B%E9%98%B6%EF%BC%9A%E5%8A%A0%E8%BD%BD%E8%A7%92%E8%89%B2%E5%92%8C%E6%9D%83%E9%99%90"><span class="nav-text">2.2.3 进阶：加载角色和权限</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%89%A9%E5%B1%95%E5%AE%9E%E4%BD%93"><span class="nav-text">1. 扩展实体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%9B%B4%E6%96%B0-UserDetailsService"><span class="nav-text">2. 更新 UserDetailsService</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-%E8%87%AA%E5%AE%9A%E4%B9%89-UserDetails-%E5%AE%9E%E7%8E%B0%E7%B1%BB-%E5%8F%AF%E9%80%89%EF%BC%8C%E4%BD%86%E6%8E%A8%E8%8D%90"><span class="nav-text">2.2.4 自定义 UserDetails 实现类 (可选，但推荐)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-PasswordEncoder-%E7%9A%84%E9%80%89%E6%8B%A9%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-text">2.3 PasswordEncoder 的选择与使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%98%8E%E6%96%87%E5%AD%98%E5%82%A8%E5%AF%86%E7%A0%81%EF%BC%9F"><span class="nav-text">2.3.1 为什么不能明文存储密码？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%98%E5%82%A8%EF%BC%9F%E2%80%94%E2%80%94-%E8%87%AA%E9%80%82%E5%BA%94%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0"><span class="nav-text">2.3.2 什么是安全的密码存储？—— 自适应单向函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-Spring-Security-%E6%8F%90%E4%BE%9B%E7%9A%84-PasswordEncoder-%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.3.3 Spring Security 提供的 PasswordEncoder 实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-PasswordEncoder"><span class="nav-text">2.3.4 如何使用 PasswordEncoder</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%A3%B0%E6%98%8E-Bean"><span class="nav-text">1. 声明 Bean</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%9C%A8%E6%B3%A8%E5%86%8C-%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E6%97%B6%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81"><span class="nav-text">2. 在注册&#x2F;修改密码时进行编码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Spring-Security-%E8%87%AA%E5%8A%A8%E8%BF%9B%E8%A1%8C%E9%AA%8C%E8%AF%81"><span class="nav-text">3. Spring Security 自动进行验证</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE"><span class="nav-text">2.4 常见的认证方式配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-%E5%9F%BA%E4%BA%8E%E8%A1%A8%E5%8D%95%E7%9A%84%E8%AE%A4%E8%AF%81-Form-Login"><span class="nav-text">2.4.1 基于表单的认证 (Form Login)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%BB%98%E8%AE%A4%E7%9A%84-Form-Login"><span class="nav-text">1. 默认的 Form Login</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2"><span class="nav-text">2. 自定义登录页面</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-HTTP-Basic-%E8%AE%A4%E8%AF%81"><span class="nav-text">2.4.2 HTTP Basic 认证</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">1. 适用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">2. 工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E9%85%8D%E7%BD%AE"><span class="nav-text">3. 配置</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-%E2%80%9C%E8%AE%B0%E4%BD%8F%E6%88%91%E2%80%9D-Remember-Me-%E5%8A%9F%E8%83%BD"><span class="nav-text">2.4.3 “记住我” (Remember-Me) 功能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E5%9F%BA%E4%BA%8E-Cookie"><span class="nav-text">1. 工作原理 (基于 Cookie)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E9%85%8D%E7%BD%AE"><span class="nav-text">2. 配置</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%8E%88%E6%9D%83%EF%BC%88Authorization%EF%BC%89"><span class="nav-text">3. 授权（Authorization）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%8E%88%E6%9D%83%E5%9F%BA%E7%A1%80%EF%BC%9A%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-text">3.1 授权基础：访问控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%86%B3%E7%AD%96%E6%9C%BA%E5%88%B6"><span class="nav-text">3.1.1 授权流程与决策机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88"><span class="nav-text">1. 授权流程概览</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E5%86%B3%E7%AD%96%E7%BB%84%E4%BB%B6"><span class="nav-text">2. 核心决策组件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">3. 异常处理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E8%A7%92%E8%89%B2-Role-%E4%B8%8E-%E6%9D%83%E9%99%90-Authority-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="nav-text">3.1.2 角色 (Role) 与 权限 (Authority) 的区别与联系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%9F%BA%E4%BA%8E-URL-%E7%9A%84%E8%AF%B7%E6%B1%82%E6%8E%88%E6%9D%83"><span class="nav-text">3.2 基于 URL 的请求授权</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E4%BD%BF%E7%94%A8-http-authorizeHttpRequests-%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE"><span class="nav-text">3.2.1 使用 http.authorizeHttpRequests() 进行配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-requestMatchers-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">3.2.2 requestMatchers() 的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Ant-%E9%A3%8E%E6%A0%BC%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D-Ant-style-Path-Matching"><span class="nav-text">1. Ant 风格路径匹配 (Ant-style Path Matching)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%8C%B9%E9%85%8D-HTTP-%E6%96%B9%E6%B3%95"><span class="nav-text">2. 匹配 HTTP 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Servlet-%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D-MVC-%E5%8C%B9%E9%85%8D"><span class="nav-text">3. Servlet 路径匹配 (MVC 匹配)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E6%A0%B8%E5%BF%83%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="nav-text">3.2.3 核心访问控制方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2-%E6%9D%83%E9%99%90%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="nav-text">3.2.4 基于角色&#x2F;权限的访问控制方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-5-%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B"><span class="nav-text">3.2.5 综合示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%96%B9%E6%B3%95%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AE%89%E5%85%A8%E6%8E%A7%E5%88%B6%EF%BC%88-EnableMethodSecurity%EF%BC%89"><span class="nav-text">3.3 方法级别的安全控制（@EnableMethodSecurity）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E5%A6%82%E4%BD%95%E5%90%AF%E7%94%A8%E6%96%B9%E6%B3%95%E5%AE%89%E5%85%A8"><span class="nav-text">3.3.1 如何启用方法安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-PreAuthorize-PostAuthorize-%E6%9C%80%E5%BC%BA%E5%A4%A7%E3%80%81%E6%9C%80%E7%81%B5%E6%B4%BB%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="nav-text">3.3.2 @PreAuthorize &#x2F; @PostAuthorize: 最强大、最灵活的注解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-PreAuthorize-expression"><span class="nav-text">1. @PreAuthorize(&quot;expression&quot;)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-PostAuthorize-expression"><span class="nav-text">2. @PostAuthorize(&quot;expression&quot;)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-Secured-%E5%92%8C-RolesAllowed-%E7%AE%80%E5%8D%95%E7%9A%84%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="nav-text">3.3.3 @Secured 和 @RolesAllowed: 简单的基于角色的控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Secured-ROLE-NAME-1-ROLE-NAME-2"><span class="nav-text">1. @Secured({&quot;ROLE_NAME_1&quot;, &quot;ROLE_NAME_2&quot;})</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-RolesAllowed-ROLE-1-ROLE-2"><span class="nav-text">2. @RolesAllowed({&quot;ROLE_1&quot;, &quot;ROLE_2&quot;})</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="nav-text">3.3.4 如何选择？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%9C%A8%E6%8E%88%E6%9D%83%E4%B8%AD%E4%BD%BF%E7%94%A8-SpEL-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">3.4 在授权中使用 SpEL 表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-SpEL-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B"><span class="nav-text">3.4.1 SpEL 表达式的核心能力</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%86%85%E7%BD%AE%E7%9A%84%E5%AE%89%E5%85%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">1. 内置的安全表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%AE%BF%E9%97%AE-authentication-%E5%AF%B9%E8%B1%A1"><span class="nav-text">2. 访问 authentication 对象</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-%E5%8A%A8%E6%80%81%E5%88%A4%E6%96%AD%EF%BC%9A%E7%BB%93%E5%90%88%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0"><span class="nav-text">3.4.2 动态判断：结合方法参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E2%80%9C%E6%89%80%E6%9C%89%E6%9D%83%E2%80%9D-%E6%A3%80%E6%9F%A5"><span class="nav-text">1. “所有权” 检查</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8-P-%E6%88%96-Param-%E6%B3%A8%E8%A7%A3%E4%B8%BA%E5%8F%82%E6%95%B0%E5%91%BD%E5%90%8D"><span class="nav-text">2. 使用 @P 或 @Param 注解为参数命名</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-%E8%AE%BF%E9%97%AE-Bean-%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%A4%8D%E6%9D%82%E5%88%A4%E6%96%AD"><span class="nav-text">3.4.3 访问 Bean 方法进行复杂判断</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1-Bean"><span class="nav-text">1. 创建一个授权服务 Bean</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%9C%A8-SpEL-%E4%B8%AD%E8%B0%83%E7%94%A8-Bean-%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">2. 在 SpEL 中调用 Bean 的方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%86%B3%E7%AD%96%E8%80%85%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89"><span class="nav-text">3.5 访问控制决策者（高级）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9A%E6%8A%95%E7%A5%A8%E5%86%B3%E7%AD%96%E6%A8%A1%E5%9E%8B"><span class="nav-text">3.5.1 核心概念：投票决策模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-AccessDecisionVoter-%E6%8E%A5%E5%8F%A3"><span class="nav-text">3.5.2 AccessDecisionVoter&lt;T&gt; 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-AccessDecisionManager-%E6%8E%A5%E5%8F%A3"><span class="nav-text">3.5.3 AccessDecisionManager 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-4-%E7%8E%B0%E4%BB%A3%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E8%BF%9B-AuthorizationManager"><span class="nav-text">3.5.4 现代架构的演进 (AuthorizationManager)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Web-%E5%AE%89%E5%85%A8%E4%B8%8E%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE"><span class="nav-text">4. Web 安全与高级配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-CSRF-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0-%E9%98%B2%E6%8A%A4"><span class="nav-text">4.1 CSRF (跨站请求伪造) 防护</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-CSRF-%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86"><span class="nav-text">4.1.1 CSRF 攻击原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-Spring-Security-%E7%9A%84-CSRF-%E9%98%B2%E6%8A%A4%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%90%8C%E6%AD%A5%E5%99%A8%E4%BB%A4%E7%89%8C%E6%A8%A1%E5%BC%8F-Synchronizer-Token-Pattern"><span class="nav-text">4.1.2 Spring Security 的 CSRF 防护机制：同步器令牌模式 (Synchronizer Token Pattern)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3-Spring-Security-%E7%9A%84-CsrfFilter-%E4%B8%8E-CsrfToken"><span class="nav-text">4.1.3 Spring Security 的 CsrfFilter 与 CsrfToken</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-4-%E4%B8%8E%E5%89%8D%E7%AB%AF%E7%9A%84%E9%9B%86%E6%88%90"><span class="nav-text">4.1.4 与前端的集成</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Thymeleaf-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="nav-text">1. Thymeleaf (服务器端渲染)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-AJAX-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB"><span class="nav-text">2. AJAX (前后端分离)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-CORS-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB-%E9%85%8D%E7%BD%AE"><span class="nav-text">4.2 CORS (跨域资源共享) 配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E5%90%AF%E7%94%A8-CORS-%E6%94%AF%E6%8C%81-cors"><span class="nav-text">4.2.1 启用 CORS 支持: .cors()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E6%8F%90%E4%BE%9B-CORS-%E9%85%8D%E7%BD%AE-CorsConfigurationSource-Bean"><span class="nav-text">4.2.2 提供 CORS 配置: CorsConfigurationSource Bean</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-Session-%E7%AE%A1%E7%90%86"><span class="nav-text">4.3 Session 管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-Session-%E5%88%9B%E5%BB%BA%E7%AD%96%E7%95%A5-SessionCreationPolicy"><span class="nav-text">4.3.1 Session 创建策略 (SessionCreationPolicy)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-Session-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6-Concurrent-Session-Control"><span class="nav-text">4.3.2 Session 并发控制 (Concurrent Session Control)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%B7%BB%E5%8A%A0-Listener"><span class="nav-text">1. 添加 Listener</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E9%85%8D%E7%BD%AE%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-text">2. 配置并发控制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-Session-Fixation-%E4%BC%9A%E8%AF%9D%E5%9B%BA%E5%AE%9A-%E6%94%BB%E5%87%BB%E9%98%B2%E6%8A%A4"><span class="nav-text">4.3.3 Session Fixation (会话固定) 攻击防护</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%9A%E8%AF%9D%E5%9B%BA%E5%AE%9A%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="nav-text">1. 什么是会话固定攻击？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Spring-Security-%E7%9A%84%E9%98%B2%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="nav-text">2. Spring Security 的防护机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E6%B3%A8%E9%94%80-Logout-%E5%8A%9F%E8%83%BD"><span class="nav-text">4.4 注销 (Logout) 功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-%E9%BB%98%E8%AE%A4%E7%9A%84%E6%B3%A8%E9%94%80%E5%8A%9F%E8%83%BD"><span class="nav-text">4.4.1 默认的注销功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E9%94%80%E9%85%8D%E7%BD%AE"><span class="nav-text">4.4.2 自定义注销配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E9%94%80%E6%88%90%E5%8A%9F%E5%90%8E%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-text">4.4.3 自定义注销成功后的处理器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-4-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%B3%A8%E9%94%80%E5%A4%84%E7%90%86%E5%99%A8-LogoutHandler"><span class="nav-text">4.4.4 添加自定义的注销处理器 (LogoutHandler)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">4.5 异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-1-AuthenticationEntryPoint-%E6%9C%AA%E8%AE%A4%E8%AF%81%E7%94%A8%E6%88%B7%E7%9A%84%E2%80%9C%E5%85%A5%E5%8F%A3%E7%82%B9%E2%80%9D"><span class="nav-text">4.5.1 AuthenticationEntryPoint: 未认证用户的“入口点”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-2-AccessDeniedHandler-%E5%B7%B2%E8%AE%A4%E8%AF%81%E4%BD%86%E6%97%A0%E6%9D%83%E9%99%90%E7%94%A8%E6%88%B7%E7%9A%84%E2%80%9C%E5%A4%84%E7%90%86%E5%99%A8%E2%80%9D"><span class="nav-text">4.5.2 AccessDeniedHandler: 已认证但无权限用户的“处理器”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-3-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="nav-text">4.5.3 总结与对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%8E%B0%E4%BB%A3%E5%8C%96%E5%BA%94%E7%94%A8%E9%9B%86%E6%88%90%EF%BC%9AJWT-%E4%B8%8E-OAuth2"><span class="nav-text">5. 现代化应用集成：JWT 与 OAuth2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E6%97%A0%E7%8A%B6%E6%80%81%E8%AE%A4%E8%AF%81%E4%B8%8E-JWT-JSON-Web-Token"><span class="nav-text">5.1 无状态认证与 JWT (JSON Web Token)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%97%A0%E7%8A%B6%E6%80%81%E8%AE%A4%E8%AF%81%EF%BC%9F"><span class="nav-text">5.1.1 为什么需要无状态认证？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-JWT-%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3%EF%BC%9AHeader-Payload-Signature"><span class="nav-text">5.1.2 JWT 结构详解：Header, Payload, Signature</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Header-%E5%A4%B4%E9%83%A8"><span class="nav-text">1. Header (头部)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Payload-%E8%BD%BD%E8%8D%B7"><span class="nav-text">2. Payload (载荷)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Signature-%E7%AD%BE%E5%90%8D"><span class="nav-text">3. Signature (签名)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-%E5%9C%A8-Spring-Security-%E4%B8%AD%E9%9B%86%E6%88%90-JWT"><span class="nav-text">5.1.3 在 Spring Security 中集成 JWT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-%E5%AE%9E%E7%8E%B0-Token-%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6"><span class="nav-text">5.1.4 实现 Token 刷新机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-OAuth2-%E4%B8%8E-OIDC-OpenID-Connect-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">5.2 OAuth2 与 OIDC (OpenID Connect) 核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-OAuth-2-0-%E5%A7%94%E6%89%98%E6%8E%88%E6%9D%83%E7%9A%84%E6%A1%86%E6%9E%B6"><span class="nav-text">5.2.1 OAuth 2.0: 委托授权的框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-OAuth-2-0-%E7%9A%84%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E8%A7%92%E8%89%B2"><span class="nav-text">5.2.2 OAuth 2.0 的四大核心角色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3-%E5%9B%9B%E7%A7%8D%E6%A0%B8%E5%BF%83%E6%8E%88%E6%9D%83%E6%A8%A1%E5%BC%8F-Grant-Types"><span class="nav-text">5.2.3 四种核心授权模式 (Grant Types)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%8E%88%E6%9D%83%E7%A0%81%E6%A8%A1%E5%BC%8F-Authorization-Code-Grant"><span class="nav-text">1. 授权码模式 (Authorization Code Grant)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%AE%80%E5%8C%96%E6%A8%A1%E5%BC%8F-Implicit-Grant-%E5%B7%B2%E4%B8%8D%E6%8E%A8%E8%8D%90"><span class="nav-text">2. 简化模式 (Implicit Grant) - (已不推荐)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F-Resource-Owner-Password-Credentials-Grant-%E5%B7%B2%E4%B8%8D%E6%8E%A8%E8%8D%90"><span class="nav-text">3. 密码模式 (Resource Owner Password Credentials Grant) - (已不推荐)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%87%AD%E8%AF%81%E6%A8%A1%E5%BC%8F-Client-Credentials-Grant"><span class="nav-text">4. 客户端凭证模式 (Client Credentials Grant)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-4-OIDC-OpenID-Connect-%E5%9C%A8-OAuth-2-0-%E4%B9%8B%E4%B8%8A%E6%9E%84%E5%BB%BA%E7%9A%84%E8%AE%A4%E8%AF%81%E5%B1%82"><span class="nav-text">5.2.4 OIDC (OpenID Connect): 在 OAuth 2.0 之上构建的认证层</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-Spring-Security-OAuth2-Client"><span class="nav-text">5.3 Spring Security OAuth2 Client</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1-%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E5%9B%9E%E9%A1%BE"><span class="nav-text">5.3.1 核心流程回顾</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%EF%BC%88%E4%BB%A5-GitHub-%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="nav-text">5.3.2 集成第三方登录（以 GitHub 为例）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-%E8%8E%B7%E5%8F%96%E7%AC%AC%E4%B8%89%E6%96%B9%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="nav-text">5.3.3 获取第三方用户信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-Spring-Security-OAuth2-Resource-Server"><span class="nav-text">5.4 Spring Security OAuth2 Resource Server</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9C%BA%E6%99%AF"><span class="nav-text">5.4.1 核心概念与场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-2-%E4%BB%A4%E7%89%8C%E9%AA%8C%E8%AF%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%96%B9%E5%BC%8F"><span class="nav-text">5.4.2 令牌验证的两种主要方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-3-%E6%9E%84%E5%BB%BA%E5%8F%97-JWT-%E4%BF%9D%E6%8A%A4%E7%9A%84%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">5.4.3 构建受 JWT 保护的资源服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-4-%E5%8F%AF%E9%80%89-%E9%85%8D%E7%BD%AE-Opaque-Token-%E6%A0%A1%E9%AA%8C"><span class="nav-text">5.4.4 [可选] 配置 Opaque Token 校验</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E9%80%89%E5%AD%A6-Spring-Authorization-Server"><span class="nav-text">5.5 [选学] Spring Authorization Server</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%87%AA%E5%BB%BA%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F"><span class="nav-text">5.5.1 为什么需要自建授权服务器？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-2-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BB%84%E4%BB%B6"><span class="nav-text">5.5.2 核心概念与组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-3-%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%80%E5%B0%8F%E5%8C%96%E7%9A%84%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">5.5.3 从零构建一个最小化的授权服务器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%89%A9%E5%B1%95"><span class="nav-text">6. 自定义与扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E8%87%AA%E5%AE%9A%E4%B9%89-SecurityFilterChain"><span class="nav-text">6.1 自定义 SecurityFilterChain</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-1-%E5%85%B3%E9%94%AE-Filter-%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-text">6.1.1 关键 Filter 的顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-2-%E6%B7%BB%E5%8A%A0%E3%80%81%E6%9B%BF%E6%8D%A2%E6%88%96%E7%A7%BB%E9%99%A4%E9%BB%98%E8%AE%A4%E7%9A%84-Filter"><span class="nav-text">6.1.2 添加、替换或移除默认的 Filter</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89-Filter"><span class="nav-text">1. 创建自定义 Filter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%B7%BB%E5%8A%A0-Filter"><span class="nav-text">2. 添加 Filter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9B%BF%E6%8D%A2%E6%88%96%E7%A7%BB%E9%99%A4-Filter"><span class="nav-text">3. 替换或移除 Filter</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%A4%E8%AF%81%E9%80%BB%E8%BE%91"><span class="nav-text">6.2 自定义认证逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1-%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%89%A9%E5%B1%95%E7%82%B9"><span class="nav-text">6.2.1 认证流程回顾与扩展点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2-%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%99%BB%E5%BD%95"><span class="nav-text">6.2.2 案例：实现短信验证码登录</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%A4%E8%AF%81%E6%88%90%E5%8A%9F-%E5%A4%B1%E8%B4%A5%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-text">6.3 自定义认证成功&#x2F;失败处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-AuthenticationSuccessHandler-%E5%A4%84%E7%90%86%E8%AE%A4%E8%AF%81%E6%88%90%E5%8A%9F"><span class="nav-text">6.3.1 AuthenticationSuccessHandler: 处理认证成功</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="nav-text">1. 默认行为</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%EF%BC%9F"><span class="nav-text">2. 为什么需要自定义？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F%E5%90%8E%E8%BF%94%E5%9B%9E-JSON-Token"><span class="nav-text">3. 实现登录成功后返回 JSON Token</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-2-AuthenticationFailureHandler-%E5%A4%84%E7%90%86%E8%AE%A4%E8%AF%81%E5%A4%B1%E8%B4%A5"><span class="nav-text">6.3.2 AuthenticationFailureHandler: 处理认证失败</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA-1"><span class="nav-text">1. 默认行为</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%EF%BC%9F-1"><span class="nav-text">2. 为什么需要自定义？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5%E5%90%8E%E8%BF%94%E5%9B%9E-JSON"><span class="nav-text">3. 实现登录失败后返回 JSON</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E8%87%AA%E5%AE%9A%E4%B9%89-AccessDecisionManager-AuthorizationManager-%E9%AB%98%E7%BA%A7"><span class="nav-text">6.4 自定义 AccessDecisionManager &#x2F; AuthorizationManager (高级)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-1-%E7%8E%B0%E4%BB%A3%E6%9E%B6%E6%9E%84-%E8%87%AA%E5%AE%9A%E4%B9%89-AuthorizationManager"><span class="nav-text">6.4.1 现代架构: 自定义 AuthorizationManager</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-2-%E4%BC%A0%E7%BB%9F%E6%9E%B6%E6%9E%84-%E8%87%AA%E5%AE%9A%E4%B9%89-AccessDecisionManager-%E4%B8%8E-Voter"><span class="nav-text">6.4.2 传统架构: 自定义 AccessDecisionManager 与 Voter</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">7. 测试与最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-Spring-Security-%E6%B5%8B%E8%AF%95"><span class="nav-text">7.1 Spring Security 测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-1-%E6%A0%B8%E5%BF%83%E6%B5%8B%E8%AF%95%E4%BE%9D%E8%B5%96"><span class="nav-text">7.1.1 核心测试依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-2-%E6%A8%A1%E6%8B%9F%E5%B7%B2%E8%AE%A4%E8%AF%81%E7%94%A8%E6%88%B7"><span class="nav-text">7.1.2 模拟已认证用户</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-WithMockUser-%E6%9C%80%E7%AE%80%E5%8D%95%E3%80%81%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E6%A8%A1%E6%8B%9F"><span class="nav-text">1. @WithMockUser: 最简单、最常用的模拟</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-WithUserDetails-%E4%BD%BF%E7%94%A8%E7%9C%9F%E5%AE%9E%E7%9A%84-UserDetailsService"><span class="nav-text">2. @WithUserDetails: 使用真实的 UserDetailsService</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-3-%E7%BB%93%E5%90%88-MockMvc-%E6%B5%8B%E8%AF%95-Controller-%E5%B1%82%E7%9A%84%E5%AE%89%E5%85%A8%E7%AB%AF%E7%82%B9"><span class="nav-text">7.1.3 结合 MockMvc 测试 Controller 层的安全端点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%B5%8B%E8%AF%95%E6%9C%AA%E8%AE%A4%E8%AF%81%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-text">1. 测试未认证的访问</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%B5%8B%E8%AF%95-CSRF-%E9%98%B2%E6%8A%A4"><span class="nav-text">2. 测试 CSRF 防护</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%B5%8B%E8%AF%95%E8%A1%A8%E5%8D%95%E7%99%BB%E5%BD%95"><span class="nav-text">3. 测试表单登录</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E5%AE%89%E5%85%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">7.2 安全最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-1-%E5%A7%8B%E7%BB%88%E4%BD%BF%E7%94%A8-HTTPS"><span class="nav-text">7.2.1 始终使用 HTTPS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-2-%E4%BD%BF%E7%94%A8%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%AF%86%E7%A0%81%E7%BC%96%E7%A0%81%E7%AD%96%E7%95%A5"><span class="nav-text">7.2.2 使用强大的密码编码策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-3-%E6%9C%80%E5%B0%8F%E6%9D%83%E9%99%90%E5%8E%9F%E5%88%99-Principle-of-Least-Privilege"><span class="nav-text">7.2.3 最小权限原则 (Principle of Least Privilege)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-4-%E4%BE%9D%E8%B5%96%E9%A1%B9%E5%AE%89%E5%85%A8%E6%89%AB%E6%8F%8F"><span class="nav-text">7.2.4 依赖项安全扫描</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-5-%E9%81%BF%E5%85%8D%E5%9C%A8%E6%97%A5%E5%BF%97%E4%B8%AD%E8%AE%B0%E5%BD%95%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF"><span class="nav-text">7.2.5 避免在日志中记录敏感信息</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/06/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringSecurity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Spring全家桶-SpringSecurity | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring全家桶-SpringSecurity
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-06 15:43:07" itemprop="dateCreated datePublished" datetime="2025-10-06T15:43:07+08:00">2025-10-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 11:09:49" itemprop="dateModified" datetime="2025-10-17T11:09:49+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/" itemprop="url" rel="index"><span itemprop="name">Spring全家桶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="五、SpringSecurity"><a href="#五、SpringSecurity" class="headerlink" title="五、SpringSecurity"></a>五、SpringSecurity</h1><h2 id="1-入门与核心概念"><a href="#1-入门与核心概念" class="headerlink" title="1. 入门与核心概念"></a>1. 入门与核心概念</h2><h3 id="1-1-为什么需要-Spring-Security？"><a href="#1-1-为什么需要-Spring-Security？" class="headerlink" title="1.1 为什么需要 Spring Security？"></a>1.1 为什么需要 Spring Security？</h3><p>在构建任何一个严肃的Web应用时，<strong>安全（Security）永远是第一道防线，而不是一个可有可无的附加功能</strong>。无论是保护用户数据，还是防止系统被恶意攻击，一个健全的安全机制都是必不可少的。</p>
<p>那么，为什么我们不自己写安全逻辑，而要选择像 Spring Security 这样重量级的框架呢？</p>
<hr>
<h4 id="1-1-1-自己实现安全控制的陷阱"><a href="#1-1-1-自己实现安全控制的陷阱" class="headerlink" title="1.1.1 自己实现安全控制的陷阱"></a>1.1.1 自己实现安全控制的陷阱</h4><p>如果我们尝试自己动手实现安全功能，通常会怎么做？</p>
<ol>
<li><strong>登录验证</strong>：在 Controller 里写一个 <code>login</code> 方法，从请求中获取用户名和密码，查询数据库，比对成功后将用户信息存入 <code>HttpSession</code>。</li>
<li><strong>访问控制</strong>：在需要保护的 Controller 方法或 Service 方法开头，写大量的 <code>if/else</code> 逻辑，从 <code>HttpSession</code> 中取出用户信息，判断其是否有权限访问。</li>
</ol>
<p>这种“手写”方式会带来一系列严重问题：</p>
<ul>
<li><strong>代码高度耦合且重复</strong>：安全逻辑（权限判断）和业务逻辑混杂在一起，遍布在项目的各个角落。一旦权限规则变更，你需要修改大量代码，极难维护。</li>
<li><strong>容易出错且不安全</strong>：安全是一个非常专业的领域。“自己发明”的加密算法、会话管理机制很可能存在未知的漏洞。例如，密码没有加盐（Salt）、容易受到时序攻击（Timing Attacks）、没有防护会话固定（Session Fixation）等。一个微小的疏忽就可能导致整个系统被攻破。</li>
<li><strong>功能不全面</strong>：一个现代Web应用需要的远不止是登录和简单的权限判断。你还需要考虑：<ul>
<li>CSRF（跨站请求伪造）防护</li>
<li>CORS（跨域资源共享）配置</li>
<li>防止暴力破解（如登录失败次数限制）</li>
<li>“记住我”功能  </li>
<li>与其他认证体系（如OAuth2, LDAP）集成</li>
<li>…</li>
</ul>
</li>
</ul>
<p><strong>结论：</strong> “不要重复造轮子”，尤其不要造“安全的轮子”。自己实现安全控制费时费力、极易出错，且难以维护。</p>
<hr>
<h4 id="1-1-2-Spring-Security-解决的核心问题"><a href="#1-1-2-Spring-Security-解决的核心问题" class="headerlink" title="1.1.2 Spring Security 解决的核心问题"></a>1.1.2 Spring Security 解决的核心问题</h4><p>Spring Security 作为一个专业、强大的安全框架，解决了两个最核心、最基础的安全问题：</p>
<ol>
<li><strong>认证 (Authentication) - “你是谁？”</strong><ul>
<li>这是验证用户身份的过程。用户提供一些凭证（Credentials），如用户名和密码、手机验证码、指纹、或是一个Token，系统通过验证这些凭证来确认用户的真实身份。</li>
</ul>
</li>
<li><strong>授权 (Authorization) - “你能做什么？”</strong><ul>
<li>这发生在认证成功之后。系统根据已认证用户的身份（通常是其拥有的角色或权限），来决定他是否有权访问某个资源（如一个URL、一个按钮、一个方法）。</li>
</ul>
</li>
</ol>
<p>Spring Security 提供了一套标准的、可扩展的机制来优雅地处理认证和授权。</p>
<hr>
<h4 id="1-1-3-Spring-Security核心优势"><a href="#1-1-3-Spring-Security核心优势" class="headerlink" title="1.1.3 Spring Security核心优势"></a>1.1.3 Spring Security核心优势</h4><ol>
<li><strong>与 Spring 生态无缝集成</strong><ul>
<li>作为 Spring 家族的一员，它能与 Spring Boot, Spring MVC, Spring Data 等项目完美整合。通过简单的依赖引入和自动化配置，你就能快速拥有一个基础的安全环境。</li>
</ul>
</li>
<li><strong>声明式安全 (Declarative Security)</strong><ul>
<li>你不再需要在业务代码中手动编写 <code>if-else</code> 来判断权限。Spring Security 允许你通过<strong>配置</strong>和<strong>注解</strong>来声明安全规则。</li>
<li><strong>例如</strong>：<ul>
<li><strong>配置层面</strong>：<code>http.authorizeHttpRequests(auth -&gt; auth.requestMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;))</code>，一行代码保护所有 <code>/admin/</code> 开头的 URL。</li>
<li><strong>方法层面</strong>：在方法上加一个注解 <code>@PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;)</code>，就完成了对该方法的权限控制。</li>
</ul>
</li>
<li>这种方式让安全逻辑与业务逻辑彻底解耦，代码更清晰，维护性更高。</li>
</ul>
</li>
<li><strong>全面且强大的功能</strong><ul>
<li><strong>全面的认证支持</strong>：支持基于表单、HTTP Basic、LDAP、OAuth2、OpenID Connect、SAML 等多种认证方式。</li>
<li><strong>精细的授权控制</strong>：支持基于URL的授权、基于方法的授权，并且可以使用强大的SpEL表达式进行复杂的动态授权。</li>
<li><strong>内置常见Web攻击防护</strong>：默认开启并强制执行 CSRF 防护、会话固定攻击防护、点击劫持（Clickjacking）防护等，大大提升了应用的安全性。</li>
</ul>
</li>
<li><strong>高度可扩展</strong><ul>
<li>Spring Security 的设计遵循“面向接口编程”和“责任链模式”。几乎每一个核心组件（如 <code>UserDetailsService</code>, <code>PasswordEncoder</code>, <code>AuthenticationProvider</code>）都是可替换、可扩展的。这意味着你可以轻松地将其定制为你需要的任何认证授权模式（如短信验证码登录、扫码登录等）。</li>
</ul>
</li>
<li><strong>久经考验，社区活跃</strong><ul>
<li>它是一个非常成熟的开源项目，被全球数百万的Java项目所使用，其稳定性和安全性经过了长时间和大规模应用的检验。活跃的社区和及时的版本更新也保证了它可以持续对抗新出现的安全威胁。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-2-Spring-Security-简介与架构概览"><a href="#1-2-Spring-Security-简介与架构概览" class="headerlink" title="1.2 Spring Security 简介与架构概览"></a>1.2 Spring Security 简介与架构概览</h3><h4 id="1-2-1-核心思想：基于-Servlet-过滤器的责任链模式"><a href="#1-2-1-核心思想：基于-Servlet-过滤器的责任链模式" class="headerlink" title="1.2.1 核心思想：基于 Servlet 过滤器的责任链模式"></a>1.2.1 核心思想：基于 Servlet 过滤器的责任链模式</h4><p>Spring Security 的核心是<strong>一系列的 Servlet 过滤器（Servlet Filter）</strong>。</p>
<p>Spring Security 利用了 Servlet Filter 这一标准机制。它将不同的安全职责（如 CSRF 防护、Session 管理、认证处理、授权检查等）封装到一个个独立的 Filter 中，并将它们组织成一个<strong>有序的链条（Filter Chain）</strong>。</p>
<p>当一个 HTTP 请求进入应用时，它会像通过依次穿过这个过滤器链。</p>
<ul>
<li><strong>优点</strong>：<ul>
<li><strong>解耦</strong>：每个 Filter 只关心自己的职责，高度内聚。</li>
<li><strong>可插拔</strong>：我们可以根据需要，轻松地在链条中添加、移除或替换某个 Filter，实现高度定制化。</li>
<li><strong>与框架无关</strong>：由于它工作在 Servlet 层面，因此它能在 <code>DispatcherServlet</code> 之前就保护你的应用，而不仅仅是保护 Spring MVC 的 Controller。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-2-宏观架构：从请求入口到安全处理"><a href="#1-2-2-宏观架构：从请求入口到安全处理" class="headerlink" title="1.2.2 宏观架构：从请求入口到安全处理"></a>1.2.2 宏观架构：从请求入口到安全处理</h4><p>一个典型的请求在 Spring Security 中的旅程如下：</p>
<pre><code class="highlight mermaid">graph LR


    subgraph &quot;Spring容器&quot;
        subgraph C[&quot;FilterChainProxy&quot;]
            E[SecurityFilterChain]
            F[SecurityFilterChain]
            G[SecurityFilterChain]
            ....
        end
    end

    subgraph &quot;Servlet容器&quot;
        subgraph &quot;过滤器链&quot;
            B[DelegatingFilterProxy]
        end
    end

    A[客户端]
    A--&gt;|HTTP请求|B
    B--&gt;C</code></pre>

<ol>
<li><strong>客户端</strong> 发起一个 HTTP 请求（例如，访问 <code>/dashboard</code>）。</li>
<li>请求首先到达 <strong>Servlet 容器</strong>（如 Tomcat）。</li>
<li>容器的过滤器链中，一个名为 <code>DelegatingFilterProxy</code> 的特殊 Filter 会被触发。</li>
<li><strong><code>DelegatingFilterProxy</code></strong>：<ul>
<li>它本身是一个标准的 Servlet Filter，生命周期由 Servlet 容器管理。</li>
<li>它的作用像一个**“桥梁”<strong>，它不做任何安全逻辑，唯一的任务就是在 Spring 的应用上下文（ApplicationContext）中找到一个名为 <code>springSecurityFilterChain</code>（这是一个 Bean 的名字）的代理，并将请求处理</strong>委托（Delegate）**给它。</li>
<li><strong>为什么需要这个桥梁？</strong> 因为 Servlet Filter 是由容器加载的，而 Spring Security 的所有组件都是 Spring 管理的 Bean。<code>DelegatingFilterProxy</code> 解决了 Servlet 世界和 Spring 世界之间的连接问题。</li>
</ul>
</li>
<li><strong><code>FilterChainProxy</code></strong> (即 <code>springSecurityFilterChain</code> Bean)：<ul>
<li>这是一个由 Spring Security 提供的功能极其强大的 Filter。可以称它为**“过滤器链的管理者”**。</li>
<li>它内部维护了<strong>一个或多个安全过滤器链 (<code>SecurityFilterChain</code>)</strong>。</li>
<li>当请求到达时，<code>FilterChainProxy</code> 会根据请求的 URL 路径，决定使用哪一个 <code>SecurityFilterChain</code> 来处理这个请求。这允许我们为不同的路径（如 <code>/api/**</code> 和 <code>/web/**</code>）配置完全不同的安全策略。</li>
</ul>
</li>
<li><strong><code>SecurityFilterChain</code></strong>：<ul>
<li>这就是我们通常通过 Java 配置（<code>@Bean public SecurityFilterChain ...</code>）来定义的东西。它是一个<strong>包含了多个具体安全过滤器的有序列表</strong>。</li>
<li>请求会按照这个列表的顺序，依次通过每一个 Filter。</li>
<li><strong>常见的 Filter 包括（顺序很重要）</strong>：<ul>
<li><code>CsrfFilter</code>: 进行 CSRF 令牌校验。</li>
<li><code>UsernamePasswordAuthenticationFilter</code>: 处理基于表单的用户名密码登录请求。</li>
<li><code>BasicAuthenticationFilter</code>: 处理 HTTP Basic 认证。</li>
<li><code>AuthorizationFilter</code>: 检查用户是否有权限访问请求的资源。</li>
<li>等等…</li>
</ul>
</li>
</ul>
</li>
<li><strong>处理流程</strong>：<ul>
<li>如果请求在链条的某个 Filter 中处理失败（例如，CSRF 令牌无效，或认证失败），该 Filter 会**“短路” (Short-circuit)** 整个流程，直接向客户端返回错误响应（如 401 Unauthorized 或 403 Forbidden），请求将不会到达后续的 Filter 或业务代码。</li>
<li>如果请求成功通过了整个过滤器链，它最终会被放行，到达 <code>DispatcherServlet</code>，并由你的 Controller 进行处理。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-2-3-状态管理：SecurityContextHolder"><a href="#1-2-3-状态管理：SecurityContextHolder" class="headerlink" title="1.2.3 状态管理：SecurityContextHolder"></a>1.2.3 状态管理：<code>SecurityContextHolder</code></h4><p>当一个用户通过认证后，他的身份信息（比如用户名、角色权限）将会存放到 <strong><code>SecurityContextHolder</code></strong>。</p>
<ul>
<li><strong><code>SecurityContextHolder</code></strong> 是一个<strong>全局的、静态的</strong>工具类，用于存储和获取当前线程的安全上下文（<code>SecurityContext</code>）。</li>
<li>默认情况下，它使用 <strong><code>ThreadLocal</code></strong> 策略来存储 <code>SecurityContext</code>。这意味着安全上下文与<strong>当前执行的线程</strong>绑定。当一个请求进入时，Spring Security 会为该请求的线程创建一个<code>SecurityContext</code>；当请求处理完毕时，它会清理这个上下文。</li>
<li><strong><code>SecurityContext</code></strong>：它主要的作用是持有 <code>Authentication</code> 对象。</li>
<li><strong><code>Authentication</code></strong>：这是 Spring Security 中代表认证信息的核心接口。它包含了：<ul>
<li><strong><code>principal</code></strong>: 代表“当事人”，通常是 <code>UserDetails</code> 对象，包含了用户的详细信息（用户名、密码、账户状态等）。</li>
<li><strong><code>authorities</code></strong>: 代表用户拥有的权限集合（如 <code>ROLE_ADMIN</code>, <code>READ_PRIVILEGE</code>）。</li>
<li><strong><code>credentials</code></strong>: 用户的凭证（如密码），在认证成功后通常会被清空。</li>
</ul>
</li>
</ul>
<p><strong>整个流程串联起来</strong>：当 <code>UsernamePasswordAuthenticationFilter</code> 成功认证一个用户后，它会创建一个完整的 <code>Authentication</code> 对象，并将其设置到 <code>SecurityContextHolder.getContext()</code> 中。之后，当请求到达 <code>AuthorizationFilter</code> 时，它就会从 <code>SecurityContextHolder</code> 中取出这个 <code>Authentication</code> 对象，检查其中的权限，来决定是否放行。你的业务代码中也可以随时通过 <code>SecurityContextHolder</code> 获取当前登录用户的信息。</p>
<hr>
<h3 id="1-3-核心组件详解"><a href="#1-3-核心组件详解" class="headerlink" title="1.3 核心组件详解"></a>1.3 核心组件详解</h3><h4 id="1-3-1-SecurityFilterChain"><a href="#1-3-1-SecurityFilterChain" class="headerlink" title="1.3.1 SecurityFilterChain"></a>1.3.1 <code>SecurityFilterChain</code></h4><ul>
<li><p><strong>是什么？</strong></p>
<ul>
<li><code>SecurityFilterChain</code> 是一个接口，其实现类包含一个<strong>有序的 Servlet Filter 列表</strong>。它代表了一套完整的、针对特定 HTTP 请求的安全处理策略。</li>
</ul>
</li>
<li><p><strong>职责</strong>：</p>
<ul>
<li>定义哪些过滤器（Filters）被应用。</li>
<li>定义这些过滤器的应用顺序。</li>
<li>定义这个过滤器链作用于哪些 HTTP 请求（通过 <code>requestMatcher</code>）。</li>
</ul>
</li>
<li><p><strong>现代配置的核心</strong>：</p>
<ul>
<li>在现代的 Spring Security 配置中（Spring Boot 2.7+），我们不再继承 <code>WebSecurityConfigurerAdapter</code>（已废弃），而是直接在 <code>@Configuration</code> 类中定义一个或多个 <code>@Bean</code> 方法，返回 <code>SecurityFilterChain</code> 实例。</li>
<li>每个 <code>SecurityFilterChain</code> Bean 都定义了一套独立的、互不干扰的安全规则。这使得我们可以非常灵活地为不同路径（如 <code>/api/**</code> 和 <code>/</code>）配置不同的安全策略。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">apiFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .securityMatcher(<span class="string">&quot;/api/**&quot;</span>) <span class="comment">// 这个链只处理 /api/ 开头的请求</span></span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth.anyRequest().authenticated())</span><br><span class="line">            .httpBasic(); <span class="comment">// 对 API 使用 HTTP Basic 认证</span></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">webFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                .requestMatchers(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/css/**&quot;</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            .formLogin(); <span class="comment">// 对其他所有请求使用表单登录</span></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-3-2-核心过滤器概览"><a href="#1-3-2-核心过滤器概览" class="headerlink" title="1.3.2 核心过滤器概览"></a>1.3.2 核心过滤器概览</h4><h5 id="1-SecurityContextHolderFilter"><a href="#1-SecurityContextHolderFilter" class="headerlink" title="1. SecurityContextHolderFilter"></a>1. <code>SecurityContextHolderFilter</code></h5><ul>
<li><strong>核心职责：</strong> <strong>建立和清理安全上下文（SecurityContext）。</strong> 它是责任链中非常靠前的一个过滤器。</li>
<li><strong>详细说明：</strong><ul>
<li><strong>请求进入时：</strong> 它的主要任务是从 <code>SecurityContextRepository</code> (通常是基于 <code>HttpSession</code>) 中加载 <code>SecurityContext</code>，然后将其设置到 <code>SecurityContextHolder</code> 中。这样，在整个请求处理期间，后续的过滤器、AOP 切面以及你自己的业务代码都能通过 <code>SecurityContextHolder.getContext()</code> 方便地获取到当前用户的认证信息。</li>
<li><strong>请求结束时：</strong> 在 <code>finally</code> 块中，它会清理 <code>SecurityContextHolder</code> 中的内容，防止因线程复用导致的数据泄露。同时，它会将变更后的 <code>SecurityContext</code> 写回 <code>SecurityContextRepository</code>，实现状态持久化。</li>
</ul>
</li>
</ul>
<h5 id="2-CsrfFilter"><a href="#2-CsrfFilter" class="headerlink" title="2. CsrfFilter"></a>2. <code>CsrfFilter</code></h5><ul>
<li><strong>核心职责：</strong> <strong>防御跨站请求伪造（CSRF）攻击。</strong></li>
<li><strong>详细说明：</strong> 该过滤器会检查所有“状态变更”的请求（如 <code>POST</code>, <code>PUT</code>, <code>DELETE</code>），验证请求中是否包含一个合法、有效的 CSRF 令牌（Token）。如果令牌不存在或不匹配，请求将被直接拒绝。对于 <code>GET</code> 等安全请求，它通常会生成一个新的令牌并附加到响应中，供前端后续使用。</li>
</ul>
<h5 id="3-UsernamePasswordAuthenticationFilter"><a href="#3-UsernamePasswordAuthenticationFilter" class="headerlink" title="3. UsernamePasswordAuthenticationFilter"></a>3. <code>UsernamePasswordAuthenticationFilter</code></h5><ul>
<li><strong>核心职责：</strong> <strong>处理基于表单的用户名和密码登录请求。</strong> 它是认证（Authentication）过程中的关键角色。</li>
<li><strong>详细说明：</strong> 这个过滤器<strong>只关心特定的登录 URL</strong>（默认为 <code>/login</code> 且为 <code>POST</code> 请求）。当请求匹配时，它会从请求体中提取用户名和密码，将它们封装成一个 <code>UsernamePasswordAuthenticationToken</code>（一个 <code>Authentication</code> 的实现类），然后委托给 <code>AuthenticationManager</code> 去执行真正的认证逻辑。</li>
</ul>
<h5 id="4-BasicAuthenticationFilter"><a href="#4-BasicAuthenticationFilter" class="headerlink" title="4. BasicAuthenticationFilter"></a>4. <code>BasicAuthenticationFilter</code></h5><ul>
<li><strong>核心职责：</strong> <strong>处理 HTTP Basic 认证。</strong></li>
<li><strong>详细说明：</strong> 它会检查请求头中是否存在 <code>Authorization: Basic &lt;base64-encoded-credentials&gt;</code>。如果存在，它会解码其中的用户名和密码，并同样委托给 <code>AuthenticationManager</code> 进行认证。这是一种无状态的认证方式，常用于 API 接口。</li>
</ul>
<h5 id="5-AuthorizationFilter"><a href="#5-AuthorizationFilter" class="headerlink" title="5. AuthorizationFilter"></a>5. <code>AuthorizationFilter</code></h5><ul>
<li><strong>核心职责：</strong> <strong>执行授权（Authorization）决策。</strong> 这是访问控制的核心。</li>
<li><strong>详细说明：</strong> 这个过滤器位于认证过滤器之后。当一个请求到达时，它会从 <code>SecurityContextHolder</code> 中获取已经认证成功的 <code>Authentication</code> 对象（包含了用户的角色和权限），然后根据你在配置中定义的访问规则（例如 <code>authorizeHttpRequests().requestMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)</code>），判断当前用户是否有权限访问请求的资源。如果无权访问，它会抛出 <code>AccessDeniedException</code>。</li>
</ul>
<h5 id="6-ExceptionTranslationFilter"><a href="#6-ExceptionTranslationFilter" class="headerlink" title="6. ExceptionTranslationFilter"></a>6. <code>ExceptionTranslationFilter</code></h5><ul>
<li><strong>核心职责：</strong> <strong>捕获安全相关的异常并进行“翻译”和处理。</strong> 它是整个安全体系的“异常调度中心”。</li>
<li><strong>详细说明：</strong> 它本身不处理请求，而是使用 <code>try-catch</code> 块包裹了后续的过滤器链调用。<ul>
<li>如果捕获到 <code>AuthenticationException</code>（认证失败，通常意味着用户根本没登录），它会启动认证流程，例如重定向到登录页面。</li>
<li>如果捕获到 <code>AccessDeniedException</code>（授权失败，用户已登录但权限不足），它会委托给 <code>AccessDeniedHandler</code> 进行处理，通常是返回 403 Forbidden 页面或错误信息。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-3-Authentication"><a href="#1-3-3-Authentication" class="headerlink" title="1.3.3 Authentication"></a>1.3.3 <code>Authentication</code></h4><ul>
<li><strong>是什么？</strong><ul>
<li><code>Authentication</code> 是 Spring Security 中代表**“认证信息”**的核心接口。它封装了一个安全请求的所有信息。</li>
</ul>
</li>
<li><strong>职责</strong>：<ul>
<li>回答 <strong>“你是谁？”</strong></li>
<li>在认证<strong>前</strong>，它通常包含用户提交的凭证（如用户名和密码）。</li>
<li>在认证<strong>后</strong>，它包含经过验证的用户主体（Principal）、权限列表，并标记为“已认证”。</li>
</ul>
</li>
<li><strong>核心方法</strong>：<ul>
<li><code>getPrincipal()</code>: 返回用户主体。认证前可能是用户名（一个 <code>String</code>），认证后通常是一个 <code>UserDetails</code> 对象。</li>
<li><code>getCredentials()</code>: 返回用户凭证（如密码）。<strong>认证成功后，框架会自动清空它以策安全</strong>。</li>
<li><code>getAuthorities()</code>: 返回授予用户的权限集合 (<code>Collection&lt;? extends GrantedAuthority&gt;</code>)。</li>
<li><code>isAuthenticated()</code>: 返回一个布尔值，表示此 <code>Authentication</code> 对象是否已经通过了认证。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-4-GrantedAuthority"><a href="#1-3-4-GrantedAuthority" class="headerlink" title="1.3.4 GrantedAuthority"></a>1.3.4 <code>GrantedAuthority</code></h4><ul>
<li><strong>是什么？</strong><ul>
<li><code>GrantedAuthority</code> 是一个接口，代表授予用户主体的**“权限”**。</li>
</ul>
</li>
<li><strong>职责</strong>：<ul>
<li>回答 <strong>“你能做什么？”</strong></li>
<li>它可以是一个角色（如 <code>ROLE_ADMIN</code>），也可以是一个更细粒度的权限（如 <code>user:delete</code>）。Spring Security 默认情况下，如果你的字符串以 <code>ROLE_</code> 开头，它会将其视为一个角色。</li>
</ul>
</li>
<li><strong>核心方法</strong>：<ul>
<li><code>getAuthority()</code>: 返回权限的字符串表示。这个字符串会被 <code>AccessDecisionManager</code>（授权管理器）用来做决策。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-5-UserDetails-UserDetailsService"><a href="#1-3-5-UserDetails-UserDetailsService" class="headerlink" title="1.3.5 UserDetails &amp; UserDetailsService"></a>1.3.5 <code>UserDetails</code> &amp; <code>UserDetailsService</code></h4><p>这两个组件是连接你的**用户数据存储（如数据库）**和 <strong>Spring Security 框架</strong>之间的桥梁。</p>
<ul>
<li><p><strong><code>UserDetails</code></strong> (接口):</p>
<ul>
<li><strong>是什么？</strong> 它是对你的**用户模型（User Model）**在安全层面的一个抽象。它不关心你的用户有多少个字段（如年龄、邮箱），只关心安全相关的核心数据。</li>
<li><strong>职责</strong>：提供框架所需的核心用户信息。</li>
<li><strong>核心方法</strong>：<ul>
<li><code>getUsername()</code>: 用户名。</li>
<li><code>getPassword()</code>: <strong>已编码的</strong>密码。</li>
<li><code>getAuthorities()</code>: 用户的权限集合 (<code>Collection&lt;? extends GrantedAuthority&gt;</code>)。</li>
<li><code>isAccountNonExpired()</code>, <code>isAccountNonLocked()</code>, <code>isCredentialsNonExpired()</code>, <code>isEnabled()</code>: 一系列表示账户状态的方法，用于控制账户是否可用。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>UserDetailsService</code></strong> (接口):</p>
<ul>
<li><strong>是什么？</strong> 这是一个**数据访问对象（DAO）**模式的接口。</li>
<li><strong>职责</strong>：根据一个用户名（<code>String</code>）加载对应的 <code>UserDetails</code> 对象。</li>
<li><strong>核心方法</strong>：<ul>
<li><code>loadUserByUsername(String username)</code>: 这是该接口唯一的方法。你需要实现这个方法，在其中编写从数据库、LDAP或其他来源查询用户数据的逻辑。如果找不到用户，必须抛出 <code>UsernameNotFoundException</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JpaUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findByUsername(username)</span><br><span class="line">            .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;User not found: &quot;</span> + username));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-3-6-PasswordEncoder"><a href="#1-3-6-PasswordEncoder" class="headerlink" title="1.3.6 PasswordEncoder"></a>1.3.6 <code>PasswordEncoder</code></h4><ul>
<li><strong>是什么？</strong><ul>
<li>一个用于<strong>密码编码和验证</strong>的服务接口。</li>
</ul>
</li>
<li><strong>职责</strong>：<ul>
<li><code>encode(CharSequence rawPassword)</code>: 将原始明文密码进行单向加密（哈希），生成一个安全的密码摘要。</li>
<li><code>matches(CharSequence rawPassword, String encodedPassword)</code>: 比较用户提交的原始密码和数据库中存储的已编码密码是否匹配。它会自动处理盐（salt）的提取和比对。</li>
</ul>
</li>
<li><strong>安全存储密码的基石</strong>：<ul>
<li><strong>绝对不能</strong>在数据库中存储明文密码！</li>
<li><code>PasswordEncoder</code> 使用<strong>单向哈希算法</strong>（如 BCrypt, SCrypt, Argon2），这意味着无法从加密后的字符串反推出原始密码。</li>
<li>它还自动包含了**“加盐（Salting）”**机制，即使两个用户设置了相同的密码，他们在数据库中存储的哈希值也是不同的，有效防止了彩虹表攻击。</li>
<li><strong>推荐使用</strong>：<code>BCryptPasswordEncoder</code> 是目前最常用和推荐的选择。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-7-SecurityContext-SecurityContextHolder"><a href="#1-3-7-SecurityContext-SecurityContextHolder" class="headerlink" title="1.3.7 SecurityContext &amp; SecurityContextHolder"></a>1.3.7 <code>SecurityContext</code> &amp; <code>SecurityContextHolder</code></h4><ul>
<li><strong><code>SecurityContext</code></strong> (接口):<ul>
<li><strong>是什么？</strong> 安全上下文。它本身非常简单，主要职责就是<strong>持有 <code>Authentication</code> 对象</strong>。</li>
<li><strong>核心方法</strong>:<ul>
<li><code>getAuthentication()</code>: 获取认证信息。</li>
<li><code>setAuthentication(Authentication authentication)</code>: 设置认证信息。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>SecurityContextHolder</code></strong> (类):<ul>
<li><strong>是什么？</strong> 一个工具类，用于<strong>存储、访问和管理</strong> <code>SecurityContext</code>。它是外界与当前请求的安全信息交互的<strong>唯一入口</strong>。</li>
<li><strong>职责</strong>：将 <code>SecurityContext</code> 与当前执行线程关联起来。</li>
<li><strong>工作模式</strong>:<ul>
<li>默认使用 <code>ThreadLocal</code> 策略。这意味着 <code>SecurityContext</code> 的生命周期与一个请求线程绑定。当请求开始时，过滤器链会准备好 <code>SecurityContext</code>；请求结束时，<code>SecurityContextHolder</code> 会被清空。这保证了不同请求之间的安全信息是隔离的。</li>
</ul>
</li>
<li><strong>如何使用</strong>:<ul>
<li>在应用的任何地方，你都可以通过静态方法 <code>SecurityContextHolder.getContext().getAuthentication()</code> 来获取当前登录用户的 <code>Authentication</code> 对象，进而得到用户名、权限等信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-4-第一个-Spring-Security-应用（”Hello-Security”）"><a href="#1-4-第一个-Spring-Security-应用（”Hello-Security”）" class="headerlink" title="1.4 第一个 Spring Security 应用（”Hello Security”）"></a>1.4 第一个 Spring Security 应用（”Hello Security”）</h3><ul>
<li>依赖引入 (<code>spring-boot-starter-security</code>)</li>
<li>默认的安全配置与自动生成的登录页</li>
<li>最简 Java 配置 (<code>@Configuration</code> &amp; <code>@Bean SecurityFilterChain</code>)</li>
</ul>
<p>这一节的目标是快速搭建一个最基础的 Spring Boot 项目，并引入 Spring Security，观察它在“零配置”下的默认行为，然后通过最简单的 Java 配置对其进行自定义。</p>
<h4 id="第一步：创建-Spring-Boot-项目"><a href="#第一步：创建-Spring-Boot-项目" class="headerlink" title="第一步：创建 Spring Boot 项目"></a>第一步：创建 Spring Boot 项目</h4><p><strong>项目设置:</strong></p>
<ul>
<li><strong>Project</strong>: Maven Project (或 Gradle)</li>
<li><strong>Language</strong>: Java</li>
<li><strong>Spring Boot</strong>: 推荐选择一个稳定的新版本 (如 3.1.x 或更高)</li>
<li><strong>Project Metadata</strong>:<ul>
<li><strong>Group</strong>: <code>com.example</code></li>
<li><strong>Artifact</strong>: <code>hello-security</code></li>
<li><strong>Packaging</strong>: Jar</li>
<li><strong>Java</strong>: 17 (或更高)</li>
</ul>
</li>
</ul>
<p><strong>添加依赖 (Dependencies):</strong></p>
<ol>
<li><strong>Spring Web</strong>: 用于构建 Web 应用，提供 MVC 功能。</li>
<li><strong>Spring Security</strong>: 这是我们的主角，引入安全功能。</li>
<li><strong>(可选) Thymeleaf</strong>: 一个模板引擎，方便我们创建一个简单的页面来测试。</li>
</ol>
<hr>
<h4 id="第二步：创建一个简单的-Controller"><a href="#第二步：创建一个简单的-Controller" class="headerlink" title="第二步：创建一个简单的 Controller"></a>第二步：创建一个简单的 Controller</h4><p>为了测试安全保护，我们需要创建一个简单的 REST Controller，它有一个公共访问的首页和一个需要保护的页面。</p>
<p>在 <code>src/main/java/com/example/hellosecurity</code> 包下创建一个 <code>HomeController.java</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">home</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;h1&gt;Welcome to the Home Page!&lt;/h1&gt;&lt;p&gt;This page is public.&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/dashboard&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dashboard</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;h1&gt;Welcome to your Dashboard!&lt;/h1&gt;&lt;p&gt;This page is protected.&lt;/p&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="第三步：启动并观察默认行为"><a href="#第三步：启动并观察默认行为" class="headerlink" title="第三步：启动并观察默认行为"></a>第三步：启动并观察默认行为</h4><p>现在，<strong>不要做任何额外的配置</strong>，直接运行 <code>HelloSecurityApplication</code> 类来启动项目。</p>
<p><strong>你会发现：</strong></p>
<ol>
<li><p><strong>控制台输出密码</strong>：<br>在应用启动的日志中，你会看到一行类似这样的输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Using generated security password: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</span><br></pre></td></tr></table></figure>

<p>这是 Spring Security 见你没有配置任何用户，为了方便开发，自动为你生成了一个用户名为 <code>user</code>，密码为这一长串随机字符串的用户。</p>
</li>
<li><p><strong>访问受保护的页面</strong>：<br>打开浏览器，访问 <code>http://localhost:8080/dashboard</code>。<br>你不会看到 “Welcome to your Dashboard!”，而是会被<strong>重定向</strong>到一个由 Spring Security 自动生成的登录页面（<code>http://localhost:8080/login</code>）。</p>
</li>
<li><p><strong>尝试登录</strong>：</p>
<ul>
<li><strong>用户名</strong>: <code>user</code></li>
<li><strong>密码</strong>: 从控制台日志中复制那一长串随机密码。</li>
<li>点击登录后，你会被成功重定向到 <code>/dashboard</code> 页面，并看到我们预期的内容。</li>
</ul>
</li>
<li><p><strong>访问公共页面</strong>：<br>现在，即使你没有登录，访问 <code>http://localhost:8080/</code>。你会发现这个页面可以正常访问。这是因为 Spring Security 的默认策略通常会放行根路径和一些静态资源。</p>
</li>
</ol>
<p><strong>结论</strong>：仅仅通过引入 <code>spring-boot-starter-security</code> 依赖，Spring Security 就已经自动为我们的应用提供了以下功能：</p>
<ul>
<li><strong>保护所有端点</strong>：默认情况下，除了少数例外，所有请求都需要认证。</li>
<li><strong>生成登录表单</strong>：提供了一个基础的、功能完备的登录页面。</li>
<li><strong>默认用户</strong>：创建了一个内存中的用户以供测试。</li>
<li><strong>基础安全防护</strong>：CSRF 保护、HTTP Header 安全设置等都已经默认开启。</li>
</ul>
<hr>
<h4 id="第四步：进行最简-Java-配置"><a href="#第四步：进行最简-Java-配置" class="headerlink" title="第四步：进行最简 Java 配置"></a>第四步：进行最简 Java 配置</h4><p>自动生成的密码非常不方便。现在，让我们通过最简单的 Java 配置来自定义安全行为。</p>
<ol>
<li><p><strong>创建配置类</strong>:<br>在 <code>com.example.hellosecurity</code> 包下创建一个 <code>SecurityConfig.java</code> 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean 1: 定义一个密码编码器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 BCrypt 强哈希函数进行加密</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean 2: 定义用户信息服务 (UserDetailsService)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个基于内存的用户信息管理器</span></span><br><span class="line">        <span class="type">InMemoryUserDetailsManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个用户，密码必须经过 passwordEncoder 加密</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> User.withUsername(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                .password(passwordEncoder().encode(<span class="string">&quot;password&quot;</span>))</span><br><span class="line">                .roles(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        </span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">admin</span> <span class="operator">=</span> User.withUsername(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                .password(passwordEncoder().encode(<span class="string">&quot;password&quot;</span>))</span><br><span class="line">                .roles(<span class="string">&quot;ADMIN&quot;</span>, <span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        manager.createUser(user);</span><br><span class="line">        manager.createUser(admin);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean 3: 定义安全过滤器链 (SecurityFilterChain)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">                        .requestMatchers(<span class="string">&quot;/dashboard&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>) <span class="comment">// /dashboard 只有 ADMIN 角色可以访问</span></span><br><span class="line">                        .requestMatchers(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;/login&quot;</span>).permitAll() <span class="comment">// 首页与登陆页允许所有用户访问</span></span><br><span class="line">                        .anyRequest().authenticated() <span class="comment">// 其他所有请求都需要认证</span></span><br><span class="line">                )</span><br><span class="line">            	<span class="comment">// 启用基于表单的登录认证功能</span></span><br><span class="line">                .formLogin(</span><br><span class="line">        			<span class="comment">// 下面这行的 permitAll 是让Spring Security知道</span></span><br><span class="line">                    <span class="comment">// formLogin() 这个机制本身是开放的，但它不会影响</span></span><br><span class="line">                    <span class="comment">// authorizeHttpRequests 对 /login URL 的访问控制。</span></span><br><span class="line">                    <span class="comment">// 这就是为什么你必须在 authorizeHttpRequests 中也进行配置。    	</span></span><br><span class="line">		            AbstractAuthenticationFilterConfigurer::permitAll</span><br><span class="line">                )</span><br><span class="line">                .logout(logout -&gt; logout</span><br><span class="line">                        .logoutSuccessUrl(<span class="string">&quot;/&quot;</span>) <span class="comment">// 注销成功后重定向到首页</span></span><br><span class="line">                );</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>配置解读</strong>：</p>
<ol>
<li><strong><code>passwordEncoder()</code></strong>:<ul>
<li>我们声明了一个 <code>PasswordEncoder</code> 的 Bean。这是现代 Spring Security 强制要求的。</li>
<li>我们选择了 <code>BCryptPasswordEncoder</code>，这是一个非常安全和推荐的密码哈希算法。</li>
</ul>
</li>
<li><strong><code>userDetailsService()</code></strong>:<ul>
<li>我们定义了一个 <code>UserDetailsService</code> Bean 来告诉 Spring Security 如何获取用户信息。</li>
<li>这里我们使用了 <code>InMemoryUserDetailsManager</code>，它在内存中创建用户，非常适合演示和测试。</li>
<li><strong>关键点</strong>：<code>User.withUsername(...)</code> 构建用户时，<code>.password()</code> 方法接收的<strong>必须是经过加密后的密码</strong>。所以我们调用了 <code>passwordEncoder().encode(&quot;password&quot;)</code>。</li>
</ul>
</li>
<li><strong><code>filterChain(HttpSecurity http)</code></strong>:<ul>
<li>这是安全配置的核心。我们通过 <code>HttpSecurity</code> 对象来构建一个 <code>SecurityFilterChain</code>。</li>
<li><code>.authorizeHttpRequests(...)</code> 定义了<strong>授权规则</strong>：<ul>
<li><code>/dashboard</code> 路径需要 “ADMIN” 角色。</li>
<li><code>/</code> 根路径与<code>/login</code>登陆路径允许所有人访问 (<code>permitAll</code>)。</li>
<li>其他任何请求 (<code>anyRequest()</code>) 都必须经过认证 (<code>authenticated()</code>)。</li>
</ul>
</li>
<li><code>.formLogin(...)</code> 配置了表单登录。</li>
<li><code>.logout(...)</code> 配置了注销功能。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="第五步：再次测试"><a href="#第五步：再次测试" class="headerlink" title="第五步：再次测试"></a>第五步：再次测试</h4><ol>
<li><strong>重新启动应用</strong>。这次控制台不会再打印随机密码了。</li>
<li><strong>访问 <code>http://localhost:8080/dashboard</code></strong>。你依然会被重定向到登录页。</li>
<li><strong>使用 <code>user</code> &#x2F; <code>password</code> 登录</strong>。你会发现登录后看到一个 <strong>403 Forbidden</strong> 错误页面。这是因为我们配置了 <code>/dashboard</code> 需要 <code>ADMIN</code> 角色，而 <code>user</code> 用户只有 <code>USER</code> 角色。</li>
<li><strong>注销</strong>（可以直接访问 <code>/logout</code>），然后<strong>使用 <code>admin</code> &#x2F; <code>password</code> 登录</strong>。这次你就能成功访问 <code>/dashboard</code> 了。</li>
<li><strong>访问 <code>http://localhost:8080/</code></strong>。无论你是否登录，这个页面始终可以访问。</li>
</ol>
<hr>
<h2 id="2-认证（Authentication）"><a href="#2-认证（Authentication）" class="headerlink" title="2. 认证（Authentication）"></a>2. 认证（Authentication）</h2><h3 id="2-1-认证流程详解（重点）"><a href="#2-1-认证流程详解（重点）" class="headerlink" title="2.1 认证流程详解（重点）"></a>2.1 认证流程详解（重点）</h3><p>当用户在登录页面输入用户名和密码，点击“登录”按钮后，Spring Security 内部发生了一系列精妙的协作。我们将以最常见的<strong>基于表单的认证 (Form Login)</strong> 为例，一步步拆解这个流程。</p>
<h4 id="2-1-1-宏观流程图"><a href="#2-1-1-宏观流程图" class="headerlink" title="2.1.1 宏观流程图"></a>2.1.1 宏观流程图</h4><pre><code class="highlight mermaid">graph LR
    subgraph &quot;SecurityFilterChain&quot;
        A[...一系列其他过滤器...&lt;br&gt;CsrfFilter, CorsFilter等]
        B[认证过滤器&lt;br&gt;UsernamePassword&lt;br&gt;AuthenticationFilter]
        C[创建未认证的&lt;br&gt;Authentication对象]
        D[调用 AuthenticationManager]
        E[AuthenticationProvider&lt;br&gt;处理认证逻辑]
        F[调用 UserDetailsService&lt;br&gt;加载用户信息]
        G[PasswordEncoder&lt;br&gt;比对密码]
        H[返回已认证的&lt;br&gt;Authentication对象]
        I[存入 SecurityContextHolder&lt;br&gt;与当前线程绑定]
    end
    A--&gt;B
    B--&gt;C
    C--&gt;|传递token对象|D
    D--&gt;|遍历管理的Provider&lt;br&gt;查看是否支持此token|E
    E--&gt;F
    F--&gt;G
    G--&gt;H
    H--&gt;I</code></pre>



<hr>
<h4 id="2-1-2-详细步骤分解"><a href="#2-1-2-详细步骤分解" class="headerlink" title="2.1.2 详细步骤分解"></a>2.1.2 详细步骤分解</h4><h5 id="第-1-步-UsernamePasswordAuthenticationFilter-拦截请求"><a href="#第-1-步-UsernamePasswordAuthenticationFilter-拦截请求" class="headerlink" title="第 1 步: UsernamePasswordAuthenticationFilter 拦截请求"></a>第 1 步: <code>UsernamePasswordAuthenticationFilter</code> 拦截请求</h5><ul>
<li><strong>触发条件</strong>: 当一个 <code>POST</code> 请求发送到 <code>/login</code> (这是默认的登录URL，可以配置) 时，这个过滤器会被激活。</li>
<li><strong>核心工作</strong>:<ol>
<li><strong>判断是否为登录请求</strong>: 它会检查请求的 URL 和 HTTP 方法是否匹配它所配置的登录请求。</li>
<li><strong>提取凭证</strong>: 如果匹配，它会从 <code>HttpServletRequest</code> 的参数中提取用户名 (默认参数名 <code>username</code>) 和密码 (默认参数名 <code>password</code>)。</li>
<li><strong>封装 Token</strong>: 它将提取出的用户名和密码封装成一个 <code>UsernamePasswordAuthenticationToken</code> 对象。这是一个 <code>Authentication</code> 接口的实现类。<ul>
<li><strong>关键点</strong>: 此时创建的这个 Token 是 <strong>“未认证” (unauthenticated)</strong> 的。我们可以通过 <code>token.isAuthenticated()</code> 返回 <code>false</code> 来判断。它的 <code>authorities</code> 列表也是空的。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h5 id="第-2-步-调用-AuthenticationManager"><a href="#第-2-步-调用-AuthenticationManager" class="headerlink" title="第 2 步: 调用 AuthenticationManager"></a>第 2 步: 调用 <code>AuthenticationManager</code></h5><ul>
<li><code>UsernamePasswordAuthenticationFilter</code> 自身并不执行真正的认证逻辑。它遵循**“委托模式”**，将认证的重任交给了 <code>AuthenticationManager</code>。</li>
<li>它调用 <code>authenticationManager.authenticate(token)</code> 方法，将上一步创建的<strong>未认证 Token</strong> 传进去。</li>
</ul>
<hr>
<h5 id="第-3-步-第-4-步-AuthenticationManager-的实现-ProviderManager"><a href="#第-3-步-第-4-步-AuthenticationManager-的实现-ProviderManager" class="headerlink" title="第 3 步 &amp; 第 4 步: AuthenticationManager 的实现 ProviderManager"></a>第 3 步 &amp; 第 4 步: <code>AuthenticationManager</code> 的实现 <code>ProviderManager</code></h5><ul>
<li><code>AuthenticationManager</code> 是一个接口，它只有一个 <code>authenticate</code> 方法。</li>
<li>在 Spring Security 中，它最常用的实现类是 <code>ProviderManager</code>。</li>
<li><code>ProviderManager</code> 的作用像一个**“认证委托总管”**。它内部维护了一个 <code>AuthenticationProvider</code> 的列表。</li>
<li>当 <code>ProviderManager</code> 收到 <code>authenticate</code> 请求时，它会<strong>遍历</strong>自己管理的所有 <code>AuthenticationProvider</code>，并询问每一个 Provider：“你能处理这种类型的 <code>Authentication</code> Token 吗？” (通过调用 <code>provider.supports(token.getClass())</code>)。</li>
</ul>
<hr>
<h5 id="第-5-步-AuthenticationProvider-执行核心认证"><a href="#第-5-步-AuthenticationProvider-执行核心认证" class="headerlink" title="第 5 步: AuthenticationProvider 执行核心认证"></a>第 5 步: <code>AuthenticationProvider</code> 执行核心认证</h5><ul>
<li>如果某个 <code>AuthenticationProvider</code> (例如，处理用户名密码的 <code>DaoAuthenticationProvider</code>) 返回 <code>true</code>，表示它可以处理，<code>ProviderManager</code> 就会调用它的 <code>authenticate(token)</code> 方法。</li>
<li><strong><code>DaoAuthenticationProvider</code> 是核心中的核心，它的工作流程如下</strong>:<ol>
<li><strong>获取用户名</strong>: 从传入的<strong>未认证 Token</strong> 中获取用户名。</li>
<li><strong>加载用户信息 (第 6、7 步)</strong>: 调用它所配置的 <code>UserDetailsService</code> 的 <code>loadUserByUsername(username)</code> 方法，去数据库 (或其他数据源) 中查找用户。<ul>
<li>如果找不到用户，<code>UserDetailsService</code> 会抛出 <code>UsernameNotFoundException</code>，认证失败。</li>
<li>如果找到了，会返回一个包含了用户所有信息（包括<strong>加密后的密码</strong>和<strong>权限列表</strong>）的 <code>UserDetails</code> 对象。</li>
</ul>
</li>
<li><strong>密码校验 (第 8 步)</strong>: 调用它所配置的 <code>PasswordEncoder</code> 的 <code>matches(rawPassword, encodedPassword)</code> 方法。<ul>
<li><code>rawPassword</code>: 来自用户提交的、<strong>未认证 Token</strong> 中的明文密码。</li>
<li><code>encodedPassword</code>: 来自上一步从数据库加载的 <code>UserDetails</code> 对象中的<strong>加密密码</strong>。</li>
<li>如果 <code>matches</code> 返回 <code>false</code>，则抛出 <code>BadCredentialsException</code>，认证失败。</li>
</ul>
</li>
<li><strong>检查账户状态</strong>: 检查从 <code>UserDetails</code> 中获取的账户状态（如 <code>isAccountNonLocked()</code>, <code>isEnabled()</code> 等）。如果账户状态异常（如被锁定、已过期），则抛出相应的异常，认证失败。</li>
<li><strong>认证成功，构建新 Token (第 9 步)</strong>: 如果所有检查都通过，<code>DaoAuthenticationProvider</code> 会创建一个<strong>新的</strong> <code>UsernamePasswordAuthenticationToken</code>。<ul>
<li><strong>这个新的 Token 是“已认证” (authenticated) 的</strong>。</li>
<li>它的 <code>principal</code> 是从数据库加载的 <code>UserDetails</code> 对象。</li>
<li>它的 <code>credentials</code> (密码) 会被<strong>清空 (设置为 null)</strong>，防止敏感信息泄露。</li>
<li>它的 <code>authorities</code> 列表会用 <code>UserDetails</code> 中的权限信息来填充。</li>
<li>最后，它将这个<strong>已认证的 Token</strong> 返回给 <code>ProviderManager</code>。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h5 id="第-10-步-返回认证结果"><a href="#第-10-步-返回认证结果" class="headerlink" title="第 10 步: 返回认证结果"></a>第 10 步: 返回认证结果</h5><ul>
<li><code>ProviderManager</code> 接收到 <code>DaoAuthenticationProvider</code> 返回的<strong>已认证 Token</strong>，然后将其原路返回给最初的调用者——<code>UsernamePasswordAuthenticationFilter</code>。</li>
<li>如果在此过程中任何一个 <code>AuthenticationProvider</code> 抛出了 <code>AuthenticationException</code>（认证异常），<code>ProviderManager</code> 会捕获它，并最终将异常传递回 Filter。</li>
</ul>
<hr>
<h5 id="第-11-步-第-12-步-后续处理"><a href="#第-11-步-第-12-步-后续处理" class="headerlink" title="第 11 步 &amp; 第 12 步: 后续处理"></a>第 11 步 &amp; 第 12 步: 后续处理</h5><p><code>UsernamePasswordAuthenticationFilter</code> 接收到 <code>AuthenticationManager</code> 返回的结果后，会进行如下操作：</p>
<ul>
<li><strong>如果认证成功 (返回了已认证的 <code>Authentication</code> 对象)</strong>:<ol>
<li><strong>更新安全上下文</strong>: 调用 <code>SecurityContextHolder.getContext().setAuthentication(authenticatedToken)</code>，将这个<strong>已认证的 Token</strong> 放入 <code>SecurityContext</code> 中。至此，当前用户就在本次请求的后续处理以及未来的请求中（通过 Session）被认为是已登录状态了。</li>
<li><strong>触发成功处理器</strong>: 调用 <code>AuthenticationSuccessHandler</code>。默认的处理器会将用户重定向到他们访问的原始页面，或者是一个配置好的默认成功页面。</li>
<li><strong>(可选) 触发 Remember-Me</strong>: 如果配置了“记住我”功能，此时也会生成相应的 cookie。</li>
</ol>
</li>
<li><strong>如果认证失败 (抛出了 <code>AuthenticationException</code>)</strong>:<ol>
<li><strong>清空安全上下文</strong>: <code>SecurityContextHolder.clearContext()</code>，确保没有任何残留的认证信息。</li>
<li><strong>触发失败处理器</strong>: 调用 <code>AuthenticationFailureHandler</code>。默认的处理器会将用户重定向回登录页面，并附带一个错误参数（如 <code>/login?error</code>）。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-2-UserDetailsService-自定义实现"><a href="#2-2-UserDetailsService-自定义实现" class="headerlink" title="2.2 UserDetailsService 自定义实现"></a>2.2 <code>UserDetailsService</code> 自定义实现</h3><p>在 <code>1.4 Hello Security</code> 示例中，我们使用了 <code>InMemoryUserDetailsManager</code> 来在内存中创建用户。这对于测试和快速原型开发非常方便，但在真实的应用中，用户信息几乎总是存储在数据库、LDAP或其他持久化存储中。</p>
<p><code>UserDetailsService</code> 接口就是 Spring Security 提供的、用于连接这些<strong>外部用户数据源</strong>的标准化桥梁。我们的任务就是提供一个该接口的实现类，告诉 Spring Security：“嘿，当需要用户信息时，调用我的这个类，我会去数据库里帮你查！”</p>
<h4 id="2-2-1-为什么需要自定义？"><a href="#2-2-1-为什么需要自定义？" class="headerlink" title="2.2.1 为什么需要自定义？"></a>2.2.1 为什么需要自定义？</h4><ul>
<li><strong>对接真实数据</strong>: 将 Spring Security 的认证机制与你的用户表（或其他用户存储）集成。</li>
<li><strong>灵活的用户模型</strong>: 你的用户实体（<code>User</code> Entity）可能包含很多业务字段（如昵称、邮箱、注册时间等），而 <code>UserDetails</code> 接口只关心安全相关的核心字段。自定义实现可以完成从你的实体到 <code>UserDetails</code> 的转换。</li>
<li><strong>复杂的权限模型</strong>: 你的权限可能存储在多个关联表中（用户-角色表，角色-权限表）。自定义实现可以在加载用户时，一并查询并组装这些复杂的权限信息。</li>
</ul>
<hr>
<h4 id="2-2-2-实现步骤-以-MP-为例"><a href="#2-2-2-实现步骤-以-MP-为例" class="headerlink" title="2.2.2 实现步骤 (以 MP 为例)"></a>2.2.2 实现步骤 (以 MP 为例)</h4><p>假设我们有一个基于 MybatisPlus 的项目，包含以下实体：</p>
<p><strong>1. 用户实体 (<code>User</code> Entity)</strong></p>
<p>这代表了我们数据库中的 <code>users</code> 表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2. 用户DAO (<code>UserMapper</code>)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-创建-UserDetailsService-的实现类"><a href="#3-创建-UserDetailsService-的实现类" class="headerlink" title="3. 创建 UserDetailsService 的实现类"></a>3. 创建 <code>UserDetailsService</code> 的实现类</h5><p>这是最核心的一步。我们创建一个 Service 类，实现 <code>UserDetailsService</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;loadUserByUsername: &#123;&#125;&quot;</span>, username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper</span><br><span class="line">                .selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;()</span><br><span class="line">                        .eq(User::getUsername, username));</span><br><span class="line">        Optional.ofNullable(user).orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">org</span>.springframework.security.core.userdetails.User(</span><br><span class="line">                user.getUsername(),</span><br><span class="line">                user.getPassword(),</span><br><span class="line">                <span class="literal">true</span>,   <span class="comment">// enabled</span></span><br><span class="line">                <span class="literal">true</span>, <span class="comment">// accountNonExpired</span></span><br><span class="line">                <span class="literal">true</span>, <span class="comment">// credentialsNonExpired</span></span><br><span class="line">                <span class="literal">true</span>, <span class="comment">// accountNonLocked</span></span><br><span class="line">                Collections.emptyList() <span class="comment">// 权限列表</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ul>
<li><code>@Service</code>: 将 <code>MyUserDetailsService</code> 注册为一个 Spring Bean，这样 Spring Security 就能自动发现并使用它。</li>
<li><code>@RequiredArgsConstructor</code>: 注入我们之前创建的 <code>UserMapper</code>。</li>
<li><code>loadUserByUsername(String username)</code>: 这是接口要求我们必须实现的方法。<ol>
<li>我们调用 <code>userMapper.selectOne(new LambdaQueryWrapper&lt;User&gt;().eq(User::getUsername, username))</code>。</li>
<li>如果找不到用户 (<code>Optional</code> 为空)，<strong>必须</strong>抛出 <code>UsernameNotFoundException</code>。这是 Spring Security 的契约，它会捕获这个异常并将其转换为一个认证失败的消息。<strong>切勿返回 <code>null</code></strong>。</li>
<li>如果找到了用户，我们需要返回一个 <code>UserDetails</code> 接口的实例。这里我们使用了 <code>org.springframework.security.core.userdetails.User</code> 这个内置的实现类，它非常方便。我们把从数据库查出的用户名、<strong>已加密的密码</strong>、账户状态等信息填充进去。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="2-2-3-进阶：加载角色和权限"><a href="#2-2-3-进阶：加载角色和权限" class="headerlink" title="2.2.3 进阶：加载角色和权限"></a>2.2.3 进阶：加载角色和权限</h4><p>通常，我们的权限模型会更复杂，比如用户有关联的角色。</p>
<h5 id="1-扩展实体"><a href="#1-扩展实体" class="headerlink" title="1. 扩展实体"></a>1. 扩展实体</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User.java (添加角色关系)</span></span><br><span class="line"><span class="keyword">private</span> String role;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-更新-UserDetailsService"><a href="#2-更新-UserDetailsService" class="headerlink" title="2. 更新 UserDetailsService"></a>2. 更新 <code>UserDetailsService</code></h5><p>现在，我们需要在加载用户时，将用户的 <code>Role</code> 集合转换为 <code>GrantedAuthority</code> 集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;loadUserByUsername: &#123;&#125;&quot;</span>, username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper</span><br><span class="line">                .selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;()</span><br><span class="line">                        .eq(User::getUsername, username));</span><br><span class="line">        Optional.ofNullable(user).orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities = Collections.singleton(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(user.getRole()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">org</span>.springframework.security.core.userdetails.User(</span><br><span class="line">                user.getUsername(),</span><br><span class="line">                user.getPassword(),</span><br><span class="line">                <span class="literal">true</span>,   <span class="comment">// enabled</span></span><br><span class="line">                <span class="literal">true</span>, <span class="comment">// accountNonExpired</span></span><br><span class="line">                <span class="literal">true</span>, <span class="comment">// credentialsNonExpired</span></span><br><span class="line">                <span class="literal">true</span>, <span class="comment">// accountNonLocked</span></span><br><span class="line">                authorities <span class="comment">// 权限列表</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ul>
<li>我们从 <code>user</code> 对象中获取 <code>role</code> 。</li>
<li>创建一个只包含单个元素的不可变集合(<code>Collections.singleton</code>),将用户角色转换为 Spring Security 能识别的权限对象,放入不可变集合中。<code>SimpleGrantedAuthority</code> 是 <code>GrantedAuthority</code> 接口最常用的实现类，它接收一个代表权限的字符串（例如，<code>&quot;ROLE_ADMIN&quot;</code>）。</li>
</ul>
<hr>
<h4 id="2-2-4-自定义-UserDetails-实现类-可选，但推荐"><a href="#2-2-4-自定义-UserDetails-实现类-可选，但推荐" class="headerlink" title="2.2.4 自定义 UserDetails 实现类 (可选，但推荐)"></a>2.2.4 自定义 <code>UserDetails</code> 实现类 (可选，但推荐)</h4><p>直接使用 <code>org.springframework.security.core.userdetails.User</code> 很方便，但有时我们希望在 <code>UserDetails</code> 对象中携带更多自定义信息（比如用户ID、昵称），或者让我们的 <code>User</code> 实体本身就具备安全用户的能力。</p>
<p>创建一个独立的类实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetails</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String role;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyUserDetails</span><span class="params">(Long id, String username, String password, String role)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.role = role;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(role));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDetails.<span class="built_in">super</span>.isAccountNonExpired();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDetails.<span class="built_in">super</span>.isAccountNonLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDetails.<span class="built_in">super</span>.isCredentialsNonExpired();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDetails.<span class="built_in">super</span>.isEnabled();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这样做的好处</strong>:</p>
<ul>
<li><strong>代码更简洁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;loadUserByUsername: &#123;&#125;&quot;</span>, username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper</span><br><span class="line">                .selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;User&gt;()</span><br><span class="line">                        .eq(User::getUsername, username));</span><br><span class="line">        Optional.ofNullable(user).orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyUserDetails</span>(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>信息更丰富</strong>: <code>Authentication</code> 对象的 <code>getPrincipal()</code> 方法将返回我们完整的 <code>User</code> 实体，你可以在业务代码中方便地获取用户ID、邮箱等任何信息。</li>
</ul>
<hr>
<h3 id="2-3-PasswordEncoder-的选择与使用"><a href="#2-3-PasswordEncoder-的选择与使用" class="headerlink" title="2.3 PasswordEncoder 的选择与使用"></a>2.3 <code>PasswordEncoder</code> 的选择与使用</h3><p><code>PasswordEncoder</code> 是 Spring Security 提供的一个核心服务接口，专门用于处理密码的<strong>单向加密（哈希）和 验证</strong>。在现代 Web 应用中，直接存储用户明文密码是绝对禁止的严重安全漏洞。</p>
<h4 id="2-3-1-为什么不能明文存储密码？"><a href="#2-3-1-为什么不能明文存储密码？" class="headerlink" title="2.3.1 为什么不能明文存储密码？"></a>2.3.1 为什么不能明文存储密码？</h4><ol>
<li><strong>数据库泄露风险</strong>：如果你的数据库被黑客拖库（整个数据库被盗走），所有用户的密码将瞬间暴露无遗。攻击者可以利用这些密码尝试登录用户的其他网站账户（因为很多用户习惯在不同网站使用相同密码），造成巨大损失。</li>
<li><strong>内部人员风险</strong>：能够接触到数据库的内部员工（DBA、运维、开发人员）可以看到所有用户的密码，这带来了极大的隐私和安全风险。</li>
<li><strong>违反合规性要求</strong>：许多数据保护法规（如 GDPR）明确要求对敏感个人数据进行加密保护，明文存储密码是违规行为。</li>
</ol>
<hr>
<h4 id="2-3-2-什么是安全的密码存储？——-自适应单向函数"><a href="#2-3-2-什么是安全的密码存储？——-自适应单向函数" class="headerlink" title="2.3.2 什么是安全的密码存储？—— 自适应单向函数"></a>2.3.2 什么是安全的密码存储？—— 自适应单向函数</h4><p>一个安全的密码存储方案，不仅仅是做一次简单的哈希（如 MD5 或 SHA-1），而是需要使用<strong>自适应单向函数 (Adaptive One-way Function)</strong>。这类函数有几个关键特性：</p>
<ol>
<li><strong>单向性 (One-way)</strong>：从原始密码计算出哈希值非常容易，但从哈希值反推出原始密码在计算上是不可行的。MD5 和 SHA 系列都具备此特性。</li>
<li><strong>加盐 (Salting)</strong>：在对密码进行哈希计算之前，会为每个密码自动生成一个随机的字符串（称为“盐”），并将其与密码结合在一起。<ul>
<li><strong>作用</strong>：即使两个用户设置了完全相同的密码（如 “123456”），由于他们的“盐”是不同的，最终存储在数据库中的哈希值也是完全不同的。这有效抵御了<strong>彩虹表攻击 (Rainbow Table Attack)</strong>。</li>
</ul>
</li>
<li><strong>慢速与可配置的工作因子 (Slow &amp; Configurable Work Factor)</strong>：这类算法被设计成<strong>计算密集型</strong>的，即计算一次哈希需要消耗相对较多的 CPU 或内存资源。<ul>
<li><strong>作用</strong>：这极大地增加了<strong>暴力破解 (Brute-force Attack)</strong> 的成本。攻击者即使拿到了数据库，也无法在短时间内尝试大量的密码组合。</li>
<li><strong>自适应</strong>：随着计算机硬件性能的提升，我们可以通过调整<strong>工作因子（Work Factor）</strong>（也叫成本、迭代次数）来增加计算的耗时，使得破解成本始终保持在一个非常高的水平。</li>
</ul>
</li>
</ol>
<p><strong>已经被淘汰的算法</strong>：</p>
<ul>
<li><strong>MD5, SHA-1, SHA-256</strong>: 这些是快速哈希算法，不包含加盐和慢速特性，非常容易被现代硬件暴力破解，<strong>绝对不能</strong>用于存储密码。</li>
</ul>
<hr>
<h4 id="2-3-3-Spring-Security-提供的-PasswordEncoder-实现"><a href="#2-3-3-Spring-Security-提供的-PasswordEncoder-实现" class="headerlink" title="2.3.3 Spring Security 提供的 PasswordEncoder 实现"></a>2.3.3 Spring Security 提供的 <code>PasswordEncoder</code> 实现</h4><p>Spring Security 提供了一系列实现了上述安全特性的 <code>PasswordEncoder</code>，封装在 <code>spring-security-crypto</code> 模块中。</p>
<table>
<thead>
<tr>
<th>编码器</th>
<th>算法</th>
<th>特点</th>
<th>推荐度</th>
</tr>
</thead>
<tbody><tr>
<td><code>BCryptPasswordEncoder</code></td>
<td>BCrypt</td>
<td><strong>业界标准，最广泛使用</strong>。基于 Blowfish 加密算法，计算密集。工作因子可调（强度，默认为10）。</td>
<td><strong>强烈推荐 (默认首选)</strong></td>
</tr>
<tr>
<td><code>SCryptPasswordEncoder</code></td>
<td>SCrypt</td>
<td><strong>内存消耗型</strong>。除了 CPU 成本，还要求大量的内存，使其更难被 GPU 或 ASIC 硬件并行破解。</td>
<td><strong>推荐</strong> (比 BCrypt 更安全，但需要更多内存)</td>
</tr>
<tr>
<td><code>Argon2PasswordEncoder</code></td>
<td>Argon2</td>
<td><strong>密码哈希竞赛冠军</strong>。现代、安全，同时对抗 CPU、GPU 和内存攻击。是未来的趋势。</td>
<td><strong>推荐</strong> (最安全的选择之一，需要 Bouncy Castle 依赖)</td>
</tr>
<tr>
<td><code>Pbkdf2PasswordEncoder</code></td>
<td>PBKDF2</td>
<td>一个较老的标准，安全性不如前三者，但仍可接受。</td>
<td>不推荐在新项目中使用，除非有兼容性要求。</td>
</tr>
</tbody></table>
<p><strong><code>DelegatingPasswordEncoder</code></strong>:</p>
<p>这是一个特殊的“代理”编码器，也是 Spring Security <strong>默认</strong>使用的。它的设计目标是为了<strong>平滑地升级密码存储策略</strong>。</p>
<ul>
<li><strong>工作原理</strong>：它生成的哈希值会带有一个<strong>前缀</strong>，用于标识该密码是使用哪种算法加密的。例如：<ul>
<li><code>{bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1j...</code></li>
<li><code>{argon2}$...</code></li>
</ul>
</li>
<li><strong>优点</strong>：<ol>
<li><strong>验证</strong>：当验证密码时，<code>DelegatingPasswordEncoder</code> 会根据前缀选择正确的编码器进行 <code>matches</code> 操作。</li>
<li><strong>升级</strong>：你可以配置它默认使用新的算法（如 Argon2）。新注册的用户或修改密码的用户会使用新算法存储。而老用户登录时，它仍然能用旧的算法（如 BCrypt）去验证他们的密码。这使得系统可以在不强制所有用户重置密码的情况下，逐步迁移到更安全的算法。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="2-3-4-如何使用-PasswordEncoder"><a href="#2-3-4-如何使用-PasswordEncoder" class="headerlink" title="2.3.4 如何使用 PasswordEncoder"></a>2.3.4 如何使用 <code>PasswordEncoder</code></h4><h5 id="1-声明-Bean"><a href="#1-声明-Bean" class="headerlink" title="1. 声明 Bean"></a>1. 声明 Bean</h5><p>在你的 <code>@Configuration</code> 类中，必须将一个 <code>PasswordEncoder</code> 实例声明为 Spring Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回一个 BCryptPasswordEncoder 实例</span></span><br><span class="line">        <span class="comment">// 构造函数可以接受一个 &quot;strength&quot; 参数 (4-31)，默认是 10。</span></span><br><span class="line">        <span class="comment">// 数字越大，计算越慢，密码越安全，但认证耗时也越长。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果你想使用 DelegatingPasswordEncoder (Spring Boot 默认行为)</span></span><br><span class="line">    <span class="comment">// import org.springframework.security.crypto.factory.PasswordEncoderFactories;</span></span><br><span class="line">    <span class="comment">// @Bean</span></span><br><span class="line">    <span class="comment">// public PasswordEncoder passwordEncoder() &#123;</span></span><br><span class="line">    <span class="comment">//     return PasswordEncoderFactories.createDelegatingPasswordEncoder();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Spring Boot 会自动配置 <code>DelegatingPasswordEncoder</code>，所以通常你只需要提供一个具体的实现（如 <code>BCryptPasswordEncoder</code>），Spring Security 会自动使用它。</strong></p>
<hr>
<h5 id="2-在注册-修改密码时进行编码"><a href="#2-在注册-修改密码时进行编码" class="headerlink" title="2. 在注册&#x2F;修改密码时进行编码"></a>2. 在注册&#x2F;修改密码时进行编码</h5><p>当用户注册或修改密码时，<strong>永远不要</strong>将明文密码存入数据库。必须先使用 <code>passwordEncoder</code> 进行编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(String username, String rawPassword)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(username);</span><br><span class="line">        <span class="comment">// 关键步骤：对明文密码进行编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encodedPassword</span> <span class="operator">=</span> passwordEncoder.encode(rawPassword);</span><br><span class="line">        user.setPassword(encodedPassword);</span><br><span class="line">        </span><br><span class="line">        save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编码后的密码（一个长得像乱码的字符串）将被存入数据库的 <code>password</code> 字段。</p>
<hr>
<h5 id="3-Spring-Security-自动进行验证"><a href="#3-Spring-Security-自动进行验证" class="headerlink" title="3. Spring Security 自动进行验证"></a>3. Spring Security 自动进行验证</h5><p>你<strong>不需要</strong>手动调用 <code>passwordEncoder.matches()</code>。</p>
<p>在认证流程（<code>2.1</code> 节已详述）中，<code>DaoAuthenticationProvider</code> 会被自动注入你声明的 <code>PasswordEncoder</code> Bean。当它从 <code>UserDetailsService</code> 加载到 <code>UserDetails</code> 后，会自动调用 <code>passwordEncoder.matches(rawPassword, encodedPassword)</code> 来进行密码比对，其中：</p>
<ul>
<li><code>rawPassword</code>: 是用户在登录表单中输入的明文密码。</li>
<li><code>encodedPassword</code>: 是从 <code>UserDetails</code> (即数据库) 中获取的已编码密码。</li>
</ul>
<hr>
<h3 id="2-4-常见的认证方式配置"><a href="#2-4-常见的认证方式配置" class="headerlink" title="2.4 常见的认证方式配置"></a>2.4 常见的认证方式配置</h3><p>Spring Security 提供了多种开箱即用的认证机制，以适应不同的应用场景。这里我们重点介绍三种最常见的：Form Login、HTTP Basic 和 Remember-Me。</p>
<h4 id="2-4-1-基于表单的认证-Form-Login"><a href="#2-4-1-基于表单的认证-Form-Login" class="headerlink" title="2.4.1 基于表单的认证 (Form Login)"></a>2.4.1 基于表单的认证 (Form Login)</h4><p>这是最常见的一种认证方式，适用于所有面向普通用户的 Web 应用程序。用户通过一个 HTML 表单提交用户名和密码来进行登录。</p>
<h5 id="1-默认的-Form-Login"><a href="#1-默认的-Form-Login" class="headerlink" title="1. 默认的 Form Login"></a>1. 默认的 Form Login</h5><p>只需在 <code>SecurityFilterChain</code> 配置中加入 <code>.formLogin()</code> 即可启用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .authorizeHttpRequests(auth -&gt; auth.anyRequest().authenticated())</span><br><span class="line">        .formLogin(Customizer.withDefaults()); <span class="comment">// 使用默认配置启用表单登录</span></span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会自动提供一个由 Spring Security 生成的登录页面（在 <code>/login</code>），并处理 <code>POST /login</code> 的登录请求。</p>
<hr>
<h5 id="2-自定义登录页面"><a href="#2-自定义登录页面" class="headerlink" title="2. 自定义登录页面"></a>2. 自定义登录页面</h5><p>在真实项目中，我们总是需要一个自定义的、符合网站风格的登录页面。</p>
<p><strong>步骤 1: 创建登录页面的 Controller</strong></p>
<p>你需要一个 Controller 来返回登录页面的视图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">loginPage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>; <span class="comment">// 返回视图名，例如 login.html (使用Thymeleaf)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 创建登录页面 (e.g., <code>src/main/resources/templates/login.html</code>)</strong></p>
<p>页面中的表单需要遵循一些约定：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Login Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Please sign in<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 显示登录失败的错误信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;param.error&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span></span><br><span class="line">        Invalid username or password.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 显示注销成功的信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;param.logout&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: green;&quot;</span>&gt;</span></span><br><span class="line">        You have been logged out.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 登录表单 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- th:action=&quot;@&#123;/login&#125;&quot; 会自动处理 context path --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- action=&quot;/login&quot; 也可以，处理登录的 URL 默认为 /login --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/login&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- name=&quot;username&quot; 是默认的用户名参数名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">autofocus</span>=<span class="string">&quot;autofocus&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>Password:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- name=&quot;password&quot; 是默认的密码参数名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 默认开启 CSRF 防护，Thymeleaf 会自动在表单中添加一个隐藏的 _csrf token --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">th:name</span>=<span class="string">&quot;$&#123;_csrf.parameterName&#125;&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Sign In<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>action</code> 必须指向 Spring Security 处理登录的 URL (默认为 <code>POST /login</code>)。</li>
<li>用户名输入框的 <code>name</code> 属性默认为 <code>username</code>。</li>
<li>密码输入框的 <code>name</code> 属性默认为 <code>password</code>。</li>
<li>如果启用了 CSRF 防护（默认开启），表单中必须包含 CSRF token。Thymeleaf 会自动处理。</li>
</ul>
<p><strong>步骤 3: 更新 Security 配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">                        .requestMatchers(<span class="string">&quot;/dashboard&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>) <span class="comment">// /dashboard 只有 ADMIN 角色可以访问</span></span><br><span class="line">                        .requestMatchers(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/css/**&quot;</span>, <span class="string">&quot;/js/**&quot;</span>).permitAll() <span class="comment">// 首页与登陆页允许所有用户访问</span></span><br><span class="line">                        .anyRequest().authenticated() <span class="comment">// 其他所有请求都需要认证</span></span><br><span class="line">                )</span><br><span class="line">                .formLogin(form -&gt; form</span><br><span class="line">                        .loginPage(<span class="string">&quot;/login&quot;</span>) <span class="comment">// 指定自定义登录页的URL</span></span><br><span class="line">                        .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>) <span class="comment">// 指定处理登录请求的URL (默认为/login)</span></span><br><span class="line">                        .usernameParameter(<span class="string">&quot;username&quot;</span>) <span class="comment">// 自定义用户名字段名 (默认为username)</span></span><br><span class="line">                        .passwordParameter(<span class="string">&quot;password&quot;</span>) <span class="comment">// 自定义密码字段名 (默认为password)</span></span><br><span class="line">                        .defaultSuccessUrl(<span class="string">&quot;/&quot;</span>, <span class="literal">true</span>) <span class="comment">// 登录成功后的默认重定向地址, true表示总是重定向</span></span><br><span class="line">                        .failureUrl(<span class="string">&quot;/login?error&quot;</span>) <span class="comment">// 登录失败后重定向的地址</span></span><br><span class="line">                        .permitAll() <span class="comment">// 必须允许所有人访问登录相关的URL</span></span><br><span class="line">                )</span><br><span class="line">                .logout(logout -&gt; logout</span><br><span class="line">                        .logoutSuccessUrl(<span class="string">&quot;/&quot;</span>) <span class="comment">// 注销成功后重定向到首页</span></span><br><span class="line">                );</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.loginPage(&quot;/login&quot;)</code>: 告诉 Spring Security 你的登录页在 <code>/login</code>，当未认证用户访问受保护资源时，将他们重定向到这里。</li>
<li><code>.loginProcessingUrl(&quot;/login&quot;)</code>: 指定 <code>UsernamePasswordAuthenticationFilter</code> 监听哪个 URL 来处理登录提交。</li>
<li><code>.defaultSuccessUrl(...)</code>: 登录成功后跳转的页面。如果设置为 <code>true</code>，则总是跳转到此页面；如果为 <code>false</code>（默认），则会跳转到用户在登录前尝试访问的页面。</li>
<li><code>.failureUrl(...)</code>: 登录失败后跳转的页面。我们通常会附带一个参数（如 <code>error</code>）用于在页面上显示提示信息。</li>
<li>最后，非常重要的一点是，<strong>必须将登录页面本身设置为 <code>permitAll()</code></strong>，否则用户将陷入无限重定向的循环。</li>
</ul>
<hr>
<h4 id="2-4-2-HTTP-Basic-认证"><a href="#2-4-2-HTTP-Basic-认证" class="headerlink" title="2.4.2 HTTP Basic 认证"></a>2.4.2 HTTP Basic 认证</h4><p>HTTP Basic 认证是一种更简单的认证方案，它不依赖 HTML 表单，而是直接使用 HTTP Header 来传递凭证。</p>
<h5 id="1-适用场景"><a href="#1-适用场景" class="headerlink" title="1. 适用场景"></a>1. 适用场景</h5><ul>
<li><strong>无状态的 RESTful API</strong>: 特别适合用于程序间的调用，例如脚本、微服务间的通信。</li>
<li><strong>简单的后台管理接口</strong>: 对于内部系统或对用户体验要求不高的场景，可以快速提供安全保护。</li>
<li><strong>开发和测试</strong>: 在开发阶段快速保护端点，无需编写登录页面。</li>
</ul>
<hr>
<h5 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h5><ol>
<li>客户端首次请求受保护资源。</li>
<li>服务器返回 <code>401 Unauthorized</code> 状态码，并在响应头中包含 <code>WWW-Authenticate: Basic realm=&quot;user realm&quot;</code>。</li>
<li>浏览器或客户端收到此响应后，会弹出一个对话框，要求用户输入用户名和密码。</li>
<li>客户端将 <code>username:password</code> 这个字符串进行 Base64 编码，然后放入后续请求的 <code>Authorization</code> Header 中，格式为 <code>Authorization: Basic &lt;base64-encoded-credentials&gt;</code>。</li>
<li>服务器端的 <code>BasicAuthenticationFilter</code> 拦截到这个 Header，解码凭证并进行认证。</li>
</ol>
<hr>
<h5 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h5><p>启用 HTTP Basic 认证非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Order(1)</span> <span class="comment">// 如果有多个 SecurityFilterChain，用 @Order 指定优先级</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">apiFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .securityMatcher(<span class="string">&quot;/api/**&quot;</span>) <span class="comment">// 此配置仅对 /api/ 开头的请求生效</span></span><br><span class="line">        .authorizeHttpRequests(auth -&gt; auth.anyRequest().authenticated())</span><br><span class="line">        .httpBasic(Customizer.withDefaults()); <span class="comment">// 启用 HTTP Basic</span></span><br><span class="line">        <span class="comment">// 因为是 API，通常是无状态的，所以禁用 CSRF 和 Session</span></span><br><span class="line">        .csrf(csrf -&gt; csrf.disable())</span><br><span class="line">        .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.httpBasic()</code>: 一行代码即可启用。</li>
<li>对于 API 场景，通常会禁用 CSRF（因为 API 客户端通常不涉及浏览器 Cookie）并设置会话策略为 <code>STATELESS</code>（无状态），这样每次请求都需要携带 <code>Authorization</code> Header。</li>
</ul>
<hr>
<h4 id="2-4-3-“记住我”-Remember-Me-功能"><a href="#2-4-3-“记住我”-Remember-Me-功能" class="headerlink" title="2.4.3 “记住我” (Remember-Me) 功能"></a>2.4.3 “记住我” (Remember-Me) 功能</h4><p>“记住我”功能允许用户在关闭浏览器后，下次访问时仍然保持登录状态，从而提升用户体验。</p>
<h5 id="1-工作原理-基于-Cookie"><a href="#1-工作原理-基于-Cookie" class="headerlink" title="1. 工作原理 (基于 Cookie)"></a>1. 工作原理 (基于 Cookie)</h5><ol>
<li>用户在登录页面勾选“记住我”复选框并成功登录。</li>
<li><code>RememberMeAuthenticationFilter</code> 捕获到这个成功的登录事件。</li>
<li>它会生成一个特殊的 <code>remember-me</code> Cookie，并将其发送给浏览器。这个 Cookie 包含了用户名、过期时间和一个根据私钥（<code>key</code>）、用户名、密码和过期时间计算出的签名。</li>
<li>用户关闭浏览器再重新打开，访问受保护的页面。</li>
<li>此时用户没有 <code>JSESSIONID</code>，未被认证。但 <code>RememberMeAuthenticationFilter</code> 会检查请求中是否存在 <code>remember-me</code> Cookie。</li>
<li>如果存在，它会验证 Cookie 的签名是否有效且未过期。</li>
<li>如果验证通过，它会像正常登录一样，从 <code>UserDetailsService</code> 加载用户信息，创建一个已认证的 <code>Authentication</code> 对象，并将其放入 <code>SecurityContextHolder</code>。</li>
<li>用户被视为已登录，可以访问受保护的资源。</li>
</ol>
<p><strong>安全性注意</strong>：这种方式相对安全，因为 Cookie 中不包含明文密码，且有签名防止篡改。但如果用户的电脑被他人使用，或者 Cookie 被窃取，攻击者仍然可以在过期前冒充用户身份。</p>
<hr>
<h5 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ... authorizeHttpRequests 和 formLogin 配置</span></span><br><span class="line">        .rememberMe(rememberMe -&gt; rememberMe</span><br><span class="line">            .key(<span class="string">&quot;a-very-secret-and-long-key-value&quot;</span>) <span class="comment">// 用于生成签名的私钥，必须配置</span></span><br><span class="line">            .tokenValiditySeconds(<span class="number">86400</span> * <span class="number">14</span>) <span class="comment">// Cookie 有效期，单位秒，这里是14天</span></span><br><span class="line">            .rememberMeParameter(<span class="string">&quot;remember-me&quot;</span>) <span class="comment">// 登录表单中复选框的 name 属性 (默认)</span></span><br><span class="line">            .userDetailsService(userDetailsService) <span class="comment">// 必须提供 UserDetailsService</span></span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>.key(&quot;...&quot;)</code>: <strong>必须设置一个复杂的、保密的私钥</strong>。如果泄露，所有用户的 <code>remember-me</code> Cookie 都将面临风险。</p>
</li>
<li><p><code>.tokenValiditySeconds(...)</code>: 设置 Cookie 的有效期。</p>
</li>
<li><p><code>.userDetailsService(...)</code>: “记住我”功能需要通过它来在 Cookie 验证成功后重新加载用户信息。</p>
</li>
<li><p><strong>前端修改</strong>: 别忘了在你的登录表单中添加一个复选框：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remember-me&quot;</span> <span class="attr">id</span>=<span class="string">&quot;remember-me&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;remember-me&quot;</span>&gt;</span>Remember me<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>进阶：基于数据库的持久化 Token</strong></p>
<p>上述基于 Cookie 的签名方式存在一个风险：只要 Cookie 未过期，它就一直有效，无法被主动撤销（除非用户修改密码）。</p>
<p>一种更安全的方式是使用持久化 Token。<code>PersistentTokenRepository</code> 会将生成的 Token 存储在数据库中。每次用户通过 “记住我” 登录时，都会生成一个新的 Token 来替换旧的，这使得一个 Token 只能被使用一次，大大降低了 Cookie 被盗用的风险。配置方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 提供一个 PersistentTokenRepository 的 Bean，例如 JdbcTokenRepositoryImpl</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PersistentTokenRepository <span class="title function_">persistentTokenRepository</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">    <span class="type">JdbcTokenRepositoryImpl</span> <span class="variable">tokenRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTokenRepositoryImpl</span>();</span><br><span class="line">    tokenRepository.setDataSource(dataSource);</span><br><span class="line">    <span class="comment">// tokenRepository.setCreateTableOnStartup(true); // 首次运行时可以设为 true 自动建表</span></span><br><span class="line">    <span class="keyword">return</span> tokenRepository;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在 rememberMe 配置中使用它</span></span><br><span class="line">.rememberMe(rememberMe -&gt; rememberMe</span><br><span class="line">    .tokenRepository(persistentTokenRepository(dataSource)) <span class="comment">// 使用基于数据库的 token 仓库</span></span><br><span class="line">    <span class="comment">// .key(...) 仍然需要</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-授权（Authorization）"><a href="#3-授权（Authorization）" class="headerlink" title="3. 授权（Authorization）"></a>3. 授权（Authorization）</h2><h3 id="3-1-授权基础：访问控制"><a href="#3-1-授权基础：访问控制" class="headerlink" title="3.1 授权基础：访问控制"></a>3.1 授权基础：访问控制</h3><p>一旦用户通过了<strong>认证 (Authentication)</strong>，确定了他的身份，接下来的每一步操作都需要经过<strong>授权 (Authorization)</strong> 的检验。授权的核心任务是：<strong>根据当前已认证用户的身份，决定他是否有权访问某个特定的资源</strong>。这个资源可以是一个 URL、一个服务方法，甚至是页面上的一个按钮。</p>
<h4 id="3-1-1-授权流程与决策机制"><a href="#3-1-1-授权流程与决策机制" class="headerlink" title="3.1.1 授权流程与决策机制"></a>3.1.1 授权流程与决策机制</h4><p>Spring Security 的授权流程在宏观上可以看作是一个“守门员”模型，它发生在请求真正到达你的业务代码之前。</p>
<h5 id="1-授权流程概览"><a href="#1-授权流程概览" class="headerlink" title="1. 授权流程概览"></a>1. 授权流程概览</h5><pre><code class="highlight mermaid">flowchart TD
    A[已认证的请求] --&gt; B[AuthorizationFilter &lt;br&gt;- 拦截请求 &lt;br&gt;- 提取目标资源信息 &lt;br&gt;- 提取用户认证信息]
    B --&gt; C&#123;&quot;将信息提交给...&quot;&#125;
    C --&gt; D[AuthorizationManager 新] 
    C --&gt; E[AccessDecisionManager 旧]
    E --&gt; F[AccessDecisionVoter 投票者 &lt;br&gt;- 每个 Voter 根据自身逻辑投票 &lt;br&gt;- 结果：ACCESS_GRANTED / &lt;br&gt;ACCESS_DENIED / ABSTAIN]
    F --&gt; G[AccessDecisionManager 旧 &lt;br&gt;- 汇总投票结果 &lt;br&gt;- 根据策略（如「一票通过」&lt;br&gt;「一致同意」） &lt;br&gt;- 做出最终裁决]
    D --&gt; H[做出最终决策 Check]
    G --&gt; H
    H --&gt; I&#123;决策结果&#125;
    I --&gt; J[允许 Allow: 请求继续执行]
    I --&gt; K[拒绝 Deny: &lt;br&gt;抛出 AccessDeniedException]
    K --&gt; L[ExceptionTranslationFilter &lt;br&gt;- 捕获 AccessDeniedException &lt;br&gt;- 调用 AccessDeniedHandler]
    L --&gt; M[返回 403 Forbidden &lt;br&gt;- 或重定向到错误页面]</code></pre>

<hr>
<h5 id="2-核心决策组件"><a href="#2-核心决策组件" class="headerlink" title="2. 核心决策组件"></a>2. 核心决策组件</h5><ul>
<li><strong>拦截器 (Interceptor)</strong>：<ul>
<li>对于 Web 请求，主要是 <code>AuthorizationFilter</code>。</li>
<li>对于方法级别的安全，是基于 AOP 的方法拦截器。</li>
<li><strong>职责</strong>：在操作发生前“拦住”它，并收集进行授权决策所需的所有信息：<ol>
<li><strong><code>Authentication</code> 对象</strong>: 当前用户的身份信息，从 <code>SecurityContextHolder</code> 获取。</li>
<li><strong>安全对象 (Secure Object)</strong>: 正在被访问的目标资源，例如 <code>Request</code> 对象或被调用的 <code>MethodInvocation</code>。</li>
<li><strong>配置属性 (Configuration Attributes)</strong>: 保护该资源所需的权限配置，例如 <code>hasRole(&#39;ADMIN&#39;)</code> 或 <code>@PreAuthorize(&quot;hasAuthority(&#39;user:read&#39;)&quot;)</code>。</li>
</ol>
</li>
</ul>
</li>
<li><strong><code>AuthorizationManager</code> (现代架构)</strong>：<ul>
<li>这是 Spring Security 6.x 之后推荐的、更简洁的授权决策接口。</li>
<li>它只有一个核心方法 <code>check(Supplier&lt;Authentication&gt; authentication, T object)</code>。</li>
<li><strong>职责</strong>：接收认证信息和目标对象，直接做出“允许”或“拒绝”的最终决策。如果拒绝，它会抛出 <code>AccessDeniedException</code>。我们通过 Lambda 表达式配置的 <code>authorizeHttpRequests</code> 内部就是转换成了不同的 <code>AuthorizationManager</code> 实现。</li>
</ul>
</li>
<li><strong><code>AccessDecisionManager</code> 和 <code>AccessDecisionVoter</code> (传统架构)</strong>：<ul>
<li><strong><code>AccessDecisionManager</code> (决策管理器)</strong>：像一个**“议长”**，它不亲自做判断，而是组织一场投票。</li>
<li><strong><code>AccessDecisionVoter</code> (投票者)</strong>：像**“议员”**。每个 <code>Voter</code> 都有自己专长的领域。例如，<code>RoleVoter</code> 只关心角色（<code>ROLE_</code> 前缀的权限），<code>WebExpressionVoter</code> 负责处理 SpEL 表达式。</li>
<li><strong>投票过程</strong>:<ol>
<li><code>AccessDecisionManager</code> 把收集到的信息分发给它管理的所有 <code>AccessDecisionVoter</code>。</li>
<li>每个 <code>Voter</code> 根据自己的逻辑进行投票，结果有三种：<ul>
<li><code>ACCESS_GRANTED</code> (赞成票)</li>
<li><code>ACCESS_DENIED</code> (反对票)</li>
<li><code>ABSTAIN</code> (弃权票，表示这个决策与我无关)</li>
</ul>
</li>
<li><code>AccessDecisionManager</code> 根据预设的<strong>决策策略</strong>来汇总投票结果：<ul>
<li><strong><code>AffirmativeBased</code> (默认)</strong>: <strong>一票赞成就通过</strong>。只要有一个 Voter 投了赞成票，就允许访问（除非有反对票，具体看配置）。</li>
<li><strong><code>ConsensusBased</code></strong>: <strong>少数服从多数</strong>。赞成票多于反对票就通过。</li>
<li><strong><code>UnanimousBased</code></strong>: <strong>一致同意制</strong>。所有 Voter 都必须投赞成票或弃权票，不能有任何反对票。</li>
</ul>
</li>
</ol>
</li>
<li><strong>最终裁决</strong>：如果最终结果是拒绝，<code>AccessDecisionManager</code> 就会抛出 <code>AccessDeniedException</code>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3. 异常处理"></a>3. 异常处理</h5><p>如果授权决策的结果是“拒绝”，流程并不会立即终止。抛出的 <code>AccessDeniedException</code> 会被 <code>ExceptionTranslationFilter</code> 捕获，然后委托给 <code>AccessDeniedHandler</code> 进行处理，最终通常是向用户返回一个 <strong>403 Forbidden</strong> 页面或 JSON 响应。</p>
<hr>
<h4 id="3-1-2-角色-Role-与-权限-Authority-的区别与联系"><a href="#3-1-2-角色-Role-与-权限-Authority-的区别与联系" class="headerlink" title="3.1.2 角色 (Role) 与 权限 (Authority) 的区别与联系"></a>3.1.2 角色 (Role) 与 权限 (Authority) 的区别与联系</h4><p>从<strong>技术实现</strong>上讲，<strong>角色和权限在 Spring Security 内部都被抽象为 <code>GrantedAuthority</code> 对象</strong>。<code>RoleVoter</code> 在判断时，只是简单地检查 <code>GrantedAuthority</code> 的字符串是否以 <code>ROLE_</code> 开头。</p>
<p>然而，从<strong>设计理念</strong>上讲，它们代表了不同的抽象层次：</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><strong>角色 (Role)</strong></th>
<th align="left"><strong>权限 (Authority&#x2F;Permission)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>概念</strong></td>
<td align="left"><strong>“是什么” (Who you are)</strong>，代表一组职责或身份的集合。</td>
<td align="left"><strong>“能做什么” (What you can do)</strong>，代表一个具体的操作许可。</td>
</tr>
<tr>
<td align="left"><strong>粒度</strong></td>
<td align="left"><strong>粗粒度 (Coarse-grained)</strong></td>
<td align="left"><strong>细粒度 (Fine-grained)</strong></td>
</tr>
<tr>
<td align="left"><strong>例子</strong></td>
<td align="left"><code>ROLE_ADMIN</code> (管理员)<br><code>ROLE_USER</code> (普通用户)<br><code>ROLE_GUEST</code> (访客)</td>
<td align="left"><code>user:create</code> (创建用户)<br><code>user:read</code> (读取用户)<br><code>order:approve</code> (审批订单)</td>
</tr>
<tr>
<td align="left"><strong>关系</strong></td>
<td align="left"><strong>一个角色通常包含多个权限</strong>。</td>
<td align="left"><strong>一个权限是最小的、不可再分的授权单元</strong>。</td>
</tr>
<tr>
<td align="left"><strong>管理</strong></td>
<td align="left">将权限分配给角色，再将角色分配给用户。</td>
<td align="left">直接将权限分配给用户（不推荐，难以维护）。</td>
</tr>
</tbody></table>
<p><strong>联系与最佳实践：基于角色的访问控制 (RBAC - Role-Based Access Control)</strong></p>
<p>这是业界最主流、最推荐的权限设计模型。它的核心思想是：</p>
<ol>
<li><strong>用户 (User) ←→ 角色 (Role)</strong>: 给用户分配一个或多个角色。<ul>
<li>例如：张三是“内容管理员”。</li>
</ul>
</li>
<li><strong>角色 (Role) ←→ 权限 (Permission&#x2F;Authority)</strong>: 给角色分配一组具体的操作权限。<ul>
<li>例如：“内容管理员”这个角色拥有 <code>article:create</code>, <code>article:edit</code>, <code>article:publish</code>, <code>comment:delete</code> 等权限。</li>
</ul>
</li>
</ol>
<p><strong>用户并不直接拥有权限，而是通过拥有角色来间接获得权限。</strong></p>
<p><strong>优点</strong>:</p>
<ul>
<li><strong>简化管理</strong>: 当需要调整权限时，只需修改角色的权限配置，所有拥有该角色的用户的权限就会自动更新。无需逐个修改每个用户的权限。</li>
<li><strong>逻辑清晰</strong>: “管理员能做什么”比“张三、李四、王五…能做什么”要清晰得多，符合业务语义。</li>
<li><strong>最小权限原则</strong>: 可以精确地为每个角色授予其完成工作所必需的最小权限集合。</li>
</ul>
<p><strong>在 Spring Security 中的体现</strong>:</p>
<ul>
<li>使用 <code>.hasRole(&quot;ADMIN&quot;)</code>: 检查用户是否拥有 <code>ROLE_ADMIN</code> 这个 <code>GrantedAuthority</code>。</li>
<li>使用 <code>.hasAuthority(&quot;user:create&quot;)</code>: 检查用户是否拥有 <code>user:create</code> 这个 <code>GrantedAuthority</code>。</li>
</ul>
<p>当你从数据库加载用户的 <code>GrantedAuthority</code> 时，你应该把用户的<strong>角色</strong>（如 <code>ROLE_ADMIN</code>）和该角色所对应的所有<strong>权限</strong>（如 <code>user:create</code>, <code>user:delete</code>）<strong>全部加载进来</strong>，并作为 <code>GrantedAuthority</code> 列表返回。这样，无论是基于角色的粗粒度控制，还是基于权限的细粒度控制，都可以无缝支持。</p>
<hr>
<h3 id="3-2-基于-URL-的请求授权"><a href="#3-2-基于-URL-的请求授权" class="headerlink" title="3.2 基于 URL 的请求授权"></a>3.2 基于 URL 的请求授权</h3><p>基于 URL 的授权是 Web 应用中最基础、最核心的安全控制方式。它通过配置，为不同的 URL 路径（endpoints）设置不同的访问规则。Spring Security 提供了强大而灵活的链式 API 来实现这一点。</p>
<h4 id="3-2-1-使用-http-authorizeHttpRequests-进行配置"><a href="#3-2-1-使用-http-authorizeHttpRequests-进行配置" class="headerlink" title="3.2.1 使用 http.authorizeHttpRequests() 进行配置"></a>3.2.1 使用 <code>http.authorizeHttpRequests()</code> 进行配置</h4><p>在现代的 <code>SecurityFilterChain</code> 配置中, 所有的 URL 授权规则都定义在 <code>.authorizeHttpRequests()</code> 这个 Lambda 表达式内部。</p>
<p>这个方法提供了一个 <code>AuthorizeHttpRequestsConfigurer</code> 对象（通常我们命名为 <code>auth</code> 或 <code>authorize</code>），我们可以用它来链式地定义一条条匹配规则。</p>
<p><strong>基本结构</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">            <span class="comment">// 在这里定义一条条的 URL 匹配规则</span></span><br><span class="line">            .requestMatchers(<span class="string">&quot;/public/**&quot;</span>, <span class="string">&quot;/login&quot;</span>).permitAll()</span><br><span class="line">            .requestMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// ... 其他配置, 如 .formLogin()</span></span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重要原则：规则的顺序至关重要 (Order Matters!)</strong></p>
<p>Spring Security 会<strong>从上到下</strong>依次匹配这些规则。一旦一个 URL 被<strong>第一条</strong>适用的规则匹配上，后续的规则就不会再生效。</p>
<p>因此，<strong>必须将更具体的规则放在更通用的规则之前</strong>。</p>
<p><strong>正确顺序示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">    .requestMatchers(<span class="string">&quot;/admin/specific-task&quot;</span>).hasRole(<span class="string">&quot;SUPER_ADMIN&quot;</span>) <span class="comment">// 1. 最具体的</span></span><br><span class="line">    .requestMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)            <span class="comment">// 2. 较通用的</span></span><br><span class="line">    .anyRequest().authenticated()                             <span class="comment">// 3. 最通用的（必须放最后）</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果把 <code>/admin/**</code> 放在前面，那么 <code>/admin/specific-task</code> 这个请求会先被 <code>.hasRole(&quot;ADMIN&quot;)</code> 匹配到，从而导致 <code>.hasRole(&quot;SUPER_ADMIN&quot;)</code> 这条更严格的规则永远不会被触发。</p>
<hr>
<h4 id="3-2-2-requestMatchers-的使用"><a href="#3-2-2-requestMatchers-的使用" class="headerlink" title="3.2.2 requestMatchers() 的使用"></a><strong>3.2.2 <code>requestMatchers()</code> 的使用</strong></h4><p><code>requestMatchers()</code> 是定义 URL 模式的入口，它支持多种匹配策略。</p>
<h5 id="1-Ant-风格路径匹配-Ant-style-Path-Matching"><a href="#1-Ant-风格路径匹配-Ant-style-Path-Matching" class="headerlink" title="1. Ant 风格路径匹配 (Ant-style Path Matching)"></a>1. Ant 风格路径匹配 (Ant-style Path Matching)</h5><p>这是最常用、最直观的匹配方式。</p>
<ul>
<li><code>?</code>: 匹配任意单个字符。<ul>
<li><code>&quot;/api/v?&quot;</code> 匹配 <code>/api/v1</code>, <code>/api/v2</code>，但不匹配 <code>/api/v</code> 或 <code>/api/v12</code>。</li>
</ul>
</li>
<li><code>*</code>: 匹配路径中任意数量的字符（不含 <code>/</code>）。<ul>
<li><code>&quot;/users/*&quot;</code> 匹配 <code>/users/123</code>, <code>/users/profile</code>，但不匹配 <code>/users/123/orders</code>。</li>
</ul>
</li>
<li><code>**</code>: 匹配路径中任意数量的目录（包含 <code>/</code>）。<ul>
<li><code>&quot;/admin/**&quot;</code> 匹配 <code>/admin/</code>, <code>/admin/users</code>, <code>/admin/users/1/edit</code> 等所有以 <code>/admin/</code> 开头的路径。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配多个具体的路径</span></span><br><span class="line">.requestMatchers(<span class="string">&quot;/home&quot;</span>, <span class="string">&quot;/about&quot;</span>, <span class="string">&quot;/contact&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配某个目录下的所有直接子路径</span></span><br><span class="line">.requestMatchers(<span class="string">&quot;/products/*&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配某个目录及其所有子目录下的所有路径</span></span><br><span class="line">.requestMatchers(<span class="string">&quot;/static/css/**&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-匹配-HTTP-方法"><a href="#2-匹配-HTTP-方法" class="headerlink" title="2. 匹配 HTTP 方法"></a>2. 匹配 HTTP 方法</h5><p>你可以在 <code>requestMatchers</code> 中指定 HTTP 方法，从而对同一个 URL 的不同操作（GET, POST, DELETE 等）设置不同的权限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.http.HttpMethod.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">.authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">    <span class="comment">// 任何人都可以 GET 用户列表</span></span><br><span class="line">    .requestMatchers(GET, <span class="string">&quot;/api/users&quot;</span>).permitAll()</span><br><span class="line">    <span class="comment">// 只有 ADMIN 可以 POST 创建新用户</span></span><br><span class="line">    .requestMatchers(POST, <span class="string">&quot;/api/users&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">    <span class="comment">// 只有 ADMIN 可以删除特定用户</span></span><br><span class="line">    .requestMatchers(DELETE, <span class="string">&quot;/api/users/&#123;id&#125;&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-Servlet-路径匹配-MVC-匹配"><a href="#3-Servlet-路径匹配-MVC-匹配" class="headerlink" title="3. Servlet 路径匹配 (MVC 匹配)"></a>3. Servlet 路径匹配 (MVC 匹配)</h5><p>Spring Security 6.1+ 默认使用 <code>Spring MVC</code> 的路径匹配规则 (<code>PathPatternParser</code>)，它性能更好，且语法与 Ant 风格基本兼容，但在 <code>**</code> 的使用上略有不同（例如 <code>**</code> 只能在路径末尾）。通常你不需要关心这个区别，除非遇到非常复杂的路径匹配场景。</p>
<hr>
<h4 id="3-2-3-核心访问控制方法"><a href="#3-2-3-核心访问控制方法" class="headerlink" title="3.2.3 核心访问控制方法"></a>3.2.3 核心访问控制方法</h4><p>这些方法跟在 <code>requestMatchers(...)</code> 后面，用于定义匹配到的 URL 需要满足什么条件才能访问。</p>
<ul>
<li><strong><code>permitAll()</code></strong>: <strong>允许所有访问</strong><ul>
<li>允许任何人（包括匿名用户）访问。</li>
<li>常用于公共资源，如登录页、注册页、静态文件 (CSS, JS)、首页等。</li>
<li><strong>示例</strong>: <code>.requestMatchers(&quot;/login&quot;, &quot;/css/**&quot;).permitAll()</code></li>
</ul>
</li>
<li><strong><code>denyAll()</code></strong>: <strong>拒绝所有访问</strong><ul>
<li>无论用户是谁，都无法访问。</li>
<li>不常用，但可用于明确禁用某些不应被外部访问的路径。</li>
<li><strong>示例</strong>: <code>.requestMatchers(&quot;/internal/secret-api&quot;).denyAll()</code></li>
</ul>
</li>
<li><strong><code>authenticated()</code></strong>: <strong>要求已认证</strong><ul>
<li>要求用户必须已经登录（通过了认证）。</li>
<li>这是最基础的保护，不关心用户具体有什么角色或权限，只要登录了就行。</li>
<li><strong>示例</strong>: <code>.requestMatchers(&quot;/my-account/**&quot;).authenticated()</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-4-基于角色-权限的访问控制方法"><a href="#3-2-4-基于角色-权限的访问控制方法" class="headerlink" title="3.2.4 基于角色&#x2F;权限的访问控制方法"></a>3.2.4 基于角色&#x2F;权限的访问控制方法</h4><p>这些方法提供了更细粒度的控制，要求用户不仅要登录，还必须拥有特定的角色或权限。</p>
<ul>
<li><strong><code>hasRole(String role)</code></strong>: <strong>要求拥有单个角色</strong><ul>
<li>检查当前用户的 <code>GrantedAuthority</code> 列表中，是否存在一个以 <code>ROLE_</code> 开头的、与指定角色名匹配的权限。</li>
<li><strong>注意</strong>: 你提供的角色名<strong>不需要</strong>加 <code>ROLE_</code> 前缀，框架会自动添加。例如，<code>.hasRole(&quot;ADMIN&quot;)</code> 会去匹配 <code>ROLE_ADMIN</code>。</li>
<li><strong>示例</strong>: <code>.requestMatchers(&quot;/admin/panel&quot;).hasRole(&quot;ADMIN&quot;)</code></li>
</ul>
</li>
<li><strong><code>hasAnyRole(String... roles)</code></strong>: <strong>要求拥有多个角色中的任意一个</strong><ul>
<li>只要用户拥有参数列表中任何一个角色，即可访问。</li>
<li><strong>示例</strong>: <code>.requestMatchers(&quot;/management/**&quot;).hasAnyRole(&quot;ADMIN&quot;, &quot;MANAGER&quot;)</code><ul>
<li>用户有 <code>ROLE_ADMIN</code> 或 <code>ROLE_MANAGER</code> (或两者都有) 就可以访问。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>hasAuthority(String authority)</code></strong>: <strong>要求拥有单个权限</strong><ul>
<li>直接匹配 <code>GrantedAuthority</code> 列表中的字符串，<strong>不会</strong>自动添加 <code>ROLE_</code> 前缀。</li>
<li>适用于细粒度的权限控制（RBAC 模型中的 Permission）。</li>
<li><strong>示例</strong>: <code>.requestMatchers(POST, &quot;/articles&quot;).hasAuthority(&quot;article:create&quot;)</code></li>
</ul>
</li>
<li><strong><code>hasAnyAuthority(String... authorities)</code></strong>: <strong>要求拥有多个权限中的任意一个</strong><ul>
<li>只要用户拥有参数列表中任何一个权限，即可访问。</li>
<li><strong>示例</strong>: <code>.requestMatchers(&quot;/articles/editor&quot;).hasAnyAuthority(&quot;article:edit&quot;, &quot;article:publish&quot;)</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-5-综合示例"><a href="#3-2-5-综合示例" class="headerlink" title="3.2.5 综合示例"></a>3.2.5 综合示例</h4><p>一个典型的、遵循最佳实践的授权配置可能如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .authorizeHttpRequests(authorize -&gt; authorize</span><br><span class="line">            <span class="comment">// 1. 优先放行公共资源</span></span><br><span class="line">            .requestMatchers(<span class="string">&quot;/css/**&quot;</span>, <span class="string">&quot;/js/**&quot;</span>, <span class="string">&quot;/images/**&quot;</span>, <span class="string">&quot;/webjars/**&quot;</span>).permitAll()</span><br><span class="line">            .requestMatchers(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;/home&quot;</span>, <span class="string">&quot;/register&quot;</span>, <span class="string">&quot;/login&quot;</span>).permitAll()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 配置基于权限的细粒度规则</span></span><br><span class="line">            .requestMatchers(POST, <span class="string">&quot;/api/products&quot;</span>).hasAuthority(<span class="string">&quot;product:write&quot;</span>)</span><br><span class="line">            .requestMatchers(DELETE, <span class="string">&quot;/api/products/**&quot;</span>).hasAuthority(<span class="string">&quot;product:delete&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 配置基于角色的粗粒度规则</span></span><br><span class="line">            .requestMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">            .requestMatchers(<span class="string">&quot;/moderator/**&quot;</span>).hasAnyRole(<span class="string">&quot;ADMIN&quot;</span>, <span class="string">&quot;MODERATOR&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. (兜底规则) 其他任何未匹配的请求，都必须登录后才能访问</span></span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">        )</span><br><span class="line">        .formLogin(form -&gt; form.loginPage(<span class="string">&quot;/login&quot;</span>).permitAll());</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-方法级别的安全控制（-EnableMethodSecurity）"><a href="#3-3-方法级别的安全控制（-EnableMethodSecurity）" class="headerlink" title="3.3 方法级别的安全控制（@EnableMethodSecurity）"></a>3.3 方法级别的安全控制（@EnableMethodSecurity）</h3><p>URL 级别的授权能够保护 Web 端点，但它无法深入到业务逻辑层（Service Layer）。有时，我们需要对 Service 方法进行保护，确保即便是 Controller 层的代码逻辑出现疏忽，非法的调用也无法触及核心业务。方法安全正是为此而生。</p>
<h4 id="3-3-1-如何启用方法安全"><a href="#3-3-1-如何启用方法安全" class="headerlink" title="3.3.1 如何启用方法安全"></a>3.3.1 如何启用方法安全</h4><p>要使用方法安全注解，首先需要在你的主配置类或安全配置类上添加 <code>@EnableMethodSecurity</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableMethodSecurity</span> <span class="comment">// 启用方法级别的安全控制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上这个注解后，Spring Security 会创建一个 AOP (面向切面编程) 的代理，来拦截标注了安全注解的方法调用，并在方法执行前后进行安全检查。</p>
<p>默认情况下，<code>@EnableMethodSecurity</code> 会启用对 <code>@PreAuthorize</code>, <code>@PostAuthorize</code>, <code>@Secured</code> 和 <code>@RolesAllowed</code> (JSR-250) 注解的支持。</p>
<hr>
<h4 id="3-3-2-PreAuthorize-PostAuthorize-最强大、最灵活的注解"><a href="#3-3-2-PreAuthorize-PostAuthorize-最强大、最灵活的注解" class="headerlink" title="3.3.2 @PreAuthorize &#x2F; @PostAuthorize: 最强大、最灵活的注解"></a>3.3.2 <code>@PreAuthorize</code> &#x2F; <code>@PostAuthorize</code>: 最强大、最灵活的注解</h4><p>这两个注解是 Spring Security 自己的注解，它们内部支持 <strong>SpEL (Spring Expression Language)</strong> 表达式，这使得我们可以编写出极其灵活和强大的动态授权规则。</p>
<h5 id="1-PreAuthorize-expression"><a href="#1-PreAuthorize-expression" class="headerlink" title="1. @PreAuthorize(&quot;expression&quot;)"></a>1. <code>@PreAuthorize(&quot;expression&quot;)</code></h5><ul>
<li><strong>执行时机</strong>: 在<strong>方法执行之前</strong>进行权限检查。</li>
<li><strong>决策</strong>: 如果 SpEL 表达式返回 <code>false</code>，方法将<strong>不会被执行</strong>，并直接抛出 <code>AccessDeniedException</code>。</li>
<li><strong>适用场景</strong>: 这是<strong>最常用</strong>的方法安全注解。绝大多数授权决策都应该在方法执行前完成，以避免不必要的资源消耗和潜在的数据操作。</li>
</ul>
<p><strong>常用 SpEL 表达式:</strong></p>
<ul>
<li><p><strong>检查角色&#x2F;权限</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span> <span class="comment">// 需要 ROLE_ADMIN 角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(Long userId)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAnyRole(&#x27;ADMIN&#x27;, &#x27;MANAGER&#x27;)&quot;)</span> <span class="comment">// 需要 ADMIN 或 MANAGER 角色</span></span><br><span class="line"><span class="keyword">public</span> Report <span class="title function_">generateReport</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;user:delete&#x27;)&quot;)</span> <span class="comment">// 需要 &#x27;user:delete&#x27; 权限</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(Long userId)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>访问 <code>authentication</code> 对象</strong>:<br>SpEL 表达式可以直接访问 <code>SecurityContext</code> 中的 <code>authentication</code> 对象，从而获取当前登录用户的详细信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有用户名是 &quot;admin&quot; 的用户才能调用</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;authentication.name == &#x27;admin&#x27;&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runAdminTask</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>访问方法参数</strong>:<br>SpEL 表达式可以通过 <code>#参数名</code> 的形式来引用方法的参数，这对于实现“对象级别的访问控制”至关重要。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有用户自己才能修改自己的信息</span></span><br><span class="line"><span class="comment">// #username 引用了方法的 username 参数</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;#username == authentication.principal.username&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUserProfile</span><span class="params">(String username, UserProfile newProfile)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 User 对象有 owner 属性</span></span><br><span class="line"><span class="comment">// 只有文章的拥有者或管理员才能编辑</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;#article.owner == authentication.name or hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">editArticle</span><span class="params">(<span class="meta">@P(&quot;article&quot;)</span> Article article)</span> &#123; ... &#125; </span><br><span class="line"><span class="comment">// 使用 @P 注解为参数命名，使其在 SpEL 中可被引用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>调用其他 Bean 的方法</strong>:<br>可以在 SpEL 表达式中通过 <code>@beanName.methodName()</code> 的形式调用 Spring 容器中任何 Bean 的方法，实现非常复杂的业务授权逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用名为 &#x27;permissionService&#x27; 的 Bean 的 checkPermission 方法</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@permissionService.checkPermission(authentication, #userId)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> UserProfile <span class="title function_">getUserProfile</span><span class="params">(Long userId)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>这是一种将授权逻辑从业务代码中完全抽离出来的强大模式。</p>
</li>
</ul>
<hr>
<h5 id="2-PostAuthorize-expression"><a href="#2-PostAuthorize-expression" class="headerlink" title="2. @PostAuthorize(&quot;expression&quot;)"></a>2. <code>@PostAuthorize(&quot;expression&quot;)</code></h5><ul>
<li><strong>执行时机</strong>: 在<strong>方法执行之后，返回结果之前</strong>进行权限检查。</li>
<li><strong>决策</strong>: 如果 SpEL 表达式返回 <code>false</code>，方法已经执行完毕，但其<strong>返回结果不会传递给调用者</strong>，而是抛出 <code>AccessDeniedException</code>。</li>
<li><strong>适用场景</strong>: 比较少见，通常用于需要<strong>根据方法的返回值</strong>来进行授权决策的场景。例如，一个方法返回了某个敏感对象，你需要检查当前用户是否有权查看这个特定的对象。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法返回一个 Order 对象</span></span><br><span class="line"><span class="comment">// 只有订单的创建者或者管理员才能获取到这个订单的详细信息</span></span><br><span class="line"><span class="meta">@PostAuthorize(&quot;returnObject.customerUsername == authentication.name or hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">getOrderDetails</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderRepository.findById(orderId);</span><br><span class="line">    <span class="comment">// ... 此时方法逻辑已经执行</span></span><br><span class="line">    <span class="keyword">return</span> order; <span class="comment">// 在返回前，会对 returnObject (即 order) 进行权限检查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>returnObject</code>: 是 SpEL 中一个特殊的关键字，代表了方法的返回值。</li>
</ul>
<p><strong>注意</strong>: 使用 <code>@PostAuthorize</code> 要小心，因为它是在业务逻辑执行后才进行检查。如果方法内部有修改数据的操作（如更新数据库），即使最后授权失败，这些操作也已经完成了，可能需要事务回滚来保证数据一致性。</p>
<hr>
<h4 id="3-3-3-Secured-和-RolesAllowed-简单的基于角色的控制"><a href="#3-3-3-Secured-和-RolesAllowed-简单的基于角色的控制" class="headerlink" title="3.3.3 @Secured 和 @RolesAllowed: 简单的基于角色的控制"></a>3.3.3 <code>@Secured</code> 和 <code>@RolesAllowed</code>: 简单的基于角色的控制</h4><p>这两个注解功能类似，都是用于简单的、基于角色的访问控制，它们不支持复杂的 SpEL 表达式。</p>
<h5 id="1-Secured-ROLE-NAME-1-ROLE-NAME-2"><a href="#1-Secured-ROLE-NAME-1-ROLE-NAME-2" class="headerlink" title="1. @Secured({&quot;ROLE_NAME_1&quot;, &quot;ROLE_NAME_2&quot;})"></a>1. <code>@Secured({&quot;ROLE_NAME_1&quot;, &quot;ROLE_NAME_2&quot;})</code></h5><ul>
<li><strong>来源</strong>: Spring Security 早期就有的注解。</li>
<li><strong>用法</strong>: 注解的参数是一个字符串数组，代表允许访问的角色列表。</li>
<li><strong>约定</strong>: 角色名<strong>必须</strong>以 <code>ROLE_</code> 作为前缀。</li>
<li><strong>逻辑</strong>: 拥有参数列表中<strong>任意一个</strong>角色的用户即可访问。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有拥有 ROLE_ADMIN 角色的用户才能访问</span></span><br><span class="line"><span class="meta">@Secured(&quot;ROLE_ADMIN&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resetSystem</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拥有 ROLE_ADMIN 或 ROLE_MANAGER 角色的用户可以访问</span></span><br><span class="line"><span class="meta">@Secured(&#123;&quot;ROLE_ADMIN&quot;, &quot;ROLE_MANAGER&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> DashboardData <span class="title function_">getDashboard</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-RolesAllowed-ROLE-1-ROLE-2"><a href="#2-RolesAllowed-ROLE-1-ROLE-2" class="headerlink" title="2. @RolesAllowed({&quot;ROLE_1&quot;, &quot;ROLE_2&quot;})"></a>2. <code>@RolesAllowed({&quot;ROLE_1&quot;, &quot;ROLE_2&quot;})</code></h5><ul>
<li><strong>来源</strong>: <strong>JSR-250</strong> 标准定义的一套 Java 安全注解之一。Spring Security 提供了对其的支持。</li>
<li><strong>用法</strong>: 与 <code>@Secured</code> 类似，参数也是一个字符串数组。</li>
<li><strong>约定</strong>: 角色名<strong>不需要</strong> <code>ROLE_</code> 前缀。Spring Security 在处理时会自动为你添加 <code>ROLE_</code> 前缀进行匹配。</li>
<li><strong>逻辑</strong>: 同样，拥有参数列表中<strong>任意一个</strong>角色的用户即可访问。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.annotation.security.RolesAllowed;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拥有 ROLE_ADMIN 角色的用户可以访问</span></span><br><span class="line"><span class="meta">@RolesAllowed(&quot;ADMIN&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resetSystem</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拥有 ROLE_ADMIN 或 ROLE_MANAGER 角色的用户可以访问</span></span><br><span class="line"><span class="meta">@RolesAllowed(&#123;&quot;ADMIN&quot;, &quot;MANAGER&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> DashboardData <span class="title function_">getDashboard</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-3-4-如何选择？"><a href="#3-3-4-如何选择？" class="headerlink" title="3.3.4 如何选择？"></a>3.3.4 如何选择？</h4><ul>
<li><strong>首选 <code>@PreAuthorize</code></strong>: 在绝大多数情况下，<code>@PreAuthorize</code> 都是最佳选择。它的 SpEL 功能提供了无与伦比的灵活性，能够满足几乎所有的授权需求，尤其是需要动态判断和对象级别访问控制的场景。</li>
<li><strong>使用 <code>@PostAuthorize</code></strong>: 仅在需要基于方法<strong>返回值</strong>进行判断时才考虑使用，并注意其副作用。</li>
<li><strong>使用 <code>@Secured</code> 或 <code>@RolesAllowed</code></strong>: 如果你的授权需求非常简单，仅仅是基于静态的角色列表，并且你和你的团队喜欢这种更简洁的声明方式，那么可以使用它们。<code>@RolesAllowed</code> 因为是 Java EE 标准的一部分，可能在某些追求标准化的项目中更受欢迎。但总的来说，它们的功能是 <code>@PreAuthorize(&quot;hasAnyRole(...)&quot;)</code> 的一个子集。</li>
</ul>
<hr>
<h3 id="3-4-在授权中使用-SpEL-表达式"><a href="#3-4-在授权中使用-SpEL-表达式" class="headerlink" title="3.4 在授权中使用 SpEL 表达式"></a>3.4 在授权中使用 SpEL 表达式</h3><p>SpEL 是一种功能强大的表达式语言，它允许在运行时查询和操作对象图。在 Spring Security 中，SpEL 被集成到了 <code>@PreAuthorize</code> 和 <code>@PostAuthorize</code> 等注解中，将静态的授权规则提升到了一个全新的、动态的维度。这使得我们能够编写出与当前请求上下文、方法参数甚至其他业务逻辑紧密相关的复杂授权规则。</p>
<h4 id="3-4-1-SpEL-表达式的核心能力"><a href="#3-4-1-SpEL-表达式的核心能力" class="headerlink" title="3.4.1 SpEL 表达式的核心能力"></a>3.4.1 SpEL 表达式的核心能力</h4><p>在 Spring Security 的方法安全表达式中，SpEL 提供了一个强大的“根对象”（Root Object）作为评估上下文，我们可以通过它访问各种有用的内置对象和函数。</p>
<h5 id="1-内置的安全表达式"><a href="#1-内置的安全表达式" class="headerlink" title="1. 内置的安全表达式"></a>1. 内置的安全表达式</h5><p>Spring Security 提供了一系列内置的、可以直接使用的安全相关函数，这些函数极大地方便了我们编写授权规则。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>等价的 URL 配置方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>hasRole(&#39;ROLE_NAME&#39;)</code></td>
<td><code>.hasRole(&quot;NAME&quot;)</code></td>
<td>判断当前用户是否拥有指定角色。 <strong>注意</strong>: 角色名通常需要 <code>ROLE_</code> 前缀。</td>
</tr>
<tr>
<td><code>hasAnyRole(&#39;R1&#39;, &#39;R2&#39;)</code></td>
<td><code>.hasAnyRole(&quot;R1&quot;,&quot;R2&quot;)</code></td>
<td>判断用户是否拥有列表中的任意一个角色。</td>
</tr>
<tr>
<td><code>hasAuthority(&#39;AUTH&#39;)</code></td>
<td><code>.hasAuthority(&quot;AUTH&quot;)</code></td>
<td>判断用户是否拥有指定权限。</td>
</tr>
<tr>
<td><code>hasAnyAuthority(&#39;A1&#39;,&#39;A2&#39;)</code></td>
<td><code>.hasAnyAuthority(&quot;A1&quot;,&quot;A2&quot;)</code></td>
<td>判断用户是否拥有列表中的任意一个权限。</td>
</tr>
<tr>
<td><code>permitAll</code></td>
<td><code>.permitAll()</code></td>
<td>总是返回 <code>true</code>，允许所有访问。</td>
</tr>
<tr>
<td><code>denyAll</code></td>
<td><code>.denyAll()</code></td>
<td>总是返回 <code>false</code>，拒绝所有访问。</td>
</tr>
<tr>
<td><code>isAuthenticated()</code></td>
<td><code>.authenticated()</code></td>
<td>判断用户是否已经认证（非匿名）。</td>
</tr>
<tr>
<td><code>isAnonymous()</code></td>
<td></td>
<td>判断用户是否是匿名用户。</td>
</tr>
<tr>
<td><code>isRememberMe()</code></td>
<td></td>
<td>判断用户是否是通过“记住我”功能认证的。</td>
</tr>
<tr>
<td><code>isFullyAuthenticated()</code></td>
<td></td>
<td>判断用户是否经过了完整的认证流程（而不是通过“记住我”）。</td>
</tr>
</tbody></table>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等同于 @Secured(&quot;ROLE_ADMIN&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ROLE_ADMIN&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAdminAction</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求用户必须是完整登录，而不是“记住我”状态</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;isFullyAuthenticated()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changePassword</span><span class="params">(String newPassword)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-访问-authentication-对象"><a href="#2-访问-authentication-对象" class="headerlink" title="2. 访问 authentication 对象"></a>2. 访问 <code>authentication</code> 对象</h5><p>SpEL 表达式可以直接访问当前 <code>SecurityContext</code> 中的 <code>authentication</code> 对象。这是实现动态判断的基础。</p>
<ul>
<li><code>authentication.name</code>: 获取当前用户名。</li>
<li><code>authentication.principal</code>: 获取当前用户主体（Principal）。如果使用的是 <code>UserDetails</code>，那么这个对象就是你的 <code>UserDetails</code> 实例。</li>
<li><code>authentication.authorities</code>: 获取当前用户的权限集合。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有用户名为 &#x27;superadmin&#x27; 的用户才能执行</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;authentication.name == &#x27;superadmin&#x27;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runSuperAdminTask</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设你的 UserDetails 实现类有一个 getEmail() 方法</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;authentication.principal.email.endsWith(&#x27;@mycompany.com&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accessInternalResource</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-4-2-动态判断：结合方法参数"><a href="#3-4-2-动态判断：结合方法参数" class="headerlink" title="3.4.2 动态判断：结合方法参数"></a>3.4.2 动态判断：结合方法参数</h4><p>SpEL 最强大的功能之一是能够引用被拦截方法的参数。这使得授权规则可以根据每次方法调用的具体上下文来动态决策。</p>
<p><strong>语法</strong>：通过 <code>#参数名</code> 的形式来引用。</p>
<h5 id="1-“所有权”-检查"><a href="#1-“所有权”-检查" class="headerlink" title="1. “所有权” 检查"></a>1. “所有权” 检查</h5><p>这是最经典的用例：判断当前用户是否是某个数据对象的“所有者”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景：用户只能查看自己的账户信息</span></span><br><span class="line"><span class="comment">// #accountId 引用了方法的 accountId 参数</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;#accountId == authentication.principal.accountId&quot;)</span> </span><br><span class="line"><span class="comment">// 假设你的 UserDetails 实现中有 getAccountId() 方法</span></span><br><span class="line"><span class="keyword">public</span> Account <span class="title function_">getAccountDetails</span><span class="params">(Long accountId)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景：用户只能更新自己的博客文章</span></span><br><span class="line"><span class="comment">// #post.authorUsername 访问了 post 对象的 authorUsername 属性</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;#post.authorUsername == authentication.name or hasRole(&#x27;ROLE_MODERATOR&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updatePost</span><span class="params">(Post post)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-使用-P-或-Param-注解为参数命名"><a href="#2-使用-P-或-Param-注解为参数命名" class="headerlink" title="2. 使用 @P 或 @Param 注解为参数命名"></a>2. 使用 <code>@P</code> 或 <code>@Param</code> 注解为参数命名</h5><p>如果你的项目编译时没有保留参数名（例如，使用旧版本的 Java 或特定的编译设置），SpEL 可能无法通过 <code>#参数名</code> 找到参数。这时，可以使用 <code>@P</code> (Spring Security 提供) 或 <code>@Param</code> (Spring Data 提供) 注解来显式地为参数命名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.access.prepost.PreAuthorize;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.parameters.P;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;#user.username == authentication.name&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeUserPassword</span><span class="params">(<span class="meta">@P(&quot;user&quot;)</span> User user, String newPassword)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>这是一个很好的编程习惯，因为它使得代码意图更明确，且不受编译选项的影响。</p>
<hr>
<h4 id="3-4-3-访问-Bean-方法进行复杂判断"><a href="#3-4-3-访问-Bean-方法进行复杂判断" class="headerlink" title="3.4.3 访问 Bean 方法进行复杂判断"></a>3.4.3 访问 Bean 方法进行复杂判断</h4><p>当授权逻辑变得非常复杂，不适合写在一个长长的 SpEL 表达式里时，最佳实践是<strong>将授权逻辑封装到一个单独的 Spring Bean 中</strong>，然后在 SpEL 中调用这个 Bean 的方法。</p>
<h5 id="1-创建一个授权服务-Bean"><a href="#1-创建一个授权服务-Bean" class="headerlink" title="1. 创建一个授权服务 Bean"></a>1. 创建一个授权服务 Bean</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;securityService&quot;)</span> <span class="comment">// 给 Bean 一个明确的名字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PostRepository postRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前用户是否是某篇文章的作者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPostOwner</span><span class="params">(Authentication authentication, Long postId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">currentUsername</span> <span class="operator">=</span> authentication.getName();</span><br><span class="line">        <span class="type">Post</span> <span class="variable">post</span> <span class="operator">=</span> postRepository.findById(postId).orElse(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (post == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 或者抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> post.getAuthorUsername().equals(currentUsername);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更复杂的逻辑，例如检查用户是否在某个项目团队中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInProjectTeam</span><span class="params">(Authentication authentication, Long projectId)</span> &#123;</span><br><span class="line">        <span class="comment">// ... 查询数据库，判断用户是否是项目成员 ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-在-SpEL-中调用-Bean-的方法"><a href="#2-在-SpEL-中调用-Bean-的方法" class="headerlink" title="2. 在 SpEL 中调用 Bean 的方法"></a>2. 在 SpEL 中调用 Bean 的方法</h5><p><strong>语法</strong>：通过 <code>@beanName.methodName(arguments)</code> 的形式调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 securityService Bean 的 isPostOwner 方法</span></span><br><span class="line"><span class="comment">// 将当前的 authentication 对象和方法的 postId 参数传递过去</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@securityService.isPostOwner(authentication, #postId)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">editPost</span><span class="params">(Long postId, String content)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@securityService.isInProjectTeam(authentication, #projectId)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ProjectDashboard <span class="title function_">getProjectDashboard</span><span class="params">(Long projectId)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>这种方法的巨大优势</strong>:</p>
<ul>
<li><strong>关注点分离</strong>: 将复杂的授权逻辑从业务方法的注解中抽离出来，放到了专门的 <code>SecurityService</code> 中，使得业务代码更干净。</li>
<li><strong>可重用性</strong>: <code>isPostOwner</code> 这样的方法可以在多个需要此项检查的地方被重复调用。</li>
<li><strong>可测试性</strong>: <code>SecurityService</code> 是一个普通的 Spring Bean，可以像其他 Service 一样被轻松地进行单元测试。</li>
<li><strong>无限扩展</strong>: 你可以在这个 Bean 中注入任何其他服务（如 <code>UserRepository</code>, <code>ProjectRepository</code>），编写任意复杂的 Java 代码来实现你的授权判断，而不仅仅局限于 SpEL 的语法。</li>
</ul>
<hr>
<h3 id="3-5-访问控制决策者（高级）"><a href="#3-5-访问控制决策者（高级）" class="headerlink" title="3.5 访问控制决策者（高级）"></a>3.5 访问控制决策者（高级）</h3><p>在我们通过 <code>.authorizeHttpRequests()</code> 或 <code>@PreAuthorize</code> 声明授权规则时，这些高级的配置最终会被 Spring Security 翻译成底层的决策逻辑。在传统的 Spring Security 架构中，这个决策过程的核心就是 <code>AccessDecisionManager</code> 和 <code>AccessDecisionVoter</code>。</p>
<h4 id="3-5-1-核心概念：投票决策模型"><a href="#3-5-1-核心概念：投票决策模型" class="headerlink" title="3.5.1 核心概念：投票决策模型"></a>3.5.1 核心概念：投票决策模型</h4><p>想象一下一个议会正在对一项法案进行投票。</p>
<ul>
<li><strong>法案</strong>: 相当于一个访问请求，例如“用户 Bob 想要访问 <code>/admin/dashboard</code>”。</li>
<li><strong>议员 (Voter)</strong>: 每个议员都有自己的专长和立场。有的只关心角色，有的只关心IP地址，有的只关心时间。</li>
<li><strong>议长 (Manager)</strong>: 议长不亲自投票，他负责组织投票，并根据议会规则（如“简单多数通过”或“一票否决”）来宣布最终结果。</li>
</ul>
<p>Spring Security 的授权决策机制就是这个模型的完美体现。</p>
<ul>
<li><strong><code>AccessDecisionVoter</code> (投票者)</strong>: 对应“议员”。</li>
<li><strong><code>AccessDecisionManager</code> (决策管理器)</strong>: 对应“议长”。</li>
</ul>
<hr>
<h4 id="3-5-2-AccessDecisionVoter-接口"><a href="#3-5-2-AccessDecisionVoter-接口" class="headerlink" title="3.5.2 AccessDecisionVoter&lt;T&gt; 接口"></a>3.5.2 <code>AccessDecisionVoter&lt;T&gt;</code> 接口</h4><p><code>AccessDecisionVoter</code> 是执行具体投票逻辑的组件。</p>
<p><strong>核心方法</strong>:</p>
<ol>
<li><strong><code>boolean supports(ConfigAttribute attribute)</code></strong>:<ul>
<li>在投票前，<code>AccessDecisionManager</code> 会用这个方法来询问 Voter：“你关心这个类型的权限配置吗？”</li>
<li><code>ConfigAttribute</code> 是对权限规则（如 <code>ROLE_ADMIN</code>）的抽象。</li>
<li>例如，<code>RoleVoter</code> 只会对代表角色的 <code>ConfigAttribute</code> 返回 <code>true</code>。</li>
</ul>
</li>
<li><strong><code>boolean supports(Class&lt;?&gt; clazz)</code></strong>:<ul>
<li>询问 Voter：“你能对这种类型的受保护对象（Secure Object）进行投票吗？”</li>
<li>例如，<code>WebExpressionVoter</code> 会对 <code>Request</code> 对象返回 <code>true</code>，而方法安全的 Voter 会对 <code>MethodInvocation</code> 返回 <code>true</code>。</li>
</ul>
</li>
<li><strong><code>int vote(Authentication authentication, T object, Collection&lt;ConfigAttribute&gt; attributes)</code></strong>:<ul>
<li>这是<strong>核心的投票方法</strong>。如果前面的 <code>supports</code> 方法都返回 <code>true</code>，<code>AccessDecisionManager</code> 就会调用它。</li>
<li><strong>参数</strong>:<ul>
<li><code>authentication</code>: 当前用户的认证信息。</li>
<li><code>object</code>: 正在被访问的受保护对象（如 <code>FilterInvocation</code>，包含了 <code>request</code> 和 <code>response</code>）。</li>
<li><code>attributes</code>: 保护该对象所需的所有权限配置的集合。</li>
</ul>
</li>
<li><strong>返回值 (int)</strong>:<ul>
<li><code>AccessDecisionVoter.ACCESS_GRANTED</code> (1): <strong>赞成</strong>。表示根据我的逻辑，应该允许访问。</li>
<li><code>AccessDecisionVoter.ACCESS_DENIED</code> (-1): <strong>反对</strong>。表示根据我的逻辑，应该拒绝访问。</li>
<li><code>AccessDecisionVoter.ACCESS_ABSTAIN</code> (0): <strong>弃权</strong>。表示这个规则我不关心，让其他 Voter 决定吧。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>常见的 Voter 实现</strong>:</p>
<ul>
<li><code>RoleVoter</code>: 可能是最简单的 Voter。它检查用户的 <code>GrantedAuthority</code> 是否匹配任何以 <code>ROLE_</code> 前缀开头的 <code>ConfigAttribute</code>。如果匹配，投赞成票；否则弃权。</li>
<li><code>AuthenticatedVoter</code>: 检查用户是否是匿名、通过“记住我”认证，或完全认证，并根据配置（如 <code>IS_AUTHENTICATED_FULLY</code>）进行投票。</li>
<li><code>WebExpressionVoter</code>: <strong>功能最强大的 Voter</strong>。它负责解析和执行 SpEL 表达式（如 <code>hasRole(&#39;ADMIN&#39;) and hasIpAddress(&#39;192.168.1.0/24&#39;)</code>）。</li>
</ul>
<hr>
<h4 id="3-5-3-AccessDecisionManager-接口"><a href="#3-5-3-AccessDecisionManager-接口" class="headerlink" title="3.5.3 AccessDecisionManager 接口"></a>3.5.3 <code>AccessDecisionManager</code> 接口</h4><p><code>AccessDecisionManager</code> 是授权决策的最终裁决者。它管理一个 <code>AccessDecisionVoter</code> 列表，并根据投票结果做出最终决定。</p>
<p><strong>核心方法</strong>:</p>
<ul>
<li><strong><code>void decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</code></strong>:<ul>
<li>这是唯一的决策方法。</li>
<li><strong>职责</strong>:<ol>
<li>遍历其管理的 <code>AccessDecisionVoter</code> 列表。</li>
<li>调用每个 Voter 的 <code>vote</code> 方法来收集投票。</li>
<li>根据自己的内部策略，对投票结果进行汇总和裁决。</li>
<li>如果最终决定是<strong>拒绝</strong>，它必须抛出 <code>AccessDeniedException</code>。</li>
<li>如果最终决定是<strong>允许</strong>，它会正常返回，不做任何事情，请求将继续执行。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>常见的 Manager 实现 (决策策略)</strong>:</p>
<ol>
<li><strong><code>AffirmativeBased</code> (默认策略)</strong><ul>
<li><strong>“一票赞成就通过”</strong>。</li>
<li><strong>逻辑</strong>:<ul>
<li>只要有一个 Voter 投了 <code>ACCESS_GRANTED</code> (赞成票)，就立即做出“允许”的决定，不再询问其他 Voter。</li>
<li>如果没有赞成票，并且 <code>isAllowIfAllAbstainDecisions()</code> 为 <code>false</code>（默认），则抛出 <code>AccessDeniedException</code>。</li>
<li><strong>注意</strong>: <code>AffirmativeBased</code> 不会因为有 <code>ACCESS_DENIED</code> (反对票) 而立即拒绝。它只关心有没有赞成票。</li>
</ul>
</li>
<li><strong>优点</strong>: 灵活。你可以组合多个独立的、可选的授权条件（例如，角色、IP、时间），满足任何一个即可。</li>
</ul>
</li>
<li><strong><code>ConsensusBased</code></strong><ul>
<li><strong>“少数服从多数”</strong>。</li>
<li><strong>逻辑</strong>:<ul>
<li>统计所有非弃权票。</li>
<li>如果赞成票严格多于反对票，则“允许”。</li>
<li>如果反对票多于或等于赞成票，则“拒绝”。</li>
<li>如果全是弃权票，根据 <code>isAllowIfAllAbstainDecisions()</code> 决定。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>UnanimousBased</code></strong><ul>
<li><strong>“一票否决制”</strong>。</li>
<li><strong>逻辑</strong>:<ul>
<li>只要有一个 Voter 投了 <code>ACCESS_DENIED</code> (反对票)，就立即做出“拒绝”的决定。</li>
<li>如果没有反对票，但至少有一个赞成票，则“允许”。</li>
<li>如果全是弃权票，根据 <code>isAllowIfAllAbstainDecisions()</code> 决定。</li>
</ul>
</li>
<li><strong>优点</strong>: 严格。适用于需要满足所有安全条件的场景。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-5-4-现代架构的演进-AuthorizationManager"><a href="#3-5-4-现代架构的演进-AuthorizationManager" class="headerlink" title="3.5.4 现代架构的演进 (AuthorizationManager)"></a>3.5.4 现代架构的演进 (<code>AuthorizationManager</code>)</h4><p>随着 Spring Security 的发展，特别是函数式配置风格的引入，<code>AccessDecisionManager</code> 和 <code>AccessDecisionVoter</code> 这套复杂的投票机制被一个更简洁的接口所取代：<strong><code>AuthorizationManager</code></strong>。</p>
<ul>
<li><strong><code>AuthorizationManager&lt;T&gt;</code></strong> 接口只有一个方法: <code>AuthorizationDecision check(Supplier&lt;Authentication&gt; authentication, T object)</code>。</li>
<li>它不再有“投票”和“弃权”的概念，而是直接返回一个 <code>AuthorizationDecision</code> 对象，该对象包含一个布尔值（<code>isGranted()</code>）。如果决策是拒绝，<code>AuthorizationManager</code> 的实现通常会直接抛出 <code>AccessDeniedException</code>。</li>
</ul>
<p><strong>关系</strong>:</p>
<p>你可以将 <code>AuthorizationManager</code> 看作是 <code>AccessDecisionManager</code> 和 <code>AccessDecisionVoter</code> 的<strong>结合体和简化版</strong>。我们通过 <code>.authorizeHttpRequests()</code> 提供的 Lambda 表达式，实际上是在动态地构建和组合各种 <code>AuthorizationManager</code> 的实现。</p>
<p>例如，<code>.hasRole(&quot;ADMIN&quot;)</code> 内部会创建一个 <code>AuthorityAuthorizationManager</code> 的实例。</p>
<p><strong>为什么还要了解旧模型？</strong></p>
<ol>
<li><strong>理解历史和设计哲学</strong>: 投票模型是 Spring Security 设计哲学的核心，理解它有助于你更深入地理解框架的行为。</li>
<li><strong>维护老项目</strong>: 大量现存的 Spring Security 项目仍然在使用基于 XML 或 <code>WebSecurityConfigurerAdapter</code> 的配置，这些配置底层就是 <code>AccessDecisionManager</code>。</li>
<li><strong>深度定制</strong>: 如果你需要实现非常独特的、标准 <code>AuthorizationManager</code> 无法满足的授权逻辑，你可能需要自定义 <code>AccessDecisionVoter</code> 和 <code>AccessDecisionManager</code>，并将它们集成到安全配置中。</li>
</ol>
<hr>
<h2 id="4-Web-安全与高级配置"><a href="#4-Web-安全与高级配置" class="headerlink" title="4. Web 安全与高级配置"></a>4. Web 安全与高级配置</h2><h3 id="4-1-CSRF-跨站请求伪造-防护"><a href="#4-1-CSRF-跨站请求伪造-防护" class="headerlink" title="4.1 CSRF (跨站请求伪造) 防护"></a>4.1 CSRF (跨站请求伪造) 防护</h3><p>CSRF (Cross-Site Request Forgery) 是一种常见的、极具欺骗性的网络攻击方式。攻击者通过诱导受害者在一个已登录的网站上执行非本意的操作，从而达到恶意目的。Spring Security 默认开启了强大的 CSRF 防护机制来应对这种威胁。</p>
<h4 id="4-1-1-CSRF-攻击原理"><a href="#4-1-1-CSRF-攻击原理" class="headerlink" title="4.1.1 CSRF 攻击原理"></a>4.1.1 CSRF 攻击原理</h4><p>要理解 CSRF 防护，首先必须明白攻击是如何发生的。</p>
<p><strong>攻击场景</strong>:</p>
<ol>
<li><p><strong>用户登录可信网站</strong>: 用户 Bob 登录了他的网上银行网站 <code>bank.com</code>，并且没有退出。<code>bank.com</code> 将 Bob 的会话信息（Session ID）存储在了浏览器的 Cookie 中。</p>
</li>
<li><p><strong>用户访问恶意网站</strong>: 之后，Bob 浏览了一个恶意网站 <code>evil.com</code>。这个网站的页面上可能包含一个隐藏的表单或一个诱导性的图片链接，其目标指向 <code>bank.com</code> 的一个敏感操作，比如转账。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 恶意网站 evil.com 的页面内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>超值优惠，点击领取！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 方式一：一个自动提交的隐藏表单 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;csrf-form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;https://bank.com/transfer&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;toAccount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Mallory-Account-ID&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;csrf-form&#x27;</span>).<span class="title function_">submit</span>();</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 方式二：一个看似无害的图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://bank.com/transfer?toAccount=Mallory-Account-ID&amp;amount=1000&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>(注: GET 请求虽然不规范，但也能触发某些不安全的敏感操作)</em></p>
</li>
<li><p><strong>浏览器自动携带 Cookie</strong>: 当 Bob 的浏览器加载 <code>evil.com</code> 的页面时，它会解析到这个表单或图片，并向 <code>bank.com/transfer</code> 发起一个请求。根据浏览器的同源策略，<strong>在跨域请求时，浏览器会自动携带目标域 (<code>bank.com</code>) 的 Cookie</strong>。</p>
</li>
<li><p><strong>攻击成功</strong>: <code>bank.com</code> 的服务器收到了这个转账请求。它检查请求中的 Cookie，发现是 Bob 的有效会话，于是认为这是 Bob 本人发起的合法操作，便执行了转账。Bob 在毫不知情的情况下，钱就被转走了。</p>
</li>
</ol>
<p><strong>攻击的核心</strong>: <strong>攻击者利用了浏览器会自动携带 Cookie 的特性，并借助用户的登录状态，伪造了用户的请求。</strong> 服务器无法分辨这个请求是用户在 <code>bank.com</code> 官网上点击按钮触发的，还是在 <code>evil.com</code> 上被动触发的。</p>
<hr>
<h4 id="4-1-2-Spring-Security-的-CSRF-防护机制：同步器令牌模式-Synchronizer-Token-Pattern"><a href="#4-1-2-Spring-Security-的-CSRF-防护机制：同步器令牌模式-Synchronizer-Token-Pattern" class="headerlink" title="4.1.2 Spring Security 的 CSRF 防护机制：同步器令牌模式 (Synchronizer Token Pattern)"></a>4.1.2 Spring Security 的 CSRF 防护机制：同步器令牌模式 (Synchronizer Token Pattern)</h4><p>Spring Security 采用业界标准的<strong>同步器令牌模式</strong>来防御 CSRF 攻击。</p>
<p><strong>工作原理</strong>:</p>
<ol>
<li><strong>服务器生成 Token</strong>: 当用户访问网站时（特别是访问包含表单的页面），服务器会生成一个随机的、不可预测的字符串，称为 <strong>CSRF Token</strong>。</li>
<li><strong>Token 双重分发</strong>:<ul>
<li><strong>一份存储在服务器端</strong>: 这个 Token 会被存储在用户的 <code>HttpSession</code> 中。</li>
<li><strong>一份发送给客户端</strong>: 这个 Token 会被放入页面的某个地方，通常是一个隐藏的表单字段。</li>
</ul>
</li>
<li><strong>客户端提交 Token</strong>: 当用户提交表单时，这个隐藏字段中的 CSRF Token 会作为请求参数，随同其他数据一起发送回服务器。</li>
<li><strong>服务器端验证</strong>: 服务器收到请求后，会执行以下比较：<ul>
<li>从请求参数中获取客户端提交的 Token。</li>
<li>从当前用户的 <code>HttpSession</code> 中获取服务器端存储的 Token。</li>
<li><strong>比较两者是否完全一致</strong>。</li>
</ul>
</li>
<li><strong>决策</strong>:<ul>
<li><strong>如果一致</strong>: 说明请求确实是由网站自己的页面发起的，是合法请求，予以处理。</li>
<li><strong>如果不一致或请求中没有 Token</strong>: 说明这很可能是一个伪造的请求（因为恶意网站 <code>evil.com</code> 无法获取到这个随机 Token），服务器会拒绝该请求，通常返回 <strong>403 Forbidden</strong>。</li>
</ul>
</li>
</ol>
<p>这个机制之所以有效，是因为攻击者所在的恶意网站 <code>evil.com</code> 受到浏览器同源策略的限制，无法通过脚本读取到 <code>bank.com</code> 页面内容或 Cookie 中精确的 Token 值，因此无法在伪造的请求中包含正确的 Token。</p>
<hr>
<h4 id="4-1-3-Spring-Security-的-CsrfFilter-与-CsrfToken"><a href="#4-1-3-Spring-Security-的-CsrfFilter-与-CsrfToken" class="headerlink" title="4.1.3 Spring Security 的 CsrfFilter 与 CsrfToken"></a>4.1.3 Spring Security 的 <code>CsrfFilter</code> 与 <code>CsrfToken</code></h4><ul>
<li><strong><code>CsrfFilter</code></strong>:<ul>
<li>这是 Spring Security 过滤器链中负责 CSRF 防护的核心组件。</li>
<li>它在 <code>UsernamePasswordAuthenticationFilter</code> 等执行实际操作的过滤器之前运行。</li>
<li><strong>职责</strong>:<ul>
<li>对所有“不安全”的 HTTP 方法（如 <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>PATCH</code>）进行拦截。它默认会放行 <code>GET</code>, <code>HEAD</code>, <code>TRACE</code>, <code>OPTIONS</code> 请求，因为这些方法被认为是幂等的，不应改变服务器状态。</li>
<li>执行上述的 Token 比较逻辑。如果验证失败，它会立即中断请求链，并抛出 <code>InvalidCsrfTokenException</code> 或 <code>MissingCsrfTokenException</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>CsrfToken</code></strong>:<ul>
<li>这是一个接口，代表了 CSRF Token 本身。它包含了三个关键信息：<ul>
<li><code>getToken()</code>: 获取 Token 的字符串值。</li>
<li><code>getHeaderName()</code>: 获取期望在 HTTP Header 中传递 Token 时使用的 Header 名称（默认为 <code>X-CSRF-TOKEN</code>）。</li>
<li><code>getParameterName()</code>: 获取期望在请求参数中传递 Token 时使用的参数名称（默认为 <code>_csrf</code>）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-1-4-与前端的集成"><a href="#4-1-4-与前端的集成" class="headerlink" title="4.1.4 与前端的集成"></a>4.1.4 与前端的集成</h4><p>为了让 CSRF 防护正常工作，前端必须正确地获取并提交 CSRF Token。</p>
<h5 id="1-Thymeleaf-服务器端渲染"><a href="#1-Thymeleaf-服务器端渲染" class="headerlink" title="1. Thymeleaf (服务器端渲染)"></a>1. Thymeleaf (服务器端渲染)</h5><p>Thymeleaf 对 Spring Security 的 CSRF 提供了无缝的、自动化的集成。</p>
<ul>
<li><p><strong>表单集成</strong>:<br>只要你在 <code>form</code> 标签上使用了 <code>th:action</code>，并且你的应用启用了 CSRF 防护，Thymeleaf 会<strong>自动</strong>在生成的 HTML 表单中添加一个隐藏字段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/process&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... other inputs ... --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 下面这行是由 Thymeleaf 自动生成的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_csrf&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你几乎不需要做任何额外的工作，这是最简单、最推荐的方式。</p>
</li>
<li><p><strong>Meta 标签集成 (用于 AJAX)</strong>:<br>为了方便在 JavaScript 中使用 Token，可以在页面的 <code>&lt;head&gt;</code> 部分添加 meta 标签：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;_csrf&quot;</span> <span class="attr">th:content</span>=<span class="string">&quot;$&#123;_csrf.token&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;_csrf_header&quot;</span> <span class="attr">th:content</span>=<span class="string">&quot;$&#123;_csrf.headerName&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，JavaScript 就可以轻松地读取这些 meta 标签来获取 Token 和 Header 名称。</p>
</li>
</ul>
<hr>
<h5 id="2-AJAX-前后端分离"><a href="#2-AJAX-前后端分离" class="headerlink" title="2. AJAX (前后端分离)"></a>2. AJAX (前后端分离)</h5><p>对于使用 JavaScript（如 Fetch API, Axios）发起的 AJAX 请求，你需要手动将 CSRF Token 添加到请求中。有两种标准方式：</p>
<p><strong>a. 作为请求参数 (Request Parameter)</strong></p>
<p>适用于 <code>application/x-www-form-urlencoded</code> 类型的请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设已通过 meta 标签获取</span></span><br><span class="line"><span class="keyword">const</span> token = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;_csrf&quot;]&#x27;</span>).<span class="title function_">getAttribute</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>();</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;field1&#x27;</span>, <span class="string">&#x27;value1&#x27;</span>);</span><br><span class="line">formData.<span class="title function_">append</span>(<span class="string">&#x27;_csrf&#x27;</span>, token); <span class="comment">// 将 token 作为参数添加</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/api/data&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: formData</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>b. 作为请求头 (Request Header) - 推荐方式</strong></p>
<p>这是更现代、更通用的方式，尤其适用于发送 JSON 数据的请求 (<code>application/json</code>)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设已通过 meta 标签获取</span></span><br><span class="line"><span class="keyword">const</span> token = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;_csrf&quot;]&#x27;</span>).<span class="title function_">getAttribute</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> headerName = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;_csrf_header&quot;]&#x27;</span>).<span class="title function_">getAttribute</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Axios 的示例</span></span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;/api/data&#x27;</span>, </span><br><span class="line">    &#123; <span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span> &#125;, </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">headers</span>: &#123;</span><br><span class="line">            [headerName]: token <span class="comment">// 将 token 放入指定的 header</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Fetch API 的示例</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/api/data&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        [headerName]: token</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span> &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>全局配置 (如 Axios Interceptors)</strong></p>
<p>在实际项目中，最好的做法是配置一个全局的请求拦截器，自动为所有不安全的请求添加 CSRF Token Header，而无需在每个请求中手动添加。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Axios 拦截器示例</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> token = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;_csrf&quot;]&#x27;</span>).<span class="title function_">getAttribute</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> headerName = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;_csrf_header&quot;]&#x27;</span>).<span class="title function_">getAttribute</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (token &amp;&amp; headerName) &#123;</span><br><span class="line">        config.<span class="property">headers</span>[headerName] = token;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>禁用 CSRF</strong></p>
<p>在某些特定场景下（例如，你正在构建一个无状态的、基于 Token 认证的 REST API，并且不使用 Cookie 进行会话管理），你可能需要禁用 CSRF 防护。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        .csrf(csrf -&gt; csrf.disable()); <span class="comment">// 禁用 CSRF 防护</span></span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>警告</strong>: 除非你完全确定你的认证机制（如 JWT in Header）不受 CSRF 攻击影响，否则不要轻易禁用它。如果你的应用同时支持 Cookie 认证和 API Token 认证，你需要更精细的配置来只对 API 部分禁用 CSRF。</p>
<hr>
<h3 id="4-2-CORS-跨域资源共享-配置"><a href="#4-2-CORS-跨域资源共享-配置" class="headerlink" title="4.2 CORS (跨域资源共享) 配置"></a>4.2 CORS (跨域资源共享) 配置</h3><p>在<code>Spring全家桶-SpringWeb</code>中的1.5.4节介绍过了跨域问题，那么SpringSecurity是如何解决的呢。</p>
<h4 id="4-2-1-启用-CORS-支持-cors"><a href="#4-2-1-启用-CORS-支持-cors" class="headerlink" title="4.2.1 启用 CORS 支持: .cors()"></a>4.2.1 启用 CORS 支持: <code>.cors()</code></h4><p>首先，你需要在你的 <code>SecurityFilterChain</code> 配置中调用 <code>.cors()</code> 方法来启用 CORS 支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .cors(Customizer.withDefaults()) <span class="comment">// 启用 CORS，并使用默认配置</span></span><br><span class="line">        <span class="comment">// ... 其他配置</span></span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>.cors()</code> 的作用是在 Spring Security 的过滤器链中添加一个 <code>CorsFilter</code>。这个过滤器会尝试从 Spring 的应用上下文中查找一个名为 <code>corsConfigurationSource</code> 的 Bean。如果找到了，它就会使用这个 Bean 提供的配置来处理 CORS 请求。</p>
<h4 id="4-2-2-提供-CORS-配置-CorsConfigurationSource-Bean"><a href="#4-2-2-提供-CORS-配置-CorsConfigurationSource-Bean" class="headerlink" title="4.2.2 提供 CORS 配置: CorsConfigurationSource Bean"></a>4.2.2 提供 CORS 配置: <code>CorsConfigurationSource</code> Bean</h4><p>所以，下一步就是定义这个 <code>corsConfigurationSource</code> Bean。这是配置 CORS 规则的核心。</p>
<p><strong>推荐方式：创建一个 <code>CorsConfigurationSource</code> Bean</strong></p>
<p>这种方式最灵活，允许你根据不同的请求路径应用不同的 CORS 策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsConfigurationSource <span class="title function_">corsConfigurationSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 CorsConfiguration 对象</span></span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 设置允许的源</span></span><br><span class="line">        <span class="comment">// configuration.setAllowedOrigins(Arrays.asList(&quot;http://localhost:3000&quot;, &quot;https://app.my-domain.com&quot;));</span></span><br><span class="line">        <span class="comment">// 对于需要携带凭证（如Cookie）的请求，不能使用 &quot;*&quot;，必须指定具体的源</span></span><br><span class="line">        configuration.setAllowedOrigins(List.of(<span class="string">&quot;http://localhost:3000&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 设置允许的 HTTP 方法</span></span><br><span class="line">        configuration.setAllowedMethods(Arrays.asList(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 设置允许的请求头</span></span><br><span class="line">        <span class="comment">// &quot;*&quot; 表示允许所有头，但在生产环境中建议明确指定</span></span><br><span class="line">        configuration.setAllowedHeaders(Arrays.asList(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;X-Requested-With&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 设置是否允许发送 Cookie 等凭证</span></span><br><span class="line">        <span class="comment">// 当设置为 true 时，allowedOrigins 不能为 &quot;*&quot;</span></span><br><span class="line">        configuration.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6. 暴露哪些响应头给前端JS，让其可以访问</span></span><br><span class="line">        <span class="comment">// configuration.setExposedHeaders(Arrays.asList(&quot;header1&quot;, &quot;header2&quot;));</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 7. 设置预检请求的有效期，单位为秒。在此期间，浏览器无需为相同的跨域请求再次发送预检请求</span></span><br><span class="line">        configuration.setMaxAge(<span class="number">3600L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8. 创建 UrlBasedCorsConfigurationSource 对象，注册 CORS 配置</span></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        <span class="comment">// 对所有 URL 路径应用上述配置</span></span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, configuration);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ul>
<li><code>setAllowedOrigins()</code>: 设置允许跨域请求的来源。在开发环境中，这通常是你的前端开发服务器地址（如 <code>http://localhost:3000</code>）。</li>
<li><code>setAllowedMethods()</code>: 设置允许的 HTTP 方法。</li>
<li><code>setAllowedHeaders()</code>: 设置允许的请求头。如果你的前端需要发送自定义头（如 <code>Authorization</code> for JWT），必须在这里声明。</li>
<li><code>setAllowCredentials(true)</code>: <strong>非常重要</strong>。如果你的前后端交互需要使用 Cookie 或 <code>Authorization</code> 头来进行会话管理和认证，必须将此项设为 <code>true</code>。同时，前端的 <code>axios</code> 或 <code>fetch</code> 请求也需要设置 <code>withCredentials: true</code>。</li>
<li><code>registerCorsConfiguration(&quot;/**&quot;, configuration)</code>: 将我们创建的 <code>CorsConfiguration</code> 应用到所有的 URL 路径 (<code>/**</code>) 上。你也可以为不同的路径（如 <code>/api/**</code> 和 <code>/public/**</code>）注册不同的 CORS 配置。</li>
</ul>
<p><strong>另一种配置方式：<code>WebMvcConfigurer</code></strong></p>
<p>在SpringWeb中介绍了此方法，当同时存在 <code>WebMvcConfigurer</code> 的 CORS 配置和 Spring Security 的 CORS 配置时，<strong>Spring Security 的配置会优先生效</strong>，因为它通过 <code>CorsFilter</code> 在过滤器链的更早阶段处理了请求。因此，<strong>推荐使用 <code>CorsConfigurationSource</code> Bean 的方式，将所有安全相关的配置集中在 Spring Security 中</strong>。</p>
<hr>
<h3 id="4-3-Session-管理"><a href="#4-3-Session-管理" class="headerlink" title="4.3 Session 管理"></a>4.3 Session 管理</h3><p>在传统的有状态（Stateful）Web 应用中，Session 是服务器用来跟踪和维持单个用户会话状态的核心机制。当用户首次登录成功后，服务器会创建一个 Session 对象，并生成一个唯一的 Session ID。这个 Session ID 通常通过 Cookie（名为 <code>JSESSIONID</code>）发送给浏览器。在后续的请求中，浏览器会自动携带这个 Cookie，服务器通过 Session ID 就能找到对应的 Session 对象，从而识别用户身份。</p>
<p>Spring Security 对 Session 的创建、使用和销毁提供了全面的控制和保护。</p>
<h4 id="4-3-1-Session-创建策略-SessionCreationPolicy"><a href="#4-3-1-Session-创建策略-SessionCreationPolicy" class="headerlink" title="4.3.1 Session 创建策略 (SessionCreationPolicy)"></a>4.3.1 Session 创建策略 (SessionCreationPolicy)</h4><p>Spring Security 允许我们精细地控制何时创建 <code>HttpSession</code>。这对于构建不同类型的应用（如有状态 Web 应用和无状态 REST API）至关重要。</p>
<p>通过 <code>.sessionManagement().sessionCreationPolicy()</code> 进行配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .sessionManagement(session -&gt; session</span><br><span class="line">            .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED) <span class="comment">// 设置策略</span></span><br><span class="line">        );</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>四种策略</strong>:</p>
<ol>
<li><strong><code>SessionCreationPolicy.IF_REQUIRED</code> (默认值)</strong><ul>
<li><strong>含义</strong>: 只有在需要时，Spring Security 才会创建 <code>HttpSession</code>。</li>
<li><strong>“需要时”</strong> 指的是：当需要存储与认证相关的信息时，比如 <code>SecurityContext</code>。典型的场景是用户通过表单登录成功后，需要将 <code>Authentication</code> 对象保存起来以维持登录状态。</li>
<li><strong>适用场景</strong>: 绝大多数传统的、有状态的 Web 应用。</li>
</ul>
</li>
<li><strong><code>SessionCreationPolicy.STATELESS</code></strong><ul>
<li><strong>含义</strong>: Spring Security <strong>永远不会</strong>创建 <code>HttpSession</code>，也<strong>不会</strong>使用它来获取 <code>SecurityContext</code>。</li>
<li><strong>适用场景</strong>: <strong>无状态的 REST API</strong>。这类 API 的每次请求都应该是自包含的，认证信息通常通过其他方式携带，比如放在 <code>Authorization</code> Header 中的 JWT (JSON Web Token)。这使得 API 服务可以轻松地水平扩展，因为服务器不需要在内存中维护任何用户的 Session 信息。</li>
</ul>
</li>
<li><strong><code>SessionCreationPolicy.NEVER</code></strong><ul>
<li><strong>含义</strong>: Spring Security <strong>永远不会</strong>自己创建 <code>HttpSession</code>，但是如果应用的其他部分（例如，非安全相关的代码）已经创建了一个 Session，Spring Security <strong>会使用它</strong>。</li>
<li><strong>适用场景</strong>: 当你确定应用本身需要 Session，但希望 Spring Security 自身不主动触发 Session 创建时使用。比较少见。</li>
</ul>
</li>
<li><strong><code>SessionCreationPolicy.ALWAYS</code></strong><ul>
<li><strong>含义</strong>: Spring Security <strong>总是</strong>会创建一个 <code>HttpSession</code>，即使用是匿名用户。</li>
<li><strong>适用场景</strong>: 极少使用。可能用于需要为匿名用户也跟踪某些会话状态的特殊场景。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-3-2-Session-并发控制-Concurrent-Session-Control"><a href="#4-3-2-Session-并发控制-Concurrent-Session-Control" class="headerlink" title="4.3.2 Session 并发控制 (Concurrent Session Control)"></a>4.3.2 Session 并发控制 (Concurrent Session Control)</h4><p>这是一个常见的业务需求：<strong>限制同一个用户账户在同一时间只能在一个地方（或指定数量的地方）登录</strong>。例如，防止账户共享，或者在用户登录新设备时自动踢掉旧设备的登录。</p>
<p><strong>配置步骤</strong>:</p>
<h5 id="1-添加-Listener"><a href="#1-添加-Listener" class="headerlink" title="1. 添加 Listener"></a>1. 添加 Listener</h5><p>Spring Security 需要监听 Session 的销毁事件，以便在 Session 过期或被无效化时，能够清理其在并发控制注册表中的记录。为此，需要在主应用类或配置类中注册一个 <code>HttpSessionEventPublisher</code> 的 Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.session.HttpSessionEventPublisher;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在你的 @Configuration 类中</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> HttpSessionEventPublisher <span class="title function_">httpSessionEventPublisher</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpSessionEventPublisher</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>在 Spring Boot 2.x 中，这个 Bean 似乎是自动配置的，但在 Spring Boot 3.x 及 Spring Framework 6.x 中，官方文档建议显式声明它以确保功能正常。</em></p>
<hr>
<h5 id="2-配置并发控制"><a href="#2-配置并发控制" class="headerlink" title="2. 配置并发控制"></a>2. 配置并发控制</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .sessionManagement(session -&gt; session</span><br><span class="line">            .maximumSessions(<span class="number">1</span>) <span class="comment">// 1. 设置最大并发会话数量为 1</span></span><br><span class="line">            .maxSessionsPreventsLogin(<span class="literal">true</span>) <span class="comment">// 2. (策略二选一) 当达到最大会话数时，阻止新登录</span></span><br><span class="line">            <span class="comment">// .expiredUrl(&quot;/login?expired&quot;) // (可选) 当会话因并发登录被踢掉时重定向的 URL</span></span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.maximumSessions(int maxSessions)</code>: 设置允许的并发会话最大数量。设置为 <code>1</code> 表示只允许单点登录。</li>
<li>之后，你需要选择一个<strong>并发处理策略</strong>（二选一）：<ul>
<li><strong><code>.maxSessionsPreventsLogin(true)</code></strong>: <strong>阻止新登录</strong>。如果用户 “user” 已经在一个地方登录，当他尝试在另一个地方用相同的账户登录时，新的登录请求将被拒绝。旧的登录会话保持有效。</li>
<li><strong><code>.maxSessionsPreventsLogin(false)</code> (默认行为)</strong>: <strong>踢掉旧登录</strong>。如果用户 “user” 已经登录，当他从新设备登录时，新登录会成功，而<strong>旧的登录会话将被标记为无效</strong>。当旧设备上的用户下次发起请求时，他会被强制下线，并可以被重定向到 <code>.expiredUrl()</code> 指定的页面。这是更常见的“互踢”策略。</li>
</ul>
</li>
</ul>
<p><strong>注意</strong>: 要使并发控制生效，<code>UserDetails</code> 的 <code>equals()</code> 和 <code>hashCode()</code> 方法必须被正确实现（通常基于 <code>username</code>），以确保 Spring Security 能够正确识别是“同一个用户”。</p>
<hr>
<h4 id="4-3-3-Session-Fixation-会话固定-攻击防护"><a href="#4-3-3-Session-Fixation-会话固定-攻击防护" class="headerlink" title="4.3.3 Session Fixation (会话固定) 攻击防护"></a>4.3.3 Session Fixation (会话固定) 攻击防护</h4><h5 id="1-什么是会话固定攻击？"><a href="#1-什么是会话固定攻击？" class="headerlink" title="1. 什么是会话固定攻击？"></a>1. 什么是会话固定攻击？</h5><p>这是一种攻击者试图将自己的 Session ID 强加给受害者的攻击方式。</p>
<ul>
<li><strong>攻击流程</strong>:<ol>
<li>攻击者 Mallory 访问了目标网站 <code>example.com</code>，服务器为她创建了一个 Session 并返回了 Session ID (例如，<code>JSESSIONID=111</code>)。</li>
<li>Mallory 通过某种方式（如钓鱼链接、网络劫持）诱导受害者 Bob 使用这个 Session ID (<code>111</code>) 去访问 <code>example.com</code>。例如，<code>http://example.com?JSESSIONID=111</code>。</li>
<li>Bob 没有察觉，点击链接后，输入了自己的用户名和密码成功登录。</li>
<li><strong>问题来了</strong>：服务器在 Bob 登录后，<strong>没有改变 Session ID</strong>，而是直接将 Bob 的认证信息关联到了这个已知的 Session ID (<code>111</code>) 上。</li>
<li>现在，攻击者 Mallory 就可以使用她预先知道的 Session ID (<code>111</code>) 来访问网站，服务器会认为她就是已经登录的 Bob，从而劫持了 Bob 的会话。</li>
</ol>
</li>
</ul>
<hr>
<h5 id="2-Spring-Security-的防护机制"><a href="#2-Spring-Security-的防护机制" class="headerlink" title="2. Spring Security 的防护机制"></a>2. Spring Security 的防护机制</h5><p>Spring Security <strong>默认开启了强大的会话固定攻击防护</strong>，你几乎不需要做任何额外配置。</p>
<ul>
<li><strong>核心策略</strong>: <strong>在用户认证成功后，迁移 Session</strong>。<ul>
<li>当用户成功登录时，Spring Security 会使当前的（可能是攻击者注入的）Session 无效化。</li>
<li>然后，它会创建一个<strong>全新的 Session</strong>，并生成一个<strong>全新的、不可预测的 Session ID</strong>。</li>
<li>最后，它会将旧 Session 中的所有属性复制到新 Session 中，并将新的 Session ID 返回给用户的浏览器。</li>
</ul>
</li>
</ul>
<p>这样一来，即使攻击者成功地将自己的 Session ID 固定给了受害者，一旦受害者登录，这个旧的 Session ID 就会失效，攻击者无法再利用它来劫持会话。</p>
<p><strong>配置</strong>:</p>
<p>这个行为由 <code>.sessionManagement().sessionFixation()</code> 控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.sessionManagement(session -&gt; session</span><br><span class="line">    .sessionFixation(fixation -&gt; fixation</span><br><span class="line">        .migrateSession() <span class="comment">// 默认策略，最推荐</span></span><br><span class="line">        <span class="comment">// .newSession()      // 创建新 Session，但不复制属性</span></span><br><span class="line">        <span class="comment">// .none()           // 关闭防护 (极不推荐!)</span></span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>migrateSession()</code>: <strong>默认值，也是最安全的选项</strong>。使旧 Session 失效，创建新 Session，并复制旧 Session 的属性。</li>
<li><code>newSession()</code>: 使旧 Session 失效，创建新 Session，但<strong>不复制</strong>属性。</li>
<li><code>none()</code>: <strong>禁用</strong>会话固定攻击防护。<strong>除非你有非常特殊且明确的理由，否则永远不要使用这个选项。</strong></li>
</ul>
<hr>
<h3 id="4-4-注销-Logout-功能"><a href="#4-4-注销-Logout-功能" class="headerlink" title="4.4 注销 (Logout) 功能"></a>4.4 注销 (Logout) 功能</h3><p>注销 (Logout) 是一个允许用户主动终止其认证会话的过程。一个设计良好的注销功能不仅能提升用户体验，更是保障账户安全的关键步骤。Spring Security 提供了非常灵活且强大的注Gitg能来配置和自定义注销行为。</p>
<h4 id="4-4-1-默认的注销功能"><a href="#4-4-1-默认的注销功能" class="headerlink" title="4.4.1 默认的注销功能"></a>4.4.1 默认的注销功能</h4><p>只需在 <code>SecurityFilterChain</code> 配置中加入 <code>.logout()</code>，即可启用一套功能完备的默认注销机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ... 其他配置</span></span><br><span class="line">        .logout(Customizer.withDefaults()); <span class="comment">// 使用默认配置启用注销功能</span></span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，这会提供以下功能：</p>
<ol>
<li><strong>监听注销 URL</strong>: 默认会拦截对 <code>/logout</code> 的 <strong>GET 请求</strong>。当用户访问这个 URL 时，注销流程就会被触发。（注意：出于安全考虑，推荐使用 POST 请求进行注销，下面会讲如何配置）。</li>
<li><strong>执行注销操作</strong>: 当注销流程被触发时，<code>LogoutFilter</code> 会执行一系列清理操作：<ul>
<li><strong>使 <code>HttpSession</code> 无效化 (Invalidate)</strong>：这是最关键的一步，清除了服务器端的所有会-话信息。</li>
<li><strong>清空 <code>SecurityContextHolder</code></strong>: 清除当前线程的安全上下文。</li>
<li><strong>清除 “记住我” (Remember-Me) Cookie</strong>: 如果用户之前使用了 “记住我” 功能，相关的持久化认证信息也会被删除。</li>
</ul>
</li>
<li><strong>重定向</strong>: 注销成功后，默认会将用户重定向到 <code>/login?logout</code> 页面。</li>
</ol>
<p><strong>前端实现</strong>:</p>
<p>你只需要在页面上提供一个指向 <code>/logout</code> 的链接或按钮即可。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 如果使用 GET (不推荐，但默认支持) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/logout&#125;&quot;</span>&gt;</span>Logout<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果使用 POST (推荐) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/logout&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Logout<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>为什么推荐使用 POST？</strong></p>
<p>使用 GET 请求进行注销存在 CSRF 风险。攻击者可以在恶意网站上放置一个 <code>&lt;img src=&quot;http://your-site.com/logout&quot;&gt;</code>，诱导已登录的用户访问，从而在用户不知情的情况下将其注销。虽然注销操作的危害性通常小于转账等操作，但这仍是一种不良实践。要求使用 POST 并配合 CSRF Token 可以完全杜绝这种风险。</p>
<hr>
<h4 id="4-4-2-自定义注销配置"><a href="#4-4-2-自定义注销配置" class="headerlink" title="4.4.2 自定义注销配置"></a>4.4.2 自定义注销配置</h4><p>Spring Security 允许我们通过 Lambda 表达式对注销的各个方面进行详细配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        .logout(logout -&gt; logout</span><br><span class="line">            <span class="comment">// 1. 配置触发注销的 URL</span></span><br><span class="line">            .logoutUrl(<span class="string">&quot;/perform_logout&quot;</span>) <span class="comment">// 默认为 /logout</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 指定注销请求必须是 POST (推荐)</span></span><br><span class="line">            .logoutRequestMatcher(<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/perform_logout&quot;</span>, <span class="string">&quot;POST&quot;</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 注销成功后的重定向地址</span></span><br><span class="line">            .logoutSuccessUrl(<span class="string">&quot;/login?logout_success&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 注销时清除的 Cookie</span></span><br><span class="line">            .deleteCookies(<span class="string">&quot;JSESSIONID&quot;</span>, <span class="string">&quot;remember-me&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5. 是否在注销时使 HttpSession 无效</span></span><br><span class="line">            .invalidateHttpSession(<span class="literal">true</span>) <span class="comment">// 默认为 true</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 6. 是否在注销时清除 SecurityContextHolder</span></span><br><span class="line">            .clearAuthentication(<span class="literal">true</span>) <span class="comment">// 默认为 true</span></span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置项详解</strong>:</p>
<ul>
<li><code>.logoutUrl(&quot;/perform_logout&quot;)</code>: 更改 <code>LogoutFilter</code> 监听的 URL。</li>
<li><code>.logoutRequestMatcher(...)</code>: 提供一个 <code>RequestMatcher</code> 来更精细地定义触发注销的请求。这里我们明确要求必须是 <code>POST</code> 方法访问 <code>/perform_logout</code>。这是替代 <code>.logoutUrl()</code> 的更现代、更灵活的方式。</li>
<li><code>.logoutSuccessUrl(&quot;/login?logout_success&quot;)</code>: 指定注销成功后重定向到哪个页面。</li>
<li><code>.deleteCookies(&quot;cookie1&quot;, &quot;cookie2&quot;, ...)</code>: 告诉 Spring Security 在注销时除了默认的 “记住我” Cookie 外，还应清除哪些指定的 Cookie。这对于清理应用自定义的 Cookie 非常有用。</li>
<li><code>.invalidateHttpSession(true)</code>: 确保 <code>HttpSession</code> 被销毁。通常应保持为 <code>true</code>。</li>
<li><code>.clearAuthentication(true)</code>: 确保 <code>SecurityContextHolder</code> 被清空。通常也应保持为 <code>true</code>。</li>
</ul>
<h4 id="4-4-3-自定义注销成功后的处理器"><a href="#4-4-3-自定义注销成功后的处理器" class="headerlink" title="4.4.3 自定义注销成功后的处理器"></a>4.4.3 自定义注销成功后的处理器</h4><p><code>.logoutSuccessUrl()</code> 只能实现简单的重定向。对于更复杂的场景，例如在前后端分离的应用中，注销后需要返回一段 JSON 数据，而不是重定向页面，这时我们就需要自定义 <code>LogoutSuccessHandler</code>。</p>
<p><strong>步骤 1: 创建 <code>LogoutSuccessHandler</code> 的实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 注册为 Spring Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogoutSuccessHandler</span> <span class="keyword">implements</span> <span class="title class_">LogoutSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLogoutSuccess</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                                HttpServletResponse response, </span></span><br><span class="line"><span class="params">                                Authentication authentication)</span> </span><br><span class="line">                                <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        </span><br><span class="line">        response.setStatus(HttpStatus.OK.value());</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonResponse</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;code\&quot;: 200, \&quot;message\&quot;: \&quot;Logout successful\&quot;&#125;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        response.getWriter().write(jsonResponse);</span><br><span class="line">        response.getWriter().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ul>
<li><code>onLogoutSuccess</code> 方法会在注销流程成功执行后被调用。</li>
<li><code>authentication</code> 参数包含了注销前用户的认证信息，你可以在这里获取用户名等信息进行日志记录。</li>
<li>我们设置了响应的状态码为 200 OK，<code>Content-Type</code> 为 <code>application/json</code>。</li>
<li>然后向响应体中写入自定义的 JSON 字符串。</li>
<li><strong>注意</strong>: 在自定义 Handler 中，我们完全控制了响应。Spring Security 不会再执行任何默认的重定向操作。</li>
</ul>
<p><strong>步骤 2: 在安全配置中使用自定义的 Handler</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyLogoutSuccessHandler myLogoutSuccessHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        .logout(logout -&gt; logout</span><br><span class="line">            .logoutUrl(<span class="string">&quot;/api/logout&quot;</span>)</span><br><span class="line">            <span class="comment">// 使用 .logoutSuccessHandler() 替代 .logoutSuccessUrl()</span></span><br><span class="line">            .logoutSuccessHandler(myLogoutSuccessHandler) </span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>.logoutSuccessHandler()</code> 方法，我们将自定义的处理器注入到了注销配置中。现在，当用户访问 <code>/api/logout</code> 时，成功注销后将收到我们定义的 JSON 响应，而不是页面跳转。</p>
<h4 id="4-4-4-添加自定义的注销处理器-LogoutHandler"><a href="#4-4-4-添加自定义的注销处理器-LogoutHandler" class="headerlink" title="4.4.4 添加自定义的注销处理器 (LogoutHandler)"></a>4.4.4 添加自定义的注销处理器 (<code>LogoutHandler</code>)</h4><p><code>LogoutSuccessHandler</code> 是在<strong>注销成功后</strong>执行的。如果你需要在<strong>注销过程中</strong>执行一些自定义的清理逻辑（例如，记录用户登出日志、调用第三方服务使 Token 失效等），你应该实现 <code>LogoutHandler</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogoutHandler</span> <span class="keyword">implements</span> <span class="title class_">LogoutHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (authentication != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authentication.getName();</span><br><span class="line">            <span class="comment">// 在这里执行自定义逻辑，比如记录日志</span></span><br><span class="line">            System.out.println(<span class="string">&quot;User &quot;</span> + username + <span class="string">&quot; is logging out.&quot;</span>);</span><br><span class="line">            <span class="comment">// 或者调用服务使 JWT Token 黑名单</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在配置中使用</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyLogoutHandler myLogoutHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">.logout(logout -&gt; logout</span><br><span class="line">    .addLogoutHandler(myLogoutHandler) <span class="comment">// 添加自定义 LogoutHandler</span></span><br><span class="line">    .logoutSuccessUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>你可以通过 <code>.addLogoutHandler()</code> 添加多个 <code>LogoutHandler</code>。它们会与 Spring Security 内置的处理器（如 <code>CookieClearingLogoutHandler</code>, <code>SecurityContextLogoutHandler</code>）一起被依次调用。</p>
<hr>
<h3 id="4-5-异常处理"><a href="#4-5-异常处理" class="headerlink" title="4.5 异常处理"></a>4.5 异常处理</h3><p>在 Spring Security 的过滤器链中，当一个安全相关的异常被抛出时，<code>ExceptionTranslationFilter</code> 会捕获它，并根据异常的类型，将处理工作委托给两个核心的策略接口：<code>AuthenticationEntryPoint</code> 和 <code>AccessDeniedHandler</code>。</p>
<p>理解这两者的区别是掌握 Spring Security 异常处理的关键。</p>
<h4 id="4-5-1-AuthenticationEntryPoint-未认证用户的“入口点”"><a href="#4-5-1-AuthenticationEntryPoint-未认证用户的“入口点”" class="headerlink" title="4.5.1 AuthenticationEntryPoint: 未认证用户的“入口点”"></a>4.5.1 <code>AuthenticationEntryPoint</code>: 未认证用户的“入口点”</h4><ul>
<li><p><strong>是什么？</strong><br><code>AuthenticationEntryPoint</code> 是一个接口，它定义了当一个**未认证（匿名）<strong>的用户尝试访问一个需要认证的受保护资源时，应该如何</strong>“开始”**认证流程。它的名字“入口点”非常形象，它就是引导匿名用户进入认证流程的起点。</p>
</li>
<li><p><strong>何时触发？</strong><br>当 <code>ExceptionTranslationFilter</code> 捕获到一个 <code>AuthenticationException</code> 时，就会调用 <code>AuthenticationEntryPoint</code>。这通常发生在：</p>
<ol>
<li>一个匿名用户直接访问了一个受保护的 URL（例如 <code>http://.../dashboard</code>）。</li>
<li>用户提交了无效的凭证（如错误的密码），导致认证失败，抛出了 <code>BadCredentialsException</code>（它是 <code>AuthenticationException</code> 的子类）。</li>
</ol>
</li>
<li><p><strong>默认行为</strong><br>Spring Security 根据你的配置，提供了不同的默认实现：</p>
<ul>
<li>如果配置了 <strong>Form Login</strong> (<code>.formLogin()</code>)，默认的 <code>LoginUrlAuthenticationEntryPoint</code> 会将用户<strong>重定向到登录页面</strong>。</li>
<li>如果配置了 <strong>HTTP Basic</strong> (<code>.httpBasic()</code>)，默认的 <code>BasicAuthenticationEntryPoint</code> 会向浏览器返回一个 <strong><code>401 Unauthorized</code></strong> 状态码，并带上 <code>WWW-Authenticate</code> 头，触发浏览器的原生登录对话框。</li>
</ul>
</li>
<li><p><strong>自定义实现（REST API 场景）</strong><br>在前后端分离的 REST API 中，我们不希望重定向到 HTML 页面，而是希望返回一个结构化的 JSON 响应，并附带 <code>401</code> 状态码。</p>
<p><strong>步骤 1: 创建 <code>AuthenticationEntryPoint</code> 的实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthenticationEntryPoint</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationEntryPoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commence</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                         HttpServletResponse response, </span></span><br><span class="line"><span class="params">                         AuthenticationException authException)</span> </span><br><span class="line">                         <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        </span><br><span class="line">        response.setStatus(HttpStatus.UNAUTHORIZED.value()); <span class="comment">// 设置状态码 401</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回一个提示需要登录的 JSON</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonResponse</span> <span class="operator">=</span> String.format(</span><br><span class="line">            <span class="string">&quot;&#123;\&quot;code\&quot;: %d, \&quot;message\&quot;: \&quot;Sorry, you must be authenticated to access this resource.\&quot;, \&quot;error\&quot;: \&quot;%s\&quot;&#125;&quot;</span>,</span><br><span class="line">            HttpStatus.UNAUTHORIZED.value(),</span><br><span class="line">            authException.getMessage()</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        response.getWriter().write(jsonResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 在安全配置中应用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAuthenticationEntryPoint myAuthenticationEntryPoint;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ... 其他配置</span></span><br><span class="line">        .exceptionHandling(exceptions -&gt; exceptions</span><br><span class="line">            .authenticationEntryPoint(myAuthenticationEntryPoint)</span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-5-2-AccessDeniedHandler-已认证但无权限用户的“处理器”"><a href="#4-5-2-AccessDeniedHandler-已认证但无权限用户的“处理器”" class="headerlink" title="4.5.2 AccessDeniedHandler: 已认证但无权限用户的“处理器”"></a>4.5.2 <code>AccessDeniedHandler</code>: 已认证但无权限用户的“处理器”</h4><ul>
<li><p><strong>是什么？</strong><br><code>AccessDeniedHandler</code> 是一个接口，它定义了当一个<strong>已经认证</strong>的用户尝试访问一个他<strong>没有足够权限</strong>的资源时，应该如何处理。</p>
</li>
<li><p><strong>何时触发？</strong><br>当 <code>ExceptionTranslationFilter</code> 捕获到一个 <code>AccessDeniedException</code> 时，就会调用 <code>AccessDeniedHandler</code>。这个异常通常由授权决策者（如 <code>AuthorizationManager</code> 或 <code>AccessDecisionManager</code>）在检查权限（例如 <code>hasRole(&#39;ADMIN&#39;)</code>）失败后抛出。</p>
</li>
<li><p><strong>默认行为</strong><br>默认的 <code>AccessDeniedHandlerImpl</code> 会向浏览器返回一个 <strong><code>403 Forbidden</code></strong> 的错误页面。这通常是一个非常简陋的、由 Web 服务器提供的页面。</p>
</li>
<li><p><strong>自定义实现（REST API 场景）</strong><br>同样，在 REST API 中，我们希望返回一个 <code>403</code> 状态码和 JSON 错误信息，而不是一个 HTML 页面。</p>
<p><strong>步骤 1: 创建 <code>AccessDeniedHandler</code> 的实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title class_">AccessDeniedHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                       HttpServletResponse response, </span></span><br><span class="line"><span class="params">                       AccessDeniedException accessDeniedException)</span> </span><br><span class="line">                       <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">                       </span><br><span class="line">        response.setStatus(HttpStatus.FORBIDDEN.value()); <span class="comment">// 设置状态码 403</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonResponse</span> <span class="operator">=</span> String.format(</span><br><span class="line">            <span class="string">&quot;&#123;\&quot;code\&quot;: %d, \&quot;message\&quot;: \&quot;Access Denied. You do not have the required permissions.\&quot;, \&quot;error\&quot;: \&quot;%s\&quot;&#125;&quot;</span>,</span><br><span class="line">            HttpStatus.FORBIDDEN.value(),</span><br><span class="line">            accessDeniedException.getMessage()</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        response.getWriter().write(jsonResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 在安全配置中应用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAccessDeniedHandler myAccessDeniedHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ... 其他配置</span></span><br><span class="line">        .exceptionHandling(exceptions -&gt; exceptions</span><br><span class="line">            <span class="comment">// .authenticationEntryPoint(...) // 可以同时配置</span></span><br><span class="line">            .accessDeniedHandler(myAccessDeniedHandler)</span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-5-3-总结与对比"><a href="#4-5-3-总结与对比" class="headerlink" title="4.5.3 总结与对比"></a>4.5.3 总结与对比</h4><p>将这两个组件放在一起配置，就可以完全控制你的 API 的安全异常响应：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAuthenticationEntryPoint myAuthenticationEntryPoint;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAccessDeniedHandler myAccessDeniedHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ... authorizeHttpRequests, csrf, cors 等配置</span></span><br><span class="line">        .exceptionHandling(exceptions -&gt; exceptions</span><br><span class="line">            .authenticationEntryPoint(myAuthenticationEntryPoint) <span class="comment">// 处理未认证</span></span><br><span class="line">            .accessDeniedHandler(myAccessDeniedHandler)           <span class="comment">// 处理未授权</span></span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>决策流程图</strong>:</p>
<pre><code class="highlight mermaid">flowchart TD
    A[请求进入&lt;br&gt;ExceptionTranslationFilter] --&gt; B&#123;安全异常被抛出?&#125;
    B --&gt;|是| C&#123;是 AuthenticationException?&lt;br&gt;用户未登录&#125;
    B --&gt;|否| G[继续处理请求]
    C --&gt;|是| D[调用 AuthenticationEntryPoint]
    C --&gt;|否| E&#123;是 AccessDeniedException?&lt;br&gt;用户已登录但无权限&#125;
    D --&gt; F[通常返回 401 + JSON&lt;br&gt;或重定向到 /login]
    E --&gt;|是| H[调用 AccessDeniedHandler]
    H --&gt; I[通常返回 403 + JSON]</code></pre>

<table>
<thead>
<tr>
<th>特性</th>
<th><code>AuthenticationEntryPoint</code></th>
<th><code>AccessDeniedHandler</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>处理的用户状态</strong></td>
<td><strong>未认证 (Anonymous)</strong></td>
<td><strong>已认证 (Authenticated)</strong></td>
</tr>
<tr>
<td><strong>触发的异常</strong></td>
<td><code>AuthenticationException</code> 及其子类</td>
<td><code>AccessDeniedException</code></td>
</tr>
<tr>
<td><strong>核心问题</strong></td>
<td><strong>“你是谁？”</strong> - 用户身份未知或无效。</td>
<td><strong>“你能做什么？”</strong> - 用户身份已知，但权限不足。</td>
</tr>
<tr>
<td><strong>典型 HTTP 状态码</strong></td>
<td><strong>401 Unauthorized</strong> (需要认证)</td>
<td><strong>403 Forbidden</strong> (禁止访问)</td>
</tr>
<tr>
<td><strong>典型行为 (Web)</strong></td>
<td>重定向到登录页</td>
<td>显示“禁止访问”错误页</td>
</tr>
<tr>
<td><strong>典型行为 (API)</strong></td>
<td>返回 JSON，提示客户端需要登录并提供凭证。</td>
<td>返回 JSON，提示客户端当前用户没有权限执行该操作。</td>
</tr>
</tbody></table>
<hr>
<h2 id="5-现代化应用集成：JWT-与-OAuth2"><a href="#5-现代化应用集成：JWT-与-OAuth2" class="headerlink" title="5. 现代化应用集成：JWT 与 OAuth2"></a>5. 现代化应用集成：JWT 与 OAuth2</h2><h3 id="5-1-无状态认证与-JWT-JSON-Web-Token"><a href="#5-1-无状态认证与-JWT-JSON-Web-Token" class="headerlink" title="5.1 无状态认证与 JWT (JSON Web Token)"></a>5.1 无状态认证与 JWT (JSON Web Token)</h3><p>传统的基于 Session 的认证机制在服务器端存储用户的会札信息，这被称为<strong>有状态 (Stateful)</strong> 认证。然而，随着分布式系统、微服务和前后端分离架构的兴起，有状态认证的弊端日益凸显，<strong>无状态 (Stateless)</strong> 认证应运而生，而 JWT 则是实现无状态认证最主流的技术方案。</p>
<h4 id="5-1-1-为什么需要无状态认证？"><a href="#5-1-1-为什么需要无状态认证？" class="headerlink" title="5.1.1 为什么需要无状态认证？"></a>5.1.1 为什么需要无状态认证？</h4><ol>
<li><strong>可伸缩性 (Scalability) 问题</strong>:<ul>
<li><strong>有状态</strong>: 用户的 Session 信息存储在某一台服务器的内存中。如果系统需要水平扩展（增加更多服务器实例），请求可能会被负载均衡器分发到没有该用户 Session 的服务器上，导致认证失败。解决方案（如 Session 复制或集中式 Session 存储）会增加系统的复杂性和开销。</li>
<li><strong>无状态</strong>: 服务器不存储任何会话信息。每个请求都包含了所有必要的认证信息（如 JWT）。任何一台服务器收到请求后，都可以独立地对其进行验证，从而实现无缝的水平扩展。</li>
</ul>
</li>
<li><strong>微服务架构的挑战</strong>:<ul>
<li>在一个复杂的微服务系统中，一个来自客户端的请求可能需要经过多个微服务（如 API 网关 -&gt; 订单服务 -&gt; 库存服务）。如果使用 Session，就需要建立一套复杂的机制来在所有服务间共享 Session 状态，这几乎是不可行的。</li>
<li>使用无状态的 Token，API 网关在验证 Token 后，可以将解析出的用户信息传递给下游服务，或者下游服务自己也可以独立验证 Token，服务之间解耦，架构更清晰。</li>
</ul>
</li>
<li><strong>多客户端支持 (SPA, 移动应用)</strong>:<ul>
<li>传统的 Session 机制严重依赖于浏览器的 Cookie (<code>JSESSIONID</code>)。</li>
<li>对于单页面应用 (SPA)、移动 App (iOS&#x2F;Android)、桌面应用等非浏览器客户端，处理 Cookie 并非它们的标准或最佳实践。</li>
<li>使用 Token（通常放在 <code>Authorization</code> 请求头中）是一种跨平台的、标准化的 API 认证方式，所有类型的客户端都能轻松支持。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-1-2-JWT-结构详解：Header-Payload-Signature"><a href="#5-1-2-JWT-结构详解：Header-Payload-Signature" class="headerlink" title="5.1.2 JWT 结构详解：Header, Payload, Signature"></a>5.1.2 JWT 结构详解：Header, Payload, Signature</h4><p>JWT 本质上是一个紧凑的、自包含的、URL 安全的字符串，它由三部分组成，每部分都经过 Base64Url 编码，并用点 (<code>.</code>) 连接。</p>
<p><code>xxxxx.yyyyy.zzzzz</code><br>(Header).(Payload).(Signature)</p>
<p><strong>把 JWT 想象成一张带防伪标识的身份证：</strong></p>
<ul>
<li><strong>Header (头部)</strong>: 身份证的“元信息”，说明了这张卡的类型和防伪技术。</li>
<li><strong>Payload (载荷)</strong>: 身份证的“个人信息”，包含了姓名、性别、出生日期等。</li>
<li><strong>Signature (签名)</strong>: 身份证的“防伪镭射标”，用来验证这张卡是不是伪造的。</li>
</ul>
<h5 id="1-Header-头部"><a href="#1-Header-头部" class="headerlink" title="1. Header (头部)"></a>1. Header (头部)</h5><p>描述 JWT 的元数据，通常包含两部分：</p>
<ul>
<li><code>typ</code> (Type): 令牌的类型，固定为 “JWT”。</li>
<li><code>alg</code> (Algorithm): 用于生成签名的算法，如 <code>HS256</code> (HMAC using SHA-256) 或 <code>RS256</code> (RSA using SHA-256)。</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这部分 JSON 会被 Base64Url 编码，形成 JWT 的第一部分。</p>
<hr>
<h5 id="2-Payload-载荷"><a href="#2-Payload-载荷" class="headerlink" title="2. Payload (载荷)"></a>2. Payload (载荷)</h5><p>存放实际需要传递的数据，这些数据被称为“声明 (Claims)”。声明分为三类：</p>
<ul>
<li><strong>Registered Claims (注册声明)</strong>: 官方预定义的一组声明，建议使用但非强制。<ul>
<li><code>iss</code> (Issuer): 签发者</li>
<li><code>sub</code> (Subject): 主题，通常是用户的唯一标识（如用户ID或用户名）</li>
<li><code>aud</code> (Audience): 接收方</li>
<li><code>exp</code> (Expiration Time): <strong>过期时间</strong> (时间戳)，是保证 Token 安全的关键。</li>
<li><code>nbf</code> (Not Before): 生效时间 (时间戳)</li>
<li><code>iat</code> (Issued At): 签发时间 (时间戳)</li>
</ul>
</li>
<li><strong>Public Claims (公共声明)</strong>: 由使用者自行定义，但为了避免冲突，应在 <a target="_blank" rel="noopener" href="https://www.iana.org/assignments/json-web-token/json-web-token.xhtml">IANA JSON Web Token Claims</a> 注册表中注册。</li>
<li><strong>Private Claims (私有声明)</strong>: 服务端和客户端共同约定的声明，用于传递自定义信息。这是我们最常使用的部分。<ul>
<li>例如，我们可以放入用户角色、权限列表、用户ID等。</li>
</ul>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user123&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;roles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;ROLE_USER&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ROLE_VIEWER&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1678886400</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1678890000</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>安全警告</strong>: Payload 部分只是被 Base64Url 编码，<strong>它不是加密的</strong>！任何人都可以解码并读取其中的内容。<strong>绝对不要在 Payload 中存放任何敏感信息，如密码！</strong></p>
<hr>
<h5 id="3-Signature-签名"><a href="#3-Signature-签名" class="headerlink" title="3. Signature (签名)"></a>3. Signature (签名)</h5><p>签名的作用是<strong>验证 Token 的完整性</strong>，确保它在传输过程中没有被篡改。</p>
<p>生成过程如下：</p>
<p><code>HMACSHA256(Base64UrlEncode(header) + &quot;.&quot; + Base64UrlEncode(payload), secret)</code></p>
<ul>
<li>将编码后的 Header 和 Payload 用点 (<code>.</code>) 连接起来。</li>
<li>使用 Header 中指定的签名算法 (<code>alg</code>) 和一个保存在<strong>服务器端的、绝不外泄的密钥 (secret)</strong> 对其进行加密。</li>
</ul>
<p><strong>验证过程</strong>:</p>
<p>当服务器收到一个 JWT 时，它会用相同的算法和密钥，对接收到的 Header 和 Payload 重新计算一次签名。然后，将计算出的新签名与 JWT 中附带的原始签名进行比对。</p>
<ul>
<li>如果一致，说明 Token 未被篡改且是由该服务器签发的。</li>
<li>如果不一致，说明 Token 是伪造的或已被篡改，验证失败。</li>
</ul>
<hr>
<h4 id="5-1-3-在-Spring-Security-中集成-JWT"><a href="#5-1-3-在-Spring-Security-中集成-JWT" class="headerlink" title="5.1.3 在 Spring Security 中集成 JWT"></a>5.1.3 在 Spring Security 中集成 JWT</h4><p>集成 JWT 的核心思想是：</p>
<ol>
<li><strong>禁用</strong> Spring Security 默认的 Session 管理和 CSRF 防护。</li>
<li>创建一个<strong>自定义的过滤器</strong>，在 Spring Security 的标准认证过滤器之前运行。</li>
<li>这个过滤器负责从请求中提取 JWT，验证它，如果验证通过，就构建一个 <code>Authentication</code> 对象并放入 <code>SecurityContextHolder</code>。</li>
</ol>
<p><strong>依赖引入 (以 <code>jjwt</code> 为例)</strong>:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 1: 创建 JWT 工具类</strong></p>
<p>封装 JWT 的生成和解析逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.secret&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String secret;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.expiration&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> expiration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 Authentication 对象生成 JWT</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateToken</span><span class="params">(Authentication authentication)</span> &#123;</span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> (UserDetails) authentication.getPrincipal();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">expiryDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(now.getTime() + expiration);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setSubject(userDetails.getUsername())</span><br><span class="line">                .setIssuedAt(now)</span><br><span class="line">                .setExpiration(expiryDate)</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, secret)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 JWT 中解析用户名</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsernameFromToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">                .setSigningKey(secret)</span><br><span class="line">                .parseClaimsJws(token)</span><br><span class="line">                .getBody();</span><br><span class="line">        <span class="keyword">return</span> claims.getSubject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证 JWT 是否有效</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateToken</span><span class="params">(String token, UserDetails userDetails)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> getUsernameFromToken(token);</span><br><span class="line">            <span class="keyword">return</span> (username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// MalformedJwtException, ExpiredJwtException, etc.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isTokenExpired</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">expirationDate</span> <span class="operator">=</span> Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody().getExpiration();</span><br><span class="line">        <span class="keyword">return</span> expirationDate.before(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 创建自定义过滤器</strong></p>
<p>这个过滤器继承 <code>OncePerRequestFilter</code>，确保每个请求只执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtUtil jwtUtil;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                                    HttpServletResponse response, </span></span><br><span class="line"><span class="params">                                    FilterChain filterChain)</span> </span><br><span class="line">                                    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 从请求头获取 JWT</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">header</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (header != <span class="literal">null</span> &amp;&amp; header.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            jwt = header.substring(<span class="number">7</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                username = jwtUtil.getUsernameFromToken(jwt);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// ... handle exceptions</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 如果获取到用户名，且当前 SecurityContext 中没有认证信息</span></span><br><span class="line">        <span class="keyword">if</span> (username != <span class="literal">null</span> &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> <span class="built_in">this</span>.userDetailsService.loadUserByUsername(username);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 验证 JWT 是否有效</span></span><br><span class="line">            <span class="keyword">if</span> (jwtUtil.validateToken(jwt, userDetails)) &#123;</span><br><span class="line">                <span class="comment">// 4. 构建 Authentication 对象</span></span><br><span class="line">                <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(</span><br><span class="line">                        userDetails, <span class="literal">null</span>, userDetails.getAuthorities());</span><br><span class="line">                authentication.setDetails(<span class="keyword">new</span> <span class="title class_">WebAuthenticationDetailsSource</span>().buildDetails(request));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5. 将 Authentication 对象放入 SecurityContext</span></span><br><span class="line">                SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6. 放行请求</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3: 更新 Security 配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAuthenticationFilter jwtAuthenticationFilter;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            <span class="comment">// 1. 禁用 CSRF</span></span><br><span class="line">            .csrf(csrf -&gt; csrf.disable())</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 配置会话管理为无状态</span></span><br><span class="line">            .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 配置授权规则</span></span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                .requestMatchers(<span class="string">&quot;/api/auth/**&quot;</span>).permitAll() <span class="comment">// 允许访问登录/注册</span></span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 将自定义的 JWT 过滤器添加到过滤器链中</span></span><br><span class="line">            <span class="comment">// 在 UsernamePasswordAuthenticationFilter 之前执行</span></span><br><span class="line">            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 需要 AuthenticationManager Bean 用于登录认证</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManager</span><span class="params">(AuthenticationConfiguration config)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> config.getAuthenticationManager();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，当一个请求到达时：</p>
<ul>
<li><code>/api/auth/login</code> 请求被放行，用户登录成功后，Controller 调用 <code>JwtUtil.generateToken()</code> 生成 JWT 并返回给前端。</li>
<li>前端在后续请求的 <code>Authorization</code> Header 中携带 <code>Bearer &lt;jwt&gt;</code>。</li>
<li><code>JwtAuthenticationFilter</code> 拦截请求，验证 JWT，并将用户信息放入 <code>SecurityContext</code>。</li>
<li>后续的授权逻辑（如 <code>@PreAuthorize</code>）就能正常工作了。</li>
</ul>
<hr>
<h4 id="5-1-4-实现-Token-刷新机制"><a href="#5-1-4-实现-Token-刷新机制" class="headerlink" title="5.1.4 实现 Token 刷新机制"></a>5.1.4 实现 Token 刷新机制</h4><p>短期的 Access Token 提高了安全性，但也带来了用户体验问题。<strong>Access Token + Refresh Token</strong> 模式是解决这个问题的最佳实践。</p>
<ul>
<li><strong>Access Token</strong>: 短生命周期（如 15-60 分钟），用于访问受保护资源，Payload 中可包含权限信息。</li>
<li><strong>Refresh Token</strong>: 长生命周期（如 7-30 天），<strong>只能</strong>用于获取新的 Access Token。它不包含任何权限信息，通常是一个随机生成的、无意义的字符串，并存储在数据库中，以便可以随时撤销。</li>
</ul>
<p><strong>刷新流程</strong>:</p>
<ol>
<li><strong>登录</strong>: 用户登录成功，服务器返回 <strong>Access Token</strong> 和 <strong>Refresh Token</strong>。</li>
<li><strong>访问</strong>: 客户端使用 Access Token 访问 API。</li>
<li><strong>过期</strong>: Access Token 过期，API 返回 401 Unauthorized。</li>
<li><strong>刷新</strong>: 客户端的请求拦截器捕获到 401 错误，然后向一个专门的刷新端点（如 <code>/api/auth/refresh</code>）发送 <strong>Refresh Token</strong>。</li>
<li><strong>验证与签发</strong>: 服务器验证 Refresh Token 是否有效（存在于数据库且未过期）。如果有效，则签发一个新的 Access Token（有时也会签发一个新的 Refresh Token，这称为“刷新令牌旋转”），并返回给客户端。</li>
<li><strong>重试</strong>: 客户端收到新的 Access Token 后，用它来自动重试之前失败的请求。整个过程对用户是透明的。</li>
</ol>
<p>这个机制需要在 <code>AuthController</code> 中增加一个处理 <code>/refresh</code> 的端点，并设计 Refresh Token 在数据库中的存储和校验逻辑。</p>
<hr>
<h3 id="5-2-OAuth2-与-OIDC-OpenID-Connect-核心概念"><a href="#5-2-OAuth2-与-OIDC-OpenID-Connect-核心概念" class="headerlink" title="5.2 OAuth2 与 OIDC (OpenID Connect) 核心概念"></a>5.2 OAuth2 与 OIDC (OpenID Connect) 核心概念</h3><h4 id="5-2-1-OAuth-2-0-委托授权的框架"><a href="#5-2-1-OAuth-2-0-委托授权的框架" class="headerlink" title="5.2.1 OAuth 2.0: 委托授权的框架"></a>5.2.1 OAuth 2.0: 委托授权的框架</h4><p>首先，要明确 OAuth 2.0 的核心目标：它<strong>不是一个认证 (Authentication) 协议</strong>，而是一个<strong>授权 (Authorization) 框架</strong>。</p>
<p>它的设计初衷是为了解决一个非常具体的问题：<strong>“如何在不暴露用户核心凭证（如用户名和密码）的前提下，允许第三方应用（客户端）访问用户在某个服务上受保护的资源？”</strong></p>
<p><strong>经典场景</strong>:</p>
<p>想象一下，你发现了一个很棒的第三方照片打印网站 <code>PrintPhotos.com</code>，你希望它能访问你在 <code>Google Photos</code> 上的照片来进行打印。</p>
<ul>
<li><strong>没有 OAuth 2.0 的糟糕做法</strong>: <code>PrintPhotos.com</code> 要求你输入你的 Google 用户名和密码。这是一个巨大的安全风险，因为它拿到了你的最高权限，不仅可以看你的照片，还能看你的邮件、日历等所有信息。</li>
<li><strong>有了 OAuth 2.0 的优雅做法</strong>:<ol>
<li><code>PrintPhotos.com</code> 会将你重定向到 Google 的登录和授权页面。</li>
<li>你直接向 Google 登录（你的密码绝不会给 <code>PrintPhotos.com</code>）。</li>
<li>Google 会询问你：“<code>PrintPhotos.com</code> 正在请求访问你的照片库，你是否同意？”</li>
<li>你点击“同意”后，Google 会给 <code>PrintPhotos.com</code> 一个临时的、有特定权限（只能访问照片）的“令牌 (Token)”。</li>
<li><code>PrintPhotos.com</code> 使用这个令牌去访问 <code>Google Photos</code> API，成功获取你的照片。</li>
</ol>
</li>
</ul>
<p>在这个过程中，<code>PrintPhotos.com</code> 从未接触到你的密码，并且它获得的授权是<strong>有限的、可撤销的</strong>。这就是 OAuth 2.0 的核心思想——<strong>委托授权</strong>。</p>
<hr>
<h4 id="5-2-2-OAuth-2-0-的四大核心角色"><a href="#5-2-2-OAuth-2-0-的四大核心角色" class="headerlink" title="5.2.2 OAuth 2.0 的四大核心角色"></a>5.2.2 OAuth 2.0 的四大核心角色</h4><p>OAuth 2.0 协议中定义了四个关键角色：</p>
<ol>
<li><strong>资源所有者 (Resource Owner)</strong><ul>
<li><strong>定义</strong>: 能够授予对受保护资源访问权限的实体。通常就是<strong>最终用户</strong>。</li>
<li><strong>例子</strong>: 在上面的场景中，<strong>你</strong>就是资源所有者，因为照片是你的。</li>
</ul>
</li>
<li><strong>客户端 (Client)</strong><ul>
<li><strong>定义</strong>: 代表资源所有者，并经其授权，去请求访问受保护资源的应用程序。</li>
<li><strong>例子</strong>: <code>PrintPhotos.com</code> 网站。</li>
<li><strong>关键属性</strong>: 每个客户端在授权服务器上注册时，都会获得一个 <code>client_id</code> 和一个 <code>client_secret</code>（对于保密客户端），用于表明自己的身份。</li>
</ul>
</li>
<li><strong>授权服务器 (Authorization Server)</strong><ul>
<li><strong>定义</strong>: <strong>整个流程的核心</strong>。负责验证资源所有者的身份，并根据其授权，向客户端颁发访问令牌 (Access Token)。</li>
<li><strong>例子</strong>: Google 的认证和授权服务 (<code>accounts.google.com</code>)。</li>
<li>它就像一个**“令牌颁发机构”**。</li>
</ul>
</li>
<li><strong>资源服务器 (Resource Server)</strong><ul>
<li><strong>定义</strong>: 托管受保护资源的服务器。它只认令牌，不认人。它能接受并验证访问令牌，如果令牌有效，就允许客户端访问资源。</li>
<li><strong>例子</strong>: 存储你照片的 <code>Google Photos</code> API 服务器 (<code>photos.googleapis.com</code>)。</li>
</ul>
</li>
</ol>
<p><strong>流程概览</strong>:</p>
<p><code>资源所有者</code> 告诉 <code>授权服务器</code>：“我同意让这个 <code>客户端</code> 访问我在 <code>资源服务器</code> 上的某些数据”。然后 <code>授权服务器</code> 给了 <code>客户端</code> 一个令牌，<code>客户端</code> 拿着这个令牌去找 <code>资源服务器</code> 要数据。</p>
<hr>
<h4 id="5-2-3-四种核心授权模式-Grant-Types"><a href="#5-2-3-四种核心授权模式-Grant-Types" class="headerlink" title="5.2.3 四种核心授权模式 (Grant Types)"></a>5.2.3 四种核心授权模式 (Grant Types)</h4><p>OAuth 2.0 定义了多种获取访问令牌的流程（称为“授权模式”），以适应不同的客户端类型和应用场景。</p>
<h5 id="1-授权码模式-Authorization-Code-Grant"><a href="#1-授权码模式-Authorization-Code-Grant" class="headerlink" title="1. 授权码模式 (Authorization Code Grant)"></a>1. 授权码模式 (Authorization Code Grant)</h5><ul>
<li><strong>流程概述</strong>: 这是<strong>功能最完整、最安全、最推荐</strong>的模式。<ol>
<li>客户端将资源所有者重定向到授权服务器。</li>
<li>资源所有者登录并授权。</li>
<li>授权服务器将资源所有者重定向回客户端，并附带一个<strong>一次性的授权码 (Authorization Code)</strong>。</li>
<li>客户端在<strong>后端</strong>，使用自己的 <code>client_id</code>, <code>client_secret</code> 和上一步获得的授权码，向授权服务器请求令牌。</li>
<li>授权服务器验证所有信息后，返回<strong>访问令牌 (Access Token)</strong> 和可选的<strong>刷新令牌 (Refresh Token)</strong>。</li>
</ol>
</li>
<li><strong>适用场景</strong>:<ul>
<li>传统的<strong>服务端 Web 应用</strong>（如 Java, Python, Ruby on Rails 应用），因为它们有安全的后端来存储 <code>client_secret</code> 和处理与授权服务器的通信。</li>
<li><strong>第三方登录</strong>（“Login with Google&#x2F;GitHub”）的核心就是这个模式。</li>
</ul>
</li>
<li><strong>安全性</strong>: 非常高。因为敏感的令牌交换是在后端服务器之间进行的，不会暴露给前端浏览器。</li>
</ul>
<hr>
<h5 id="2-简化模式-Implicit-Grant-已不推荐"><a href="#2-简化模式-Implicit-Grant-已不推荐" class="headerlink" title="2. 简化模式 (Implicit Grant) - (已不推荐)"></a>2. 简化模式 (Implicit Grant) - (已不推荐)</h5><ul>
<li><strong>流程概述</strong>:<ol>
<li>流程与授权码模式类似，但授权服务器在用户授权后，<strong>直接</strong>通过重定向将<strong>访问令牌</strong>返回给客户端的前端。</li>
<li>没有授权码交换的步骤。</li>
</ol>
</li>
<li><strong>适用场景</strong>:<ul>
<li>最初是为<strong>纯前端应用 (SPA)</strong> 设计的，因为它们没有后端来安全地存储 <code>client_secret</code>。</li>
</ul>
</li>
<li><strong>安全性</strong>: <strong>较低，已不推荐使用</strong>。因为访问令牌直接暴露在浏览器中，容易被截获。现代 SPA 应用应使用<strong>带有 PKCE 的授权码模式</strong>来替代。</li>
</ul>
<hr>
<h5 id="3-密码模式-Resource-Owner-Password-Credentials-Grant-已不推荐"><a href="#3-密码模式-Resource-Owner-Password-Credentials-Grant-已不推荐" class="headerlink" title="3. 密码模式 (Resource Owner Password Credentials Grant) - (已不推荐)"></a>3. 密码模式 (Resource Owner Password Credentials Grant) - (已不推荐)</h5><ul>
<li><strong>流程概述</strong>:<ol>
<li>客户端直接向用户索要用户名和密码。</li>
<li>客户端将用户名、密码、<code>client_id</code> 和 <code>client_secret</code> 一起发送给授权服务器。</li>
<li>授权服务器验证后，直接返回访问令牌。</li>
</ol>
</li>
<li><strong>适用场景</strong>:<ul>
<li>仅限于<strong>高度可信的“第一方”客户端</strong>（例如，官方自己开发的移动 App）。</li>
</ul>
</li>
<li><strong>安全性</strong>: <strong>较低，强烈不推荐使用</strong>。因为它违背了 OAuth 2.0 的核心原则——不向客户端暴露用户密码。这使得客户端可以存储用户密码，增加了风险。</li>
</ul>
<hr>
<h5 id="4-客户端凭证模式-Client-Credentials-Grant"><a href="#4-客户端凭证模式-Client-Credentials-Grant" class="headerlink" title="4. 客户端凭证模式 (Client Credentials Grant)"></a>4. 客户端凭证模式 (Client Credentials Grant)</h5><ul>
<li><strong>流程概述</strong>:<ol>
<li><strong>没有资源所有者参与</strong>。</li>
<li>客户端直接使用自己的 <code>client_id</code> 和 <code>client_secret</code> 向授权服务器请求访问令牌。</li>
<li>授权服务器验证客户端身份后，返回一个访问令牌。这个令牌代表的是<strong>客户端自身</strong>，而不是某个最终用户。</li>
</ol>
</li>
<li><strong>适用场景</strong>:<ul>
<li><strong>机器对机器 (M2M) 的通信</strong>。例如，一个后台的数据同步服务需要调用另一个服务的 API。这个数据同步服务本身就是一个客户端，它需要访问资源，但这个过程与任何终端用户都无关。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-2-4-OIDC-OpenID-Connect-在-OAuth-2-0-之上构建的认证层"><a href="#5-2-4-OIDC-OpenID-Connect-在-OAuth-2-0-之上构建的认证层" class="headerlink" title="5.2.4 OIDC (OpenID Connect): 在 OAuth 2.0 之上构建的认证层"></a>5.2.4 OIDC (OpenID Connect): 在 OAuth 2.0 之上构建的认证层</h4><p>前面提到，OAuth 2.0 是一个授权框架。但实际应用中，我们经常需要“第三方登录”，这不仅需要授权，还需要<strong>认证</strong>——即“确认当前用户的身份是谁”。</p>
<p><strong>OIDC (OpenID Connect)</strong> 就是为了解决这个问题而生的。</p>
<ul>
<li><strong>定义</strong>: OIDC 是建立在 OAuth 2.0 协议之上的一个<strong>身份认证层 (Identity Layer)</strong>。</li>
<li><strong>核心扩展</strong>: OIDC 在 OAuth 2.0 的流程中，增加了一个关键产物：<strong>ID Token</strong>。<ul>
<li><strong>ID Token</strong> 是一个 <strong>JWT (JSON Web Token)</strong>。</li>
<li>它包含了关于<strong>资源所有者（用户）的身份信息</strong>，如用户的唯一标识符 (<code>sub</code>)、签发者 (<code>iss</code>)、签发时间 (<code>iat</code>) 等。</li>
<li>ID Token 经过了<strong>数字签名</strong>，客户端可以验证其真实性和完整性，从而确认用户的身份。</li>
</ul>
</li>
</ul>
<p><strong>OIDC 与 OAuth 2.0 的关系</strong>:</p>
<ul>
<li>所有 OIDC 流程都是合法的 OAuth 2.0 流程。</li>
<li>OIDC 在 OAuth 2.0 的基础上增加了 <code>openid</code> 这个特殊的 <code>scope</code> (权限范围)。当客户端请求中包含 <code>scope=openid</code> 时，授权服务器就知道这是一个 OIDC 请求。</li>
<li>在返回 <code>Access Token</code> 的同时，授权服务器还会返回一个 <code>ID Token</code>。</li>
</ul>
<p><strong>总结</strong>:</p>
<ul>
<li>如果你只需要<strong>授权</strong>（让应用 A 访问应用 B 的数据），使用 <strong>OAuth 2.0</strong>。</li>
<li>如果你需要<strong>认证</strong>（实现“使用 Google&#x2F;GitHub 登录”的功能），你需要的是 <strong>OIDC</strong>。</li>
</ul>
<p><strong>Spring Security OAuth2 Client 模块实际上就是一个 OIDC 的客户端实现</strong>，它能帮助我们轻松地集成支持 OIDC 的第三方认证服务。</p>
<hr>
<h3 id="5-3-Spring-Security-OAuth2-Client"><a href="#5-3-Spring-Security-OAuth2-Client" class="headerlink" title="5.3 Spring Security OAuth2 Client"></a>5.3 Spring Security OAuth2 Client</h3><p>Spring Security 的 <code>spring-security-oauth2-client</code> 模块极大地简化了作为 OAuth2&#x2F;OIDC 客户端与第三方身份提供商（IdP, Identity Provider）集成的过程。它封装了所有复杂的 OAuth2 授权码流程，让我们只需少量配置就能实现强大的第三方登录功能。</p>
<h4 id="5-3-1-核心流程回顾"><a href="#5-3-1-核心流程回顾" class="headerlink" title="5.3.1 核心流程回顾"></a>5.3.1 核心流程回顾</h4><p>当我们集成第三方登录时，我们的应用扮演的是 <strong>OAuth2 客户端 (Client)</strong> 的角色。整个流程遵循 <strong>授权码模式 (Authorization Code Grant)</strong>：</p>
<ol>
<li><strong>用户点击“使用 GitHub 登录”</strong>: 我们的应用将用户重定向到 GitHub 的授权页面。</li>
<li><strong>用户在 GitHub 上授权</strong>: 用户登录自己的 GitHub 账户，并同意授权我们的应用访问其基本信息。</li>
<li><strong>GitHub 重定向回应用</strong>: GitHub 将用户重定向回我们应用预先配置的回调 URL (<code>redirect-uri</code>)，并附带一个一次性的<strong>授权码 (code)</strong>。</li>
<li><strong>后台交换令牌</strong>: Spring Security OAuth2 Client 模块自动拦截这个回调请求，在后台用授权码、<code>client-id</code> 和 <code>client-secret</code> 向 GitHub 的 Token 端点交换<strong>访问令牌 (Access Token)</strong>。</li>
<li><strong>获取用户信息</strong>: 获得 Access Token 后，模块会用它去请求 GitHub 的 UserInfo 端点，获取用户的详细信息（如用户名、头像、邮箱等）。</li>
<li><strong>创建本地会话</strong>: 模块将获取到的第三方用户信息适配成一个 <code>Authentication</code> 对象，并存入 <code>SecurityContextHolder</code>，创建本地登录会话。</li>
<li><strong>用户登录成功</strong>: 用户被重定向到应用的首页或登录前的目标页面。</li>
</ol>
<p><strong>好消息是：以上所有步骤，Spring Security 都已经为我们自动处理好了！</strong> 我们需要做的主要是提供配置信息。</p>
<hr>
<h4 id="5-3-2-集成第三方登录（以-GitHub-为例）"><a href="#5-3-2-集成第三方登录（以-GitHub-为例）" class="headerlink" title="5.3.2 集成第三方登录（以 GitHub 为例）"></a>5.3.2 集成第三方登录（以 GitHub 为例）</h4><p><strong>步骤 1: 引入依赖</strong></p>
<p>确保你的 <code>pom.xml</code> 中包含了 <code>oauth2-client</code> 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-oauth2-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 在第三方平台注册应用</strong></p>
<p>你必须先到你要集成的第三方平台（如 GitHub, Google, Facebook）的开发者中心注册你的应用，以获取凭证。</p>
<p><strong>以 GitHub 为例</strong>:</p>
<ol>
<li>登录 GitHub，进入 <code>Settings</code> -&gt; <code>Developer settings</code> -&gt; <code>OAuth Apps</code> -&gt; <code>New OAuth App</code>。</li>
<li>填写应用信息：<ul>
<li><strong>Application name</strong>: 你的应用名称。</li>
<li><strong>Homepage URL</strong>: 你的应用主页地址，例如 <code>http://localhost:8080</code>。</li>
<li><strong>Authorization callback URL</strong>: <strong>极其重要！</strong> 这是 GitHub 在用户授权后将用户重定向回来的地址。Spring Security 默认的格式是 <code>{baseUrl}/login/oauth2/code/{registrationId}</code>。<ul>
<li><code>baseUrl</code>: 你的应用的基础 URL，例如 <code>http://localhost:8080</code>。</li>
<li><code>registrationId</code>: 你在 <code>application.yml</code> 中为这个提供商起的名字，对于 GitHub，通常就是 <code>github</code>。</li>
<li>所以，这里应该填写 <code>http://localhost:8080/login/oauth2/code/github</code>。</li>
</ul>
</li>
</ul>
</li>
<li>注册成功后，你将获得一个 <strong>Client ID</strong> 和一个 <strong>Client Secret</strong>。<strong>请妥善保管 Client Secret，绝不要泄露到前端或公共代码库中。</strong></li>
</ol>
<p><strong>步骤 3: 配置 <code>application.yml</code></strong></p>
<p>这是最核心的配置步骤。Spring Boot 对常见的 OAuth2 提供商（Google, GitHub, Facebook, Okta）提供了极简的自动化配置。</p>
<p>在 <code>src/main/resources/application.yml</code> 中添加如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">oauth2:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">registration:</span></span><br><span class="line">          <span class="comment"># &quot;github&quot; 是这个配置的 registrationId，必须与回调 URL 中的一致</span></span><br><span class="line">          <span class="attr">github:</span> </span><br><span class="line">            <span class="attr">client-id:</span> <span class="string">YOUR_GITHUB_CLIENT_ID</span> <span class="comment"># 替换成你的 Client ID</span></span><br><span class="line">            <span class="attr">client-secret:</span> <span class="string">YOUR_GITHUB_CLIENT_SECRET</span> <span class="comment"># 替换成你的 Client Secret</span></span><br><span class="line">            <span class="comment"># scope: # (可选) 指定请求的权限范围，如 read:user, user:email</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment"># 如果要同时集成 Google</span></span><br><span class="line">          <span class="attr">google:</span></span><br><span class="line">            <span class="attr">client-id:</span> <span class="string">YOUR_GOOGLE_CLIENT_ID</span></span><br><span class="line">            <span class="attr">client-secret:</span> <span class="string">YOUR_GOOGLE_CLIENT_SECRET</span></span><br><span class="line">            <span class="attr">scope:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">openid</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">profile</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">email</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">provider:</span></span><br><span class="line">          <span class="comment"># 对于非 Spring Boot 预置的提供商，需要在这里手动配置端点信息。</span></span><br><span class="line">          <span class="comment"># 对于 GitHub, Google 等，这些信息都是自动配置的，所以 provider 部分可以省略。</span></span><br></pre></td></tr></table></figure>

<p><strong>配置解读</strong>:</p>
<ul>
<li><code>spring.security.oauth2.client.registration</code>: 这个路径下定义了所有客户端的注册信息。</li>
<li><code>github</code>: 这是我们为 GitHub 这个提供商定义的 <code>registrationId</code>。</li>
<li><code>client-id</code> &#x2F; <code>client-secret</code>: 填入从 GitHub 获取的凭证。</li>
<li><code>scope</code>: (可选) 定义你希望向用户申请的权限范围。对于 OIDC (如 Google)，<code>openid</code> 是必须的。</li>
</ul>
<p><strong>步骤 4: 启用 OAuth2 登录</strong></p>
<p>在你的 <code>SecurityFilterChain</code> 配置中，启用 <code>.oauth2Login()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                .requestMatchers(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;/login**&quot;</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            .oauth2Login(Customizer.withDefaults()); <span class="comment">// 启用 OAuth2 登录，使用默认配置</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>oauth2Login()</code> 会自动配置 <code>OAuth2LoginAuthenticationFilter</code>，它负责处理整个 OAuth2 登录流程。</p>
<p><strong>步骤 5: 创建登录链接</strong></p>
<p>Spring Security 默认的登录发起 URL 格式是 <code>/oauth2/authorization/{registrationId}</code>。</p>
<p>你可以在你的登录页面（或任何页面）上添加入口链接：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 Thymeleaf 模板中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Login with:<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/oauth2/authorization/github&quot;</span>&gt;</span>GitHub<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/oauth2/authorization/google&quot;</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当用户点击这个链接时，Spring Security 会自动将他们重定向到对应的第三方授权页面。</p>
<p><strong>就是这么简单！</strong> 完成以上步骤后，启动你的应用，访问首页，点击“GitHub”链接，你应该就能体验完整的第三方登录流程了。</p>
<hr>
<h4 id="5-3-3-获取第三方用户信息"><a href="#5-3-3-获取第三方用户信息" class="headerlink" title="5.3.3 获取第三方用户信息"></a>5.3.3 获取第三方用户信息</h4><p>当用户通过 OAuth2 登录成功后，Spring Security 会将获取到的用户信息封装成一个 <code>Authentication</code> 对象，其 <code>Principal</code> 通常是一个 <code>OAuth2User</code> (对于标准 OAuth2) 或 <code>OidcUser</code> (对于 OIDC) 的实例。</p>
<p>你可以在 Controller 中方便地获取这些信息。</p>
<p><strong>方法 1: 从 <code>Authentication</code> 对象获取</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getUserInfo</span><span class="params">(Authentication authentication)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是从 OAuth2 登录</span></span><br><span class="line">        <span class="keyword">if</span> (authentication.getPrincipal() <span class="keyword">instanceof</span> OAuth2User) &#123;</span><br><span class="line">            <span class="type">OAuth2User</span> <span class="variable">oauth2User</span> <span class="operator">=</span> (OAuth2User) authentication.getPrincipal();</span><br><span class="line">            <span class="comment">// attributes 包含了从 UserInfo 端点获取的所有用户信息</span></span><br><span class="line">            <span class="keyword">return</span> oauth2User.getAttributes();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果是 OIDC 登录 (如 Google)</span></span><br><span class="line">        <span class="keyword">if</span> (authentication.getPrincipal() <span class="keyword">instanceof</span> OidcUser) &#123;</span><br><span class="line">            <span class="type">OidcUser</span> <span class="variable">oidcUser</span> <span class="operator">=</span> (OidcUser) authentication.getPrincipal();</span><br><span class="line">            <span class="comment">// OidcUser 包含更丰富的身份信息</span></span><br><span class="line">            Map&lt;String, Object&gt; claims = oidcUser.getClaims();</span><br><span class="line">            <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> oidcUser.getEmail();</span><br><span class="line">            <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> oidcUser.getFullName();</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> claims;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理其他登录方式...</span></span><br><span class="line">        <span class="keyword">return</span> Map.of(<span class="string">&quot;username&quot;</span>, authentication.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法 2: 使用 <code>@AuthenticationPrincipal</code> 注解</strong></p>
<p>这是一种更简洁的方式，可以直接将 <code>Principal</code> 对象注入到方法参数中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.core.annotation.AuthenticationPrincipal;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.core.user.OAuth2User;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/info/principal&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getUserInfoFromPrincipal</span><span class="params">(<span class="meta">@AuthenticationPrincipal</span> OAuth2User principal)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (principal == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 用户可能不是通过 OAuth2 登录的</span></span><br><span class="line">        <span class="keyword">return</span> Map.of(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;Not an OAuth2 user&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// principal.getAttributes() 返回一个包含用户信息的 Map</span></span><br><span class="line">    <span class="comment">// 例如: &quot;login&quot; -&gt; &quot;username&quot;, &quot;avatar_url&quot; -&gt; &quot;...&quot;, &quot;name&quot; -&gt; &quot;...&quot;</span></span><br><span class="line">    <span class="keyword">return</span> principal.getAttributes();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@AuthenticationPrincipal</code> 注解会自动进行类型转换。如果用户是通过 OIDC 登录的，你可以直接注入 <code>OidcUser</code> 类型。</p>
<p><strong>自定义处理</strong>:</p>
<p>在实际应用中，当用户首次通过第三方登录时，你可能需要在你的数据库中创建一个对应的用户记录。你可以通过自定义 <code>OAuth2UserService</code> 来实现这个逻辑，将获取到的 <code>OAuth2User</code> 信息保存到你的 <code>User</code> 实体中。</p>
<hr>
<h3 id="5-4-Spring-Security-OAuth2-Resource-Server"><a href="#5-4-Spring-Security-OAuth2-Resource-Server" class="headerlink" title="5.4 Spring Security OAuth2 Resource Server"></a>5.4 Spring Security OAuth2 Resource Server</h3><p>在 OAuth2 的世界里，<strong>资源服务器 (Resource Server)</strong> 是托管受保护资源（如用户数据、业务 API）的一方。它的核心职责是：<strong>接收并验证客户端出示的访问令牌 (Access Token)，只有在令牌有效且具备足够权限时，才允许访问资源</strong>。</p>
<p>Spring Security 的 <code>spring-security-oauth2-resource-server</code> 模块为我们构建这样的服务提供了强大的支持。</p>
<h4 id="5-4-1-核心概念与场景"><a href="#5-4-1-核心概念与场景" class="headerlink" title="5.4.1 核心概念与场景"></a>5.4.1 核心概念与场景</h4><ul>
<li><strong>场景</strong>: 你正在构建一个微服务或一个后端 RESTful API。这个 API 是无状态的，它不会处理用户登录流程。它只信任由一个独立的<strong>授权服务器 (Authorization Server)</strong>（如 Okta, Keycloak, Auth0，或者你自己用 Spring Authorization Server 构建的服务）签发的令牌。</li>
<li><strong>交互流程</strong>:<ol>
<li>前端应用（客户端）通过 OAuth2 流程（如授权码模式）从授权服务器获取到一个 Access Token。</li>
<li>前端应用在每次请求你的 API 时，都在 <code>Authorization</code> 请求头中携带这个令牌：<code>Authorization: Bearer &lt;access_token&gt;</code>。</li>
<li>你的 API 服务（资源服务器）拦截到请求，提取出 Access Token。</li>
<li>资源服务器<strong>独立地</strong>对这个 Token 进行验证。</li>
<li>如果验证通过，资源服务器处理请求并返回数据；否则，返回 <code>401 Unauthorized</code> 或 <code>403 Forbidden</code>。</li>
</ol>
</li>
<li><strong>关键点</strong>: 资源服务器<strong>不关心</strong>令牌是如何获取的，它只关心<strong>如何验证</strong>令牌的有效性。</li>
</ul>
<hr>
<h4 id="5-4-2-令牌验证的两种主要方式"><a href="#5-4-2-令牌验证的两种主要方式" class="headerlink" title="5.4.2 令牌验证的两种主要方式"></a>5.4.2 令牌验证的两种主要方式</h4><p>资源服务器验证 Access Token 的方式主要有两种：</p>
<ol>
<li><strong>JWT (JSON Web Token)</strong><ul>
<li><strong>原理</strong>: JWT 是<strong>自包含</strong>的。它本身就包含了所有验证所需的信息（签名、过期时间、签发者、权限等）。资源服务器只需要知道授权服务器的<strong>公钥</strong>或<strong>对称密钥</strong>，就可以在<strong>本地</strong>对 JWT 进行完整的验证，<strong>无需与授权服务器进行网络通信</strong>。</li>
<li><strong>优点</strong>: 性能高，可扩展性强。因为验证是离线的，不会给授权服务器带来压力。</li>
<li><strong>缺点</strong>: 令牌一旦签发，在过期前通常无法轻易撤销。</li>
</ul>
</li>
<li><strong>Opaque Token (不透明令牌)</strong><ul>
<li><strong>原理</strong>: Opaque Token 本身是一个无意义的、随机的字符串。它不包含任何用户信息。</li>
<li><strong>验证方式</strong>: 资源服务器必须通过网络调用授权服务器提供的一个特殊端点——<strong>内省端点 (Introspection Endpoint)</strong>，将令牌发送过去，由授权服务器来判断该令牌是否有效。</li>
<li><strong>优点</strong>: 安全性更高。授权服务器可以随时撤销任何一个令牌，资源服务器每次查询都能得到最新的状态。</li>
<li><strong>缺点</strong>: 性能较低，增加了网络延迟，并对授权服务器产生了强依赖和负载压力。</li>
</ul>
</li>
</ol>
<p><strong>在现代微服务架构中，JWT 是更常用、更主流的选择。</strong></p>
<hr>
<h4 id="5-4-3-构建受-JWT-保护的资源服务器"><a href="#5-4-3-构建受-JWT-保护的资源服务器" class="headerlink" title="5.4.3 构建受 JWT 保护的资源服务器"></a>5.4.3 构建受 JWT 保护的资源服务器</h4><p><strong>步骤 1: 引入依赖</strong></p>
<p>确保你的 <code>pom.xml</code> 中包含了 <code>oauth2-resource-server</code> 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-oauth2-resource-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 配置 <code>application.yml</code></strong></p>
<p>你需要告诉资源服务器如何找到用于验证 JWT 签名的公钥。授权服务器通常会通过一个标准的 <strong>JWK Set URI</strong> (<code>.well-known/jwks.json</code>) 来发布其公钥集。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">oauth2:</span></span><br><span class="line">      <span class="attr">resourceserver:</span></span><br><span class="line">        <span class="attr">jwt:</span></span><br><span class="line">          <span class="comment"># JWK Set URI: 这是授权服务器发布其公钥的地方。</span></span><br><span class="line">          <span class="comment"># 你的资源服务器会启动时或首次需要时从这个地址下载公钥。</span></span><br><span class="line">          <span class="attr">jwk-set-uri:</span> <span class="string">https://your-auth-server.com/.well-known/jwks.json</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment"># (可选) Issuer URI: 指定期望的签发者。</span></span><br><span class="line">          <span class="comment"># 资源服务器会验证 JWT 中的 &#x27;iss&#x27; 声明是否与此值匹配，增强安全性。</span></span><br><span class="line">          <span class="comment"># Spring Boot 也能从此地址自动发现 JWK Set URI (通过 .well-known/openid-configuration)。</span></span><br><span class="line">          <span class="comment"># issuer-uri: https://your-auth-server.com</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>jwk-set-uri</code>: <strong>核心配置</strong>。指向授权服务器的公钥集地址。</li>
<li><code>issuer-uri</code>: 推荐配置。这不仅可以验证 <code>iss</code> 声明，还能让 Spring Boot 自动发现 <code>jwk-set-uri</code>，使得配置更简洁。如果配置了 <code>issuer-uri</code>，<code>jwk-set-uri</code> 就可以省略。</li>
</ul>
<p><strong>步骤 3: 启用资源服务器支持</strong></p>
<p>在你的 <code>SecurityFilterChain</code> 配置中，启用 <code>.oauth2ResourceServer()</code> 并指定使用 JWT。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableMethodSecurity</span> <span class="comment">// 强烈建议开启，以便进行基于 scope/claims 的方法级授权</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            <span class="comment">// 1. 配置所有请求都需要认证</span></span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// 2. 启用 OAuth2 资源服务器支持，并指定使用 JWT</span></span><br><span class="line">            .oauth2ResourceServer(oauth2 -&gt; oauth2</span><br><span class="line">                .jwt(Customizer.withDefaults())</span><br><span class="line">            );</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>.oauth2ResourceServer(oauth2 -&gt; oauth2.jwt(...))</code>: 这行代码会配置 <code>BearerTokenAuthenticationFilter</code>。这个过滤器负责从 <code>Authorization</code> Header 中提取 Bearer Token (JWT)，然后委托给 <code>JwtDecoder</code> 进行解码和验证。如果验证成功，它会创建一个 <code>JwtAuthenticationToken</code> 并放入 <code>SecurityContextHolder</code>。</li>
</ul>
<p><strong>步骤 4: 基于 Scope&#x2F;Claims 进行授权</strong></p>
<p>一旦 JWT 被成功验证，我们就可以利用其 Payload 中的声明（特别是 <code>scope</code> 或自定义的 <code>authorities</code> 声明）来进行细粒度的授权。</p>
<p><strong>URL 级别授权</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">    <span class="comment">// 要求 Token 必须包含 &quot;read&quot; 这个 scope</span></span><br><span class="line">    .requestMatchers(HttpMethod.GET, <span class="string">&quot;/api/data&quot;</span>).hasAuthority(<span class="string">&quot;SCOPE_read&quot;</span>)</span><br><span class="line">    <span class="comment">// 要求 Token 必须包含 &quot;write&quot; 这个 scope</span></span><br><span class="line">    .requestMatchers(HttpMethod.POST, <span class="string">&quot;/api/data&quot;</span>).hasAuthority(<span class="string">&quot;SCOPE_write&quot;</span>)</span><br><span class="line">    .anyRequest().authenticated()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: Spring Security 会自动为 <code>scope</code> 声明的值添加 <code>SCOPE_</code> 前缀，使其可以被 <code>hasAuthority()</code> 匹配。</p>
<p><strong>方法级别授权 (更推荐)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/data&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;SCOPE_read&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;You have read the data!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;SCOPE_write&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">writeData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;You have written the data!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 甚至可以基于自定义的 claim 进行判断</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;SCOPE_delete&#x27;) and #jwt.getClaimAsString(&#x27;department&#x27;) == &#x27;FINANCE&#x27;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteData</span><span class="params">(<span class="meta">@PathVariable</span> String id, <span class="meta">@AuthenticationPrincipal</span> Jwt jwt)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Data &quot;</span> + id + <span class="string">&quot; deleted by someone from FINANCE department.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@AuthenticationPrincipal Jwt jwt</code>: 可以直接注入解码后的 <code>Jwt</code> 对象，方便地访问其中的任何 claim。</li>
</ul>
<hr>
<h4 id="5-4-4-可选-配置-Opaque-Token-校验"><a href="#5-4-4-可选-配置-Opaque-Token-校验" class="headerlink" title="5.4.4 [可选] 配置 Opaque Token 校验"></a>5.4.4 [可选] 配置 Opaque Token 校验</h4><p>如果你的授权服务器使用不透明令牌，配置方式略有不同。</p>
<p><strong><code>application.yml</code> 配置</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">oauth2:</span></span><br><span class="line">      <span class="attr">resourceserver:</span></span><br><span class="line">        <span class="attr">opaque-token:</span></span><br><span class="line">          <span class="comment"># 内省端点的 URI</span></span><br><span class="line">          <span class="attr">introspection-uri:</span> <span class="string">https://your-auth-server.com/oauth2/introspect</span></span><br><span class="line">          <span class="comment"># 资源服务器自己的凭证，用于向内省端点表明身份</span></span><br><span class="line">          <span class="attr">client-id:</span> <span class="string">your-resource-server-client-id</span></span><br><span class="line">          <span class="attr">client-secret:</span> <span class="string">your-resource-server-client-secret</span></span><br></pre></td></tr></table></figure>

<p><strong>Security 配置</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.oauth2ResourceServer(oauth2 -&gt; oauth2</span><br><span class="line">    .opaqueToken(Customizer.withDefaults())</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这样配置后，<code>BearerTokenAuthenticationFilter</code> 会将提取到的令牌通过网络请求发送到 <code>introspection-uri</code> 进行验证。</p>
<hr>
<h3 id="5-5-选学-Spring-Authorization-Server"><a href="#5-5-选学-Spring-Authorization-Server" class="headerlink" title="5.5 [选学] Spring Authorization Server"></a>5.5 [选学] Spring Authorization Server</h3><p>在前面的章节中，我们学习了如何作为 <strong>客户端 (Client)</strong> 去集成第三方登录，以及如何作为 <strong>资源服务器 (Resource Server)</strong> 去保护 API。但提供这些服务的<strong>授权服务器 (Authorization Server)</strong> 是由第三方（如 Google, GitHub, Okta）提供的。</p>
<p><strong>Spring Authorization Server (SAS)</strong> 项目则让我们有能力<strong>自己从零构建一个功能齐全、符合 OAuth 2.1 和 OIDC 1.0 规范的授权服务器</strong>。这意味着你可以成为自己生态系统中的“Google”或“Okta”。</p>
<h4 id="5-5-1-为什么需要自建授权服务器？"><a href="#5-5-1-为什么需要自建授权服务器？" class="headerlink" title="5.5.1 为什么需要自建授权服务器？"></a>5.5.1 为什么需要自建授权服务器？</h4><ul>
<li><strong>统一身份认证 (Single Sign-On, SSO)</strong>: 当你的公司有多个内部应用（如 CRM, HR 系统, Wiki）时，你希望员工只需登录一次，就可以访问所有授权的应用。SAS 是实现 SSO 的核心。</li>
<li><strong>中心化授权管理</strong>: 为你自己的所有 API 和微服务提供一个统一的令牌签发和管理中心。你可以集中控制哪个应用（客户端）可以访问哪个 API（资源），以及拥有哪些权限（scope）。</li>
<li><strong>开放平台能力</strong>: 如果你想构建一个开放平台，允许第三方开发者创建应用来访问你的用户数据（就像微信开放平台、GitHub Apps），那么一个标准的授权服务器是必不可少的。</li>
<li><strong>数据主权与合规性</strong>: 在某些行业（如金融、医疗），出于数据隐私和法规要求，必须将用户身份数据存储在自己的基础设施内，不能依赖外部 IdP。</li>
</ul>
<hr>
<h4 id="5-5-2-核心概念与组件"><a href="#5-5-2-核心概念与组件" class="headerlink" title="5.5.2 核心概念与组件"></a>5.5.2 核心概念与组件</h4><p>Spring Authorization Server 的设计遵循了 OAuth 2.1 规范，其核心是管理和协调以下几个关键实体：</p>
<ol>
<li><strong><code>RegisteredClient</code> (注册客户端)</strong><ul>
<li>代表一个在你的授权服务器上注册的<strong>客户端应用</strong>（如一个 Web 应用、一个移动 App、一个后台服务）。</li>
<li><strong>核心配置</strong>:<ul>
<li><code>clientId</code> &#x2F; <code>clientSecret</code>: 客户端的唯一凭证。</li>
<li><code>clientAuthenticationMethods</code>: 客户端如何向授权服务器验证自己（如 <code>client_secret_basic</code>）。</li>
<li><code>authorizationGrantTypes</code>: 该客户端被允许使用的授权模式（如 <code>AUTHORIZATION_CODE</code>, <code>CLIENT_CREDENTIALS</code>, <code>REFRESH_TOKEN</code>）。</li>
<li><code>redirectUris</code>: 对于授权码模式，授权成功后允许重定向回的白名单 URL。</li>
<li><code>scopes</code>: 该客户端被允许请求的权限范围。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>OAuth2AuthorizationService</code> (授权管理服务)</strong><ul>
<li>这是一个状态存储服务，用于<strong>持久化</strong>在授权过程中产生的状态，主要是<strong>授权码 (Authorization Code)</strong> 和<strong>访问&#x2F;刷新令牌 (Access&#x2F;Refresh Token)</strong>。</li>
<li>它将令牌与用户、客户端关联起来，并记录其状态（如是否已吊销）。</li>
<li>默认实现是基于内存的 (<code>InMemoryOAuth2AuthorizationService</code>)，生产环境必须替换为持久化实现（如 <code>JdbcOAuth2AuthorizationService</code>）。</li>
</ul>
</li>
<li><strong><code>OAuth2AuthorizationConsentService</code> (用户同意管理服务)</strong><ul>
<li>用于存储用户对特定客户端的授权同意记录。</li>
<li>当你看到“应用 XXX 希望访问你的以下信息：头像、昵称。你是否同意？”这个页面时，如果你点击“同意”，这个同意记录就会被此服务存储。下次同一个客户端请求相同权限时，可能就不需要你再次确认了。</li>
<li>同样有内存和 JDBC 实现。</li>
</ul>
</li>
<li><strong>JWK (JSON Web Key) 源</strong><ul>
<li>授权服务器需要一个**密钥对（公钥和私钥）**来对 JWT 进行签名。</li>
<li><code>JWKSource</code> 负责提供这些密钥。你可以从文件中加载，或者在启动时动态生成。</li>
<li>公钥会通过 <code>/oauth2/jwks</code> (JWK Set) 端点暴露出去，供资源服务器下载和验证令牌签名。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-5-3-从零构建一个最小化的授权服务器"><a href="#5-5-3-从零构建一个最小化的授权服务器" class="headerlink" title="5.5.3 从零构建一个最小化的授权服务器"></a>5.5.3 从零构建一个最小化的授权服务器</h4><p><strong>步骤 1: 引入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-oauth2-authorization-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用与你的 Spring Boot 版本匹配的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 基础安全配置 (用户认证)</strong></p>
<p>授权服务器首先需要一个普通的用户认证机制，来确认<strong>资源所有者</strong>的身份。这里我们使用一个简单的内存用户。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Order(2)</span> <span class="comment">// 默认的安全过滤器链</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">defaultSecurityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth.anyRequest().authenticated())</span><br><span class="line">            .formLogin(Customizer.withDefaults());</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> User.withDefaultPasswordEncoder()</span><br><span class="line">                .username(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                .password(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .roles(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 3: 授权服务器核心配置</strong></p>
<p>这是最关键的一步。我们需要配置 SAS 提供的所有 OAuth2 端点（如 <code>/oauth2/authorize</code>, <code>/oauth2/token</code>）以及核心服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationServerConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Order(1)</span> <span class="comment">// 授权服务器的过滤器链，优先级更高</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">authorizationServerSecurityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 应用 SAS 的默认安全配置</span></span><br><span class="line">        OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 启用 OpenID Connect 1.0 功能</span></span><br><span class="line">        http.getConfigurer(OAuth2AuthorizationServerConfigurer.class)</span><br><span class="line">            .oidc(Customizer.withDefaults());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 配置异常处理，将 OAuth2 相关的认证错误重定向到登录页面</span></span><br><span class="line">        http</span><br><span class="line">            .exceptionHandling(exceptions -&gt; exceptions</span><br><span class="line">                .defaultAuthenticationEntryPointFor(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">LoginUrlAuthenticationEntryPoint</span>(<span class="string">&quot;/login&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">MediaTypeRequestMatcher</span>(MediaType.TEXT_HTML)</span><br><span class="line">                )</span><br><span class="line">            );</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 配置注册的客户端信息</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RegisteredClientRepository <span class="title function_">registeredClientRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RegisteredClient</span> <span class="variable">oidcClient</span> <span class="operator">=</span> RegisteredClient.withId(UUID.randomUUID().toString())</span><br><span class="line">                .clientId(<span class="string">&quot;oidc-client&quot;</span>)</span><br><span class="line">                .clientSecret(<span class="string">&quot;&#123;noop&#125;secret&quot;</span>) <span class="comment">// 生产环境必须加密</span></span><br><span class="line">                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)</span><br><span class="line">                .redirectUri(<span class="string">&quot;http://127.0.0.1:8080/login/oauth2/code/oidc-client&quot;</span>)</span><br><span class="line">                .scope(OidcScopes.OPENID)</span><br><span class="line">                .scope(OidcScopes.PROFILE)</span><br><span class="line">                .scope(<span class="string">&quot;message.read&quot;</span>)</span><br><span class="line">                .scope(<span class="string">&quot;message.write&quot;</span>)</span><br><span class="line">                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(<span class="literal">true</span>).build())</span><br><span class="line">                .build();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用内存存储，生产环境应替换为 JdbcRegisteredClientRepository</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryRegisteredClientRepository</span>(oidcClient);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 配置用于 JWT 签名的密钥对</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JWKSource&lt;SecurityContext&gt; <span class="title function_">jwkSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> generateRsaKey();</span><br><span class="line">        <span class="type">RSAPublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> (RSAPublicKey) keyPair.getPublic();</span><br><span class="line">        <span class="type">RSAPrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> (RSAPrivateKey) keyPair.getPrivate();</span><br><span class="line">        <span class="type">RSAKey</span> <span class="variable">rsaKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RSAKey</span>.Builder(publicKey)</span><br><span class="line">                .privateKey(privateKey)</span><br><span class="line">                .keyID(UUID.randomUUID().toString())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">JWKSet</span> <span class="variable">jwkSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JWKSet</span>(rsaKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ImmutableJWKSet</span>&lt;&gt;(jwkSet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> KeyPair <span class="title function_">generateRsaKey</span><span class="params">()</span> &#123; <span class="comment">/* ... a helper method to generate RSA key pair ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 配置 ProviderSettings，定义授权服务器的 Issuer URI</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizationServerSettings <span class="title function_">authorizationServerSettings</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AuthorizationServerSettings.builder().issuer(<span class="string">&quot;http://localhost:9000&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 7. [可选] 配置 OAuth2AuthorizationConsentService 和 OAuth2AuthorizationService</span></span><br><span class="line">    <span class="comment">// 默认是 InMemory，生产应使用 JDBC 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ol>
<li><strong><code>authorizationServerSecurityFilterChain</code></strong>: 这是一个专门为 SAS 端点设计的安全过滤器链，通过 <code>@Order(1)</code> 确保它在默认的用户认证链之前被匹配。<code>OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http)</code> 是一个便捷方法，它会自动配置好所有必需的端点和过滤器。</li>
<li><strong><code>oidc(Customizer.withDefaults())</code></strong>: 启用 OIDC 支持，这会开启 <code>/userinfo</code> 端点，并在令牌响应中包含 ID Token。</li>
<li><strong><code>registeredClientRepository()</code></strong>: 定义了“谁可以（客户端）”来使用我们的授权服务。这里我们硬编码了一个客户端，在生产环境中，这些信息应该存储在数据库中 (<code>JdbcRegisteredClientRepository</code>)。</li>
<li><strong><code>jwkSource()</code></strong>: 提供了用于 JWT 签名的 RSA 密钥对。每次服务器重启都会生成新的密钥（仅用于演示）。生产中应从固定的密钥库文件加载。</li>
<li><strong><code>authorizationServerSettings()</code></strong>: 配置授权服务器的元数据，最重要的就是 <code>issuer</code> URI。</li>
</ol>
<p><strong>步骤 4: 运行与测试</strong><br>启动应用后，你的授权服务器就运行在 <code>http://localhost:9000</code> 了。你可以通过以下端点来观察它的能力：</p>
<ul>
<li><strong>Issuer Discovery</strong>: <code>http://localhost:9000/.well-known/openid-configuration</code><ul>
<li>这是一个标准的元数据端点，它会告诉客户端你的授权服务器的所有端点地址（授权、令牌、用户信息、JWKS 等）以及支持的功能。</li>
</ul>
</li>
<li><strong>JWK Set URI</strong>: <code>http://localhost:9000/oauth2/jwks</code><ul>
<li>资源服务器可以从这里获取用于验证 JWT 签名的公钥。</li>
</ul>
</li>
</ul>
<p>现在，你可以配置一个 OAuth2 Client 应用（就像 <code>5.3</code> 节那样），将其 <code>issuer-uri</code> 指向 <code>http://localhost:9000</code>，<code>client-id</code> 和 <code>client-secret</code> 配置为 <code>oidc-client</code> 和 <code>secret</code>，然后尝试通过你自己的授权服务器进行登录。</p>
<hr>
<h2 id="6-自定义与扩展"><a href="#6-自定义与扩展" class="headerlink" title="6. 自定义与扩展"></a>6. 自定义与扩展</h2><h3 id="6-1-自定义-SecurityFilterChain"><a href="#6-1-自定义-SecurityFilterChain" class="headerlink" title="6.1 自定义 SecurityFilterChain"></a>6.1 自定义 <code>SecurityFilterChain</code></h3><p>虽然 Spring Security 提供的默认配置和高级 DSL (<code>.formLogin()</code>, <code>.oauth2Login()</code>) 能够满足绝大多数需求，但在某些高级场景下，我们可能需要更精细地控制过滤器链的行为——比如插入一个自定义的认证过滤器（如 JWT），或者添加一个用于审计的日志过滤器。</p>
<h4 id="6-1-1-关键-Filter-的顺序"><a href="#6-1-1-关键-Filter-的顺序" class="headerlink" title="6.1.1 关键 Filter 的顺序"></a>6.1.1 关键 Filter 的顺序</h4><table>
<thead>
<tr>
<th align="left">顺序</th>
<th align="left">过滤器 (部分)</th>
<th align="left">职责</th>
<th align="left">为什么在这个位置？</th>
</tr>
</thead>
<tbody><tr>
<td align="left">早</td>
<td align="left"><code>CorsFilter</code></td>
<td align="left">处理跨域预检请求 (OPTIONS) 和添加 CORS 响应头。</td>
<td align="left">必须在任何认证&#x2F;授权之前处理，以允许前端脚本的跨域请求。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>CsrfFilter</code></td>
<td align="left">验证 CSRF Token。</td>
<td align="left">必须在任何会改变状态的操作（如登录）之前，防止 CSRF 攻击。</td>
</tr>
<tr>
<td align="left">中</td>
<td align="left"><code>LogoutFilter</code></td>
<td align="left">处理 <code>/logout</code> 请求，使会话失效。</td>
<td align="left">在认证过滤器之前，以便可以立即处理注销请求。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>UsernamePasswordAuthenticationFilter</code></td>
<td align="left">处理表单登录提交的用户名和密码。</td>
<td align="left">这是核心的认证入口之一。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>BasicAuthenticationFilter</code></td>
<td align="left">处理 HTTP Basic 认证头。</td>
<td align="left">提供了另一种认证方式。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>BearerTokenAuthenticationFilter</code></td>
<td align="left">(当使用 <code>.oauth2ResourceServer()</code> 时) 处理 Bearer Token。</td>
<td align="left">用于 API 的 Token 认证。</td>
</tr>
<tr>
<td align="left">晚</td>
<td align="left"><code>ExceptionTranslationFilter</code></td>
<td align="left">捕获 <code>AuthenticationException</code> 和 <code>AccessDeniedException</code> 并进行处理。</td>
<td align="left">它包裹了后续的过滤器，以便捕获它们抛出的安全异常。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>AuthorizationFilter</code></td>
<td align="left"><strong>执行最终的授权决策</strong>，检查用户是否有权限访问请求的 URL。</td>
<td align="left">必须在认证之后，因为只有知道了“你是谁”，才能判断“你能做什么”。</td>
</tr>
</tbody></table>
<p><strong>核心思想</strong>：通用策略和防御性检查在前，身份认证在中，权限决策在后。</p>
<hr>
<h4 id="6-1-2-添加、替换或移除默认的-Filter"><a href="#6-1-2-添加、替换或移除默认的-Filter" class="headerlink" title="6.1.2 添加、替换或移除默认的 Filter"></a>6.1.2 添加、替换或移除默认的 Filter</h4><p><code>HttpSecurity</code> 对象提供了多个方法来让我们在默认的过滤器链中“做手术”。</p>
<h5 id="1-创建自定义-Filter"><a href="#1-创建自定义-Filter" class="headerlink" title="1. 创建自定义 Filter"></a>1. 创建自定义 Filter</h5><p>首先自定义的过滤器。最佳实践是继承 <code>OncePerRequestFilter</code>，它能确保在一次请求分派中，你的过滤器逻辑只会被执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的日志过滤器示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestLoggingFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(RequestLoggingFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                                    HttpServletResponse response, </span></span><br><span class="line"><span class="params">                                    FilterChain filterChain)</span> </span><br><span class="line">                                    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 在请求到达 Controller 之前执行</span></span><br><span class="line">        logger.info(<span class="string">&quot;Incoming request: &#123;&#125; &#123;&#125;&quot;</span>, request.getMethod(), request.getRequestURI());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将请求传递给链中的下一个过滤器</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 在响应返回给客户端之前执行</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">        logger.info(<span class="string">&quot;Request finished in &#123;&#125; ms with status &#123;&#125;&quot;</span>, duration, response.getStatus());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-添加-Filter"><a href="#2-添加-Filter" class="headerlink" title="2. 添加 Filter"></a>2. 添加 Filter</h5><p><code>HttpSecurity</code> 提供了三种主要的添加方式：</p>
<ul>
<li><p><strong><code>addFilterBefore(Filter filter, Class&lt;? extends Filter&gt; beforeFilter)</code></strong>:</p>
<ul>
<li><strong>含义</strong>: 将你的 <code>filter</code> 添加到 <code>beforeFilter</code> <strong>之前</strong>。</li>
<li><strong>最常用</strong>的场景：实现自定义认证。例如，在 <code>UsernamePasswordAuthenticationFilter</code> 尝试处理表单登录<strong>之前</strong>，先用你的 <code>JwtAuthenticationFilter</code> 检查一下请求头里有没有 JWT。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterBefore(<span class="keyword">new</span> <span class="title class_">JwtAuthenticationFilter</span>(), UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>addFilterAfter(Filter filter, Class&lt;? extends Filter&gt; afterFilter)</code></strong>:</p>
<ul>
<li><strong>含义</strong>: 将你的 <code>filter</code> 添加到 <code>afterFilter</code> <strong>之后</strong>。</li>
<li><strong>场景</strong>: 如果你的过滤器依赖于某个前置过滤器的执行结果。例如，你可能想在 <code>ExceptionTranslationFilter</code> <strong>之后</strong>添加一个过滤器来对特定的安全异常进行特殊格式化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterAfter(<span class="keyword">new</span> <span class="title class_">CustomExceptionFormattingFilter</span>(), ExceptionTranslationFilter.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>addFilterAt(Filter filter, Class&lt;? extends Filter&gt; atFilter)</code></strong>:</p>
<ul>
<li><strong>含义</strong>: 将你的 <code>filter</code> 添加到与 <code>atFilter</code> <strong>相同的位置</strong>，并可能替换它。</li>
<li><strong>场景</strong>: 如果你想完全替换掉一个 Spring Security 的默认过滤器。例如，你有一个高度定制的 <code>MyUsernamePasswordAuthenticationFilter</code>，你想用它来替换掉 Spring 默认的实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterAt(<span class="keyword">new</span> <span class="title class_">MyUsernamePasswordAuthenticationFilter</span>(), UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="3-替换或移除-Filter"><a href="#3-替换或移除-Filter" class="headerlink" title="3. 替换或移除 Filter"></a>3. 替换或移除 Filter</h5><p>通常，我们不直接“移除”一个 Filter 对象，而是通过<strong>禁用</strong>添加该 Filter 的功能特性来实现。</p>
<ul>
<li><p><strong>禁用 Form Login</strong>: 这会从过滤器链中移除 <code>UsernamePasswordAuthenticationFilter</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.formLogin(formLogin -&gt; formLogin.disable());</span><br><span class="line"><span class="comment">// 或者更简洁的 http.formLogin(AbstractHttpConfigurer::disable);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>禁用 CSRF 防护</strong>: 这会移除 <code>CsrfFilter</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.csrf(csrf -&gt; csrf.disable());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>禁用 HTTP Basic</strong>: 这会移除 <code>BasicAuthenticationFilter</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.httpBasic(httpBasic -&gt; httpBasic.disable());</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>替换的典型流程</strong>:</p>
<p>实现 JWT 认证就是一个经典的“替换”流程：</p>
<ol>
<li><strong>禁用</strong>会话管理、Form Login、HTTP Basic 和 CSRF，因为这些都是有状态或不适用于 Token 认证的。</li>
<li><strong>添加</strong>你自定义的 <code>JwtAuthenticationFilter</code> 到合适的位置（通常是 <code>before</code> <code>UsernamePasswordAuthenticationFilter.class</code>）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            <span class="comment">// 1. 禁用不需要的默认功能</span></span><br><span class="line">            .csrf(csrf -&gt; csrf.disable())</span><br><span class="line">            .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))</span><br><span class="line">            .formLogin(form -&gt; form.disable())</span><br><span class="line">            .httpBasic(httpBasic -&gt; httpBasic.disable())</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 配置授权规则</span></span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                .requestMatchers(<span class="string">&quot;/api/auth/**&quot;</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 添加自定义的 JWT 过滤器</span></span><br><span class="line">            .addFilterBefore(<span class="keyword">new</span> <span class="title class_">JwtAuthenticationFilter</span>(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，即使 <code>UsernamePasswordAuthenticationFilter.class</code> 对应的过滤器因为 <code>formLogin().disable()</code> 而被移除了，这个类引用仍然可以作为一个有效的<strong>锚点</strong>，告诉 Spring Security 你的过滤器应该放在哪个逻辑位置上。</p>
<hr>
<h3 id="6-2-自定义认证逻辑"><a href="#6-2-自定义认证逻辑" class="headerlink" title="6.2 自定义认证逻辑"></a>6.2 自定义认证逻辑</h3><p>Spring Security 的认证架构是高度可插拔的。其核心在于 <code>AuthenticationManager</code> 将认证任务委托给一系列的 <code>AuthenticationProvider</code>。默认情况下，<code>DaoAuthenticationProvider</code> 负责处理用户名和密码。</p>
<p>当我们想实现全新的认证方式时，例如<strong>短信验证码登录</strong>、<strong>邮箱验证码登录</strong>、<strong>扫码登录</strong>或<strong>社交媒体一键登录</strong>（非标准 OAuth2），最佳实践就是<strong>创建我们自己的 <code>AuthenticationProvider</code></strong>。</p>
<h4 id="6-2-1-认证流程回顾与扩展点"><a href="#6-2-1-认证流程回顾与扩展点" class="headerlink" title="6.2.1 认证流程回顾与扩展点"></a>6.2.1 认证流程回顾与扩展点</h4><p>回想一下 <code>2.1</code> 节的认证流程：</p>
<ol>
<li><strong>Filter</strong> 拦截请求，从 <code>HttpServletRequest</code> 中提取凭证。</li>
<li>Filter 将凭证封装成一个**<code>Authentication</code> Token** (例如，<code>UsernamePasswordAuthenticationToken</code>)。</li>
<li>Token 被传递给 <strong><code>AuthenticationManager</code></strong> (<code>ProviderManager</code>)。</li>
<li><code>ProviderManager</code> 遍历其下的所有 <strong><code>AuthenticationProvider</code></strong>，询问谁能处理这种类型的 Token。</li>
<li>匹配的 <code>AuthenticationProvider</code> 执行核心认证逻辑，并返回一个<strong>已认证</strong>的 <code>Authentication</code> Token。</li>
</ol>
<p>要实现自定义认证，我们需要扩展以下三个关键组件：</p>
<ol>
<li><strong>自定义 <code>Authentication</code> Token</strong>: 用于封装新的凭证类型（如手机号和验证码）。</li>
<li><strong>自定义 <code>AuthenticationProvider</code></strong>: 用于实现新的认证逻辑（如校验验证码是否正确）。</li>
<li><strong>自定义 <code>Filter</code></strong>: 用于从请求中提取新的凭证，并发起认证流程。</li>
</ol>
<hr>
<h4 id="6-2-2-案例：实现短信验证码登录"><a href="#6-2-2-案例：实现短信验证码登录" class="headerlink" title="6.2.2 案例：实现短信验证码登录"></a>6.2.2 案例：实现短信验证码登录</h4><p>我们将以一个完整的“手机号 + 短信验证码”登录为例，一步步实现自定义认证。</p>
<p><strong>步骤 1: 创建自定义 <code>Authentication</code> Token</strong></p>
<p>我们需要一个类来携带手机号和验证码。这个类必须继承 <code>AbstractAuthenticationToken</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AbstractAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsCodeAuthenticationToken</span> <span class="keyword">extends</span> <span class="title class_">AbstractAuthenticationToken</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object principal; <span class="comment">// 通常是手机号</span></span><br><span class="line">    <span class="keyword">private</span> Object credentials; <span class="comment">// 通常是验证码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数1: 用于封装认证前的凭证</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsCodeAuthenticationToken</span><span class="params">(Object principal, Object credentials)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="literal">null</span>); <span class="comment">// 认证前权限为 null</span></span><br><span class="line">        <span class="built_in">this</span>.principal = principal;</span><br><span class="line">        <span class="built_in">this</span>.credentials = credentials;</span><br><span class="line">        setAuthenticated(<span class="literal">false</span>); <span class="comment">// 明确标记为未认证</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数2: 用于封装认证后的信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsCodeAuthenticationToken</span><span class="params">(Object principal, Object credentials,</span></span><br><span class="line"><span class="params">                                        Collection&lt;? extends GrantedAuthority&gt; authorities)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(authorities); <span class="comment">// 认证后传入权限</span></span><br><span class="line">        <span class="built_in">this</span>.principal = principal;</span><br><span class="line">        <span class="built_in">this</span>.credentials = credentials;</span><br><span class="line">        <span class="built_in">super</span>.setAuthenticated(<span class="literal">true</span>); <span class="comment">// 明确标记为已认证</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getCredentials</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.credentials;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getPrincipal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.principal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthenticated</span><span class="params">(<span class="type">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAuthenticated) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">super</span>.setAuthenticated(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eraseCredentials</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.eraseCredentials();</span><br><span class="line">        credentials = <span class="literal">null</span>; <span class="comment">// 认证成功后清除凭证</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 创建自定义 <code>AuthenticationProvider</code></strong></p>
<p>这是核心认证逻辑的实现。它需要实现 <code>AuthenticationProvider</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.BadCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设我们有一个 SmsCodeService 用于校验验证码</span></span><br><span class="line"><span class="comment">// @Component</span></span><br><span class="line"><span class="comment">// public class SmsCodeService &#123;</span></span><br><span class="line"><span class="comment">//     public boolean verifyCode(String mobile, String code) &#123; ... &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsCodeAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line">    <span class="keyword">private</span> SmsCodeService smsCodeService; <span class="comment">// 注入我们自己的验证码服务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造函数注入依赖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsCodeAuthenticationProvider</span><span class="params">(UserDetailsService userDetailsService, SmsCodeService smsCodeService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDetailsService = userDetailsService;</span><br><span class="line">        <span class="built_in">this</span>.smsCodeService = smsCodeService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mobile</span> <span class="operator">=</span> (String) authentication.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> (String) authentication.getCredentials();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 核心校验逻辑：调用服务验证验证码是否正确</span></span><br><span class="line">        <span class="keyword">if</span> (!smsCodeService.verifyCode(mobile, code)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="string">&quot;SMS code is invalid.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 验证码正确，加载用户信息</span></span><br><span class="line">        <span class="comment">// 注意：这里的 UserDetailsService 是通过手机号加载用户的。</span></span><br><span class="line">        <span class="comment">// 你可能需要自定义 UserDetailsService 的实现。</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> userDetailsService.loadUserByUsername(mobile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 认证成功，创建一个已认证的 Token</span></span><br><span class="line">        <span class="type">SmsCodeAuthenticationToken</span> <span class="variable">authenticatedToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsCodeAuthenticationToken</span>(</span><br><span class="line">                userDetails, <span class="comment">// principal 现在是 UserDetails 对象</span></span><br><span class="line">                <span class="literal">null</span>,        <span class="comment">// credentials 设为 null</span></span><br><span class="line">                userDetails.getAuthorities() <span class="comment">// 权限</span></span><br><span class="line">        );</span><br><span class="line">        authenticatedToken.setDetails(authentication.getDetails());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> authenticatedToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> &#123;</span><br><span class="line">        <span class="comment">// 告诉 AuthenticationManager，我能处理 SmsCodeAuthenticationToken 类型的 Token</span></span><br><span class="line">        <span class="keyword">return</span> (SmsCodeAuthenticationToken.class.isAssignableFrom(authentication));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>supports()</code> 方法至关重要</strong>，它就像 <code>Provider</code> 在向 <code>Manager</code> “举手”说：“这种类型的认证请求，我能处理！”</p>
<p><strong>步骤 3: 创建自定义 <code>Filter</code></strong></p>
<p>我们需要一个过滤器来拦截短信登录请求（例如 <code>POST /sms/login</code>），提取手机号和验证码，然后启动认证流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.util.matcher.AntPathRequestMatcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsCodeAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">AbstractAuthenticationProcessingFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_LOGIN_REQUEST_URL</span> <span class="operator">=</span> <span class="string">&quot;/sms/login&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HTTP_METHOD</span> <span class="operator">=</span> <span class="string">&quot;POST&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPRING_SECURITY_FORM_MOBILE_KEY</span> <span class="operator">=</span> <span class="string">&quot;mobile&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPRING_SECURITY_FORM_CODE_KEY</span> <span class="operator">=</span> <span class="string">&quot;code&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsCodeAuthenticationFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(DEFAULT_LOGIN_REQUEST_URL, HTTP_METHOD));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsCodeAuthenticationFilter</span><span class="params">(AuthenticationManager authenticationManager)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(DEFAULT_LOGIN_REQUEST_URL, HTTP_METHOD), authenticationManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="comment">// 从请求中提取手机号和验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mobile</span> <span class="operator">=</span> request.getParameter(SPRING_SECURITY_FORM_MOBILE_KEY);</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> request.getParameter(SPRING_SECURITY_FORM_CODE_KEY);</span><br><span class="line">        </span><br><span class="line">        mobile = (mobile != <span class="literal">null</span>) ? mobile.trim() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        code = (code != <span class="literal">null</span>) ? code : <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建未认证的 Token</span></span><br><span class="line">        <span class="type">SmsCodeAuthenticationToken</span> <span class="variable">authRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsCodeAuthenticationToken</span>(mobile, code);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将请求详情（如 IP 地址）设置到 Token 中</span></span><br><span class="line">        authRequest.setDetails(<span class="built_in">this</span>.authenticationDetailsSource.buildDetails(request));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 AuthenticationManager，发起认证</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 4: 将它们组装到 <code>SecurityFilterChain</code></strong></p>
<p>最后一步是将我们创建的这三个组件整合到安全配置中。这通常需要创建一个自定义的 <code>SecurityConfigurer</code>，或者直接在 <code>SecurityFilterChain</code> 中配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... (注入 UserDetailsService, SmsCodeService 等)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http, AuthenticationManager authenticationManager)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 创建并配置我们的 Filter</span></span><br><span class="line">        <span class="type">SmsCodeAuthenticationFilter</span> <span class="variable">smsCodeFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsCodeAuthenticationFilter</span>(authenticationManager);</span><br><span class="line">        <span class="comment">// (可选) 设置成功和失败的处理器</span></span><br><span class="line">        smsCodeFilter.setAuthenticationSuccessHandler(<span class="keyword">new</span> <span class="title class_">MyAuthenticationSuccessHandler</span>());</span><br><span class="line">        smsCodeFilter.setAuthenticationFailureHandler(<span class="keyword">new</span> <span class="title class_">MyAuthenticationFailureHandler</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 创建我们的 Provider</span></span><br><span class="line">        <span class="type">SmsCodeAuthenticationProvider</span> <span class="variable">smsCodeProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsCodeAuthenticationProvider</span>(userDetailsService, smsCodeService);</span><br><span class="line"></span><br><span class="line">        http</span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth.anyRequest().authenticated())</span><br><span class="line">            .formLogin(Customizer.withDefaults())</span><br><span class="line">            <span class="comment">// 3. 将我们的 Provider 添加到 AuthenticationManager 的管理中</span></span><br><span class="line">            .authenticationProvider(smsCodeProvider)</span><br><span class="line">            <span class="comment">// 4. 将我们的 Filter 添加到过滤器链的合适位置</span></span><br><span class="line">            .addFilterAfter(smsCodeFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManager</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> http.getSharedObject(AuthenticationManagerBuilder.class).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置解读</strong>:</p>
<ol>
<li>我们创建了 <code>SmsCodeAuthenticationFilter</code> 的实例。</li>
<li>我们创建了 <code>SmsCodeAuthenticationProvider</code> 的实例。</li>
<li>通过 <code>http.authenticationProvider(smsCodeProvider)</code>，我们将自定义的 Provider 注册到了 <code>ProviderManager</code> 中。现在 <code>ProviderManager</code> 在遍历时就能找到它了。</li>
<li>通过 <code>http.addFilterAfter(smsCodeFilter, ...)</code>，我们将自定义的 Filter 插入到了过滤器链中。放在 <code>UsernamePasswordAuthenticationFilter</code> 之后意味着，如果请求不是 <code>/sms/login</code>，它会继续被后面的过滤器处理（如表单登录过滤器）。</li>
</ol>
<p>现在，当用户向 <code>POST /sms/login</code> 发送包含 <code>mobile</code> 和 <code>code</code> 参数的请求时，你的自定义认证流程就会被完整地触发！</p>
<hr>
<p><strong>其他场景的思路</strong>:</p>
<ul>
<li><strong>扫码登录</strong>:<ol>
<li><strong>Filter</strong>: 拦截一个轮询接口（如 <code>/check-scan-status?ticket=xxx</code>）。</li>
<li><strong>Token</strong>: 包含一个一次性的 <code>ticket</code>。</li>
<li><strong>Provider</strong>: 认证逻辑是检查这个 <code>ticket</code> 对应的扫码状态（在 Redis 或数据库中）是否已被 App 端确认为“已扫码并同意登录”。如果确认，则加载用户信息，认证成功。</li>
</ol>
</li>
<li><strong>内部系统免密认证</strong>:<ol>
<li><strong>Filter</strong>: 从请求头或参数中提取一个预共享密钥或内部服务 Token。</li>
<li><strong>Token</strong>: 包含这个密钥。</li>
<li><strong>Provider</strong>: 认证逻辑是验证这个密钥是否有效，如果有效，则直接认证通过，并为其赋予一个预设的系统角色。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="6-3-自定义认证成功-失败处理器"><a href="#6-3-自定义认证成功-失败处理器" class="headerlink" title="6.3 自定义认证成功&#x2F;失败处理器"></a>6.3 自定义认证成功&#x2F;失败处理器</h3><p>在 Spring Security 的认证流程中，当 <code>AbstractAuthenticationProcessingFilter</code>（如 <code>UsernamePasswordAuthenticationFilter</code>）收到 <code>AuthenticationManager</code> 的认证结果后，它不会自己决定接下来该做什么，而是将后续处理委托给两个专门的策略接口：</p>
<ul>
<li><strong><code>AuthenticationSuccessHandler</code></strong>: 当认证<strong>成功</strong>时被调用。</li>
<li><strong><code>AuthenticationFailureHandler</code></strong>: 当认证<strong>失败</strong>时被调用。</li>
</ul>
<p>通过实现这两个接口，我们可以完全掌控认证成功或失败后的行为，例如返回自定义的 JSON、记录日志、更新用户统计数据等。</p>
<h4 id="6-3-1-AuthenticationSuccessHandler-处理认证成功"><a href="#6-3-1-AuthenticationSuccessHandler-处理认证成功" class="headerlink" title="6.3.1 AuthenticationSuccessHandler: 处理认证成功"></a>6.3.1 <code>AuthenticationSuccessHandler</code>: 处理认证成功</h4><h5 id="1-默认行为"><a href="#1-默认行为" class="headerlink" title="1. 默认行为"></a>1. 默认行为</h5><p>默认的 <code>SavedRequestAwareAuthenticationSuccessHandler</code> 非常智能，它会：</p>
<ol>
<li>检查 Session 中是否存在一个“被保存的请求”（<code>SavedRequest</code>）。这通常是用户在登录前尝试访问的那个受保护页面。</li>
<li>如果存在，它会将用户<strong>重定向到那个原始请求的 URL</strong>。</li>
<li>如果不存在（例如，用户是直接访问的登录页面），它会将用户重定向到一个配置好的<strong>默认成功 URL</strong>（通常是根路径 <code>/</code>）。</li>
</ol>
<p>这种行为非常适合传统的、基于页面的 Web 应用。</p>
<hr>
<h5 id="2-为什么需要自定义？"><a href="#2-为什么需要自定义？" class="headerlink" title="2. 为什么需要自定义？"></a>2. 为什么需要自定义？</h5><p>在前后端分离的架构中（例如 Vue&#x2F;React + Spring Boot API），前端发起登录请求后，期望的不是页面重定向，而是一个包含成功信息和 <strong>JWT (JSON Web Token)</strong> 的 <strong>JSON 响应</strong>。前端拿到这个 Token 后会将其存储起来，并在后续的 API 请求中携带。</p>
<hr>
<h5 id="3-实现登录成功后返回-JSON-Token"><a href="#3-实现登录成功后返回-JSON-Token" class="headerlink" title="3. 实现登录成功后返回 JSON Token"></a>3. 实现登录成功后返回 JSON Token</h5><p><strong>步骤 1: 创建 <code>AuthenticationSuccessHandler</code> 的实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AuthenticationSuccessHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthenticationSuccessHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtUtil jwtUtil; <span class="comment">// 注入我们之前创建的 JWT 工具类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper; <span class="comment">// Spring Boot 自动配置的 Jackson ObjectMapper</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                        HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                        Authentication authentication)</span></span><br><span class="line">                                        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 从 Authentication 对象生成 JWT</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> jwtUtil.generateToken(authentication);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 准备要返回的 JSON 数据</span></span><br><span class="line">        Map&lt;String, Object&gt; responseData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        responseData.put(<span class="string">&quot;code&quot;</span>, HttpStatus.OK.value());</span><br><span class="line">        responseData.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;Login successful&quot;</span>);</span><br><span class="line">        responseData.put(<span class="string">&quot;token&quot;</span>, token);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 设置响应头</span></span><br><span class="line">        response.setStatus(HttpStatus.OK.value());</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将 JSON 数据写入响应体</span></span><br><span class="line">        response.getWriter().write(objectMapper.writeValueAsString(responseData));</span><br><span class="line">        response.getWriter().flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：这里我们已经处理了响应，所以不需要再调用 filterChain.doFilter()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ul>
<li><code>onAuthenticationSuccess</code> 方法的 <code>authentication</code> 参数是<strong>已认证</strong>的 <code>Authentication</code> 对象，包含了用户的 <code>UserDetails</code> 和权限信息。</li>
<li>我们利用 <code>JwtUtil</code> 为这个已认证的用户生成一个 JWT。</li>
<li>然后构建一个包含 Token 和成功信息的 Map。</li>
<li>最后，使用 <code>ObjectMapper</code> 将 Map 序列化为 JSON 字符串，并写入 <code>HttpServletResponse</code>。</li>
</ul>
<p><strong>步骤 2: 在安全配置中应用</strong></p>
<p>将我们自定义的 Handler 应用到 <code>.formLogin()</code> 配置中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">            .requestMatchers(<span class="string">&quot;/login&quot;</span>).permitAll()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">        )</span><br><span class="line">        .formLogin(form -&gt; form</span><br><span class="line">            .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>) <span class="comment">// 指定登录处理 URL</span></span><br><span class="line">            .successHandler(myAuthenticationSuccessHandler) <span class="comment">// ✨ 使用自定义的成功处理器</span></span><br><span class="line">            <span class="comment">// .failureHandler(...) // 稍后会添加失败处理器</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// ... (通常会禁用 csrf 和 session)</span></span><br><span class="line">        .csrf(csrf -&gt; csrf.disable())</span><br><span class="line">        .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，当用户通过 <code>POST /login</code> 成功登录后，他们将收到一个 JSON 响应，而不是被重定向。</p>
<hr>
<h4 id="6-3-2-AuthenticationFailureHandler-处理认证失败"><a href="#6-3-2-AuthenticationFailureHandler-处理认证失败" class="headerlink" title="6.3.2 AuthenticationFailureHandler: 处理认证失败"></a>6.3.2 <code>AuthenticationFailureHandler</code>: 处理认证失败</h4><h5 id="1-默认行为-1"><a href="#1-默认行为-1" class="headerlink" title="1. 默认行为"></a>1. 默认行为</h5><p>默认的 <code>SimpleUrlAuthenticationFailureHandler</code> 会将用户<strong>重定向</strong>到一个指定的失败 URL，通常是 <code>/login?error</code>。它还会在 Session 中存储导致失败的 <code>AuthenticationException</code>，以便在登录页面上可以显示具体的错误信息（如“密码错误”或“用户不存在”）。</p>
<hr>
<h5 id="2-为什么需要自定义？-1"><a href="#2-为什么需要自定义？-1" class="headerlink" title="2. 为什么需要自定义？"></a>2. 为什么需要自定义？</h5><p>同样，在 REST API 场景中，我们不希望重定向，而是希望返回一个包含详细错误信息的 <strong>JSON 响应</strong>，并附带一个合适的 HTTP 状态码（通常是 <code>401 Unauthorized</code>）。</p>
<hr>
<h5 id="3-实现登录失败后返回-JSON"><a href="#3-实现登录失败后返回-JSON" class="headerlink" title="3. 实现登录失败后返回 JSON"></a>3. 实现登录失败后返回 JSON</h5><p><strong>步骤 1: 创建 <code>AuthenticationFailureHandler</code> 的实现类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.AuthenticationFailureHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthenticationFailureHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationFailureHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                        HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                        AuthenticationException exception)</span></span><br><span class="line">                                        <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 准备要返回的 JSON 数据</span></span><br><span class="line">        Map&lt;String, Object&gt; responseData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        responseData.put(<span class="string">&quot;code&quot;</span>, HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">        responseData.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;Login failed: &quot;</span> + exception.getMessage());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 也可以根据不同的异常类型返回更具体的信息</span></span><br><span class="line">        <span class="comment">// if (exception instanceof BadCredentialsException) &#123; ... &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置响应头</span></span><br><span class="line">        response.setStatus(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 JSON 数据写入响应体</span></span><br><span class="line">        response.getWriter().write(objectMapper.writeValueAsString(responseData));</span><br><span class="line">        response.getWriter().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解读</strong>:</p>
<ul>
<li><code>onAuthenticationFailure</code> 方法的 <code>exception</code> 参数是导致认证失败的具体异常，例如 <code>BadCredentialsException</code>, <code>UsernameNotFoundException</code> 等。</li>
<li>我们可以利用 <code>exception.getMessage()</code> 来获取友好的错误提示。</li>
<li>我们构建了一个包含错误信息的 JSON，并以 <code>401</code> 状态码返回给前端。</li>
</ul>
<p><strong>步骤 2: 在安全配置中应用</strong></p>
<p>将失败处理器也添加到 <code>.formLogin()</code> 配置中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyAuthenticationFailureHandler myAuthenticationFailureHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        .formLogin(form -&gt; form</span><br><span class="line">            .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">            .successHandler(myAuthenticationSuccessHandler)</span><br><span class="line">            .failureHandler(myAuthenticationFailureHandler) <span class="comment">// ✨ 使用自定义的失败处理器</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-4-自定义-AccessDecisionManager-AuthorizationManager-高级"><a href="#6-4-自定义-AccessDecisionManager-AuthorizationManager-高级" class="headerlink" title="6.4 自定义 AccessDecisionManager &#x2F; AuthorizationManager (高级)"></a>6.4 自定义 <code>AccessDecisionManager</code> &#x2F; <code>AuthorizationManager</code> (高级)</h3><p>标准的安全配置（如 <code>.requestMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)</code>）是<strong>静态</strong>的。这些规则在应用启动时就被硬编码在配置中。然而，在许多复杂的企业级应用中，权限需求是<strong>动态</strong>的：</p>
<ul>
<li>权限本身是在数据库中配置的，可以由管理员在运行时添加、修改或删除。</li>
<li>一个 URL 的访问权限可能不仅仅依赖于用户的角色，还可能依赖于请求的参数、当前时间、用户所属的部门等多种动态因素。</li>
</ul>
<p>为了实现这种级别的动态授权，我们需要深入到 Spring Security 的决策核心，自定义 <code>AccessDecisionManager</code> (传统架构) 或 <code>AuthorizationManager</code> (现代架构)。</p>
<h4 id="6-4-1-现代架构-自定义-AuthorizationManager"><a href="#6-4-1-现代架构-自定义-AuthorizationManager" class="headerlink" title="6.4.1 现代架构: 自定义 AuthorizationManager"></a>6.4.1 现代架构: 自定义 <code>AuthorizationManager</code></h4><p>在 Spring Security 6+ 中，<code>AuthorizationManager</code> 是推荐的、更简洁的授权决策接口。自定义它通常是实现动态授权的首选方式。</p>
<p><strong>场景</strong>: 假设我们有一个权限管理系统，数据库中有一张 <code>permission</code> 表，存储了 URL 路径与所需权限的对应关系。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> permission (</span><br><span class="line">  id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">  url <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,      <span class="comment">-- 受保护的 URL 模式 (e.g., /api/users/**)</span></span><br><span class="line">  permission <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span> <span class="comment">-- 访问该 URL 所需的权限 (e.g., user:list)</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一个用户-角色表，一个角色-权限表 (此处简化，权限直接关联用户)</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> user_permissions (</span><br><span class="line">  username <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  permission <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>我们的目标是：当一个请求进来时，根据请求的 URL 从数据库中查出所需的权限，然后检查当前用户是否拥有该权限。</p>
<p><strong>步骤 1: 创建自定义 <code>AuthorizationManager</code></strong></p>
<p>我们需要创建一个类，实现 <code>AuthorizationManager&lt;RequestAuthorizationContext&gt;</code> 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authorization.AuthorizationDecision;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authorization.AuthorizationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.access.intercept.RequestAuthorizationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.AntPathMatcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicAuthorizationManager</span> <span class="keyword">implements</span> <span class="title class_">AuthorizationManager</span>&lt;RequestAuthorizationContext&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入用于查询数据库的服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PermissionService permissionService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AntPathMatcher</span> <span class="variable">antPathMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicAuthorizationManager</span><span class="params">(PermissionService permissionService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.permissionService = permissionService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizationDecision <span class="title function_">check</span><span class="params">(Supplier&lt;Authentication&gt; authenticationSupplier, RequestAuthorizationContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取当前请求的 HttpServletRequest 对象</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> context.getRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestUrl</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 从数据库中查询所有已配置的 URL 权限规则</span></span><br><span class="line">        Collection&lt;Permission&gt; allPermissions = permissionService.getAllPermissions();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 遍历所有规则，找到与当前请求 URL 匹配的规则</span></span><br><span class="line">        <span class="keyword">for</span> (Permission permission : allPermissions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (antPathMatcher.match(permission.getUrl(), requestUrl)) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 4. 如果找到匹配规则，获取当前用户的认证信息</span></span><br><span class="line">                <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> authenticationSupplier.get();</span><br><span class="line">                <span class="keyword">if</span> (authentication == <span class="literal">null</span> || !authentication.isAuthenticated()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthorizationDecision</span>(<span class="literal">false</span>); <span class="comment">// 未认证用户直接拒绝</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5. 检查用户是否拥有该规则所要求的权限</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">requiredPermission</span> <span class="operator">=</span> permission.getPermission();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">hasPermission</span> <span class="operator">=</span> authentication.getAuthorities().stream()</span><br><span class="line">                        .anyMatch(grantedAuthority -&gt; grantedAuthority.getAuthority().equals(requiredPermission));</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 6. 返回决策结果</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthorizationDecision</span>(hasPermission);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 如果没有匹配到任何已配置的规则，可以采取默认策略</span></span><br><span class="line">        <span class="comment">// 例如，默认拒绝 (更安全)，或者允许 (如果你的系统有大量公共接口)</span></span><br><span class="line">        <span class="comment">// 这里我们选择默认拒绝未明确配置的 URL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AuthorizationDecision</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>PermissionService</code> (示意)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PermissionService</span> &#123;</span><br><span class="line">    <span class="comment">// 这是一个示例，实际应从数据库查询</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;Permission&gt; <span class="title function_">getAllPermissions</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在实际应用中，这里应该有缓存以提高性能</span></span><br><span class="line">        <span class="keyword">return</span> List.of(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Permission</span>(<span class="string">&quot;/api/users/**&quot;</span>, <span class="string">&quot;user:list&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Permission</span>(<span class="string">&quot;/api/orders/**&quot;</span>, <span class="string">&quot;order:manage&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2: 在安全配置中使用自定义 <code>AuthorizationManager</code></strong></p>
<p>现在，我们可以在 <code>SecurityFilterChain</code> 中使用这个自定义的 <code>AuthorizationManager</code> 来保护所有请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DynamicAuthorizationManager dynamicAuthorizationManager;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">        .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">            <span class="comment">// 将所有请求的授权决策委托给我们自定义的 Manager</span></span><br><span class="line">            .anyRequest().access(dynamicAuthorizationManager)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// ... 其他配置</span></span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>.anyRequest().access(dynamicAuthorizationManager)</code>，我们告诉 Spring Security：“对于任何请求，都不要使用 <code>hasRole</code>, <code>permitAll</code> 等静态规则了，直接调用我的 <code>dynamicAuthorizationManager</code> 来做决定吧！”</p>
<p><strong>优势</strong>:</p>
<ul>
<li><strong>完全动态</strong>: 现在你可以通过修改数据库中的 <code>permission</code> 表来实时地更新应用的授权规则，无需重启应用。</li>
<li><strong>逻辑集中</strong>: 所有 URL 相关的授权逻辑都集中在 <code>DynamicAuthorizationManager</code> 中，便于管理和审计。</li>
<li><strong>无限扩展</strong>: 你可以在 <code>check</code> 方法中实现任意复杂的逻辑，比如结合请求参数、请求头、当前时间等因素来做决策。</li>
</ul>
<hr>
<h4 id="6-4-2-传统架构-自定义-AccessDecisionManager-与-Voter"><a href="#6-4-2-传统架构-自定义-AccessDecisionManager-与-Voter" class="headerlink" title="6.4.2 传统架构: 自定义 AccessDecisionManager 与 Voter"></a><strong>6.4.2 传统架构: 自定义 <code>AccessDecisionManager</code> 与 <code>Voter</code></strong></h4><p>如果你正在维护一个老项目，或者需要实现更复杂的“投票”逻辑，你可能需要自定义 <code>AccessDecisionManager</code> 和 <code>Voter</code>。</p>
<p><strong>思路</strong>:</p>
<ol>
<li><strong>自定义 <code>FilterInvocationSecurityMetadataSource</code></strong>: 这个组件的职责是在 <code>AccessDecisionManager</code> 做决策之前，为它提供“决策所需的依据”（即 <code>ConfigAttribute</code>）。我们需要自定义它，让它根据请求的 URL 从数据库中查询出所需的权限，并封装成 <code>ConfigAttribute</code>。</li>
<li><strong>自定义 <code>AccessDecisionVoter</code></strong>: 创建一个 Voter，它能够理解我们自定义的 <code>ConfigAttribute</code>。它的 <code>vote</code> 方法会比较用户拥有的权限和 <code>ConfigAttribute</code> 中要求的权限。</li>
<li><strong>配置 <code>AccessDecisionManager</code></strong>: 将我们的自定义 Voter 配置到一个 <code>AccessDecisionManager</code> 中（例如 <code>AffirmativeBased</code>）。</li>
<li><strong>将它们整合到 <code>FilterSecurityInterceptor</code></strong>: 这是最终执行授权的过滤器。</li>
</ol>
<p>这个过程比自定义 <code>AuthorizationManager</code> 复杂得多，涉及的组件也更多。</p>
<p><strong>简化版自定义 <code>AccessDecisionManager</code> 示例</strong>:</p>
<p>我们也可以不使用 Voter，而是直接实现一个 <code>AccessDecisionManager</code>，将所有逻辑都放在里面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicAccessDecisionManager</span> <span class="keyword">implements</span> <span class="title class_">AccessDecisionManager</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... (注入 PermissionService, AntPathMatcher 等)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decide</span><span class="params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</span> </span><br><span class="line">            <span class="keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ((FilterInvocation) object).getRequest();</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestUrl</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... (与 DynamicAuthorizationManager 类似的逻辑) ...</span></span><br><span class="line">        <span class="comment">// 1. 查数据库，找到匹配的 requiredPermission</span></span><br><span class="line">        <span class="comment">// 2. 检查 authentication.getAuthorities() 是否包含 requiredPermission</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasPermission</span> <span class="operator">=</span> ...; <span class="comment">// 检查逻辑</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!hasPermission) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessDeniedException</span>(<span class="string">&quot;Access is denied.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有权限，则方法正常返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(ConfigAttribute attribute)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 支持所有类型的 ConfigAttribute</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FilterInvocation.class.isAssignableFrom(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置 (使用 <code>WebSecurityConfigurerAdapter</code> 的老式方法)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">        .withObjectPostProcessor(<span class="keyword">new</span> <span class="title class_">ObjectPostProcessor</span>&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;O <span class="keyword">extends</span> <span class="title class_">FilterSecurityInterceptor</span>&gt; O <span class="title function_">postProcess</span><span class="params">(O fsi)</span> &#123;</span><br><span class="line">                fsi.setAccessDecisionManager(<span class="keyword">new</span> <span class="title class_">DynamicAccessDecisionManager</span>());</span><br><span class="line">                <span class="comment">// fsi.setSecurityMetadataSource(...) 如果需要的话</span></span><br><span class="line">                <span class="keyword">return</span> fsi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .anyRequest().authenticated();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个配置方式比较晦涩，这也是 Spring Security 推荐迁移到 <code>AuthorizationManager</code> 的原因之一。</p>
<hr>
<h2 id="7-测试与最佳实践"><a href="#7-测试与最佳实践" class="headerlink" title="7. 测试与最佳实践"></a>7. 测试与最佳实践</h2><h3 id="7-1-Spring-Security-测试"><a href="#7-1-Spring-Security-测试" class="headerlink" title="7.1 Spring Security 测试"></a>7.1 Spring Security 测试</h3><p>在开发过程中，手动登录并测试每个受保护的端点既繁琐又容易出错。Spring Security 提供了强大的测试支持，允许我们编写自动化的集成测试，来验证我们的安全配置是否按预期工作。</p>
<h4 id="7-1-1-核心测试依赖"><a href="#7-1-1-核心测试依赖" class="headerlink" title="7.1.1 核心测试依赖"></a>7.1.1 核心测试依赖</h4><p>要进行 Spring Security 的测试，你需要确保项目中包含了以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot 的测试启动器，包含了 JUnit, Mockito, Spring Test 等 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Spring Security 的测试支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7-1-2-模拟已认证用户"><a href="#7-1-2-模拟已认证用户" class="headerlink" title="7.1.2 模拟已认证用户"></a>7.1.2 模拟已认证用户</h4><p><code>spring-security-test</code> 模块最核心的功能就是提供了一系列注解，让我们可以在测试方法运行时，轻松地**“伪造”**一个已认证的用户身份，而无需经过实际的登录流程。</p>
<h5 id="1-WithMockUser-最简单、最常用的模拟"><a href="#1-WithMockUser-最简单、最常用的模拟" class="headerlink" title="1. @WithMockUser: 最简单、最常用的模拟"></a>1. <code>@WithMockUser</code>: 最简单、最常用的模拟</h5><p>这个注解会在执行测试方法前，自动在 <code>SecurityContextHolder</code> 中放入一个模拟的 <code>Authentication</code> 对象。</p>
<p><strong>常用属性</strong>:</p>
<ul>
<li><code>username</code> &#x2F; <code>value</code>: 模拟的用户名（默认为 “user”）。</li>
<li><code>password</code>: 模拟的密码（默认为 “password”）。</li>
<li><code>roles</code>: 一个字符串数组，用于指定用户拥有的<strong>角色</strong>。<strong>注意</strong>: 你提供的角色名<strong>不需要</strong> <code>ROLE_</code> 前缀，注解会自动添加。</li>
<li><code>authorities</code>: 一个字符串数组，用于指定用户拥有的<strong>权限</strong>。这里的字符串会原样作为 <code>GrantedAuthority</code>。</li>
</ul>
<p><strong>示例</strong>:</p>
<p>假设我们有一个 <code>AdminController</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/dashboard&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAdminDashboard</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Welcome, Admin!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user-profile&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserProfile</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + authentication.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在来编写测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.test.context.support.WithMockUser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span> <span class="comment">// 自动配置 MockMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminControllerTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@WithMockUser(username = &quot;test_admin&quot;, roles = &#123;&quot;ADMIN&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">whenAdminAccessesDashboard_thenSucceeds</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/admin/dashboard&quot;</span>))</span><br><span class="line">               .andExpect(status().isOk())</span><br><span class="line">               .andExpect(content().string(<span class="string">&quot;Welcome, Admin!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@WithMockUser(username = &quot;test_user&quot;, roles = &#123;&quot;USER&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">whenUserAccessesDashboard_thenIsForbidden</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// test_user 只有 USER 角色，没有 ADMIN 角色</span></span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/admin/dashboard&quot;</span>))</span><br><span class="line">               .andExpect(status().isForbidden()); <span class="comment">// 期望得到 403 Forbidden</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@WithMockUser(username = &quot;john.doe&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">whenAnyAuthenticatedUserAccessesProfile_thenSucceeds</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/admin/user-profile&quot;</span>))</span><br><span class="line">               .andExpect(status().isOk())</span><br><span class="line">               .andExpect(content().string(<span class="string">&quot;Hello, john.doe&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@SpringBootTest</code>: 加载完整的 Spring 应用上下文。</li>
<li><code>@AutoConfigureMockMvc</code>: 自动注入 <code>MockMvc</code> Bean，这是我们模拟 HTTP 请求的入口。</li>
<li><code>@WithMockUser</code> 应用在测试方法上，为该次测试提供了一个临时的安全上下文。方法执行完毕后，上下文会自动清理。</li>
</ul>
<hr>
<h5 id="2-WithUserDetails-使用真实的-UserDetailsService"><a href="#2-WithUserDetails-使用真实的-UserDetailsService" class="headerlink" title="2. @WithUserDetails: 使用真实的 UserDetailsService"></a>2. <code>@WithUserDetails</code>: 使用真实的 <code>UserDetailsService</code></h5><p><code>@WithMockUser</code> 非常方便，但它创建的是一个<strong>完全模拟</strong>的用户，这个用户可能并不存在于你的数据库中。如果你希望测试的 <code>Authentication</code> 对象是由你自己的 <code>UserDetailsService</code> 加载而来的真实用户数据，你应该使用 <code>@WithUserDetails</code>。</p>
<p><strong>前提</strong>: 你必须已经实现了一个 <code>UserDetailsService</code> Bean。</p>
<p><strong>常用属性</strong>:</p>
<ul>
<li><code>value</code> &#x2F; <code>username</code>: 指定要加载的用户名。</li>
<li><code>userDetailsServiceBeanName</code>: (可选) 如果你有多个 <code>UserDetailsService</code> 的实现，可以用这个属性指定要使用哪一个 Bean。</li>
</ul>
<p><strong>示例</strong>:<br>假设你的 <code>JpaUserDetailsService</code> 会从数据库加载用户。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@WithUserDetails(&quot;real_admin_from_db&quot;)</span> <span class="comment">// 假设数据库中存在名为 &quot;real_admin_from_db&quot; 的用户</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenAuthenticatingWithRealUser_thenSucceeds</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 在这个测试方法中，SecurityContextHolder 中的 Principal</span></span><br><span class="line">    <span class="comment">// 将是一个由你的 JpaUserDetailsService.loadUserByUsername() 方法返回的真实 UserDetails 对象</span></span><br><span class="line">    </span><br><span class="line">    mockMvc.perform(get(<span class="string">&quot;/admin/dashboard&quot;</span>))</span><br><span class="line">           .andExpect(status().isOk());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong>: 这种方式的测试保真度更高，因为它使用了你的真实用户数据加载逻辑，可以一并测试 <code>UserDetailsService</code> 的正确性。</p>
<hr>
<h4 id="7-1-3-结合-MockMvc-测试-Controller-层的安全端点"><a href="#7-1-3-结合-MockMvc-测试-Controller-层的安全端点" class="headerlink" title="7.1.3 结合 MockMvc 测试 Controller 层的安全端点"></a>7.1.3 结合 <code>MockMvc</code> 测试 Controller 层的安全端点</h4><p><code>MockMvc</code> 是 Spring Test 框架提供的服务器端测试工具，它允许我们在不启动完整 Web 服务器的情况下，对 Controller 进行“真实”的 HTTP 请求调用。</p>
<h5 id="1-测试未认证的访问"><a href="#1-测试未认证的访问" class="headerlink" title="1. 测试未认证的访问"></a>1. 测试未认证的访问</h5><p>要测试匿名用户访问受保护的端点，非常简单：<strong>不使用任何 <code>@With...</code> 注解即可</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenAnonymousAccessesProtectedEndpoint_thenIsRedirectedToLogin</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 假设我们配置了 Form Login</span></span><br><span class="line">    mockMvc.perform(get(<span class="string">&quot;/admin/dashboard&quot;</span>))</span><br><span class="line">           .andExpect(status().is3xxRedirection()) <span class="comment">// 期望 3xx 重定向</span></span><br><span class="line">           .andExpect(redirectedUrl(<span class="string">&quot;http://localhost/login&quot;</span>)); <span class="comment">// 期望重定向到登录页</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenAnonymousAccessesApiEndpoint_thenIsUnauthorized</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 假设 /api/data 是受保护的，且异常处理器会返回 401</span></span><br><span class="line">    mockMvc.perform(get(<span class="string">&quot;/api/data&quot;</span>))</span><br><span class="line">           .andExpect(status().isUnauthorized()); <span class="comment">// 期望 401 Unauthorized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-测试-CSRF-防护"><a href="#2-测试-CSRF-防护" class="headerlink" title="2. 测试 CSRF 防护"></a>2. 测试 CSRF 防护</h5><p>当你的应用开启了 CSRF 防护时，所有“不安全”的请求（POST, PUT, DELETE）都必须携带有效的 CSRF Token。<code>spring-security-test</code> 提供了 <code>csrf()</code> 请求后处理器来自动处理这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@WithMockUser</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenPostingWithCsrfToken_thenSucceeds</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    mockMvc.perform(post(<span class="string">&quot;/transfer&quot;</span>)</span><br><span class="line">                .param(<span class="string">&quot;amount&quot;</span>, <span class="string">&quot;100&quot;</span>)</span><br><span class="line">                .with(csrf())) <span class="comment">// ✨ 添加一个有效的 CSRF Token</span></span><br><span class="line">           .andExpect(status().isOk());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@WithMockUser</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenPostingWithoutCsrfToken_thenIsForbidden</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    mockMvc.perform(post(<span class="string">&quot;/transfer&quot;</span>)</span><br><span class="line">                .param(<span class="string">&quot;amount&quot;</span>, <span class="string">&quot;100&quot;</span>))</span><br><span class="line">                <span class="comment">// 没有 .with(csrf())</span></span><br><span class="line">           .andExpect(status().isForbidden()); <span class="comment">// 期望 403 Forbidden</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>with(csrf())</code> 会自动模拟一个合法的 CSRF Token 并将其放入请求中，让你的测试能够顺利通过 CSRF 过滤器的检查。</p>
<hr>
<h5 id="3-测试表单登录"><a href="#3-测试表单登录" class="headerlink" title="3. 测试表单登录"></a>3. 测试表单登录</h5><p><code>spring-security-test</code> 还提供了一个便捷的 <code>formLogin()</code> 请求处理器来模拟完整的表单登录流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestBuilders.formLogin;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.authenticated;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.unauthenticated;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenLoginWithValidCredentials_thenIsAuthenticated</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    mockMvc.perform(formLogin(<span class="string">&quot;/login&quot;</span>).user(<span class="string">&quot;user&quot;</span>).password(<span class="string">&quot;password&quot;</span>)) <span class="comment">// 模拟表单登录</span></span><br><span class="line">           .andExpect(status().is3xxRedirection())</span><br><span class="line">           .andExpect(redirectedUrl(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">           .andExpect(authenticated().withUsername(<span class="string">&quot;user&quot;</span>)); <span class="comment">// 验证认证成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">whenLoginWithInvalidCredentials_thenIsUnauthenticated</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    mockMvc.perform(formLogin(<span class="string">&quot;/login&quot;</span>).user(<span class="string">&quot;user&quot;</span>).password(<span class="string">&quot;wrongpassword&quot;</span>))</span><br><span class="line">           .andExpect(status().is3xxRedirection())</span><br><span class="line">           .andExpect(redirectedUrl(<span class="string">&quot;/login?error&quot;</span>))</span><br><span class="line">           .andExpect(unauthenticated()); <span class="comment">// 验证认证失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>formLogin()</code> 极大地简化了登录接口的测试，同时 <code>authenticated()</code> 和 <code>unauthenticated()</code> 断言也让结果验证更清晰。</p>
<hr>
<h3 id="7-2-安全最佳实践"><a href="#7-2-安全最佳实践" class="headerlink" title="7.2 安全最佳实践"></a>7.2 安全最佳实践</h3><p>仅仅正确配置 Spring Security 是不够的，一个安全的应用是一个系统工程，需要遵循一系列业界公认的最佳实践。</p>
<h4 id="7-2-1-始终使用-HTTPS"><a href="#7-2-1-始终使用-HTTPS" class="headerlink" title="7.2.1 始终使用 HTTPS"></a>7.2.1 始终使用 HTTPS</h4><p><strong>为什么？</strong></p>
<p>未使用 HTTPS 的 HTTP 协议是<strong>明文传输</strong>的。这意味着在客户端和服务器之间传输的所有数据，包括用户名、密码、Session Cookie、JWT Token 以及任何敏感的业务数据，都可能被网络中间人（如同一 WiFi 下的攻击者、ISP、网络节点）轻易地窃听和截获。这就是所谓的<strong>中间人攻击 (Man-in-the-Middle, MITM)</strong>。</p>
<p><strong>如何做？</strong></p>
<ul>
<li><p><strong>生产环境强制 HTTPS</strong>: 必须为你的生产环境配置 SSL&#x2F;TLS 证书。现在有许多免费的证书颁发机构（如 Let’s Encrypt），获取证书非常方便。</p>
</li>
<li><p><strong>配置 Spring Boot 开启 SSL</strong>: 在 <code>application.properties</code> 或 <code>yml</code> 中配置服务器 SSL 属性。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.ssl.key-store</span>=<span class="string">classpath:keystore.p12</span></span><br><span class="line"><span class="attr">server.ssl.key-store-password</span>=<span class="string">your-password</span></span><br><span class="line"><span class="attr">server.ssl.key-alias</span>=<span class="string">your-alias</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>HTTP 到 HTTPS 的自动重定向</strong>: 配置你的 Web 服务器（如 Nginx）或应用网关，将所有传入的 HTTP 请求（端口 80）自动重定向到 HTTPS（端口 443）。在 Spring Security 中，你也可以配置来实现这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.requiresChannel(channel -&gt; channel.anyRequest().requiresSecure());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 HSTS (HTTP Strict Transport Security)</strong>: 在响应头中添加 <code>Strict-Transport-Security</code>。这会告诉浏览器，在未来的一段时间内，所有对该域名的访问都<strong>必须</strong>使用 HTTPS，从而防止 SSL 剥离攻击。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http.headers(headers -&gt; headers</span><br><span class="line">    .httpStrictTransportSecurity(hsts -&gt; hsts</span><br><span class="line">        .includeSubDomains(<span class="literal">true</span>)</span><br><span class="line">        .maxAgeInSeconds(<span class="number">31536000</span>)</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="7-2-2-使用强大的密码编码策略"><a href="#7-2-2-使用强大的密码编码策略" class="headerlink" title="7.2.2 使用强大的密码编码策略"></a>7.2.2 使用强大的密码编码策略</h4><p><strong>为什么？</strong></p>
<p>正如 <code>2.3</code> 节所述，明文存储密码是灾难性的。即使是使用过时的哈希算法（如 MD5, SHA-1）也无法有效抵御现代的破解技术。一个强大的密码策略能够确保即使数据库被泄露，用户的原始密码也不会暴露。</p>
<p><strong>如何做？</strong></p>
<ul>
<li><p><strong>选择合适的算法</strong>:</p>
<ul>
<li><strong>首选 <code>BCryptPasswordEncoder</code></strong>: 它是目前功能、安全性和易用性之间最好的平衡点，是绝大多数新项目的默认选择。</li>
<li>如果对安全有更高要求，可以考虑 <code>SCryptPasswordEncoder</code> 或 <code>Argon2PasswordEncoder</code>。</li>
</ul>
</li>
<li><p><strong>使用 <code>DelegatingPasswordEncoder</code></strong>: 这是 Spring Security 的默认行为，也是最佳实践。它允许你平滑地升级密码存储算法，而无需强制所有用户重置密码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spring Boot 会自动配置这个，你只需要提供一个具体的 Encoder Bean 即可</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>调整工作因子</strong>: 对于 <code>BCryptPasswordEncoder</code>，可以根据你的服务器性能调整其构造函数中的 <code>strength</code> 参数（默认为 10）。这个值越高，哈希计算越慢，暴力破解的难度就越大。你应该选择一个既能提供足够安全性，又不会导致登录响应时间过长的值。</p>
</li>
</ul>
<hr>
<h4 id="7-2-3-最小权限原则-Principle-of-Least-Privilege"><a href="#7-2-3-最小权限原则-Principle-of-Least-Privilege" class="headerlink" title="7.2.3 最小权限原则 (Principle of Least Privilege)"></a>7.2.3 最小权限原则 (Principle of Least Privilege)</h4><p><strong>为什么？</strong></p>
<p>这个原则要求任何用户、程序或进程只应拥有其完成任务所必需的最小权限集合。如果一个账户（无论是用户还是系统服务）被盗用，最小权限原则可以极大地限制攻击者能够造成的损害范围。</p>
<p><strong>如何做？</strong></p>
<ul>
<li><strong>避免使用“超级管理员”</strong>: 不要创建一个可以为所欲为的 <code>SUPER_ADMIN</code> 角色，然后把它分配给所有需要管理权限的用户。</li>
<li><strong>基于角色的访问控制 (RBAC)</strong>: 将权限（细粒度的操作许可，如 <code>user:create</code>, <code>order:approve</code>）分配给角色（职责集合，如 <code>USER_MANAGER</code>, <code>ORDER_APPROVER</code>），再将角色分配给用户。</li>
<li><strong>默认拒绝</strong>: 你的授权策略应该是“默认拒绝，明确允许”。对于任何未明确配置权限的资源，都应该默认拒绝访问。在 Spring Security 中，这通常通过在授权规则链的末尾加上 <code>.anyRequest().authenticated()</code> 或 <code>.anyRequest().denyAll()</code> 来实现。</li>
<li><strong>为 API 客户端授权</strong>: 当使用客户端凭证模式为后台服务授权时，也应遵循最小权限原则。例如，一个“报表生成服务”只应被授予读取相关数据的权限，而绝不应该有写入或删除的权限。</li>
</ul>
<hr>
<h4 id="7-2-4-依赖项安全扫描"><a href="#7-2-4-依赖项安全扫描" class="headerlink" title="7.2.4 依赖项安全扫描"></a>7.2.4 依赖项安全扫描</h4><p><strong>为什么？</strong></p>
<p>你的应用不仅仅是你自己写的代码。它构建在大量的开源第三方库（依赖项）之上。这些依赖项可能存在已知的安全漏洞（CVEs - Common Vulnerabilities and Exposures）。攻击者常常利用这些公开的漏洞来攻击系统。</p>
<p><strong>如何做？</strong></p>
<ul>
<li><strong>使用自动化扫描工具</strong>:<ul>
<li><strong>Maven</strong>: 使用 <code>dependency-check-maven</code> 插件。</li>
<li><strong>Gradle</strong>: 使用 <code>dependency-check-gradle</code> 插件。</li>
<li><strong>GitHub</strong>: 启用 <strong>Dependabot</strong>，它可以自动扫描你的依赖项，并在发现漏洞时创建 Pull Request 来更新到安全版本。</li>
<li><strong>商业工具</strong>: Snyk, Sonatype Nexus Lifecycle 等提供了更强大的扫描和管理功能。</li>
</ul>
</li>
<li><strong>保持依赖项更新</strong>: 定期（例如，在每个 sprint 开始时）检查并更新你的项目依赖到一个新的稳定版本。这不仅能修复已知的安全漏洞，还能获得性能改进和新功能。</li>
<li><strong>订阅安全通告</strong>: 关注你所使用的核心框架（如 Spring, Log4j）的安全邮件列表或公告，以便在出现严重漏洞（如 Log4Shell）时能第一时间响应。</li>
</ul>
<hr>
<h4 id="7-2-5-避免在日志中记录敏感信息"><a href="#7-2-5-避免在日志中记录敏感信息" class="headerlink" title="7.2.5 避免在日志中记录敏感信息"></a>7.2.5 避免在日志中记录敏感信息</h4><p><strong>为什么？</strong></p>
<p>日志是排查问题的重要工具，但也可能成为敏感信息泄露的源头。如果在日志中不慎打印了用户密码、Session ID、API Key、信用卡号、个人身份信息等，这些信息可能会被存储在日志文件、日志管理系统（如 ELK Stack）中，从而扩大了攻击面。任何能够访问日志系统的人都可能获取到这些敏感数据。</p>
<p><strong>如何做？</strong></p>
<ul>
<li><p><strong>重写 <code>toString()</code> 方法</strong>: 对于包含敏感数据的 DTO 或实体类（如 <code>User</code>），务必重写其 <code>toString()</code> 方法，对敏感字段进行屏蔽。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegistrationDto</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserRegistrationDto&#123;&quot;</span> +</span><br><span class="line">               <span class="string">&quot;username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">               <span class="string">&quot;, password=&#x27;[PROTECTED]&#x27;&quot;</span> +</span><br><span class="line">               <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Lombok 的 <code>@ToString(exclude = {&quot;password&quot;})</code> 是一个更简洁的方式。</p>
</li>
<li><p><strong>审查日志输出</strong>: 在代码审查（Code Review）时，特别注意 <code>logger.info()</code>, <code>System.out.println()</code> 等输出语句，确保它们没有直接打印包含敏感信息的完整对象或请求体。</p>
</li>
<li><p><strong>配置日志框架</strong>: 一些日志框架允许配置过滤器，自动屏蔽匹配特定模式（如信用卡号格式）的字符串。</p>
</li>
<li><p><strong>Spring Boot Actuator</strong>: 如果你使用了 Actuator 的 <code>/trace</code> 或 <code>/httptrace</code> 端点，要注意它默认可能会记录请求头和响应头。检查其配置，确保像 <code>Authorization</code> 或 <code>Cookie</code> 这样的敏感头信息被屏蔽了。</p>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringData/" rel="prev" title="Spring全家桶-SpringData">
                  <i class="fa fa-angle-left"></i> Spring全家桶-SpringData
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/10/09/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/JavaServlet/" rel="next" title="JavaServlet">
                  JavaServlet <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
