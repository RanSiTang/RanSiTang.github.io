<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="一、JVM 基础入门1. JVM是什么？从宏观上讲，Java虚拟机（JVM）是一个可以执行Java字节码的虚拟计算机。它是Java技术的核心，也是实现Java“跨平台”特性的关键。JVM有自己完善的硬件架构（如处理器、堆栈、寄存器等），以及相应的指令系统。 1.1 JVM、JRE、JDK 的关系与区别1.1.1 核心概念1. JDK (Java Development Kit - Java开发工具">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://example.com/2025/10/27/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/JVM/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="一、JVM 基础入门1. JVM是什么？从宏观上讲，Java虚拟机（JVM）是一个可以执行Java字节码的虚拟计算机。它是Java技术的核心，也是实现Java“跨平台”特性的关键。JVM有自己完善的硬件架构（如处理器、堆栈、寄存器等），以及相应的指令系统。 1.1 JVM、JRE、JDK 的关系与区别1.1.1 核心概念1. JDK (Java Development Kit - Java开发工具">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-27T11:08:27.000Z">
<meta property="article:modified_time" content="2025-10-30T01:28:31.915Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/10/27/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/JVM/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/10/27/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/JVM/","path":"2025/10/27/基础核心层/JVM/","title":"JVM"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JVM | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81JVM-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8"><span class="nav-text">一、JVM 基础入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-JVM%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1. JVM是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-JVM%E3%80%81JRE%E3%80%81JDK-%E7%9A%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="nav-text">1.1 JVM、JRE、JDK 的关系与区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">1.1.1 核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-JDK-Java-Development-Kit-Java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85"><span class="nav-text">1. JDK (Java Development Kit - Java开发工具包)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-JRE-Java-Runtime-Environment-Java%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="nav-text">2. JRE (Java Runtime Environment - Java运行环境)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-JVM-Java-Virtual-Machine-Java%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-text">3. JVM (Java Virtual Machine - Java虚拟机)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93"><span class="nav-text">1.1.2 关系总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E2%80%9C%E4%B8%80%E6%AC%A1%E7%BC%96%E5%86%99%EF%BC%8C%E5%88%B0%E5%A4%84%E8%BF%90%E8%A1%8C%E2%80%9D-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">1.2 “一次编写，到处运行” 的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">1.2.1 核心思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3"><span class="nav-text">1.2.2 原理图解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E6%80%BB%E7%BB%93"><span class="nav-text">1.2.3 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E4%B8%BB%E6%B5%81%E7%9A%84JVM%E5%AE%9E%E7%8E%B0"><span class="nav-text">1.3 主流的JVM实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-HotSpot-VM"><span class="nav-text">1.3.1 HotSpot VM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-GraalVM"><span class="nav-text">1.3.2 GraalVM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3-OpenJ9"><span class="nav-text">1.3.3 OpenJ9</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-4-Alibaba-Dragonwell-%E9%98%BF%E9%87%8C%E9%BE%99%E4%BA%95"><span class="nav-text">1.3.4 Alibaba Dragonwell (阿里龙井)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E7%9A%84JVM%E4%B9%8B%E6%97%85"><span class="nav-text">2. 第一个Java程序的JVM之旅</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%BB%8E-java-%E6%96%87%E4%BB%B6%E5%88%B0-class-%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="nav-text">2.1 从 .java 文件到 .class 文件的编译过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-Lexical-Analysis-Scanning"><span class="nav-text">2.1.1 词法分析 (Lexical Analysis &#x2F; Scanning)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-Syntax-Analysis-Parsing"><span class="nav-text">2.1.2 语法分析 (Syntax Analysis &#x2F; Parsing)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90-Semantic-Analysis"><span class="nav-text">2.1.3 语义分析 (Semantic Analysis)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-%E5%AD%97%E8%8A%82%E7%A0%81%E7%94%9F%E6%88%90-Bytecode-Generation"><span class="nav-text">2.1.4 字节码生成 (Bytecode Generation)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-class-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%9D%E6%8E%A2-%E9%AD%94%E6%95%B0%E3%80%81%E7%89%88%E6%9C%AC%E5%8F%B7%E3%80%81%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%AD%89"><span class="nav-text">2.2 .class 文件结构初探 (魔数、版本号、常量池等)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E9%AD%94%E6%95%B0-Magic-Number"><span class="nav-text">2.2.1 魔数 (Magic Number)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E7%89%88%E6%9C%AC%E5%8F%B7-Version"><span class="nav-text">2.2.2 版本号 (Version)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E5%B8%B8%E9%87%8F%E6%B1%A0-Constant-Pool"><span class="nav-text">2.2.3 常量池 (Constant Pool)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-%E5%85%B6%E4%BB%96%E5%85%B3%E9%94%AE%E9%83%A8%E5%88%86"><span class="nav-text">2.2.4 其他关键部分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-java-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%90%8E%EF%BC%8CJVM%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88"><span class="nav-text">2.3 java 命令执行后，JVM的启动流程概览</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E5%88%9B%E5%BB%BAJVM%E5%AE%9E%E4%BE%8B"><span class="nav-text">2.3.1 创建JVM实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E5%88%9B%E5%BB%BA%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8A%A0%E8%BD%BD%E4%B8%BB%E7%B1%BB"><span class="nav-text">2.3.2 创建主线程并加载主类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-%E5%AF%BB%E6%89%BE%E5%B9%B6%E6%89%A7%E8%A1%8Cmain%E6%96%B9%E6%B3%95"><span class="nav-text">2.3.3 寻找并执行main方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C"><span class="nav-text">2.3.4 开始执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-5-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9D%9F%EF%BC%8CJVM%E5%85%B3%E9%97%AD"><span class="nav-text">2.3.5 程序结束，JVM关闭</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81JVM-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90"><span class="nav-text">二、JVM 核心原理深度剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="nav-text">1. JVM 内存区域 (运行时数据区)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E5%8C%BA%E5%9F%9F"><span class="nav-text">1.1 线程私有区域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-Program-Counter-Register"><span class="nav-text">1.1.1 程序计数器 (Program Counter Register)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88-Java-Virtual-Machine-Stack"><span class="nav-text">1.1.2 Java 虚拟机栈 (Java Virtual Machine Stack)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-Native-Method-Stack"><span class="nav-text">1.1.3 本地方法栈 (Native Method Stack)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-4-%E6%80%BB%E7%BB%93%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E5%8C%BA"><span class="nav-text">1.1.4 总结线程私有区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%8C%BA%E5%9F%9F"><span class="nav-text">1.2 线程共享区域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-Java-%E5%A0%86-Heap"><span class="nav-text">1.2.1 Java 堆 (Heap)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E6%96%B9%E6%B3%95%E5%8C%BA-Method-Area"><span class="nav-text">1.2.2 方法区 (Method Area)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E6%80%BB%E7%BB%93%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%8C%BA%E5%9F%9F"><span class="nav-text">1.2.3 总结线程共享区域</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E9%87%8D%E7%82%B9%E8%BE%A8%E6%9E%90"><span class="nav-text">1.3 重点辨析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-%E5%A0%86-Heap-%E4%B8%8E-%E6%A0%88-Stack-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="nav-text">1.3.1 堆 (Heap) 与 栈 (Stack) 的核心区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-%E6%B0%B8%E4%B9%85%E4%BB%A3-PermGen-vs-%E5%85%83%E7%A9%BA%E9%97%B4-Metaspace-%E7%9A%84%E6%BC%94%E8%BF%9B%E4%B8%8E%E5%B7%AE%E5%BC%82"><span class="nav-text">1.3.2 永久代 (PermGen) vs. 元空间 (Metaspace) 的演进与差异</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98-Direct-Memory"><span class="nav-text">1.4 直接内存 (Direct Memory)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-HotSpot%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">2. HotSpot中的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B-new%E6%8C%87%E4%BB%A4%E3%80%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">2.1 对象的创建过程 (new指令、分配内存、初始化)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E6%80%BB%E8%A7%88%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-text">2.1.1 总览流程图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4%E5%88%86%E8%A7%A3"><span class="nav-text">2.1.2 详细步骤分解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%9F%A5-Class-Loading-Check"><span class="nav-text">1. 类加载检查 (Class Loading Check)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98-Memory-Allocation"><span class="nav-text">2. 分配内存 (Memory Allocation)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B6%E5%80%BC-Zero-Value-Initialization"><span class="nav-text">3. 初始化零值 (Zero-Value Initialization)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%A4%B4-Setting-the-Object-Header"><span class="nav-text">4. 设置对象头 (Setting the Object Header)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%89%A7%E8%A1%8C-%E6%96%B9%E6%B3%95-Constructor-Execution"><span class="nav-text">5. 执行 &lt;init&gt; 方法 (Constructor Execution)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80-%E5%AF%B9%E8%B1%A1%E5%A4%B4%E3%80%81%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE%E3%80%81%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85"><span class="nav-text">2.2 对象的内存布局 (对象头、实例数据、对齐填充)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E5%AF%B9%E8%B1%A1%E5%A4%B4-Object-Header"><span class="nav-text">2.2.1 对象头 (Object Header)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Mark-Word-%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5"><span class="nav-text">1. Mark Word (标记字段)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Klass-Pointer-%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88-Class-Pointer"><span class="nav-text">2. Klass Pointer (类型指针 &#x2F; Class Pointer)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6-Array-Length"><span class="nav-text">3. 数组长度 (Array Length)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE-Instance-Data"><span class="nav-text">2.2.2 实例数据 (Instance Data)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85-Padding"><span class="nav-text">2.2.3 对齐填充 (Padding)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE-vs-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE"><span class="nav-text">2.3 对象的访问定位 (句柄访问 vs. 直接指针访问)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE-Handle-Access"><span class="nav-text">2.3.1 句柄访问 (Handle Access)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE-Direct-Pointer-Access"><span class="nav-text">2.3.2 直接指针访问 (Direct Pointer Access)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-text">2.3.4 HotSpot虚拟机的选择</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-Garbage-Collection"><span class="nav-text">3. 垃圾回收 (Garbage Collection)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E9%9C%80%E8%A6%81%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="nav-text">3.1 如何判断对象需要被回收？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95-%E5%8F%8A%E5%85%B6%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98"><span class="nav-text">3.1.1 引用计数法 (及其循环引用问题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95-GC-Roots"><span class="nav-text">3.1.2 可达性分析算法 (GC Roots)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9A%E5%BC%BA%E3%80%81%E8%BD%AF%E3%80%81%E5%BC%B1%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">3.2 Java的四种引用类型：强、软、弱、虚引用及其应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E5%BC%BA%E5%BC%95%E7%94%A8-Strong-Reference"><span class="nav-text">3.2.1 强引用 (Strong Reference)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E8%BD%AF%E5%BC%95%E7%94%A8-Soft-Reference"><span class="nav-text">3.2.2 软引用 (Soft Reference)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E5%BC%B1%E5%BC%95%E7%94%A8-Weak-Reference"><span class="nav-text">3.2.3 弱引用 (Weak Reference)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-%E8%99%9A%E5%BC%95%E7%94%A8-Phantom-Reference"><span class="nav-text">3.2.4 虚引用 (Phantom Reference)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-text">3.3 经典垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4-Mark-Sweep-%E7%AE%97%E6%B3%95"><span class="nav-text">3.3.1 标记-清除 (Mark-Sweep) 算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6-Mark-Copy-%E7%AE%97%E6%B3%95"><span class="nav-text">3.3.2 标记-复制 (Mark-Copy) 算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86-Mark-Compact-%E7%AE%97%E6%B3%95"><span class="nav-text">3.3.3 标记-整理 (Mark-Compact) 算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-%E6%80%BB%E7%BB%93%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">3.3.4 总结和应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E6%80%9D%E6%83%B3%EF%BC%9A%E6%96%B0%E7%94%9F%E4%BB%A3-Eden-S0-S1-%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-text">3.4 分代收集思想：新生代 (Eden, S0, S1) 与老年代</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-%E6%80%9D%E6%83%B3%E7%9A%84%E6%9D%A5%E6%BA%90"><span class="nav-text">3.4.1 思想的来源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-%E5%88%86%E4%BB%A3%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-text">3.4.2 分代设计：新生代与老年代</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%96%B0%E7%94%9F%E4%BB%A3-Young-Generation"><span class="nav-text">1. 新生代 (Young Generation)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%80%81%E5%B9%B4%E4%BB%A3-Old-Generation"><span class="nav-text">2. 老年代 (Old Generation)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E2%80%9C%E4%B8%80%E7%94%9F%E2%80%9D%EF%BC%9A%E4%BB%8E%E8%AF%9E%E7%94%9F%E5%88%B0%E6%99%8B%E5%8D%87-%E6%B6%88%E4%BA%A1"><span class="nav-text">3.4.3 一个对象的“一生”：从诞生到晋升&#x2F;消亡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-4-%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%EF%BC%9A%E5%A4%A7%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="nav-text">3.4.4 特殊情况：大对象与分配担保</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E4%B8%83%E5%A4%A7%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-text">3.5 七大经典垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-Serial-Serial-Old-%E4%B8%B2%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">3.5.1 Serial &#x2F; Serial Old(串行收集器)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-Parallel-Parallel-Old-%E5%B9%B6%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">3.5.2 Parallel &#x2F; Parallel Old(并行收集器)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-CMS-Concurrent-Mark-Sweep"><span class="nav-text">3.5.3 CMS (Concurrent Mark Sweep)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-4-G1-Garbage-First"><span class="nav-text">3.5.4 G1 (Garbage-First)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-5-ZGC-Shenandoah-%E8%B6%85%E4%BD%8E%E5%81%9C%E9%A1%BF%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text">3.5.5 ZGC &#x2F; Shenandoah(超低停顿收集器)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-Stop-The-World-STW"><span class="nav-text">3.6 Stop-The-World (STW)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-1-%E4%BB%80%E4%B9%88%E6%98%AF-STW%EF%BC%9F"><span class="nav-text">3.6.1 什么是 STW？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Stop-The-World%EF%BC%9F"><span class="nav-text">3.6.2 为什么需要 Stop-The-World？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-3-STW-%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-text">3.6.3 STW 的影响</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-4-%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9STW"><span class="nav-text">3.6.4 现代垃圾回收器如何应对STW</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-5-%E6%80%BB%E7%BB%93"><span class="nav-text">3.6.5 总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-text">4. 类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">4.1 类加载的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%E5%8A%A0%E8%BD%BD"><span class="nav-text">4.1.1 加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-%E9%93%BE%E6%8E%A5"><span class="nav-text">4.1.2 链接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%AA%8C%E8%AF%81"><span class="nav-text">1. 验证</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%87%86%E5%A4%87"><span class="nav-text">2. 准备</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E8%A7%A3%E6%9E%90"><span class="nav-text">3. 解析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">4.1.3 初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">4.2 类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">4.2.1 启动类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">4.2.2 扩展类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">4.2.3 应用程序类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-4-%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93"><span class="nav-text">4.2.4 三层结构总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-text">4.3 双亲委派模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E5%8E%9F%E7%90%86"><span class="nav-text">4.3.1 原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%E4%BC%98%E5%8A%BF"><span class="nav-text">4.3.2 优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-text">4.3.3 如何打破双亲委派模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="nav-text">5. 字节码执行引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C-vs-%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C"><span class="nav-text">5.1 解释执行 vs. 编译执行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C"><span class="nav-text">5.1.1 解释执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C"><span class="nav-text">5.1.2 编译执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-HotSpot%E7%9A%84%E9%80%89%E6%8B%A9%EF%BC%9A%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F-Mixed-Mode-%E8%A7%A3%E9%87%8A%E4%B8%8E%E7%BC%96%E8%AF%91%E5%B9%B6%E5%AD%98"><span class="nav-text">5.1.3 HotSpot的选择：混合模式 (Mixed Mode) - 解释与编译并存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94"><span class="nav-text">5.1.4 总结对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8-JIT-Just-In-Time-Compiler"><span class="nav-text">5.2 即时编译器 (JIT, Just-In-Time Compiler)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-JIT-%E5%9C%A8JVM%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%B8%8E%E8%A7%92%E8%89%B2"><span class="nav-text">5.2.1 JIT 在JVM中的位置与角色</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-JIT-%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%9AC1-%E5%92%8C-C2"><span class="nav-text">5.2.2 JIT 的两种编译器：C1 和 C2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3-JIT-%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="nav-text">5.2.3 JIT 的核心优化技术</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94-Method-Inlining"><span class="nav-text">1. 方法内联 (Method Inlining)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90-Escape-Analysis"><span class="nav-text">2. 逃逸分析 (Escape Analysis)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%85%AC%E5%85%B1%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B6%88%E9%99%A4-Common-Subexpression-Elimination"><span class="nav-text">3. 公共子表达式消除 (Common Subexpression Elimination)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80-Loop-Unrolling"><span class="nav-text">4. 循环展开 (Loop Unrolling)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-4-%E9%80%86%E4%BC%98%E5%8C%96-Deoptimization"><span class="nav-text">5.2.4 逆优化 (Deoptimization)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81%E6%8E%A2%E6%B5%8B%E3%80%81%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94%E3%80%81%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%AD%89%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="nav-text">5.3 热点代码探测、方法内联、逃逸分析等优化技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1-%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81%E6%8E%A2%E6%B5%8B-HotSpot-Code-Detection"><span class="nav-text">5.3.1 热点代码探测 (HotSpot Code Detection)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8-Method-Invocation-Counter"><span class="nav-text">1. 方法调用计数器 (Method Invocation Counter)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8-Back-Edge-Counter"><span class="nav-text">2. 回边计数器 (Back-Edge Counter)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94-Method-Inlining"><span class="nav-text">5.3.2 方法内联 (Method Inlining)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90-Escape-Analysis"><span class="nav-text">5.3.3 逃逸分析 (Escape Analysis)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%8E%E5%AE%9E%E6%88%98"><span class="nav-text">三、企业级性能调优与实战</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-JVM%E8%B0%83%E4%BC%98%E7%9A%84%E7%9B%AE%E6%A0%87%E4%B8%8E%E5%8E%9F%E5%88%99"><span class="nav-text">1. JVM调优的目标与原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E8%B0%83%E4%BC%98%E4%B8%89%E5%A4%A7%E6%8C%87%E6%A0%87"><span class="nav-text">1.1 调优三大指标</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E5%90%9E%E5%90%90%E9%87%8F-Throughput"><span class="nav-text">1.1.1 吞吐量 (Throughput)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E5%BB%B6%E8%BF%9F-Latency-%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4-Pause-Time"><span class="nav-text">1.1.2 延迟 (Latency) &#x2F; 停顿时间 (Pause Time)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8-Footprint"><span class="nav-text">1.1.3 内存占用 (Footprint)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-4-%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9F%9B%E7%9B%BE"><span class="nav-text">1.1.4 三者之间的矛盾</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%B0%83%E4%BC%98%E5%8E%9F%E5%88%99"><span class="nav-text">1.2 调优原则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E6%97%A0%E7%9B%91%E6%8E%A7%EF%BC%8C%E4%B8%8D%E8%B0%83%E4%BC%98-Profile-First-Tune-Later"><span class="nav-text">1.2.1 无监控，不调优 (Profile First, Tune Later)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E4%BB%8E%E5%85%A8%E5%B1%80%E5%88%B0%E5%B1%80%E9%83%A8-System-Wide-to-JVM"><span class="nav-text">1.2.2 从全局到局部 (System-Wide to JVM)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E5%85%88%E5%AE%9A%E4%BD%8D%E7%93%B6%E9%A2%88-Identify-the-Bottleneck-First"><span class="nav-text">1.2.3 先定位瓶颈 (Identify the Bottleneck First)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%B8%B8%E7%94%A8%E7%9A%84JVM%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-text">2. 常用的JVM参数设置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%A0%86%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE"><span class="nav-text">2.1 堆内存设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%85%83%E7%A9%BA%E9%97%B4-%E6%B0%B8%E4%B9%85%E4%BB%A3%E8%AE%BE%E7%BD%AE"><span class="nav-text">2.2 元空间&#x2F;永久代设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E9%80%89%E6%8B%A9"><span class="nav-text">2.3 垃圾回收器选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-GC%E6%97%A5%E5%BF%97%E7%9B%B8%E5%85%B3"><span class="nav-text">2.4 GC日志相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-OOM%E5%BF%AB%E7%85%A7"><span class="nav-text">2.5 OOM快照</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%85%B8%E5%9E%8B%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-Case-Study"><span class="nav-text">3. 典型调优案例分析 (Case Study)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-OutOfMemoryError-OOM-%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="nav-text">3.1 OutOfMemoryError (OOM) 问题排查</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-java-lang-OutOfMemoryError-Java-heap-space-%E5%A0%86%E6%BA%A2%E5%87%BA"><span class="nav-text">3.1.1 java.lang.OutOfMemoryError: Java heap space (堆溢出)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-java-lang-OutOfMemoryError-Metaspace-%E5%85%83%E7%A9%BA%E9%97%B4%E6%BA%A2%E5%87%BA"><span class="nav-text">3.1.2 java.lang.OutOfMemoryError: Metaspace (元空间溢出)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-java-lang-OutOfMemoryError-GC-overhead-limit-exceeded-GC%E5%BC%80%E9%94%80%E8%B6%85%E9%99%90"><span class="nav-text">3.1.3 java.lang.OutOfMemoryError: GC overhead limit exceeded (GC开销超限)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4-java-lang-OutOfMemoryError-Unable-to-create-new-native-thread-%E6%97%A0%E6%B3%95%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BA%BF%E7%A8%8B"><span class="nav-text">3.1.4 java.lang.OutOfMemoryError: Unable to create new native thread (无法创建新线程)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-CPU-100-%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="nav-text">3.2 CPU 100% 问题排查</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E6%8E%92%E6%9F%A5%E6%AD%A5%E9%AA%A4"><span class="nav-text">3.2.1 排查步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%80%EF%BC%9A%E6%89%BE%E5%88%B0%E6%9C%80%E8%80%97CPU%E7%9A%84Java%E8%BF%9B%E7%A8%8B"><span class="nav-text">步骤一：找到最耗CPU的Java进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4%E4%BA%8C%EF%BC%9A%E6%89%BE%E5%88%B0%E8%AF%A5%E8%BF%9B%E7%A8%8B%E5%86%85%E6%9C%80%E8%80%97CPU%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="nav-text">步骤二：找到该进程内最耗CPU的线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%89%EF%BC%9A%E5%B0%86%E7%BA%BF%E7%A8%8BID%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6"><span class="nav-text">步骤三：将线程ID转换为十六进制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4%E5%9B%9B%EF%BC%9A%E4%BD%BF%E7%94%A8jstack%E7%94%9F%E6%88%90%E7%BA%BF%E7%A8%8B%E5%BF%AB%E7%85%A7%E5%B9%B6%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E7%BA%BF%E7%A8%8B"><span class="nav-text">步骤四：使用jstack生成线程快照并定位问题线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4%E4%BA%94%EF%BC%9A%E5%88%86%E6%9E%90%E7%BA%BF%E7%A8%8B%E5%BF%AB%E7%85%A7%EF%BC%8C%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="nav-text">步骤五：分析线程快照，定位问题代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC"><span class="nav-text">3.2.2 自动化脚本</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-GC-%E9%A2%91%E7%B9%81-STW%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF-%E8%B0%83%E4%BC%98"><span class="nav-text">3.3 GC 频繁 &#x2F; STW时间过长 调优</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%B8%BB%E8%A6%81%E8%A1%A8%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF"><span class="nav-text">问题的两种主要表现及分析思路</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%80%EF%BC%9AMinor-GC-Young-GC-%E8%BF%87%E4%BA%8E%E9%A2%91%E7%B9%81"><span class="nav-text">场景一：Minor GC (Young GC) 过于频繁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF%E4%BA%8C%EF%BC%9AFull-GC-%E8%BF%87%E4%BA%8E%E9%A2%91%E7%B9%81%E6%88%96-STW-%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF"><span class="nav-text">场景二：Full GC 过于频繁或 STW 时间过长</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-Web%E5%BA%94%E7%94%A8%E4%BD%8E%E5%BB%B6%E8%BF%9F%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84GC%E8%B0%83%E4%BC%98-%E5%A6%82G1-ZGC"><span class="nav-text">3.4 Web应用低延迟场景下的GC调优 (如G1&#x2F;ZGC)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-text">垃圾回收器的选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8G1%E8%BF%9B%E8%A1%8C%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%B0%83%E4%BC%98"><span class="nav-text">使用G1进行低延迟调优</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8ZGC%E8%BF%9B%E8%A1%8C%E8%B6%85%E4%BD%8E%E5%BB%B6%E8%BF%9F%E8%B0%83%E4%BC%98"><span class="nav-text">使用ZGC进行超低延迟调优</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E5%A4%A7%E6%95%B0%E6%8D%AE-%E6%89%B9%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84GC%E8%B0%83%E4%BC%98-%E5%A6%82Parallel-GC"><span class="nav-text">3.5 大数据&#x2F;批处理任务吞吐量优先场景下的GC调优 (如Parallel GC)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E9%80%89%E6%8B%A9-1"><span class="nav-text">垃圾回收器的选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Parallel-GC%E8%BF%9B%E8%A1%8C%E5%90%9E%E5%90%90%E9%87%8F%E8%B0%83%E4%BC%98"><span class="nav-text">使用Parallel GC进行吞吐量调优</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9CParallel-GC%E4%BB%8D%E7%84%B6%E6%97%A0%E6%B3%95%E6%BB%A1%E8%B6%B3%E9%9C%80%E6%B1%82"><span class="nav-text">如果Parallel GC仍然无法满足需求</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%E4%B8%8E%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="nav-text">四、诊断工具与问题排查</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-JDK%E8%87%AA%E5%B8%A6%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7"><span class="nav-text">1. JDK自带命令行工具</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#jps-JVM-Process-Status-Tool"><span class="nav-text">jps (JVM Process Status Tool)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jstat-JVM-Statistics-Monitoring-Tool"><span class="nav-text">jstat (JVM Statistics Monitoring Tool)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jinfo-Configuration-Info-for-Java"><span class="nav-text">jinfo (Configuration Info for Java)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jmap-Memory-Map-for-Java"><span class="nav-text">jmap (Memory Map for Java)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jstack-Stack-Trace-for-Java"><span class="nav-text">jstack (Stack Trace for Java)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jhat-JVM-Heap-Analysis-Tool"><span class="nav-text">jhat (JVM Heap Analysis Tool)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%8F%AF%E8%A7%86%E5%8C%96%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7"><span class="nav-text">2. 可视化诊断工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JConsole-Java-Monitoring-and-Management-Console"><span class="nav-text">JConsole (Java Monitoring and Management Console)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VisualVM-Java-VisualVM"><span class="nav-text">VisualVM (Java VisualVM)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MAT-Eclipse-Memory-Analyzer-Tool-%E9%87%8D%E7%82%B9"><span class="nav-text">MAT (Eclipse Memory Analyzer Tool) - 重点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Arthas-%E9%98%BF%E5%B0%94%E8%90%A8%E6%96%AF-%E9%87%8D%E7%82%B9"><span class="nav-text">Arthas (阿尔萨斯) - 重点</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%89%8D%E6%B2%BF%E4%B8%8E%E5%B1%95%E6%9C%9B"><span class="nav-text">五、前沿与展望</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-GraalVM-%E4%B8%8E-AOT-%E7%BC%96%E8%AF%91"><span class="nav-text">1. GraalVM 与 AOT 编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-GraalVM-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%8E-HotSpot-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">1.1 GraalVM 是什么？与 HotSpot 的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-AOT-Ahead-of-Time-%E7%BC%96%E8%AF%91%E4%B8%8E-Native-Image%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%AF%AB%E7%A7%92%E7%BA%A7%E5%90%AF%E5%8A%A8"><span class="nav-text">1.2 AOT (Ahead-of-Time) 编译与 Native Image，实现毫秒级启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%9C%A8%E4%BA%91%E5%8E%9F%E7%94%9F%E3%80%81Serverless-%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8%E5%89%8D%E6%99%AF"><span class="nav-text">1.3 在云原生、Serverless 领域的应用前景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AE%B9%E5%99%A8%E5%8C%96%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84JVM"><span class="nav-text">2. 容器化环境下的JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Docker-K8s-%E7%8E%AF%E5%A2%83%E4%B8%ADJVM%E7%9A%84%E5%86%85%E5%AD%98-CPU%E6%84%9F%E7%9F%A5%E9%97%AE%E9%A2%98"><span class="nav-text">2.1 Docker&#x2F;K8s 环境中JVM的内存&#x2F;CPU感知问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-%E5%86%85%E5%AD%98%E6%84%9F%E7%9F%A5%E9%97%AE%E9%A2%98"><span class="nav-text">a. 内存感知问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-CPU%E6%84%9F%E7%9F%A5%E9%97%AE%E9%A2%98"><span class="nav-text">b. CPU感知问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Java-10-%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E6%94%AF%E6%8C%81%E4%B8%8E%E6%96%B0%E5%8F%82%E6%95%B0-XX-MaxRAMPercentage"><span class="nav-text">2.2 Java 10+ 对容器的支持与新参数 (-XX:MaxRAMPercentage)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E6%96%B0%E7%9A%84%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-text">引入新的内存配置参数</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-JVM%E4%B8%8EOff-Heap%E5%86%85%E5%AD%98"><span class="nav-text">3. JVM与Off-Heap内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-DirectByteBuffer-%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="nav-text">3.1 DirectByteBuffer 的原理与应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-Netty%E7%AD%89%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD"><span class="nav-text">3.2 Netty等框架如何利用堆外内存提升性能</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/27/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JVM | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-27 19:08:27" itemprop="dateCreated datePublished" datetime="2025-10-27T19:08:27+08:00">2025-10-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-30 09:28:31" itemprop="dateModified" datetime="2025-10-30T09:28:31+08:00">2025-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/" itemprop="url" rel="index"><span itemprop="name">基础核心层</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="一、JVM-基础入门"><a href="#一、JVM-基础入门" class="headerlink" title="一、JVM 基础入门"></a>一、JVM 基础入门</h1><h2 id="1-JVM是什么？"><a href="#1-JVM是什么？" class="headerlink" title="1. JVM是什么？"></a>1. JVM是什么？</h2><p>从宏观上讲，Java虚拟机（JVM）是一个可以执行Java字节码的<strong>虚拟计算机</strong>。它是Java技术的核心，也是实现Java“跨平台”特性的关键。JVM有自己完善的硬件架构（如处理器、堆栈、寄存器等），以及相应的指令系统。</p>
<h3 id="1-1-JVM、JRE、JDK-的关系与区别"><a href="#1-1-JVM、JRE、JDK-的关系与区别" class="headerlink" title="1.1 JVM、JRE、JDK 的关系与区别"></a>1.1 JVM、JRE、JDK 的关系与区别</h3><h4 id="1-1-1-核心概念"><a href="#1-1-1-核心概念" class="headerlink" title="1.1.1 核心概念"></a>1.1.1 核心概念</h4><h5 id="1-JDK-Java-Development-Kit-Java开发工具包"><a href="#1-JDK-Java-Development-Kit-Java开发工具包" class="headerlink" title="1. JDK (Java Development Kit - Java开发工具包)"></a>1. JDK (Java Development Kit - Java开发工具包)</h5><ul>
<li><strong>定位</strong>：面向<strong>开发者</strong>。</li>
<li><strong>包含内容</strong>：它是三者中功能最全的，是用于支持Java程序开发的最小环境。它不仅包含了Java程序的运行环境（JRE），还提供了大量的开发工具。</li>
<li><strong>关键组件</strong>：<ul>
<li><code>javac</code>：Java编译器，将<code>.java</code>源文件编译成<code>.class</code>字节码文件。</li>
<li><code>java</code>：Java运行工具，用于启动JVM执行字节码。</li>
<li><code>jar</code>：打包工具。</li>
<li><code>jdb</code>：调试工具。</li>
<li><code>jps</code>, <code>jstat</code>, <code>jmap</code>, <code>jstack</code>：一系列用于性能监控和故障排查的工具。</li>
<li><strong>它包含了完整的JRE</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-JRE-Java-Runtime-Environment-Java运行环境"><a href="#2-JRE-Java-Runtime-Environment-Java运行环境" class="headerlink" title="2. JRE (Java Runtime Environment - Java运行环境)"></a>2. JRE (Java Runtime Environment - Java运行环境)</h5><ul>
<li><strong>定位</strong>：面向<strong>运行Java程序的用户或服务器</strong>。</li>
<li><strong>包含内容</strong>：它是运行已编译Java程序所需的所有内容的集合，是Java程序能够运行的最小环境。</li>
<li><strong>关键组件</strong>：<ul>
<li><strong>JVM</strong>：Java虚拟机，是JRE的核心部分，负责执行程序。</li>
<li><strong>Java核心类库 (Java Class Libraries)</strong>：Java程序运行时所依赖的基础类库，如 <code>java.lang.*</code>, <code>java.util.*</code> 等（例如 <code>rt.jar</code>）。没有这些类库，即使有JVM也无法运行，就像操作系统只有内核没有应用程序一样。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-JVM-Java-Virtual-Machine-Java虚拟机"><a href="#3-JVM-Java-Virtual-Machine-Java虚拟机" class="headerlink" title="3. JVM (Java Virtual Machine - Java虚拟机)"></a>3. JVM (Java Virtual Machine - Java虚拟机)</h5><ul>
<li><strong>定位</strong>：Java程序的<strong>执行者和管理者</strong>。</li>
<li><strong>包含内容</strong>：它是JRE的一部分，是整个Java技术的核心。它负责将Java字节码（<code>.class</code>文件）解释&#x2F;编译为特定平台的机器码并执行。它还负责内存管理、垃圾回收、安全等。</li>
</ul>
<hr>
<h4 id="1-1-2-关系总结"><a href="#1-1-2-关系总结" class="headerlink" title="1.1.2 关系总结"></a>1.1.2 关系总结</h4><ul>
<li><strong>包含关系</strong>：<code>JDK &gt; JRE &gt; JVM</code><ul>
<li><code>JDK = JRE + 开发工具包</code></li>
<li><code>JRE = JVM + Java核心类库</code></li>
</ul>
</li>
<li><strong>注意</strong>：自Java 9引入模块化系统（Jigsaw）后，JDK和JRE的目录结构发生了变化，不再有显式的<code>jre</code>目录。但从概念上，上述关系依然成立。开发者可以使用<code>jlink</code>工具创建包含所需模块的自定义运行时镜像，这可以看作是一个精简版的JRE。</li>
</ul>
<hr>
<h3 id="1-2-“一次编写，到处运行”-的实现原理"><a href="#1-2-“一次编写，到处运行”-的实现原理" class="headerlink" title="1.2 “一次编写，到处运行” 的实现原理"></a>1.2 “一次编写，到处运行” 的实现原理</h3><p>这是Java语言最著名的口号，其实现原理正是依赖于JVM。</p>
<h4 id="1-2-1-核心思想"><a href="#1-2-1-核心思想" class="headerlink" title="1.2.1 核心思想"></a>1.2.1 核心思想</h4><p>代码的<strong>编译</strong>和<strong>执行</strong>相分离。</p>
<ol>
<li><strong>编译阶段（平台无关）</strong>：<ul>
<li>无论你在Windows、macOS还是Linux上，Java编译器（<code>javac</code>）都会将你的Java源代码（<code>.java</code>文件）编译成一种<strong>统一的、与平台无关的中间格式——Java字节码（Bytecode）</strong>，并保存在<code>.class</code>文件中。</li>
<li>这个字节码不是任何特定CPU能直接执行的机器码，而是一种专为JVM设计的指令集。</li>
</ul>
</li>
<li><strong>执行阶段（平台相关）</strong>：<ul>
<li>当你想在某个特定的操作系统上运行这个Java程序时，你只需要在该系统上安装一个<strong>对应版本的JVM</strong>即可。</li>
<li>这个特定平台的JVM会加载并执行那个平台无关的<code>.class</code>文件。JVM扮演了一个**“翻译官”<strong>的角色，它会将通用的字节码指令</strong>实时地翻译成底层操作系统和硬件能够理解的本地机器码（Native Machine Code）**来执行。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-2-2-原理图解"><a href="#1-2-2-原理图解" class="headerlink" title="1.2.2 原理图解"></a>1.2.2 原理图解</h4><pre><code class="highlight mermaid">graph TD
    A[MyCode.java] --&gt;|&quot;javac (编译一次)&quot;| B[&quot;MyCode.class&lt;br/&gt;(平台无关的字节码)&quot;]

    subgraph Windows
        C1[Windows JVM] --&gt;|翻译/执行| D1[Windows机器码]
    end

    subgraph Linux
        C2[Linux JVM] --&gt;|翻译/执行| D2[Linux机器码]
    end

    subgraph macOS
        C3[macOS JVM] --&gt;|翻译/执行| D3[macOS机器码]
    end

    B --&gt;|在Windows上运行| C1
    B --&gt;|在Linux上运行| C2
    B --&gt;|在macOS上运行| C3</code></pre>

<hr>
<h4 id="1-2-3-总结"><a href="#1-2-3-总结" class="headerlink" title="1.2.3 总结"></a>1.2.3 总结</h4><p>Java的跨平台性，并非Java语言本身能跨平台，而是通过在不同平台上提供统一接口的JVM，将底层平台的差异屏蔽掉了。开发者只需关心业务逻辑的实现，而无需为不同系统的兼容性问题操心。</p>
<hr>
<h3 id="1-3-主流的JVM实现"><a href="#1-3-主流的JVM实现" class="headerlink" title="1.3 主流的JVM实现"></a>1.3 主流的JVM实现</h3><p>JVM是一个<strong>规范</strong>（The Java Virtual Machine Specification），而不是一个具体的实现。任何公司或组织都可以根据这个规范开发自己的JVM。以下是一些主流和有特色的JVM实现：</p>
<h4 id="1-3-1-HotSpot-VM"><a href="#1-3-1-HotSpot-VM" class="headerlink" title="1.3.1 HotSpot VM"></a>1.3.1 HotSpot VM</h4><ul>
<li><strong>来源</strong>：Oracle&#x2F;OpenJDK</li>
<li><strong>地位</strong>：<strong>绝对的主流，事实上的标准</strong>。我们通常所说的JDK（无论是Oracle JDK还是OpenJDK）中包含的默认就是HotSpot VM。</li>
<li><strong>特点</strong>：<ul>
<li>拥有目前规模最大、最活跃的开发社区。</li>
<li>拥有最成熟、经过最广泛生产验证的垃圾回收器（如G1、ZGC、Shenandoah）。</li>
<li>包含强大的即时编译器（JIT），如C1（Client Compiler）和C2（Server Compiler），能进行深度性能优化。</li>
<li>作为后端开发，你打交道最多的99%都是HotSpot。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-2-GraalVM"><a href="#1-3-2-GraalVM" class="headerlink" title="1.3.2 GraalVM"></a>1.3.2 GraalVM</h4><ul>
<li><strong>来源</strong>：Oracle</li>
<li><strong>地位</strong>：<strong>下一代高性能JVM的有力竞争者</strong>，被誉为“黑科技”。</li>
<li><strong>特点</strong>：<ul>
<li><strong>高性能JIT编译器</strong>：其顶层编译器Graal Compiler本身就是用Java编写的，优化能力强大。</li>
<li><strong>AOT编译 (Ahead-of-Time)</strong>：最引人注目的特性是<code>Native Image</code>技术，可以将Java代码直接编译成无需JVM即可运行的本地可执行文件。这带来了<strong>毫秒级的启动速度</strong>和<strong>极低的内存占用</strong>，非常适合云原生、Serverless和微服务场景。</li>
<li><strong>多语言支持（Polyglot）</strong>：可以在同一个运行时里高效运行Java、JavaScript、Python、Ruby等多种语言。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-3-OpenJ9"><a href="#1-3-3-OpenJ9" class="headerlink" title="1.3.3 OpenJ9"></a>1.3.3 OpenJ9</h4><ul>
<li><strong>来源</strong>：最初由IBM开发（名为J9），后捐赠给Eclipse基金会，成为开源项目。</li>
<li><strong>地位</strong>：<strong>资源友好型JVM的代表</strong>。</li>
<li><strong>特点</strong>：<ul>
<li><strong>低内存占用</strong>：相比HotSpot，在同等负载下通常占用更少的内存。</li>
<li><strong>快速启动</strong>：启动速度比HotSpot更快（但慢于GraalVM Native Image）。</li>
<li>使用了类数据共享（Class Data Sharing）等技术来优化启动时间和内存。</li>
<li>非常适合内存受限的容器化环境或希望降低云成本的场景。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-4-Alibaba-Dragonwell-阿里龙井"><a href="#1-3-4-Alibaba-Dragonwell-阿里龙井" class="headerlink" title="1.3.4 Alibaba Dragonwell (阿里龙井)"></a>1.3.4 Alibaba Dragonwell (阿里龙井)</h4><ul>
<li><strong>来源</strong>：阿里巴巴</li>
<li><strong>地位</strong>：<strong>国内大厂深度定制JVM的典范</strong>。</li>
<li><strong>特点</strong>：<ul>
<li>基于OpenJDK HotSpot进行深度定制和优化。</li>
<li>集成了阿里巴巴在超大规模电商业务场景下积累的JVM技术和经验。</li>
<li>提供了一些上游社区没有的增强功能和诊断特性，如JWarmup（应用预热）、GCIH（GC Invisible Heap）等，旨在解决大型Java应用在生产环境中的痛点。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-第一个Java程序的JVM之旅"><a href="#2-第一个Java程序的JVM之旅" class="headerlink" title="2. 第一个Java程序的JVM之旅"></a>2. 第一个Java程序的JVM之旅</h2><p>假设我们有一个最简单的Java程序 <code>HelloWorld.java</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, JVM!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们跟随这个程序，看看它在JVM世界里的奇妙旅程。</p>
<h3 id="2-1-从-java-文件到-class-文件的编译过程"><a href="#2-1-从-java-文件到-class-文件的编译过程" class="headerlink" title="2.1 从 .java 文件到 .class 文件的编译过程"></a>2.1 从 <code>.java</code> 文件到 <code>.class</code> 文件的编译过程</h3><p>这个过程由Java编译器 <code>javac</code> 完成。<code>javac HelloWorld.java</code> 这个简单的命令背后，编译器进行了一系列复杂而精密的步骤，可以概括为以下四个主要阶段：</p>
<h4 id="2-1-1-词法分析-Lexical-Analysis-Scanning"><a href="#2-1-1-词法分析-Lexical-Analysis-Scanning" class="headerlink" title="2.1.1 词法分析 (Lexical Analysis &#x2F; Scanning)"></a>2.1.1 词法分析 (Lexical Analysis &#x2F; Scanning)</h4><ul>
<li><strong>目标</strong>：将源代码的字符流（<code>p</code>, <code>u</code>, <code>b</code>, <code>l</code>, <code>i</code>, <code>c</code>, &#96;&#96;…）转换成有意义的**词法单元（Token）**流。</li>
<li><strong>过程</strong>：编译器逐个读取字符，当识别出一个符合Java语法规则的“单词”时，就将其打包成一个Token。</li>
<li><strong>示例</strong>：<code>public class HelloWorld { ...</code> 会被分解为 <code>TOKEN_PUBLIC</code>, <code>TOKEN_CLASS</code>, <code>TOKEN_IDENTIFIER(&quot;HelloWorld&quot;)</code>, <code>TOKEN_LBRACE</code>, … 等等。空格和注释通常在此阶段被丢弃。</li>
</ul>
<hr>
<h4 id="2-1-2-语法分析-Syntax-Analysis-Parsing"><a href="#2-1-2-语法分析-Syntax-Analysis-Parsing" class="headerlink" title="2.1.2 语法分析 (Syntax Analysis &#x2F; Parsing)"></a>2.1.2 语法分析 (Syntax Analysis &#x2F; Parsing)</h4><ul>
<li><strong>目标</strong>：基于Token流，检查代码是否符合Java的语法规则，并构建一个结构化的表示——<strong>抽象语法树 (Abstract Syntax Tree, AST)</strong>。</li>
<li><strong>过程</strong>：语法分析器像一个严格的语法老师，检查词法单元的排列组合是否正确。例如，<code>class</code> 关键字后面必须跟一个标识符。如果语法有误（如少了一个分号），编译就会在此阶段报错。</li>
<li><strong>产物(AST)</strong>：AST是源代码结构的一种树状表示，它抛弃了具体语法细节（如括号、分号），只保留核心的程序结构。<code>HelloWorld</code> 类的AST根节点可能是一个<code>ClassDef</code>，它有<code>main</code>方法的<code>MethodDef</code>子节点，<code>MethodDef</code>又有<code>MethodInvocation</code>（调用<code>println</code>）子节点。</li>
</ul>
<hr>
<h4 id="2-1-3-语义分析-Semantic-Analysis"><a href="#2-1-3-语义分析-Semantic-Analysis" class="headerlink" title="2.1.3 语义分析 (Semantic Analysis)"></a>2.1.3 语义分析 (Semantic Analysis)</h4><ul>
<li><strong>目标</strong>：在AST的基础上，检查代码的<strong>逻辑含义</strong>是否正确。语法正确不代表逻辑正确。</li>
<li><strong>过程</strong>：这个阶段进行更深层次的检查，包括：<ul>
<li><strong>类型检查</strong>：<code>System.out.println</code> 是否接受一个字符串参数？变量类型是否匹配？</li>
<li><strong>变量作用域分析</strong>：使用的变量是否已经声明？</li>
<li><strong>可达性分析</strong>：<code>return</code> 语句后面的代码是否无法执行？</li>
</ul>
</li>
<li><strong>注解处理 (Annotation Processing)</strong>：这也是一个关键环节。如果你的代码中使用了如Lombok的<code>@Data</code>、MapStruct的<code>@Mapper</code>等注解，注解处理器会在此阶段介入，修改或生成新的AST节点（例如，为<code>HelloWorld</code>类自动生成getter&#x2F;setter方法的AST节点）。</li>
</ul>
<hr>
<h4 id="2-1-4-字节码生成-Bytecode-Generation"><a href="#2-1-4-字节码生成-Bytecode-Generation" class="headerlink" title="2.1.4 字节码生成 (Bytecode Generation)"></a>2.1.4 字节码生成 (Bytecode Generation)</h4><ul>
<li><strong>目标</strong>：将经过上述所有检查和处理的AST，翻译成JVM可以理解的<strong>字节码（Bytecode）</strong>。</li>
<li><strong>过程</strong>：编译器遍历AST，为每个节点生成对应的字节码指令。例如，<code>System.out.println(&quot;Hello, JVM!&quot;);</code> 会被翻译成类似 <code>getstatic</code>（获取<code>System.out</code>）、<code>ldc</code>（加载常量”Hello, JVM!”）、<code>invokevirtual</code>（调用<code>println</code>方法）等一系列指令。</li>
<li><strong>产物</strong>：所有这些信息——包括类信息、方法、字段、以及方法的字节码指令——最终被打包成一个严格遵循规范的二进制文件，即 <strong><code>.class</code> 文件</strong>。</li>
</ul>
<hr>
<h3 id="2-2-class-文件结构初探-魔数、版本号、常量池等"><a href="#2-2-class-文件结构初探-魔数、版本号、常量池等" class="headerlink" title="2.2 .class 文件结构初探 (魔数、版本号、常量池等)"></a>2.2 <code>.class</code> 文件结构初探 (魔数、版本号、常量池等)</h3><p><code>.class</code> 文件不是给人阅读的，它是一个高度结构化的二进制文件，是JVM的“说明书”。我们可以通过 <code>javap -v HelloWorld.class</code> 命令来窥探它的内部结构。主要包含以下部分：</p>
<h4 id="2-2-1-魔数-Magic-Number"><a href="#2-2-1-魔数-Magic-Number" class="headerlink" title="2.2.1 魔数 (Magic Number)"></a>2.2.1 魔数 (Magic Number)</h4><ul>
<li><strong>内容</strong>：每个<code>.class</code>文件的<strong>头4个字节</strong>都是一个固定的十六进制值：<code>0xCAFEBABE</code>。</li>
<li><strong>作用</strong>：这是一个快速的身份标识。JVM在加载任何文件时，首先检   查这4个字节。如果不是<code>0xCAFEBABE</code>，JVM会直接拒绝加载，并抛出 <code>java.lang.ClassFormatError</code>。这个设计可以防止JVM错误地加载非<code>.class</code>文件。</li>
</ul>
<hr>
<h4 id="2-2-2-版本号-Version"><a href="#2-2-2-版本号-Version" class="headerlink" title="2.2.2 版本号 (Version)"></a>2.2.2 版本号 (Version)</h4><ul>
<li><strong>内容</strong>：紧跟在魔数之后的4个字节，分别是次版本号（Minor Version）和主版本号（Major Version）。</li>
<li><strong>作用</strong>：标识这个<code>.class</code>文件是由哪个版本的JDK编译器生成的。例如，JDK 8编译的主版本号是52.0。这个版本号用于<strong>向后兼容</strong>：高版本的JVM可以执行低版本编译器生成的<code>.class</code>文件，但低版本的JVM尝试执行高版本的<code>.class</code>文件时，会抛出 <code>java.lang.UnsupportedClassVersionError</code>。</li>
</ul>
<hr>
<h4 id="2-2-3-常量池-Constant-Pool"><a href="#2-2-3-常量池-Constant-Pool" class="headerlink" title="2.2.3 常量池 (Constant Pool)"></a>2.2.3 常量池 (Constant Pool)</h4><ul>
<li><strong>地位</strong>：<code>.class</code>文件中<strong>最核心、最庞大的数据集合</strong>，可以理解为这个类的“资源仓库”或“符号表”。</li>
<li><strong>内容</strong>：它存储了两大类常量：<ul>
<li><strong>字面量 (Literals)</strong>：如文本字符串（<code>&quot;Hello, JVM!&quot;</code>）、被声明为<code>final</code>的常量值等。</li>
<li><strong>符号引用 (Symbolic References)</strong>：这是重点。它以<strong>纯文本</strong>的形式描述了类、方法、字段等信息，但<strong>不是内存地址</strong>。<ul>
<li>类的全限定名（如 <code>java/lang/Object</code>）</li>
<li>字段的名称和描述符（如 <code>name:Ljava/lang/String;</code>）</li>
<li>方法的名称和描述符（如 <code>main:([Ljava/lang/String;)V</code>）</li>
</ul>
</li>
</ul>
</li>
<li><strong>作用</strong>：当JVM运行时，需要将这些符号引用动态地解析和链接为实际内存中的直接引用（内存地址或偏移量）。这种设计实现了动态链接，使得代码在编译时无需知道其依赖项在内存中的具体位置。</li>
</ul>
<hr>
<h4 id="2-2-4-其他关键部分"><a href="#2-2-4-其他关键部分" class="headerlink" title="2.2.4 其他关键部分"></a>2.2.4 其他关键部分</h4><ul>
<li><strong>访问标志 (Access Flags)</strong>：一个标志位，用于表示这个类是<code>public</code>还是<code>private</code>，是否是<code>abstract</code>或<code>final</code>等。</li>
<li><strong>类索引、父类索引、接口索引集合 (this_class, super_class, interfaces)</strong>：都指向常量池中的符号引用，用以确定这个类的继承和实现关系。</li>
<li><strong>字段表集合 (Fields)</strong>：描述类中声明的所有字段（成员变量），包括字段的作用域、类型、名称等。</li>
<li><strong>方法表集合 (Methods)</strong>：描述类中声明的所有方法，包括方法的访问权限、返回类型、参数列表。<ul>
<li><strong>Code属性</strong>：对于非抽象方法，方法表中会有一个<code>Code</code>属性，这里存放着该方法<strong>真正的字节码指令流</strong>，以及操作数栈的最大深度、局部变量表大小等信息。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-java-命令执行后，JVM的启动流程概览"><a href="#2-3-java-命令执行后，JVM的启动流程概览" class="headerlink" title="2.3 java 命令执行后，JVM的启动流程概览"></a>2.3 <code>java</code> 命令执行后，JVM的启动流程概览</h3><p>当你敲下 <code>java HelloWorld</code> 并回车后，一场大戏在操作系统和JVM内部上演：</p>
<h4 id="2-3-1-创建JVM实例"><a href="#2-3-1-创建JVM实例" class="headerlink" title="2.3.1 创建JVM实例"></a>2.3.1 创建JVM实例</h4><ul>
<li><code>java.exe</code> (或<code>java</code>在Linux&#x2F;macOS上) 是一个本地可执行程序（启动器）。它的首要任务是找到并加载JVM的核心动态链接库（如Windows上的<code>jvm.dll</code>）。</li>
<li>然后，它在当前进程中初始化JVM，并创建一个C++层面的<code>JavaVM</code>实例。此时，JVM的各种内部结构（如垃圾回收器、执行引擎等）开始准备就绪。</li>
</ul>
<hr>
<h4 id="2-3-2-创建主线程并加载主类"><a href="#2-3-2-创建主线程并加载主类" class="headerlink" title="2.3.2 创建主线程并加载主类"></a>2.3.2 创建主线程并加载主类</h4><ul>
<li>JVM内部会创建一个<strong>主线程</strong>来执行Java程序。</li>
<li>JVM会启动<strong>类加载子系统</strong>，并使用<strong>应用程序类加载器 (Application ClassLoader)</strong> 来定位并加载你在命令行中指定的主类 <code>HelloWorld.class</code>。</li>
<li>加载过程遵循**“加载-链接-初始化”**的生命周期：<ul>
<li><strong>加载 (Loading)</strong>：在磁盘上找到<code>HelloWorld.class</code>文件，读取其二进制数据流，并在JVM的方法区中创建一个代表这个类的<code>java.lang.Class</code>对象。</li>
<li><strong>链接 (Linking)</strong>：<ul>
<li><strong>验证 (Verification)</strong>：确保字节码符合JVM规范，不会危害虚拟机安全。</li>
<li><strong>准备 (Preparation)</strong>：为类的静态变量分配内存，并设置其<strong>零值</strong>（如<code>int</code>为0，对象为<code>null</code>）。</li>
<li><strong>解析 (Resolution)</strong>：将常量池中的<strong>符号引用</strong>替换为<strong>直接引用</strong>（真实的内存地址）。这个过程可以是动态的（即用时再解析）。</li>
</ul>
</li>
<li><strong>初始化 (Initialization)</strong>：执行类的构造器方法<code>&lt;clinit&gt;()</code>。这个方法由编译器自动收集所有<strong>静态变量的赋值动作</strong>和<strong>静态代码块</strong>中的语句合并而成。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-3-3-寻找并执行main方法"><a href="#2-3-3-寻找并执行main方法" class="headerlink" title="2.3.3 寻找并执行main方法"></a>2.3.3 寻找并执行<code>main</code>方法</h4><ul>
<li>主类<code>HelloWorld</code>初始化完成后，JVM会在其方法表中查找一个具有特定签名的方法：<code>public static void main(String[] args)</code>。</li>
<li>如果找不到，JVM会报错 (<code>NoSuchMethodError: main</code>)。如果找到，执行引擎就准备执行它。</li>
</ul>
<hr>
<h4 id="2-3-4-开始执行"><a href="#2-3-4-开始执行" class="headerlink" title="2.3.4 开始执行"></a>2.3.4 开始执行</h4><ul>
<li>JVM为<code>main</code>方法在主线程的<strong>Java虚拟机栈</strong>上创建一个新的<strong>栈帧（Stack Frame）</strong>。</li>
<li>命令行传入的参数（<code>String[] args</code>）被放入这个栈帧的局部变量表中。</li>
<li><strong>程序计数器 (PC Register)</strong> 指向<code>main</code>方法的第一条字节码指令。</li>
<li><strong>执行引擎</strong>开始从程序计数器指示的位置取出指令，并逐条解释或编译执行。</li>
<li><code>Hello, JVM!</code> 被打印到控制台。</li>
</ul>
<hr>
<h4 id="2-3-5-程序结束，JVM关闭"><a href="#2-3-5-程序结束，JVM关闭" class="headerlink" title="2.3.5 程序结束，JVM关闭"></a>2.3.5 程序结束，JVM关闭</h4><ul>
<li><code>main</code>方法执行完毕，其对应的栈帧从Java虚拟机栈中弹出。</li>
<li>此时，主线程结束。由于<code>HelloWorld</code>程序没有启动其他非守护线程（Non-Daemon Thread），JVM判断可以退出了。</li>
<li>JVM执行关闭和清理操作，释放资源，进程终止。</li>
</ul>
<hr>
<h1 id="二、JVM-核心原理深度剖析"><a href="#二、JVM-核心原理深度剖析" class="headerlink" title="二、JVM 核心原理深度剖析"></a>二、JVM 核心原理深度剖析</h1><h2 id="1-JVM-内存区域-运行时数据区"><a href="#1-JVM-内存区域-运行时数据区" class="headerlink" title="1. JVM 内存区域 (运行时数据区)"></a>1. JVM 内存区域 (运行时数据区)</h2><h3 id="1-1-线程私有区域"><a href="#1-1-线程私有区域" class="headerlink" title="1.1 线程私有区域"></a>1.1 线程私有区域</h3><h4 id="1-1-1-程序计数器-Program-Counter-Register"><a href="#1-1-1-程序计数器-Program-Counter-Register" class="headerlink" title="1.1.1 程序计数器 (Program Counter Register)"></a>1.1.1 程序计数器 (Program Counter Register)</h4><ul>
<li><strong>核心定义</strong><br>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的<strong>字节码的行号指示器</strong>。</li>
<li><strong>作用与原理</strong><ol>
<li><strong>指令执行控制</strong>：JVM的执行引擎需要依赖程序计数器来读取下一条需要执行的字节码指令。它存储的是下一条指令在方法区中的地址。</li>
<li><strong>流程控制基础</strong>：分支、循环、跳转、异常处理、方法调用等基础的流程控制功能，都依赖程序计数器来完成指令的跳转。</li>
<li><strong>并发关键</strong>：在多线程场景下，CPU会在不同线程之间快速切换（时间片轮转）。当一个线程被挂起，切换到另一个线程时，它需要记住自己执行到了哪里。程序计数器就扮演了这个“记忆”的角色。当线程被重新调度时，它能从程序计数器记录的地址继续执行，保证了线程切换后能恢复到正确的执行位置。</li>
</ol>
</li>
<li><strong>特点与深入理解</strong><ul>
<li>它是JVM规范中<strong>唯一一个没有规定任何 <code>OutOfMemoryError</code> 情况</strong>的区域。因为它占用的内存非常小，且在编译时就能确定其大小。</li>
<li>如果线程正在执行的是一个<strong>Java方法</strong>，这个计数器记录的是正在执行的虚拟机字节码指令的地址。</li>
<li>如果正在执行的是<strong>本地（Native）方法</strong>，这个计数器值则为<strong>未指定（Undefined）</strong>。因为Native方法由本地代码（如C&#x2F;C++）实现，其执行不归JVM管理，而是由操作系统直接调度，有其自己的PC寄存器。</li>
</ul>
</li>
<li><strong>形象比喻</strong><br>可以把程序计数器想象成你<strong>看书时用的书签</strong>。它总是夹在你下一页要读的地方。即使你中途放下书去做别的事情（线程被挂起），回来时也能通过书签立刻找到上次读到的位置（恢复执行）。</li>
</ul>
<hr>
<h4 id="1-1-2-Java-虚拟机栈-Java-Virtual-Machine-Stack"><a href="#1-1-2-Java-虚拟机栈-Java-Virtual-Machine-Stack" class="headerlink" title="1.1.2 Java 虚拟机栈 (Java Virtual Machine Stack)"></a>1.1.2 Java 虚拟机栈 (Java Virtual Machine Stack)</h4><ul>
<li><strong>核心定义</strong><br>Java虚拟机栈是线程私有的，描述的是<strong>Java方法执行的内存模型</strong>。每个方法在执行时，JVM都会同步创建一个<strong>栈帧（Stack Frame）</strong>，用于存储该方法的相关信息。</li>
<li><strong>作用与原理</strong><ul>
<li>一个方法的调用过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
<li>当一个线程调用一个方法时，一个栈帧被创建并<strong>压入（push）栈顶；当方法执行完毕（无论是正常返回还是抛出异常），该栈帧就会被弹出（pop）</strong>。</li>
<li>因此，在任意时刻，只有一个栈帧位于栈顶，被称为<strong>当前栈帧（Current Stack Frame）</strong>，它对应的方法就是<strong>当前方法（Current Method）</strong>。</li>
</ul>
</li>
<li><strong>栈帧（Stack Frame）的内部结构</strong><br>栈帧是虚拟机栈的基本元素，它包含了方法运行所需的所有数据。<ol>
<li><strong>局部变量表 (Local Variable Table)</strong><ul>
<li><strong>用途</strong>：存放方法参数和方法内部定义的局部变量。</li>
<li><strong>结构</strong>：它是一个以“槽（Slot）”为基本单位的数组。一个Slot可以存放一个<code>boolean</code>, <code>byte</code>, <code>char</code>, <code>short</code>, <code>int</code>, <code>float</code>, <code>reference</code>（对象引用）或<code>returnAddress</code>类型的数据。</li>
<li><strong>注意</strong>：<code>long</code>和<code>double</code>这两种64位的数据类型会占用<strong>两个连续的Slot</strong>。</li>
<li><strong>生命周期</strong>：局部变量表所需的内存空间在<strong>编译期间</strong>就已经确定，并写入<code>.class</code>文件的<code>Code</code>属性中。在方法运行期间，其大小不会改变。</li>
</ul>
</li>
<li><strong>操作数栈 (Operand Stack)</strong><ul>
<li><strong>用途</strong>：一个后进先出（LIFO）的栈，作为方法执行时的<strong>工作区</strong>。大多数字节码指令都是从操作数栈中弹出数据，进行运算，然后将结果压入栈中。</li>
<li><strong>示例</strong>：执行整数加法指令 <code>iadd</code> 时，它会从操作数栈顶弹出两个整数，相加后，将结果压回操作-数栈顶。</li>
<li><strong>数据流</strong>：数据在局部变量表和操作数栈之间频繁交换。</li>
</ul>
</li>
<li><strong>动态链接 (Dynamic Linking)</strong><ul>
<li>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。</li>
<li>在<code>.class</code>文件中，所有的方法调用都以符号引用的形式存在。动态链接的作用就是将这些<strong>符号引用</strong>转换为对实际方法的<strong>直接引用</strong>（内存地址）。</li>
</ul>
</li>
<li><strong>方法返回地址 (Return Address)</strong><ul>
<li>当一个方法执行完毕后，需要返回到调用它的地方继续执行。方法返回地址就存放着调用者的程序计数器的值。</li>
<li>方法退出分两种：<strong>正常返回</strong>（执行了<code>return</code>等指令）和<strong>异常返回</strong>。无论哪种方式，都会导致栈帧被弹出。</li>
</ul>
</li>
</ol>
</li>
<li><strong>相关异常</strong><ul>
<li><strong><code>StackOverflowError</code></strong>：如果线程请求的栈深度大于虚拟机所允许的深度（通常是由于无限递归或非常深的方法调用链导致），将抛出此错误。</li>
<li><strong><code>OutOfMemoryError</code></strong>：如果虚拟机栈可以动态扩展，但在尝试扩展时无法申请到足够的内存，会抛出此错误。</li>
</ul>
</li>
<li><strong>形象比喻</strong><br>可以把Java虚拟机栈想象成一个<strong>叠起来的盘子</strong>。每调用一个方法，就往上放一个新盘子（栈帧）。盘子里放着做这道菜（方法）所需的食材（局部变量）和一个小碗（操作数栈）。你永远只能在最上面的盘子里操作。菜做完了，就把这个盘子拿走，继续处理下面的盘子。如果盘子叠得太高，超过了天花板，就会塌掉（<code>StackOverflowError</code>）。</li>
</ul>
<hr>
<h4 id="1-1-3-本地方法栈-Native-Method-Stack"><a href="#1-1-3-本地方法栈-Native-Method-Stack" class="headerlink" title="1.1.3 本地方法栈 (Native Method Stack)"></a>1.1.3 本地方法栈 (Native Method Stack)</h4><ul>
<li><strong>核心定义</strong><br>本地方法栈与Java虚拟机栈的作用非常相似，区别在于Java虚拟机栈为JVM执行<strong>Java方法</strong>（即字节码）服务，而本地方法栈则为JVM使用到的<strong>本地（Native）方法</strong>服务。</li>
<li><strong>作用与原理</strong><ul>
<li>当Java代码通过JNI（Java Native Interface）调用非Java代码（如C、C++编写的函数）时，就需要本地方法栈来支持其执行。</li>
<li>一个线程在调用一个Native方法时，会进入一个不再受JVM约束的世界。JVM会使用本地方法栈来支持Native方法的调用，可能会为这个调用在本地方法栈中创建一个对应的栈帧。</li>
</ul>
</li>
<li><strong>特点与深入理解</strong><ul>
<li>《Java虚拟机规范》对本地方法栈中方法的语言、使用方式与数据结构没有强制规定，因此虚拟机可以自由实现它。</li>
<li>在主流的<strong>HotSpot虚拟机</strong>中，它<strong>直接将本地方法栈和Java虚拟机栈合二为一</strong>了。也就是说，当你调用Native方法时，它只是在同一个栈上创建了一个特殊的栈帧来处理，并没有一个物理上独立的“本地方法栈”。</li>
<li>与Java虚拟机栈一样，本地方法栈区域也会抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-4-总结线程私有区"><a href="#1-1-4-总结线程私有区" class="headerlink" title="1.1.4 总结线程私有区"></a>1.1.4 总结线程私有区</h4><table>
<thead>
<tr>
<th>内存区域</th>
<th>作用</th>
<th>特点</th>
<th>可能的异常</th>
</tr>
</thead>
<tbody><tr>
<td><strong>程序计数器</strong></td>
<td>记录下一条要执行的字节码指令地址</td>
<td>唯一无OOM的区域，线程切换恢复执行位置的关键</td>
<td>无</td>
</tr>
<tr>
<td><strong>Java虚拟机栈</strong></td>
<td>存储Java方法调用的状态（栈帧）</td>
<td>LIFO，方法调用与栈帧出入栈对应</td>
<td><code>StackOverflowError</code>, <code>OOM</code></td>
</tr>
<tr>
<td><strong>本地方法栈</strong></td>
<td>存储Native方法调用的状态</td>
<td>服务于JNI，HotSpot中与Java栈合一</td>
<td><code>StackOverflowError</code>, <code>OOM</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="1-2-线程共享区域"><a href="#1-2-线程共享区域" class="headerlink" title="1.2 线程共享区域"></a>1.2 线程共享区域</h3><p>与线程私有区域不同，线程共享区域随着虚拟机的启动而创建，只要虚拟机不退出，它们就一直存在。所有线程都可以访问这部分内存，因此它们是并发编程中需要重点关注的区域，也是线程安全问题的“重灾区”。</p>
<h4 id="1-2-1-Java-堆-Heap"><a href="#1-2-1-Java-堆-Heap" class="headerlink" title="1.2.1 Java 堆 (Heap)"></a>1.2.1 Java 堆 (Heap)</h4><ul>
<li><strong>核心定义</strong><br>Java堆是Java虚拟机所管理的内存中<strong>最大的一块</strong>。它是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是<strong>存放对象实例</strong>。</li>
<li><strong>作用与原理</strong><ol>
<li><strong>对象实例的存储</strong>：几乎所有的<strong>对象实例</strong>以及<strong>数组</strong>都在这里分配内存。通过<code>new</code>关键字创建的对象，其数据就存放在堆上。栈中通常只保存该对象在堆中的引用（地址）。</li>
<li><strong>垃圾回收的主战场</strong>：堆是垃圾收集器（Garbage Collector, GC）进行管理和回收的主要区域。GC通过可达性分析等算法，判断哪些对象不再被使用，并回收它们占用的内存，从而实现内存的自动管理。</li>
</ol>
</li>
<li><strong>堆的内部结构 (以HotSpot为例)</strong><br>为了优化GC的效率，HotSpot虚拟机通常采用**分代收集（Generational Collection）**的思想来管理堆内存。堆被划分为两个主要区域：<ul>
<li><strong>新生代 (Young Generation &#x2F; New Generation)</strong><ul>
<li><strong>特点</strong>：绝大多数新创建的对象都首先分配在这里。新生代的对象生命周期短，”朝生夕死”，因此GC在这里发生的频率非常高（称为Minor GC或Young GC），但速度也很快。</li>
<li><strong>内部结构</strong>：新生代内部又被细分为三个区域：<ul>
<li><strong>伊甸园区 (Eden Space)</strong>：新对象分配的主要区域。当Eden区满时，会触发一次Minor GC。</li>
<li><strong>两个幸存者区 (Survivor Space)</strong>：通常称为 From Space (S0) 和 To Space (S1)。它们大小相等，并且在任意时刻只有一个是“激活”的（有数据）。</li>
</ul>
</li>
<li><strong>Minor GC 流程 (基于标记-复制算法)</strong>：<ol>
<li>当Eden区满时，GC启动。</li>
<li>将Eden区和当前“激活”的Survivor区（假设是S0）中仍然存活的对象，复制到另一个“未激活”的Survivor区（S1）。</li>
<li>在复制过程中，对象的“年龄”（经历的GC次数）会加1。</li>
<li>清空Eden区和S0区。</li>
<li>下一次Minor GC时，S1和S0的角色互换。</li>
</ol>
</li>
</ul>
</li>
<li><strong>老年代 (Old Generation &#x2F; Tenured Generation)</strong><ul>
<li><strong>特点</strong>：存放生命周期较长的对象。当老年代空间不足时，会触发一次Major GC或Full GC，这个过程通常比Minor GC慢得多。</li>
<li><strong>对象来源</strong>：<ol>
<li><strong>晋升 (Promotion)</strong>：在新生代中经历了多次Minor GC仍然存活的对象（默认是15次，可通过<code>-XX:MaxTenuringThreshold</code>调整），会被“晋升”到老年代。</li>
<li><strong>大对象直接分配</strong>：非常大的对象（如长数组）可能会绕过新生代，直接在老年代分配。这是为了避免新生代频繁GC时，大对象在Eden和Survivor区之间进行大量内存复制。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>相关概念与异常</strong><ul>
<li><strong>TLAB (Thread Local Allocation Buffer)</strong>：线程本地分配缓冲区。虽然堆是线程共享的，但为了提高对象分配的效率，避免多线程同时在Eden区分配对象时需要加锁竞争，JVM会为每个新创建的线程在Eden区分配一小块私有区域——TLAB。线程创建新对象时，优先在自己的TLAB中分配，只有当TLAB用完或对象太大放不下时，才需要通过加锁在共享的Eden区中分配。这是一种**“私有化共享区域”**的优化手段。</li>
<li><strong><code>OutOfMemoryError: Java heap space</code></strong>：如果堆中没有足够内存来完成实例分配，并且堆也无法再扩展时，就会抛出这个最常见的OOM错误。</li>
</ul>
</li>
<li><strong>形象比喻</strong><br>可以把Java堆想象成一个<strong>城市</strong>。<ul>
<li><strong>新生代</strong>是**“青年公寓区”**，大部分年轻人（新对象）都住在这里，人员流动非常快（频繁GC）。<ul>
<li><strong>Eden区</strong>是**“接待大厅”**，所有新来的人先在这里落脚。</li>
<li><strong>Survivor区</strong>是两个**“中转宿舍”**，经历过一次人口普查（Minor GC）还没搬走的人会在这里暂住。</li>
</ul>
</li>
<li><strong>老年代</strong>是**“长寿社区”**，在青年公寓区住久了的老人（长寿对象）会搬到这里，环境稳定，不轻易动迁（不常GC）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-2-方法区-Method-Area"><a href="#1-2-2-方法区-Method-Area" class="headerlink" title="1.2.2 方法区 (Method Area)"></a>1.2.2 方法区 (Method Area)</h4><ul>
<li><strong>核心定义</strong><br>方法区也是所有线程共享的内存区域，它用于存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器（JIT）编译后的代码缓存</strong>等数据。</li>
<li><strong>作用与原理</strong><ol>
<li><strong>类型信息存储</strong>：当JVM通过类加载器加载一个<code>.class</code>文件时，它会从文件信息中解析出类的元数据，并存放在方法区。这些信息包括：<ul>
<li>类的全限定名。</li>
<li>父类的全限定名。</li>
<li>方法的完整信息（名称、返回类型、参数、字节码）。</li>
<li>字段的完整信息（名称、类型、修饰符）。</li>
</ul>
</li>
<li><strong>运行时常量池 (Runtime Constant Pool)</strong>：<ul>
<li>它是方法区的一部分。<code>.class</code>文件中的常量池（Constant Pool）在类加载后，其内容会进入方法区的运行时常量池。</li>
<li>除了存放编译期生成的各种字面量和符号引用外，它还具备<strong>动态性</strong>。例如，<code>String.intern()</code>方法就可以在运行时将新的常量放入池中。</li>
</ul>
</li>
<li><strong>静态变量存储</strong>：类中用<code>static</code>修饰的变量（也叫类变量）会存放在方法区。</li>
</ol>
</li>
<li><strong>演进历史：永久代 (Permanent Generation) vs. 元空间 (Metaspace)</strong><br>方法区是一个<strong>逻辑概念</strong>，《Java虚拟机规范》只规定了它的作用，并没有规定如何实现。不同的JVM实现可以有不同的方式。<ul>
<li><strong>JDK 7及以前 (HotSpot) - 永久代 (PermGen)</strong><ul>
<li><strong>实现方式</strong>：HotSpot虚拟机使用<strong>永久代</strong>来实现方法区。这意味着方法区的内存是<strong>Java堆的一部分</strong>，也受GC管理。</li>
<li><strong>弊端</strong>：<ul>
<li><strong>内存大小受限</strong>：永久代有一个固定的最大大小（<code>-XX:MaxPermSize</code>），如果动态加载的类过多（如在一些OSGi、动态代理、CGLIB等场景），很容易导致 <code>OutOfMemoryError: PermGen space</code>。</li>
<li><strong>GC效率问题</strong>：对永久代进行GC的效率和效果并不理想。</li>
</ul>
</li>
</ul>
</li>
<li><strong>JDK 8及以后 (HotSpot) - 元空间 (Metaspace)</strong><ul>
<li><strong>实现方式</strong>：从JDK 8开始，HotSpot彻底移除了永久代，取而代之的是<strong>元空间</strong>。</li>
<li><strong>重大变化</strong>：元空间<strong>不再使用JVM堆内存</strong>，而是直接使用<strong>本地内存（Native Memory）</strong>。</li>
<li><strong>优势</strong>：<ul>
<li><strong>内存大小不再受限</strong>：理论上，只要你的物理机内存足够，元空间就可以一直扩展。这极大地降低了因类加载过多而导致OOM的风险。默认情况下，元空间的大小仅受可用本地内存的限制。</li>
<li><strong>GC解耦</strong>：元空间的管理与堆内存的GC解耦，虽然元空间本身也会触发GC（当其占用的本地内存达到阈值时），但其管理更加灵活。</li>
</ul>
</li>
<li><strong>相关参数</strong>：<code> -XX:MetaspaceSize</code> (初始大小) 和 <code>-XX:MaxMetaspaceSize</code> (最大大小)。</li>
</ul>
</li>
</ul>
</li>
<li><strong>相关异常</strong><ul>
<li><strong><code>OutOfMemoryError: PermGen space</code></strong> (JDK 7及以前)</li>
<li><strong><code>OutOfMemoryError: Metaspace</code></strong> (JDK 8及以后)：当元空间无法申请到足够的本地内存时抛出。</li>
</ul>
</li>
<li><strong>形象比喻</strong><br>可以把方法区想象成一个城市的**“中央图书馆”**。<ul>
<li>图书馆里存放着这个城市所有机构和建筑（<strong>类</strong>）的<strong>设计蓝图和档案</strong>（元数据）。</li>
<li><strong>运行时常量池</strong>就像是图书馆的**“索引总表”**，记录了所有蓝图里提到的材料、供应商、外部专家（符号引用）的联系方式。</li>
<li><strong>静态变量</strong>就像是图书馆大厅里展示的<strong>公共雕塑或展品</strong>，所有市民（线程）都可以看到和使用。</li>
<li><strong>永久代</strong>是把图书馆建在了<strong>城市内部有限的土地上</strong>，地方不够就容易出问题。</li>
<li><strong>元空间</strong>是把图书馆建在了<strong>城市外的广阔土地上（本地内存）</strong>，地方几乎无限大，扩展起来方便多了。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-3-总结线程共享区域"><a href="#1-2-3-总结线程共享区域" class="headerlink" title="1.2.3 总结线程共享区域"></a>1.2.3 总结线程共享区域</h4><table>
<thead>
<tr>
<th>内存区域</th>
<th>作用</th>
<th>特点</th>
<th>可能的异常</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Java堆</strong></td>
<td>存放对象实例和数组</td>
<td>GC的主要区域，分代管理（新生代、老年代），可有TLAB优化</td>
<td><code>OutOfMemoryError: Java heap space</code></td>
</tr>
<tr>
<td><strong>方法区</strong></td>
<td>存储类信息、常量、静态变量、JIT代码等</td>
<td>逻辑区域，JDK8前由永久代实现，JDK8后由元空间（本地内存）实现</td>
<td><code>OutOfMemoryError: PermGen/Metaspace</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="1-3-重点辨析"><a href="#1-3-重点辨析" class="headerlink" title="1.3 重点辨析"></a>1.3 重点辨析</h3><h4 id="1-3-1-堆-Heap-与-栈-Stack-的核心区别"><a href="#1-3-1-堆-Heap-与-栈-Stack-的核心区别" class="headerlink" title="1.3.1 堆 (Heap) 与 栈 (Stack) 的核心区别"></a>1.3.1 堆 (Heap) 与 栈 (Stack) 的核心区别</h4><p>它们的差异贯穿了内存管理、性能、数据存储和并发等多个维度。</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Java 虚拟机栈 (Stack)</th>
<th>Java 堆 (Heap)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>功能&#x2F;作用</strong></td>
<td><strong>存储方法调用的状态</strong>。每个线程有自己的栈，用于跟踪方法调用链。存放<strong>栈帧</strong>，包含局部变量、操作数栈等。</td>
<td><strong>存储对象实例和数组</strong>。是所有线程共享的数据区域，用于动态分配内存。</td>
</tr>
<tr>
<td><strong>数据存储</strong></td>
<td>存储<strong>基本数据类型</strong>（<code>int</code>, <code>double</code>等）的值，以及<strong>对象的引用</strong>（即对象在堆中的地址）。</td>
<td>存储<strong>通过<code>new</code>关键字创建的对象实例</strong>和<strong>数组</strong>的实际数据。</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td><strong>与线程相同</strong>。方法调用时创建栈帧（入栈），方法结束时销毁栈帧（出栈）。<strong>栈内存会自动释放</strong>。</td>
<td><strong>与JVM进程几乎相同</strong>（从启动到关闭）。对象的生命周期由**垃圾回收器（GC）**决定和管理。</td>
</tr>
<tr>
<td><strong>内存管理</strong></td>
<td><strong>由编译器自动管理</strong>，无需程序员干预。内存分配和释放非常快速，类似于数据结构中的“栈”。</td>
<td><strong>由程序员申请</strong>（通过<code>new</code>），但<strong>由GC自动回收</strong>。管理相对复杂，分配和回收开销较大。</td>
</tr>
<tr>
<td><strong>共享性</strong></td>
<td><strong>线程私有</strong>。每个线程都有独立的栈，互不干扰，不存在线程安全问题。</td>
<td><strong>所有线程共享</strong>。多线程访问共享对象时，需要考虑<strong>线程安全</strong>问题，如加锁。</td>
</tr>
<tr>
<td><strong>空间大小</strong></td>
<td><strong>空间较小且固定</strong>（可通过<code>-Xss</code>设置）。深度有限，容易发生<code>StackOverflowError</code>。</td>
<td><strong>空间较大且可动态调整</strong>（通过<code>-Xms</code>和<code>-Xmx</code>设置）。是内存消耗的大户，容易发生<code>OutOfMemoryError</code>。</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td><strong>访问速度快</strong>。栈顶数据是活跃数据，CPU有专门的指令支持，内存是连续的，访问效率高。</td>
<td><strong>访问速度相对较慢</strong>。因为内存不一定是连续的，且对象的定位可能需要间接访问（如句柄）。</td>
</tr>
</tbody></table>
<p><strong>一个典型的代码示例来解释：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// name 是一个引用，存储在Person对象内部，即在堆上</span></span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// main方法入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        <span class="comment">// 1. &#x27;age&#x27; 是基本类型，直接在 main 方法的栈帧的局部变量表中存储值 25</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          2. 执行这行代码</span></span><br><span class="line"><span class="comment">          a. new Person(&quot;Alice&quot;) 在【堆】上创建一个Person对象实例</span></span><br><span class="line"><span class="comment">          b. &#x27;p1&#x27; 是一个引用变量，在 main 方法的栈帧的局部变量表中存储【堆】上那个对象的地址</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. &#x27;p2&#x27; 也是一个引用变量，它复制了 &#x27;p1&#x27; 的值，即【堆】上同一个对象的地址</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> p1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 调用 doSomething 方法</span></span><br><span class="line">        doSomething(p2, age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. main 方法执行完毕，其栈帧出栈，&#x27;age&#x27;, &#x27;p1&#x27;, &#x27;p2&#x27; 消失</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        5. doSomething 方法入栈，创建新的栈帧</span></span><br><span class="line"><span class="comment">        a. &#x27;p&#x27; 是一个新的引用变量，它的值是 main 中 p2 传来的地址副本</span></span><br><span class="line"><span class="comment">        b. &#x27;num&#x27; 是一个新的基本类型变量，它的值是 main 中 age 传来的值副本 (25)</span></span><br><span class="line"><span class="comment">        ... some operations</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(Person p, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6. doSomething 方法执行完毕，其栈帧出栈，&#x27;p&#x27; 和 &#x27;num&#x27; 消失</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li><strong>栈管运行，堆管存储。</strong> 栈像一个方法的执行流水线，而堆像一个所有对象的存储仓库。</li>
<li><strong>栈是“朝生夕死”的，堆是“生死未卜”的。</strong> 栈中数据随方法调用结束而亡，堆中对象何时死亡由GC决定。</li>
</ul>
<hr>
<h4 id="1-3-2-永久代-PermGen-vs-元空间-Metaspace-的演进与差异"><a href="#1-3-2-永久代-PermGen-vs-元空间-Metaspace-的演进与差异" class="headerlink" title="1.3.2 永久代 (PermGen) vs. 元空间 (Metaspace) 的演进与差异"></a>1.3.2 永久代 (PermGen) vs. 元空间 (Metaspace) 的演进与差异</h4><p>这是HotSpot虚拟机中关于<strong>方法区实现</strong>的重大变迁，是JDK 8最显著的变化之一。</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>永久代 (Permanent Generation) - JDK 7及以前</th>
<th>元空间 (Metaspace) - JDK 8及以后</th>
</tr>
</thead>
<tbody><tr>
<td><strong>本质&#x2F;实现</strong></td>
<td><strong>方法区的一种实现</strong>，并且是<strong>Java堆内存的一部分</strong>。</td>
<td><strong>方法区的一种实现</strong>，但使用的是<strong>本地内存（Native Memory）</strong>，而非JVM堆内存。</td>
</tr>
<tr>
<td><strong>内存位置</strong></td>
<td>位于<strong>JVM堆内存</strong>中，与新生代、老年代在逻辑上并列。</td>
<td>位于<strong>操作系统的本地内存</strong>中，独立于JVM堆。</td>
</tr>
<tr>
<td><strong>内存管理</strong></td>
<td><strong>受JVM堆内存大小限制</strong>。需要通过 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 进行设置。</td>
<td><strong>默认只受限于可用本地内存的大小</strong>。可以通过 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 设置，但通常不设上限。</td>
</tr>
<tr>
<td><strong>GC影响</strong></td>
<td><strong>Full GC会扫描和回收永久代</strong>。回收效果不佳，容易因类加载过多而触发Full GC。</td>
<td><strong>元空间的GC是独立触发的</strong>。当元空间占用达到一定阈值（由<code>MetaspaceSize</code>等参数影响）时，会触发专门的GC来卸载不再使用的类。与堆的Full GC解耦。</td>
</tr>
<tr>
<td><strong>典型问题</strong></td>
<td><strong><code>java.lang.OutOfMemoryError: PermGen space</code></strong>。非常常见，尤其是在动态类加载、反射、代理等场景下。</td>
<td><strong><code>java.lang.OutOfMemoryError: Metaspace</code></strong>。相对少见，通常是由于加载了海量的类，且 <code>-XX:MaxMetaspaceSize</code> 设置过小，或本地内存耗尽。</td>
</tr>
<tr>
<td><strong>字符串常量池</strong></td>
<td><strong>在JDK 6及以前，位于永久代</strong>。<strong>从JDK 7开始，被移到了Java堆中</strong>。</td>
<td>字符串常量池<strong>仍然位于Java堆中</strong>，与元空间无关。</td>
</tr>
<tr>
<td><strong>静态变量</strong></td>
<td><strong>位于永久代</strong>。</td>
<td>伴随类元信息一起，<strong>也存储在元空间中</strong>。</td>
</tr>
</tbody></table>
<p><strong>为什么要做这个改变？</strong></p>
<ol>
<li><strong>解决内存溢出问题</strong>：<code>PermGen space</code> OOM是过去Java应用非常头疼的问题。将方法区移到使用本地内存的元空间，可以利用更广阔的物理内存，从根本上降低了此类OOM的风险。</li>
<li><strong>提升GC效率与简化GC实现</strong>：将方法区的元数据与堆中的对象实例进行物理隔离，使得GC可以针对不同区域的特点设计更高效的回收策略。简化了Full GC的复杂性，因为不再需要处理堆中这块“特殊”的永久代区域。</li>
<li><strong>为未来技术融合做准备</strong>：移除永久代是HotSpot虚拟机与JRockit虚拟机（另一款优秀的Oracle JVM，没有永久代的概念）代码融合的一部分。统一技术架构，有利于未来的维护和发展（例如GraalVM等新技术的引入）。</li>
</ol>
<p><strong>总结：</strong></p>
<p>从永久代到元空间的演进，是HotSpot虚拟机一次重要的<strong>自我进化和现代化改造</strong>。它通过<strong>将方法区的实现从JVM堆内存中剥离出来，改用更灵活、更广阔的本地内存</strong>，从而解决了长期困扰开发者的<code>PermGen</code> OOM问题，并优化了GC的复杂度和性能。这是一个典型的权衡与取舍：用更复杂的底层内存管理（与操作系统交互）换取了上层应用更好的稳定性和性能。</p>
<hr>
<h3 id="1-4-直接内存-Direct-Memory"><a href="#1-4-直接内存-Direct-Memory" class="headerlink" title="1.4 直接内存 (Direct Memory)"></a>1.4 直接内存 (Direct Memory)</h3><ul>
<li><p><strong>核心定义</strong><br>直接内存（Direct Memory）并不是《Java虚拟机规范》中定义的运行时数据区的一部分，也不是由JVM直接管理的内存区域。它是在Java堆之外，<strong>直接向操作系统申请的一块内存空间</strong>。Java程序可以通过<code>java.nio</code>包中的<code>ByteBuffer</code>类来间接操作这块内存。</p>
</li>
<li><p><strong>为什么需要直接内存？—— 解决I&#x2F;O性能瓶颈</strong><br>要理解直接内存的价值，首先需要了解传统的基于Java堆内存的I&#x2F;O操作（称为<strong>堆内缓冲区，Heap Buffer</strong>）存在的问题。</p>
<p><strong>传统I&#x2F;O操作流程（使用Heap Buffer）：</strong><br>假设我们要从磁盘读取一个文件，并通过网络发送出去。</p>
<ol>
<li>Java程序发起<code>read()</code>系统调用。</li>
<li><strong>第一次拷贝</strong>：操作系统内核从磁盘读取数据到<strong>内核缓冲区（Kernel Buffer）</strong>。</li>
<li><strong>第二次拷贝</strong>：操作系统内核将内核缓冲区的数据，拷贝到Java程序的**堆内存缓冲区（Heap Buffer）**中。此时，<code>read()</code>调用返回，Java程序可以操作这份数据了。</li>
<li>Java程序发起<code>write()</code>系统调用，准备将数据发送到网络。</li>
<li><strong>第三次拷贝</strong>：操作系统内核将Java程序的堆内存缓冲区的数据，再次拷贝到与网络Socket关联的<strong>内核缓冲区</strong>中。</li>
<li><strong>第四次拷贝</strong>：操作系统内核将Socket内核缓冲区的数据，拷贝到网络协议引擎（如网卡缓冲区）中，完成发送。</li>
</ol>
<p><strong>问题所在</strong>：在这个过程中，数据在内核空间和用户空间（Java堆）之间来回<strong>拷贝了两次（步骤2和3）</strong>。对于大文件或高并发的I&#x2F;O场景，这两次冗余的拷贝会极大地消耗CPU资源和内存带宽，成为性能瓶颈。</p>
</li>
<li><p><strong>直接内存如何优化？—— 零拷贝（Zero-Copy）思想</strong><br>直接内存的引入，就是为了避免这种冗余的数据拷贝。通过<code>ByteBuffer.allocateDirect()</code>创建的<strong>直接缓冲区（Direct Buffer）</strong>，其内存是直接在操作系统的本地内存中分配的。</p>
<p><strong>使用直接内存的I&#x2F;O操作流程（使用Direct Buffer）：</strong></p>
<ol>
<li>Java程序通过<code>ByteBuffer.allocateDirect()</code>创建一个直接缓冲区，这块内存的地址对Java代码和操作系统内核都是可见的。</li>
<li>Java程序发起<code>read()</code>系统调用。</li>
<li><strong>第一次拷贝</strong>：操作系统内核从磁盘读取数据，<strong>直接拷贝到这个直接缓冲区</strong>中。数据一步到位，不再需要拷贝到Java堆。</li>
<li>Java程序发起<code>write()</code>系统调用。</li>
<li><strong>第二次拷贝</strong>：操作系统内核直接将<strong>直接缓冲区</strong>中的数据，拷贝到与网络Socket关联的内核缓冲区中，然后发送。</li>
</ol>
<p><strong>效果</strong>：通过使用直接内存，我们成功地<strong>省去了数据在内核缓冲区和Java堆之间的两次拷贝</strong>，数据传递路径从“磁盘 -&gt; 内核 -&gt; 堆 -&gt; 内核 -&gt; 网卡”缩短为“磁盘 -&gt; 内核（直接内存）-&gt; 网卡”。这种技术通常被称为“零拷贝”的一种形式（虽然并非严格意义上的零拷贝，但显著减少了拷贝次数）。</p>
</li>
<li><p><strong>如何使用直接内存</strong><br>Java通过<code>java.nio.ByteBuffer</code>类提供了对直接内存的访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectMemoryExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 分配1MB的直接内存</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">directBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向直接内存中写入数据</span></span><br><span class="line">        directBuffer.put(<span class="string">&quot;Hello, Direct Memory!&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换到读模式</span></span><br><span class="line">        directBuffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从直接内存中读取数据</span></span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[directBuffer.remaining()];</span><br><span class="line">        directBuffer.get(data);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接内存的释放由GC间接管理，也可以手动清理（不推荐，但特定场景下有用）</span></span><br><span class="line">        <span class="comment">// ((DirectBuffer) directBuffer).cleaner().clean();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>直接内存的管理与回收</strong></p>
<ul>
<li><strong>分配</strong>：直接内存的分配成本较高，因为它需要调用底层的<code>malloc</code>等操作系统函数，比在堆上分配对象要慢。因此，直接内存适合用于创建需要<strong>长期存在、会被频繁复用</strong>的缓冲区。</li>
<li><strong>回收</strong>：直接内存不受JVM堆GC的直接管理。它的回收机制比较特殊：<ol>
<li>当创建一个<code>DirectByteBuffer</code>对象时，JVM会同时创建一个**<code>Cleaner</code>对象**（一种特殊的虚引用）。</li>
<li>这个<code>DirectByteBuffer</code>对象本身是存储在Java堆上的，它很小，只包含直接内存的地址、大小等信息。</li>
<li>当堆上的<code>DirectByteBuffer</code>对象<strong>不再被任何强引用指向</strong>，并且在下一次GC中被判定为可回收时，GC会处理与之关联的<code>Cleaner</code>对象。</li>
<li><code>Cleaner</code>对象被触发后，会通过一个专门的低优先级线程（<code>ReferenceHandler</code>线程）去执行一个清理任务，这个任务最终会调用<code>Unsafe.freeMemory()</code>来<strong>释放对应的本地直接内存</strong>。</li>
</ol>
</li>
<li><strong>潜在风险</strong>：<ul>
<li><strong>内存泄漏</strong>：由于直接内存的回收依赖于堆中<code>DirectByteBuffer</code>对象的GC，如果长时间没有触发Full GC（比如堆内存很充足），而直接内存又被大量分配和废弃，可能会导致<strong>本地内存耗尽</strong>，从而抛出<code>OutOfMemoryError: Direct buffer memory</code>。</li>
<li><strong>管理参数</strong>：可以通过 <code>-XX:MaxDirectMemorySize</code>来指定JVM可以使用的直接内存的最大值。当超出这个限制时，也会抛出OOM。如果不设置，默认值与Java堆最大值（<code>-Xmx</code>）相同。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>应用场景</strong></p>
<ul>
<li><strong>NIO网络编程</strong>：Netty、Mina等高性能网络框架大量使用直接内存作为网络通信的缓冲区，以提升吞吐量和降低延迟。</li>
<li><strong>文件操作</strong>：<code>FileChannel</code>的<code>map</code>方法可以将文件直接映射到内存中（<code>MappedByteBuffer</code>），这背后也是直接内存技术，非常适合处理大文件。</li>
<li><strong>大数据和内存计算</strong>：一些内存数据库或计算框架（如Apache Flink、Spark）会利用直接内存来管理海量数据，避免GC带来的性能抖动。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>维度</th>
<th>直接内存 (Direct Memory)</th>
<th>Java堆 (Heap)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>位置</strong></td>
<td><strong>操作系统本地内存</strong>，JVM堆之外。</td>
<td><strong>JVM管理的内存区域</strong>。</td>
</tr>
<tr>
<td><strong>管理</strong></td>
<td>由Java代码（<code>ByteBuffer.allocateDirect</code>）申请，但其生命周期由GC<strong>间接管理</strong>（通过<code>Cleaner</code>）。</td>
<td>由Java代码（<code>new</code>）申请，由GC<strong>直接管理</strong>。</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td><strong>分配&#x2F;销毁慢</strong>，但<strong>I&#x2F;O操作快</strong>（减少了数据拷贝）。</td>
<td><strong>分配&#x2F;销毁快</strong>（通过TLAB等优化），但<strong>I&#x2F;O操作慢</strong>（存在额外拷贝）。</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>高性能I&#x2F;O、需要长期存在且被复用的大缓冲区。</td>
<td>绝大多数常规的对象创建和业务逻辑处理。</td>
</tr>
<tr>
<td><strong>风险</strong></td>
<td>可能因GC不及时导致本地内存泄漏，抛出 <code>OOM: Direct buffer memory</code>。</td>
<td>经典的对象分配过多导致 <code>OOM: Java heap space</code>。</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-HotSpot中的对象"><a href="#2-HotSpot中的对象" class="headerlink" title="2. HotSpot中的对象"></a>2. HotSpot中的对象</h2><h3 id="2-1-对象的创建过程-new指令、分配内存、初始化"><a href="#2-1-对象的创建过程-new指令、分配内存、初始化" class="headerlink" title="2.1 对象的创建过程 (new指令、分配内存、初始化)"></a>2.1 对象的创建过程 (new指令、分配内存、初始化)</h3><p>当我们写下 <code>Person p = new Person();</code> 这行代码时，从JVM的视角看，它经历了一个复杂而严谨的过程。这个过程可以分解为以下几个关键步骤：</p>
<h4 id="2-1-1-总览流程图"><a href="#2-1-1-总览流程图" class="headerlink" title="2.1.1 总览流程图"></a>2.1.1 总览流程图</h4><pre><code class="highlight mermaid">graph TD
    subgraph &quot;执行入口&quot;
        A[&quot;[Java Code: new Person()]&quot;]
    end

    A --&gt; B[(&quot;1&quot;)];

    subgraph &quot;JVM内部流程&quot;
        B --- B_desc[&quot;&lt;strong&gt;1. 类加载检查&lt;/strong&gt;&lt;br/&gt;JVM遇到new指令，检查Person类是否已加载、解析、初始化？&lt;br/&gt;(是) -&gt; 继续&lt;br/&gt;(否) -&gt; 先执行类加载过程&quot;];
        B_desc --&gt; C[(&quot;2&quot;)];
        C --- C_desc[&quot;&lt;strong&gt;2. 分配内存&lt;/strong&gt;&lt;br/&gt;在Java堆中为Person对象分配一块确定大小的内存&lt;br/&gt;- 方式1: 指针碰撞 (Bump the Pointer)&lt;br/&gt;- 方式2: 空闲列表 (Free List)&lt;br/&gt;- 并发处理: CAS 或 TLAB&quot;];
        C_desc --&gt; D[(&quot;3&quot;)];
        D --- D_desc[&quot;&lt;strong&gt;3. 初始化零值&lt;/strong&gt;&lt;br/&gt;将分配到的内存空间所有字节清零 (不包括对象头)&lt;br/&gt;- 保证字段不赋初值时也有默认值 (0, false, null)&quot;];
        D_desc --&gt; E[(&quot;4&quot;)];
        E --- E_desc[&quot;&lt;strong&gt;4. 设置对象头&lt;/strong&gt;&lt;br/&gt;填充对象头(Object Header)信息&lt;br/&gt;- Mark Word: 哈希码, GC年龄, 锁状态...&lt;br/&gt;- Klass Pointer: 指向方法区中Person类的元数据&quot;];
        E_desc --&gt; F[(&quot;5&quot;)];
        F --- F_desc[&quot;&lt;strong&gt;5. 执行&amp;lt;init&amp;gt;方法&lt;/strong&gt;&lt;br/&gt;执行invokespecial指令，调用Person的构造方法&lt;br/&gt;- 按照程序员的意图进行初始化 (字段赋值、执行构造代码)&quot;];
    end

    F_desc --&gt; G;

    subgraph &quot;最终结果&quot;
        G[&quot;栈上的引用 p 指向堆中的新对象&quot;]
    end

    %% 样式定义
    style A fill:#f9f,stroke:#333,stroke-width:2px
    style G fill:#ccf,stroke:#333,stroke-width:2px
    style B fill:#bbf,stroke:#333,stroke-width:2px
    style C fill:#bbf,stroke:#333,stroke-width:2px
    style D fill:#bbf,stroke:#333,stroke-width:2px
    style E fill:#bbf,stroke:#333,stroke-width:2px
    style F fill:#bbf,stroke:#333,stroke-width:2px</code></pre>

<hr>
<h4 id="2-1-2-详细步骤分解"><a href="#2-1-2-详细步骤分解" class="headerlink" title="2.1.2 详细步骤分解"></a>2.1.2 详细步骤分解</h4><h5 id="1-类加载检查-Class-Loading-Check"><a href="#1-类加载检查-Class-Loading-Check" class="headerlink" title="1. 类加载检查 (Class Loading Check)"></a>1. 类加载检查 (Class Loading Check)</h5><p>当JVM执行引擎遇到一条<code>new</code>字节码指令时，它首先会执行一个检查：</p>
<ul>
<li><strong>定位类的符号引用</strong>：<code>new</code>指令的参数是在常量池中指向这个类（如<code>Person</code>）的符号引用。</li>
<li><strong>检查类是否已加载</strong>：JVM会检查这个符号引用代表的类是否已经被加载、解析和初始化过。</li>
<li><strong>触发类加载</strong>：如果该类还没有被加载，JVM必须立即启动相应的<strong>类加载过程</strong>（加载、链接、初始化）。这是确保对象能够被正确创建的前提。</li>
</ul>
<hr>
<h5 id="2-分配内存-Memory-Allocation"><a href="#2-分配内存-Memory-Allocation" class="headerlink" title="2. 分配内存 (Memory Allocation)"></a>2. 分配内存 (Memory Allocation)</h5><p>类加载检查通过后，JVM就要在<strong>Java堆</strong>中为这个新对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。</p>
<p>内存分配的方式取决于Java堆是否规整，而堆是否规整又由所采用的垃圾收集器是否带有**空间压缩整理（Compact）**功能决定。</p>
<ul>
<li><strong>分配方式一：指针碰撞 (Bump the Pointer)</strong><ul>
<li><strong>适用场景</strong>：当堆内存是<strong>绝对规整</strong>的（即所有用过的内存在一边，未用的在另一边），比如使用<strong>Serial、ParNew</strong>等带Compact过程的收集器时。</li>
<li><strong>工作原理</strong>：内存分配就非常简单，只需维护一个指针作为已用内存和空闲内存的分界点。当需要分配内存时，<strong>把指针向空闲空间那边挪动一段与对象大小相等的距离</strong>即可。</li>
<li><strong>比喻</strong>：就像在电影院里按顺序入座，售票员只需要记住下一个空座位是第几排第几号。</li>
</ul>
</li>
<li><strong>分配方式二：空闲列表 (Free List)</strong><ul>
<li><strong>适用场景</strong>：当堆内存是<strong>不规整</strong>的（已用和未用的内存相互交错），比如使用<strong>CMS</strong>这种基于标记-清除算法的收集器时。</li>
<li><strong>工作原理</strong>：JVM必须维护一个<strong>列表</strong>，记录哪些内存块是可用的。分配时，从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</li>
<li><strong>比喻</strong>：就像在已经有人坐的电影院里找一个空位，你需要一张“座位图”（空闲列表）来找到合适的位置。</li>
</ul>
</li>
</ul>
<p><strong>并发问题及其解决方案：</strong></p>
<p>在多线程环境下，多个线程可能同时申请内存（即同时执行<code>new</code>操作），这会导致并发问题。比如，两个线程可能同时看中了同一块内存。JVM采用以下两种方案来保证线程安全：</p>
<ol>
<li><strong>CAS + 失败重试 (Compare-And-Swap)</strong>：<br>JVM采用CAS配上失败重试的方式来保证更新操作的原子性。当一个线程尝试更新内存分配指针时，它会检查这个指针是否还是之前它读取时的值。如果是，就更新；如果不是（说明被其他线程修改了），就重试，直到成功为止。这是一种<strong>乐观锁</strong>机制。</li>
<li><strong>线程本地分配缓冲 (Thread Local Allocation Buffer, TLAB)</strong>：<br>这是更常用、更高效的解决方案。它的核心思想是<strong>为每个线程在Java堆的Eden区预先分配一小块私有内存</strong>。<ul>
<li>当线程需要分配对象时，<strong>首先在自己的TLAB中进行分配</strong>。因为这是线程私有的，所以完全不需要同步，速度极快。</li>
<li>只有当TLAB用完，或者要分配的对象太大TLAB放不下时，才需要通过上述的CAS机制到共享的Eden区中分配。</li>
<li>是否启用TLAB由JVM参数 <code>-XX:+/-UseTLAB</code> 控制（默认开启）。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="3-初始化零值-Zero-Value-Initialization"><a href="#3-初始化零值-Zero-Value-Initialization" class="headerlink" title="3. 初始化零值 (Zero-Value Initialization)"></a>3. 初始化零值 (Zero-Value Initialization)</h5><p>内存分配完成后，虚拟机必须将分配到的内存空间（<strong>不包括对象头</strong>）都初始化为<strong>零值</strong>。</p>
<ul>
<li><strong>作用</strong>：这一步操作保证了对象的实例字段在Java代码中可以不赋初值就直接使用。程序能访问到这些字段的数据类型所对应的默认值（如<code>int</code>为<code>0</code>，<code>boolean</code>为<code>false</code>，引用类型为<code>null</code>）。</li>
<li><strong>位置</strong>：这个操作发生在<strong>设置对象头之前</strong>，是在JVM层面完成的。</li>
</ul>
<hr>
<h5 id="4-设置对象头-Setting-the-Object-Header"><a href="#4-设置对象头-Setting-the-Object-Header" class="headerlink" title="4. 设置对象头 (Setting the Object Header)"></a>4. 设置对象头 (Setting the Object Header)</h5><p>初始化零值之后，虚拟机要对对象进行必要的设置，将一些关键信息存入对象的**对象头 (Object Header)**中。对象头包含两部分主要信息：</p>
<ul>
<li><strong>Mark Word (标记字段)</strong>：存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等。这部分数据是动态的。</li>
<li><strong>Klass Pointer (类型指针)</strong>：即对象指向它的类元数据的指针。虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
</ul>
<hr>
<h5 id="5-执行-方法-Constructor-Execution"><a href="#5-执行-方法-Constructor-Execution" class="headerlink" title="5. 执行 &lt;init&gt; 方法 (Constructor Execution)"></a>5. 执行 <code>&lt;init&gt;</code> 方法 (Constructor Execution)</h5><p>在上述所有步骤都完成之后，从JVM的视角来看，一个新对象已经产生了。但从Java程序的视角来看，对象的创建才刚刚开始——构造方法还没有执行。</p>
<ul>
<li><strong>调用构造器</strong>：<code>new</code>指令之后，会紧接着执行<code>&lt;init&gt;()</code>方法（即我们编写的构造函数）。这个方法是按照开发者的意图对对象进行<strong>显式初始化</strong>。</li>
<li><strong>初始化顺序</strong>：在<code>&lt;init&gt;()</code>方法内部，会先执行父类的构造器，然后是实例变量的初始化（如 <code>private String name = &quot;default&quot;;</code>），最后才是构造方法体内的代码。</li>
<li><strong>完成创建</strong>：当<code>&lt;init&gt;()</code>方法执行完毕后，一个真正“可用”的对象才算完全创建出来。此时，执行引擎会把堆中该对象的引用地址压入操作数栈顶，接着赋值给栈帧局部变量表中的引用变量（如 <code>p</code>）。</li>
</ul>
<p>至此，<code>Person p = new Person();</code> 这行代码的背后故事才算完整落幕。这个过程体现了JVM设计的严谨性和为了性能所做的深度优化（如TLAB）。</p>
<hr>
<h3 id="2-2-对象的内存布局-对象头、实例数据、对齐填充"><a href="#2-2-对象的内存布局-对象头、实例数据、对齐填充" class="headerlink" title="2.2 对象的内存布局 (对象头、实例数据、对齐填充)"></a>2.2 对象的内存布局 (对象头、实例数据、对齐填充)</h3><p>在HotSpot虚拟机中，一个Java对象在堆内存中的存储布局可以划分为三个部分：<strong>对象头（Header）</strong>、<strong>实例数据（Instance Data）</strong> 和 <strong>对齐填充（Padding）</strong>。</p>
<h4 id="2-2-1-对象头-Object-Header"><a href="#2-2-1-对象头-Object-Header" class="headerlink" title="2.2.1 对象头 (Object Header)"></a>2.2.1 对象头 (Object Header)</h4><p>对象头是对象内存布局的起始部分，它包含了对象的元信息，不存储业务数据。在HotSpot中，对象头内部又包含两部分（或三部分，如果是数组对象的话）：</p>
<h5 id="1-Mark-Word-标记字段"><a href="#1-Mark-Word-标记字段" class="headerlink" title="1. Mark Word (标记字段)"></a>1. Mark Word (标记字段)</h5><p>Mark Word是对象头中<strong>最复杂、最核心</strong>的部分。它用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态等。这部分数据是<strong>动态的</strong>，会随着对象的运行状态而改变。</p>
<p>为了在有限的空间里存储更多的信息，Mark Word被设计成一个<strong>非固定的数据结构</strong>，它会根据对象的状态复用自己的存储空间。在32位和64位虚拟机中，Mark Word分别占用32位（4字节）和64位（8字节）。</p>
<p>以下是<strong>64位虚拟机</strong>中Mark Word在不同状态下的结构示例：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>锁标志位</th>
<th>存储内容 (从高位到低位)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>无锁状态</strong></td>
<td>01</td>
<td><code>unused(25)_hashCode(31)_unused(1)_age(4)_biased_lock(1)_lock(2)</code></td>
<td>存储对象的哈希码(HashCode)、GC分代年龄(Age)、是否是偏向锁。</td>
</tr>
<tr>
<td><strong>偏向锁状态</strong></td>
<td>01</td>
<td><code>thread_id(54)_epoch(2)_unused(1)_age(4)_biased_lock(1)_lock(2)</code></td>
<td>存储持有偏向锁的线程ID、Epoch、GC分代年龄。哈希码不再存储。</td>
</tr>
<tr>
<td><strong>轻量级锁状态</strong></td>
<td>00</td>
<td><code>ptr_to_lock_record(62)_lock(2)</code></td>
<td>指向线程栈中锁记录（Lock Record）的指针。</td>
</tr>
<tr>
<td><strong>重量级锁状态</strong></td>
<td>10</td>
<td><code>ptr_to_heavyweight_monitor(62)_lock(2)</code></td>
<td>指向一个重量级锁（Monitor）的指针。</td>
</tr>
<tr>
<td><strong>GC标记状态</strong></td>
<td>11</td>
<td><code>empty(62)_lock(2)</code></td>
<td>在GC时用于标记对象，没有其他业务含义。</td>
</tr>
</tbody></table>
<p><strong>关键点：</strong></p>
<ul>
<li><strong>锁升级</strong>：Java的<code>synchronized</code>锁的优化（偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁）就是通过修改Mark Word中的锁标志位和数据来实现的。</li>
<li><strong>GC年龄</strong>：对象每经历一次Minor GC后存活下来，其GC年龄就会+1。当达到一定阈值（默认15），就会晋升到老年代。</li>
<li><strong>哈希码</strong>：<code>Object.hashCode()</code>方法计算的哈希码是<strong>懒加载</strong>的。只有当第一次调用该方法时，才会计算并存入Mark Word。如果对象已经进入了其他锁定状态，哈希码会被移到别处存储。</li>
</ul>
<hr>
<h5 id="2-Klass-Pointer-类型指针-Class-Pointer"><a href="#2-Klass-Pointer-类型指针-Class-Pointer" class="headerlink" title="2. Klass Pointer (类型指针 &#x2F; Class Pointer)"></a>2. Klass Pointer (类型指针 &#x2F; Class Pointer)</h5><p>类型指针是对象指向<strong>它的类元数据</strong>的指针。虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<ul>
<li><strong>指向位置</strong>：这个指针指向方法区（在JDK 8+中是元空间）中对应的<code>Klass</code>对象（C++层面的类信息表示）。</li>
<li><strong>空间占用</strong>：<ul>
<li>在64位系统中，默认开启<strong>指针压缩</strong>（<code>-XX:+UseCompressedOops</code>），Klass Pointer会占用<strong>4个字节</strong>。</li>
<li>如果关闭指针压缩（<code>-XX:-UseCompressedOops</code>），它会占用<strong>8个字节</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-数组长度-Array-Length"><a href="#3-数组长度-Array-Length" class="headerlink" title="3. 数组长度 (Array Length)"></a>3. 数组长度 (Array Length)</h5><p>这部分数据<strong>只有在对象是数组的情况下才会有</strong>。如果对象不是数组，则没有这部分信息。</p>
<ul>
<li><strong>作用</strong>：用于记录数组的长度。</li>
<li><strong>空间占用</strong>：占用4个字节。</li>
</ul>
<p><strong>总结对象头大小（64位JVM）：</strong></p>
<ul>
<li><strong>非数组对象</strong>：Mark Word (8字节) + Klass Pointer (4字节, 开启压缩) &#x3D; <strong>12字节</strong></li>
<li><strong>数组对象</strong>：Mark Word (8字节) + Klass Pointer (4字节, 开启压缩) + 数组长度 (4字节) &#x3D; <strong>16字节</strong></li>
</ul>
<hr>
<h4 id="2-2-2-实例数据-Instance-Data"><a href="#2-2-2-实例数据-Instance-Data" class="headerlink" title="2.2.2 实例数据 (Instance Data)"></a>2.2.2 实例数据 (Instance Data)</h4><p>实例数据部分是对象<strong>真正存储有效信息</strong>的地方，也就是我们在类中定义的各种类型的字段内容。</p>
<ul>
<li><strong>存储内容</strong>：包括父类继承下来的字段和子类自己定义的字段。</li>
<li><strong>存储顺序</strong>：会受到虚拟机分配策略参数（<code>-XX:FieldsAllocationStyle</code>）和字段在Java源码中定义顺序的影响。HotSpot默认的分配策略是：<ol>
<li><strong>按数据类型大小排序</strong>：<code>longs/doubles</code> -&gt; <code>ints/floats</code> -&gt; <code>shorts/chars</code> -&gt; <code>bytes/booleans</code> -&gt; <code>references</code>。这样可以更有效地利用空间，减少填充。</li>
<li><strong>父类字段在前</strong>：如果设置了<code>-XX:+CompactFields</code>（默认开启），父类的字段会出现在子类字段之前。</li>
<li><strong>相同宽度的字段</strong>：相同宽度的字段会被分配到一起。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="2-2-3-对齐填充-Padding"><a href="#2-2-3-对齐填充-Padding" class="headerlink" title="2.2.3 对齐填充 (Padding)"></a>2.2.3 对齐填充 (Padding)</h4><p>对齐填充并不是必然存在的，它仅仅是<strong>为了占位，起到对齐的作用</strong>。</p>
<ul>
<li><strong>为什么需要对齐？</strong><ul>
<li>HotSpot虚拟机的自动内存管理系统要求对象的起始地址必须是<strong>8字节的整数倍</strong>。换句话说，任何对象的大小都必须是8字节的倍数。</li>
</ul>
</li>
<li><strong>工作原理</strong>：<ul>
<li>当一个对象的对象头和实例数据部分加起来的大小<strong>不是8字节的倍数</strong>时，对齐填充部分就会自动填补若干字节，使得整个对象的大小凑成8的倍数。</li>
<li>这部分不存储任何有效数据，纯粹是空间上的占位。</li>
</ul>
</li>
<li><strong>对齐的好处</strong>：<ul>
<li><strong>CPU高效访问</strong>：现代CPU在处理数据时，从对齐的内存地址读取数据的效率最高。不对齐的访问可能会导致CPU需要两次内存读取操作，或者触发异常。通过空间换时间，提升了存取性能。</li>
<li><strong>简化内存管理</strong>：统一的对齐规则也使得JVM在管理内存（如分配、回收）时更加规整和高效。</li>
</ul>
</li>
</ul>
<p><strong>示例分析：</strong></p>
<p>假设我们有一个简单的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;    <span class="comment">// 4 bytes</span></span><br><span class="line">    <span class="type">boolean</span> b; <span class="comment">// 1 byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在64位JVM中，一个<code>MyObject</code>实例的内存布局会是：</p>
<ol>
<li><strong>对象头</strong>：12字节（Mark Word 8B + Klass Pointer 4B）。</li>
<li><strong>实例数据</strong>：<ul>
<li><code>int a</code>: 4字节</li>
<li><code>boolean b</code>: 1字节</li>
<li><strong>实例数据总计</strong>：5字节。</li>
</ul>
</li>
<li><strong>计算总大小</strong>：对象头 (12B) + 实例数据 (5B) &#x3D; <strong>17字节</strong>。</li>
<li><strong>对齐填充</strong>：17不是8的倍数，下一个8的倍数是24。因此，需要填充 <code>24 - 17 = 7</code> 字节。</li>
<li><strong>最终对象大小</strong>：<strong>24字节</strong>。</li>
</ol>
<p><strong>如何查看对象内存布局？</strong></p>
<p>可以使用 <code>JOL (Java Object Layout)</code> 这个强大的工具库来精确地分析一个Java对象的内存布局。只需引入其Maven依赖，即可在代码中打印出详细的内存信息。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JOLExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line"></span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">myObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(myObj).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-对象的访问定位-句柄访问-vs-直接指针访问"><a href="#2-3-对象的访问定位-句柄访问-vs-直接指针访问" class="headerlink" title="2.3 对象的访问定位 (句柄访问 vs. 直接指针访问)"></a>2.3 对象的访问定位 (句柄访问 vs. 直接指针访问)</h3><p>我们已经知道，当执行 <code>Person p = new Person();</code> 时，变量 <code>p</code> 作为一个引用（reference）存放在Java虚拟机栈的局部变量表中，而 <code>new Person()</code> 的实例则存放在Java堆中。现在的问题是，栈上的 <code>p</code> 是如何精确地定位到堆上那个对象的？</p>
<h4 id="2-3-1-句柄访问-Handle-Access"><a href="#2-3-1-句柄访问-Handle-Access" class="headerlink" title="2.3.1 句柄访问 (Handle Access)"></a>2.3.1 句柄访问 (Handle Access)</h4><p><strong>工作原理：</strong></p>
<p>句柄访问方式引入了一个<strong>中间层</strong>——<strong>句柄池（Handle Pool）</strong>。</p>
<ol>
<li>Java堆中会划出一块内存作为句柄池。</li>
<li>栈上的 <code>reference</code> 变量存储的不再是对象的直接地址，而是对象在<strong>句柄池中的地址（或索引）</strong>。</li>
<li>句柄池中的每个句柄包含<strong>两个指针</strong>：<ul>
<li>一个指向堆中<strong>对象实例数据</strong>的指针（Instance Pointer）。</li>
<li>另一个指向方法区中<strong>对象类型数据</strong>的指针（Klass Pointer）。</li>
</ul>
</li>
</ol>
<p><strong>访问过程图解：</strong></p>
<pre><code class="highlight mermaid">graph TD
    %% 定义整体布局为自上而下

    %% 1. Java 栈区域
    subgraph &quot;Java 栈 (Stack Frame)&quot;
        stack_ref[&quot;reference&quot;]
    end

    %% 2. Java 堆区域 (内部分为句柄池和实例区)
    subgraph &quot;Java 堆 (Heap)&quot;
        subgraph &quot;句柄池 (Handle Pool)&quot;
            handle[&quot;&lt;strong&gt;句柄 (Handle)&lt;/strong&gt;&lt;br/&gt;- 实例指针 (Instance Pointer)&lt;br/&gt;- 类型指针 (Klass Pointer)&quot;]
        end
        
        subgraph &quot;对象实例区 (Object Pool)&quot;
            heap_instance[&quot;Person 对象实例&lt;br/&gt;(实例数据)&quot;]
        end
    end

    %% 3. 方法区区域
    subgraph &quot;方法区 (Method Area)&quot;
        method_area_class[&quot;Person 类信息&lt;br/&gt;(Class Metadata)&quot;]
    end

    %% 定义指针关系
    stack_ref -- &quot;指向句柄&quot; --&gt; handle
    handle -- &quot;实例指针&quot; --&gt; heap_instance
    handle -- &quot;类型指针&quot; --&gt; method_area_class

    %% 样式定义 (可选，用于美化)
    style stack_ref fill:#cde,stroke:#333,stroke-width:2px
    style handle fill:#f9f,stroke:#333,stroke-width:2px
    style heap_instance fill:#fcf,stroke:#333,stroke-width:2px
    style method_area_class fill:#ccf,stroke:#333,stroke-width:2px</code></pre>

<p><strong>优点：</strong></p>
<ul>
<li><strong>引用稳定 (Reference Stability)</strong>：这是句柄访问最大的优点。当发生垃圾回收（GC）导致对象在堆中被移动（例如，在新生代中的复制算法或老年代中的整理算法）时，<strong>只需要修改句柄池中对应实例的指针即可</strong>，而栈上的 <code>reference</code> 变量本身<strong>完全不需要改变</strong>。这使得GC期间的引用更新工作量变小。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>访问速度较慢 (Slower Access)</strong>：访问一个对象需要经过<strong>两次指针解引用</strong>（<code>reference</code> -&gt; 句柄 -&gt; 对象实例）。这比直接访问多了一次间接寻址的开销，在对象访问非常频繁的场景下，性能会受到影响。</li>
<li><strong>额外的空间开销</strong>：句柄池本身也需要占用一定的内存空间。</li>
</ul>
<hr>
<h4 id="2-3-2-直接指针访问-Direct-Pointer-Access"><a href="#2-3-2-直接指针访问-Direct-Pointer-Access" class="headerlink" title="2.3.2 直接指针访问 (Direct Pointer Access)"></a>2.3.2 直接指针访问 (Direct Pointer Access)</h4><p><strong>工作原理：</strong></p>
<p>直接指针访问方式更加直接，它<strong>不使用中间层</strong>。</p>
<ol>
<li>栈上的 <code>reference</code> 变量<strong>直接存储对象在堆中的起始地址</strong>。</li>
<li>对象的内存布局中必须包含足够的信息来定位到它的类型数据（即对象头中必须有类型指针）。</li>
</ol>
<p><strong>访问过程图解：</strong></p>
<pre><code class="highlight mermaid">graph TD
    %% 定义整体布局为自上而下

    %% 1. Java 栈区域
    subgraph &quot;Java 栈 (Stack Frame)&quot;
        stack_ref[&quot;reference&lt;br/&gt;(直接存储对象地址)&quot;]
    end

    %% 2. Java 堆区域
    subgraph &quot;Java 堆 (Heap)&quot;
        heap_object[&quot;&lt;strong&gt;Person 对象实例&lt;/strong&gt;&lt;br/&gt;&lt;hr/&gt;&lt;strong&gt;对象头 (Header)&lt;/strong&gt;&lt;br/&gt;&amp;nbsp;&amp;nbsp;- 类型指针 (Klass Pointer)&lt;br/&gt;&amp;nbsp;&amp;nbsp;- Mark Word&lt;br/&gt;&lt;hr/&gt;&lt;strong&gt;实例数据 (Instance Data)&lt;/strong&gt;&lt;br/&gt;...&lt;br/&gt;&lt;hr/&gt;&lt;strong&gt;对齐填充 (Padding)&lt;/strong&gt;&quot;]
    end

    %% 3. 方法区区域
    subgraph &quot;方法区 (Method Area)&quot;
        method_area_class[&quot;Person 类信息&lt;br/&gt;(Class Metadata)&quot;]
    end

    %% 定义指针关系
    stack_ref -- &quot;直接指向&quot; --&gt; heap_object
    heap_object -- &quot;对象头中的类型指针指向&quot; --&gt; method_area_class

    %% 样式定义 (可选，用于美化)
    style stack_ref fill:#cde,stroke:#333,stroke-width:2px
    style heap_object fill:#fcf,stroke:#333,stroke-width:2px
    style method_area_class fill:#ccf,stroke:#333,stroke-width:2px</code></pre>

<p><strong>优点：</strong></p>
<ul>
<li><strong>访问速度快 (Faster Access)</strong>：访问对象只需要<strong>一次指针解引用</strong>，减少了一次间接寻址的开销。这对于性能至关重要，因为对象访问是程序中最频繁的操作之一。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>引用不稳定 (Reference Instability)</strong>：当发生垃圾回收导致对象在堆中被移动时，<strong>必须遍历所有指向该对象的引用，并逐一更新它们的地址</strong>。这个过程相对复杂，尤其是在对象引用数量很多的情况下。</li>
</ul>
<hr>
<h4 id="2-3-4-HotSpot虚拟机的选择"><a href="#2-3-4-HotSpot虚拟机的选择" class="headerlink" title="2.3.4 HotSpot虚拟机的选择"></a>2.3.4 HotSpot虚拟机的选择</h4><p><strong>HotSpot虚拟机采用的是——直接指针访问方式。</strong></p>
<p><strong>为什么？</strong></p>
<p>这是一个典型的<strong>性能权衡</strong>。虽然在GC时对象移动会导致引用更新的成本，但从整个程序的生命周期来看，<strong>对象访问的频率远远高于垃圾回收的频率</strong>。</p>
<p>为了追求极致的性能，HotSpot团队选择了牺牲GC时的一点复杂性，来换取日常运行时更高的访问速度。因此，我们平时在HotSpot上运行的Java程序，其引用变量存储的都是对象的直接地址。</p>
<p><strong>总结对比：</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>句柄访问 (Handle Access)</th>
<th>直接指针访问 (Direct Pointer Access)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>访问速度</strong></td>
<td>慢 (两次指针解引用)</td>
<td><strong>快 (一次指针解引用)</strong></td>
</tr>
<tr>
<td><strong>引用稳定性</strong></td>
<td><strong>高 (对象移动时，栈中引用不变)</strong></td>
<td>低 (对象移动时，必须更新所有栈中引用)</td>
</tr>
<tr>
<td><strong>空间开销</strong></td>
<td>额外需要句柄池的空间</td>
<td>无额外开销</td>
</tr>
<tr>
<td><strong>实现复杂度</strong></td>
<td>相对简单</td>
<td>GC时更新引用的逻辑相对复杂</td>
</tr>
<tr>
<td><strong>主流选择</strong></td>
<td>一些早期的或特定的JVM实现</td>
<td><strong>HotSpot、OpenJ9等主流JVM的选择</strong></td>
</tr>
</tbody></table>
<p>这个选择也体现了JVM设计中的一个核心理念：<strong>对最频繁的操作进行深度优化</strong>。</p>
<hr>
<h2 id="3-垃圾回收-Garbage-Collection"><a href="#3-垃圾回收-Garbage-Collection" class="headerlink" title="3. 垃圾回收 (Garbage Collection)"></a>3. 垃圾回收 (Garbage Collection)</h2><h3 id="3-1-如何判断对象需要被回收？"><a href="#3-1-如何判断对象需要被回收？" class="headerlink" title="3.1 如何判断对象需要被回收？"></a>3.1 如何判断对象需要被回收？</h3><h4 id="3-1-1-引用计数法-及其循环引用问题"><a href="#3-1-1-引用计数法-及其循环引用问题" class="headerlink" title="3.1.1 引用计数法 (及其循环引用问题)"></a>3.1.1 引用计数法 (及其循环引用问题)</h4><p>这是最直观、最简单的一种判断方法。</p>
<p><strong>核心思想：</strong></p>
<ul>
<li>为每个对象在对象头中分配一个<strong>引用计数器</strong>。</li>
<li>当有一个地方引用这个对象时，计数器就<strong>加1</strong>。</li>
<li>当一个引用失效（例如，引用被置为<code>null</code>，或引用所在的栈帧被销毁）时，计数器就<strong>减1</strong>。</li>
<li>任何时刻，当一个对象的引用计数器为<strong>0</strong>时，GC就可以认为这个对象是“死亡”的，可以被回收。</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testGC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>(); <span class="comment">// objA的引用计数为1</span></span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>(); <span class="comment">// objB的引用计数为1</span></span><br><span class="line">        </span><br><span class="line">        objA.instance = objB; <span class="comment">// objB的引用计数变为2</span></span><br><span class="line">        objB.instance = objA; <span class="comment">// objA的引用计数变为2</span></span><br><span class="line">        </span><br><span class="line">        objA = <span class="literal">null</span>; <span class="comment">// objA的引用计数从2减为1</span></span><br><span class="line">        objB = <span class="literal">null</span>; <span class="comment">// objB的引用计数从2减为1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 此时，objA和objB的引用计数都为1，而不是0</span></span><br><span class="line">        <span class="comment">// 如果是引用计数法，这两个对象将永远无法被回收</span></span><br><span class="line">        System.gc(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li><strong>实现简单</strong>：算法逻辑清晰明了。</li>
<li><strong>回收效率高</strong>：当对象的引用计数变为0时，可以被立即回收，不需要等到GC线程统一工作。这可以减少程序在垃圾回收时的“停顿”。</li>
</ul>
<p><strong>致命缺点：循环引用问题 (Circular Reference Problem)</strong></p>
<ul>
<li><strong>问题描述</strong>：如果两个或多个对象相互引用，形成一个闭环，那么即使它们在外部已经没有任何引用了，它们的引用计数器也永远不会是0。</li>
<li><strong>后果</strong>：这将导致这些对象<strong>永远无法被回收</strong>，造成<strong>内存泄漏</strong>。</li>
<li><strong>结论</strong>：由于这个致命的缺陷，<strong>主流的Java虚拟机（如HotSpot）都没有采用引用计数法来管理内存</strong>。虽然Python等语言使用了引用计数，但它们也需要配合其他标记-清除等机制来解决循环引用的问题。</li>
</ul>
<hr>
<h4 id="3-1-2-可达性分析算法-GC-Roots"><a href="#3-1-2-可达性分析算法-GC-Roots" class="headerlink" title="3.1.2 可达性分析算法 (GC Roots)"></a>3.1.2 可达性分析算法 (GC Roots)</h4><p>这是当前主流商用编程语言（包括Java、C#等）所采用的对象存活判断算法。</p>
<p><strong>核心思想：</strong></p>
<ul>
<li>算法将所有对象看作是一个<strong>有向图</strong>中的节点，引用关系就是图中的边。</li>
<li>算法首先确定一系列<strong>必须存活</strong>的“根”对象，这些对象构成了<strong>GC Roots</strong>集合。</li>
<li>从这些GC Roots节点开始，沿着引用链进行<strong>深度优先或广度优先的遍历</strong>。</li>
<li>所有能够从GC Roots<strong>直接或间接到达</strong>的对象，都被标记为**“存活”对象**。</li>
<li>在遍历结束后，所有<strong>未被标记</strong>（即从GC Roots不可达）的对象，都被判定为**“死亡”对象**，可以被垃圾回收。</li>
</ul>
<p><strong>图解可达性分析：</strong></p>
<pre><code class="highlight mermaid">graph TD
    %% -- 定义节点 --
    gc1[GC Root 1]
    gc2[GC Root 2]
    A[Object A]
    B[Object B]
    C[Object C]
    D[Object D]
    E[Object E]
    F[Object F]

    %% -- 定义可达对象的引用关系 --
    subgraph &quot;GC Roots可达对象 (Reachable Objects)&quot;
        gc1 --&gt; A
        gc2 --&gt; B
        A --&gt; B
        A --&gt; C
        D --&gt; B
    end

    %% -- 定义不可达对象的引用关系 (循环引用) --
    subgraph &quot;与GC Roots不可达 (Unreachable,可被回收)&quot;
        E &lt;--&gt; F
    end

    %% -- 设置样式 (可选) --
    style gc1 fill:#f9f,stroke:#333,stroke-width:2px
    style gc2 fill:#f9f,stroke:#333,stroke-width:2px
    style E fill:#ffb,stroke:#333,stroke-width:1px
    style F fill:#ffb,stroke:#333,stroke-width:1px</code></pre>

<ul>
<li><strong>遍历结果</strong>：从<code>GC Root 1</code>和<code>GC Root 2</code>出发，可以到达<code>Object A</code>, <code>Object B</code>, <code>Object C</code>, <code>Object D</code>。</li>
<li><strong>判定</strong>：<ul>
<li><code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> 是<strong>存活</strong>的。</li>
<li><code>E</code> 和 <code>F</code> 虽然相互引用，但从任何GC Root都无法到达它们，所以它们是<strong>不可达</strong>的，即“死亡”对象，将被回收。</li>
</ul>
</li>
</ul>
<p><strong>GC Roots 是什么？</strong></p>
<p>GC Roots是可达性分析的起点，它们是一些在程序运行期间就确定为必须存活的对象。在Java中，固定的GC Roots主要包括以下几类：</p>
<ol>
<li><strong>Java虚拟机栈中引用的对象 (Stack Locals)</strong>：<ul>
<li>正在执行的方法的局部变量表和操作数栈中引用的对象。当一个方法还在执行时，它的局部变量所引用的对象必须是存活的。</li>
</ul>
</li>
<li><strong>方法区中类静态属性引用的对象 (Class Statics)</strong>：<ul>
<li>类的静态成员变量（<code>static</code>字段）所引用的对象。因为静态变量与类本身关联，只要类不被卸载，这些对象就必须存活。</li>
</ul>
</li>
<li><strong>方法区中常量引用的对象 (Constants)</strong>：<ul>
<li>运行时常量池中引用的对象，例如字符串常量池中的字符串。</li>
</ul>
</li>
<li><strong>本地方法栈中JNI引用的对象 (JNI References)</strong>：<ul>
<li>在执行本地（Native）方法时，本地代码（如C&#x2F;C++）所持有的Java对象。</li>
</ul>
</li>
<li><strong>JVM内部的引用</strong>：<ul>
<li>如基本数据类型对应的<code>Class</code>对象、一些常驻的异常对象（如<code>NullPointerException</code>）、系统类加载器等。</li>
</ul>
</li>
<li><strong>被同步锁（<code>synchronized</code>）持有的对象</strong>：<ul>
<li>作为锁对象的实例。</li>
</ul>
</li>
<li><strong>分代回收中，跨代引用的对象</strong>：<ul>
<li>在分代GC中，如果老年代对象引用了新生代对象，那么这个老年代对象也会被视为一个“伪”GC Root，以避免在只扫描新生代时错误地回收被老年代引用的对象。</li>
</ul>
</li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li><strong>解决了循环引用问题</strong>：无论对象之间如何形成复杂的引用环，只要它们与GC Roots的连接断开，就会被判定为可回收。</li>
<li><strong>准确性高</strong>：能够精确地识别出所有不再使用的对象。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>需要暂停用户线程 (Stop-The-World)</strong>：在进行可达性分析的初始标记阶段，通常需要暂停所有用户线程（即“Stop-The-World”或STW），以确保在分析期间引用关系不会发生变化。虽然现代的GC（如CMS、G1、ZGC）通过并发标记等技术极大地缩短了STW的时间，但完全消除STW仍然是一个挑战。</li>
<li><strong>实现相对复杂</strong>。</li>
</ul>
<p><strong>总结：</strong></p>
<table>
<thead>
<tr>
<th>算法</th>
<th>原理</th>
<th>优点</th>
<th>缺点</th>
<th>JVM中的应用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>引用计数法</strong></td>
<td>对象被引用则计数器+1，引用失效则-1。计数器为0时可回收。</td>
<td>实现简单，回收及时。</td>
<td><strong>无法解决循环引用问题</strong>，导致内存泄漏。</td>
<td><strong>不采用</strong></td>
</tr>
<tr>
<td><strong>可达性分析法</strong></td>
<td>从GC Roots出发遍历引用链，不可达的对象即为可回收对象。</td>
<td><strong>能解决循环引用问题</strong>，准确可靠。</td>
<td>实现复杂，分析期间通常需要<strong>Stop-The-World</strong>。</td>
<td><strong>主流选择</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="3-2-Java的四种引用类型：强、软、弱、虚引用及其应用场景"><a href="#3-2-Java的四种引用类型：强、软、弱、虚引用及其应用场景" class="headerlink" title="3.2 Java的四种引用类型：强、软、弱、虚引用及其应用场景"></a>3.2 Java的四种引用类型：强、软、弱、虚引用及其应用场景</h3><h4 id="3-2-1-强引用-Strong-Reference"><a href="#3-2-1-强引用-Strong-Reference" class="headerlink" title="3.2.1 强引用 (Strong Reference)"></a>3.2.1 强引用 (Strong Reference)</h4><ul>
<li><p><strong>核心定义</strong><br>强引用是我们编程中最常见、默认的引用类型。当一个对象具有强引用时，它就处于**“必须存活”**的状态。</p>
</li>
<li><p><strong>垃圾回收行为</strong><br>只要一个对象有任何强引用链指向它（即从GC Roots可达），<strong>垃圾回收器就永远不会回收这个对象</strong>，即使系统内存严重不足，宁可抛出<code>OutOfMemoryError</code>。</p>
</li>
<li><p><strong>如何使用</strong><br>所有常规的对象创建和赋值都是强引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new Object() 创建的对象，被变量 &#x27;o&#x27; 强引用</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要 &#x27;o&#x27; 这个引用还在（比如在方法执行期间），GC就不会回收这个Object实例</span></span><br><span class="line"></span><br><span class="line">o = <span class="literal">null</span>; <span class="comment">// 解除强引用，对象现在可能可以被回收了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>核心应用场景</strong></p>
<ul>
<li><strong>日常编程</strong>：绝大多数的对象都由强引用持有，用于构建程序的业务逻辑和数据结构。</li>
<li><strong>内存泄漏的根源</strong>：如果一个不再需要的对象仍然被一个长生命周期的强引用（如静态集合）持有，就会导致内存泄漏。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-2-软引用-Soft-Reference"><a href="#3-2-2-软引用-Soft-Reference" class="headerlink" title="3.2.2 软引用 (Soft Reference)"></a>3.2.2 软引用 (Soft Reference)</h4><ul>
<li><p><strong>核心定义</strong><br>软引用用来描述一些<strong>还有用，但非必需</strong>的对象。它比强引用弱，比弱引用强。</p>
</li>
<li><p><strong>垃圾回收行为</strong><br>当一个对象只被软引用指向时：</p>
<ul>
<li>如果系统<strong>内存充足</strong>，GC<strong>不会</strong>回收它。</li>
<li>如果系统<strong>内存即将不足</strong>（在抛出<code>OutOfMemoryError</code>之前），GC<strong>会</strong>把这些软引用对象列入回收范围，进行第二次回收，以释放空间。</li>
</ul>
</li>
<li><p><strong>如何使用</strong><br>需要使用<code>java.lang.ref.SoftReference</code>类来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个强引用的对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">strongObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个软引用，指向这个对象</span></span><br><span class="line">SoftReference&lt;Object&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(strongObj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除强引用，此时对象只被软引用指向</span></span><br><span class="line">strongObj = <span class="literal">null</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 程序运行，内存可能变得紧张 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次尝试获取对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">retrievedObj</span> <span class="operator">=</span> softRef.get();</span><br><span class="line"><span class="keyword">if</span> (retrievedObj != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 内存充足，对象未被回收</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 内存紧张，对象已被GC回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>核心应用场景</strong></p>
<ul>
<li><strong>实现内存敏感的高速缓存 (Memory-Sensitive Cache)</strong>：这是软引用的经典用途。<ul>
<li><strong>场景</strong>：比如网页缓存、图片缓存。我们可以把这些缓存对象用软引用来维护。</li>
<li><strong>好处</strong>：<ol>
<li>内存充足时，对象保留在缓存中，加速访问。</li>
<li>内存紧张时，GC自动清理这些缓存对象，释放内存，从而<strong>避免了因缓存过大导致的OOM</strong>，保证了核心业务的稳定性。这比手动管理缓存要智能和安全得多。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-3-弱引用-Weak-Reference"><a href="#3-2-3-弱引用-Weak-Reference" class="headerlink" title="3.2.3 弱引用 (Weak Reference)"></a>3.2.3 弱引用 (Weak Reference)</h4><ul>
<li><p><strong>核心定义</strong><br>弱引用的强度比软引用更弱。它也用来描述<strong>非必需</strong>的对象，但它的生命周期更短。</p>
</li>
<li><p><strong>垃圾回收行为</strong><br>当一个对象只被弱引用指向时，无论当前内存是否充足，<strong>只要发生垃圾回收，它就一定会被回收</strong>。换句话说，弱引用关联的对象只能生存到下一次GC发生之前。</p>
</li>
<li><p><strong>如何使用</strong><br>需要使用<code>java.lang.ref.WeakReference</code>类来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">strongObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(strongObj);</span><br><span class="line"></span><br><span class="line">strongObj = <span class="literal">null</span>; <span class="comment">// 解除强引用</span></span><br><span class="line"></span><br><span class="line">System.gc(); <span class="comment">// 强制触发GC (仅为演示，生产环境不建议)</span></span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">retrievedObj</span> <span class="operator">=</span> weakRef.get();</span><br><span class="line"><span class="comment">// 此时 retrievedObj 极大概率为 null</span></span><br><span class="line">System.out.println(retrievedObj); </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>核心应用场景</strong></p>
<ol>
<li><strong><code>WeakHashMap</code></strong>：这是弱引用的最典型应用。<ul>
<li><strong>场景</strong>：<code>WeakHashMap</code>的<code>Key</code>是弱引用。当一个<code>Key</code>对象在外部不再有任何强引用时，在下一次GC后，这个<code>Key</code>所对应的整个<code>Entry</code>（键值对）就会被自动从Map中移除。</li>
<li><strong>好处</strong>：非常适合用来<strong>存储对象的元数据或附加信息</strong>，而又不妨碍该对象被正常回收。例如，你想为一个对象关联一些额外数据，但又不希望因为这个关联而导致对象内存泄漏。</li>
</ul>
</li>
<li><strong>防止内存泄漏</strong>：在一些监听器和回调注册的场景中，如果被观察者生命周期很长，而观察者生命周期很短，使用弱引用来持有观察者可以防止内存泄漏。<code>ThreadLocal</code>的实现也利用了弱引用来避免一定的内存泄漏风险。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="3-2-4-虚引用-Phantom-Reference"><a href="#3-2-4-虚引用-Phantom-Reference" class="headerlink" title="3.2.4 虚引用 (Phantom Reference)"></a>3.2.4 虚引用 (Phantom Reference)</h4><p>也称为“幽灵引用”或“幻影引用”，它是所有引用类型中最弱的一种。</p>
<ul>
<li><p><strong>核心定义</strong><br>虚引用<strong>完全不影响对象的生命周期</strong>。它存在的唯一目的就是<strong>在一个对象被垃圾回收时收到一个系统通知</strong>。</p>
</li>
<li><p><strong>垃圾回收行为</strong><br>一个对象是否有虚引用，对其生存时间没有任何影响，也无法通过虚引用来获取一个对象实例。虚引用的<code>get()</code>方法<strong>永远返回<code>null</code></strong>。</p>
</li>
<li><p><strong>如何使用</strong><br>必须和**引用队列（<code>ReferenceQueue</code>）**联合使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">strongObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建虚引用，并关联引用队列</span></span><br><span class="line">PhantomReference&lt;Object&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(strongObj, queue);</span><br><span class="line"></span><br><span class="line">strongObj = <span class="literal">null</span>; <span class="comment">// 解除强引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 在未来的某个GC周期中，strongObj被回收 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在strongObj被回收后，phantomRef这个引用对象本身会被放入到关联的queue中</span></span><br><span class="line"><span class="comment">// 我们可以通过检查队列来得知对象已被回收</span></span><br><span class="line"><span class="comment">// a separate thread would poll the queue:</span></span><br><span class="line"><span class="comment">// Reference&lt;?&gt; ref = queue.poll();</span></span><br><span class="line"><span class="comment">// if (ref != null) &#123;</span></span><br><span class="line"><span class="comment">//     // 对象已被回收，可以执行相关的清理工作</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>核心应用场景</strong></p>
<ul>
<li><strong>管理堆外内存 (Off-Heap Memory)</strong>：这是虚引用的最重要用途。<ul>
<li><strong>场景</strong>：<code>NIO</code>中的<code>DirectByteBuffer</code>就是典型例子。它在Java堆上只是一个很小的对象，但它通过JNI在本地内存（堆外）分配了一大块空间。</li>
<li><strong>问题</strong>：当堆上的<code>DirectByteBuffer</code>对象被GC回收时，JVM并不知道它还关联着一块巨大的堆外内存需要释放。</li>
<li><strong>解决方案</strong>：为<code>DirectByteBuffer</code>对象创建一个虚引用，并关联一个引用队列。当<code>DirectByteBuffer</code>对象被回收时，其虚引用会被加入队列。一个专门的清理线程会监控这个队列，一旦发现有虚引用进入，就意味着其关联的堆外内存可以被安全释放了（通过调用<code>Unsafe.freeMemory()</code>等方法）。这样就精确地实现了堆外内存的回收。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>总结对比</strong></p>
<table>
<thead>
<tr>
<th align="left">引用类型</th>
<th align="left">强度</th>
<th align="left">垃圾回收时机</th>
<th align="left">核心应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>强引用 (Strong)</strong></td>
<td align="left">最强</td>
<td align="left">只要引用存在，GC<strong>绝不</strong>回收</td>
<td align="left">日常对象使用，程序逻辑骨架</td>
</tr>
<tr>
<td align="left"><strong>软引用 (Soft)</strong></td>
<td align="left">较强</td>
<td align="left"><strong>内存不足时</strong>回收</td>
<td align="left">实现内存敏感的缓存 (e.g., 图片缓存)</td>
</tr>
<tr>
<td align="left"><strong>弱引用 (Weak)</strong></td>
<td align="left">较弱</td>
<td align="left"><strong>下一次GC时</strong>回收 (无论内存是否充足)</td>
<td align="left"><code>WeakHashMap</code>，防止与对象生命周期不一致导致的内存泄漏</td>
</tr>
<tr>
<td align="left"><strong>虚引用 (Phantom)</strong></td>
<td align="left">最弱</td>
<td align="left">不影响生命周期，<code>get()</code>恒为<code>null</code>。对象被回收后发出通知。</td>
<td align="left">管理堆外内存（如<code>DirectByteBuffer</code>），执行精确的GC后清理操作</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-3-经典垃圾回收算法"><a href="#3-3-经典垃圾回收算法" class="headerlink" title="3.3 经典垃圾回收算法"></a>3.3 经典垃圾回收算法</h3><p>在通过可达性分析等方法标记出所有“死亡”对象后，接下来的任务就是如何清理这些对象所占用的内存。以下三种算法是解决这个问题的核心策略。</p>
<h4 id="3-3-1-标记-清除-Mark-Sweep-算法"><a href="#3-3-1-标记-清除-Mark-Sweep-算法" class="headerlink" title="3.3.1 标记-清除 (Mark-Sweep) 算法"></a>3.3.1 标记-清除 (Mark-Sweep) 算法</h4><p>这是最基础的垃圾收集算法，后续的算法都是基于它的思想进行改进的。</p>
<p><strong>执行过程：</strong></p>
<p>算法分为两个阶段：</p>
<ol>
<li><strong>标记 (Mark) 阶段</strong>：<ul>
<li>首先，从GC Roots开始，遍历所有可达对象，并给它们打上一个“存活”标记。</li>
<li>这个过程与可达性分析算法的过程一致。</li>
</ul>
</li>
<li><strong>清除 (Sweep) 阶段</strong>：<ul>
<li>在标记阶段完成后，再次从头到尾扫描整个堆内存。</li>
<li>将所有<strong>没有</strong>被标记为“存活”的对象（即“死亡”对象）直接回收，清除它们所占用的内存空间。</li>
</ul>
</li>
</ol>
<p><strong>图解：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[GC前]</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line">| A | B | C | D | E | F | G | H | I | J |  (A, C, F, H, J 是存活对象)</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line"></span><br><span class="line">[1. 标记阶段]</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line">| A*| B | C*| D | E | F*| G | H*| I | J*|  (* 表示被标记为存活)</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line"></span><br><span class="line">[2. 清除阶段]</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line">| A*|   | C*|   |   | F*|   | H*|   | J*|  (B, D, E, G, I 被回收，留下空洞)</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li><strong>实现简单</strong>：算法思想直接，易于实现。</li>
<li><strong>空间利用率高</strong>：不需要额外的空间来辅助回收，它直接在原有的内存上进行操作。</li>
</ul>
<p><strong>缺点：</strong></p>
<ol>
<li><strong>执行效率不稳定</strong>：如果堆中有大量对象，并且其中大部分都需要被回收，那么标记和清除这两个阶段的执行时间都会很长，因为都需要遍历整个堆。</li>
<li><strong>产生内存碎片 (Memory Fragmentation)</strong>：这是<strong>最致命的缺点</strong>。清除后会产生大量不连续的、细小的内存块（空洞）。当后续需要分配一个较大的对象时，即使总的空闲内存足够，也可能因为找不到一块足够大的<strong>连续</strong>内存空间而不得不提前触发下一次垃圾回收，甚至导致<code>OutOfMemoryError</code>。</li>
</ol>
<hr>
<h4 id="3-3-2-标记-复制-Mark-Copy-算法"><a href="#3-3-2-标记-复制-Mark-Copy-算法" class="headerlink" title="3.3.2 标记-复制 (Mark-Copy) 算法"></a>3.3.2 标记-复制 (Mark-Copy) 算法</h4><p>为了解决标记-清除算法的内存碎片问题，标记-复制算法应运而生。它在HotSpot的新生代收集中被广泛使用。</p>
<p><strong>执行过程：</strong></p>
<ol>
<li><strong>内存划分</strong>：首先，将可用的堆内存按容量划分为大小相等的<strong>两块</strong>，通常称为From空间和To空间。在任意时刻，只有一块空间是正在使用的（我们称之为“活动空间”）。</li>
<li><strong>标记与复制</strong>：<ul>
<li>当需要进行GC时，算法会扫描“活动空间”。</li>
<li>将所有“活动空间”中仍然<strong>存活的对象</strong>，一次性、连续地<strong>复制</strong>到另一块“非活动空间”（To空间）中。</li>
<li>在复制过程中，对象会被紧凑地排列，从而自然地解决了内存碎片问题。</li>
</ul>
</li>
<li><strong>清空与角色互换</strong>：<ul>
<li>复制完成后，直接将原来的“活动空间”（From空间）<strong>一次性全部清空</strong>，因为里面剩下的都是垃圾对象。</li>
<li>然后，From空间和To空间的角色<strong>互换</strong>。原来的To空间变成了新的“活动空间”，原来的From空间变成了“非活动空间”，等待下一次GC。</li>
</ul>
</li>
</ol>
<p><strong>图解（以新生代为例）：</strong></p>
<p><em>新生代的Eden区和Survivor From区作为“活动空间”，Survivor To区作为“非活动空间”。</em></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[GC前: Eden区满]</span><br><span class="line">Eden: [A, B, C, D] (A, C存活)   Survivor From: [E] (E存活)   Survivor To: [] (空)</span><br><span class="line"></span><br><span class="line">[1. 标记与复制]</span><br><span class="line">- 扫描Eden和S-From，找到存活对象 A, C, E。</span><br><span class="line">- 将A, C, E 连续复制到 S-To。</span><br><span class="line"></span><br><span class="line">[复制后]</span><br><span class="line">Eden: [A, B, C, D]    S-From: [E]    S-To: [A, C, E] (紧凑排列)</span><br><span class="line"></span><br><span class="line">[2. 清空与角色互换]</span><br><span class="line">- 一次性清空Eden区和S-From区。</span><br><span class="line">- S-From和S-To角色互换。</span><br><span class="line"></span><br><span class="line">[GC后]</span><br><span class="line">Eden: [] (空)   Survivor From: [A, C, E] (新的活动区)   Survivor To: [] (新的非活动区)</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li><strong>不会产生内存碎片</strong>：每次回收都是对整个半区进行内存整理，分配时只需要按顺序分配（指针碰撞），实现简单，运行高效。</li>
<li><strong>执行效率高</strong>：当存活对象较少时（符合新生代“朝生夕死”的特点），只需要复制少量对象，然后一次性清空半个区域，效率非常高。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>空间利用率低</strong>：将可用的内存缩小为了原来的一半，代价比较高。在对象存活率较高的情况下（如老年代），需要复制大量对象，效率会急剧下降。</li>
</ul>
<hr>
<h4 id="3-3-3-标记-整理-Mark-Compact-算法"><a href="#3-3-3-标记-整理-Mark-Compact-算法" class="headerlink" title="3.3.3 标记-整理 (Mark-Compact) 算法"></a>3.3.3 标记-整理 (Mark-Compact) 算法</h4><p>该算法结合了标记-清除和标记-复制的优点，主要用于<strong>老年代</strong>的垃圾回收。</p>
<p><strong>执行过程：</strong></p>
<p>它的标记阶段与标记-清除算法一样，但后续步骤有所不同。</p>
<ol>
<li><strong>标记 (Mark) 阶段</strong>：<ul>
<li>同样是从GC Roots开始，遍历并标记所有存活对象。</li>
</ul>
</li>
<li><strong>整理 (Compact) 阶段</strong>：<ul>
<li>标记完成后，<strong>不是直接清理</strong>未被标记的对象。</li>
<li>而是将所有<strong>存活的对象</strong>向内存空间的<strong>一端移动</strong>，并紧凑地排列在一起。</li>
<li>移动完成后，直接清理掉端边界以外的所有内存。</li>
</ul>
</li>
</ol>
<p><strong>图解：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[GC前]</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line">| A | B | C | D | E | F | G | H*| I | J*|  (A, C, F, H, J 是存活对象)</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line"></span><br><span class="line">[1. 标记阶段]</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line">| A*| B | C*| D | E | F*| G | H*| I | J*|  (* 表示被标记为存活)</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line"></span><br><span class="line">[2. 整理阶段 - 移动存活对象]</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line">| A*| C*| F*| H*| J*| F | G | H | I | J |  (A,C,F,H,J被移动到一端)</span><br><span class="line">+---+---+---+---+---+---+---+---+---+---+</span><br><span class="line"></span><br><span class="line">[整理后 - 清理边界外内存]</span><br><span class="line">+---+---+---+---+---+---------------------+</span><br><span class="line">| A*| C*| F*| H*| J*|     (空闲空间)      |</span><br><span class="line">+---+---+---+---+---+---------------------+</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li><strong>解决了内存碎片问题</strong>：回收后会产生一块连续的可用内存空间。</li>
<li><strong>空间利用率高</strong>：不需要像复制算法那样牺牲一半的内存空间。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>执行效率相对较低</strong>：整理阶段需要移动大量对象，并且要更新所有指向这些被移动对象的引用，这个过程比单纯的清除要复杂和耗时。因此，它的“Stop-The-World”时间通常比前两种算法要长。</li>
</ul>
<hr>
<h4 id="3-3-4-总结和应用场景"><a href="#3-3-4-总结和应用场景" class="headerlink" title="3.3.4 总结和应用场景"></a>3.3.4 总结和应用场景</h4><table>
<thead>
<tr>
<th>算法</th>
<th>优点</th>
<th>缺点</th>
<th>核心应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>标记-清除 (Mark-Sweep)</strong></td>
<td>实现简单，空间利用率100%</td>
<td><strong>产生内存碎片</strong>，效率不稳定</td>
<td><strong>CMS收集器</strong>（作为后备方案的Full GC）</td>
</tr>
<tr>
<td><strong>标记-复制 (Mark-Copy)</strong></td>
<td><strong>无内存碎片</strong>，在存活对象少时效率高</td>
<td><strong>空间利用率低</strong>（通常为50%），存活对象多时效率低</td>
<td><strong>绝大多数新生代收集器</strong>（如Serial, ParNew, G1的新生代部分）</td>
</tr>
<tr>
<td><strong>标记-整理 (Mark-Compact)</strong></td>
<td><strong>无内存碎片</strong>，空间利用率100%</td>
<td><strong>移动对象和更新引用开销大</strong>，STW时间长</td>
<td><strong>绝大多数老年代收集器</strong>（如Serial Old, Parallel Old, G1的老年代）</td>
</tr>
</tbody></table>
<p><strong>分代收集思想的体现：</strong></p>
<p>现代JVM垃圾收集器通常采用<strong>混合策略</strong>，即<strong>分代收集</strong>：</p>
<ul>
<li><strong>对于新生代</strong>：因为对象存活率低，每次GC只有少量对象存活，所以采用<strong>标记-复制算法</strong>，只需付出少量对象复制的成本就可以完成收集，且效率很高。</li>
<li><strong>对于老年代</strong>：因为对象存活率高，每次GC只有少量对象是垃圾，如果用复制算法代价太大。因此，通常采用<strong>标记-清除</strong>或<strong>标记-整理</strong>算法（或它们的混合形式）来进行回收。</li>
</ul>
<hr>
<h3 id="3-4-分代收集思想：新生代-Eden-S0-S1-与老年代"><a href="#3-4-分代收集思想：新生代-Eden-S0-S1-与老年代" class="headerlink" title="3.4 分代收集思想：新生代 (Eden, S0, S1) 与老年代"></a>3.4 分代收集思想：新生代 (Eden, S0, S1) 与老年代</h3><h4 id="3-4-1-思想的来源"><a href="#3-4-1-思想的来源" class="headerlink" title="3.4.1 思想的来源"></a>3.4.1 思想的来源</h4><p>分代收集并非凭空而来，它建立在对大量程序中对象生命周期进行统计分析后得出的两个重要假说之上：</p>
<ol>
<li><strong>弱分代假说 (Weak Generational Hypothesis)</strong><ul>
<li><strong>内容</strong>：<strong>绝大部分对象都是“朝生夕死”的</strong>。它们在被创建后很短的时间内就会变成垃圾。</li>
<li><strong>推论</strong>：既然大部分对象活不长，我们就可以把它们集中放在一个区域，然后非常<strong>频繁地</strong>对这个区域进行垃圾回收。因为每次回收都能清理掉大量垃圾，所以效率会非常高。</li>
</ul>
</li>
<li><strong>跨代引用假说 (Intergenerational Reference Hypothesis)</strong><ul>
<li><strong>内容</strong>：<strong>跨代引用（尤其是老年代对象引用新生代对象）是极少数的</strong>。</li>
<li><strong>推论</strong>：这个假说至关重要。它意味着我们在对新生代进行垃圾回收（Minor GC）时，<strong>不必为了寻找根节点而扫描整个老年代</strong>。否则，每次回收新生代都得扫描一遍老年代，分代就失去了意义。JVM为此设计了名为**“卡片表”（Card Table）**的数据结构，用以记录老年代的哪块区域（“卡”）存在对新生代对象的引用。这样，进行Minor GC时，只需将这些被标记的“卡片”区域中的对象加入GC Roots一并扫描即可，极大地减少了扫描范围。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-4-2-分代设计：新生代与老年代"><a href="#3-4-2-分代设计：新生代与老年代" class="headerlink" title="3.4.2 分代设计：新生代与老年代"></a>3.4.2 分代设计：新生代与老年代</h4><p>基于上述假说，HotSpot虚拟机将Java堆划分为两个物理上独立的区域：</p>
<ul>
<li><strong>新生代 (Young Generation)</strong></li>
<li><strong>老年代 (Old Generation)</strong></li>
</ul>
<h5 id="1-新生代-Young-Generation"><a href="#1-新生代-Young-Generation" class="headerlink" title="1. 新生代 (Young Generation)"></a>1. 新生代 (Young Generation)</h5><ul>
<li><strong>特点</strong>：新创建的对象<strong>首先</strong>被分配在这里。此区域的对象生命周期短，更新换代快。</li>
<li><strong>GC类型</strong>：发生在此区域的GC称为 <strong>Minor GC</strong> 或 <strong>Young GC</strong>。特点是<strong>频繁但快速</strong>。</li>
<li><strong>采用算法</strong>：由于对象“朝生夕死”，每次Minor GC后只有少量对象存活，因此新生代非常适合采用<strong>标记-复制（Mark-Copy）算法</strong>。</li>
<li><strong>内部结构</strong>：为了配合复制算法的执行，新生代内部又被细分为三个区域：<ul>
<li><strong>伊甸园区 (Eden Space)</strong>：占据了新生代绝大部分空间（默认80%）。它是新对象<strong>真正的出生地</strong>。</li>
<li><strong>两个幸存者区 (Survivor Spaces)</strong>：分别称为 <strong>From Survivor (S0)</strong> 和 <strong>To Survivor (S1)</strong>。它们大小相等，各占新生代的一小部分（默认各10%）。它们是对象在新生代中经历GC后**临时存放和“升级”**的地方。</li>
</ul>
</li>
</ul>
<p><strong>新生代 Minor GC 的完整流程：</strong></p>
<ol>
<li><strong>对象诞生</strong>：绝大多数新对象在<strong>Eden区</strong>中分配。如果开启了TLAB（线程本地分配缓冲），会优先在TLAB上分配。</li>
<li><strong>Eden区满</strong>：当Eden区没有足够空间进行下一次对象分配时，触发<strong>Minor GC</strong>。</li>
<li><strong>标记与复制</strong>：<ul>
<li>GC开始，扫描Eden区和当前作为“From”区的Survivor（假设是S0），找出所有存活对象。</li>
<li>将这些存活对象<strong>复制</strong>到另一个空的Survivor区，即“To”区（S1）。</li>
<li>在复制过程中，每个被复制的对象的**“年龄”（Age）计数器会加1**。</li>
</ul>
</li>
<li><strong>清空</strong>：复制完成后，一次性<strong>清空Eden区和From区（S0）</strong>。此时，这两个区域就变回了干净的空闲空间。</li>
<li><strong>角色互换</strong>：S0和S1的角色发生互换。原来的To区（S1）现在变成了新的From区，里面存放着上一轮GC存活下来的对象；而原来的From区（S0）则变成了新的To区，等待下一次GC。</li>
<li><strong>循环往复</strong>：程序继续运行，新对象仍在Eden区分配。当Eden区再次满时，重复上述过程，只是这次的From区是S1，To区是S0。对象在两个Survivor区之间“来回倒腾”，每次存活下来年龄就加1。</li>
</ol>
<hr>
<h5 id="2-老年代-Old-Generation"><a href="#2-老年代-Old-Generation" class="headerlink" title="2. 老年代 (Old Generation)"></a>2. 老年代 (Old Generation)</h5><ul>
<li><strong>特点</strong>：主要存放生命周期长或者体积大的对象。此区域的对象比较稳定，GC频率远低于新生代。</li>
<li><strong>GC类型</strong>：发生在此区域的GC称为 <strong>Major GC</strong> 或 <strong>Full GC</strong>。特点是<strong>不频繁但耗时较长</strong>，通常会伴随至少一次Minor GC。</li>
<li><strong>采用算法</strong>：由于老年代对象存活率高，不适合复制算法。因此通常采用**标记-清除（Mark-Sweep）<strong>或</strong>标记-整理（Mark-Compact）**算法及其变种。</li>
</ul>
<hr>
<h4 id="3-4-3-一个对象的“一生”：从诞生到晋升-消亡"><a href="#3-4-3-一个对象的“一生”：从诞生到晋升-消亡" class="headerlink" title="3.4.3 一个对象的“一生”：从诞生到晋升&#x2F;消亡"></a>3.4.3 一个对象的“一生”：从诞生到晋升&#x2F;消亡</h4><ol>
<li><strong>诞生</strong>：一个普通对象<code>obj</code>通过<code>new</code>关键字在新生代的<strong>Eden区</strong>出生。</li>
<li><strong>首次幸存</strong>：<code>obj</code>在Eden区经历了一次Minor GC后存活下来，它被复制到<strong>Survivor区</strong>（例如S0），并且它的年龄变为<strong>1</strong>。</li>
<li><strong>颠沛流离</strong>：<code>obj</code>在S0区继续存活，又经历了一次Minor GC。它被复制到另一个Survivor区（S1），年龄变为<strong>2</strong>。就这样，它在S0和S1之间来回“倒腾”。</li>
<li><strong>晋升</strong>：当<code>obj</code>的年龄达到一个阈值（默认是<strong>15</strong>，可以通过<code>-XX:MaxTenuringThreshold</code>设置）后，JVM认为它是一个长期存活的对象。在下一次Minor GC时，它将被**“晋升”（Promote）到老年代**。</li>
<li><strong>终老</strong>：<code>obj</code>在老年代安家落户。它可能会在这里一直存活到程序结束，也可能在未来的某一次Major GC或Full GC中，因为它最终变得不可达而被回收。</li>
</ol>
<hr>
<h4 id="3-4-4-特殊情况：大对象与分配担保"><a href="#3-4-4-特殊情况：大对象与分配担保" class="headerlink" title="3.4.4 特殊情况：大对象与分配担保"></a>3.4.4 特殊情况：大对象与分配担保</h4><ul>
<li><strong>大对象直接进入老年代 (Pre-tenuring)</strong><ul>
<li><strong>原因</strong>：非常大的对象（如长字符串、大数组）如果在新生代分配，会导致在Eden和两个Survivor区之间进行大量的内存复制，效率低下。</li>
<li><strong>策略</strong>：JVM提供了一个参数<code>-XX:PretenureSizeThreshold</code>，当要分配的对象大小超过这个值时，会<strong>直接在老年代分配</strong>。</li>
</ul>
</li>
<li><strong>空间分配担保 (Handle Promotion Failure)</strong><ul>
<li><strong>场景</strong>：在进行Minor GC时，Survivor区空间不足以容纳所有存活对象，需要将一部分对象提前晋升到老年代。但此时，如果老年代的剩余空间也不足以容纳这些要晋升的对象，该怎么办？</li>
<li><strong>策略</strong>：在发生Minor GC前，JVM会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果大于，则此次Minor GC是安全的。如果小于，JVM会查看<code>-XX:HandlePromotionFailure</code>设置是否允许担保失败，如果允许，会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小。如果大于，将尝试进行一次Minor GC（有风险）；如果小于，或者不允许担保失败，则会改为进行一次<strong>Full GC</strong>，以清理出更多的老年代空间。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-5-七大经典垃圾回收器"><a href="#3-5-七大经典垃圾回收器" class="headerlink" title="3.5 七大经典垃圾回收器"></a>3.5 七大经典垃圾回收器</h3><p><strong>组合关系图 (JDK 8及以前):</strong></p>
<pre><code class="highlight mermaid">graph TD
    subgraph &quot;新生代 (Young Gen)&quot;
        S[Serial]
        PN[ParNew]
        PS[(&quot;Parallel&lt;br&gt;Scavenge&quot;)]
    end

    subgraph &quot;老年代 (Old Gen)&quot;
        SO[Serial Old]
        CMS
        PO[(&quot;Parallel Old&quot;)]
    end

    subgraph G1 Collector
      G1[(&quot;G1&lt;br&gt;逻辑分代, 物理不分&quot;)]
    end

    %% 定义收集器之间的搭配关系
    S --&gt; SO
    PN &lt;--&gt; CMS
    PS &lt;--&gt; PO

    %% 您的图中有一个从 Serial 和 ParNew 指向下方，
    %% 以及一个从 Serial Old 指向上方的箭头，
    %% 这通常表示 ParNew 在 CMS 失败时会使用 Serial Old 作为后备。
    %% 这里用虚线表示这种后备关系。
    PN -.-&gt; SO</code></pre>

<p><em>虚线表示在某些JDK版本中可以组合使用。JDK 9以后，ParNew和CMS被标记为废弃，移除了这种组合。</em></p>
<h4 id="3-5-1-Serial-Serial-Old-串行收集器"><a href="#3-5-1-Serial-Serial-Old-串行收集器" class="headerlink" title="3.5.1 Serial &#x2F; Serial Old(串行收集器)"></a>3.5.1 Serial &#x2F; Serial Old(串行收集器)</h4><ul>
<li><strong>特点</strong>：<ul>
<li><strong>单线程</strong>：无论是在新生代（Serial）还是老年代（Serial Old），进行垃圾回收时都只使用<strong>一个CPU或一条GC线程</strong>。</li>
<li><strong>Stop-The-World (STW)</strong>：在GC期间，必须暂停所有用户线程，直到GC结束。</li>
<li><strong>简单高效</strong>：对于单核CPU环境或内存较小的应用，由于没有线程切换的开销，它的回收效率有时是最高的。</li>
</ul>
</li>
<li><strong>工作原理</strong>：<ul>
<li><strong>Serial (新生代)</strong>：采用<strong>标记-复制 (Mark-Copy)</strong> 算法。</li>
<li><strong>Serial Old (老年代)</strong>：采用<strong>标记-整理 (Mark-Compact)</strong> 算法。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li><strong>客户端模式 (Client Mode)</strong>：是HotSpot在Client模式下的默认新生代收集器。适用于桌面应用等对停顿不敏感、内存占用不大的场景。</li>
<li><strong>单核服务器</strong>：在只有一个CPU核心的服务器上，避免了多线程竞争的开销。</li>
<li>作为CMS收集器的后备预案，在并发收集失败时使用。</li>
</ul>
</li>
<li><strong>开启方式</strong>：<code>-XX:+UseSerialGC</code></li>
</ul>
<hr>
<h4 id="3-5-2-Parallel-Parallel-Old-并行收集器"><a href="#3-5-2-Parallel-Parallel-Old-并行收集器" class="headerlink" title="3.5.2 Parallel &#x2F; Parallel Old(并行收集器)"></a>3.5.2 Parallel &#x2F; Parallel Old(并行收集器)</h4><p>也被称为**“吞吐量优先收集器”**。</p>
<ul>
<li><strong>特点</strong>：<ul>
<li><strong>多线程并行</strong>：与Serial类似，但GC时会<strong>同时启动多个GC线程</strong>进行回收，从而缩短STW的时间。</li>
<li><strong>关注吞吐量</strong>：它的目标是达到一个可控的吞吐量（<code>吞吐量 = 用户代码运行时间 / (用户代码运行时间 + GC时间)</code>）。它不特别关注单次GC的停顿时间，而是致力于让单位时间内STW的总时间最短。</li>
<li><strong>自适应调节</strong>：提供了两个关键参数<code>-XX:MaxGCPauseMillis</code>（最大GC停顿时间）和<code>-XX:GCTimeRatio</code>（GC时间占比），GC会根据这些目标自动调整堆的大小等参数。</li>
</ul>
</li>
<li><strong>工作原理</strong>：<ul>
<li><strong>Parallel Scavenge (新生代)</strong>：采用<strong>标记-复制</strong>算法，是多线程并行版本。</li>
<li><strong>Parallel Old (老年代)</strong>：采用<strong>标记-整理</strong>算法，是多线程并行版本。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li><strong>服务器模式 (Server Mode)</strong>：<strong>JDK 8及以前的默认GC</strong>。</li>
<li><strong>后台计算和数据处理</strong>：适用于那些在后台进行大量计算，不需要太多交互，对停顿时间不敏感，但对高吞吐量有要求的任务（如批处理、科学计算）。</li>
</ul>
</li>
<li><strong>开启方式</strong>：<code>-XX:+UseParallelGC</code> (会自动激活Parallel Old) 或 <code>-XX:+UseParallelOldGC</code>。</li>
</ul>
<hr>
<h4 id="3-5-3-CMS-Concurrent-Mark-Sweep"><a href="#3-5-3-CMS-Concurrent-Mark-Sweep" class="headerlink" title="3.5.3 CMS (Concurrent Mark Sweep)"></a>3.5.3 CMS (Concurrent Mark Sweep)</h4><p>**“低停顿”**概念的开创者，是第一款真正意义上的并发收集器。</p>
<ul>
<li><strong>特点</strong>：<ul>
<li><strong>并发收集</strong>：GC线程在某些阶段可以与用户线程<strong>并发执行</strong>，极大地降低了STW时间。</li>
<li><strong>目标是低停顿</strong>：致力于获取最短的回收停顿时间，提升用户体验。</li>
</ul>
</li>
<li><strong>工作原理（基于标记-清除算法）</strong>：<ol>
<li><strong>初始标记 (Initial Mark)</strong>：<strong>STW</strong>。标记GC Roots能直接关联到的对象，速度很快。</li>
<li><strong>并发标记 (Concurrent Mark)</strong>：<strong>并发执行</strong>。从初始标记的对象开始，遍历整个对象图，标记所有存活对象。这个阶段耗时最长，但用户线程可以继续运行。</li>
<li><strong>重新标记 (Remark)</strong>：<strong>STW</strong>。修正并发标记期间因用户线程继续运行而导致标记变动的那一部分对象的标记记录。时间比初始标记稍长，但远比并发标记短。</li>
<li><strong>并发清除 (Concurrent Sweep)</strong>：<strong>并发执行</strong>。清除未被标记的垃圾对象。</li>
</ol>
</li>
<li><strong>缺点</strong>：<ol>
<li><strong>对CPU资源敏感</strong>：并发阶段会占用CPU资源，可能导致用户程序变慢。</li>
<li><strong>无法处理浮动垃圾 (Floating Garbage)</strong>：在并发标记和清除阶段，用户线程新产生的垃圾无法在本次GC中被处理，只能等到下一次GC。</li>
<li><strong>产生内存碎片</strong>：基于<strong>标记-清除</strong>算法，会产生大量内存碎片。当碎片过多导致无法为大对象分配空间时，会触发一次后备的、STW的、使用Serial Old的Full GC，停顿时间反而更长。</li>
<li><strong>CMS与ParNew组合</strong>：CMS作为老年代收集器，通常与新生代的<code>ParNew</code>收集器（实质上是Parallel的“近亲”）配合使用。</li>
</ol>
</li>
<li><strong>适用场景</strong>：<ul>
<li><strong>互联网应用和网站后台</strong>：对响应时间有高要求的服务，希望系统停顿时间尽可能短，以提升用户体验。</li>
<li>在G1出现之前是低延迟应用的首选。</li>
</ul>
</li>
<li><strong>开启方式</strong>：<code>-XX:+UseConcMarkSweepGC</code></li>
</ul>
<hr>
<h4 id="3-5-4-G1-Garbage-First"><a href="#3-5-4-G1-Garbage-First" class="headerlink" title="3.5.4 G1 (Garbage-First)"></a>3.5.4 G1 (Garbage-First)</h4><p>一款<strong>面向服务端应用</strong>的、<strong>兼顾吞吐量和低停顿</strong>的垃圾收集器，是GC发展史上的里程碑。</p>
<ul>
<li><strong>特点</strong>：<ul>
<li><strong>逻辑分代，物理不分</strong>：它将整个Java堆划分为多个大小相等的独立区域（<strong>Region</strong>），每个Region可以根据需要扮演Eden、Survivor或Old的角色。这种设计使得GC可以<strong>按“价值”回收</strong>。</li>
<li><strong>可预测的停顿模型</strong>：允许用户指定一个期望的最大停顿时间（通过<code>-XX:MaxGCPauseMillis</code>）。G1会尽力满足这个目标。</li>
<li><strong>空间整合</strong>：从整体上看是基于<strong>标记-整理</strong>算法，从局部（两个Region之间）看是基于<strong>标记-复制</strong>算法。<strong>不会产生内存碎片</strong>。</li>
<li><strong>并行与并发</strong>：充分利用多核CPU，既有并行阶段（如STW的标记和对象转移），也有并发阶段（如并发标记）。</li>
</ul>
</li>
<li><strong>工作原理</strong>：<ol>
<li>G1会跟踪每个Region的<strong>回收价值</strong>（即回收能释放多少空间，以及预计耗时）。</li>
<li>在后台维护一个<strong>优先列表</strong>，根据用户设定的停顿时间目标，优先回收那些<strong>价值最高</strong>的Region（这也是“Garbage-First”名称的由来）。</li>
<li>GC时，它不是回收整个堆，而是选择一部分Region构成<strong>回收集合（Collection Set）</strong>，通过将存活对象从这些Region复制到其他空闲Region来完成回收。</li>
</ol>
</li>
<li><strong>适用场景</strong>：<ul>
<li><strong>大内存服务器</strong>（通常&gt;6-8GB）。</li>
<li>需要<strong>可控且较低的GC停顿</strong>，同时又希望有不错的吞吐量的应用。</li>
<li><strong>JDK 9+ 的默认GC</strong>，是目前替代CMS的主流选择。</li>
</ul>
</li>
<li><strong>开启方式</strong>：<code>-XX:+UseG1GC</code></li>
</ul>
<hr>
<h4 id="3-5-5-ZGC-Shenandoah-超低停顿收集器"><a href="#3-5-5-ZGC-Shenandoah-超低停顿收集器" class="headerlink" title="3.5.5 ZGC &#x2F; Shenandoah(超低停顿收集器)"></a>3.5.5 ZGC &#x2F; Shenandoah(超低停顿收集器)</h4><p>这两款是目前最前沿的、以<strong>追求极致低停顿</strong>为目标的垃圾收集器，被称为“Stall-Free”（无停顿）或“Pauseless”（无暂停）GC。</p>
<ul>
<li><strong>共同特点</strong>：<ul>
<li><strong>极短的STW时间</strong>：它们的STW时间通常都在<strong>1毫秒以内</strong>，且这个停顿时间<strong>不随堆大小或对象数量的增加而增长</strong>。</li>
<li><strong>并发一切</strong>：它们将GC过程中几乎所有耗时的工作（如标记、转移、整理）都设计为可以与用户线程<strong>并发执行</strong>。</li>
<li><strong>使用读屏障 (Read Barrier)</strong>：这是实现并发转移的关键技术。当用户线程访问一个正在被移动的对象时，读屏障会拦截这次访问，并返回对象的新地址，从而保证数据一致性。</li>
<li><strong>面向超大内存</strong>：为TB级别的堆内存而设计，非常适合未来需要巨大内存的应用。</li>
</ul>
</li>
<li><strong>ZGC (Z Garbage Collector)</strong>：<ul>
<li>由Oracle开发，从JDK 11开始引入，JDK 15正式GA。</li>
<li>采用**着色指针 (Colored Pointers)<strong>和</strong>多重映射 (Multi-Mapping)**技术，将对象信息（如是否被标记）直接编码在指针中，效率极高。</li>
</ul>
</li>
<li><strong>Shenandoah</strong>：<ul>
<li>由Red Hat开发，最早在OpenJDK 12中出现。</li>
<li>采用**连接指针 (Brooks Pointer)**技术，在每个对象头中增加一个转发指针，来实现并发转移。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li><strong>对延迟极度敏感</strong>的服务，如金融交易、实时竞价、在线游戏等，任何长时间的停顿都可能导致业务失败。</li>
<li><strong>需要使用非常大堆内存</strong>（几十GB到几TB）的应用。</li>
</ul>
</li>
<li><strong>开启方式</strong>：<ul>
<li><strong>ZGC</strong>: <code>-XX:+UseZGC</code></li>
<li><strong>Shenandoah</strong>: <code>-XX:+UseShenandoahGC</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-6-Stop-The-World-STW"><a href="#3-6-Stop-The-World-STW" class="headerlink" title="3.6 Stop-The-World (STW)"></a>3.6 Stop-The-World (STW)</h3><h4 id="3-6-1-什么是-STW？"><a href="#3-6-1-什么是-STW？" class="headerlink" title="3.6.1 什么是 STW？"></a>3.6.1 什么是 STW？</h4><p><strong>STW</strong>是指在Java虚拟机（JVM）进行垃圾回收（GC）的特定阶段，必须**暂停所有正在执行的Java应用线程（也称为用户线程）**的现象。</p>
<p>当STW发生时，从应用程序的视角来看，整个系统仿佛被“冻结”了。所有的服务请求处理、定时任务执行、用户交互响应等都会完全停止。只有当垃圾回收的这个阶段完成后，被暂停的用户线程才会被恢复，应用程序才能继续运行。</p>
<hr>
<h4 id="3-6-2-为什么需要-Stop-The-World？"><a href="#3-6-2-为什么需要-Stop-The-World？" class="headerlink" title="3.6.2 为什么需要 Stop-The-World？"></a>3.6.2 为什么需要 Stop-The-World？</h4><p>STW的存在是为了解决一个根本性的问题：<strong>保证垃圾回收期间数据的一致性和准确性</strong>。</p>
<p>在进行垃圾回收时，GC线程需要对整个堆内存中的对象引用关系进行分析，以确定哪些对象是“存活”的，哪些是“死亡”的。这个过程就像是给整个对象图拍一张“快照”。</p>
<p><strong>如果不暂停用户线程，会发生什么？</strong></p>
<ul>
<li><strong>引用关系不断变化</strong>：GC线程正在分析对象A引用了对象B，而与此同时，用户线程可能就把这个引用改成了A引用对象C，或者直接把A的引用置为<code>null</code>。</li>
<li><strong>分析结果不准确</strong>：这种“边分析边修改”的情况会导致GC线程得到一个不准确、不一致的对象引用图。这会带来两个致命的后果：<ol>
<li><strong>错标（误判为垃圾）</strong>：一个本来还在被使用的对象，可能因为在分析过程中引用关系恰好发生了变化，而被错误地标记为“死亡”对象并回收掉。这会导致程序在后续访问这个对象时出现严重错误（如空指针、数据错乱）。</li>
<li><strong>漏标（误判为存活）</strong>：一个本应被回收的垃圾对象，可能因为引用关系的变动而被错误地标记为“存活”，从而导致内存泄漏。</li>
</ol>
</li>
</ul>
<p>因此，为了确保GC能够在一个<strong>稳定、一致</strong>的内存快照上进行分析，<strong>必须</strong>在某些关键阶段（如初始标记、重新标记）让整个世界“停下来”，即执行STW。</p>
<hr>
<h4 id="3-6-3-STW-的影响"><a href="#3-6-3-STW-的影响" class="headerlink" title="3.6.3 STW 的影响"></a>3.6.3 STW 的影响</h4><p>STW对应用程序的影响是直接且显著的，主要体现在**“停顿”（Pause）**上。</p>
<ol>
<li><strong>应用吞吐量下降</strong>：<ul>
<li>STW期间，CPU时间被GC线程占用，用户代码无法执行。STW时间越长、发生越频繁，应用程序用于处理业务逻辑的有效时间就越少，整体吞吐量就会下降。</li>
</ul>
</li>
<li><strong>延迟增加，响应时间变长</strong>：<ul>
<li>这是STW最直观的负面影响。对于需要与用户实时交互的应用（如Web服务、交易系统、在线游戏），一次较长的STW停顿（几十毫秒到几秒不等）可能导致：<ul>
<li>用户请求超时。</li>
<li>交易失败。</li>
<li>界面卡顿、无响应，用户体验急剧下降。</li>
<li>在分布式系统中，可能导致服务被上游系统误判为“死亡”而被剔除出集群。</li>
</ul>
</li>
</ul>
</li>
<li><strong>可预测性差</strong>：<ul>
<li>传统的GC（如Parallel GC）的STW时间与堆大小和对象数量有关，堆越大，停顿时间可能越长，且难以预测。这种不确定性使得满足严格的SLA（服务水平协议）变得困难。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-6-4-现代垃圾回收器如何应对STW"><a href="#3-6-4-现代垃圾回收器如何应对STW" class="headerlink" title="3.6.4 现代垃圾回收器如何应对STW"></a>3.6.4 现代垃圾回收器如何应对STW</h4><p>GC技术的发展史，在很大程度上就是一部<strong>与STW作斗争的历史</strong>。所有现代垃圾回收器都在努力通过各种技术来<strong>缩短、消除或规避</strong>STW。</p>
<ul>
<li><strong>并行收集器 (Parallel GC)</strong>：<ul>
<li><strong>策略</strong>：不减少STW，但通过<strong>多线程并行</strong>的方式，加快GC速度，从而<strong>缩短单次STW的时间</strong>。它关注的是整体吞吐量，而不是单次停顿。</li>
</ul>
</li>
<li><strong>并发收集器 (CMS, G1, ZGC, Shenandoah)</strong>：<ul>
<li><strong>核心思想</strong>：将GC过程中最耗时的阶段（如标记、清理、整理）<strong>拆分</strong>出来，让它们尽可能地与用户线程<strong>并发执行</strong>。</li>
<li><strong>策略</strong>：只在绝对必要（无法并发）的极短阶段进行STW（如初始标记、最终标记）。</li>
<li><strong>CMS</strong>：开创了并发标记的先河，但并发清除会产生碎片。</li>
<li><strong>G1</strong>：实现了并发标记，并通过Region化和复制算法避免了碎片问题，引入了可预测停顿模型。</li>
<li><strong>ZGC &#x2F; Shenandoah</strong>：将并发思想推向极致，通过读屏障等技术实现了<strong>并发的对象移动和整理</strong>，将STW时间压缩到亚毫秒级别，几乎做到了“无停顿”。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-6-5-总结"><a href="#3-6-5-总结" class="headerlink" title="3.6.5 总结"></a>3.6.5 总结</h4><ul>
<li><strong>STW是GC为了保证数据一致性而必须采取的“冻结”应用线程的措施。</strong></li>
<li><strong>它的主要负面影响是导致应用停顿，降低吞吐量，增加延迟。</strong></li>
<li><strong>JVM GC技术的发展趋势就是不断地减少STW的发生频率和持续时间。</strong></li>
<li><strong>选择合适的垃圾回收器，是根据应用场景在“高吞吐量”和“低停顿”之间做出的权衡。</strong></li>
</ul>
<hr>
<h2 id="4-类加载机制"><a href="#4-类加载机制" class="headerlink" title="4. 类加载机制"></a>4. 类加载机制</h2><h3 id="4-1-类加载的生命周期"><a href="#4-1-类加载的生命周期" class="headerlink" title="4.1 类加载的生命周期"></a>4.1 类加载的生命周期</h3><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历以下七个阶段。其中，<strong>验证、准备、解析</strong>三个部分统称为<strong>链接（Linking）</strong>。</p>
<p><strong>生命周期图示：</strong></p>
<pre><code class="highlight mermaid">graph LR
    A[加载&lt;br/&gt;Loading] --&gt; B[验证&lt;br/&gt;Verification]
    B --&gt; C[准备&lt;br/&gt;Preparation]
    C --&gt; D[解析&lt;br/&gt;Resolution]
    D --&gt; E[初始化&lt;br/&gt;Initialization]
    E --&gt; F[使用&lt;br/&gt;Using]
    F --&gt; G[卸载&lt;br/&gt;Unloading]
    
    B -.链接 Linking.-&gt; E
    
    style A fill:#e1f5ff
    style B fill:#fff4e1
    style C fill:#fff4e1
    style D fill:#fff4e1
    style E fill:#fff4e1
    style F fill:#e8f5e9
    style G fill:#ffebee</code></pre>

<p>这些阶段通常是按顺序开始的，但并非按顺序完成。例如，解析阶段在某些情况下可能会在初始化阶段之后再开始，这是为了支持Java的动态绑定（晚期绑定）。</p>
<h4 id="4-1-1-加载"><a href="#4-1-1-加载" class="headerlink" title="4.1.1 加载"></a>4.1.1 加载</h4><p>加载是“类加载”过程的第一个阶段，也是最外部的一个环节，它由**类加载器（ClassLoader）**负责完成。</p>
<p><strong>加载阶段，虚拟机需要完成三件事情：</strong></p>
<ol>
<li><strong>获取二进制字节流</strong>：通过一个类的<strong>全限定名</strong>（如<code>java.lang.String</code>），找到对应的<code>.class</code>文件，并获取定义这个类的二进制字节流。<ul>
<li><strong>来源非常灵活</strong>：可以从本地文件系统（最常见）、网络（如Applet）、JAR&#x2F;ZIP压缩包、数据库，甚至是运行时动态生成（如动态代理技术）。</li>
</ul>
</li>
<li><strong>转化为方法区数据结构</strong>：将这个字节流所代表的静态存储结构，转化为方法区中的<strong>运行时数据结构</strong>。</li>
<li><strong>生成Class对象</strong>：在<strong>Java堆</strong>中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的数据的访问入口。</li>
</ol>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中了，而堆中的<code>Class</code>对象则可以让我们在程序中方便地访问到这些类型数据。</p>
<hr>
<h4 id="4-1-2-链接"><a href="#4-1-2-链接" class="headerlink" title="4.1.2 链接"></a>4.1.2 链接</h4><p>链接阶段负责把类的二进制数据合并到JRE中。</p>
<h5 id="1-验证"><a href="#1-验证" class="headerlink" title="1. 验证"></a>1. 验证</h5><p>验证是链接阶段的第一步，这一阶段的目的是确保<code>.class</code>文件的字节流中包含的信息<strong>符合《Java虚拟机规范》的全部约束要求</strong>，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
<p>这是一个非常重要的安全措施，可以防止恶意代码（如通过修改字节码文件）对JVM造成破坏。验证阶段大致会完成下面四个阶段的检验动作：</p>
<ol>
<li><strong>文件格式验证</strong>：检查字节流是否符合<code>.class</code>文件格式规范，例如：<ul>
<li>是否以魔数<code>0xCAFEBABE</code>开头。</li>
<li>主、次版本号是否在当前虚拟机接受范围之内。</li>
</ul>
</li>
<li><strong>元数据验证</strong>：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，例如：<ul>
<li>这个类是否有父类（除了<code>java.lang.Object</code>之外，所有类都应当有父类）。</li>
<li>这个类是否继承了不允许被继承的类（被<code>final</code>修饰的类）。</li>
</ul>
</li>
<li><strong>字节码验证</strong>：这是整个验证过程中最复杂的一个阶段，主要通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。例如：<ul>
<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li>
<li>保证方法体中的类型转换总是有效的。</li>
</ul>
</li>
<li><strong>符号引用验证</strong>：发生在虚拟机将符号引用转化为直接引用的时候（解析阶段）。这个验证是为了确保解析行为能正常执行。</li>
</ol>
<hr>
<h5 id="2-准备"><a href="#2-准备" class="headerlink" title="2. 准备"></a>2. 准备</h5><p>准备阶段是正式为<strong>类中定义的变量（即静态变量，被<code>static</code>修饰的变量）分配内存并设置其初始值</strong>的阶段。</p>
<p><strong>关键点：</strong></p>
<ol>
<li><strong>分配内存</strong>：此时进行内存分配的<strong>仅包括类变量（<code>static</code>）</strong>，而不包括实例变量。实例变量将会在对象实例化时随着对象一起分配在Java堆中。</li>
<li><strong>设置初始值</strong>：这里所说的“初始值”通常情况下是数据类型的<strong>零值（Zero Value）</strong>，而不是在Java代码中为变量赋的“初始值”。</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>在<strong>准备阶段</strong>，<code>value</code>会被初始化为<code>0</code>，而不是<code>123</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONST_VALUE</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p><strong>例外情况</strong>：如果一个类变量是<strong>常量</strong>（被<code>static final</code>修饰），那么在准备阶段，这个变量的值就会被直接初始化为代码中指定的值。因此，<code>CONST_VALUE</code>在准备阶段就会被赋值为<code>123</code>。这是因为常量的值在编译时就已经确定，并存入了<code>.class</code>文件的常量池中。</p>
<hr>
<h5 id="3-解析"><a href="#3-解析" class="headerlink" title="3. 解析"></a>3. 解析</h5><p>解析阶段是虚拟机将常量池内的**符号引用（Symbolic References）替换为直接引用（Direct References）**的过程。</p>
<ul>
<li><strong>符号引用 (Symbolic Reference)</strong>：<ul>
<li>以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要能无歧义地定位到目标即可。</li>
<li>例如，<code>CONSTANT_Methodref_info</code>中可能包含了方法所在类的全限定名、方法名、方法描述符等文本信息。</li>
<li>符号引用与虚拟机实现的内存布局<strong>无关</strong>。</li>
</ul>
</li>
<li><strong>直接引用 (Direct Reference)</strong>：<ul>
<li>可以是直接指向目标的<strong>指针</strong>、相对<strong>偏移量</strong>或者是一个能间接定位到目标的<strong>句柄</strong>。</li>
<li>直接引用是和虚拟机实现的内存布局<strong>直接相关</strong>的。</li>
</ul>
</li>
</ul>
<p>解析动作主要针对<strong>类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符</strong>这7类符号引用进行。</p>
<hr>
<h4 id="4-1-3-初始化"><a href="#4-1-3-初始化" class="headerlink" title="4.1.3 初始化"></a>4.1.3 初始化</h4><p>初始化是类加载过程的<strong>最后一步</strong>，也是真正开始执行类中定义的**Java程序代码（或者说字节码）**的阶段。</p>
<p><strong>核心任务：</strong></p>
<ul>
<li>执行类的<strong>构造器<code>&lt;clinit&gt;()</code>方法</strong>。</li>
</ul>
<p><strong><code>&lt;clinit&gt;()</code>方法详解：</strong></p>
<ol>
<li><strong>生成方式</strong>：它是由编译器自动收集类中的所有<strong>类变量的赋值动作</strong>和**静态语句块（<code>static{}</code>块）**中的语句合并产生的。编译器收集的顺序是由语句在源文件中出现的顺序决定的。</li>
<li><strong>与实例构造器的区别</strong>：<code>&lt;clinit&gt;()</code>是针对类的，而<code>&lt;init&gt;()</code>（实例构造器）是针对对象的。</li>
<li><strong>执行时机</strong>：只有在父类的<code>&lt;clinit&gt;()</code>方法都执行完毕之后，子类的<code>&lt;clinit&gt;()</code>方法才能执行。因此，在虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类型肯定是<code>java.lang.Object</code>。</li>
<li><strong>非必需</strong>：如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。</li>
<li><strong>线程安全</strong>：虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地<strong>加锁、同步</strong>。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行完毕。</li>
</ol>
<p><strong>触发初始化的时机（主动引用）：</strong></p>
<p>《Java虚拟机规范》严格规定了<strong>有且只有</strong>六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这四条字节码指令时。对应的Java代码场景是：<ul>
<li>使用<code>new</code>关键字实例化对象。</li>
<li>读取或设置一个类型的静态字段（被<code>final</code>修饰、已在编译期把结果放入常量池的静态字段除外）。</li>
<li>调用一个类型的静态方法。</li>
</ul>
</li>
<li>使用<code>java.lang.reflect</code>包的方法对类型进行反射调用时。</li>
<li>当初始化一个类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含<code>main()</code>方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK 7新加入的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果为<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口定义了JDK 8新加入的默认方法（被<code>default</code>关键字修饰的接口方法）时，如果这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<p>除这六种情形以外，所有其他引用类型的方式都不会触发初始化，称为<strong>被动引用</strong>。</p>
<hr>
<h3 id="4-2-类加载器"><a href="#4-2-类加载器" class="headerlink" title="4.2 类加载器"></a>4.2 类加载器</h3><p>从Java虚拟机的角度来看，只存在两种不同的类加载器：</p>
<ol>
<li><strong>启动类加载器 (Bootstrap ClassLoader)</strong>：这个类加载器使用C++语言实现，是虚拟机自身的一部分。</li>
<li><strong>所有其他类加载器</strong>：这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类<code>java.lang.ClassLoader</code>。</li>
</ol>
<p>从Java开发人员的角度来看，类加载器可以划分得更细致一些，构成了经典的三层类加载器结构。</p>
<h4 id="4-2-1-启动类加载器"><a href="#4-2-1-启动类加载器" class="headerlink" title="4.2.1 启动类加载器"></a>4.2.1 启动类加载器</h4><ul>
<li><p><strong>职责</strong>：</p>
<ul>
<li>负责加载Java的<strong>核心类库</strong>，这是Java程序能够正常运行的基础。</li>
<li>它加载存放于<code>&lt;JAVA_HOME&gt;\lib</code>目录，或者被<code>-Xbootclasspath</code>参数所指定的路径中，并且是虚拟机<strong>识别</strong>的类库（按文件名识别，如<code>rt.jar</code>、<code>tools.jar</code>，并非所有放在<code>lib</code>下的都会被加载）。</li>
</ul>
</li>
<li><p><strong>实现与特点</strong>：</p>
<ul>
<li><strong>C++实现</strong>：它是内嵌在JVM内核中的，并非一个Java类。</li>
<li><strong>无父加载器</strong>：它是类加载器层次结构的<strong>顶端</strong>，没有父加载器。</li>
<li><strong>不可见性</strong>：由于它不是Java对象，所以在Java代码中<strong>无法直接获取</strong>到对启动类加载器的引用。当我们尝试获取核心类库（如<code>String.class</code>）的类加载器时，会返回<code>null</code>。</li>
</ul>
</li>
<li><p><strong>代码验证</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取String类的类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">stringClassLoader</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;String.class&#x27;s ClassLoader: &quot;</span> + stringClassLoader); </span><br><span class="line">        <span class="comment">// 输出: String.class&#x27;s ClassLoader: null</span></span><br><span class="line">        <span class="comment">// 因为String是核心类库，由Bootstrap ClassLoader加载，而它在Java层面是不可见的。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-2-2-扩展类加载器"><a href="#4-2-2-扩展类加载器" class="headerlink" title="4.2.2 扩展类加载器"></a>4.2.2 扩展类加载器</h4><p><em>注意：在Java 9及之后，由于模块化系统的引入，扩展类加载器被*<em>平台类加载器 (Platform ClassLoader)</em></em> 所取代，但其基本职责和层次关系思想得以延续。这里我们以JDK 8及以前的经典模型为主要讲解对象。*</p>
<ul>
<li><p><strong>职责</strong>：</p>
<ul>
<li>负责加载Java的<strong>扩展类库</strong>。</li>
<li>它加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库。</li>
<li>开发者可以把自己开发的类库打包成JAR文件放入<code>ext</code>目录，来为所有Java应用提供通用功能，但这在现代开发中已不推荐。</li>
</ul>
</li>
<li><p><strong>实现与特点</strong>：</p>
<ul>
<li><strong>Java实现</strong>：它是一个纯粹的Java类，继承自<code>java.lang.ClassLoader</code>。在JDK 8中，其具体实现类是<code>sun.misc.Launcher$ExtClassLoader</code>。</li>
<li><strong>父加载器</strong>：它的父加载器是<strong>启动类加载器 (Bootstrap ClassLoader)</strong>。</li>
</ul>
</li>
<li><p><strong>代码验证</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试获取一个扩展包中的类，例如DNS服务提供者</span></span><br><span class="line">        <span class="comment">// 这里我们直接获取ExtClassLoader本身来观察其父加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> sun.misc.Launcher.getLauncher().getExtClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;Extension ClassLoader: &quot;</span> + extClassLoader);</span><br><span class="line">        <span class="comment">// 输出类似: Extension ClassLoader: sun.misc.Launcher$ExtClassLoader@...</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Parent of Extension ClassLoader: &quot;</span> + extClassLoader.getParent());</span><br><span class="line">        <span class="comment">// 输出: Parent of Extension ClassLoader: null</span></span><br><span class="line">        <span class="comment">// 同样返回null，因为其父加载器是Bootstrap ClassLoader，Java代码中不可见。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-2-3-应用程序类加载器"><a href="#4-2-3-应用程序类加载器" class="headerlink" title="4.2.3 应用程序类加载器"></a>4.2.3 应用程序类加载器</h4><p>也常被称为<strong>系统类加载器</strong>。</p>
<ul>
<li><p><strong>职责</strong>：</p>
<ul>
<li>负责加载用户类路径（<strong>Classpath</strong>）上所指定的类库。</li>
<li>它加载的是我们自己编写的Java代码、以及项目依赖的第三方JAR包。</li>
<li>是程序中<strong>默认的类加载器</strong>。</li>
</ul>
</li>
<li><p><strong>实现与特点</strong>：</p>
<ul>
<li><strong>Java实现</strong>：它也是一个Java类，继承自<code>java.lang.ClassLoader</code>。在JDK 8中，其具体实现类是<code>sun.misc.Launcher$AppClassLoader</code>。</li>
<li><strong>父加载器</strong>：它的父加载器是<strong>扩展类加载器 (Extension ClassLoader)</strong>。</li>
<li><strong>可直接获取</strong>：在应用程序中，如果自己不定义类加载器，那么默认就是使用这个。可以通过<code>ClassLoader.getSystemClassLoader()</code>方法获取到它的实例。</li>
</ul>
</li>
<li><p><strong>代码验证</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前类的类加载器，即应用程序类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">appClassLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;Application ClassLoader: &quot;</span> + appClassLoader);</span><br><span class="line">        <span class="comment">// 输出类似: Application ClassLoader: sun.misc.Launcher$AppClassLoader@...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取其父加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> appClassLoader.getParent();</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent of Application ClassLoader: &quot;</span> + extClassLoader);</span><br><span class="line">        <span class="comment">// 输出类似: Parent of Application ClassLoader: sun.misc.Launcher$ExtClassLoader@...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取父加载器的父加载器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Parent of Extension ClassLoader: &quot;</span> + extClassLoader.getParent());</span><br><span class="line">        <span class="comment">// 输出: Parent of Extension ClassLoader: null (Bootstrap ClassLoader)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-2-4-三层结构总结"><a href="#4-2-4-三层结构总结" class="headerlink" title="4.2.4 三层结构总结"></a>4.2.4 三层结构总结</h4><p>这三层类加载器共同构成了一个有层次的、父子相继的加载体系。</p>
<table>
<thead>
<tr>
<th>类加载器名称</th>
<th>JDK 8实现类</th>
<th>职责范围</th>
<th>父加载器</th>
<th>Java代码可见性</th>
</tr>
</thead>
<tbody><tr>
<td><strong>启动类加载器 (Bootstrap)</strong></td>
<td>(C++实现)</td>
<td><code>&lt;JAVA_HOME&gt;\lib</code>下的核心类库</td>
<td>无 (是顶层)</td>
<td><strong>不可见 (null)</strong></td>
</tr>
<tr>
<td><strong>扩展类加载器 (Extension)</strong></td>
<td><code>sun.misc.Launcher$ExtClassLoader</code></td>
<td><code>&lt;JAVA_HOME&gt;\lib\ext</code>下的扩展类库</td>
<td>启动类加载器</td>
<td>可见</td>
</tr>
<tr>
<td><strong>应用程序类加载器 (App)</strong></td>
<td><code>sun.misc.Launcher$AppClassLoader</code></td>
<td>用户类路径（Classpath）上的类</td>
<td>扩展类加载器</td>
<td><strong>可见</strong></td>
</tr>
</tbody></table>
<p><strong>自定义类加载器 (Custom ClassLoader)</strong>：</p>
<p>除了这三层系统提供的类加载器，开发者还可以通过继承<code>java.lang.ClassLoader</code>类，重写<code>findClass()</code>方法来创建自己的类加载器。自定义类加载器通常用于实现一些高级功能，如：</p>
<ul>
<li><strong>热部署、热加载</strong>：如Tomcat、Spring Boot DevTools。</li>
<li><strong>代码加密和解密</strong>：在加载<code>.class</code>文件时先进行解密操作。</li>
<li><strong>从非标准来源加载类</strong>：如从数据库、网络或其他自定义存储中加载。</li>
</ul>
<p>自定义类加载器的父加载器默认是<strong>应用程序类加载器</strong>。</p>
<hr>
<h3 id="4-3-双亲委派模型"><a href="#4-3-双亲委派模型" class="headerlink" title="4.3 双亲委派模型"></a>4.3 双亲委派模型</h3><h4 id="4-3-1-原理"><a href="#4-3-1-原理" class="headerlink" title="4.3.1 原理"></a>4.3.1 原理</h4><p>双亲委派模型描述的是<strong>类加载器之间的协作关系</strong>，但它并非一种强制性的约束，而是Java设计者推荐给开发者的一种类加载器实现方式。</p>
<p><strong>核心工作流程：</strong></p>
<p>当一个类加载器收到一个类加载请求时，它的处理步骤如下：</p>
<ol>
<li><strong>向上委派 (Delegate Up)</strong>：它<strong>不会</strong>首先自己去尝试加载这个类，而是会把这个请求<strong>委派给它的父类加载器</strong>去完成。</li>
<li><strong>层层上报</strong>：这个委派过程会一直向上，层层传递，直到达到最顶层的<strong>启动类加载器（Bootstrap ClassLoader）</strong>。</li>
<li><strong>向下加载 (Load Down)</strong>：只有当<strong>父类加载器反馈自己无法完成这个加载请求</strong>（即在它的搜索范围内没有找到所需的类）时，子加载器才会<strong>自己去尝试加载</strong>。</li>
</ol>
<p><strong>图解流程：</strong></p>
<p>假设<code>AppClassLoader</code>收到了加载<code>com.example.MyClass</code>的请求。</p>
<pre><code class="highlight mermaid">graph TD
    A[&quot;&lt;b&gt;加载请求发起&lt;/b&gt;&lt;br&gt;AppClassLoader.loadClass(...)&quot;] --&gt;|&quot;(1. 委派)&quot;| B;
    B[&quot;&lt;b&gt;ExtClassLoader&lt;/b&gt;&lt;br&gt;检查自己是否加载过？(否)&lt;br&gt;继续委派...&quot;] --&gt;|&quot;(2. 委派)&quot;| C;
    C[&quot;&lt;b&gt;BootstrapClassLoader&lt;/b&gt;&lt;br&gt;在 &amp;lt;JAVA_HOME&amp;gt;\\lib 中查找...&lt;br&gt;(找不到com.example.MyClass)&lt;br&gt;返回“无法加载”&quot;] --&gt;|&quot;(3. 父加载器失败，子加载器尝试)&quot;| D;
    D[&quot;&lt;b&gt;ExtClassLoader&lt;/b&gt;&lt;br&gt;在 &amp;lt;JAVA_HOME&amp;gt;\\lib\\ext 中查找...&lt;br&gt;(找不到com.example.MyClass)&lt;br&gt;返回“无法加载”&quot;] --&gt;|&quot;(4. 父加载器失败，子加载器尝试)&quot;| E;
    E[&quot;&lt;b&gt;AppClassLoader&lt;/b&gt;&lt;br&gt;在 Classpath 中查找...&lt;br&gt;(找到！com.example.MyClass)&lt;br&gt;加载成功，返回Class对象&quot;]

    %% --- 样式定义 ---
    style A fill:#e6f3ff,stroke:#5b9bd5,stroke-width:2px
    style E fill:#e2f0d9,stroke:#70ad47,stroke-width:2px
    style C fill:#fbe5d6,stroke:#ed7d31,stroke-width:2px
    style D fill:#fbe5d6,stroke:#ed7d31,stroke-width:2px</code></pre>

<p><strong>代码实现：</strong></p>
<p>这个模型的精髓体现在<code>java.lang.ClassLoader</code>的<code>loadClass()</code>方法的逻辑中（JDK 8 源码简化版）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 1. 检查这个类是否已经被加载过了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 2. 如果没有加载，委派给父加载器</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果父加载器是null，则委派给顶层的Bootstrap ClassLoader</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// 父加载器抛出异常，说明它找不到这个类</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 3. 如果所有父加载器都找不到，才调用自己的 findClass() 方法进行加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出，实现双亲委派的关键在于，将自定义的类加载逻辑写在<code>findClass()</code>方法中，而不是去重写<code>loadClass()</code>方法。</p>
<hr>
<h4 id="4-3-2-优势"><a href="#4-3-2-优势" class="headerlink" title="4.3.2 优势"></a>4.3.2 优势</h4><p>双亲委派模型带来了两个巨大的好处：</p>
<ol>
<li><strong>避免类的重复加载 (Avoids Redundant Loading)</strong><ul>
<li><strong>原理</strong>：由于类加载请求总是先委派给父加载器，一个类在被加载时，会从顶层开始逐层检查是否已被加载。一旦在某一层加载成功，这个<code>Class</code>对象就会被缓存起来。后续任何对该类的加载请求，在委派过程中就会直接返回这个已加载的<code>Class</code>对象。</li>
<li><strong>效果</strong>：确保了在程序的整个生命周期中，对于同一个全限定名的类，<strong>永远只存在一个<code>Class</code>对象</strong>。这为后续判断对象类型来源的一致性（如<code>instanceof</code>检查）提供了基础。</li>
</ul>
</li>
<li><strong>保证Java核心库的安全性 (Ensures Security of Core Libraries)</strong><ul>
<li><strong>原理</strong>：这是双亲委派模型<strong>最重要的作用</strong>。所有的类加载请求最终都会委派到顶层的<code>BootstrapClassLoader</code>。这意味着，Java的核心类库（如<code>java.lang.String</code>、<code>java.lang.Object</code>等）永远是由<code>BootstrapClassLoader</code>来加载的。</li>
<li><strong>效果</strong>：假设一个恶意用户自己编写了一个名为<code>java.lang.String</code>的类，并试图通过自定义的类加载器来加载它以替代系统核心的<code>String</code>类。在双亲委派模型下，这个加载请求会被一直委派到<code>BootstrapClassLoader</code>。<code>BootstrapClassLoader</code>会在核心类库路径下找到并加载正版的<code>java.lang.String</code>，并直接返回，恶意的<code>String</code>类<strong>根本没有机会被加载</strong>。这从根本上防止了核心API被篡改，保护了Java平台的安全。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="4-3-3-如何打破双亲委派模型"><a href="#4-3-3-如何打破双亲委派模型" class="headerlink" title="4.3.3 如何打破双亲委派模型"></a>4.3.3 如何打破双亲委派模型</h4><p>虽然双亲委派模型是推荐的最佳实践，但在某些特定场景下，它并不能满足需求，因此需要被“打破”。打破双亲委派模型，本质上就是改变类加载的默认委派流程。主要有以下几种方式和场景：</p>
<ol>
<li><strong>重写<code>loadClass()</code>方法 (The “Brute-Force” Way)</strong><ul>
<li><strong>方式</strong>：直接重写<code>ClassLoader</code>的<code>loadClass()</code>方法，在其中实现自己的加载逻辑，不遵循“先委派后加载”的原则。例如，可以设计成“先自己加载，失败再委派给父类”。</li>
<li><strong>影响</strong>：这是一种比较彻底的“破坏”，完全颠覆了双亲委派的流程。除非有非常特殊的需求，否则<strong>极不推荐</strong>这样做，因为它可能会引入类加载的混乱和安全风险。</li>
</ul>
</li>
<li><strong>线程上下文类加载器 (Thread Context ClassLoader)</strong><ul>
<li><strong>背景</strong>：双亲委派模型很好地解决了“子加载器能看到父加载器加载的类”的问题，但无法解决“<strong>父加载器需要加载子加载器路径下的类</strong>”的问题。</li>
<li><strong>典型场景：JNDI, JDBC</strong><ul>
<li>JNDI（Java Naming and Directory Interface）服务的代码由核心类库（<code>rt.jar</code>）提供，由<code>BootstrapClassLoader</code>加载。</li>
<li>但JNDI需要调用由各个厂商实现的具体SPI（Service Provider Interface）接口，这些接口的实现类（如MySQL的JDBC驱动<code>com.mysql.cj.jdbc.Driver</code>）通常放在应用程序的Classpath下，由<code>AppClassLoader</code>加载。</li>
<li>这就产生了矛盾：顶层的<code>BootstrapClassLoader</code>无法加载底层的<code>AppClassLoader</code>路径下的类。</li>
</ul>
</li>
<li><strong>解决方案</strong>：引入<strong>线程上下文类加载器</strong>。<code>Thread.currentThread().getContextClassLoader()</code>可以获取当前线程的上下文类加载器（默认是<code>AppClassLoader</code>）。Java核心库（如JNDI）在需要加载SPI实现时，不再使用自己的加载器，而是<strong>反向</strong>从当前线程获取这个上下文类加载器，并用它来加载所需的SPI类。这是一种“<strong>逆向调用</strong>”，巧妙地绕过了双亲委派模型的限制。</li>
</ul>
</li>
<li><strong>OSGi 和模块化热部署 (OSGi &amp; Hot-Deployment)</strong><ul>
<li><strong>背景</strong>：OSGi（Open Service Gateway initiative）是一个动态模块化系统。在OSGi环境下，每个模块（Bundle）都有自己的类加载器。模块之间需要相互引用对方的类，但又不希望是简单的父子关系，而是一种<strong>平级的网状结构</strong>。</li>
<li><strong>解决方案</strong>：OSGi设计了更为复杂的网状类加载器结构。一个Bundle的类加载器在加载类时，会根据模块的依赖关系，去委托其他Bundle的类加载器进行加载，而不是简单地向上委派。这实现了模块间的隔离和精确的依赖管理，是实现热部署等高级功能的基础。</li>
</ul>
</li>
</ol>
<p><strong>Tomcat的类加载器架构 (A Classic Example)</strong></p>
<p>Tomcat作为Web容器，也打破了双亲委派模型，以实现以下目标：</p>
<ul>
<li><strong>Web应用隔离</strong>：部署在同一个Tomcat中的多个Web应用，它们各自的类库（如放在<code>WEB-INF/lib</code>下的JAR）应该相互隔离，互不影响。</li>
<li><strong>共享与隔离并存</strong>：多个Web应用可以共享Tomcat提供的一些公共类库，但又要与应用自身的类库隔离。</li>
</ul>
<p>为了实现这一点，Tomcat设计了一套自己的类加载器结构：</p>
<pre><code class="highlight mermaid">graph TD
    A[BootstrapClassLoader] --&gt; B[&quot;SystemClassLoader&lt;br&gt;(AppClassLoader)&quot;];
    B --&gt; C[CommonClassLoader];
    C --&gt; D[WebApp1ClassLoader];
    C --&gt; E[WebApp2ClassLoader];
    C --&gt; F[...];</code></pre>

<ul>
<li><strong>CommonClassLoader</strong>：加载Tomcat和所有Web应用共享的类库（如<code>tomcat/lib</code>下的）。</li>
<li><strong>WebAppClassLoader</strong>：每个Web应用都有一个自己专属的<code>WebAppClassLoader</code>，负责加载该应用的<code>WEB-INF/classes</code>和<code>WEB-INF/lib</code>下的类。</li>
</ul>
<p><strong>Tomcat的加载顺序</strong>：</p>
<p><code>WebAppClassLoader</code>重写了<code>loadClass()</code>方法，其加载顺序大致为：</p>
<ol>
<li>首先在本地缓存（<code>WEB-INF/...</code>）中查找是否已加载。</li>
<li><strong>先自己尝试加载</strong>（从<code>WEB-INF/classes</code>和<code>WEB-INF/lib</code>）。<strong>—— 这就打破了双亲委派！</strong></li>
<li>如果自己加载不到，<strong>再委派给父加载器</strong>（<code>CommonClassLoader</code> -&gt; <code>System</code> -&gt; <code>Bootstrap</code>）去加载。</li>
</ol>
<p>这种“<strong>先己后亲</strong>”的策略，保证了Web应用可以自由地使用自己版本的类库，而不会与Tomcat或其他应用产生冲突，完美地实现了应用隔离。</p>
<hr>
<h2 id="5-字节码执行引擎"><a href="#5-字节码执行引擎" class="headerlink" title="5. 字节码执行引擎"></a>5. 字节码执行引擎</h2><h3 id="5-1-解释执行-vs-编译执行"><a href="#5-1-解释执行-vs-编译执行" class="headerlink" title="5.1 解释执行 vs. 编译执行"></a>5.1 解释执行 vs. 编译执行</h3><p>当JVM加载了<code>.class</code>文件后，其内部的字节码并不能被底层操作系统直接执行。执行引擎（Execution Engine）的任务就是将这些字节码指令“翻译”成底层平台能够识别的本地机器码。这个“翻译”过程主要有两种方式：<strong>解释执行</strong>和<strong>编译执行</strong>。</p>
<h4 id="5-1-1-解释执行"><a href="#5-1-1-解释执行" class="headerlink" title="5.1.1 解释执行"></a>5.1.1 解释执行</h4><ul>
<li><p><strong>核心思想</strong><br>解释执行就像一个“同声传译”。解释器（Interpreter）逐条读取字节码指令，<strong>每读一条，就立刻翻译成对应的本地机器码并执行</strong>。它不关心下一条指令是什么，也不关心这条指令是否已经被执行过。</p>
</li>
<li><p><strong>工作流程</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读取下一条字节码 -&gt; 翻译为本地机器码 -&gt; 执行该机器码 -&gt; 读取再下一条字节码 ...</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点</strong></p>
<ol>
<li><strong>启动速度快 (Fast Startup)</strong>：不需要预先进行任何耗时的编译工作。当程序需要运行时，解释器可以立即开始工作，这使得Java程序的启动响应非常迅速。</li>
<li><strong>平台无关性</strong>：解释器本身是与平台相关的，它负责屏蔽底层平台的差异。这使得同一份字节码可以在安装了不同平台解释器的JVM上运行，是“一次编写，到处运行”的基石。</li>
</ol>
</li>
<li><p><strong>缺点</strong></p>
<ol>
<li><strong>运行效率低 (Slow Execution)</strong>：这是解释执行最主要的缺点。如果一段代码（例如一个循环体）被反复执行，解释器每次遇到它时都必须<strong>重新进行翻译和执行</strong>。这个重复的翻译开销会极大地拉低程序的整体性能。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="5-1-2-编译执行"><a href="#5-1-2-编译执行" class="headerlink" title="5.1.2 编译执行"></a>5.1.2 编译执行</h4><ul>
<li><strong>核心思想</strong><br>编译执行就像一个“书籍翻译”。编译器（Compiler）会将<strong>整个方法或热点代码块</strong>一次性地、完整地翻译成优化过的本地机器码，然后将这份机器码缓存起来。后续再执行到这段代码时，<strong>直接运行缓存的本地机器码</strong>，无需再次翻译。</li>
<li><strong>在JVM中的实现：即时编译器 (Just-In-Time, JIT)</strong><ul>
<li>Java中谈论的编译执行，通常不是指<code>javac</code>的编译（那是前端编译，从<code>.java</code>到<code>.class</code>），而是指JVM内部的<strong>JIT编译器</strong>。</li>
<li>JIT编译器并不会在一开始就编译所有代码，而是在程序<strong>运行时</strong>，根据代码的执行频率，有选择性地进行编译。</li>
</ul>
</li>
<li><strong>优点</strong><ol>
<li><strong>运行效率高 (Fast Execution)</strong>：对于被频繁执行的“热点代码”，JIT编译带来的性能提升是巨大的。编译后的本地机器码可以直接在CPU上高速运行，省去了重复的翻译开销。</li>
<li><strong>深度优化</strong>：JIT编译器在编译时，可以进行许多高级的、基于运行时信息的优化，例如<strong>方法内联（Method Inlining）</strong>、<strong>逃逸分析（Escape Analysis）</strong>、<strong>公共子表达式消除</strong>等，这些优化可以生成比解释执行和静态编译（AOT）更高质量的机器码。</li>
</ol>
</li>
<li><strong>缺点</strong><ol>
<li><strong>启动速度慢 (Slow Startup)</strong>：JIT编译本身是一个耗时、耗费CPU资源的过程。在程序启动初期，JIT需要时间来分析和编译热点代码，这会增加启动的延迟。</li>
<li><strong>占用内存</strong>：编译后生成的本地机器码需要存储在**代码缓存（Code Cache）**中，这会占用额外的内存空间。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="5-1-3-HotSpot的选择：混合模式-Mixed-Mode-解释与编译并存"><a href="#5-1-3-HotSpot的选择：混合模式-Mixed-Mode-解释与编译并存" class="headerlink" title="5.1.3 HotSpot的选择：混合模式 (Mixed Mode) - 解释与编译并存"></a>5.1.3 HotSpot的选择：混合模式 (Mixed Mode) - 解释与编译并存</h4><p>为了兼顾启动速度和长期运行的性能，现代主流的HotSpot虚拟机采用了<strong>解释执行与即时编译并存的混合模式</strong>，这被认为是目前最成功的方案。</p>
<p><strong>工作流程：</strong></p>
<ol>
<li><strong>以解释器启动</strong>：程序启动时，所有代码都先由<strong>解释器</strong>来执行，以保证快速响应。</li>
<li><strong>热点代码探测 (HotSpot Detection)</strong>：在解释执行的过程中，JVM内部的分析器（Profiler）会持续监控代码的运行情况，主要通过两种计数器来识别“热点代码”：<ul>
<li><strong>方法调用计数器</strong>：统计一个方法被调用的次数。</li>
<li><strong>回边计数器</strong>：统计一个方法中循环体代码执行的次数（“回边”即指循环跳转）。</li>
</ul>
</li>
<li><strong>JIT编译介入</strong>：当某个方法或代码块的计数器超过了预设的<strong>阈值</strong>，JVM就会认为它是一段“热点代码”，并将其提交给JIT编译器。</li>
<li><strong>后台编译</strong>：JIT编译器会在一个或多个<strong>后台线程</strong>中对这段热点代码进行编译，生成高度优化的本地机器码。</li>
<li><strong>代码替换</strong>：编译完成后，JVM会将这个方法原本的入口地址，<strong>透明地替换为指向已编译机器码的地址</strong>。当下次再调用这个方法时，就会直接执行编译后的本地机器码，从而实现性能的飞跃。</li>
</ol>
<p><strong>分层编译 (Tiered Compilation)</strong>：</p>
<p>为了进一步优化“编译慢”和“启动慢”的矛盾，从JDK 7开始，HotSpot引入了分层编译策略。它将编译分为多个层次：</p>
<ul>
<li><strong>C1编译器 (Client Compiler)</strong>：一个轻量级的编译器，编译速度快，优化程度较低。它能让热点代码<strong>快速获得</strong>性能提升。</li>
<li><strong>C2编译器 (Server Compiler)</strong>：一个重量级的编译器，编译速度慢，但优化程度极高，能生成<strong>性能最优</strong>的机器码。</li>
</ul>
<p>在分层编译模式下，一个方法可能会先被C1编译，如果它变得“更热”，则会再被C2重新编译，以达到最佳性能。这种渐进式的优化策略，使得程序的性能曲线更加平滑。</p>
<hr>
<h4 id="5-1-4-总结对比"><a href="#5-1-4-总结对比" class="headerlink" title="5.1.4 总结对比"></a>5.1.4 总结对比</h4><table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">解释执行 (Interpreter)</th>
<th align="left">即时编译 (JIT Compiler)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>执行方式</strong></td>
<td align="left">逐条翻译，逐条执行</td>
<td align="left">将热点代码一次性编译成机器码，后续直接执行机器码</td>
</tr>
<tr>
<td align="left"><strong>启动速度</strong></td>
<td align="left"><strong>快</strong>，无需等待编译</td>
<td align="left"><strong>慢</strong>，需要时间进行分析和编译</td>
</tr>
<tr>
<td align="left"><strong>运行速度</strong></td>
<td align="left"><strong>慢</strong>，存在重复翻译开销</td>
<td align="left"><strong>快</strong>，执行优化后的本地机器码，性能接近C&#x2F;C++</td>
</tr>
<tr>
<td align="left"><strong>优化程度</strong></td>
<td align="left">基本无优化</td>
<td align="left"><strong>可进行深度、动态的运行时优化</strong></td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">程序启动阶段、只执行一次或几次的代码</td>
<td align="left">长期运行的服务中被频繁调用的“热点代码”</td>
</tr>
<tr>
<td align="left"><strong>JVM角色</strong></td>
<td align="left"><strong>启动的先行者</strong>，保证快速响应，并为JIT收集性能数据</td>
<td align="left"><strong>性能的压舱石</strong>，负责将程序性能推向极致</td>
</tr>
</tbody></table>
<p>通过这种“先解释，后编译”的智能化混合模式，Java成功地在<strong>启动速度</strong>和<strong>峰值性能</strong>之间取得了绝佳的平衡，使其成为构建大型、高性能后台服务的理想选择。</p>
<hr>
<h3 id="5-2-即时编译器-JIT-Just-In-Time-Compiler"><a href="#5-2-即时编译器-JIT-Just-In-Time-Compiler" class="headerlink" title="5.2 即时编译器 (JIT, Just-In-Time Compiler)"></a>5.2 即时编译器 (JIT, Just-In-Time Compiler)</h3><p>即时编译器（JIT）是Java虚拟机执行引擎的一部分，它的核心任务是在程序<strong>运行时</strong>，将频繁执行的“热点”字节码动态地编译成本地机器码，并进行深度优化，以极大地提升程序的执行性能。</p>
<h4 id="5-2-1-JIT-在JVM中的位置与角色"><a href="#5-2-1-JIT-在JVM中的位置与角色" class="headerlink" title="5.2.1 JIT 在JVM中的位置与角色"></a>5.2.1 JIT 在JVM中的位置与角色</h4><p>在HotSpot虚拟机中，JIT编译器与解释器是并存且协同工作的。</p>
<ul>
<li><strong>解释器 (Interpreter)</strong>：作为启动时的先行者，保证程序能快速启动和运行。同时，它还扮演着“探子”的角色，为JIT收集代码执行的统计信息。</li>
<li><strong>JIT编译器 (Compiler)</strong>：作为性能的“引擎”，在后台默默地将解释器识别出的热点代码编译成高效的本地代码。</li>
</ul>
<p>这种**混合模式（Mixed Mode）**是HotSpot的默认运行模式。你可以通过<code>-Xint</code>参数强制JVM只使用解释模式，或者通过<code>-Xcomp</code>参数强制JVM在首次使用时就编译所有代码（这会导致启动非常慢）。</p>
<hr>
<h4 id="5-2-2-JIT-的两种编译器：C1-和-C2"><a href="#5-2-2-JIT-的两种编译器：C1-和-C2" class="headerlink" title="5.2.2 JIT 的两种编译器：C1 和 C2"></a>5.2.2 JIT 的两种编译器：C1 和 C2</h4><p>为了在编译速度和编译质量之间取得平衡，HotSpot虚拟机内置了两种（或更多）不同的JIT编译器。从JDK 7开始，默认采用**分层编译（Tiered Compilation）**的策略，这两种编译器协同工作。</p>
<ul>
<li><strong>C1 编译器 (Client Compiler)</strong><ul>
<li><strong>特点</strong>：一个简单、快速的编译器，主要进行<strong>局部性的、可靠的优化</strong>，如方法内联、常量折叠等。</li>
<li><strong>目标</strong>：<strong>快速地</strong>将热点代码编译成本地代码，缩短编译时间，让程序尽快进入编译执行的状态。它致力于提升<strong>启动性能</strong>和<strong>响应速度</strong>。</li>
<li><strong>适用场景</strong>：桌面应用等对启动速度敏感的场景。</li>
</ul>
</li>
<li><strong>C2 编译器 (Server Compiler)</strong><ul>
<li><strong>特点</strong>：一个高度优化的重量级编译器，会执行所有经典的编译器优化，以及一些更激进的、基于运行时统计信息的优化，如逃逸分析、标量替换等。</li>
<li><strong>目标</strong>：生成<strong>性能最优</strong>的本地代码。它的编译过程耗时较长，但能最大化程序的<strong>峰值性能</strong>。</li>
<li><strong>适用场景</strong>：需要长时间运行、对峰值性能要求极高的服务器端应用。</li>
</ul>
</li>
</ul>
<p><strong>分层编译（Tiered Compilation）的工作模式：</strong></p>
<p>分层编译将编译过程划分为多个级别（通常是5个级别，0到4）：</p>
<ul>
<li><strong>Level 0</strong>: 解释执行。</li>
<li><strong>Level 1</strong>: C1编译（无性能分析）。</li>
<li><strong>Level 2</strong>: C1编译（带有限的性能分析）。</li>
<li><strong>Level 3</strong>: C1编译（带完整的性能分析）。</li>
<li><strong>Level 4</strong>: C2编译。</li>
</ul>
<p>一个方法通常会这样“进化”：</p>
<ol>
<li>开始时在 <strong>Level 0</strong>（解释执行）。</li>
<li>当被调用次数达到C1的阈值时，被提交给C1编译器，编译成 <strong>Level 3</strong> 的代码，快速获得性能提升。</li>
<li>如果这个方法继续被大量执行，其性能分析信息会越来越完善。当达到C2的阈值时，它会被提交给C2编译器，编译成 <strong>Level 4</strong> 的代码，达到性能巅峰。</li>
</ol>
<p>这种策略使得程序启动时能快速响应（得益于C1），在长期运行后又能达到极高的性能（得益于C2）。</p>
<hr>
<h4 id="5-2-3-JIT-的核心优化技术"><a href="#5-2-3-JIT-的核心优化技术" class="headerlink" title="5.2.3 JIT 的核心优化技术"></a>5.2.3 JIT 的核心优化技术</h4><p>JIT之所以能生成高效的机器码，关键在于它执行的一系列复杂的优化技术。以下是几种最具代表性的优化：</p>
<h5 id="1-方法内联-Method-Inlining"><a href="#1-方法内联-Method-Inlining" class="headerlink" title="1. 方法内联 (Method Inlining)"></a>1. 方法内联 (Method Inlining)</h5><ul>
<li><p><strong>概念</strong>：这是<strong>最重要</strong>的优化技术之一。它将目标方法的代码“复制”到调用者的代码中，从而避免了方法调用的开销。</p>
</li>
<li><p><strong>方法调用的开销</strong>：一次方法调用涉及创建栈帧、保存和恢复现场、参数传递等一系列操作，是有成本的。</p>
</li>
<li><p><strong>内联的好处</strong>：</p>
<ol>
<li><strong>消除调用开销</strong>：直接省去了上述所有操作。</li>
<li><strong>为其他优化创造条件</strong>：这是更关键的一点。将多个方法体合并到一起后，形成了一个更大的代码块，这为其他跨方法的优化（如逃逸分析）提供了可能性。</li>
</ol>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联优化后 (伪代码)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-逃逸分析-Escape-Analysis"><a href="#2-逃逸分析-Escape-Analysis" class="headerlink" title="2. 逃逸分析 (Escape Analysis)"></a>2. 逃逸分析 (Escape Analysis)</h5><ul>
<li><strong>概念</strong>：一种分析对象动态作用域的技术。它分析一个对象在方法中被创建后，是否**“逃逸”**出方法之外。</li>
<li><strong>“逃逸”的场景</strong>：<ul>
<li><strong>方法逃逸</strong>：作为方法返回值返回。</li>
<li><strong>线程逃逸</strong>：被赋值给类变量，或在其他线程中被访问。</li>
</ul>
</li>
<li><strong>不逃逸的优化</strong>：如果JIT通过分析，确定一个对象<strong>不会逃逸</strong>出当前方法（即它只在方法内部被使用，方法结束后就成了垃圾），就可以进行以下优化：<ol>
<li><strong>栈上分配 (Stack Allocation)</strong>：将这个对象直接在<strong>栈</strong>上分配，而不是在堆上。<ul>
<li><strong>好处</strong>：对象随方法调用结束而自动销毁，无需垃圾回收器介入，极大地减轻了GC压力。</li>
</ul>
</li>
<li><strong>标量替换 (Scalar Replacement)</strong>：如果一个对象不会被整体访问，JIT可能会不创建这个对象，而是将其成员变量“打散”成多个独立的<strong>标量</strong>（基本类型或引用），并直接在栈上分配。<ul>
<li><strong>好处</strong>：连对象创建的开销都省了，是更深层次的优化。</li>
</ul>
</li>
<li><strong>锁消除 (Lock Elision)</strong>：如果一个对象不会逃逸出线程，那么对这个对象的所有同步锁（<code>synchronized</code>）都是没有必要的，JIT可以安全地将这些锁消除掉。</li>
</ol>
</li>
</ul>
<hr>
<h5 id="3-公共子表达式消除-Common-Subexpression-Elimination"><a href="#3-公共子表达式消除-Common-Subexpression-Elimination" class="headerlink" title="3. 公共子表达式消除 (Common Subexpression Elimination)"></a>3. 公共子表达式消除 (Common Subexpression Elimination)</h5><ul>
<li><p><strong>概念</strong>：如果一个表达式在程序中被多次计算，并且其操作数没有改变，那么编译器会将其第一次计算的结果保存起来，后续直接复用这个结果，从而避免重复计算。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前</span></span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> (c * b) * <span class="number">12</span> + a + (b * c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后</span></span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> c * b;</span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> temp * <span class="number">12</span> + a + temp;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="4-循环展开-Loop-Unrolling"><a href="#4-循环展开-Loop-Unrolling" class="headerlink" title="4. 循环展开 (Loop Unrolling)"></a>4. 循环展开 (Loop Unrolling)</h5><ul>
<li><p><strong>概念</strong>：通过减少循环的迭代次数，但增加每次迭代中的操作数量，来减少循环控制（如循环计数器增减、循环条件判断）带来的开销。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    array[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后 (伪代码)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    array[i] = i;</span><br><span class="line">    array[i+<span class="number">1</span>] = i+<span class="number">1</span>;</span><br><span class="line">    array[i+<span class="number">2</span>] = i+<span class="number">2</span>;</span><br><span class="line">    array[i+<span class="number">3</span>] = i+<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="5-2-4-逆优化-Deoptimization"><a href="#5-2-4-逆优化-Deoptimization" class="headerlink" title="5.2.4 逆优化 (Deoptimization)"></a>5.2.4 逆优化 (Deoptimization)</h4><p>JIT的许多激进优化是建立在**“假设”**之上的（例如，假设一个接口只有一个实现类，从而可以进行内联）。如果程序运行过程中，这个假设被打破了（例如，加载了该接口的另一个实现类），那么之前基于这个假设编译的代码就变得无效了。</p>
<p>此时，JVM会进行<strong>逆优化</strong>，抛弃已编译的机器码，回退到<strong>解释执行</strong>状态，等待重新收集信息并进行更保守的编译。这个过程保证了JIT优化的安全性和灵活性。</p>
<p><strong>总结：</strong> JIT编译器是JVM的性能心脏。它通过分层编译策略和一系列复杂的优化技术（如方法内联、逃逸分析等），在保证程序快速启动的同时，将Java程序的峰值性能提升到了一个非常高的水平。理解JIT的原理，对于编写高性能Java代码和进行深度性能调优具有重要意义。</p>
<hr>
<h3 id="5-3-热点代码探测、方法内联、逃逸分析等优化技术"><a href="#5-3-热点代码探测、方法内联、逃逸分析等优化技术" class="headerlink" title="5.3 热点代码探测、方法内联、逃逸分析等优化技术"></a>5.3 热点代码探测、方法内联、逃逸分析等优化技术</h3><p>JIT编译器并非盲目地编译所有代码，它需要一套精密的机制来识别最有价值的代码并对其进行深度优化。</p>
<hr>
<h4 id="5-3-1-热点代码探测-HotSpot-Code-Detection"><a href="#5-3-1-热点代码探测-HotSpot-Code-Detection" class="headerlink" title="5.3.1 热点代码探测 (HotSpot Code Detection)"></a>5.3.1 热点代码探测 (HotSpot Code Detection)</h4><p>这是JIT优化的<strong>前提</strong>。JVM必须先找出哪些代码是“热点”，才值得花费时间和资源去编译。HotSpot虚拟机采用的是**基于计数器的热点探测（Counter-Based Hot Spot Detection）**方法。</p>
<p>它为每个方法（或代码块）建立了两类计数器：</p>
<h5 id="1-方法调用计数器-Method-Invocation-Counter"><a href="#1-方法调用计数器-Method-Invocation-Counter" class="headerlink" title="1. 方法调用计数器 (Method Invocation Counter)"></a>1. 方法调用计数器 (Method Invocation Counter)</h5><ul>
<li><strong>作用</strong>：统计一个方法被调用的次数。</li>
<li><strong>工作流程</strong>：<ol>
<li>当一个方法被调用时，JVM会检查该方法是否存在已编译的版本。如果没有，调用计数器加1。</li>
<li>当计数器的值超过一个<strong>阈值</strong>时（在Client模式下默认为1,500次，Server模式下为10,000次，可通过<code>-XX:CompileThreshold</code>调整），这个方法就会被认为是一个热点方法。</li>
<li>JVM会向JIT编译器提交一个对该方法的编译请求，并由后台的编译线程来执行编译。</li>
<li>编译完成后，这个方法的入口地址会被替换为指向本地机器码的地址。</li>
</ol>
</li>
<li><strong>热度衰减 (Counter Decay)</strong>：这个计数器并不是永久累加的。为了适应程序行为的动态变化（可能某个方法在一段时间后就不再是热点了），计数器会随着时间的推移而“衰减”。当超过一定时间（由<code>-XX:CounterHalfLifeTime</code>参数设定）没有调用时，计数器的值会减半。</li>
</ul>
<hr>
<h5 id="2-回边计数器-Back-Edge-Counter"><a href="#2-回边计数器-Back-Edge-Counter" class="headerlink" title="2. 回边计数器 (Back-Edge Counter)"></a>2. 回边计数器 (Back-Edge Counter)</h5><ul>
<li><strong>作用</strong>：统计一个方法中<strong>循环体代码被执行的次数</strong>。“回边”指的是在循环中，从循环体末尾跳转回循环头部的指令。</li>
<li><strong>目的</strong>：有时候一个方法可能被调用的次数不多，但方法内部有一个长时间执行的大循环。这种情况下，方法本身不是热点，但循环体是热点。回边计数器就是为了识别这种情况。</li>
<li><strong>工作流程</strong>：<ol>
<li>当解释器遇到循环的回边指令时，回边计数器加1。</li>
<li>当计数器值超过一个阈值时，这个循环体被判定为热点。</li>
<li>此时会触发一种特殊的编译——<strong>栈上替换（On-Stack Replacement, OSR）</strong>。</li>
</ol>
</li>
<li><strong>栈上替换 (OSR)</strong>：它允许JVM在<strong>方法执行过程中</strong>，即时地将正在解释执行的循环体切换到已编译的机器码版本上继续执行，而不需要等待整个方法调用结束。这对于提升长时间运行循环的性能至关重要。</li>
</ul>
<hr>
<h4 id="5-3-2-方法内联-Method-Inlining"><a href="#5-3-2-方法内联-Method-Inlining" class="headerlink" title="5.3.2 方法内联 (Method Inlining)"></a>5.3.2 方法内联 (Method Inlining)</h4><p>这是JIT优化中<strong>最重要、最基础</strong>的技术，没有之一。它的效果不仅在于消除方法调用的开销，更在于为其他优化技术创造了条件。</p>
<ul>
<li><p><strong>核心思想</strong>：将目标方法的代码“复制”到调用者的代码中，替换掉原来的方法调用指令。</p>
</li>
<li><p><strong>带来的好处</strong>：</p>
<ol>
<li><strong>消除方法调用成本</strong>：方法调用本身是有开销的，包括创建和销毁栈帧、保存和恢复寄存器、传递参数等。内联直接消除了这些开销。</li>
<li><strong>创造更多优化机会（更关键）</strong>：将多个方法体“展平”到一个更大的代码块中后，编译器的优化视野变大了。原本局限于单个方法内的优化（如公共子表达式消除、常量传播）现在可以<strong>跨方法</strong>进行，从而产生1+1 &gt; 2的效果。</li>
</ol>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化前</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> add(a, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JIT进行方法内联后 (逻辑上等效于)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>内联的挑战与决策</strong>：JIT不会无限制地进行内联，因为它会导致编译后的代码体积膨胀。它会根据一些启发式规则来决定是否内联，比如：</p>
<ul>
<li>方法体大小：太大的方法通常不会被内联。</li>
<li>调用频率：只有热点方法才值得被内联。</li>
<li>虚方法调用：对于虚方法（需要动态绑定的方法），JIT会通过<strong>类型继承关系分析（CHA）**和**内联缓存（Inline Caching）**来确定目标方法的具体类型，如果目标类型是唯一的或高度稳定的，就会进行**守护内联（Guarded Inlining）<strong>，并准备在假设失败时进行</strong>逆优化</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-3-3-逃逸分析-Escape-Analysis"><a href="#5-3-3-逃逸分析-Escape-Analysis" class="headerlink" title="5.3.3 逃逸分析 (Escape Analysis)"></a>5.3.3 逃逸分析 (Escape Analysis)</h4><p>这是JIT中一项非常前沿且强大的优化技术，它不是直接进行代码优化，而是为其他优化提供分析依据。</p>
<ul>
<li><p><strong>核心思想</strong>：分析一个对象在方法中被创建后，它的引用是否会**“逃逸”**出当前方法的范围。</p>
</li>
<li><p><strong>三种逃逸状态</strong>：</p>
<ol>
<li><strong>不逃逸 (NoEscape)</strong>：对象的引用<strong>始终</strong>只在当前方法内部活动，没有被外部方法引用，也没有作为返回值返回。</li>
<li><strong>参数逃逸 (ArgEscape)</strong>：对象被作为参数传递给了其他方法，但没有发生更进一步的逃逸。</li>
<li><strong>全局逃逸 (GlobalEscape)</strong>：对象的引用逃出了当前方法，比如作为返回值返回，或者被赋值给了静态变量或逃逸对象的字段。</li>
</ol>
</li>
<li><p><strong>基于“不逃逸”状态的优化</strong>：如果JIT通过逃逸分析确定一个对象是**“不逃逸”**的，它就可以进行以下三种重量级优化：</p>
<ol>
<li><p><strong>栈上分配 (Stack Allocation)</strong></p>
<ul>
<li><strong>做法</strong>：将本应在**堆（Heap）<strong>上分配的对象，直接在当前线程的</strong>栈（Stack）**上分配内存。</li>
<li><strong>巨大优势</strong>：栈上的内存在方法执行结束后会自动弹出并销毁，<strong>完全不需要垃圾回收器（GC）的介入</strong>。这极大地减轻了GC的压力，提升了程序的吞吐量。</li>
</ul>
</li>
<li><p><strong>标量替换 (Scalar Replacement)</strong></p>
<ul>
<li><p><strong>做法</strong>：如果一个“不逃逸”的对象甚至都不需要作为一个完整的对象来访问，JIT可能会不创建这个对象实例，而是将其内部的各个字段（称为<strong>标量</strong>）打散，当作独立的局部变量来对待。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123; <span class="type">int</span> x, y; &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(); <span class="comment">// p不逃逸</span></span><br><span class="line">    p.x = <span class="number">1</span>;</span><br><span class="line">    p.y = <span class="number">2</span>;</span><br><span class="line">    use(p.x + p.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 标量替换后 (逻辑上等效于)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">px</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">py</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    use(px + py);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优势</strong>：连对象创建的内存开销和字段访问的开销都省掉了，是比栈上分配更彻底的优化。</p>
</li>
</ul>
</li>
<li><p><strong>锁消除 (Lock Elision)</strong></p>
<ul>
<li><strong>做法</strong>：如果一个“不逃逸”的对象被用作<code>synchronized</code>锁，JIT会判断这个锁是完全没有必要的（因为其他线程根本无法访问到这个对象），从而安全地<strong>消除掉这个同步锁</strong>。</li>
<li><strong>优势</strong>：消除了无意义的锁竞争和同步开销。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>总结</strong>：这些优化技术环环相扣，共同构成了JIT的强大能力。</p>
<ol>
<li><strong>热点代码探测</strong>首先识别出最有价值的优化目标。</li>
<li><strong>方法内联</strong>打破了方法间的壁垒，为后续优化提供了广阔的舞台。</li>
<li><strong>逃逸分析</strong>则对对象的生命周期进行深度洞察，从而解锁了<strong>栈上分配</strong>、<strong>标量替换</strong>和<strong>锁消除</strong>这些能够从根本上改变内存分配和并发行为的重量级优化。</li>
</ol>
<p>正是这些技术的协同作用，使得Java程序在经过充分预热后，能够展现出惊人的高性能。</p>
<hr>
<h1 id="三、企业级性能调优与实战"><a href="#三、企业级性能调优与实战" class="headerlink" title="三、企业级性能调优与实战"></a>三、企业级性能调优与实战</h1><h2 id="1-JVM调优的目标与原则"><a href="#1-JVM调优的目标与原则" class="headerlink" title="1. JVM调优的目标与原则"></a>1. JVM调优的目标与原则</h2><p>JVM调优不是一个盲目的过程，它是一项有明确目标、遵循科学方法的工程活动。在动手修改任何参数之前，必须先明确我们想要达成什么目标，以及应该遵循什么样的原则。</p>
<h3 id="1-1-调优三大指标"><a href="#1-1-调优三大指标" class="headerlink" title="1.1 调优三大指标"></a>1.1 调优三大指标</h3><p>吞吐量 (Throughput)、延迟 (Latency)、内存占用 (Footprint) 这三个指标是衡量一个Java应用性能最核心的维度。它们之间常常存在<strong>相互制约</strong>的关系，调优的过程就是在这三者之间寻找最适合当前业务场景的<strong>平衡点（Trade-off）</strong>。</p>
<h4 id="1-1-1-吞吐量-Throughput"><a href="#1-1-1-吞吐量-Throughput" class="headerlink" title="1.1.1 吞吐量 (Throughput)"></a>1.1.1 吞吐量 (Throughput)</h4><ul>
<li><p><strong>定义</strong><br>吞吐量指的是在<strong>单位时间内，应用程序能够完成的工作量</strong>。对于JVM来说，通常更关注的是<strong>用户代码运行时间占总运行时间的比例</strong>。</p>
<p><code>吞吐量 = 用户代码运行时间 / (用户代码运行时间 + GC时间)</code></p>
</li>
<li><p><strong>衡量标准</strong></p>
<ul>
<li><strong>高吞吐量</strong>意味着GC所占用的时间相对较少，CPU能够更多地投入到业务逻辑的执行上。</li>
<li>指标通常是百分比，如99%的吞吐量意味着只有1%的时间花在了GC上。</li>
</ul>
</li>
<li><p><strong>适用场景</strong></p>
<ul>
<li><strong>后台计算、数据处理、批处理任务</strong>：这类任务不与用户直接交互，对单次任务的响应时间不敏感，但要求在限定时间内处理尽可能多的数据。例如，大数据分析、报表生成、科学计算等。</li>
</ul>
</li>
<li><p><strong>对应的垃圾回收器</strong></p>
<ul>
<li><strong>Parallel &#x2F; Parallel Old</strong>：这是典型的“吞吐量优先”收集器，它的设计目标就是最大化吞吐量。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-2-延迟-Latency-停顿时间-Pause-Time"><a href="#1-1-2-延迟-Latency-停顿时间-Pause-Time" class="headerlink" title="1.1.2 延迟 (Latency) &#x2F; 停顿时间 (Pause Time)"></a>1.1.2 延迟 (Latency) &#x2F; 停顿时间 (Pause Time)</h4><ul>
<li><strong>定义</strong><br>延迟指的是应用程序<strong>从发出请求到收到响应所花费的时间</strong>。在JVM调优中，我们更关注的是由<strong>垃圾回收（GC）导致的“Stop-The-World”（STW）停顿时间</strong>。这个停顿时间是影响延迟的关键因素。</li>
<li><strong>衡量标准</strong><ul>
<li><strong>低延迟</strong>意味着GC导致的STW停顿时间非常短且可控。</li>
<li>指标通常是<strong>最大停顿时间</strong>（Max Pause Time）或<strong>停顿时间的百分位统计</strong>（如99.9th percentile pause time &lt; 10ms），后者更能反映系统在绝大多数情况下的表现。</li>
</ul>
</li>
<li><strong>适用场景</strong><ul>
<li><strong>对响应时间有高要求的在线服务</strong>：这类应用需要快速响应用户请求，任何长时间的停顿都可能导致用户体验下降或系统雪崩。例如，高并发的Web应用、API网关、交易系统、在线游戏等。</li>
</ul>
</li>
<li><strong>对应的垃圾回收器</strong><ul>
<li><strong>CMS、G1、ZGC、Shenandoah</strong>：这些并发收集器的核心设计目标就是降低GC停顿时间。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-3-内存占用-Footprint"><a href="#1-1-3-内存占用-Footprint" class="headerlink" title="1.1.3 内存占用 (Footprint)"></a>1.1.3 内存占用 (Footprint)</h4><ul>
<li><strong>定义</strong><br>内存占用指的是一个Java进程在其生命周期内所消耗的<strong>内存大小</strong>。主要包括<strong>堆内存</strong>和<strong>非堆内存</strong>（如元空间、直接内存）。</li>
<li><strong>衡量标准</strong><ul>
<li><strong>低内存占用</strong>意味着在满足性能要求的前提下，使用尽可能少的内存。</li>
<li>指标是具体的内存大小，如MB或GB。</li>
</ul>
</li>
<li><strong>适用场景</strong><ul>
<li><strong>内存受限的环境</strong>：如微服务架构、容器化部署（Docker&#x2F;Kubernetes）、嵌入式设备等。在这些场景下，每个服务实例分配的内存有限，需要精打细算。</li>
<li><strong>成本敏感型应用</strong>：在云环境中，内存是重要的计费资源，降低内存占用直接等同于节约成本。</li>
</ul>
</li>
<li><strong>对应的垃圾回收器&#x2F;策略</strong><ul>
<li><strong>OpenJ9</strong>：以低内存占用著称。</li>
<li><strong>G1&#x2F;ZGC</strong>：虽然为大内存设计，但通过合理的参数配置，也可以在一定程度上控制内存占用。</li>
<li><strong>合理设置堆大小</strong>（<code>-Xms</code>, <code>-Xmx</code>）是控制内存占用的最直接手段。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-4-三者之间的矛盾"><a href="#1-1-4-三者之间的矛盾" class="headerlink" title="1.1.4 三者之间的矛盾"></a>1.1.4 三者之间的矛盾</h4><p>通常情况下，无法同时完美地实现这三个目标。</p>
<ul>
<li>要<strong>降低延迟</strong>（使用并发GC），就需要在GC和用户线程之间共享CPU，可能会牺牲一些<strong>吞吐量</strong>，并且并发GC通常需要更大的<strong>内存</strong>来容纳浮动垃圾。</li>
<li>要<strong>提高吞TP量</strong>（使用并行GC），通常意味着GC时会独占CPU，导致较长的<strong>延迟</strong>（STW）。</li>
<li>要<strong>减少内存占用</strong>，可能会导致更频繁的GC，从而影响<strong>吞吐量</strong>和<strong>延迟</strong>。</li>
</ul>
<p><strong>因此，调优的第一步就是明确业务场景下最关键的指标是什么，并愿意在其他指标上做出妥协。</strong></p>
<hr>
<h3 id="1-2-调优原则"><a href="#1-2-调优原则" class="headerlink" title="1.2 调优原则"></a>1.2 调优原则</h3><p>在进行具体的调优操作时，遵循以下原则可以让你事半功倍，避免误入歧途。</p>
<h4 id="1-2-1-无监控，不调优-Profile-First-Tune-Later"><a href="#1-2-1-无监控，不调优-Profile-First-Tune-Later" class="headerlink" title="1.2.1 无监控，不调优 (Profile First, Tune Later)"></a>1.2.1 无监控，不调优 (Profile First, Tune Later)</h4><ul>
<li><strong>核心思想</strong>：<strong>永远不要基于猜测去调优</strong>。性能问题必须由<strong>真实的数据</strong>来驱动。</li>
<li><strong>实践</strong>：<ol>
<li><strong>建立监控体系</strong>：在生产或准生产环境中，部署完善的监控系统，持续收集JVM的各项关键指标，如GC次数、GC时间、堆内存使用情况、线程状态等。</li>
<li><strong>使用分析工具</strong>：在发现问题后，使用专业的性能分析工具（如JFR, VisualVM, MAT, Arthas等）来深入剖析瓶颈所在。</li>
<li><strong>量化问题</strong>：用数据来描述问题，例如“Full GC平均耗时从200ms上升到1s”，而不是“系统变慢了”。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="1-2-2-从全局到局部-System-Wide-to-JVM"><a href="#1-2-2-从全局到局部-System-Wide-to-JVM" class="headerlink" title="1.2.2 从全局到局部 (System-Wide to JVM)"></a>1.2.2 从全局到局部 (System-Wide to JVM)</h4><ul>
<li><p><strong>核心思想</strong>：一个应用的性能瓶颈不一定在JVM内部。在深入JVM调优之前，先从更宏观的层面排查。</p>
</li>
<li><p><strong>实践</strong>：</p>
<ol>
<li><strong>检查外部系统</strong>：性能问题是否由外部依赖（如数据库慢查询、第三方API延迟、网络抖动）引起？</li>
<li><strong>检查操作系统层面</strong>：CPU使用率是否过高？磁盘I&#x2F;O是否成为瓶颈？内存是否足够？</li>
<li><strong>检查应用架构和代码</strong>：是否存在不合理的算法、数据结构使用不当、过多的同步锁竞争、或者资源未正确释放等问题？</li>
</ol>
<ul>
<li><strong>80%的性能问题都可以通过优化代码和架构来解决</strong>。JVM调优通常是解决最后那20%问题的“最后一公里”。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-3-先定位瓶颈-Identify-the-Bottleneck-First"><a href="#1-2-3-先定位瓶颈-Identify-the-Bottleneck-First" class="headerlink" title="1.2.3 先定位瓶颈 (Identify the Bottleneck First)"></a>1.2.3 先定位瓶颈 (Identify the Bottleneck First)</h4><ul>
<li><strong>核心思想</strong>：性能调优的目标是解决<strong>瓶颈</strong>，而不是盲目地调整所有参数。根据“木桶理论”，应用的整体性能取决于其最慢的那个环节。</li>
<li><strong>实践</strong>：<ol>
<li><strong>区分瓶颈类型</strong>：当前的瓶颈是<strong>CPU密集型</strong>还是<strong>I&#x2F;O密集型</strong>？是<strong>内存分配</strong>过快导致频繁GC，还是<strong>GC停顿</strong>时间过长？</li>
<li><strong>对症下药</strong>：<ul>
<li>如果是频繁Minor GC，可能是Eden区太小，或者对象分配速率过高。</li>
<li>如果是频繁Full GC，可能是老年代空间不足、存在内存泄漏、或有大对象分配问题。</li>
<li>如果是STW时间过长，可能需要更换垃圾回收器或调整其参数。</li>
<li>如果是CPU占用率高，需要用<code>jstack</code>等工具定位到具体的耗时线程和代码。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="2-常用的JVM参数设置"><a href="#2-常用的JVM参数设置" class="headerlink" title="2. 常用的JVM参数设置"></a>2. 常用的JVM参数设置</h2><p>JVM参数大致可以分为三类：</p>
<ul>
<li><strong>标准参数 (<code>-</code>)</strong>：所有JVM实现都必须支持的功能，相对稳定。如 <code>-version</code>, <code>-help</code>。</li>
<li><strong>非标准参数 (<code>-X</code>)</strong>：特定于某个JVM实现（如HotSpot）的参数，不保证所有JVM都支持，但通常比较稳定。如 <code>-Xms</code>, <code>-Xmx</code>。</li>
<li><strong>非稳定参数 (<code>-XX</code>)</strong>：主要用于JVM的深度调优和开发，可能在不同版本间发生变化，不保证向后兼容。这类参数最多，也最关键。<ul>
<li><strong>布尔类型</strong>：<code>-XX:+&lt;option&gt;</code> (开启) 或 <code>-XX:-&lt;option&gt;</code> (关闭)。</li>
<li><strong>键值类型</strong>：<code>-XX:&lt;option&gt;=&lt;value&gt;</code>。</li>
</ul>
</li>
</ul>
<h3 id="2-1-堆内存设置"><a href="#2-1-堆内存设置" class="headerlink" title="2.1 堆内存设置"></a>2.1 堆内存设置</h3><p>这是最基础、最重要的参数设置，直接决定了JVM的内存“地基”。</p>
<ul>
<li><strong><code>-Xms&lt;size&gt;</code></strong><ul>
<li><strong>含义</strong>：设置Java堆的<strong>初始大小 (Initial Heap Size)</strong>。</li>
<li><strong>示例</strong>：<code>-Xms2g</code> 表示初始堆大小为2GB。</li>
<li><strong>最佳实践</strong>：在生产环境中，通常建议将初始堆大小与最大堆大小设置为<strong>相等</strong>，即 <code>-Xms</code> 和 <code>-Xmx</code> 设置成一样的值。</li>
<li><strong>原因</strong>：<ol>
<li><strong>避免运行时扩容开销</strong>：如果初始值和最大值不同，JVM在运行时需要根据内存使用情况动态地扩展或收缩堆。这个过程可能会触发GC，带来不必要的性能抖动。</li>
<li><strong>启动时即获得稳定性能</strong>：一开始就分配好足够的内存，可以保证应用启动后立刻就能以稳定的状态运行。</li>
</ol>
</li>
</ul>
</li>
<li><strong><code>-Xmx&lt;size&gt;</code></strong><ul>
<li><strong>含义</strong>：设置Java堆的<strong>最大大小 (Maximum Heap Size)</strong>。</li>
<li><strong>示例</strong>：<code>-Xmx4g</code> 表示最大堆大小为4GB。</li>
<li><strong>最佳实践</strong>：这个值的设定需要根据应用的实际内存需求和服务器的物理内存来综合考量。设置过小容易导致OOM，设置过大（超过物理内存）可能导致操作系统使用交换空间（Swap），性能会急剧下降。</li>
</ul>
</li>
<li><strong><code>-Xmn&lt;size&gt;</code></strong> 或 <strong><code>-XX:NewSize=&lt;size&gt;</code> &#x2F; <code>-XX:MaxNewSize=&lt;size&gt;</code></strong><ul>
<li><strong>含义</strong>：设置<strong>新生代 (Young Generation)</strong> 的大小。<code>-Xmn</code>是设置一个固定的大小，而<code>NewSize</code>和<code>MaxNewSize</code>分别设置初始和最大值。</li>
<li><strong>示例</strong>：<code>-Xmn1g</code> 表示新生代大小为1GB。</li>
<li><strong>最佳实践</strong>：新生代的大小对GC性能影响很大。<ul>
<li><strong>设置得大</strong>：可以减少Minor GC的频率，但单次Minor GC的时间可能会变长。</li>
<li><strong>设置得小</strong>：Minor GC会更频繁，但单次耗时短。对象也可能更快地晋升到老年代，增加Full GC的风险。</li>
<li>通常建议设置为整个堆大小的<strong>1&#x2F;4到1&#x2F;2</strong>之间。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>-XX:SurvivorRatio=&lt;ratio&gt;</code></strong><ul>
<li><strong>含义</strong>：设置新生代中 <strong>Eden区与一个Survivor区的空间比例</strong>。默认值是8。</li>
<li><strong>计算公式</strong>：<code>Eden区大小 = (新生代大小 / (ratio + 2)) * ratio</code>，<code>每个Survivor区大小 = 新生代大小 / (ratio + 2)</code>。</li>
<li><strong>示例</strong>：<code>-XX:SurvivorRatio=8</code> 意味着 Eden : S0 : S1 &#x3D; 8 : 1 : 1。</li>
<li><strong>最佳实践</strong>：如果<code>SurvivorRatio</code>设置得过大，会导致Survivor区过小，对象在Minor GC后可能因为Survivor区放不下而直接晋升到老年代，增加Full GC压力。如果设置得过小，Eden区会变小，导致Minor GC更加频繁。通常保持默认值即可，除非通过GC日志分析发现Survivor区确实存在空间问题。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-元空间-永久代设置"><a href="#2-2-元空间-永久代设置" class="headerlink" title="2.2 元空间&#x2F;永久代设置"></a>2.2 元空间&#x2F;永久代设置</h3><ul>
<li><strong><code>-XX:PermSize=&lt;size&gt;</code> &#x2F; <code>-XX:MaxPermSize=&lt;size&gt;</code></strong> (JDK 7及以前)<ul>
<li><strong>含义</strong>：分别设置永久代的初始大小和最大大小。</li>
<li><strong>现状</strong>：在JDK 8中已废弃，被元空间取代。</li>
</ul>
</li>
<li><strong><code>-XX:MetaspaceSize=&lt;size&gt;</code></strong> (JDK 8及以后)<ul>
<li><strong>含义</strong>：设置元空间的<strong>初始大小</strong>。这是一个<strong>触发Full GC的阈值</strong>。当元空间的使用量达到这个值时，会触发一次Full GC来卸载不再使用的类。</li>
<li><strong>最佳实践</strong>：如果应用在启动时会加载大量的类，适当调高这个值可以推迟第一次因元空间不足而引发的Full GC，从而<strong>加快启动速度</strong>。</li>
</ul>
</li>
<li><strong><code>-XX:MaxMetaspaceSize=&lt;size&gt;</code></strong> (JDK 8及以后)<ul>
<li><strong>含义</strong>：设置元空间的<strong>最大大小</strong>。默认情况下没有上限，只受限于可用本地内存。</li>
<li><strong>最佳实践</strong>：在生产环境中，<strong>强烈建议设置一个明确的最大值</strong>。</li>
<li><strong>原因</strong>：如果不设置上限，在某些极端情况下（如动态类加载、代码热更新、GCLib等库使用不当）可能导致元空间无限制地占用本地内存，最终耗尽服务器所有内存，导致系统崩溃。设置上限可以提供一层保护。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-垃圾回收器选择"><a href="#2-3-垃圾回收器选择" class="headerlink" title="2.3 垃圾回收器选择"></a>2.3 垃圾回收器选择</h3><ul>
<li><strong><code>-XX:+UseSerialGC</code></strong>：启用串行GC（Serial + Serial Old）。</li>
<li><strong><code>-XX:+UseParallelGC</code></strong>：启用并行GC（Parallel Scavenge + Parallel Old）。<strong>JDK 8默认</strong>。</li>
<li><strong><code>-XX:+UseConcMarkSweepGC</code></strong>：启用CMS GC。通常需要与<code>-XX:+UseParNewGC</code>（启用新生代并行GC）配合。</li>
<li><strong><code>-XX:+UseG1GC</code></strong>：启用G1 GC。<strong>JDK 9及以后默认</strong>。</li>
<li><strong><code>-XX:+UseZGC</code></strong>：启用ZGC（JDK 11+）。</li>
<li><strong><code>-XX:+UseShenandoahGC</code></strong>：启用Shenandoah GC（JDK 12+）。</li>
</ul>
<p>选择哪个GC取决于你的应用场景（吞吐量优先还是低延迟优先）和JDK版本。</p>
<hr>
<h3 id="2-4-GC日志相关"><a href="#2-4-GC日志相关" class="headerlink" title="2.4 GC日志相关"></a>2.4 GC日志相关</h3><p>GC日志是进行JVM调优和问题排查的<strong>最重要、最直接的依据</strong>。</p>
<ul>
<li><strong>JDK 8及以前</strong>：<ul>
<li><strong><code>-XX:+PrintGCDetails</code></strong>: 打印详细的GC日志信息。</li>
<li><strong><code>-XX:+PrintGCDateStamps</code> &#x2F; <code>-XX:+PrintGCTimeStamps</code></strong>: 在日志中打印日期或时间戳。</li>
<li><strong><code>-Xloggc:&lt;file_path&gt;</code></strong>: 将GC日志输出到指定文件。</li>
</ul>
</li>
<li><strong>JDK 9及以后 (统一日志框架)</strong>：<ul>
<li><strong><code>-Xlog:gc\*:&lt;file_path&gt;:time,level,tags</code></strong>: 这是新的、更强大的日志框架。</li>
<li><strong><code>-Xlog:gc\*</code></strong>: 打印所有与GC相关的日志（<code>gc*</code>表示所有<code>gc</code>标签的日志）。</li>
<li><strong>示例</strong>：<code>-Xlog:gc*:file=gc.log:time,level,tags:filecount=5,filesize=100m</code><ul>
<li>将所有GC日志输出到<code>gc.log</code>文件。</li>
<li>带上时间、级别、标签。</li>
<li>使用滚动日志，最多5个文件，每个文件100MB。</li>
</ul>
</li>
<li><strong>这是一个巨大的进步</strong>，提供了更灵活、更结构化的日志配置。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-5-OOM快照"><a href="#2-5-OOM快照" class="headerlink" title="2.5 OOM快照"></a>2.5 OOM快照</h3><p>这是排查内存泄漏问题的<strong>终极武器</strong>。</p>
<ul>
<li><strong><code>-XX:+HeapDumpOnOutOfMemoryError</code></strong><ul>
<li><strong>含义</strong>：当JVM抛出<code>OutOfMemoryError</code>时，<strong>自动生成一个堆转储快照（Heap Dump）文件</strong>。</li>
<li><strong>最佳实践</strong>：<strong>强烈建议在所有生产环境中开启此参数！</strong></li>
<li><strong>原因</strong>：OOM发生时，现场信息至关重要。如果没有这个快照文件，事后排查内存泄漏问题将变得极其困难，几乎等同于“大海捞针”。有了快照文件，就可以使用MAT、VisualVM等工具进行离线分析，精确定位到是哪些对象占用了大量内存，以及它们的引用关系。</li>
</ul>
</li>
<li><strong><code>-XX:HeapDumpPath=&lt;path&gt;</code></strong><ul>
<li><strong>含义</strong>：指定堆转储快照文件的<strong>存储路径</strong>。</li>
<li><strong>示例</strong>：<code>-XX:HeapDumpPath=/data/dumps/</code></li>
<li><strong>最佳实践</strong>：建议将其指定到一个<strong>磁盘空间足够大</strong>的目录，因为堆转储文件的大小通常与JVM的最大堆大小（<code>-Xmx</code>）相当。</li>
</ul>
</li>
</ul>
<p><strong>综合示例（一个典型的生产环境启动脚本参数）：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java -server \</span><br><span class="line">     -Xms4g -Xmx4g \</span><br><span class="line">     -XX:MaxMetaspaceSize=512m \</span><br><span class="line">     -XX:+UseG1GC \</span><br><span class="line">     -XX:MaxGCPauseMillis=200 \</span><br><span class="line">     -XX:+HeapDumpOnOutOfMemoryError \</span><br><span class="line">     -XX:HeapDumpPath=/path/to/dumps/ \</span><br><span class="line">     -Xlog:gc*:file=/path/to/logs/gc.log:<span class="keyword">time</span>,level,tags:filecount=10,filesize=100m \</span><br><span class="line">     -jar my-application.jar</span><br></pre></td></tr></table></figure>

<p>这个配置体现了：</p>
<ol>
<li>堆大小固定，避免扩容。</li>
<li>为元空间设置上限，防止内存耗尽。</li>
<li>选择G1作为垃圾回收器，并设定了期望的停顿时间目标。</li>
<li>开启了OOM自动Dump和详细的GC滚动日志，为问题排查做好了充分准备。</li>
</ol>
<hr>
<h2 id="3-典型调优案例分析-Case-Study"><a href="#3-典型调优案例分析-Case-Study" class="headerlink" title="3. 典型调优案例分析 (Case Study)"></a>3. 典型调优案例分析 (Case Study)</h2><h3 id="3-1-OutOfMemoryError-OOM-问题排查"><a href="#3-1-OutOfMemoryError-OOM-问题排查" class="headerlink" title="3.1 OutOfMemoryError (OOM) 问题排查"></a>3.1 OutOfMemoryError (OOM) 问题排查</h3><p>在排查任何OOM问题之前，请确保你的JVM启动参数中已经包含了这两个“救命”参数：</p>
<ul>
<li><strong><code>-XX:+HeapDumpOnOutOfMemoryError</code></strong></li>
<li><strong><code>-XX:HeapDumpPath=/path/to/dump/</code></strong></li>
</ul>
<p>这将保证在OOM发生时，能留下最宝贵的现场证据——堆转储快照（Heap Dump）。</p>
<h4 id="3-1-1-java-lang-OutOfMemoryError-Java-heap-space-堆溢出"><a href="#3-1-1-java-lang-OutOfMemoryError-Java-heap-space-堆溢出" class="headerlink" title="3.1.1 java.lang.OutOfMemoryError: Java heap space (堆溢出)"></a>3.1.1 <code>java.lang.OutOfMemoryError: Java heap space</code> (堆溢出)</h4><ul>
<li><strong>错误原因</strong>：<br>这是<strong>最常见</strong>的OOM类型。它意味着<strong>Java堆内存</strong>耗尽，无法为新创建的对象分配空间，并且在执行了GC之后仍然无法回收出足够的空间。</li>
<li><strong>可能场景</strong>：<ol>
<li><strong>内存泄漏 (Memory Leak)</strong>：这是最主要的原因。程序中存在一些生命周期过长的对象（通常被静态集合、缓存、或未关闭的资源所持有），它们已经不再被使用，但GC无法回收它们，导致堆内存被逐渐占满。</li>
<li><strong>堆空间设置过小</strong>：为JVM分配的堆内存（<code>-Xmx</code>）确实不足以支撑应用的正常运行，尤其是在高并发或处理大数据量时。</li>
<li><strong>创建了巨型对象</strong>：代码中一次性创建了一个非常巨大的对象（如一个超大数组或List），直接占满了堆空间。</li>
</ol>
</li>
<li><strong>排查思路</strong>：<ol>
<li><strong>获取Heap Dump文件</strong>：这是解决问题的第一步。在OOM发生时，JVM会自动生成一个<code>.hprof</code>文件。</li>
<li><strong>使用内存分析工具分析Dump文件</strong>：<ul>
<li><strong>工具</strong>：<strong>MAT (Eclipse Memory Analyzer Tool)</strong> 是首选，功能强大。VisualVM、JProfiler等也支持。</li>
<li><strong>分析重点</strong>：<ul>
<li><strong>支配树（Dominator Tree）</strong>：这是最关键的视图。它可以清晰地展示出哪些对象占用了最多的内存（Shallow Heap vs. Retained Heap），以及是谁（支配者）阻止了这些大对象被回收。</li>
<li><strong>查找内存泄漏（Leak Suspects Report）</strong>：MAT可以自动分析并给出可能的泄漏点报告，通常非常准确。</li>
<li><strong>直方图（Histogram）</strong>：查看堆中哪种类型的对象实例最多、占用的内存最大，从而快速定位到问题代码。</li>
</ul>
</li>
</ul>
</li>
<li><strong>定位到代码</strong>：通过分析工具找到占用内存最多的对象后，查看它的<strong>GC Roots引用链</strong>。顺着引用链往上追溯，就能找到是哪个静态变量、哪个线程、或哪个缓存持有了这个对象的引用，从而定位到导致内存泄漏的具体代码。</li>
<li><strong>修复代码或调整参数</strong>：<ul>
<li>如果是内存泄漏，修复代码逻辑（如及时从集合中<code>remove</code>不再使用的对象，正确关闭资源等）。</li>
<li>如果确实是堆空间不足，则在确认没有内存泄漏的前提下，适当调大<code>-Xmx</code>的值。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h4 id="3-1-2-java-lang-OutOfMemoryError-Metaspace-元空间溢出"><a href="#3-1-2-java-lang-OutOfMemoryError-Metaspace-元空间溢出" class="headerlink" title="3.1.2 java.lang.OutOfMemoryError: Metaspace (元空间溢出)"></a>3.1.2 <code>java.lang.OutOfMemoryError: Metaspace</code> (元空间溢出)</h4><ul>
<li><strong>错误原因</strong>：<br>这个错误意味着用于存储<strong>类元数据</strong>的<strong>元空间（Metaspace）</strong>（在JDK 8之前是永久代PermGen）耗尽了。</li>
<li><strong>可能场景</strong>：<ol>
<li><strong>动态类加载过多</strong>：应用中大量使用反射、CGLib&#x2F;Javassist等字节码生成技术、动态代理、Groovy&#x2F;Jython等动态语言。每次动态生成一个新的类，都会在元空间中存储其元数据。</li>
<li><strong>加载的类过多</strong>：应用本身或其依赖的库非常庞大，加载了海量的类。</li>
<li><strong><code>MaxMetaspaceSize</code>设置过小</strong>：为元空间设置的最大值不足以支撑应用的类加载需求。</li>
<li><strong>字符串常量池过大（仅限JDK 6及以前）</strong>：在JDK 6及以前，字符串常量池位于永久代，大量调用<code>String.intern()</code>可能导致<code>PermGen space</code> OOM。JDK 7+已将其移至堆内。</li>
</ol>
</li>
<li><strong>排查思路</strong>：<ol>
<li><strong>检查启动参数</strong>：首先确认<code>-XX:MaxMetaspaceSize</code>是否设置得过小。</li>
<li><strong>生成Heap Dump</strong>：虽然元空间不属于堆，但元空间OOM时，<code>HeapDumpOnOutOfMemoryError</code><strong>同样会触发堆转储</strong>。</li>
<li><strong>分析Dump文件</strong>：<ul>
<li>使用MAT等工具，重点查看**类加载器（ClassLoader）**相关的信息。</li>
<li>检查是否存在大量的、由<strong>自定义类加载器</strong>或**动态代理框架（如CGLib）**生成的类实例。MAT的<code>Class Loader Explorer</code>视图非常有用。</li>
<li>如果发现有成千上万个名字相似（如<code>com.example.MyClass$$EnhancerByCGLIB$$...</code>）的类，那么问题很可能出在动态类的生成上。</li>
</ul>
</li>
<li><strong>定位代码</strong>：找到是哪部分代码在无限制地生成动态类。可能是缓存实现不当（例如，每次都为同一个配置生成一个新的代理类），或者使用了某些库的bug版本。</li>
<li><strong>修复代码或调整参数</strong>：<ul>
<li>优化动态类的生成逻辑，实现类的复用。</li>
<li>如果确认是正常业务需要加载大量类，则适当调大<code>-XX:MaxMetaspaceSize</code>的值。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h4 id="3-1-3-java-lang-OutOfMemoryError-GC-overhead-limit-exceeded-GC开销超限"><a href="#3-1-3-java-lang-OutOfMemoryError-GC-overhead-limit-exceeded-GC开销超限" class="headerlink" title="3.1.3 java.lang.OutOfMemoryError: GC overhead limit exceeded (GC开销超限)"></a>3.1.3 <code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code> (GC开销超限)</h4><ul>
<li><p><strong>错误原因</strong>：<br>这是一个保护性错误。它表示JVM花费了<strong>过多的时间</strong>在垃圾回收上，但<strong>收效甚微</strong>。</p>
<ul>
<li><strong>HotSpot的默认策略</strong>是：如果连续多次GC后，有<strong>超过98%的CPU时间</strong>花在了GC上，并且每次回收到的内存**少于2%**的堆内存，就会抛出这个错误。</li>
<li>这个机制是为了防止应用在GC中“假死”，即CPU几乎全在进行GC，但内存情况毫无改善，导致应用长时间无响应。</li>
</ul>
</li>
<li><p><strong>可能场景</strong>：</p>
<ul>
<li><strong>隐蔽的内存泄漏</strong>：这几乎是此错误的<strong>最根本原因</strong>。堆中充满了大量“半死不活”的对象（即它们是可达的，但实际上已经无用），导致GC每次都辛辛苦苦地标记它们为存活，但又回收不了多少空间。</li>
<li><strong>堆空间严重不足</strong>：堆太小，无法容纳应用所需的对象，导致GC刚回收一点空间，马上又被填满，陷入频繁GC的恶性循环。</li>
</ul>
</li>
<li><p><strong>排查思路</strong>：</p>
<ul>
<li><strong>与<code>Java heap space</code> OOM的排查思路基本一致</strong>。因为这个错误本质上是<code>Java heap space</code> OOM发生前的“最后警告”。</li>
</ul>
<ol>
<li><strong>获取并分析Heap Dump文件</strong>：立即分析堆转储快照，查找内存泄漏。支配树、GC Roots引用链是你的主要工具。</li>
<li><strong>检查GC日志</strong>：查看GC日志，你会发现<code>Full GC</code>的频率非常高，且每次回收的效果很差。</li>
<li><strong>定位并修复内存泄漏</strong>：找到持有大量无用对象的根本原因并修复代码。</li>
<li><strong>调整堆大小</strong>：在没有内存泄漏的前提下，如果确实是业务需要，可以考虑增大堆内存。</li>
<li><strong>关闭该机制（不推荐）</strong>：可以通过添加<code>-XX:-UseGCOverheadLimit</code>来禁用这个检查，但这只是掩盖了问题，治标不治本，最终应用还是会因为<code>Java heap space</code> OOM而崩溃。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="3-1-4-java-lang-OutOfMemoryError-Unable-to-create-new-native-thread-无法创建新线程"><a href="#3-1-4-java-lang-OutOfMemoryError-Unable-to-create-new-native-thread-无法创建新线程" class="headerlink" title="3.1.4 java.lang.OutOfMemoryError: Unable to create new native thread (无法创建新线程)"></a>3.1.4 <code>java.lang.OutOfMemoryError: Unable to create new native thread</code> (无法创建新线程)</h4><ul>
<li><strong>错误原因</strong>：<br>这个错误与堆内存或元空间<strong>无关</strong>。它表示JVM向操作系统申请创建**一个新的本地线程（Native Thread）**时失败了。</li>
<li><strong>可能场景</strong>：<ol>
<li><strong>应用创建了过多的线程</strong>：程序中无限制地创建线程（例如，在线程池使用不当、或每次请求都创建一个新线程的场景下），超出了操作系统的限制。</li>
<li><strong>操作系统限制</strong>：<ul>
<li><strong>进程的最大线程数限制</strong>：操作系统对单个进程可以创建的线程数有上限（如Linux下的<code>/proc/sys/kernel/threads-max</code>和<code>ulimit -u</code>）。</li>
<li><strong>进程的可用内存限制</strong>：每个线程都需要消耗一定的栈空间（由<code>-Xss</code>设置，默认为1MB左右）以及一些本地内存。即使总内存充足，如果进程的虚拟地址空间被耗尽，也无法创建新线程。</li>
</ul>
</li>
<li><strong>JVM栈大小设置过大 (<code>-Xss</code>)</strong>：如果每个线程的栈大小设置得过大，那么在固定的总内存下，能够创建的线程总数就会减少。</li>
</ol>
</li>
<li><strong>排查思路</strong>：<ol>
<li><strong>检查线程总数</strong>：<ul>
<li>在问题发生时，立即使用<code>jstack &lt;pid&gt;</code>命令打印线程快照，并用<code>wc -l</code>统计线程总数。如果线程数异常地高（几千甚至上万），那么问题很可能出在线程创建上。</li>
<li>或者使用<code>ps -eLf | grep java | wc -l</code>来查看Java进程的总线程数。</li>
</ul>
</li>
<li><strong>分析线程快照 (<code>jstack</code>输出)</strong>：<ul>
<li>查看<code>jstack</code>的输出，观察大量的线程都处于什么状态（<code>RUNNABLE</code>, <code>TIMED_WAITING</code>, <code>BLOCKED</code>等），以及它们的堆栈信息。</li>
<li>如果发现大量线程都在执行相同的代码，或者都阻塞在某个资源上，就能定位到是哪部分代码在疯狂创建线程。</li>
</ul>
</li>
<li><strong>检查操作系统限制</strong>：<ul>
<li>使用<code>ulimit -a</code>查看当前用户的进程和线程数限制。如果限制过低，可以考虑调高它。</li>
</ul>
</li>
<li><strong>检查<code>-Xss</code>参数</strong>：<ul>
<li>查看JVM启动参数，<code>-Xss</code>是否被设置得过大。在不需要很大栈空间的情况下，可以适当减小它（例如<code>-Xss256k</code>），从而在相同内存下创建更多线程。</li>
</ul>
</li>
<li><strong>修复代码</strong>：<ul>
<li>最根本的解决方法是审查代码，<strong>使用线程池来管理线程</strong>，避免无限制地创建线程。确保线程池的大小是合理的，并且有界。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="3-2-CPU-100-问题排查"><a href="#3-2-CPU-100-问题排查" class="headerlink" title="3.2 CPU 100% 问题排查"></a>3.2 <strong>CPU 100%</strong> 问题排查</h3><p>当监控系统告警，显示某台服务器上你的Java应用的CPU使用率飙升至100%（或接近100%）时，通常意味着程序中出现了严重的问题，如死循环、无阻塞的资源等待、或者极其密集的计算。如果不及时处理，可能导致服务完全不可用。</p>
<p><strong>排查目标</strong>：快速、精确地定位到是<strong>哪个线程</strong>的<strong>哪段代码</strong>导致了CPU飙高。</p>
<p><strong>核心工具</strong>：</p>
<ul>
<li><code>top</code> (或 <code>htop</code>)：Linux系统命令，用于实时查看系统进程和线程的资源占用情况。</li>
<li><code>jps</code>：JDK自带命令，用于查看Java进程ID。</li>
<li><code>jstack</code>：JDK自带命令，用于生成Java进程的线程快照（Thread Dump）。</li>
</ul>
<h4 id="3-2-1-排查步骤"><a href="#3-2-1-排查步骤" class="headerlink" title="3.2.1 排查步骤"></a>3.2.1 排查步骤</h4><h5 id="步骤一：找到最耗CPU的Java进程"><a href="#步骤一：找到最耗CPU的Java进程" class="headerlink" title="步骤一：找到最耗CPU的Java进程"></a>步骤一：找到最耗CPU的Java进程</h5><ol>
<li><p>登录到问题服务器。</p>
</li>
<li><p>执行<code>top</code>命令，然后按<code>Shift + P</code>，让进程按CPU使用率降序排列。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>

<p>你会看到类似下面的输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">12345 admin     20   0   12.3g   4.1g  19780 S  99.8 25.5   12:34.56 java</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>记下这个最耗CPU的Java进程的PID</strong>，在这个例子中是 <code>12345</code>。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="步骤二：找到该进程内最耗CPU的线程"><a href="#步骤二：找到该进程内最耗CPU的线程" class="headerlink" title="步骤二：找到该进程内最耗CPU的线程"></a>步骤二：找到该进程内最耗CPU的线程</h5><ol>
<li><p>继续使用<code>top</code>命令，但这次我们加上<code>-H</code>参数来查看该进程下的所有线程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -H -p 12345</span><br></pre></td></tr></table></figure>

<p>同样，按<code>Shift + P</code>进行CPU排序。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">12350 admin     20   0   12.3g   4.1g  19780 R  85.0 25.5    8:10.21 java</span><br><span class="line">12366 admin     20   0   12.3g   4.1g  19780 S  10.0 25.5    2:05.33 java</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>记下这个最耗CPU的线程的PID</strong>，在这个例子中是 <code>12350</code>。</li>
<li>这个PID是操作系统层面的线程ID（也称为 LWP, Light Weight Process ID）。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="步骤三：将线程ID转换为十六进制"><a href="#步骤三：将线程ID转换为十六进制" class="headerlink" title="步骤三：将线程ID转换为十六进制"></a>步骤三：将线程ID转换为十六进制</h5><p>Java的<code>jstack</code>工具打印的线程ID（<code>nid</code>）是十六进制格式的，所以我们需要将上一步得到的十进制线程ID进行转换。</p>
<ol>
<li><p>使用<code>printf</code>命令进行转换：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%x\n&quot;</span> 12350</span><br></pre></td></tr></table></figure>

<p>假设输出是 <code>303e</code>。</p>
<ul>
<li><strong>记下这个十六进制的线程ID</strong>：<code>303e</code>。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="步骤四：使用jstack生成线程快照并定位问题线程"><a href="#步骤四：使用jstack生成线程快照并定位问题线程" class="headerlink" title="步骤四：使用jstack生成线程快照并定位问题线程"></a>步骤四：使用<code>jstack</code>生成线程快照并定位问题线程</h5><p>有了Java进程的PID（<code>12345</code>）和问题线程的十六进制ID（<code>303e</code>），可以使用<code>jstack</code>来揭开谜底了。</p>
<ol>
<li><p>执行<code>jstack</code>命令，并将输出重定向到一个文件中，以便后续分析。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 12345 &gt; jstack.dump</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开<code>jstack.dump</code>文件，搜索我们刚才得到的十六进制线程ID <code>303e</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -A 20 <span class="string">&quot;303e&quot;</span> jstack.dump</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-A 20</code> 参数表示显示匹配行及其后的20行，这通常足够看到完整的线程堆栈。</li>
</ul>
<p>你将会看到类似下面的输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;Thread-1&quot; #12 prio=5 os_prio=0 tid=0x00007f1c8c0f5800 nid=0x303e runnable [0x00007f1c6d7fa000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at com.example.myproject.MyProblematicClass.calculate(MyProblematicClass.java:42)</span><br><span class="line">        at com.example.myproject.MyService.runLoop(MyService.java:101)</span><br><span class="line">        at com.example.myproject.MyService$$FastClassByCGLIB$$...</span><br><span class="line">        ... (more stack trace)</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="步骤五：分析线程快照，定位问题代码"><a href="#步骤五：分析线程快照，定位问题代码" class="headerlink" title="步骤五：分析线程快照，定位问题代码"></a>步骤五：分析线程快照，定位问题代码</h5><p>分析<code>jstack</code>的输出：</p>
<ol>
<li><strong>线程名称 (Thread Name)</strong>：<code>&quot;Thread-1&quot;</code>。</li>
<li><strong>线程状态 (Thread State)</strong>：<code>java.lang.Thread.State: RUNNABLE</code>。<ul>
<li><code>RUNNABLE</code>状态表示这个线程要么正在CPU上执行，要么在就绪队列中等待CPU调度。对于CPU 100%的场景，问题线程几乎总是处于<code>RUNNABLE</code>状态。</li>
</ul>
</li>
<li><strong>线程ID (nid)</strong>：<code>nid=0x303e</code>。这确认了我们找对了线程。</li>
<li><strong>堆栈信息 (Stack Trace)</strong>：这是<strong>最关键</strong>的信息。堆栈从上到下显示了方法的调用链。<ul>
<li><strong><code>at com.example.myproject.MyProblematicClass.calculate(MyProblematicClass.java:42)</code></strong></li>
<li>这行代码精确地告诉我们，CPU正在<code>MyProblematicClass</code>类的<code>calculate</code>方法的第42行疯狂执行。</li>
</ul>
</li>
</ol>
<p><strong>接下来做什么？</strong></p>
<ul>
<li><strong>审查代码</strong>：立即去查看<code>MyProblematicClass.java</code>的第42行代码。<ul>
<li><strong>常见问题</strong>：<ul>
<li><strong><code>while(true)</code> 死循环</strong>：循环体内部没有<code>break</code>、<code>return</code>或<code>sleep/wait</code>等阻塞操作。</li>
<li><strong>无界集合的遍历</strong>：在一个非常大的、甚至还在增长的集合上进行循环，而没有终止条件。</li>
<li><strong>复杂的正则表达式匹配</strong>：一个写得不好的正则表达式在处理某些特定输入时，可能会发生“灾难性回溯”，消耗大量CPU。</li>
<li><strong>密集的数学计算</strong>：如复杂的加密、图形渲染、或者不合理的递归等。</li>
</ul>
</li>
</ul>
</li>
<li><strong>多次快照对比</strong>：如果一次<code>jstack</code>不能完全确定问题，可以<strong>间隔几秒钟，连续执行3-5次<code>jstack</code></strong>，并比较多次快照中这个高耗CPU线程的堆栈。如果它始终停留在同一行代码附近，那么问题就几乎可以100%确定。</li>
</ul>
<hr>
<h4 id="3-2-2-自动化脚本"><a href="#3-2-2-自动化脚本" class="headerlink" title="3.2.2 自动化脚本"></a>3.2.2 自动化脚本</h4><p>为了提高效率，可以将上述步骤封装成一个脚本，一键定位问题。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本：find-busy-java-thread.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$0</span> &lt;PID&gt;&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">PID=<span class="variable">$1</span></span><br><span class="line"><span class="comment"># 将PID转换为16进制</span></span><br><span class="line">PID_HEX=$(<span class="built_in">printf</span> <span class="string">&quot;%x\n&quot;</span> <span class="variable">$PID</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Finding busiest thread in Java process <span class="variable">$PID</span>...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用top命令找到最耗CPU的线程ID (LWP)</span></span><br><span class="line">TOP_THREAD_ID=$(top -b -H -p <span class="variable">$PID</span> -n 1 | grep <span class="variable">$PID_HEX</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$TOP_THREAD_ID</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Could not find any thread for PID <span class="variable">$PID</span>. Is the process running?&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将线程ID转换为16进制</span></span><br><span class="line">THREAD_ID_HEX=$(<span class="built_in">printf</span> <span class="string">&quot;%x\n&quot;</span> <span class="variable">$TOP_THREAD_ID</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Busiest thread ID (LWP): <span class="variable">$TOP_THREAD_ID</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Busiest thread ID (Hex): 0x<span class="variable">$THREAD_ID_HEX</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;--------------------------------------------------&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Generating jstack dump and searching for the thread...&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;--------------------------------------------------&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用jstack查找对应的线程堆栈</span></span><br><span class="line">jstack <span class="variable">$PID</span> | grep -A 20 <span class="string">&quot;nid=0x<span class="variable">$THREAD_ID_HEX</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>使用方法</strong>：</p>
<ol>
<li>保存脚本为<code>find-busy-java-thread.sh</code>并给予执行权限 <code>chmod +x find-busy-java-thread.sh</code>。</li>
<li>通过<code>jps</code>或<code>top</code>找到Java进程的PID。</li>
<li>执行 <code>./find-busy-java-thread.sh &lt;PID&gt;</code>。</li>
</ol>
<hr>
<h3 id="3-3-GC-频繁-STW时间过长-调优"><a href="#3-3-GC-频繁-STW时间过长-调优" class="headerlink" title="3.3 GC 频繁 &#x2F; STW时间过长 调优"></a>3.3 <strong>GC 频繁 &#x2F; STW时间过长</strong> 调优</h3><p>这类问题直接影响应用的吞吐量和延迟。频繁的GC会抢占CPU资源，而过长的STW则会导致应用“假死”。调优的目标是找到一个平衡点，让GC对应用的影响降到最低。</p>
<p><strong>核心工具</strong>：</p>
<ul>
<li><strong>GC日志</strong>：这是分析GC行为的<strong>唯一可靠依据</strong>。必须通过<code>-Xlog:gc*</code>（JDK 9+）或<code>-XX:+PrintGCDetails</code>等参数开启。</li>
<li><strong>GC日志分析工具</strong>：如 <strong>GCEasy.io</strong>, <strong>GCViewer</strong>, <strong>MAT</strong>（分析GC-related的内存问题）。</li>
<li><strong>JVM监控工具</strong>：如 <strong>VisualVM</strong>, <strong>JConsole</strong>, <strong>Prometheus + Grafana</strong>（集成Micrometer）。</li>
</ul>
<hr>
<h4 id="问题的两种主要表现及分析思路"><a href="#问题的两种主要表现及分析思路" class="headerlink" title="问题的两种主要表现及分析思路"></a><strong>问题的两种主要表现及分析思路</strong></h4><h5 id="场景一：Minor-GC-Young-GC-过于频繁"><a href="#场景一：Minor-GC-Young-GC-过于频繁" class="headerlink" title="场景一：Minor GC (Young GC) 过于频繁"></a><strong>场景一：Minor GC (Young GC) 过于频繁</strong></h5><ul>
<li><strong>现象</strong>：<ul>
<li>通过监控或GC日志发现，Minor GC的频率非常高（例如，几秒钟甚至一秒内多次）。</li>
<li>应用的整体吞吐量下降，CPU使用率可能周期性地升高。</li>
</ul>
</li>
<li><strong>根本原因</strong>：<br><strong>新生代空间不足以容纳对象的分配速率。</strong> 简单来说，就是“生产”太快，“回收”场地太小，导致垃圾车（Minor GC）不得不频繁出动。</li>
<li><strong>具体原因分析与调优策略</strong>：<ol>
<li><strong>新生代（<code>-Xmn</code>）绝对空间过小</strong>：<ul>
<li><strong>分析</strong>：查看GC日志，观察每次Minor GC后，存活对象的大小。如果Eden区很快就被填满，说明新生代整体空间可能不足。</li>
<li><strong>策略</strong>：<strong>增大新生代空间</strong>。可以通过直接增大<code>-Xmn</code>的值，或者在固定堆大小（<code>-Xms</code>&#x3D;<code>-Xmx</code>）的前提下，调整新生代与老年代的比例（<code>-XX:NewRatio</code>，默认是2，表示老年代:新生代&#x3D;2:1）。</li>
<li><strong>示例</strong>：<code>-Xmn2g</code> 或 <code>-XX:NewRatio=1</code>（让新生代和老年代各占一半）。</li>
<li><strong>效果</strong>：增大了Eden区，延长了两次Minor GC之间的时间间隔，降低了GC频率。</li>
</ul>
</li>
<li><strong>Eden区与Survivor区比例不合理（<code>-XX:SurvivorRatio</code>）</strong>：<ul>
<li><strong>分析</strong>：查看GC日志，关注**晋升（Promotion）**到老年代的对象大小。如果发现大量生命周期不长的对象在一次Minor GC后就因为Survivor区空间不足而直接晋升到老年代，说明<code>SurvivorRatio</code>可能设置不当。</li>
<li><strong>原因</strong>：<code>SurvivorRatio</code>过大（默认8），导致Survivor区过小。存活对象在Eden区经历一次GC后，本应进入Survivor区，但Survivor区放不下，只能“被迫”晋升。</li>
<li><strong>策略</strong>：<strong>适当减小<code>SurvivorRatio</code>的值</strong>，以增大Survivor区的空间。</li>
<li><strong>示例</strong>：<code>-XX:SurvivorRatio=4</code> (Eden:S0:S1 &#x3D; 4:1:1)。</li>
<li><strong>效果</strong>：让更多“年轻”对象能在新生代多经历几次GC，而不是过早地污染老年代，从而降低Full GC的频率。</li>
</ul>
</li>
<li><strong>代码中存在瞬时大量对象创建</strong>：<ul>
<li><strong>分析</strong>：即使堆空间设置合理，如果代码中存在某个方法或逻辑，在短时间内创建了海量对象（例如，在一个循环中不停<code>new</code>对象，或者一次性从数据库查询出大量数据并创建实体），也会瞬间填满Eden区，触发频繁GC。</li>
<li><strong>策略</strong>：<strong>优化代码逻辑</strong>。这是最根本的解决方法。<ul>
<li>使用<strong>对象池技术</strong>复用对象。</li>
<li>在循环中，避免重复创建相同的对象。</li>
<li>采用<strong>流式处理</strong>或<strong>分页查询</strong>来避免一次性加载过多数据。</li>
<li>检查是否有不合理的数据结构使用，如在循环中对<code>String</code>进行拼接（应用<code>StringBuilder</code>）。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h5 id="场景二：Full-GC-过于频繁或-STW-时间过长"><a href="#场景二：Full-GC-过于频繁或-STW-时间过长" class="headerlink" title="场景二：Full GC 过于频繁或 STW 时间过长"></a><strong>场景二：Full GC 过于频繁或 STW 时间过长</strong></h5><ul>
<li><strong>现象</strong>：<ul>
<li>监控显示应用出现较长时间的卡顿（几百毫秒到数秒），对应GC日志中的<code>Full GC</code>或长STW记录。</li>
<li><code>GC overhead limit exceeded</code> OOM的前兆。</li>
<li>应用的响应时间（latency）飙升。</li>
</ul>
</li>
<li><strong>根本原因</strong>：<br><strong>老年代空间出现问题</strong>，或者<strong>当前的GC策略不适合应用场景</strong>。</li>
<li><strong>具体原因分析与调优策略</strong>：<ol>
<li><strong>老年代空间不足&#x2F;内存泄漏</strong>：<ul>
<li><strong>分析</strong>：这是最常见的原因。由于新生代晋升的对象过多，或存在内存泄漏，导致老年代空间持续增长并最终被耗尽，不得不频繁触发Full GC。</li>
<li><strong>策略</strong>：<ul>
<li><strong>排查内存泄漏</strong>：使用MAT等工具分析Heap Dump，找到占用内存不释放的“元凶”。此为首要任务。</li>
<li><strong>增大老年代空间</strong>：在确认无内存泄漏的前提下，如果业务确实需要更大的内存，则增大总堆内存（<code>-Xmx</code>）。</li>
<li><strong>优化新生代配置</strong>：如前所述，通过调整新生代大小和<code>SurvivorRatio</code>，让对象尽可能在新生代被回收，减少进入老年代的对象数量。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>Metaspace</code>（元空间）或 <code>PermGen</code>（永久代）不足</strong>：<ul>
<li><strong>分析</strong>：如果Full GC日志中显示是由于元空间不足而触发的，那么问题出在类加载上。</li>
<li><strong>策略</strong>：<strong>增大元空间大小</strong>（<code>-XX:MaxMetaspaceSize</code>），并排查是否存在动态类加载导致的内存泄漏。</li>
</ul>
</li>
<li><strong>显式调用<code>System.gc()</code></strong>：<ul>
<li><strong>分析</strong>：代码中（或依赖的第三方库中）不恰当地调用了<code>System.gc()</code>，这会建议JVM执行一次Full GC，带来不必要的长STW。</li>
<li><strong>策略</strong>：<ul>
<li>审查代码，移除<code>System.gc()</code>调用。</li>
<li>使用JVM参数**<code>-XX:+DisableExplicitGC</code>**来禁止显式的GC调用，一劳永逸。</li>
</ul>
</li>
</ul>
</li>
<li><strong>垃圾回收器选择不当导致STW过长</strong>：<ul>
<li><strong>分析</strong>：你的应用可能对延迟敏感，但却使用了吞吐量优先的<strong>Parallel GC</strong>。Parallel GC在执行Full GC时，STW时间可能会很长，尤其是在大堆内存下。</li>
<li><strong>策略</strong>：<strong>更换为低延迟的垃圾回收器</strong>。<ul>
<li><strong>G1 GC (<code>-XX:+UseG1GC</code>)</strong>：这是目前最主流的选择，它通过Region化管理和可预测的停顿模型，能很好地平衡吞吐量和延迟。你可以通过<code>-XX:MaxGCPauseMillis=&lt;N&gt;</code>来设定一个期望的最大停顿时间（例如200ms），G1会尽力去满足。</li>
<li><strong>CMS GC (<code>-XX:+UseConcMarkSweepGC</code>)</strong>：G1出现之前的主流低延迟选择，但有内存碎片等问题，在现代JVM中已不推荐。</li>
<li><strong>ZGC (<code>-XX:+UseZGC</code>) &#x2F; Shenandoah (<code>-XX:+UseShenandoahGC</code>)</strong>：如果你的应用对延迟要求极高（希望STW在毫秒级），并且服务器硬件和JDK版本支持，可以考虑使用这两款超低延迟GC。它们能将STW时间控制在极低的水平，且不随堆大小增长而增长。</li>
</ul>
</li>
</ul>
</li>
<li><strong>针对特定GC的参数调优（以G1为例）</strong>：<ul>
<li><strong><code>-XX:MaxGCPauseMillis=&lt;N&gt;</code></strong>: 设定目标最大停顿时间。这是G1调优的<strong>核心参数</strong>。如果设置得过低，G1为了达成目标可能会更频繁地进行小范围GC，影响吞吐量。</li>
<li><strong><code>-XX:G1HeapRegionSize=&lt;N&gt;</code></strong>: 设置Region的大小（1MB到32MB，必须是2的幂）。Region太小可能导致大对象直接进入老年代，Region太大则可能影响GC的灵活性。通常让JVM自动选择即可。</li>
<li><strong><code>-XX:InitiatingHeapOccupancyPercent=&lt;N&gt;</code></strong>: 默认45。当老年代占用率达到这个百分比时，G1会触发一次并发标记周期。如果Full GC频繁，可以适当调低此值，让GC更早地启动。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<p><strong>调优总结流程</strong>：</p>
<ol>
<li><strong>开启GC日志和监控</strong>：没有数据，一切免谈。</li>
<li><strong>分析日志，识别问题类型</strong>：是Minor GC频繁，还是Full GC频繁&#x2F;STW过长？</li>
<li><strong>对症下药，提出假设</strong>：根据问题类型，猜测可能的原因（如新生代太小、存在内存泄漏、GC策略不当等）。</li>
<li><strong>调整参数或代码，进行验证</strong>：一次只调整一个参数，进行A&#x2F;B测试，观察调整后的GC日志和应用性能指标，验证你的假设是否正确。</li>
<li><strong>循环迭代</strong>：重复步骤2-4，直到达到预期的性能目标。</li>
</ol>
<hr>
<h3 id="3-4-Web应用低延迟场景下的GC调优-如G1-ZGC"><a href="#3-4-Web应用低延迟场景下的GC调优-如G1-ZGC" class="headerlink" title="3.4 Web应用低延迟场景下的GC调优 (如G1&#x2F;ZGC)"></a>3.4 Web应用低延迟场景下的GC调优 (如G1&#x2F;ZGC)</h3><p><strong>场景特点</strong>：</p>
<ul>
<li><strong>高并发</strong>：大量的用户请求同时涌入。</li>
<li><strong>低延迟要求</strong>：API响应时间通常要求在几十到几百毫秒内。任何超过100ms的GC停顿都可能被用户感知到，并影响体验。</li>
<li><strong>对象生命周期分明</strong>：大量的请求作用域对象（Request-Scoped Objects）是“朝生夕死”的，而一些缓存、会话对象则会长期存活。这非常符合分代收集的假设。</li>
<li><strong>内存使用波动</strong>：在业务高峰期和低谷期，内存使用量可能会有较大差异。</li>
</ul>
<p><strong>调优目标</strong>：<br><strong>首要目标是控制并降低GC的最大停顿时间（Max Pause Time）和停顿频率</strong>，在此前提下，再尽可能地提高吞吐量。</p>
<hr>
<h4 id="垃圾回收器的选择"><a href="#垃圾回收器的选择" class="headerlink" title="垃圾回收器的选择"></a><strong>垃圾回收器的选择</strong></h4><p>对于低延迟场景，传统的<strong>Parallel GC</strong>通常不是一个好的选择，因为它在Full GC时会产生较长的STW。我们的选择应该集中在现代的并发GC上。</p>
<ol>
<li><strong>G1 (Garbage-First) GC</strong>:<ul>
<li><strong>适用性</strong>：<strong>当前最主流、最通用、最平衡</strong>的低延迟选择。适用于绝大多数现代Web应用，尤其是堆内存在4GB到几百GB的场景。</li>
<li><strong>核心优势</strong>：引入<strong>可预测的停顿时间模型</strong>，允许开发者设定一个期望的最大停顿时间。</li>
</ul>
</li>
<li><strong>ZGC (Z Garbage Collector)</strong> &#x2F; <strong>Shenandoah GC</strong>:<ul>
<li><strong>适用性</strong>：对延迟要求<strong>极其苛刻</strong>的场景，目标是实现亚毫秒级（sub-millisecond）的STW。适用于需要超大堆内存（几十GB到TB级别）且对停顿极度敏感的应用（如高频交易、实时广告竞价）。</li>
<li><strong>核心优势</strong>：STW时间不随堆大小的增长而增长，提供了近乎“无停顿”的体验。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="使用G1进行低延迟调优"><a href="#使用G1进行低延迟调优" class="headerlink" title="使用G1进行低延迟调优"></a><strong>使用G1进行低延迟调优</strong></h4><p>G1的设计理念就是为了取代CMS，并成为低延迟场景下的主力。它的调优相对“智能”，很多时候我们只需要设定好目标，G1就会尽力去达成。</p>
<p><strong>核心调优参数与策略</strong>：</p>
<ol>
<li><strong>开启G1并设定停顿时间目标（最关键）</strong>：<ul>
<li><strong><code>-XX:+UseG1GC</code></strong>: 启用G1。</li>
<li><strong><code>-XX:MaxGCPauseMillis=&lt;N&gt;</code></strong>: 设定期望的最大STW停顿时间（单位：毫秒）。这是一个<strong>软目标</strong>，G1会尽力去满足，但不能100%保证。<ul>
<li><strong>设置建议</strong>：对于Web应用，一个常见的初始值是**<code>200</code>** (ms)。</li>
<li><strong>权衡</strong>：这个值设置得<strong>越低</strong>，G1为了达成目标可能会选择更小的回收集合（Collection Set），导致GC<strong>更频繁</strong>，从而牺牲一部分<strong>吞吐量</strong>。如果设置得<strong>太高</strong>，则可能达不到低延迟的要求。你需要根据业务的SLA来设定这个值。</li>
</ul>
</li>
</ul>
</li>
<li><strong>设置合理的堆大小</strong>：<ul>
<li><strong><code>-Xms&lt;size&gt; -Xmx&lt;size&gt;</code></strong>: 在生产环境中，务必将初始堆和最大堆设置为相等，以避免运行时堆扩容带来的性能抖动。堆的大小需要根据压测和线上监控来确定，要为G1的并发标记和对象复制留出足够的“冗余”空间（通常建议堆占用率在触发GC时不要超过70-80%）。</li>
</ul>
</li>
<li><strong>调整并发标记的触发时机</strong>：<ul>
<li><strong><code>-XX:InitiatingHeapOccupancyPercent=&lt;N&gt;</code></strong> (IHOP): 当老年代占用率达到这个百分比时，G1会启动一次并发标记周期。默认值是<strong>45</strong>。</li>
<li><strong>调优场景</strong>：<ul>
<li>如果GC日志显示频繁发生<strong>Full GC</strong>或**“to-space exhausted”<strong>（空间耗尽，G1中一种严重的失败模式），这通常意味着并发标记启动得</strong>太晚了**，垃圾还没来得及清理，新的对象就没地方放了。</li>
<li><strong>策略</strong>：<strong>适当调低IHOP的值</strong>，比如<code>-XX:InitiatingHeapOccupancyPercent=35</code>，让GC周期更早地启动。</li>
<li>反之，如果堆内存使用率很低，但并发标记周期仍然频繁启动，可以适当调高此值，以减少不必要的GC活动。</li>
</ul>
</li>
</ul>
</li>
<li><strong>避免大对象直接进入老年代</strong>：<ul>
<li>G1中，一个对象如果大小超过了Region大小的一半，就会被视为**“巨型对象”（Humongous Object）**，并直接分配在老年代的连续Region中。</li>
<li><strong>问题</strong>：巨型对象的分配和回收成本都很高，容易导致GC问题。</li>
<li><strong>策略</strong>：<ul>
<li><strong>分析代码</strong>：通过GC日志（会打印<code>Humongous allocation</code>）或Heap Dump找到创建大对象的代码，从根源上<strong>避免创建不必要的巨型对象</strong>。例如，检查是否有代码一次性从缓存或数据库加载了过大的数据。</li>
<li><strong>调整Region大小（不常用）</strong>：可以通过<code>-XX:G1HeapRegionSize=&lt;N&gt;</code>（1M, 2M, 4M, …, 32M）来调整Region大小。增大Region大小可以提高巨型对象的阈值，但会降低GC的灵活性。通常让JVM自动选择即可。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>G1调优小结</strong>：</p>
<ul>
<li><strong>起点</strong>：<code>-XX:+UseG1GC -Xms=... -Xmx=... -XX:MaxGCPauseMillis=200</code></li>
<li><strong>核心</strong>：观察GC日志，如果出现Full GC或to-space exhausted，就调低<code>-XX:InitiatingHeapOccupancyPercent</code>。</li>
<li><strong>原则</strong>：尽可能让G1自行调节，只在出现明确问题时才介入。不要过度调优。</li>
</ul>
<hr>
<h4 id="使用ZGC进行超低延迟调优"><a href="#使用ZGC进行超低延迟调优" class="headerlink" title="使用ZGC进行超低延迟调优"></a><strong>使用ZGC进行超低延迟调优</strong></h4><p>当你使用G1已经无法满足延迟要求时（例如，即使设置了<code>MaxGCPauseMillis=50</code>，实际停顿仍然远超此值），就可以考虑ZGC。</p>
<p><strong>ZGC的调优非常简单，因为它被设计为“自适应”和“免调优”的。</strong></p>
<p><strong>核心调优参数与策略</strong>：</p>
<ol>
<li><strong>开启ZGC并设置堆大小（最关键）</strong>：<ul>
<li><strong><code>-XX:+UseZGC</code></strong>: 启用ZGC。</li>
<li><strong><code>-Xms&lt;size&gt; -Xmx&lt;size&gt;</code></strong>: <strong>必须设置</strong>。ZGC需要一个足够大的堆来支持其并发操作。堆越大，ZGC的性能表现通常越好，因为它有更多的空间来容纳浮动垃圾和进行并发整理。</li>
</ul>
</li>
<li><strong>设置并发GC线程数（可选）</strong>：<ul>
<li><strong><code>-XX:ConcGCThreads=&lt;N&gt;</code></strong>: 设置用于并发GC的线程数。默认情况下，ZGC会根据CPU核心数自动计算一个合理的值。</li>
<li><strong>调优场景</strong>：如果发现GC期间CPU占用率过高，影响了业务线程，可以适当调低此值。反之，如果希望GC更快完成，可以适当调高（不超过CPU核心数）。通常保持默认即可。</li>
</ul>
</li>
</ol>
<p>**ZGC几乎没有其他需要你操心的参数。*<em>像G1的<code>MaxGCPauseMillis</code>、<code>NewRatio</code>、<code>SurvivorRatio</code>等参数在ZGC中都*<em>不再需要</em></em>。ZGC会自动处理新生代&#x2F;老年代的划分（虽然它也是分代的），并始终以实现超低停顿为最高优先级。</p>
<p><strong>ZGC的使用前提</strong>：</p>
<ul>
<li><strong>JDK版本</strong>：JDK 15+ 正式生产可用。</li>
<li><strong>操作系统</strong>：需要较新的Linux内核支持。</li>
<li><strong>CPU和内存</strong>：ZGC会消耗更多的CPU资源和一定的额外内存（用于着色指针和转发表），需要确保硬件资源充足。</li>
</ul>
<hr>
<p><strong>总结：Web应用低延迟GC调优路径</strong></p>
<ol>
<li><strong>基础选择</strong>：对于绝大多数Web应用，<strong>G1是首选且足够好的选择</strong>。从一个合理的堆大小和<code>MaxGCPauseMillis=200</code>开始。</li>
<li><strong>G1调优</strong>：通过分析GC日志，主要调整<code>MaxGCPauseMillis</code>和<code>InitiatingHeapOccupancyPercent</code>来应对出现的具体问题。</li>
<li><strong>终极选择</strong>：如果你的应用是“延迟敏感型野兽”，并且G1调优已到极限，同时硬件和JDK版本满足要求，那么<strong>果断切换到ZGC</strong>。ZGC的配置极其简单，几乎只需要设置堆大小，就能享受到亚毫秒级的GC停顿。</li>
</ol>
<p>在调优过程中，始终牢记“<strong>无监控，不调优</strong>”的原则，任何参数的调整都必须基于<strong>数据</strong>和<strong>测试</strong>。</p>
<hr>
<h3 id="3-5-大数据-批处理任务吞吐量优先场景下的GC调优-如Parallel-GC"><a href="#3-5-大数据-批处理任务吞吐量优先场景下的GC调优-如Parallel-GC" class="headerlink" title="3.5 大数据&#x2F;批处理任务吞吐量优先场景下的GC调优 (如Parallel GC)"></a>3.5 大数据&#x2F;批处理任务吞吐量优先场景下的GC调优 (如Parallel GC)</h3><p><strong>场景特点</strong>：</p>
<ul>
<li><strong>计算密集型</strong>：任务的核心是大量的CPU计算和内存操作，而不是与用户进行实时交互。</li>
<li><strong>长时间运行</strong>：任务可能会持续运行几分钟、几小时甚至更长时间。</li>
<li><strong>对停顿不敏感</strong>：任务执行过程中，发生几次较长时间的STW（Stop-The-World）停顿通常是可以接受的，只要不导致任务失败即可。</li>
<li><strong>关注总执行时间</strong>：最终目标是在最短的总时间内完成整个任务，即最大化<strong>吞吐量</strong>。</li>
</ul>
<p><strong>典型应用</strong>：</p>
<ul>
<li><strong>ETL（数据抽取、转换、加载）作业</strong>。</li>
<li><strong>大规模数据分析和报表生成</strong>。</li>
<li><strong>科学计算和模拟</strong>。</li>
<li><strong>机器学习模型训练</strong>。</li>
</ul>
<p><strong>调优目标</strong>：<br><strong>首要目标是最大化吞吐量</strong>，即让CPU尽可能多地用于执行用户代码，而不是GC。这意味着要<strong>降低GC所占用的总时间比例</strong>。</p>
<hr>
<h4 id="垃圾回收器的选择-1"><a href="#垃圾回收器的选择-1" class="headerlink" title="垃圾回收器的选择"></a><strong>垃圾回收器的选择</strong></h4><p>对于吞吐量优先的场景，**Parallel GC（并行GC）**是当之无愧的最佳选择。</p>
<ul>
<li><strong>Parallel GC (Parallel Scavenge + Parallel Old)</strong><ul>
<li><strong>适用性</strong>：<strong>专为吞吐量而生</strong>。是JDK 8及以前的默认Server GC。</li>
<li><strong>核心优势</strong>：<ul>
<li><strong>GC期间并行处理</strong>：在进行Minor GC和Full GC时，它会启动多个GC线程并行工作，充分利用多核CPU的优势，极大地缩短了单次GC的墙钟时间（Wall Clock Time）。</li>
<li><strong>无并发开销</strong>：与CMS、G1等并发GC不同，Parallel GC在GC时会完全暂停用户线程（STW）。这虽然带来了较长的停顿，但也意味着GC期间<strong>不会与用户线程争抢CPU资源</strong>，可以将所有CPU核心都用于垃圾回收，从而实现最高的GC效率。</li>
</ul>
</li>
<li><strong>结论</strong>：在不考虑单次停顿时间的情况下，Parallel GC能实现最低的GC总开销，从而达到最高的吞吐量。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="使用Parallel-GC进行吞吐量调优"><a href="#使用Parallel-GC进行吞吐量调优" class="headerlink" title="使用Parallel GC进行吞吐量调优"></a><strong>使用Parallel GC进行吞吐量调优</strong></h4><p>Parallel GC的调优相对直接，因为它提供了非常明确的性能目标参数。</p>
<p><strong>核心调优参数与策略</strong>：</p>
<ol>
<li><strong>开启Parallel GC</strong>：<ul>
<li><strong><code>-XX:+UseParallelGC</code></strong>: 启用Parallel GC。在JDK 8中，如果服务器是多核的，这通常是默认开启的。此参数会自动激活新生代的Parallel Scavenge和老年代的Serial Old。</li>
<li><strong><code>-XX:+UseParallelOldGC</code></strong>: <strong>强烈建议同时开启</strong>。此参数会将老年代的收集器也升级为并行的Parallel Old。这样，无论是Minor GC还是Full GC，都能享受到并行处理带来的好处。</li>
</ul>
</li>
<li><strong>设定吞吐量目标（最关键）</strong>：<ul>
<li><strong><code>-XX:GCTimeRatio=&lt;N&gt;</code></strong>: 设置<strong>GC时间占总时间的比例</strong>。<ul>
<li><strong>计算公式</strong>：<code>GC时间占比 = 1 / (1 + N)</code>。</li>
<li><strong>默认值</strong>：<code>99</code>，意味着允许最多<code>1 / (1 + 99) = 1%</code>的时间用于GC。</li>
<li><strong>调优策略</strong>：<ul>
<li>如果你希望进一步提高吞吐量，可以<strong>增大<code>GCTimeRatio</code>的值</strong>。例如，设置为<code>199</code>，则目标GC时间占比为<code>1 / (1 + 199) = 0.5%</code>。</li>
<li>这是一个<strong>宏观目标</strong>。GC会为了达成这个目标而<strong>自动调整堆的各个区域大小</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>设定最大停顿时间目标（辅助）</strong>：<ul>
<li><strong><code>-XX:MaxGCPauseMillis=&lt;N&gt;</code></strong>: 设置一个期望的最大GC停顿时间（单位：毫秒）。</li>
<li><strong>注意</strong>：这与G1的同名参数意义不同。在Parallel GC中，这更像一个“建议”而非硬性目标。如果设置了这个参数，Parallel GC会<strong>在吞吐量目标和停顿时间目标之间进行权衡</strong>。</li>
<li><strong>调优策略</strong>：<ul>
<li>对于纯批处理任务，可以<strong>不设置此参数</strong>，让GC完全以吞吐量为导向。</li>
<li>如果任务中间偶尔需要对外提供一些状态查询，不希望停顿过长，可以设置一个相对宽松的值，如<code>500</code>或<code>1000</code>（ms）。</li>
<li><strong>警告</strong>：不要将此值设置得过低，否则GC为了满足停顿目标可能会频繁地进行小范围GC，反而会牺牲吞吐量。</li>
</ul>
</li>
</ul>
</li>
<li><strong>启用GC自适应调节策略（默认开启）</strong>：<ul>
<li><strong><code>-XX:+UseAdaptiveSizePolicy</code></strong>: 这是Parallel GC的一个核心特性。当开启时，JVM会根据你设定的<code>GCTimeRatio</code>和<code>MaxGCPauseMillis</code>目标，<strong>动态地、自动地调整</strong>新生代大小、Eden与Survivor的比例、晋升阈值等参数。</li>
<li><strong>最佳实践</strong>：<strong>保持开启</strong>。对于大多数场景，让JVM的自适应策略去工作，通常比手动去精细调整<code>-Xmn</code>、<code>-XX:SurvivorRatio</code>等参数效果更好、更省心。你只需要告诉它你的<strong>宏观目标</strong>（吞吐量和最大停顿）即可。</li>
</ul>
</li>
<li><strong>设置合理的堆大小</strong>：<ul>
<li><strong><code>-Xms&lt;size&gt; -Xmx&lt;size&gt;</code></strong>: 同样建议设置为相等，避免运行时扩容。</li>
<li><strong>对于批处理任务，堆内存通常是越大越好</strong>（在物理内存允许的范围内）。更大的堆意味着更低的GC频率，从而减少GC总开销，提升吞吐量。</li>
</ul>
</li>
</ol>
<p><strong>Parallel GC调优小结</strong>：</p>
<ul>
<li><strong>起点</strong>：<code>-XX:+UseParallelGC -XX:+UseParallelOldGC -Xms=... -Xmx=...</code></li>
<li><strong>核心</strong>：设定你的性能目标，而不是具体的内存布局。<ul>
<li><strong>吞吐量优先</strong>：调整<code>-XX:GCTimeRatio</code>。</li>
<li><strong>兼顾一点停顿</strong>：设置一个宽松的<code>-XX:MaxGCPauseMillis</code>。</li>
</ul>
</li>
<li><strong>原则</strong>：相信并利用Parallel GC的自适应调节能力，避免进行过度的微观参数调整。</li>
</ul>
<hr>
<h4 id="如果Parallel-GC仍然无法满足需求"><a href="#如果Parallel-GC仍然无法满足需求" class="headerlink" title="如果Parallel GC仍然无法满足需求"></a><strong>如果Parallel GC仍然无法满足需求</strong></h4><p>在某些极端的大数据场景下，如果堆内存非常巨大（例如超过100GB），即使是并行的Full GC，其STW时间也可能长到无法接受（例如几分钟），甚至导致任务因超时而失败。</p>
<p>在这种情况下，可以考虑<strong>G1 GC</strong>。虽然G1的首要目标是低延迟，但它在大堆上的表现非常稳定，并且通过并发处理避免了超长时间的Full GC。你可以通过以下方式让G1更偏向于吞吐量：</p>
<ul>
<li><strong>放宽停顿时间目标</strong>：将<code>-XX:MaxGCPauseMillis</code>设置一个较高的值，比如<code>500</code>ms。</li>
<li><strong>调整GC启动阈值</strong>：适当提高<code>-XX:InitiatingHeapOccupancyPercent</code>，让GC不那么频繁地启动。</li>
</ul>
<p><strong>总结</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>主要目标</th>
<th>推荐GC</th>
<th>核心调优策略</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Web应用</strong></td>
<td><strong>低延迟</strong></td>
<td><strong>G1</strong>, ZGC</td>
<td>设定<code>MaxGCPauseMillis</code>，通过<code>InitiatingHeapOccupancyPercent</code>避免Full GC。ZGC则基本免调优。</td>
</tr>
<tr>
<td><strong>大数据&#x2F;批处理</strong></td>
<td><strong>高吞TP量</strong></td>
<td><strong>Parallel GC</strong></td>
<td>设定<code>GCTimeRatio</code>，让GC自适应调节策略工作。堆内存尽可能大。在超大堆下可考虑G1作为备选。</td>
</tr>
</tbody></table>
<p>通过为不同的应用场景选择合适的GC策略并进行针对性的调优，可以最大限度地发挥JVM的性能潜力。</p>
<hr>
<h1 id="四、诊断工具与问题排查"><a href="#四、诊断工具与问题排查" class="headerlink" title="四、诊断工具与问题排查"></a>四、诊断工具与问题排查</h1><h2 id="1-JDK自带命令行工具"><a href="#1-JDK自带命令行工具" class="headerlink" title="1. JDK自带命令行工具"></a>1. JDK自带命令行工具</h2><p>这些工具通常位于JDK安装目录的<code>bin</code>文件夹下。在使用它们之前，请确保<code>JAVA_HOME/bin</code>已经添加到了系统的<code>PATH</code>环境变量中。</p>
<hr>
<h5 id="jps-JVM-Process-Status-Tool"><a href="#jps-JVM-Process-Status-Tool" class="headerlink" title="jps (JVM Process Status Tool)"></a><strong><code>jps</code> (JVM Process Status Tool)</strong></h5><ul>
<li><p><strong>核心功能</strong>：列出当前系统中所有正在运行的<strong>Java虚拟机进程</strong>。它的功能类似于Linux的<code>ps</code>命令，但专门针对Java进程。</p>
</li>
<li><p><strong>常用参数</strong>：</p>
<ul>
<li><strong><code>jps</code></strong> (无参数)：只显示Java进程的ID（LVMID, Local Virtual Machine Identifier）和主类名称（或JAR文件名）。</li>
<li><strong><code>-q</code></strong>: 只显示进程ID，不显示主类名。</li>
<li><strong><code>-l</code></strong>: 输出主类的全限定名，或者如果程序是通过JAR文件运行的，则输出JAR文件的完整路径。</li>
<li><strong><code>-v</code></strong>: 输出传递给JVM的参数（如<code>-Xms</code>, <code>-Xmx</code>等）。</li>
<li><strong><code>-m</code></strong>: 输出传递给主函数<code>main()</code>的参数。</li>
</ul>
</li>
<li><p><strong>典型用法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快速找到你的目标Java应用的进程ID</span></span><br><span class="line">$ jps -l</span><br><span class="line">12345 com.example.myproject.Application</span><br><span class="line">67890 org.apache.catalina.startup.Bootstrap</span><br></pre></td></tr></table></figure>

<p><code>jps</code>是所有其他诊断命令的<strong>起点</strong>，因为你需要先用它获取到目标进程的PID。</p>
</li>
</ul>
<hr>
<h5 id="jstat-JVM-Statistics-Monitoring-Tool"><a href="#jstat-JVM-Statistics-Monitoring-Tool" class="headerlink" title="jstat (JVM Statistics Monitoring Tool)"></a><strong><code>jstat</code> (JVM Statistics Monitoring Tool)</strong></h5><ul>
<li><p><strong>核心功能</strong>：实时监控和显示JVM的<strong>各类运行时统计信息</strong>，如类加载、内存、垃圾回收、JIT编译等。</p>
</li>
<li><p><strong>命令格式</strong>：<code>jstat -&lt;option&gt; &lt;pid&gt; &lt;interval&gt; &lt;count&gt;</code></p>
<ul>
<li><code>&lt;option&gt;</code>：要监控的统计类型。</li>
<li><code>&lt;pid&gt;</code>：Java进程ID。</li>
<li><code>&lt;interval&gt;</code>：采样间隔时间（单位：毫秒）。</li>
<li><code>&lt;count&gt;</code>：采样的次数（如果省略，则持续监控）。</li>
</ul>
</li>
<li><p><strong>常用<code>&lt;option&gt;</code></strong>：</p>
<ul>
<li><strong><code>-gc</code></strong>: <strong>最常用</strong>，显示与GC相关的堆信息。<ul>
<li><code>S0C/S1C</code>: Survivor 0&#x2F;1区的总容量。</li>
<li><code>S0U/S1U</code>: Survivor 0&#x2F;1区已使用的容量。</li>
<li><code>EC/EU</code>: Eden区的总容量&#x2F;已使用容量。</li>
<li><code>OC/OU</code>: 老年代的总容量&#x2F;已使用容量。</li>
<li><code>MC/MU</code>: 元空间的总容量&#x2F;已使用容量。</li>
<li><code>YGC/YGCT</code>: Young GC的次数&#x2F;总耗时。</li>
<li><code>FGC/FGCT</code>: Full GC的次数&#x2F;总耗时。</li>
</ul>
</li>
<li><strong><code>-gccapacity</code></strong>: 显示各代堆的容量和最大容量。</li>
<li><strong><code>-gcutil</code></strong>: 显示各代堆空间的使用百分比。</li>
<li><strong><code>-class</code></strong>: 监控类加载、卸载的数量及耗时。</li>
<li><strong><code>-compiler</code></strong>: 监控JIT编译器的编译任务数量及耗时。</li>
</ul>
</li>
<li><p><strong>典型用法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔1秒监控进程12345的GC情况，共监控10次</span></span><br><span class="line">$ jstat -gc 12345 1000 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 持续监控进程12345的GC使用率</span></span><br><span class="line">$ jstat -gcutil 12345 2000</span><br></pre></td></tr></table></figure>

<p><code>jstat</code>是观察GC行为、判断GC是否频繁、内存分配是否合理的<strong>第一手数据来源</strong>。</p>
</li>
</ul>
<hr>
<h5 id="jinfo-Configuration-Info-for-Java"><a href="#jinfo-Configuration-Info-for-Java" class="headerlink" title="jinfo (Configuration Info for Java)"></a><strong><code>jinfo</code> (Configuration Info for Java)</strong></h5><ul>
<li><p><strong>核心功能</strong>：<strong>实时查看和动态修改</strong>正在运行的JVM的各项参数。</p>
</li>
<li><p><strong>常用参数</strong>：</p>
<ul>
<li><strong><code>jinfo -flags &lt;pid&gt;</code></strong>: 查看目标JVM进程当前生效的所有参数（包括默认值和用户指定的）。</li>
<li><strong><code>jinfo -flag &lt;name&gt; &lt;pid&gt;</code></strong>: 查看指定名称的参数的值。</li>
<li><strong><code>jinfo -flag [+|-]&lt;name&gt; &lt;pid&gt;</code></strong>: <strong>动态修改</strong>一个布尔类型的参数（如开启&#x2F;关闭<code>PrintGCDetails</code>）。</li>
<li><strong><code>jinfo -flag &lt;name&gt;=&lt;value&gt; &lt;pid&gt;</code></strong>: <strong>动态修改</strong>一个键值类型的参数。</li>
</ul>
</li>
<li><p><strong>典型用法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看进程12345的所有JVM参数</span></span><br><span class="line">$ jinfo -flags 12345</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看MaxHeapSize的值</span></span><br><span class="line">$ jinfo -flag MaxHeapSize 12345</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态开启GC日志打印 (仅对可动态修改的参数有效)</span></span><br><span class="line">$ jinfo -flag +PrintGCDetails 12345</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：并非所有参数都支持动态修改。<code>jinfo</code>在排查问题时，可以快速确认当前应用的JVM配置是否符合预期。</p>
</li>
</ul>
<hr>
<h5 id="jmap-Memory-Map-for-Java"><a href="#jmap-Memory-Map-for-Java" class="headerlink" title="jmap (Memory Map for Java)"></a><strong><code>jmap</code> (Memory Map for Java)</strong></h5><ul>
<li><p><strong>核心功能</strong>：生成Java堆的**内存快照（Heap Dump）*<em>和查看堆的摘要信息。是排查内存泄漏和OOM问题的*<em>核心工具</em></em>。</p>
</li>
<li><p><strong>常用参数</strong>：</p>
<ul>
<li><strong><code>jmap -dump:format=b,file=&lt;filename&gt; &lt;pid&gt;</code></strong>: <strong>最重要</strong>的命令。生成一个二进制格式的堆转储快照文件。<ul>
<li>可以添加<code>live</code>选项（<code>-dump:live,...</code>），表示只dump堆中的存活对象，这可以减小dump文件的大小，但可能会丢失一些排查问题需要的信息。</li>
</ul>
</li>
<li><strong><code>jmap -heap &lt;pid&gt;</code></strong>: 显示堆的详细信息，如各代大小、GC策略、堆配置参数等。</li>
<li><strong><code>jmap -histo &lt;pid&gt;</code></strong>: 显示堆中对象的直方图，即按类名统计实例数量和总大小。</li>
</ul>
</li>
<li><p><strong>典型用法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为进程12345生成一个名为heap.hprof的堆快照</span></span><br><span class="line">$ jmap -dump:format=b,file=heap.hprof 12345</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程12345的堆中对象统计信息，并只看前20行</span></span><br><span class="line">$ jmap -histo 12345 | <span class="built_in">head</span> -20</span><br></pre></td></tr></table></figure>

<p><strong>警告</strong>：在生产环境中执行<code>jmap -dump</code>会导致<strong>STW</strong>，即Java进程会被挂起，直到dump完成。对于大堆内存的应用，这个过程可能会持续几十秒甚至几分钟，对线上服务影响巨大。因此，<strong>推荐的做法是使用<code>-XX:+HeapDumpOnOutOfMemoryError</code>参数让JVM在OOM时自动dump</strong>，或者在业务低峰期执行。</p>
</li>
</ul>
<hr>
<h5 id="jstack-Stack-Trace-for-Java"><a href="#jstack-Stack-Trace-for-Java" class="headerlink" title="jstack (Stack Trace for Java)"></a><strong><code>jstack</code> (Stack Trace for Java)</strong></h5><ul>
<li><p><strong>核心功能</strong>：生成指定Java进程在<strong>某一时刻的线程快照（Thread Dump）</strong>。是排查<strong>线程死锁、死循环、请求无响应、CPU飙升</strong>等问题的<strong>核心工具</strong>。</p>
</li>
<li><p><strong>常用参数</strong>：</p>
<ul>
<li><strong><code>jstack &lt;pid&gt;</code></strong>: 打印目标进程的所有线程堆栈信息。</li>
<li><strong><code>-l</code></strong>: 在堆栈信息的基础上，额外打印<strong>锁信息</strong>，如持有的锁、等待的锁等。在分析死锁问题时<strong>必不可少</strong>。</li>
<li><strong><code>-F</code></strong>: 当正常的<code>jstack</code>命令无响应时（例如进程僵死），可以强制生成线程快照。</li>
</ul>
</li>
<li><p><strong>典型用法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成进程12345的线程快照，并包含锁信息</span></span><br><span class="line">$ jstack -l 12345 &gt; thread.dump</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制生成快照</span></span><br><span class="line">$ jstack -F 12345</span><br></pre></td></tr></table></figure>

<p><code>jstack</code>的输出包含了每个线程的名称、ID、状态、以及完整的调用堆栈。通过分析这些信息，可以清晰地了解每个线程正在做什么，从而定位到问题根源。</p>
</li>
</ul>
<hr>
<h5 id="jhat-JVM-Heap-Analysis-Tool"><a href="#jhat-JVM-Heap-Analysis-Tool" class="headerlink" title="jhat (JVM Heap Analysis Tool)"></a><strong><code>jhat</code> (JVM Heap Analysis Tool)</strong></h5><ul>
<li><strong>核心功能</strong>：用于<strong>分析<code>jmap</code>生成的堆转储快照文件</strong>。</li>
<li><strong>工作方式</strong>：<code>jhat</code>会启动一个内置的HTTP服务器，你可以在浏览器中通过<code>http://localhost:7000</code>来查看分析结果。</li>
<li><strong>现状</strong>：<strong>已不常用，并且在JDK 9中已被移除</strong>。</li>
<li><strong>原因</strong>：<ol>
<li><strong>性能差，消耗资源</strong>：<code>jhat</code>在分析大内存的dump文件时，非常慢，并且会消耗大量的本地内存。</li>
<li><strong>功能简陋，体验差</strong>：其Web界面提供的分析功能远不如现代的可视化工具强大和直观。</li>
</ol>
</li>
<li><strong>替代方案</strong>：<ul>
<li><strong>MAT (Eclipse Memory Analyzer)</strong>：功能最强大、最专业的堆内存分析工具。</li>
<li><strong>VisualVM</strong>：内置了堆快照分析功能，使用方便。</li>
<li><strong>JProfiler</strong>：商业工具，功能全面。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong>：<code>jps</code>, <code>jstat</code>, <code>jmap</code>, <code>jstack</code>是Java问题排查的“四大金刚”，需要反复练习，熟练掌握。而<code>jinfo</code>作为辅助，<code>jhat</code>则已成为历史。在实际工作中，通常是<code>jps</code>定位 -&gt; <code>jstat</code>&#x2F;<code>top</code>初步观察 -&gt; <code>jstack</code>&#x2F;<code>jmap</code>深入分析的流程。</p>
<hr>
<h2 id="2-可视化诊断工具"><a href="#2-可视化诊断工具" class="headerlink" title="2. 可视化诊断工具"></a>2. 可视化诊断工具</h2><h4 id="JConsole-Java-Monitoring-and-Management-Console"><a href="#JConsole-Java-Monitoring-and-Management-Console" class="headerlink" title="JConsole (Java Monitoring and Management Console)"></a><strong><code>JConsole</code> (Java Monitoring and Management Console)</strong></h4><ul>
<li><strong>定位</strong>：JDK自带的、<strong>基础的</strong>、轻量级的图形化监控工具。</li>
<li><strong>启动方式</strong>：在命令行直接输入<code>jconsole</code>即可启动。</li>
<li><strong>核心功能</strong>：<ol>
<li><strong>概览 (Overview)</strong>：以图表形式实时展示堆内存使用、线程数、类加载数和CPU占用率的趋势。</li>
<li><strong>内存 (Memory)</strong>：详细监控堆内各区域（Eden、Survivor、Old Gen）以及非堆内存（Metaspace）的使用情况。可以手动执行GC。</li>
<li><strong>线程 (Threads)</strong>：列出所有线程，显示其状态。提供**“检测死锁”**的功能，可以一键找出死锁的线程及其相互持有的锁。</li>
<li><strong>类 (Classes)</strong>：显示已加载和已卸载的类的数量。</li>
<li><strong>VM摘要 (VM Summary)</strong>：展示JVM的详细信息，包括启动参数、版本、堆配置等。</li>
<li><strong>MBeans (Managed Beans)</strong>：提供一个JMX（Java Management Extensions）客户端，可以查看和操作JVM暴露的MBeans，从而进行更深度的监控和管理。</li>
</ol>
</li>
<li><strong>优点</strong>：<ul>
<li><strong>无需安装</strong>，JDK自带，开箱即用。</li>
<li><strong>资源消耗小</strong>，对目标应用性能影响较低。</li>
<li>对于基础的内存趋势监控和死锁检测，非常方便快捷。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>功能相对单一，不提供性能分析（Profiling）、快照分析等高级功能。</li>
<li>界面比较简陋，交互体验一般。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li>快速查看应用的实时运行状态。</li>
<li>进行简单的内存和线程监控。</li>
<li>快速诊断死锁问题。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="VisualVM-Java-VisualVM"><a href="#VisualVM-Java-VisualVM" class="headerlink" title="VisualVM (Java VisualVM)"></a><strong><code>VisualVM</code> (Java VisualVM)</strong></h4><ul>
<li><strong>定位</strong>：功能强大的<strong>多合一</strong>故障排查和性能监控工具。可以看作是<code>JConsole</code>的<strong>超集</strong>，并集成了<code>jstack</code>, <code>jmap</code>, <code>jstat</code>等多种工具的功能。</li>
<li><strong>启动方式</strong>：JDK 8及以前的版本通常自带（位于<code>bin</code>目录），JDK 9以后需要从官网（<a target="_blank" rel="noopener" href="https://visualvm.github.io/%EF%BC%89%E5%8D%95%E7%8B%AC%E4%B8%8B%E8%BD%BD%E3%80%82">https://visualvm.github.io/）单独下载。</a></li>
<li><strong>核心功能</strong>：<ol>
<li><strong>基础监控</strong>：包含JConsole的所有监控功能（CPU、内存、类、线程），但图表更精美，信息更丰富。</li>
<li><strong>线程分析</strong>：可以实时查看线程状态，并生成**线程快照（Thread Dump）**进行分析。</li>
<li><strong>堆分析</strong>：可以生成<strong>堆快照（Heap Dump）</strong>，并在工具内直接进行分析（虽然功能不如MAT强大），也可以加载离线的<code>.hprof</code>文件。</li>
<li><strong>性能分析 (Profiler)</strong>：这是VisualVM的王牌功能。<ul>
<li><strong>CPU分析器</strong>：采样或插桩分析方法的执行时间，找出CPU热点。</li>
<li><strong>内存分析器</strong>：分析对象的分配情况，找出哪些代码在创建大量对象。</li>
</ul>
</li>
<li><strong>插件扩展</strong>：支持安装各种插件，如Visual GC插件可以非常直观地动态展示GC过程和各代内存的变化。</li>
</ol>
</li>
<li><strong>优点</strong>：<ul>
<li><strong>功能全面</strong>，一个工具解决了大部分监控和诊断需求。</li>
<li><strong>性能分析功能强大</strong>，能够定位到代码级别的方法性能瓶颈。</li>
<li><strong>可视化效果好</strong>，特别是Visual GC插件，对理解GC非常有帮助。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>开启Profiling时，对目标应用的性能影响较大。</li>
<li>堆内存分析功能相比MAT稍弱。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li>日常开发和测试阶段的性能监控与分析。</li>
<li>定位CPU热点和内存分配热点。</li>
<li>集成的诊断平台，适合大多数非紧急的线上问题排查。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="MAT-Eclipse-Memory-Analyzer-Tool-重点"><a href="#MAT-Eclipse-Memory-Analyzer-Tool-重点" class="headerlink" title="MAT (Eclipse Memory Analyzer Tool) - 重点"></a><strong><code>MAT</code> (Eclipse Memory Analyzer Tool) - 重点</strong></h4><ul>
<li><strong>定位</strong>：<strong>最专业、最强大</strong>的Java<strong>堆内存分析利器</strong>，专门用于分析<code>jmap</code>或<code>-XX:+HeapDumpOnOutOfMemoryError</code>生成的堆转储快照（<code>.hprof</code>文件）。</li>
<li><strong>启动方式</strong>：独立软件，需从Eclipse官网下载（<a target="_blank" rel="noopener" href="https://www.eclipse.org/mat/%EF%BC%89%E3%80%82">https://www.eclipse.org/mat/）。</a></li>
<li><strong>核心功能</strong>：<ol>
<li><strong>支配树（Dominator Tree）</strong>：这是MAT的<strong>核心视图</strong>。它能清晰地展示出哪些对象占用了最多的内存（Retained Heap），以及这些对象的层级关系。通过支配树，可以快速找到内存消耗的根源。</li>
<li><strong>查找泄漏（Leak Suspects Report）</strong>：MAT能够自动分析整个堆，并生成一份高度可疑的内存泄漏报告，直接指出问题所在。</li>
<li><strong>路径到GC Roots（Path to GC Roots）</strong>：对于任何一个对象，都可以查询到它被哪些GC Roots引用，从而精确地找出它为什么没有被回收。</li>
<li><strong>OQL（Object Query Language）</strong>：提供了一种类似SQL的查询语言，可以对堆中的对象进行复杂的查询和筛选。</li>
<li><strong>组件报告（Component Report）</strong>：可以分析出应用中不同组件（如Tomcat, Log4j等）的内存占用情况。</li>
</ol>
</li>
<li><strong>优点</strong>：<ul>
<li><strong>分析能力极强</strong>，尤其擅长处理大内存（几十GB）的Dump文件。</li>
<li><strong>内存泄漏定位精准</strong>，支配树和GC Roots路径功能是排查OOM问题的终极武器。</li>
<li>自动化报告功能大大简化了分析过程。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>只能进行<strong>离线分析</strong>，无法实时监控。</li>
<li>学习曲线相对较陡峭，需要理解支配树、Shallow Heap、Retained Heap等概念。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li><strong><code>OutOfMemoryError: Java heap space</code>问题的终极排查</strong>。</li>
<li>深度分析应用的内存结构和对象引用关系。</li>
<li>查找和确认内存泄漏。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Arthas-阿尔萨斯-重点"><a href="#Arthas-阿尔萨斯-重点" class="headerlink" title="Arthas (阿尔萨斯) - 重点"></a><strong><code>Arthas</code> (阿尔萨斯) - 重点</strong></h4><ul>
<li><strong>定位</strong>：阿里开源的Java<strong>在线诊断神器</strong>。它采用命令行交互模式，可以在<strong>不重启服务</strong>的情况下，对正在运行的Java应用进行实时的监控、诊断和动态修改。</li>
<li><strong>启动方式</strong>：通过一个<code>arthas-boot.jar</code>包，以<code>java -jar</code>的方式附加（attach）到目标Java进程上。</li>
<li><strong>核心功能（命令）</strong>：<ol>
<li><strong><code>dashboard</code></strong>: 实时数据面板，显示线程、内存、GC等概览信息。</li>
<li><strong><code>thread</code></strong>: 查看所有线程信息，支持<code>thread -b</code>一键找出CPU占用最高的几个线程，并打印其堆栈。</li>
<li><strong><code>watch</code></strong>: <strong>王牌功能</strong>。观测指定方法的<strong>出入参、返回值和抛出的异常</strong>。可以用来排查“参数传错了”、“返回值不符合预期”等问题。</li>
<li><strong><code>trace</code></strong>: 跟踪方法的内部调用路径，并输出每个子调用的耗时。用于性能热点分析，找出慢在哪里。</li>
<li><strong><code>stack</code></strong>: 输出指定方法被调用的完整路径（调用堆栈）。</li>
<li><strong><code>monitor</code></strong>: 周期性地统计方法的调用次数、成功率、平均耗时等。</li>
<li><strong><code>jad</code></strong>: 反编译指定类的源码，可以用来确认线上运行的代码是否是最新版本。</li>
<li><strong><code>redefine</code> &#x2F; <code>mc</code></strong>: <strong>“黑科技”</strong>。可以动态地修改已加载类的字节码，例如改一个<code>if</code>判断的条件，或者热更新一个有bug的方法，<strong>无需重启应用</strong>。</li>
<li><strong><code>heapdump</code></strong>: 在线生成堆快照，功能类似<code>jmap</code>。</li>
</ol>
</li>
<li><strong>优点</strong>：<ul>
<li><strong>实时、在线、非侵入式</strong>，对线上服务影响极小。</li>
<li><strong>无需重启</strong>即可解决大量问题，极大地提高了线上问题排查的效率和时效性。</li>
<li>功能极其强大，覆盖了从监控、诊断到热修复的全链路。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>需要通过命令行交互，对新手有一定学习成本。</li>
<li>动态修改代码等高级功能有一定风险，需谨慎使用。</li>
</ul>
</li>
<li><strong>适用场景</strong>：<ul>
<li><strong>所有线上Java应用的问题排查</strong>，尤其是那些不能轻易重启的关键服务。</li>
<li>快速定位CPU飙高、方法执行慢、参数异常等各类疑难杂症。</li>
<li>进行紧急的热修复。</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong></p>
<table>
<thead>
<tr>
<th align="left">工具</th>
<th align="left">定位</th>
<th align="left">核心优势</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>JConsole</strong></td>
<td align="left">基础监控工具</td>
<td align="left">轻量，自带，快速查看状态和死锁</td>
<td align="left">基础监控，简单诊断</td>
</tr>
<tr>
<td align="left"><strong>VisualVM</strong></td>
<td align="left">多合一诊断平台</td>
<td align="left">功能全面，带强大的Profiler</td>
<td align="left">开发测试，全面的性能分析</td>
</tr>
<tr>
<td align="left"><strong>MAT</strong></td>
<td align="left"><strong>堆内存分析专家</strong></td>
<td align="left"><strong>分析大Dump，精确定位内存泄漏</strong></td>
<td align="left"><strong>OOM问题排查</strong>，深度内存分析</td>
</tr>
<tr>
<td align="left"><strong>Arthas</strong></td>
<td align="left"><strong>在线诊断与热修复神器</strong></td>
<td align="left"><strong>实时、在线、无需重启，功能极其强大</strong></td>
<td align="left"><strong>所有线上疑难杂症的排查和紧急修复</strong></td>
</tr>
</tbody></table>
<hr>
<h1 id="五、前沿与展望"><a href="#五、前沿与展望" class="headerlink" title="五、前沿与展望"></a>五、前沿与展望</h1><h2 id="1-GraalVM-与-AOT-编译"><a href="#1-GraalVM-与-AOT-编译" class="headerlink" title="1. GraalVM 与 AOT 编译"></a>1. GraalVM 与 AOT 编译</h2><h3 id="1-1-GraalVM-是什么？与-HotSpot-的关系"><a href="#1-1-GraalVM-是什么？与-HotSpot-的关系" class="headerlink" title="1.1 GraalVM 是什么？与 HotSpot 的关系"></a>1.1 GraalVM 是什么？与 HotSpot 的关系</h3><ul>
<li><strong>GraalVM 是什么？</strong><br>GraalVM是一个由Oracle开发的<strong>高性能、可嵌入、支持多种语言的通用虚拟机</strong>。它不仅仅是一个JVM，更是一个强大的运行时平台。它的核心组件包括：<ol>
<li><strong>Graal编译器 (Graal Compiler)</strong>：这是GraalVM的“心脏”。它是一个用<strong>纯Java编写的、高度优化的动态编译器</strong>。相比于HotSpot中用C++编写的C2编译器，Graal编译器本身更易于维护和创新，并且能执行更激进、更现代的优化。</li>
<li><strong>Truffle框架 (Truffle Framework)</strong>：一个用于构建编程语言解释器的Java库。通过Truffle框架，开发者可以为任何编程语言（如JavaScript, Python, Ruby, R）编写解释器，而这些语言将能够<strong>在GraalVM上以极高的性能运行</strong>，并与Java实现无缝互操作。这就是GraalVM被称为“Polyglot”（多语言）虚拟机的原因。</li>
<li><strong>Native Image</strong>：一个强大的**预先编译（AOT）**工具，可以将Java应用程序直接编译成一个无需JVM即可独立运行的本地可执行文件。</li>
</ol>
</li>
<li><strong>与HotSpot的关系</strong><br>GraalVM与我们熟知的HotSpot虚拟机之间存在着既紧密又可分离的关系。可以从两个模式来理解：<ol>
<li><strong>作为HotSpot的“插件式”JIT编译器</strong>：<ul>
<li>从JDK 9开始，Java引入了<strong>JVM编译器接口（JVMCI）</strong>。这允许将JIT编译器作为可插拔的模块来使用。</li>
<li>你可以继续使用标准的OpenJDK或Oracle JDK（它们都基于HotSpot），但通过特定的JVM参数，将默认的C2编译器<strong>替换为Graal编译器</strong>。</li>
<li><strong>启用方式</strong>：<code>-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler</code></li>
<li>在这种模式下，<strong>JVM仍然是HotSpot</strong>，但它使用了更强大的Graal编译器来进行JIT编译。这可以看作是对现有HotSpot的一次“引擎升级”，旨在获得更好的峰值性能。</li>
</ul>
</li>
<li><strong>作为独立的、增强版的JDK发行版</strong>：<ul>
<li>Oracle也提供了包含GraalVM所有特性的完整JDK发行版（GraalVM Community Edition &#x2F; Enterprise Edition）。</li>
<li>在这个发行版中，Graal编译器是默认的顶层JIT编译器。同时，它还包含了Truffle框架、Native Image工具以及对其他语言的支持。</li>
<li>这种模式下，GraalVM可以被看作是<strong>HotSpot的一个超集或替代品</strong>，提供了一个功能更全面的开发和运行环境。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>总结</strong>：GraalVM既可以是HotSpot的一个**“可插拔的高性能JIT编译器”<strong>，也可以是一个</strong>“功能更全面的、独立的JVM平台”**。</p>
<hr>
<h3 id="1-2-AOT-Ahead-of-Time-编译与-Native-Image，实现毫秒级启动"><a href="#1-2-AOT-Ahead-of-Time-编译与-Native-Image，实现毫秒级启动" class="headerlink" title="1.2 AOT (Ahead-of-Time) 编译与 Native Image，实现毫秒级启动"></a>1.2 AOT (Ahead-of-Time) 编译与 Native Image，实现毫秒级启动</h3><ul>
<li><p><strong>AOT (Ahead-of-Time) 编译 vs. JIT (Just-in-Time) 编译</strong></p>
<ul>
<li><strong>JIT (即时编译)</strong>：在<strong>运行时</strong>，根据代码热度动态地将字节码编译成本地机器码。<strong>优点</strong>是可以利用运行时收集的性能分析数据进行深度优化；<strong>缺点</strong>是存在预热（Warm-up）过程，导致启动慢。</li>
<li><strong>AOT (预先编译)</strong>：在<strong>构建时</strong>（运行之前），就将字节码或源代码直接编译成特定平台的本地机器码。<strong>优点</strong>是程序启动时无需再进行编译，可以实现“瞬时”启动；<strong>缺点</strong>是无法利用运行时信息，优化程度可能不如JIT的峰值性能。</li>
</ul>
</li>
<li><p><strong>GraalVM Native Image</strong><br>Native Image是GraalVM提供的AOT编译框架。它通过一个名为<code>native-image</code>的工具，将一个Java应用程序打包成一个平台相关的、独立的<strong>本地可执行文件</strong>（如Linux下的ELF文件，Windows下的EXE文件）。</p>
<p><strong>工作原理——“封闭世界”假设 (Closed-World Assumption)</strong>：<br>Native Image技术的核心在于一个“封闭世界”的假设，即它认为<strong>在编译时，所有会被执行到的代码路径都是已知的、可达的</strong>。</p>
<ol>
<li><strong>静态分析</strong>：<code>native-image</code>工具从<code>main</code>方法开始，进行深入的静态分析，找出所有可达的类、方法和字段。</li>
<li><strong>预先初始化</strong>：在构建时提前初始化类，并将堆的一部分快照（包含已初始化的对象）直接固化到可执行文件中。</li>
<li><strong>代码剔除（Dead Code Elimination）</strong>：所有在静态分析中不可达的代码（包括JDK中大量未被使用的类）都将被彻底剔除。</li>
<li><strong>AOT编译</strong>：将所有可达的Java字节码编译成高质量的本地机器码。</li>
<li><strong>打包</strong>：将编译好的机器码、堆快照、以及一个名为<strong>Substrate VM</strong>的微型运行时（负责GC、线程管理等基础功能）打包成一个独立的本地可执行文件。</li>
</ol>
</li>
<li><p><strong>实现毫秒级启动的原因</strong>：<br>运行这个本地可执行文件时，它<strong>不再需要一个完整的JVM</strong>。它跳过了传统Java程序启动时所有耗时的步骤：</p>
<ul>
<li><strong>无需JVM启动</strong>：没有庞大的JVM初始化过程。</li>
<li><strong>无需类加载</strong>：所有类在构建时已经处理完毕。</li>
<li><strong>无需解释执行</strong>：代码已经是机器码，直接运行。</li>
<li><strong>无需JIT编译预热</strong>：不存在性能爬坡过程，启动即是峰值。</li>
</ul>
<p>其结果就是，一个由Native Image生成的Java应用，其启动速度可以达到<strong>几十毫秒甚至几毫秒</strong>，与用Go或C++编写的程序相当。</p>
</li>
<li><p><strong>AOT的代价</strong>：<br>“封闭世界”假设也带来了一些限制，主要是对Java动态特性的挑战：</p>
<ul>
<li><strong>反射（Reflection）</strong>：需要通过配置文件在构建时明确告知<code>native-image</code>工具哪些类需要被反射。</li>
<li><strong>动态类加载</strong>：原则上不支持。</li>
<li><strong>动态代理</strong>：也需要配置。<br>主流框架如Spring Boot（通过Spring Native项目）、Quarkus、Micronaut等已经解决了这些问题，为开发者提供了无缝的Native Image支持。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-在云原生、Serverless-领域的应用前景"><a href="#1-3-在云原生、Serverless-领域的应用前景" class="headerlink" title="1.3 在云原生、Serverless 领域的应用前景"></a>1.3 在云原生、Serverless 领域的应用前景</h3><p>GraalVM Native Image技术的出现，完美地解决了Java在云原生和Serverless时代面临的两个核心痛点：<strong>启动慢</strong>和<strong>内存占用大</strong>。</p>
<ol>
<li><strong>Serverless（无服务器计算，如AWS Lambda, Azure Functions）</strong><ul>
<li><strong>痛点</strong>：<strong>冷启动（Cold Start）问题</strong>。当一个Serverless函数长时间未被调用后，其运行环境会被回收。下一次调用时，需要重新初始化整个环境，对于传统Java应用，这个冷启动时间可能长达数秒，这在延迟敏感的场景下是不可接受的。</li>
<li><strong>GraalVM解决方案</strong>：通过Native Image实现的<strong>毫秒级启动</strong>，从根本上消除了Java的冷启动惩罚，使得Java成为Serverless场景下的<strong>一流语言</strong>，能够与其他天生启动快的语言（如Go, Python）同台竞技。</li>
</ul>
</li>
<li><strong>微服务与容器化（Microservices &amp; Containers, 如Docker, Kubernetes）</strong><ul>
<li><strong>痛点</strong>：<ul>
<li><strong>高内存占用</strong>：传统JVM为了支持JIT等复杂特性，本身就有上百MB的内存开销。在微服务架构下，部署成百上千个服务实例，这种内存开销累加起来非常可观，直接导致更高的服务器成本。</li>
<li><strong>启动慢</strong>：在需要快速弹性伸缩（如根据负载自动增减Pod数量）的场景下，JVM的启动速度成为瓶颈，影响了系统的响应能力。</li>
</ul>
</li>
<li><strong>GraalVM解决方案</strong>：<ul>
<li><strong>极低的内存占用</strong>：Native Image应用通常只需要几十MB的内存即可运行，相比传统JVM应用节省了80%以上的内存。这意味着在同一台物理机上可以<strong>部署更多的服务实例（更高的部署密度）</strong>，从而<strong>大幅降低云资源成本</strong>。</li>
<li><strong>快速启动</strong>：使得服务的弹性伸缩变得非常迅速，提升了整个系统的敏捷性和韧性。</li>
<li><strong>更小的Docker镜像</strong>：由于可执行文件是独立的，不再需要一个完整的JDK作为基础镜像。Docker镜像可以基于极简的<code>distroless</code>或<code>scratch</code>镜像构建，体积可以从几百MB骤降到几十MB，加快了镜像的构建、推送和拉取速度。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>结论</strong>：GraalVM及其AOT编译技术，通过提供<strong>极快的启动速度</strong>和<strong>极低的内存占用</strong>，正在帮助Java语言摆脱“笨重”的刻板印象，使其能够更好地适应<strong>云原生、Serverless、微服务</strong>这些现代化架构的需求，为Java的未来开辟了全新的、广阔的应用前景。</p>
<hr>
<h2 id="2-容器化环境下的JVM"><a href="#2-容器化环境下的JVM" class="headerlink" title="2. 容器化环境下的JVM"></a>2. 容器化环境下的JVM</h2><p>随着Docker和Kubernetes（K8s）的普及，将Java应用打包成容器镜像进行部署已成为标准实践。然而，在早期，JVM与容器这种“被限制的运行环境”之间存在着一些“水土不服”的问题。</p>
<h3 id="2-1-Docker-K8s-环境中JVM的内存-CPU感知问题"><a href="#2-1-Docker-K8s-环境中JVM的内存-CPU感知问题" class="headerlink" title="2.1 Docker&#x2F;K8s 环境中JVM的内存&#x2F;CPU感知问题"></a>2.1 Docker&#x2F;K8s 环境中JVM的内存&#x2F;CPU感知问题</h3><p><strong>问题的根源</strong>：<br>在容器技术出现之前，JVM习惯于认为自己是运行在一台“完整”的物理机或虚拟机上。因此，它会直接从<strong>操作系统</strong>那里获取关于可用内存和CPU核心数的信息，并据此来设置其默认的堆大小、GC线程数等。</p>
<p>然而，容器（如Docker）是利用Linux的**Cgroups（Control Groups）**技术来实现资源隔离和限制的。对于容器内的进程来说，Cgroups限制的资源（如<code>--memory=2g</code>, <code>--cpus=2</code>）只是操作系统总资源的一部分。</p>
<p><strong>问题就出在这里：</strong><br>在<strong>Java 8 update 131</strong>以及<strong>Java 9</strong>之前的版本中，<strong>JVM无法感知到Cgroups的限制</strong>。</p>
<h5 id="a-内存感知问题"><a href="#a-内存感知问题" class="headerlink" title="a. 内存感知问题"></a><strong>a. 内存感知问题</strong></h5><ul>
<li><strong>现象</strong>：<ol>
<li>你为Docker容器设置了内存限制，例如 <code>docker run --memory=2g ... my-java-app</code>。</li>
<li>你没有为JVM明确指定<code>-Xmx</code>参数。</li>
<li>JVM启动时，它会向<strong>宿主机操作系统</strong>查询可用内存。如果宿主机有32GB内存，JVM可能会根据其默认的堆大小策略（如物理内存的1&#x2F;4），尝试设置一个8GB的最大堆。</li>
<li>当Java应用的堆内存使用增长，超过了容器的2GB限制时，容器的<strong>OOM Killer</strong>（操作系统的内存管理机制）会介入，不由分说地**直接杀死（kill -9）**这个Java进程，因为它违反了容器的内存限制。</li>
<li>你不会在Java应用层面看到任何<code>OutOfMemoryError</code>，也<strong>不会生成Heap Dump文件</strong>。你只会看到容器异常退出（<code>Exit Code 137</code>），排查起来非常困难。</li>
</ol>
</li>
<li><strong>总结</strong>：在旧版Java中，JVM会基于宿主机的内存来设置默认堆大小，而无视容器的内存限制，这极易导致容器级的OOM Kill。</li>
</ul>
<h5 id="b-CPU感知问题"><a href="#b-CPU感知问题" class="headerlink" title="b. CPU感知问题"></a><strong>b. CPU感知问题</strong></h5><ul>
<li><strong>现象</strong>：<ol>
<li>你为容器设置了CPU核心数限制，例如 <code>--cpus=2</code>。</li>
<li>宿主机可能有32个CPU核心。</li>
<li>JVM启动时，它会向宿主机查询CPU核心数，并得到32。</li>
<li>基于这个数字，JVM会创建默认数量的<strong>JIT编译线程</strong>、<strong>GC线程</strong>（例如，Parallel GC的线程数默认与CPU核心数相同）等。</li>
<li>结果就是，JVM可能会创建32个GC线程，但在一个只有2个CPU核心可用的容器里，这32个线程会为了抢占有限的CPU资源而产生<strong>剧烈的上下文切换</strong>，反而降低了GC效率，增加了不必要的系统开销。</li>
</ol>
</li>
<li><strong>总结</strong>：在旧版Java中，JVM会根据宿主机的CPU核心数来创建内部线程池，而无视容器的CPU限制，导致资源浪费和性能下降。</li>
</ul>
<hr>
<h3 id="2-2-Java-10-对容器的支持与新参数-XX-MaxRAMPercentage"><a href="#2-2-Java-10-对容器的支持与新参数-XX-MaxRAMPercentage" class="headerlink" title="2.2 Java 10+ 对容器的支持与新参数 (-XX:MaxRAMPercentage)"></a>2.2 Java 10+ 对容器的支持与新参数 (<code>-XX:MaxRAMPercentage</code>)</h3><p>为了解决上述问题，从<strong>Java 8u131</strong>、<strong>Java 9</strong>开始，尤其是<strong>Java 10</strong>以后，JVM对容器的支持得到了根本性的改进。</p>
<p><strong>核心改进</strong>：<strong>JVM现在能够自动感知并遵守Cgroups施加的资源限制</strong>。</p>
<ol>
<li><strong>开启容器支持</strong>：<ul>
<li>在Java 8u191+、Java 10及以后版本中，默认开启了容器感知功能，由参数 <strong><code>-XX:+UseContainerSupport</code></strong> 控制（默认<code>true</code>）。</li>
<li>这意味着，当JVM检测到自己运行在容器环境中时，它会<strong>自动从Cgroups的配置中读取内存和CPU的限制</strong>，而不是从宿主机操作系统。</li>
</ul>
</li>
<li><strong>改进后的行为</strong>：<ul>
<li><strong>内存</strong>：如果未指定<code>-Xmx</code>，JVM会根据容器的内存限制来计算一个合理的默认最大堆大小。</li>
<li><strong>CPU</strong>：JVM会根据容器的CPU核心数限制来设置GC线程数、JIT线程数等。</li>
</ul>
</li>
</ol>
<h5 id="引入新的内存配置参数"><a href="#引入新的内存配置参数" class="headerlink" title="引入新的内存配置参数"></a><strong>引入新的内存配置参数</strong></h5><p>为了在容器环境中更灵活地配置内存，Java 10引入了一系列新的、基于<strong>百分比</strong>的参数，使得JVM配置可以与容器的动态资源分配更好地结合。</p>
<ul>
<li><strong><code>-XX:InitialRAMPercentage</code></strong>, <strong><code>-XX:MaxRAMPercentage</code></strong>, <strong><code>-XX:MinRAMPercentage</code></strong><ul>
<li><strong>含义</strong>：这些参数允许你将JVM的堆大小设置为<strong>容器可用内存</strong>的一个百分比。</li>
<li><strong><code>-XX:MaxRAMPercentage</code></strong>: <strong>最常用</strong>。用于设置最大堆内存（<code>-Xmx</code>）占容器内存的百分比。<ul>
<li><strong>示例</strong>：<code>docker run --memory=4g ... java -XX:MaxRAMPercentage=75.0 -jar my-app.jar</code></li>
<li>在这个例子中，容器有4GB内存，JVM的最大堆大小将被设置为 <code>4GB * 75% = 3GB</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>为什么使用百分比参数更好？</strong><br>在云原生环境中，我们追求的是构建一个**“一次构建，到处运行”**的Docker镜像。</p>
<ul>
<li><strong>硬编码<code>-Xmx</code>的弊端</strong>：如果你在<code>Dockerfile</code>中硬编码了<code>-Xmx2g</code>，那么这个镜像无论被部署在分配了4GB内存的容器里，还是8GB内存的容器里，它都只会使用2GB的堆内存，无法充分利用资源。</li>
<li><strong>百分比参数的优势</strong>：如果你使用的是<code>-XX:MaxRAMPercentage=75.0</code>，那么这个镜像是<strong>环境自适应</strong>的。<ul>
<li>部署在4GB的容器里，它的<code>-Xmx</code>就是3GB。</li>
<li>部署在8GB的容器里，它的<code>-Xmx</code>就会自动变成6GB。</li>
<li>这使得同一个镜像可以灵活地适应不同的部署环境，而无需修改启动脚本，极大地增强了配置的灵活性和可移植性。</li>
</ul>
</li>
</ul>
<p><strong>为什么要设置75%而不是100%？</strong><br>因为Java进程占用的内存<strong>不仅仅是堆内存</strong>。还包括：</p>
<ul>
<li><strong>元空间 (Metaspace)</strong></li>
<li><strong>线程栈 (Thread Stacks)</strong>：每个线程都需要栈空间（<code>-Xss</code>）。</li>
<li><strong>直接内存 (Direct Memory)</strong></li>
<li><strong>JVM自身和JIT代码缓存</strong></li>
<li><strong>其他本地库占用的内存</strong></li>
</ul>
<p>通常为这些非堆内存预留**20-25%**的“安全边际”是一个比较合理的做法，以避免发生容器级的OOM Kill。</p>
<hr>
<p><strong>总结与最佳实践</strong></p>
<ol>
<li><strong>使用新版Java</strong>：务必使用<strong>Java 11&#x2F;17&#x2F;21</strong>等长期支持（LTS）版本，它们对容器有良好的原生支持。避免使用低于Java 8u191的版本。</li>
<li><strong>拥抱百分比参数</strong>：在<code>Dockerfile</code>或启动脚本中，**优先使用<code>-XX:MaxRAMPercentage</code>**来配置堆内存，而不是硬编码<code>-Xmx</code>。</li>
<li><strong>为非堆内存留足空间</strong>：<code>MaxRAMPercentage</code>的值通常设置在<strong>70.0到80.0</strong>之间，具体取决于你的应用对非堆内存的使用情况（线程数、直接内存使用等）。</li>
<li><strong>明确设置CPU限制</strong>：在K8s的部署配置（Deployment YAML）中，明确为你的Pod设置<code>resources.requests.cpu</code>和<code>resources.limits.cpu</code>，JVM会据此调整其内部线程池大小，实现更优的性能。</li>
</ol>
<p>通过遵循这些实践，你可以确保你的Java应用在容器化环境中表现得像一个“一等公民”，能够高效、稳定地利用被分配的资源。</p>
<hr>
<h2 id="3-JVM与Off-Heap内存"><a href="#3-JVM与Off-Heap内存" class="headerlink" title="3. JVM与Off-Heap内存"></a>3. JVM与Off-Heap内存</h2><p>堆外内存，顾名思义，指的是存在于Java虚拟机<strong>堆内存之外</strong>、由应用程序直接向操作系统申请和管理的内存。JVM本身不会对这部分内存进行垃圾回收。Java通过<code>java.nio</code>包为我们提供了操作堆外内存的桥梁。</p>
<h4 id="3-1-DirectByteBuffer-的原理与应用"><a href="#3-1-DirectByteBuffer-的原理与应用" class="headerlink" title="3.1 DirectByteBuffer 的原理与应用"></a>3.1 <code>DirectByteBuffer</code> 的原理与应用</h4><p>我们之前在讨论JVM内存区域时已经初步接触过直接内存，这里我们再次深入其原理。</p>
<ul>
<li><p><strong>回顾核心价值</strong>：<code>DirectByteBuffer</code>的核心价值在于<strong>减少I&#x2F;O过程中的数据拷贝</strong>。在进行网络或文件I&#x2F;O时，使用<code>DirectByteBuffer</code>可以让数据在操作系统内核缓冲区和应用程序的内存之间直接传递，避免了“内核 -&gt; Java堆 -&gt; 内核”的冗余拷贝，从而实现“<strong>零拷贝（Zero-Copy）</strong>”或准零拷贝，极大地提升I&#x2F;O性能。</p>
</li>
<li><p><strong>背后的“魔法”——<code>Unsafe</code>类</strong>：<br><code>DirectByteBuffer</code>的创建和操作，其底层依赖于一个“臭名昭著”但功能强大的类——<code>sun.misc.Unsafe</code>。</p>
<ol>
<li><strong>分配</strong>：当调用<code>ByteBuffer.allocateDirect(capacity)</code>时，内部实际上是调用了<code>Unsafe.allocateMemory(size)</code>方法，该方法类似于C语言中的<code>malloc()</code>，直接向操作系统申请一块连续的本地内存。</li>
<li><strong>访问</strong>：对<code>DirectByteBuffer</code>的读写操作（如<code>put()</code>, <code>get()</code>），最终都会被翻译成<code>Unsafe</code>类对特定内存地址的读写操作（如<code>Unsafe.putByte(address, value)</code>）。</li>
</ol>
</li>
<li><p><strong>回收机制——<code>Cleaner</code>与虚引用</strong>：<br>既然堆外内存不受GC直接管理，那么它如何被回收以避免内存泄漏呢？<br><code>DirectByteBuffer</code>巧妙地利用了**虚引用（<code>PhantomReference</code>）**机制。</p>
<ol>
<li>在创建<code>DirectByteBuffer</code>对象的同时，会创建一个与之关联的<code>sun.misc.Cleaner</code>对象（<code>Cleaner</code>是<code>PhantomReference</code>的一个子类）。</li>
<li>当堆上的<code>DirectByteBuffer</code>对象本身不再被任何强引用指向，并在GC中被回收时，与之关联的<code>Cleaner</code>对象会被放入一个<code>ReferenceQueue</code>中。</li>
<li>一个专门的、低优先级的GC后台线程会监控这个队列。一旦发现有<code>Cleaner</code>对象入队，就会执行其<code>clean()</code>方法。</li>
<li><code>clean()</code>方法最终会调用<code>Unsafe.freeMemory(address)</code>，从而释放之前申请的堆外内存。</li>
</ol>
<ul>
<li>这个精巧的设计，将堆外内存的生命周期与堆内的一个“代理”对象的生命周期绑定在了一起，实现了堆外内存的<strong>自动（但非实时）回收</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-Netty等框架如何利用堆外内存提升性能"><a href="#3-2-Netty等框架如何利用堆外内存提升性能" class="headerlink" title="3.2 Netty等框架如何利用堆外内存提升性能"></a>3.2 Netty等框架如何利用堆外内存提升性能</h4><p>像Netty这样的高性能网络框架，将堆外内存的应用发挥到了极致，其策略远不止是简单地使用<code>DirectByteBuffer</code>。</p>
<p><strong>Netty使用堆外内存的核心原因：</strong></p>
<ol>
<li><strong>避免GC影响，实现低延迟</strong>：<ul>
<li>网络应用中的缓冲区（Buffer）可能会很大，并且生命周期可能较长。如果将这些Buffer分配在Java堆上，它们很容易在多次Minor GC后晋升到老年代。</li>
<li>大量Buffer对象进入老年代会增加老年代的内存压力，更容易触发耗时较长的Full GC，导致应用出现长时间的STW停顿，这对于低延迟服务是致命的。</li>
<li>通过将网络缓冲区分配在<strong>堆外内存</strong>，Netty成功地<strong>将这些大块、生命周期不定的内存从GC的管辖范围中移出</strong>，极大地降低了GC的压力和频率，从而保证了服务的低延迟和高稳定性。</li>
</ul>
</li>
<li><strong>内存池化技术（Pooling），降低分配开销</strong>：<ul>
<li><code>DirectByteBuffer</code>的创建和销毁是昂贵的，因为它们直接涉及到操作系统的系统调用（<code>malloc</code>&#x2F;<code>free</code>）。在高并发场景下，频繁地申请和释放堆外内存会成为性能瓶瓶颈。</li>
<li><strong>Netty的核心优化在于内存池化</strong>。它设计了强大的<code>ByteBuf</code>内存池（如<code>PooledByteBufAllocator</code>）。</li>
<li><strong>工作原理</strong>：<ul>
<li>Netty在启动时，会向操作系统<strong>预先申请一大块连续的堆外内存</strong>。</li>
<li>然后，它像一个“内存的自定义分配器”一样，将这块大内存切分成许多标准大小的块（<code>Chunk</code>、<code>Page</code>、<code>Subpage</code>），并用复杂的数据结构（如二叉树）来管理这些内存块的分配和回收。</li>
<li>当一个网络连接需要缓冲区时，Netty会<strong>从池中快速地取出一块合适的内存</strong>分配给它。</li>
<li>当缓冲区使用完毕后，它会被<strong>归还到池中</strong>，而不是被操作系统回收，以供下一个请求复用。</li>
</ul>
</li>
<li><strong>效果</strong>：通过内存池化，Netty将昂贵的系统调用开销<strong>摊销</strong>了，使得在高并发下获取和释放缓冲区的操作变得极其高效。</li>
</ul>
</li>
<li><strong>与操作系统I&#x2F;O的无缝集成</strong>：<ul>
<li>数据从网卡Socket读入时，可以直接被放入Netty的堆外<code>ByteBuf</code>中，无需经过Java堆的中转。</li>
<li>当需要将数据写回给客户端时，<code>ByteBuf</code>中的数据也可以被直接传递给Socket进行发送。</li>
<li>这最大限度地遵循了“零拷贝”原则，减少了CPU在内存拷贝上的浪费。</li>
</ul>
</li>
</ol>
<p><strong>总结：Netty的高性能秘诀</strong></p>
<p><code>Netty高性能 ≈ 堆外内存 + 内存池化 + 零拷贝</code></p>
<p>通过这种方式，Netty等框架成功地绕开了传统JVM内存管理的一些限制，构建了一套更适合高性能I&#x2F;O场景的内存管理模型。这对于Java后端开发者来说是一个重要的启示：在性能敏感的场景下，不要局限于JVM堆，合理地利用堆外内存可以带来巨大的性能收益。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/10/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/Redis/" rel="prev" title="Redis">
                  <i class="fa fa-angle-left"></i> Redis
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
