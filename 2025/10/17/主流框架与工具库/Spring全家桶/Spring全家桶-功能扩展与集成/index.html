<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="六、功能扩展与集成1. 任务调度 (Task Scheduling)在软件开发中，任务调度是指在预定的时间点或按固定的时间间隔自动执行特定代码逻辑的机制。它是一种常见的非用户触发的后台处理模式，广泛应用于各种业务场景。 为什么需要任务调度？  自动化处理： 无需人工干预，系统能自动执行重复性任务，如数据备份、报表生成。 异步与解耦： 将耗时的、非核心的任务（如发送通知邮件、数据同步）从主业务流程中">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring全家桶-功能扩展与集成">
<meta property="og:url" content="http://example.com/2025/10/17/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95%E4%B8%8E%E9%9B%86%E6%88%90/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="六、功能扩展与集成1. 任务调度 (Task Scheduling)在软件开发中，任务调度是指在预定的时间点或按固定的时间间隔自动执行特定代码逻辑的机制。它是一种常见的非用户触发的后台处理模式，广泛应用于各种业务场景。 为什么需要任务调度？  自动化处理： 无需人工干预，系统能自动执行重复性任务，如数据备份、报表生成。 异步与解耦： 将耗时的、非核心的任务（如发送通知邮件、数据同步）从主业务流程中">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-17T05:20:07.000Z">
<meta property="article:modified_time" content="2025-10-17T05:20:59.554Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/10/17/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95%E4%B8%8E%E9%9B%86%E6%88%90/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/10/17/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95%E4%B8%8E%E9%9B%86%E6%88%90/","path":"2025/10/17/主流框架与工具库/Spring全家桶/Spring全家桶-功能扩展与集成/","title":"Spring全家桶-功能扩展与集成"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Spring全家桶-功能扩展与集成 | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95%E4%B8%8E%E9%9B%86%E6%88%90"><span class="nav-text">六、功能扩展与集成</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6-Task-Scheduling"><span class="nav-text">1. 任务调度 (Task Scheduling)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-Scheduled-%E6%B3%A8%E8%A7%A3"><span class="nav-text">1.1 @Scheduled 注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="nav-text">1.1.1 使用步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%BC%80%E5%90%AF%E8%B0%83%E5%BA%A6%E5%8A%9F%E8%83%BD"><span class="nav-text">1. 开启调度功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="nav-text">2. 创建定时任务</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E5%B8%B8%E7%94%A8%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="nav-text">1.1.2 常用调度策略</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-fixedRate%EF%BC%9A%E5%9B%BA%E5%AE%9A%E9%A2%91%E7%8E%87%E6%89%A7%E8%A1%8C"><span class="nav-text">1. fixedRate：固定频率执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-fixedDelay%EF%BC%9A%E5%9B%BA%E5%AE%9A%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C"><span class="nav-text">2. fixedDelay：固定延迟执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-cron%EF%BC%9ACron-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">3. cron：Cron 表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-initialDelay%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%BB%B6%E8%BF%9F"><span class="nav-text">4. initialDelay：初始延迟</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">1.1.3 深入理解与注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Cron-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">1.2 Cron 表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-Cron-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84"><span class="nav-text">1.2.1 Cron 表达式的语法结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E8%AF%A6%E8%A7%A3"><span class="nav-text">1.2.2 特殊字符详解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E5%B8%B8%E8%A7%81-Cron-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%A4%BA%E4%BE%8B"><span class="nav-text">1.2.3 常见 Cron 表达式示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">1.2.4 使用技巧与注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E5%BA%A6"><span class="nav-text">1.3 动态与分布式调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-Quartz%EF%BC%9A%E5%BC%BA%E5%A4%A7%E7%9A%84%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6"><span class="nav-text">1.3.1 Quartz：强大的企业级调度框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E4%B8%AD%E5%BF%83"><span class="nav-text">1.3.2 分布式任务调度中心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3-%E6%80%BB%E7%BB%93%E4%B8%8E%E9%80%89%E5%9E%8B%E5%AF%B9%E6%AF%94"><span class="nav-text">1.3.3 总结与选型对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BC%93%E5%AD%98%E6%8A%BD%E8%B1%A1-Caching-Abstraction"><span class="nav-text">2. 缓存抽象 (Caching Abstraction)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3"><span class="nav-text">2.1 核心注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-Cacheable%EF%BC%9A%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="nav-text">2.1.1 @Cacheable：查询缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-CachePut%EF%BC%9A%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98"><span class="nav-text">2.1.2 @CachePut：更新缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-CacheEvict%EF%BC%9A%E5%A4%B1%E6%95%88%E7%BC%93%E5%AD%98"><span class="nav-text">2.1.3 @CacheEvict：失效缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-Caching-%E5%92%8C-CacheConfig%EF%BC%9A%E7%BB%84%E5%90%88%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="nav-text">2.1.4 @Caching 和 @CacheConfig：组合与配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-CacheManager-%E4%B8%8E-Cache-%E6%8E%A5%E5%8F%A3"><span class="nav-text">2.2 CacheManager 与 Cache 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-CacheManager-%E6%8E%A5%E5%8F%A3%EF%BC%9A%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-text">2.2.1 CacheManager 接口：缓存管理器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-Cache-%E6%8E%A5%E5%8F%A3%EF%BC%9A%E7%BC%93%E5%AD%98%E6%9C%AC%E8%BA%AB"><span class="nav-text">2.2.2 Cache 接口：缓存本身</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E9%85%8D%E7%BD%AE-CacheManager-Bean-%E4%BB%A5-Caffeine-%E4%B8%BA%E4%BE%8B"><span class="nav-text">2.2.3 配置 CacheManager Bean (以 Caffeine 为例)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-%E7%BC%96%E7%A8%8B%E5%BC%8F%E7%BC%93%E5%AD%98%E6%93%8D%E4%BD%9C%EF%BC%9A%E6%89%8B%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%BC%93%E5%AD%98"><span class="nav-text">2.2.4 编程式缓存操作：手动控制缓存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%B8%B8%E7%94%A8%E7%BC%93%E5%AD%98%E6%8F%90%E4%BE%9B%E5%95%86%E9%9B%86%E6%88%90"><span class="nav-text">2.3 常用缓存提供商集成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-Caffeine%EF%BC%9A%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98"><span class="nav-text">2.3.1 Caffeine：高性能本地缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-Redis%EF%BC%9A%E8%A1%8C%E4%B8%9A%E6%A0%87%E5%87%86%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98"><span class="nav-text">2.3.2 Redis：行业标准的分布式缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-EhCache%EF%BC%9A%E4%BC%A0%E7%BB%9F%E7%9A%84-JCache-%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.3.3 EhCache：传统的 JCache 实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="nav-text">2.3.4 总结与对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81-Mail"><span class="nav-text">3. 邮件发送 (Mail)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-JavaMailSender"><span class="nav-text">3.1 JavaMailSender</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E9%9B%86%E6%88%90-spring-boot-starter-mail"><span class="nav-text">3.1.1 集成 spring-boot-starter-mail</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E6%B3%A8%E5%85%A5%E5%B9%B6%E4%BD%BF%E7%94%A8-JavaMailSender"><span class="nav-text">3.1.2 注入并使用 JavaMailSender</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">3.1.3 最佳实践与注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%8F%91%E9%80%81%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E3%80%81%E9%99%84%E4%BB%B6%E9%82%AE%E4%BB%B6%E3%80%81%E5%86%85%E8%81%94%E8%B5%84%E6%BA%90%E9%82%AE%E4%BB%B6"><span class="nav-text">3.2 发送简单邮件、附件邮件、内联资源邮件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E5%8F%91%E9%80%81%E7%AE%80%E5%8D%95%E6%96%87%E6%9C%AC%E9%82%AE%E4%BB%B6-Simple-Text-Mail"><span class="nav-text">3.2.1 发送简单文本邮件 (Simple Text Mail)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E5%8F%91%E9%80%81%E5%B8%A6%E9%99%84%E4%BB%B6%E7%9A%84%E9%82%AE%E4%BB%B6-Mail-with-Attachments"><span class="nav-text">3.2.2 发送带附件的邮件 (Mail with Attachments)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E5%8F%91%E9%80%81%E5%B8%A6%E5%86%85%E8%81%94%E8%B5%84%E6%BA%90%E7%9A%84%E9%82%AE%E4%BB%B6-Mail-with-Inline-Resources"><span class="nav-text">3.2.3 发送带内联资源的邮件 (Mail with Inline Resources)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="nav-text">3.2.4 总结与对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%A8%A1%E6%9D%BF%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81"><span class="nav-text">3.3 模板邮件发送</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E9%9B%86%E6%88%90-Thymeleaf"><span class="nav-text">3.3.1 集成 Thymeleaf</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E5%88%9B%E5%BB%BA%E9%82%AE%E4%BB%B6%E6%A8%A1%E6%9D%BF"><span class="nav-text">3.3.2 创建邮件模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%9D%BF%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E6%9C%8D%E5%8A%A1"><span class="nav-text">3.3.3 实现模板邮件发送服务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C-Asynchronous-Execution"><span class="nav-text">4. 异步执行 (Asynchronous Execution)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Async-%E6%B3%A8%E8%A7%A3"><span class="nav-text">4.1 @Async 注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%E5%BC%80%E5%90%AF%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81"><span class="nav-text">4.1.1 开启异步支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-%E5%88%9B%E5%BB%BA%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-text">4.1.2 创建异步方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95-void"><span class="nav-text">1. 无返回值的异步方法 (void)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95-Future-CompletableFuture"><span class="nav-text">2. 有返回值的异步方法 (Future &#x2F; CompletableFuture)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3-%E9%87%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%E4%B8%8E%E9%99%B7%E9%98%B1"><span class="nav-text">4.1.3 重要使用规则与陷阱</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">4.2 自定义线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="nav-text">4.2.1 为什么需要自定义线程池？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">4.2.2 实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%87%8D%E5%86%99%E9%BB%98%E8%AE%A4%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">1. 重写默认的异步线程池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BA%E5%B9%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">2. 创建并使用多个线程池</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-%E6%80%BB%E7%BB%93"><span class="nav-text">4.2.3 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%BC%82%E6%AD%A5%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">4.3 异步返回值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-Future%EF%BC%9A%E7%BB%8F%E5%85%B8%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BB%93%E6%9E%9C%E5%8F%A5%E6%9F%84"><span class="nav-text">4.3.1 Future&lt;T&gt;：经典的异步结果句柄</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-CompletableFuture%EF%BC%9A%E6%8E%A8%E8%8D%90%E7%9A%84%E7%8E%B0%E4%BB%A3%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F"><span class="nav-text">4.3.2 CompletableFuture&lt;T&gt;：推荐的现代异步编程方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-ListenableFuture-%E5%B7%B2%E8%BF%87%E6%97%B6"><span class="nav-text">4.3.3 ListenableFuture&lt;T&gt; (已过时)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-4-%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94"><span class="nav-text">4.3.4 总结对比</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/17/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95%E4%B8%8E%E9%9B%86%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Spring全家桶-功能扩展与集成 | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring全家桶-功能扩展与集成
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-10-17 13:20:07 / 修改时间：13:20:59" itemprop="dateCreated datePublished" datetime="2025-10-17T13:20:07+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/" itemprop="url" rel="index"><span itemprop="name">Spring全家桶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="六、功能扩展与集成"><a href="#六、功能扩展与集成" class="headerlink" title="六、功能扩展与集成"></a>六、功能扩展与集成</h1><h2 id="1-任务调度-Task-Scheduling"><a href="#1-任务调度-Task-Scheduling" class="headerlink" title="1. 任务调度 (Task Scheduling)"></a>1. 任务调度 (Task Scheduling)</h2><p>在软件开发中，任务调度是指在预定的时间点或按固定的时间间隔自动执行特定代码逻辑的机制。它是一种常见的非用户触发的后台处理模式，广泛应用于各种业务场景。</p>
<p><strong>为什么需要任务调度？</strong></p>
<ul>
<li><strong>自动化处理：</strong> 无需人工干预，系统能自动执行重复性任务，如数据备份、报表生成。</li>
<li><strong>异步与解耦：</strong> 将耗时的、非核心的任务（如发送通知邮件、数据同步）从主业务流程中分离出来，放到后台定时执行，提升系统响应速度和用户体验。</li>
<li><strong>资源削峰：</strong> 将高并发的请求或计算密集型任务分散到系统负载较低的时间段（如凌晨）执行。</li>
</ul>
<p><strong>常见应用场景：</strong></p>
<ul>
<li><strong>数据清理：</strong> 每天凌晨清理过期日志、临时文件或无效数据。</li>
<li><strong>报表生成：</strong> 每周一凌晨自动生成上周的业务统计报表。</li>
<li><strong>数据同步：</strong> 每隔10分钟从第三方系统拉取最新数据。</li>
<li><strong>状态检查与通知：</strong> 定时扫描订单表，对超时的未支付订单进行关闭，并发送通知。</li>
</ul>
<p>Spring 框架提供了强大的内置任务调度支持，通过简单的注解就能实现复杂的调度需求，极大地简化了开发过程。</p>
<hr>
<h3 id="1-1-Scheduled-注解"><a href="#1-1-Scheduled-注解" class="headerlink" title="1.1 @Scheduled 注解"></a>1.1 <code>@Scheduled</code> 注解</h3><p><code>@Scheduled</code> 是 Spring 提供的一个注解，用于将一个普通方法标记为需要定时执行的任务。这是实现任务调度的最简单、最快捷的方式。</p>
<h4 id="1-1-1-使用步骤"><a href="#1-1-1-使用步骤" class="headerlink" title="1.1.1 使用步骤"></a>1.1.1 使用步骤</h4><h5 id="1-开启调度功能"><a href="#1-开启调度功能" class="headerlink" title="1. 开启调度功能"></a>1. 开启调度功能</h5><p>要使 <code>@Scheduled</code> 注解生效，必须在 Spring Boot 的主启动类或任何一个配置类（<code>@Configuration</code>）上添加 <code>@EnableScheduling</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">// 开启定时任务调度功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-创建定时任务"><a href="#2-创建定时任务" class="headerlink" title="2. 创建定时任务"></a>2. 创建定时任务</h5><p>在一个 Spring管理的 Bean（如 <code>@Component</code>, <code>@Service</code>）中，创建一个 public、void、无参的方法，并在其上添加 <code>@Scheduled</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTasks</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例任务</span></span><br><span class="line">    <span class="meta">@Scheduled(...)</span> <span class="comment">// 在这里配置调度规则</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myTaskMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;定时任务执行于: &quot;</span> + LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-1-2-常用调度策略"><a href="#1-1-2-常用调度策略" class="headerlink" title="1.1.2 常用调度策略"></a>1.1.2 常用调度策略</h4><p><code>@Scheduled</code> 注解提供了多种属性来定义任务的执行时机：</p>
<h5 id="1-fixedRate：固定频率执行"><a href="#1-fixedRate：固定频率执行" class="headerlink" title="1. fixedRate：固定频率执行"></a><strong>1. <code>fixedRate</code>：固定频率执行</strong></h5><ul>
<li><strong>含义：</strong> 上一次任务<strong>开始执行</strong>后，间隔固定时间再次执行。单位为毫秒。</li>
<li><strong>特点：</strong> 任务的启动时间是固定的，不受任务执行时长的影响。如果任务执行时间超过了 <code>fixedRate</code> 的间隔，那么上一个任务结束后，下一个任务会立即执行。</li>
<li><strong>示例：</strong> 每隔5秒执行一次。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(fixedRate = 5000)</span> <span class="comment">// 5000 毫秒 = 5秒</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTaskAtFixedRate</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;fixedRate 任务执行...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-fixedDelay：固定延迟执行"><a href="#2-fixedDelay：固定延迟执行" class="headerlink" title="2. fixedDelay：固定延迟执行"></a>2. <code>fixedDelay</code>：固定延迟执行</h5><ul>
<li><strong>含义：</strong> 上一次任务<strong>执行完毕</strong>后，等待固定时间再执行下一次。单位为毫秒。</li>
<li><strong>特点：</strong> 两次任务执行的间隔是固定的，即 <code>(上一次任务结束时间)</code> + <code>fixedDelay</code> &#x3D; <code>(下一次任务开始时间)</code>。</li>
<li><strong>示例：</strong> 任务执行完成后，延迟3秒再执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(fixedDelay = 3000)</span> <span class="comment">// 3000 毫秒 = 3秒</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTaskWithFixedDelay</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;fixedDelay 任务执行...&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务耗时2秒</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行流程：执行(2s) -&gt; 等待(3s) -&gt; 执行(2s) -&gt; 等待(3s) -&gt; ...</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-cron：Cron-表达式"><a href="#3-cron：Cron-表达式" class="headerlink" title="3. cron：Cron 表达式"></a>3. <code>cron</code>：Cron 表达式</h5><ul>
<li><p><strong>含义：</strong> 最灵活的调度方式，使用标准的 Cron 表达式来定义复杂的执行计划。</p>
</li>
<li><p><strong>格式：</strong> <code>秒 分 时 日 月 周</code> (共6个或7个字段，Spring 支持6个字段，年是可选的)。</p>
<ul>
<li><code>*</code>：匹配所有值。</li>
<li><code>?</code>：仅在“日”和“周”字段中使用，表示不指定值。</li>
<li><code>/</code>：表示步长，如 <code>0/15</code> 在秒字段表示每15秒。</li>
</ul>
</li>
<li><p><strong>示例：</strong> 每天凌晨2点整执行。</p>
<blockquote>
<p><strong>Tip:</strong> 可以使用在线 Cron 表达式生成器来创建和验证表达式。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;秒 分 时 日 月 周&quot;</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 2 * * ?&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTaskWithCron</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Cron 任务在每天凌晨2点执行...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-initialDelay：初始延迟"><a href="#4-initialDelay：初始延迟" class="headerlink" title="4. initialDelay：初始延迟"></a>4. <code>initialDelay</code>：初始延迟</h5><ul>
<li><strong>含义：</strong> 指定任务首次执行前的延迟时间，可与 <code>fixedRate</code> 或 <code>fixedDelay</code> 配合使用。单位为毫秒。</li>
<li><strong>示例：</strong> 服务启动后，延迟10秒，然后每5秒执行一次。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(initialDelay = 10000, fixedRate = 5000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTaskWithInitialDelay</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;首次延迟10秒后，每5秒执行一次的任务...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-1-3-深入理解与注意事项"><a href="#1-1-3-深入理解与注意事项" class="headerlink" title="1.1.3 深入理解与注意事项"></a>1.1.3 深入理解与注意事项</h4><ul>
<li><strong>默认单线程执行：</strong> Spring 调度的所有 <code>@Scheduled</code> 任务<strong>默认使用一个单线程的线程池</strong>。这意味着，如果一个任务执行时间过长，它会阻塞其他任务的执行。</li>
<li><strong>解决方案（自定义线程池）：</strong> 在生产环境中，强烈建议为定时任务配置一个独立的线程池，以避免任务间的相互影响。</li>
</ul>
<p><strong>配置示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchedulingConfig</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个包含10个线程的线程池</span></span><br><span class="line">        taskRegistrar.setScheduler(Executors.newScheduledThreadPool(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个配置，所有的 <code>@Scheduled</code> 任务就会在这个容量为10的线程池中并发执行。</p>
<hr>
<h3 id="1-2-Cron-表达式"><a href="#1-2-Cron-表达式" class="headerlink" title="1.2 Cron 表达式"></a>1.2 Cron 表达式</h3><p><code>@Scheduled</code> 注解中的 <code>fixedRate</code> 和 <code>fixedDelay</code> 适用于简单的、固定间隔的调度。但对于更复杂的业务场景，例如“每个工作日的上午10点”、“每个月最后一天”或“每季度第一个周一”，我们就需要使用 Cron 表达式。</p>
<p>Cron 表达式是一个字符串，由 6 到 7 个由空格分隔的字段组成，它精确地定义了任务触发的时间规则。</p>
<h4 id="1-2-1-Cron-表达式的语法结构"><a href="#1-2-1-Cron-表达式的语法结构" class="headerlink" title="1.2.1 Cron 表达式的语法结构"></a>1.2.1 Cron 表达式的语法结构</h4><p>Spring 的 Cron 表达式包含 6 个必填字段，其顺序和含义如下：</p>
<table>
<thead>
<tr>
<th align="left">位置</th>
<th align="left">字段</th>
<th align="left">允许值</th>
<th align="left">允许的特殊字符</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>秒 (Second)</strong></td>
<td align="left"><code>0-59</code></td>
<td align="left"><code>* , - /</code></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>分 (Minute)</strong></td>
<td align="left"><code>0-59</code></td>
<td align="left"><code>* , - /</code></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>时 (Hour)</strong></td>
<td align="left"><code>0-23</code></td>
<td align="left"><code>* , - /</code></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>日 (Day of Month)</strong></td>
<td align="left"><code>1-31</code></td>
<td align="left"><code>* , - / ? L W</code></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>月 (Month)</strong></td>
<td align="left"><code>1-12</code> 或 <code>JAN-DEC</code></td>
<td align="left"><code>* , - /</code></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>周 (Day of Week)</strong></td>
<td align="left"><code>1-7</code> 或 <code>MON-SUN</code></td>
<td align="left"><code>* , - / ? L #</code></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>重要提示</strong>：在 “日 (Day of Month)” 和 “周 (Day of Week)” 字段中，通常必须有一个使用 <code>?</code> 来表示“不指定”，以避免冲突。例如，你不能同时指定“每月的15号”并且“是周五”。</p>
</blockquote>
<hr>
<h4 id="1-2-2-特殊字符详解"><a href="#1-2-2-特殊字符详解" class="headerlink" title="1.2.2 特殊字符详解"></a>1.2.2 特殊字符详解</h4><table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">名称</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>*</code></td>
<td align="left">星号 (任意值)</td>
<td align="left">代表该字段的每一个可能的值。例如，在“分”字段中表示“每分钟”。</td>
</tr>
<tr>
<td align="left"><code>?</code></td>
<td align="left">问号 (不指定)</td>
<td align="left">仅用于“日”和“周”字段。当其中一个字段被指定了值，另一个字段就应该使用 <code>?</code> 来表示不关心。</td>
</tr>
<tr>
<td align="left"><code>-</code></td>
<td align="left">减号 (范围)</td>
<td align="left">指定一个范围。例如，在“时”字段中使用 <code>10-12</code> 表示 10点、11点和12点。</td>
</tr>
<tr>
<td align="left"><code>,</code></td>
<td align="left">逗号 (列表)</td>
<td align="left">指定一个值的列表。例如，在“周”字段中使用 <code>MON,WED,FRI</code> 表示周一、周三和周五。</td>
</tr>
<tr>
<td align="left"><code>/</code></td>
<td align="left">斜杠 (步长)</td>
<td align="left">指定增量。例如，在“秒”字段中使用 <code>0/15</code> 表示从第0秒开始，每隔15秒执行一次（即 0, 15, 30, 45秒）。</td>
</tr>
<tr>
<td align="left"><code>L</code></td>
<td align="left">Last (最后)</td>
<td align="left">仅用于“日”和“周”字段。<br/>- 在“日”字段中，<code>L</code> 表示这个月的最后一天（31、30、29或28）。<br/>- 在“周”字段中，<code>L</code> 表示一周的最后一天（即周六 <code>SAT</code> 或 <code>7</code>）。<code>5L</code> 则表示这个月最后一个周四。</td>
</tr>
<tr>
<td align="left"><code>W</code></td>
<td align="left">Weekday (工作日)</td>
<td align="left">仅用于“日”字段。<code>15W</code> 表示离15号最近的那个工作日（周一到周五）。如果15号是周六，则在14号（周五）触发；如果15号是周日，则在16号（周一）触发。<code>LW</code> 组合表示这个月最后一个工作日。</td>
</tr>
<tr>
<td align="left"><code>#</code></td>
<td align="left">井号 (第几个)</td>
<td align="left">仅用于“周”字段。<code>5#3</code> 表示这个月的第三个星期四。</td>
</tr>
</tbody></table>
<hr>
<h4 id="1-2-3-常见-Cron-表达式示例"><a href="#1-2-3-常见-Cron-表达式示例" class="headerlink" title="1.2.3 常见 Cron 表达式示例"></a>1.2.3 常见 Cron 表达式示例</h4><p>下面是一些实际应用中的例子，可以直接在 <code>@Scheduled</code> 注解中使用。</p>
<p><strong>示例1：每分钟的第30秒执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;30 * * * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例2：每天凌晨 1:00 整执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 秒 分 时 日 月 周</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 1 * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例3：每个工作日 (周一至周五) 的上午 10:15 执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 15 10 ? * MON-FRI&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例4：每个月1号、11号、21号的凌晨 2:00 执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 2 1,11,21 * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例5：每隔 5 分钟执行一次</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0/5 * * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task5</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例6：每个月最后一个周五的晚上 10:00 执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 22 ? * 5L&quot;)</span> <span class="comment">// 5L 表示最后一个周四</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">task6</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-4-使用技巧与注意事项"><a href="#1-2-4-使用技巧与注意事项" class="headerlink" title="1.2.4 使用技巧与注意事项"></a>1.2.4 使用技巧与注意事项</h4><ul>
<li><p><strong>在线生成器：</strong> 对于复杂的 Cron 表达式，强烈建议使用在线 Cron 表达式生成和校验工具 (如 Cron Maker, Crontab Guru)。这可以有效避免手动编写错误。</p>
</li>
<li><p><strong>时区问题 (Time Zone)：</strong> Spring 的 <code>@Scheduled</code> 默认使用服务器的本地时区。如果你的应用需要基于特定时区进行调度（例如，所有任务都按 <code>UTC+8</code> 执行），可以在注解中指定 <code>zone</code> 属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 1 * * ?&quot;, zone = &quot;Asia/Shanghai&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskInSpecificTimeZone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这个任务总是在北京时间凌晨1点执行，无论服务器在哪个时区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代码可读性：</strong> 复杂的 Cron 表达式会降低代码的可读性。建议在 <code>@Scheduled</code> 注解上方添加一行注释，用自然语言解释该表达式的含义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute at 10:15 AM every weekday</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 15 10 ? * MON-FRI&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDailyReport</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置化：</strong> 在生产环境中，将 Cron 表达式配置在 <code>application.properties</code> 或 <code>application.yml</code> 中是更好的实践，这样可以在不重新编译和部署代码的情况下调整任务执行时间。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"><span class="attr">myapp.scheduling.report-task.cron</span>=<span class="string">0 15 10 ? * MON-FRI</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;$&#123;myapp.scheduling.report-task.cron&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDailyReport</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="1-3-动态与分布式调度"><a href="#1-3-动态与分布式调度" class="headerlink" title="1.3 动态与分布式调度"></a>1.3 动态与分布式调度</h3><p>虽然 <code>@Scheduled</code> 注解非常方便，但它存在一些固有的局限性，尤其是在现代化的、可扩展的应用程序中：</p>
<ol>
<li><strong>静态性 (Static Nature):</strong> 任务的触发规则（如 Cron 表达式）通常硬编码在代码或配置文件中。如果需要修改执行时间、暂停任务或新增任务，必须修改代码、重新打包并部署应用，缺乏灵活性。</li>
<li><strong>单点问题 (Single Point of Execution):</strong> 在分布式环境中，如果将应用部署为多个实例（集群），每个实例都会独立执行相同的 <code>@Scheduled</code> 任务，这会导致任务被重复执行，可能引发数据错乱或资源浪费。</li>
<li><strong>功能局限 (Limited Functionality):</strong> <code>@Scheduled</code> 缺少一些高级的企业级功能，如：<ul>
<li>可视化的管理和监控界面。</li>
<li>失败重试、任务依赖、历史日志查询。</li>
<li>任务分片（将一个大任务拆分给多个节点执行）。</li>
<li>故障转移（一个节点宕机后，任务自动由其他节点接管）。</li>
</ul>
</li>
</ol>
<p>为了解决这些问题，我们需要引入更专业的调度框架，它们主要分为两大类：<strong>企业级调度框架（如 Quartz）</strong> 和 <strong>分布式任务调度中心（如 XXL-Job, PowerJob）</strong>。</p>
<hr>
<h4 id="1-3-1-Quartz：强大的企业级调度框架"><a href="#1-3-1-Quartz：强大的企业级调度框架" class="headerlink" title="1.3.1 Quartz：强大的企业级调度框架"></a>1.3.1 Quartz：强大的企业级调度框架</h4><p>Quartz 是一个功能丰富、历史悠久的开源作业调度库，可以紧密集成在 Java 应用中。你可以把它看作是 Spring 内置调度的“超级增强版”。</p>
<p><strong>核心概念:</strong></p>
<ul>
<li><strong><code>Scheduler</code>：</strong> 调度器核心，负责管理和触发任务。</li>
<li><strong><code>Job</code>：</strong> 一个接口，定义了需要被执行的具体业务逻辑。</li>
<li><strong><code>Trigger</code>：</strong> 触发器，定义了 <code>Job</code> 何时被执行（例如，使用 <code>CronTrigger</code> 或 <code>SimpleTrigger</code>）。</li>
<li><strong><code>JobDetail</code>：</strong> <code>Job</code> 的实例，包含了 <code>Job</code> 的身份信息（名称、组）和相关的状态数据 (<code>JobDataMap</code>)。</li>
</ul>
<p><strong>关键特性:</strong></p>
<ol>
<li><strong>持久化 (Persistence):</strong> Quartz 可以将任务（<code>Job</code> 和 <code>Trigger</code>）的信息存储在数据库中。这样即使应用重启，之前定义的任务也不会丢失，保证了任务的可靠性。</li>
<li><strong>动态管理 (Dynamic Management):</strong> 你可以通过代码（API调用）在运行时动态地创建、修改、暂停、恢复和删除任务，而无需重启服务。这解决了 <code>@Scheduled</code> 的静态性问题。</li>
<li><strong>集群支持 (Clustering):</strong> Quartz 支持集群模式。多个应用实例可以连接到同一个数据库，Quartz 通过数据库锁机制来确保在同一时刻，一个任务只会被集群中的一个节点执行，从而避免了任务重复执行的问题。</li>
<li><strong>丰富的触发器:</strong> 除了 Cron 触发器，还支持 <code>SimpleTrigger</code>（在指定时间点执行，可设置重复次数和间隔）等多种触发方式。</li>
</ol>
<p><strong>与 Spring Boot 集成:</strong></p>
<p>通过引入 <code>spring-boot-starter-quartz</code> 依赖，可以非常方便地将 Quartz 集成到 Spring Boot 项目中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-3-2-分布式任务调度中心"><a href="#1-3-2-分布式任务调度中心" class="headerlink" title="1.3.2 分布式任务调度中心"></a>1.3.2 分布式任务调度中心</h4><p>对于微服务架构或大规模分布式系统，更好的选择是使用一个独立的、可视化的<strong>分布式任务调度中心</strong>。</p>
<p>这种架构将 <strong>调度器 (Scheduler)</strong> 和 <strong>执行器 (Executor)</strong> 分离开来：</p>
<ul>
<li><strong>调度中心 (Scheduler Center):</strong> 一个独立的、高可用的服务。它负责任务的统一管理（增删改查）、触发、监控、路由和故障转移。通常提供一个 Web 管理界面。</li>
<li><strong>执行器 (Executor):</strong> 通常是一个轻量级的 Agent 或 SDK，内嵌在你的业务应用中。它负责接收来自调度中心的指令，并执行具体的业务代码。</li>
</ul>
<p><strong>主流框架:</strong></p>
<ul>
<li><strong>XXL-Job:</strong> 由大众点评开源，是一个轻量级、易于上手的分布式任务调度平台。它功能完善，社区活跃，在国内被广泛使用。</li>
<li><strong>PowerJob:</strong> 新一代分布式计算与任务调度框架，功能更强大，支持 DAG（有向无环图）任务编排、MapReduce、任务分片等高级特性。</li>
</ul>
<p><strong>核心优势:</strong></p>
<ol>
<li><strong>可视化管理:</strong> 提供统一的 Web 界面，可以方便地管理所有任务、查看执行日志、监控执行器状态等，运维非常友好。</li>
<li><strong>高可用与解耦:</strong> 调度中心和业务应用完全解耦。调度中心可以独立部署为高可用集群，业务应用的扩缩容或宕机不影响调度中心的稳定性。</li>
<li><strong>强大的分布式特性:</strong><ul>
<li><strong>路由策略:</strong> 可以灵活地选择哪个执行器实例来运行任务（如轮询、随机、故障转移、分片广播等）。</li>
<li><strong>任务分片:</strong> 可以将一个海量数据处理任务平均分配给多个执行器实例并行处理，极大提升处理效率。</li>
<li><strong>故障转移:</strong> 当某个执行器节点宕机时，调度中心能自动将任务 перенаправить (redirect) 到其他健康的节点上执行。</li>
<li><strong>生命周期管理:</strong> 完善的任务生命周期管理，包括任务超时控制、失败告警、执行日志追踪等。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-3-3-总结与选型对比"><a href="#1-3-3-总结与选型对比" class="headerlink" title="1.3.3 总结与选型对比"></a>1.3.3 总结与选型对比</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>@Scheduled</code> (Spring 内置)</th>
<th align="left">Quartz (企业级框架)</th>
<th align="left">分布式调度中心 (XXL-Job&#x2F;PowerJob)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>易用性</strong></td>
<td align="left"><strong>极高</strong> (一个注解搞定)</td>
<td align="left">较高 (需要理解核心概念)</td>
<td align="left">中等 (需要部署调度中心和集成执行器)</td>
</tr>
<tr>
<td align="left"><strong>动态管理</strong></td>
<td align="left">不支持 (需重启)</td>
<td align="left"><strong>支持</strong> (通过 API 动态管理)</td>
<td align="left"><strong>核心特性</strong> (通过 Web 界面管理)</td>
</tr>
<tr>
<td align="left"><strong>分布式支持</strong></td>
<td align="left">不支持 (会重复执行)</td>
<td align="left">支持集群模式 (通过DB锁)</td>
<td align="left"><strong>核心特性</strong> (原生分布式设计)</td>
</tr>
<tr>
<td align="left"><strong>监控与管理</strong></td>
<td align="left">无</td>
<td align="left">弱 (需自行实现)</td>
<td align="left"><strong>强大</strong> (提供统一的可视化管理后台)</td>
</tr>
<tr>
<td align="left"><strong>高级功能</strong></td>
<td align="left">无 (失败重试、分片等)</td>
<td align="left">有限支持</td>
<td align="left"><strong>非常丰富</strong> (分片、路由、故障转移、依赖)</td>
</tr>
<tr>
<td align="left"><strong>架构</strong></td>
<td align="left">内嵌在应用中</td>
<td align="left">内嵌在应用中 (可配置DB持久化)</td>
<td align="left"><strong>调度与执行分离</strong></td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">单体应用、简单的后台任务</td>
<td align="left">复杂的单体应用、需要动态管理任务的场景</td>
<td align="left"><strong>微服务架构、大规模分布式系统</strong>、复杂任务编排</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-缓存抽象-Caching-Abstraction"><a href="#2-缓存抽象-Caching-Abstraction" class="headerlink" title="2. 缓存抽象 (Caching Abstraction)"></a>2. 缓存抽象 (Caching Abstraction)</h2><p>Spring 缓存抽象的目标是提供一个统一的、与具体缓存技术无关的编程模型。开发者只需通过简单的注解，就能将缓存逻辑透明地集成到现有代码中，而无需关心底层使用的是 Redis、Caffeine 还是其他缓存实现。这极大地实现了<strong>业务逻辑与缓存逻辑的解耦</strong>。</p>
<p>与任务调度类似，使用缓存注解前，必须在 Spring Boot 的主启动类或任何配置类（<code>@Configuration</code>）上添加 <code>@EnableCaching</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span> <span class="comment">// 开启基于注解的缓存功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-核心注解"><a href="#2-1-核心注解" class="headerlink" title="2.1 核心注解"></a>2.1 核心注解</h3><h4 id="2-1-1-Cacheable：查询缓存"><a href="#2-1-1-Cacheable：查询缓存" class="headerlink" title="2.1.1 @Cacheable：查询缓存"></a>2.1.1 <code>@Cacheable</code>：查询缓存</h4><ul>
<li><strong>作用：</strong> 这是最常用的缓存注解。在方法执行前，Spring 会先根据 <code>key</code> 检查缓存中是否存在对应的数据。<ul>
<li><strong>如果缓存存在</strong>：直接返回缓存中的数据，<strong>方法体内的代码不会被执行</strong>。</li>
<li><strong>如果缓存不存在</strong>：执行方法，并将方法的返回值存入缓存，然后返回结果。</li>
</ul>
</li>
<li><strong>适用场景：</strong> 主要用于数据<strong>查询</strong>操作，对于读多写少的场景效果显著。</li>
<li><strong>常用属性：</strong><ul>
<li><code>value</code> &#x2F; <code>cacheNames</code>：指定要使用的缓存名称（可以是一个或多个）。例如，<code>cacheNames = &quot;users&quot;</code>。</li>
<li><code>key</code>：缓存的键。这是缓存中数据的唯一标识。支持使用 <strong>SpEL (Spring Expression Language)</strong> 动态生成。<ul>
<li>如果省略，Spring 会使用默认策略生成 key（通常是方法的参数组合）。</li>
<li><strong>强烈建议手动指定 <code>key</code></strong> 以保证其唯一性和可读性。</li>
</ul>
</li>
<li><code>condition</code>：条件成立时才进行缓存。SpEL 表达式，返回 <code>true</code> 时缓存，<code>false</code> 则不缓存。例如 <code>condition = &quot;#id &gt; 0&quot;</code>。</li>
<li><code>unless</code>：条件成立时<strong>不</strong>缓存方法的返回值。用于否决缓存，例如 <code>unless = &quot;#result == null&quot;</code>，表示如果方法返回 <code>null</code>，则不缓存。</li>
</ul>
</li>
<li><strong>代码示例：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设这是从数据库查询的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Cacheable(cacheNames = &quot;users&quot;, key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing findById from DB for ID: &quot;</span> + id);</span><br><span class="line">        <span class="comment">// 模拟数据库查询</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, <span class="string">&quot;User&quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>调用分析</strong>：</p>
<ul>
<li>第一次调用 <code>findById(1L)</code>：控制台打印 “Executing findById from DB…”，方法执行，返回值被存入名为 “users” 的缓存中，key 为 “1”。</li>
<li>第二次调用 <code>findById(1L)</code>：直接从缓存返回数据，控制台<strong>不会</strong>有任何打印，方法体未被执行。</li>
</ul>
</blockquote>
<hr>
<h4 id="2-1-2-CachePut：更新缓存"><a href="#2-1-2-CachePut：更新缓存" class="headerlink" title="2.1.2 @CachePut：更新缓存"></a>2.1.2 <code>@CachePut</code>：更新缓存</h4><ul>
<li><strong>作用：</strong> 与 <code>@Cacheable</code> 不同，<code>@CachePut</code> 会<strong>始终执行方法体</strong>，然后将方法的返回值更新（或放入）到缓存中。</li>
<li><strong>适用场景：</strong> 主要用于数据<strong>更新</strong>操作。它确保了在更新数据库的同时，也更新了缓存中的数据，保持数据一致性。</li>
<li><strong>常用属性：</strong><ul>
<li><code>value</code> &#x2F; <code>cacheNames</code>：同上。</li>
<li><code>key</code>：必须指定，且通常需要与查询时（<code>@Cacheable</code>）使用的 <code>key</code> 保持一致，这样才能正确更新同一条数据。</li>
</ul>
</li>
<li><strong>代码示例：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachePut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CachePut(cacheNames = &quot;users&quot;, key = &quot;#user.id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing updateUser in DB for user: &quot;</span> + user.getId());</span><br><span class="line">        <span class="comment">// 模拟更新数据库</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> user; <span class="comment">// 返回更新后的对象，该对象将被放入缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>调用分析</strong>：每次调用 <code>updateUser(user)</code>，控制台<strong>总是</strong>会打印 “Executing updateUser…”，并且缓存 “users” 中对应 key 的数据会被更新为方法返回的新 <code>user</code> 对象。</p>
</blockquote>
<hr>
<h4 id="2-1-3-CacheEvict：失效缓存"><a href="#2-1-3-CacheEvict：失效缓存" class="headerlink" title="2.1.3 @CacheEvict：失效缓存"></a>2.1.3 <code>@CacheEvict</code>：失效缓存</h4><ul>
<li><strong>作用：</strong> 从缓存中移除一条或多条数据。</li>
<li><strong>适用场景：</strong> 主要用于数据<strong>删除</strong>操作，或在某些更新操作后需要清除相关缓存的场景。</li>
<li><strong>常用属性：</strong><ul>
<li><code>value</code> &#x2F; <code>cacheNames</code>：同上。</li>
<li><code>key</code>：指定要移除的缓存键。</li>
<li><code>allEntries</code>：布尔值，默认为 <code>false</code>。如果设置为 <code>true</code>，则会清空整个缓存（<code>cacheNames</code> 指定的那个），而不仅仅是移除某个 <code>key</code> 对应的数据。</li>
<li><code>beforeInvocation</code>：布尔值，默认为 <code>false</code>。<ul>
<li><code>false</code>（默认）：在方法成功执行<strong>之后</strong>才清除缓存。如果方法执行失败并抛出异常，缓存不会被清除，保证了数据一致性。</li>
<li><code>true</code>：在方法执行<strong>之前</strong>就清除缓存。这种方式存在风险，如果方法后续执行失败，会导致缓存已删但数据未删的不一致状态。</li>
</ul>
</li>
</ul>
</li>
<li><strong>代码示例：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CacheEvict;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CacheEvict(cacheNames = &quot;users&quot;, key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executing deleteById from DB for ID: &quot;</span> + id);</span><br><span class="line">        <span class="comment">// 模拟从数据库删除</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(cacheNames = &quot;users&quot;, allEntries = true)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearAllUsersCache</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Clearing all users cache...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-4-Caching-和-CacheConfig：组合与配置"><a href="#2-1-4-Caching-和-CacheConfig：组合与配置" class="headerlink" title="2.1.4 @Caching 和 @CacheConfig：组合与配置"></a>2.1.4 <code>@Caching</code> 和 <code>@CacheConfig</code>：组合与配置</h4><ul>
<li><p><strong><code>@Caching</code>：</strong> 当一个方法需要应用多个不同类型的缓存注解时，可以使用 <code>@Caching</code> 将它们组合在一起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Caching(</span></span><br><span class="line"><span class="meta">    put = &#123; @CachePut(cacheNames = &quot;user&quot;, key = &quot;#user.id&quot;) &#125;,</span></span><br><span class="line"><span class="meta">    evict = &#123; @CacheEvict(cacheNames = &quot;userList&quot;, allEntries = true) &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上述代码表示，在保存用户后，更新单个用户缓存，并清空用户列表缓存。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@CacheConfig</code>：</strong> 类级别的注解，用于抽取该类中所有缓存注解的公共配置，如 <code>cacheNames</code>。这有助于简化代码，避免重复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames = &quot;users&quot;)</span> <span class="comment">// 在类级别统一配置缓存名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(Long id)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CachePut(key = &quot;#user.id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-2-CacheManager-与-Cache-接口"><a href="#2-2-CacheManager-与-Cache-接口" class="headerlink" title="2.2 CacheManager 与 Cache 接口"></a>2.2 <code>CacheManager</code> 与 <code>Cache</code> 接口</h3><p><code>@Cacheable</code> 等注解之所以能工作，是因为 Spring AOP 在背后做了一系列操作。当我们调用一个带有缓存注解的方法时，Spring 的一个拦截器会介入，而这个拦截器正是通过 <code>CacheManager</code> 和 <code>Cache</code> 这两个核心接口来完成实际的缓存读写。</p>
<p><strong>从注解到接口：揭秘幕后工作原理</strong></p>
<p>让我们以 <code>@Cacheable(cacheNames = &quot;users&quot;, key = &quot;#id&quot;)</code> 为例，看看其背后发生了什么：</p>
<ol>
<li><strong>方法调用被拦截</strong>：当 <code>findById(1L)</code> 方法被调用时，Spring AOP 的缓存切面（<code>CacheInterceptor</code>）会首先拦截这个调用。</li>
<li><strong>获取 <code>CacheManager</code></strong>：拦截器会从 Spring 容器中获取已配置的 <code>CacheManager</code> Bean。</li>
<li><strong>获取 <code>Cache</code> 对象</strong>：拦截器调用 <code>cacheManager.getCache(&quot;users&quot;)</code> 方法，向管理器索要一个名为 “users” 的 <code>Cache</code> 实例。如果这个 <code>Cache</code> 不存在，<code>CacheManager</code> 可能会动态创建一个。</li>
<li><strong>在 <code>Cache</code> 中查找数据</strong>：拦截器根据注解中的 <code>key</code> 属性（<code>#id</code>，解析为 <code>1L</code>）作为键，调用 <code>cache.get(1L)</code> 方法在 <code>Cache</code> 实例中查找数据。</li>
<li><strong>决策与执行</strong>：<ul>
<li><strong>缓存命中</strong>：如果 <code>cache.get(1L)</code> 返回了非 <code>null</code> 的值，拦截器就直接将这个值返回给调用方，<strong>原始的 <code>findById</code> 方法体完全不会执行</strong>。</li>
<li><strong>缓存未命中</strong>：如果 <code>cache.get(1L)</code> 返回 <code>null</code>，拦截器会继续执行原始的 <code>findById</code> 方法。</li>
</ul>
</li>
<li><strong>填充缓存</strong>：方法执行成功后，拦截器会获取其返回值，然后调用 <code>cache.put(1L, returnedUserObject)</code>，将结果存入缓存中，以便下次使用。</li>
</ol>
<hr>
<h4 id="2-2-1-CacheManager-接口：缓存管理器"><a href="#2-2-1-CacheManager-接口：缓存管理器" class="headerlink" title="2.2.1 CacheManager 接口：缓存管理器"></a>2.2.1 <code>CacheManager</code> 接口：缓存管理器</h4><p><code>CacheManager</code> 是 Spring 缓存抽象的中心接口。你可以把它理解为一个<strong>工厂和注册中心</strong>，它负责管理应用中所有 <code>Cache</code> 实例的生命周期。</p>
<p><strong>核心职责：</strong></p>
<ul>
<li><strong>管理缓存集合</strong>：它维护着一个 <code>Cache</code> 实例的集合，每个 <code>Cache</code> 都有一个唯一的名称。</li>
<li><strong>提供 <code>Cache</code> 实例</strong>：其最核心的方法是 <code>getCache(String name)</code>，用于根据名称获取一个具体的 <code>Cache</code> 对象。</li>
<li><strong>配置入口</strong>：在 Spring 配置中，我们主要配置的就是 <code>CacheManager</code>。通过配置不同的 <code>CacheManager</code> 实现类，我们可以决定应用底层使用哪种缓存技术（如 Redis, Caffeine, EhCache 等），并对其进行统一的全局设置（如过期时间、最大容量等）。</li>
</ul>
<p><strong>常见的 <code>CacheManager</code> 实现类（由 Spring Boot 自动配置提供）：</strong></p>
<ul>
<li><code>ConcurrentMapCacheManager</code>：默认的实现，使用 <code>ConcurrentHashMap</code>作为底层存储，主要用于开发和测试，功能简单，不支持持久化和过期策略。</li>
<li><code>CaffeineCacheManager</code>：集成高性能的本地缓存库 Caffeine。</li>
<li><code>RedisCacheManager</code>：集成 Redis 作为分布式缓存。</li>
<li><code>EhCacheCacheManager</code>：集成经典的 EhCache 缓存库。</li>
<li><code>CompositeCacheManager</code>：一个组合管理器，可以让你同时使用多种不同类型的 <code>CacheManager</code>。</li>
</ul>
<hr>
<h4 id="2-2-2-Cache-接口：缓存本身"><a href="#2-2-2-Cache-接口：缓存本身" class="headerlink" title="2.2.2 Cache 接口：缓存本身"></a>2.2.2 <code>Cache</code> 接口：缓存本身</h4><p><code>Cache</code> 接口是对缓存这一概念的直接抽象，它定义了所有缓存都应具备的基本操作。无论底层是 <code>HashMap</code> 还是 Redis，它们都被统一封装为 <code>Cache</code> 接口。</p>
<p><strong>核心方法：</strong></p>
<ul>
<li><code>String getName()</code>: 获取此缓存的名称。</li>
<li><code>Object getNativeCache()</code>: 返回底层的、实际的缓存对象（例如，返回一个 <code>com.github.benmanes.caffeine.cache.Cache</code> 实例或一个 Redis 连接），这允许你在需要时绕过 Spring 的抽象，直接使用特定缓存技术的高级功能。</li>
<li><code>ValueWrapper get(Object key)</code>: 根据键从缓存中获取值。注意返回值是 <code>ValueWrapper</code>，这是为了能区分“缓存值为 <code>null</code>”和“缓存中不存在该键”这两种情况。如果键不存在，此方法返回 <code>null</code>；如果键存在但其值为 <code>null</code>，则返回一个包含 <code>null</code> 的 <code>ValueWrapper</code> 对象。</li>
<li><code>&lt;T&gt; T get(Object key, Class&lt;T&gt; type)</code>: 一个方便的泛型版本，直接返回指定类型的值。</li>
<li><code>void put(Object key, Object value)</code>: 将一个键值对存入缓存。</li>
<li><code>void evict(Object key)</code>: 从缓存中移除一个键对应的数据。</li>
<li><code>void clear()</code>: 清空整个缓存中的所有数据。</li>
</ul>
<hr>
<h4 id="2-2-3-配置-CacheManager-Bean-以-Caffeine-为例"><a href="#2-2-3-配置-CacheManager-Bean-以-Caffeine-为例" class="headerlink" title="2.2.3 配置 CacheManager Bean (以 Caffeine 为例)"></a>2.2.3 配置 <code>CacheManager</code> Bean (以 Caffeine 为例)</h4><p>虽然 Spring Boot 提供了强大的自动配置，但有时我们需要更精细化的控制，比如为不同的缓存设置不同的过期时间。这时，我们可以自定义一个 <code>CacheManager</code> Bean 来覆盖默认配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 CaffeineCacheManager</span></span><br><span class="line">        <span class="type">CaffeineCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaffeineCacheManager</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置默认的缓存行为：写入后 10 分钟过期，最大容量 500</span></span><br><span class="line">        cacheManager.setCaffeine(Caffeine.newBuilder()</span><br><span class="line">                .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES)</span><br><span class="line">                .maximumSize(<span class="number">500</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要为特定的 cache name (如 &quot;users&quot;) 进行单独配置，可以这样做：</span></span><br><span class="line">        <span class="comment">// cacheManager.registerCustomCache(&quot;users&quot;,</span></span><br><span class="line">        <span class="comment">//     Caffeine.newBuilder()</span></span><br><span class="line">        <span class="comment">//         .expireAfterWrite(30, TimeUnit.MINUTES)</span></span><br><span class="line">        <span class="comment">//         .maximumSize(100)</span></span><br><span class="line">        <span class="comment">//         .build()</span></span><br><span class="line">        <span class="comment">// );</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong>：一旦你在配置类中定义了这样一个 <code>CacheManager</code> Bean，Spring Boot 将不会再使用它的默认自动配置，而是采用你提供的这个实例。</p>
</blockquote>
<hr>
<h4 id="2-2-4-编程式缓存操作：手动控制缓存"><a href="#2-2-4-编程式缓存操作：手动控制缓存" class="headerlink" title="2.2.4 编程式缓存操作：手动控制缓存"></a>2.2.4 编程式缓存操作：手动控制缓存</h4><p>除了使用注解，我们也可以在代码中直接注入 <code>CacheManager</code>，手动地对缓存进行读写。这在一些逻辑复杂、注解难以表达的场景下非常有用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManualCacheService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CacheManager cacheManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取名为 &quot;users&quot; 的 Cache 对象</span></span><br><span class="line">        <span class="type">Cache</span> <span class="variable">usersCache</span> <span class="operator">=</span> cacheManager.getCache(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (usersCache == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cache &#x27;users&#x27; is not configured.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 尝试从缓存中获取数据</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> usersCache.get(id, User.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Manual cache hit for ID: &quot;</span> + id);</span><br><span class="line">            <span class="keyword">return</span> user; <span class="comment">// 缓存命中，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 缓存未命中，从数据库查询</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Manual cache miss. Fetching from DB for ID: &quot;</span> + id);</span><br><span class="line">        user = findUserInDatabase(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将查询结果放入缓存</span></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            usersCache.put(id, user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User <span class="title function_">findUserInDatabase</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟数据库查询</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, <span class="string">&quot;User&quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子完整地展示了不使用注解的情况下，如何通过 <code>CacheManager</code> 和 <code>Cache</code> 接口实现与 <code>@Cacheable</code> 完全相同的逻辑。</p>
<hr>
<h3 id="2-3-常用缓存提供商集成"><a href="#2-3-常用缓存提供商集成" class="headerlink" title="2.3 常用缓存提供商集成"></a>2.3 常用缓存提供商集成</h3><p>Spring 的缓存抽象本身不提供缓存的存储实现，它只是一套标准和规范。我们需要集成第三方的缓存技术来作为“提供商”（Provider），为这套规范提供具体的实现。</p>
<p>得益于 Spring Boot 强大的自动配置能力，集成这些提供商通常只需要两步：</p>
<ol>
<li><strong>添加依赖</strong>：在 <code>pom.xml</code> 中引入相应的 Starter。</li>
<li><strong>修改配置</strong>：在 <code>application.properties</code> 或 <code>application.yml</code> 中指定使用哪种缓存类型。</li>
</ol>
<p>下面我们介绍三种最主流的缓存提供商：<strong>Caffeine</strong>（本地缓存）、<strong>Redis</strong>（分布式缓存）和 <strong>EhCache</strong>（传统本地&#x2F;磁盘缓存）。</p>
<hr>
<h4 id="2-3-1-Caffeine：高性能本地缓存"><a href="#2-3-1-Caffeine：高性能本地缓存" class="headerlink" title="2.3.1 Caffeine：高性能本地缓存"></a>2.3.1 Caffeine：高性能本地缓存</h4><ul>
<li><strong>简介</strong>：Caffeine 是一个基于 Java 8 的、近乎最优的高性能本地缓存库，被认为是 Google Guava Cache 的“继任者”。它提供了丰富的缓存过期策略、容量控制和命中率统计等功能。</li>
<li><strong>适用场景</strong>：<ul>
<li>单体应用或对性能要求极高的场景。</li>
<li>缓存那些读多写少、可以接受短暂不一致的数据（因为每个应用实例都有自己的独立缓存）。</li>
<li>不需要在多个服务实例间共享缓存。</li>
</ul>
</li>
</ul>
<p><strong>集成步骤：</strong></p>
<p><strong>① 添加依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot 缓存抽象的 Starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Caffeine 缓存库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>② 开启缓存：</strong> 确保主类上有 <code>@EnableCaching</code> 注解。</p>
<p><strong>③ 修改配置 (<code>application.yml</code>)：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="comment"># 1. 告诉 Spring Boot 使用 Caffeine 作为缓存提供商</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">caffeine</span></span><br><span class="line">    <span class="comment"># 2. 配置 Caffeine 的规格 (spec)</span></span><br><span class="line">    <span class="attr">caffeine:</span></span><br><span class="line">      <span class="comment"># spec 是一种简洁的字符串格式，用于定义缓存的各种行为</span></span><br><span class="line">      <span class="comment"># initialCapacity: 初始容量</span></span><br><span class="line">      <span class="comment"># maximumSize: 最大容量</span></span><br><span class="line">      <span class="comment"># expireAfterWrite: 写入后多久过期</span></span><br><span class="line">      <span class="comment"># expireAfterAccess: 最后一次访问后多久过期</span></span><br><span class="line">      <span class="comment"># refreshAfterWrite: 写入后多久异步刷新</span></span><br><span class="line">      <span class="attr">spec:</span> <span class="string">initialCapacity=100,maximumSize=500,expireAfterWrite=10m</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>完成！</strong> 现在你项目中的所有 <code>@Cacheable</code> 等注解都会自动使用配置好的 Caffeine 缓存。无需修改任何 Java 代码。</p>
</blockquote>
<hr>
<h4 id="2-3-2-Redis：行业标准的分布式缓存"><a href="#2-3-2-Redis：行业标准的分布式缓存" class="headerlink" title="2.3.2 Redis：行业标准的分布式缓存"></a>2.3.2 Redis：行业标准的分布式缓存</h4><ul>
<li><strong>简介</strong>：Redis 是一个开源的、基于内存的键值对数据库，常被用作数据库、缓存和消息中间件。作为分布式缓存，它的数据独立于应用服务，可以被多个服务实例共享。</li>
<li><strong>适用场景</strong>：<ul>
<li>微服务架构或分布式集群环境。</li>
<li>需要跨多个服务实例共享缓存数据（例如，用户登录状态 Session 共享）。</li>
<li>缓存数据需要在应用重启后依然存在。</li>
</ul>
</li>
</ul>
<p><strong>集成步骤：</strong></p>
<p><strong>① 添加依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot 缓存抽象的 Starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring Boot Data Redis 的 Starter (它包含了 Redis 客户端和核心依赖) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>② 开启缓存：</strong> 确保主类上有 <code>@EnableCaching</code> 注解。</p>
<p><strong>③ 修改配置 (<code>application.yml</code>)：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># Redis 服务器连接配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment"># password: your-password</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="comment"># 1. 告诉 Spring Boot 使用 Redis 作为缓存提供商</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="comment"># 2. 配置 Redis 缓存的全局行为</span></span><br><span class="line">      <span class="comment"># 设置全局的缓存过期时间，例如 30 分钟</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="string">30m</span></span><br><span class="line">      <span class="comment"># 是否缓存 null 值，防止缓存穿透</span></span><br><span class="line">      <span class="attr">cache-null-values:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># key 的前缀，避免与其他 Redis 应用的 key 冲突</span></span><br><span class="line">      <span class="attr">key-prefix: myapp:cache:</span></span><br><span class="line">      <span class="comment"># 是否使用前缀</span></span><br><span class="line">      <span class="attr">use-key-prefix:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>④ (重要) 配置序列化方式：</strong></p>
<p>默认情况下，Spring 使用 JDK 的序列化方式将 Java 对象存入 Redis，这会导致 Redis 中存储的是二进制乱码，可读性差且有跨语言兼容性问题。<strong>生产环境中强烈推荐使用 JSON 格式序列化</strong>。</p>
<p>创建一个配置类来定义 <code>RedisCacheConfiguration</code> Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCacheConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisCacheConfiguration <span class="title function_">redisCacheConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">            <span class="comment">// 设置 key 的序列化方式为 String</span></span><br><span class="line">            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>()))</span><br><span class="line">            <span class="comment">// 设置 value 的序列化方式为 JSON</span></span><br><span class="line">            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-3-EhCache：传统的-JCache-实现"><a href="#2-3-3-EhCache：传统的-JCache-实现" class="headerlink" title="2.3.3 EhCache：传统的 JCache 实现"></a>2.3.3 EhCache：传统的 JCache 实现</h4><ul>
<li><strong>简介</strong>：EhCache 是一个成熟的、开源的 Java 缓存框架，它完全实现了 JCache (JSR-107) 标准。它支持内存、堆外内存和磁盘等多种存储层级。</li>
<li><strong>适用场景</strong>：<ul>
<li>需要遵循 JCache 标准的项目。</li>
<li>需要在应用重启后从磁盘恢复缓存数据的单体应用。</li>
<li>一些遗留项目或对 EhCache 有深厚技术栈依赖的团队。</li>
</ul>
</li>
</ul>
<p><strong>集成步骤：</strong></p>
<p><strong>① 添加依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- JCache API --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.cache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cache-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- EhCache 3 实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>② 创建配置文件 <code>ehcache.xml</code></strong>：</p>
<p>在 <code>src/main/resources</code> 目录下创建 <code>ehcache.xml</code> 文件来定义缓存。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">config</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns</span>=<span class="string">&quot;http://www.ehcache.org/v3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.ehcache.org/v3 http://www.ehcache.org/schema/ehcache-core-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义一个名为 &quot;users&quot; 的缓存 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">alias</span>=<span class="string">&quot;users&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key-type</span>&gt;</span>java.lang.Long<span class="tag">&lt;/<span class="name">key-type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value-type</span>&gt;</span>com.example.myapp.model.User<span class="tag">&lt;/<span class="name">value-type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">expiry</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 缓存 10 分钟 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ttl</span> <span class="attr">unit</span>=<span class="string">&quot;minutes&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">ttl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">expiry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 堆内存中最多存储 100 个条目 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">heap</span> <span class="attr">unit</span>=<span class="string">&quot;entries&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">heap</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>③ 修改配置 (<code>application.yml</code>)：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="comment"># 1. 告诉 Spring Boot 使用 JCache (EhCache 是其实现)</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">jcache</span></span><br><span class="line">    <span class="comment"># 2. 指定 JCache 配置文件的位置</span></span><br><span class="line">    <span class="attr">jcache:</span></span><br><span class="line">      <span class="attr">config:</span> <span class="string">classpath:ehcache.xml</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-4-总结与对比"><a href="#2-3-4-总结与对比" class="headerlink" title="2.3.4 总结与对比"></a>2.3.4 总结与对比</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Caffeine</th>
<th align="left">Redis</th>
<th align="left">EhCache</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类型</strong></td>
<td align="left"><strong>本地缓存</strong> (In-Memory)</td>
<td align="left"><strong>分布式缓存</strong> (Remote)</td>
<td align="left"><strong>本地缓存</strong> (In-Memory, Disk)</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">单体应用、高性能读缓存</td>
<td align="left">微服务、分布式集群、需要数据共享</td>
<td align="left">JCache 标准项目、需要磁盘持久化的单体应用</td>
</tr>
<tr>
<td align="left"><strong>数据共享</strong></td>
<td align="left">否 (各实例独立)</td>
<td align="left">是 (所有实例共享)</td>
<td align="left">否 (可持久化到磁盘)</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left"><strong>极高</strong> (无网络开销)</td>
<td align="left">高 (有网络开销)</td>
<td align="left">较高 (磁盘模式下较慢)</td>
</tr>
<tr>
<td align="left"><strong>依赖</strong></td>
<td align="left">仅 Java 库</td>
<td align="left">需要独立的 Redis Server</td>
<td align="left">仅 Java 库</td>
</tr>
<tr>
<td align="left"><strong>配置复杂度</strong></td>
<td align="left">简单 (yml)</td>
<td align="left">中等 (yml + 序列化配置)</td>
<td align="left">中等 (yml + xml)</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-邮件发送-Mail"><a href="#3-邮件发送-Mail" class="headerlink" title="3. 邮件发送 (Mail)"></a>3. 邮件发送 (Mail)</h2><p>在现代 Web 应用中，邮件发送是一项基础且不可或缺的功能，广泛应用于用户注册验证、消息通知、营销推广等场景。</p>
<p>Spring Framework 通过 <code>spring-context-support</code> 模块提供了对 JavaMail API 的高级抽象，极大地简化了邮件发送的实现。开发者无需再处理底层的、复杂的邮件协议（如 SMTP）和会话管理，只需与 Spring 提供的高层接口交互即可。</p>
<h3 id="3-1-JavaMailSender"><a href="#3-1-JavaMailSender" class="headerlink" title="3.1 JavaMailSender"></a>3.1 <code>JavaMailSender</code></h3><p><code>JavaMailSender</code> 是 Spring 邮件抽象的核心接口，它继承自 JavaMail 的 <code>MailSender</code> 接口，并为其增加了对 <code>MimeMessage</code> 的支持，使其能够发送更复杂的邮件（如包含 HTML 内容、附件或内联图片的邮件）。</p>
<p>你可以将 <code>JavaMailSender</code> 理解为 Spring 为你准备好的一个“邮件发送客户端”，它已经封装好了所有与邮件服务器通信的细节。</p>
<h4 id="3-1-1-集成-spring-boot-starter-mail"><a href="#3-1-1-集成-spring-boot-starter-mail" class="headerlink" title="3.1.1 集成 spring-boot-starter-mail"></a>3.1.1 集成 <code>spring-boot-starter-mail</code></h4><p>Spring Boot 提供了专门的 Mail Starter，它会自动配置 <code>JavaMailSender</code> Bean，我们只需要添加依赖并提供必要的配置。</p>
<p><strong>① 添加 Maven 依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>② 在 <code>application.yml</code> 中配置邮件服务器信息：</strong></p>
<p>以 QQ 邮箱为例（其他邮箱类似，如 163、Gmail 等）。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="comment"># 邮件服务器地址</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.qq.com</span></span><br><span class="line">    <span class="comment"># 邮件服务器端口 (SSL 加密通常是 465 或 587)</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">465</span></span><br><span class="line">    <span class="comment"># 发件人邮箱账号</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">your-email@qq.com</span></span><br><span class="line">    <span class="comment"># 关键：这里不是邮箱的登录密码，而是开启 SMTP 服务后生成的 &quot;授权码&quot;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">your-authorization-code</span></span><br><span class="line">    <span class="comment"># 协议</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">smtp</span></span><br><span class="line">    <span class="comment"># 其他属性</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">mail:</span></span><br><span class="line">        <span class="attr">smtp:</span></span><br><span class="line">          <span class="comment"># 开启 SSL 加密</span></span><br><span class="line">          <span class="attr">ssl:</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">          <span class="comment"># 身份验证</span></span><br><span class="line">          <span class="attr">auth:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>重要提示</strong>：<code>spring.mail.password</code> 属性对于大多数公共邮箱服务（如 QQ、163、Gmail）来说，<strong>不是你的登录密码</strong>，而是在邮箱设置中开启 SMTP 服务时生成的专用<strong>授权码</strong>或<strong>应用密码</strong>。</p>
</blockquote>
<hr>
<h4 id="3-1-2-注入并使用-JavaMailSender"><a href="#3-1-2-注入并使用-JavaMailSender" class="headerlink" title="3.1.2 注入并使用 JavaMailSender"></a>3.1.2 注入并使用 <code>JavaMailSender</code></h4><p>配置完成后，Spring Boot 会自动创建一个 <code>JavaMailSender</code> 的实例并放入 IoC 容器。我们可以在任何 Spring Bean（如 <code>@Service</code>）中直接 <code>@Autowired</code> 注入它。</p>
<p><strong>1. 发送简单文本邮件 (<code>SimpleMailMessage</code>)</strong></p>
<p><code>SimpleMailMessage</code> 是一个简单的 JavaBean，用于封装纯文本邮件的基本信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从配置文件中获取发件人邮箱</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fromEmail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送一封简单的文本邮件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to 收件人地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject 邮件主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content 邮件正文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSimpleMail</span><span class="params">(String to, String subject, String content)</span> &#123;</span><br><span class="line">        <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line">        message.setFrom(fromEmail); <span class="comment">// 发件人</span></span><br><span class="line">        message.setTo(to); <span class="comment">// 收件人</span></span><br><span class="line">        message.setSubject(subject); <span class="comment">// 主题</span></span><br><span class="line">        message.setText(content); <span class="comment">// 正文</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mailSender.send(message);</span><br><span class="line">            System.out.println(<span class="string">&quot;简单邮件发送成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;发送简单邮件时发生异常！&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 发送复杂邮件 (<code>MimeMessage</code>)</strong></p>
<p>对于需要发送 HTML、附件或内联图片的邮件，我们需要使用 <code>MimeMessage</code>。Spring 提供了 <code>MimeMessageHelper</code> 类来简化 <code>MimeMessage</code> 的创建过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="comment">// ... (注入 mailSender 和 fromEmail 同上)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送一封复杂的邮件（HTML + 附件 + 内联资源）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to 收件人</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject 主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> htmlContent HTML 内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attachmentPath 附件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inlineImagePath 内联图片路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rscId 内联资源的 Content-ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendComplexMail</span><span class="params">(String to, String subject, String htmlContent,</span></span><br><span class="line"><span class="params">                                String attachmentPath, String inlineImagePath, String rscId)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 MimeMessage 实例</span></span><br><span class="line">        <span class="type">MimeMessage</span> <span class="variable">mimeMessage</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// MimeMessageHelper：true 表示创建一个 multipart message</span></span><br><span class="line">            <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(mimeMessage, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            helper.setFrom(fromEmail);</span><br><span class="line">            helper.setTo(to);</span><br><span class="line">            helper.setSubject(subject);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置 HTML 内容 (第二个参数 true 表示这是一个 HTML)</span></span><br><span class="line">            helper.setText(htmlContent, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加附件</span></span><br><span class="line">            <span class="keyword">if</span> (attachmentPath != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">FileSystemResource</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="keyword">new</span> <span class="title class_">File</span>(attachmentPath));</span><br><span class="line">                <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file.getFilename();</span><br><span class="line">                helper.addAttachment(fileName, file);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加内联资源 (例如，在 HTML 中通过 cid:rscId 引用)</span></span><br><span class="line">            <span class="comment">// &lt;img src=&#x27;cid:rscId&#x27; /&gt;</span></span><br><span class="line">            <span class="keyword">if</span> (inlineImagePath != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">FileSystemResource</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="keyword">new</span> <span class="title class_">File</span>(inlineImagePath));</span><br><span class="line">                helper.addInline(rscId, res);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mailSender.send(mimeMessage);</span><br><span class="line">            System.out.println(<span class="string">&quot;复杂邮件发送成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;发送复杂邮件时发生异常！&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-3-最佳实践与注意事项"><a href="#3-1-3-最佳实践与注意事项" class="headerlink" title="3.1.3 最佳实践与注意事项"></a>3.1.3 最佳实践与注意事项</h4><ul>
<li><strong>异步发送</strong>：邮件发送是一个网络 I&#x2F;O 操作，可能会有延迟，阻塞当前线程。在 Web 应用中，强烈建议将邮件发送操作<strong>异步化</strong>。只需在发送方法上添加 <code>@Async</code> 注解，并开启异步支持（<code>@EnableAsync</code>），即可让邮件在后台线程池中发送，从而立即响应用户请求。</li>
<li><strong>模板引擎</strong>：硬编码 HTML 字符串是不好的实践。应该集成模板引擎（如 Thymeleaf, FreeMarker）来动态生成邮件内容，实现视图与逻辑的分离，使邮件模板更易于维护。</li>
<li><strong>异常处理</strong>：邮件发送可能会因为网络问题、认证失败等原因抛出 <code>MailException</code>。必须进行适当的 <code>try-catch</code> 处理，记录日志，甚至可以实现失败重试机制。</li>
<li><strong>安全性</strong>：避免在代码中硬编码敏感信息（如邮箱密码&#x2F;授权码），应始终将其放在配置文件中，并通过版本控制系统（如 Git）的 <code>.gitignore</code> 文件忽略该配置文件，防止敏感信息泄露。</li>
</ul>
<hr>
<h3 id="3-2-发送简单邮件、附件邮件、内联资源邮件"><a href="#3-2-发送简单邮件、附件邮件、内联资源邮件" class="headerlink" title="3.2 发送简单邮件、附件邮件、内联资源邮件"></a>3.2 发送简单邮件、附件邮件、内联资源邮件</h3><p>在 <code>JavaMailSender</code> 的基础上，Spring 提供了不同的消息对象和辅助类来构建这三类邮件。我们将分别展示它们的具体实现。</p>
<p>为了方便演示，我们假设已经创建了一个 <code>MailService</code> 类，并注入了 <code>JavaMailSender</code> 和发件人邮箱地址 <code>fromEmail</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fromEmail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 下面的方法都将定义在这个类中 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-1-发送简单文本邮件-Simple-Text-Mail"><a href="#3-2-1-发送简单文本邮件-Simple-Text-Mail" class="headerlink" title="3.2.1 发送简单文本邮件 (Simple Text Mail)"></a>3.2.1 发送简单文本邮件 (Simple Text Mail)</h4><p>这是最基础的邮件形式，只包含纯文本内容，没有任何格式、图片或附件。</p>
<ul>
<li><strong>核心类</strong>：<code>org.springframework.mail.SimpleMailMessage</code></li>
<li><strong>特点</strong>：构建简单，开销小，适用于发送验证码、系统通知等场景。</li>
</ul>
<p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送一封简单的文本邮件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to 收件人地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subject 邮件主题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> content 邮件正文 (纯文本)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSimpleMail</span><span class="params">(String to, String subject, String content)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个简单的邮件消息对象</span></span><br><span class="line">    <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置邮件的基本信息</span></span><br><span class="line">    message.setFrom(fromEmail);</span><br><span class="line">    message.setTo(to);</span><br><span class="line">    message.setSubject(subject);</span><br><span class="line">    message.setText(content);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 发送邮件</span></span><br><span class="line">        mailSender.send(message);</span><br><span class="line">        System.out.println(<span class="string">&quot;简单文本邮件发送成功！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;发送简单文本邮件时发生异常: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-2-发送带附件的邮件-Mail-with-Attachments"><a href="#3-2-2-发送带附件的邮件-Mail-with-Attachments" class="headerlink" title="3.2.2 发送带附件的邮件 (Mail with Attachments)"></a>3.2.2 发送带附件的邮件 (Mail with Attachments)</h4><p>当需要在邮件中附加文件（如报告、发票、图片等）时，就需要创建一封 “multipart” (多部分) 格式的邮件。</p>
<ul>
<li><strong>核心类</strong>：<code>javax.mail.internet.MimeMessage</code></li>
<li><strong>辅助类</strong>：<code>org.springframework.mail.javamail.MimeMessageHelper</code></li>
<li><strong>关键方法</strong>：<code>helper.addAttachment(String attachmentFilename, InputStreamSource inputStreamSource)</code></li>
</ul>
<p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送一封带附件的邮件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to 收件人地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subject 邮件主题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> content 邮件正文 (可以是 HTML)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath 附件的文件路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendAttachmentMail</span><span class="params">(String to, String subject, String content, String filePath)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 MimeMessage 对象</span></span><br><span class="line">    <span class="type">MimeMessage</span> <span class="variable">mimeMessage</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 MimeMessageHelper 来构建邮件，true 表示需要创建一个 multipart message</span></span><br><span class="line">        <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(mimeMessage, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置邮件的基本信息</span></span><br><span class="line">        helper.setFrom(fromEmail);</span><br><span class="line">        helper.setTo(to);</span><br><span class="line">        helper.setSubject(subject);</span><br><span class="line">        helper.setText(content, <span class="literal">true</span>); <span class="comment">// true 表示邮件内容为 HTML 格式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加附件</span></span><br><span class="line">        <span class="type">FileSystemResource</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="keyword">new</span> <span class="title class_">File</span>(filePath));</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file.getFilename(); <span class="comment">// 获取文件名</span></span><br><span class="line">        <span class="keyword">if</span> (fileName != <span class="literal">null</span>) &#123;</span><br><span class="line">            helper.addAttachment(fileName, file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送邮件</span></span><br><span class="line">        mailSender.send(mimeMessage);</span><br><span class="line">        System.out.println(<span class="string">&quot;附件邮件发送成功！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;发送附件邮件时发生异常: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-3-发送带内联资源的邮件-Mail-with-Inline-Resources"><a href="#3-2-3-发送带内联资源的邮件-Mail-with-Inline-Resources" class="headerlink" title="3.2.3 发送带内联资源的邮件 (Mail with Inline Resources)"></a>3.2.3 发送带内联资源的邮件 (Mail with Inline Resources)</h4><p>内联资源（通常是图片）是指嵌入到邮件正文中、作为内容一部分显示的资源，而不是作为单独的附件。这常用于创建图文并茂的富文本邮件。</p>
<ul>
<li><strong>核心类</strong>：<code>javax.mail.internet.MimeMessage</code></li>
<li><strong>辅助类</strong>：<code>org.springframework.mail.javamail.MimeMessageHelper</code></li>
<li><strong>关键方法</strong>：<code>helper.addInline(String contentId, Resource resource)</code></li>
<li><strong>核心机制</strong>：通过 <code>Content-ID</code> (cid) 将 HTML 中的 <code>&lt;img&gt;</code> 标签与邮件中的内联资源关联起来。</li>
</ul>
<p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送一封带内联资源的邮件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to 收件人地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subject 邮件主题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> imagePath 内联图片的路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendInlineResourceMail</span><span class="params">(String to, String subject, String imagePath)</span> &#123;</span><br><span class="line">    <span class="comment">// 这是我们的 HTML 邮件内容，注意看 img 标签的 src 属性</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">rscId</span> <span class="operator">=</span> <span class="string">&quot;logo001&quot;</span>; <span class="comment">// 定义一个内容ID (Content-ID)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">htmlContent</span> <span class="operator">=</span> <span class="string">&quot;&lt;html&gt;&lt;body&gt;&quot;</span> +</span><br><span class="line">                         <span class="string">&quot;&lt;h1&gt;这是一封带内联图片的邮件&lt;/h1&gt;&quot;</span> +</span><br><span class="line">                         <span class="string">&quot;&lt;h3&gt;图片如下：&lt;/h3&gt;&quot;</span> +</span><br><span class="line">                         <span class="string">&quot;&lt;img src=&#x27;cid:&quot;</span> + rscId + <span class="string">&quot;&#x27; /&gt;&quot;</span> + <span class="comment">// 使用 cid: 引用内联资源</span></span><br><span class="line">                         <span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">MimeMessage</span> <span class="variable">mimeMessage</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(mimeMessage, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        helper.setFrom(fromEmail);</span><br><span class="line">        helper.setTo(to);</span><br><span class="line">        helper.setSubject(subject);</span><br><span class="line">        helper.setText(htmlContent, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加内联资源</span></span><br><span class="line">        <span class="type">FileSystemResource</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="keyword">new</span> <span class="title class_">File</span>(imagePath));</span><br><span class="line">        <span class="comment">// 使用 addInline 方法，第一个参数是 Content-ID，必须与 HTML 中的 cid 一致</span></span><br><span class="line">        helper.addInline(rscId, res);</span><br><span class="line"></span><br><span class="line">        mailSender.send(mimeMessage);</span><br><span class="line">        System.out.println(<span class="string">&quot;内联资源邮件发送成功！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;发送内联资源邮件时发生异常: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-4-总结与对比"><a href="#3-2-4-总结与对比" class="headerlink" title="3.2.4 总结与对比"></a>3.2.4 总结与对比</h4><table>
<thead>
<tr>
<th align="left">邮件类型</th>
<th align="left">核心类&#x2F;辅助类</th>
<th align="left">关键方法&#x2F;步骤</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>简单文本邮件</strong></td>
<td align="left"><code>SimpleMailMessage</code></td>
<td align="left">直接设置 <code>from</code>, <code>to</code>, <code>subject</code>, <code>text</code> 属性。</td>
<td align="left">发送纯文本通知、验证码等。</td>
</tr>
<tr>
<td align="left"><strong>附件邮件</strong></td>
<td align="left"><code>MimeMessage</code> + <code>MimeMessageHelper</code></td>
<td align="left"><code>new MimeMessageHelper(mimeMessage, true)</code><br/><code>helper.addAttachment(...)</code></td>
<td align="left">发送报告、文档、合同等文件。</td>
</tr>
<tr>
<td align="left"><strong>内联资源邮件</strong></td>
<td align="left"><code>MimeMessage</code> + <code>MimeMessageHelper</code></td>
<td align="left"><code>helper.addInline(contentId, ...)</code><br/>在HTML中使用 <code>&lt;img src=&#39;cid:contentId&#39;&gt;</code></td>
<td align="left">创建图文并茂的营销邮件、欢迎邮件等。</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-3-模板邮件发送"><a href="#3-3-模板邮件发送" class="headerlink" title="3.3 模板邮件发送"></a>3.3 模板邮件发送</h3><p>在前面的示例中，我们直接在 Java 代码中拼接 HTML 字符串来构建邮件内容。这种方式存在明显的问题：</p>
<ul>
<li><strong>难以维护</strong>：HTML 代码和 Java 逻辑混杂在一起，可读性差。如果邮件样式需要修改，就必须改动 Java 代码并重新编译部署。</li>
<li><strong>职责不清</strong>：开发人员需要关心邮件的视觉样式，而 UI&#x2F;UX 设计师无法直接参与邮件模板的设计。</li>
<li><strong>复用性差</strong>：无法轻松地复用邮件的布局和结构。</li>
</ul>
<p><strong>解决方案</strong>：使用<strong>模板引擎</strong>。模板引擎允许我们将邮件的结构和样式定义在独立的模板文件中，将动态数据与静态布局分离。在发送邮件时，程序会加载模板，用具体的数据填充模板中的占位符，最终生成完整的 HTML 内容。</p>
<p>Spring Boot 与多种模板引擎都能完美集成，其中最常用的是 <strong>Thymeleaf</strong> 和 <strong>FreeMarker</strong>。我们以 Thymeleaf 为例进行详细说明。</p>
<p><strong>核心流程</strong></p>
<ol>
<li><strong>添加依赖</strong>：引入模板引擎的 Starter。</li>
<li><strong>创建模板</strong>：在 <code>src/main/resources/templates/</code> 目录下创建一个 HTML 模板文件。</li>
<li><strong>处理模板</strong>：在 Java 代码中，注入 <code>TemplateEngine</code>，创建一个数据模型（<code>Context</code>），然后调用 <code>process</code> 方法来渲染模板，生成最终的 HTML 字符串。</li>
<li><strong>发送邮件</strong>：将生成的 HTML 字符串作为邮件正文发送。</li>
</ol>
<hr>
<h4 id="3-3-1-集成-Thymeleaf"><a href="#3-3-1-集成-Thymeleaf" class="headerlink" title="3.3.1 集成 Thymeleaf"></a>3.3.1 集成 Thymeleaf</h4><p>在 <code>pom.xml</code> 中添加 Thymeleaf 的 Starter。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-3-2-创建邮件模板"><a href="#3-3-2-创建邮件模板" class="headerlink" title="3.3.2 创建邮件模板"></a>3.3.2 创建邮件模板</h4><p>在 <code>src/main/resources/templates/</code> 目录下创建一个名为 <code>mailTemplate.html</code> 的文件。Thymeleaf 的语法非常自然，可以直接用浏览器打开预览。</p>
<p><strong><code>mailTemplate.html</code> 示例：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>邮件模板<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>您好, <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>!<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>欢迎您注册我们的服务！这是您的验证码：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: blue; font-weight: bold; font-size: 20px;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;verificationCode&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>请在5分钟内使用。如果您没有请求此验证码，请忽略本邮件。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>感谢您的支持！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>-- Spring Boot 团队<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code>: 引入 Thymeleaf 的命名空间。</li>
<li><code>th:text=&quot;${...}&quot;</code>: 这是 Thymeleaf 的核心语法，用于将 <code>${...}</code> 中变量的值替换掉标签内的文本。<code>${username}</code> 和 <code>${verificationCode}</code> 就是我们稍后需要从 Java 代码中传入的动态数据。</li>
</ul>
<hr>
<h4 id="3-3-3-实现模板邮件发送服务"><a href="#3-3-3-实现模板邮件发送服务" class="headerlink" title="3.3.3 实现模板邮件发送服务"></a>3.3.3 实现模板邮件发送服务</h4><p>在 <code>MailService</code> 中，我们需要注入 Thymeleaf 的 <code>TemplateEngine</code>，并创建一个新方法来处理和发送模板邮件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TemplateEngine templateEngine; <span class="comment">// 注入模板引擎</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fromEmail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送基于 Thymeleaf 模板的邮件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to 收件人</span></span><br><span class="line"><span class="comment">     *   subject 主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名 (模板中的变量)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> verificationCode 验证码 (模板中的变量)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendTemplateMail</span><span class="params">(String to, String subject, String username, String verificationCode)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个 Thymeleaf 的上下文对象 (Context)</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 设置模板中需要替换的变量</span></span><br><span class="line">        context.setVariable(<span class="string">&quot;username&quot;</span>, username);</span><br><span class="line">        context.setVariable(<span class="string">&quot;verificationCode&quot;</span>, verificationCode);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 使用模板引擎渲染模板，生成最终的 HTML 字符串</span></span><br><span class="line">        <span class="comment">// 第一个参数是模板文件的名称 (相对于 templates/ 目录，无需 .html 后缀)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">emailContent</span> <span class="operator">=</span> templateEngine.process(<span class="string">&quot;mailTemplate&quot;</span>, context);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 创建 MimeMessage 并发送</span></span><br><span class="line">        <span class="type">MimeMessage</span> <span class="variable">mimeMessage</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(mimeMessage, <span class="literal">true</span>);</span><br><span class="line">            helper.setFrom(fromEmail);</span><br><span class="line">            helper.setTo(to);</span><br><span class="line">            helper.setSubject(subject);</span><br><span class="line">            helper.setText(emailContent, <span class="literal">true</span>); <span class="comment">// true 表示内容是 HTML</span></span><br><span class="line"></span><br><span class="line">            mailSender.send(mimeMessage);</span><br><span class="line">            System.out.println(<span class="string">&quot;模板邮件发送成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;发送模板邮件时发生异常: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优势与最佳实践</strong></p>
<ul>
<li><strong>彻底的职责分离</strong>：设计师可以专注于 <code>mailTemplate.html</code> 的美化，而程序员只需关心如何准备数据和调用发送逻辑。</li>
<li><strong>代码整洁</strong>：Java 代码中不再有大段的、丑陋的 HTML 字符串。</li>
<li><strong>国际化 (i18n)</strong>：Thymeleaf 等模板引擎通常具有强大的国际化支持。你可以为不同语言创建不同的模板或资源文件，根据用户的语言环境发送相应语言的邮件。</li>
<li><strong>逻辑处理</strong>：模板引擎通常支持条件判断（<code>th:if</code>）、循环（<code>th:each</code>）等简单逻辑，可以构建非常复杂的动态邮件内容（如订单确认邮件中的商品列表）。</li>
<li><strong>异步发送</strong>：模板渲染和邮件发送都应该是异步的。在 <code>sendTemplateMail</code> 方法上添加 <code>@Async</code> 注解，可以确保用户请求被立即响应，而耗时的邮件任务在后台执行。</li>
</ul>
<hr>
<h2 id="4-异步执行-Asynchronous-Execution"><a href="#4-异步执行-Asynchronous-Execution" class="headerlink" title="4. 异步执行 (Asynchronous Execution)"></a>4. 异步执行 (Asynchronous Execution)</h2><p>在同步执行模型中，当一个方法被调用时，调用者必须等待该方法完全执行完毕并返回结果后，才能继续执行后续的代码。对于一些耗时较长的操作（如文件上传、数据批量处理、发送邮件&#x2F;短信、调用慢速的第三方 API），这种同步等待会严重影响系统性能和用户体验，导致线程长时间阻塞，降低系统的吞吐量。</p>
<p>异步执行则解决了这个问题。它允许将耗时的任务提交给一个独立的后台线程（通常来自一个线程池）来执行，而调用者线程则可以立即返回，继续处理其他事情，无需等待。</p>
<p><strong>核心优势：</strong></p>
<ul>
<li><strong>提升响应速度</strong>：特别是在 Web 应用中，可以将非核心的耗时操作异步化，从而快速响应用户请求，改善用户体验。</li>
<li><strong>提高系统吞吐量</strong>：通过将任务分配给专门的线程池，可以更有效地利用 CPU 资源，并发处理更多任务。</li>
<li><strong>任务解耦</strong>：将主流程与耗时任务解耦，使系统架构更清晰、更具弹性。</li>
</ul>
<p>Spring 框架通过 <code>@Async</code> 注解，提供了一种非侵入式的、声明式的方式来实现方法的异步调用。</p>
<h3 id="4-1-Async-注解"><a href="#4-1-Async-注解" class="headerlink" title="4.1 @Async 注解"></a>4.1 <code>@Async</code> 注解</h3><p><code>@Async</code> 是 Spring 提供的一个方法级别的注解。当它被应用到一个方法上时，Spring 会为该方法创建一个代理。当这个被代理的方法被调用时，Spring 会将实际的方法执行逻辑提交到一个线程池中异步执行，并立即返回一个 <code>Future</code> 对象给调用者。</p>
<h4 id="4-1-1-开启异步支持"><a href="#4-1-1-开启异步支持" class="headerlink" title="4.1.1 开启异步支持"></a>4.1.1 开启异步支持</h4><p>要使 <code>@Async</code> 注解生效，必须在 Spring Boot 的主启动类或任何一个配置类（<code>@Configuration</code>）上添加 <code>@EnableAsync</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span> <span class="comment">// 开启异步方法执行功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@EnableAsync</code> 注解会激活 Spring 对 <code>@Async</code> 注解的发现和代理机制。</p>
<h4 id="4-1-2-创建异步方法"><a href="#4-1-2-创建异步方法" class="headerlink" title="4.1.2 创建异步方法"></a>4.1.2 创建异步方法</h4><p>在一个 Spring Bean 中（如 <code>@Service</code> 或 <code>@Component</code>），将 <code>@Async</code> 注解添加到需要异步执行的 public 方法上。</p>
<h5 id="1-无返回值的异步方法-void"><a href="#1-无返回值的异步方法-void" class="headerlink" title="1. 无返回值的异步方法 (void)"></a>1. 无返回值的异步方法 (<code>void</code>)</h5><p>这是最简单的异步场景，常用于“执行并忘记”(fire-and-forget) 的任务，如记录日志、发送通知等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncTaskService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始发送邮件... 当前线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟耗时 3 秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;邮件发送完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncTaskService asyncTaskService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test-async&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testAsync</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Controller 开始执行... 当前线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        asyncTaskService.sendEmail(); <span class="comment">// 立即返回，不会等待 3 秒</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Controller 执行完毕！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Async task submitted!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>执行结果分析</strong>：</p>
<p>访问 <code>/test-async</code> 接口，你会立即在控制台看到：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Controller 开始执行... 当前线程: http-nio-8080-exec-1</span><br><span class="line">Controller 执行完毕！</span><br><span class="line">开始发送邮件... 当前线程: task-1  &lt;-- 注意！线程名变了</span><br></pre></td></tr></table></figure>

<p>大约 3 秒后，才会看到：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">邮件发送完成！</span><br></pre></td></tr></table></figure>

<p>这证明了 <code>sendEmail()</code> 方法是在一个名为 <code>task-1</code> 的后台线程中执行的，而主线程 <code>http-nio-8080-exec-1</code> 没有被阻塞。</p>
</blockquote>
<hr>
<h5 id="2-有返回值的异步方法-Future-CompletableFuture"><a href="#2-有返回值的异步方法-Future-CompletableFuture" class="headerlink" title="2. 有返回值的异步方法 (Future &#x2F; CompletableFuture)"></a>2. 有返回值的异步方法 (<code>Future</code> &#x2F; <code>CompletableFuture</code>)</h5><p>如果调用者需要获取异步任务的执行结果（或检查其执行状态），异步方法的返回值类型必须是 <code>java.util.concurrent.Future</code>、<code>java.util.concurrent.CompletableFuture</code> 或 Spring 的 <code>org.springframework.util.concurrent.ListenableFuture</code>。</p>
<p><code>CompletableFuture</code> (Java 8+) 是目前推荐的方式，因为它功能更强大，支持链式调用和回调。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncTaskService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">fetchUserData</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始获取用户数据... 当前线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟耗时 5 秒</span></span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;User data fetched successfully!&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户数据获取完成！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(result); <span class="comment">// 将结果包装在 CompletableFuture 中返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callAsyncWithResult</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始调用异步任务...&quot;</span>);</span><br><span class="line">    CompletableFuture&lt;String&gt; future = asyncTaskService.fetchUserData();</span><br><span class="line">    System.out.println(<span class="string">&quot;异步任务已提交，主线程继续执行其他事情...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 在这里可以做其他工作 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当需要结果时，调用 get() 方法阻塞等待</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get(); <span class="comment">// 这行会阻塞，直到异步任务完成</span></span><br><span class="line">    System.out.println(<span class="string">&quot;获取到异步任务的结果: &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-1-3-重要使用规则与陷阱"><a href="#4-1-3-重要使用规则与陷阱" class="headerlink" title="4.1.3 重要使用规则与陷阱"></a>4.1.3 重要使用规则与陷阱</h4><p><code>@Async</code> 的实现依赖于 Spring AOP 代理，因此必须遵守 AOP 的使用规则，否则注解会失效：</p>
<ol>
<li><p><strong>只能应用于 public 方法</strong>：<code>@Async</code> 对 <code>protected</code>、<code>private</code> 或包级私有的方法无效。</p>
</li>
<li><p><strong>方法必须定义在 Spring Bean 中</strong>：该方法所在的类必须被 Spring 容器管理（例如，有 <code>@Service</code>, <code>@Component</code> 等注解）。</p>
</li>
<li><p><strong>避免类内部调用 (self-invocation)</strong>：</p>
<ul>
<li><p><strong>错误示例</strong>：在同一个类中，一个 <code>public</code> 方法调用同一个类的另一个 <code>@Async</code> 方法，异步会失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncMethod</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syncMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这样调用是错误的！异步不会生效！</span></span><br><span class="line">        <span class="built_in">this</span>.asyncMethod(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原因</strong>：<code>syncMethod</code> 通过 <code>this</code> 关键字调用 <code>asyncMethod</code>，这是直接的对象内部调用，绕过了 Spring 创建的代理对象，因此 AOP 切面无法拦截，异步逻辑也就无法触发。</p>
</li>
<li><p><strong>解决方案</strong>：将 <code>@Async</code> 方法移到另一个独立的 Bean 中，然后通过注入的方式来调用它。</p>
</li>
</ul>
</li>
<li><p><strong>默认线程池</strong>：Spring Boot 会自动配置一个 <code>ThreadPoolTaskExecutor</code> 作为默认的异步线程池。如果需要更精细的控制（如核心线程数、队列容量、拒绝策略等），建议自定义线程池。我们将在下一节详细讨论。</p>
</li>
</ol>
<hr>
<h3 id="4-2-自定义线程池"><a href="#4-2-自定义线程池" class="headerlink" title="4.2 自定义线程池"></a>4.2 自定义线程池</h3><h4 id="4-2-1-为什么需要自定义线程池？"><a href="#4-2-1-为什么需要自定义线程池？" class="headerlink" title="4.2.1 为什么需要自定义线程池？"></a>4.2.1 为什么需要自定义线程池？</h4><p>Spring Boot 会为 <code>@Async</code>  提供一个默认的线程池（<code>ThreadPoolTaskExecutor</code>）。虽然开箱即用很方便，但在生产环境中，依赖默认配置通常是不够的，原因如下：</p>
<ol>
<li><strong>资源隔离与控制</strong>：默认情况下，所有 <code>@Async</code> 任务共享同一个线程池。如果一种类型的异步任务（如文件处理）执行得非常慢且数量巨大，它可能会占满所有线程，导致其他更重要的异步任务（如发送验证码）被阻塞或延迟执行。通过为不同类型的业务创建不同的线程池，可以实现资源隔离。</li>
<li><strong>精细化配置</strong>：默认线程池的参数（如核心线程数、最大线程数、队列容量）可能不适合你的应用负载。例如，对于 I&#x2F;O 密集型任务，你可能需要更多的线程；对于 CPU 密集型任务，线程数通常设置为 CPU 核心数左右。自定义线程池允许你根据业务特性进行精细化配置。</li>
<li><strong>命名与监控</strong>：为线程池指定一个有意义的名称（如 <code>email-task-executor</code>），可以在日志和监控工具（如 JMX, Prometheus）中清晰地识别出是哪个线程池在执行任务，便于问题排查和性能分析。</li>
<li><strong>拒绝策略</strong>：当线程池和任务队列都满了之后，新提交的任务该如何处理？默认的拒绝策略可能会抛出异常。你可以自定义拒绝策略，例如记录日志后丢弃、由调用者线程自己执行等。</li>
</ol>
<hr>
<h4 id="4-2-2-实现方式"><a href="#4-2-2-实现方式" class="headerlink" title="4.2.2 实现方式"></a>4.2.2 实现方式</h4><p>在 Spring 中自定义线程池主要有两种方式：</p>
<ol>
<li><strong>重写默认线程池</strong>：通过定义一个特定类型的 Bean 来覆盖 Spring Boot 的默认配置。</li>
<li><strong>创建多个线程池</strong>：定义多个 <code>TaskExecutor</code> Bean，并在 <code>@Async</code> 注解中指定使用哪一个。</li>
</ol>
<h5 id="1-重写默认的异步线程池"><a href="#1-重写默认的异步线程池" class="headerlink" title="1. 重写默认的异步线程池"></a>1. 重写默认的异步线程池</h5><p>如果你希望整个应用的所有 <code>@Async</code> 调用都使用统一的、自定义配置的线程池，可以创建一个 <code>TaskExecutor</code> 类型的 Bean。Spring Boot 在自动配置时，如果发现容器中已经存在一个 <code>TaskExecutor</code> Bean，就会使用它，而不再创建默认的。</p>
<p><strong>实现步骤：</strong></p>
<p>在一个配置类（<code>@Configuration</code>）中定义一个 <code>Bean</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;taskExecutor&quot;)</span> <span class="comment">// Bean 的名称可以自定义，Spring 会优先寻找名为 &quot;taskExecutor&quot; 的 Bean</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">taskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 核心线程数：线程池创建时初始化的线程数</span></span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>); </span><br><span class="line">        <span class="comment">// 最大线程数：线程池最大的线程数，只有在缓冲队列满了之后才会申请超过核心线程数的线程</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">20</span>); </span><br><span class="line">        <span class="comment">// 缓冲队列：用来缓冲执行任务的队列</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 允许线程的空闲时间 (当超过核心线程数时，多余的线程会被销毁)</span></span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">        <span class="comment">// 线程池名的前缀：设置好了之后可以方便我们定位处理任务所在的线程池</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;default-async-&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 拒绝策略：当线程池和队列都满了，表明达到了最大处理能力，该如何处理新来的任务</span></span><br><span class="line">        <span class="comment">// AbortPolicy: 直接抛出 RejectedExecutionException 异常 (默认)</span></span><br><span class="line">        <span class="comment">// CallerRunsPolicy: 由调用者线程处理该任务</span></span><br><span class="line">        <span class="comment">// DiscardPolicy: 丢弃最新的任务，不处理</span></span><br><span class="line">        <span class="comment">// DiscardOldestPolicy: 丢弃队列最前面的任务，然后重新尝试执行当前任务</span></span><br><span class="line">        <span class="comment">// executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待所有任务结束后再关闭线程池</span></span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong>：完成以上配置后，所有未指定线程池的 <code>@Async</code> 方法都会自动使用这个名为 <code>taskExecutor</code> 的线程池。</p>
</blockquote>
<hr>
<h5 id="2-创建并使用多个线程池"><a href="#2-创建并使用多个线程池" class="headerlink" title="2. 创建并使用多个线程池"></a>2. 创建并使用多个线程池</h5><p>这是一种更灵活、更推荐的方式，尤其是在复杂的应用中。你可以为不同业务场景创建专用的线程池。</p>
<p><strong>实现步骤：</strong></p>
<p><strong>在配置类中定义多个 <code>Executor</code> Bean，并为它们指定唯一的名称。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultipleAsyncConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池一：用于处理邮件发送任务</span></span><br><span class="line">    <span class="meta">@Bean(&quot;emailTaskExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">emailTaskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">5</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">50</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;email-async-&quot;</span>);</span><br><span class="line">        <span class="comment">// 拒绝策略：由调用者线程执行，确保邮件不会轻易丢失</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程池二：用于处理数据分析任务 (CPU 密集型)</span></span><br><span class="line">    <span class="meta">@Bean(&quot;dataAnalysisTaskExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">dataAnalysisTaskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">// CPU 密集型任务，线程数不宜过多</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">coreCount</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">        executor.setCorePoolSize(coreCount);</span><br><span class="line">        executor.setMaxPoolSize(coreCount * <span class="number">2</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">100</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;data-analysis-async-&quot;</span>);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在使用 <code>@Async</code> 注解时，通过其 <code>value</code> 属性指定要使用的线程池 Bean 的名称。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指定使用名为 &quot;emailTaskExecutor&quot; 的线程池</span></span><br><span class="line">    <span class="meta">@Async(&quot;emailTaskExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送邮件... 当前线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">// ... 邮件发送逻辑 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataAnalysisService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定使用名为 &quot;dataAnalysisTaskExecutor&quot; 的线程池</span></span><br><span class="line">    <span class="meta">@Async(&quot;dataAnalysisTaskExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">analyzeData</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;分析数据... 当前线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">// ... 复杂的数据计算逻辑 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：如果 <code>@Async</code> 注解没有指定 <code>value</code>，它会去寻找名为 <code>taskExecutor</code> 的 Bean，或者 Spring Boot 的默认线程池。</p>
</blockquote>
<hr>
<h4 id="4-2-3-总结"><a href="#4-2-3-总结" class="headerlink" title="4.2.3 总结"></a>4.2.3 总结</h4><ul>
<li><strong>默认配置用于开发</strong>：Spring Boot 的默认异步线程池适合快速开发和简单场景。</li>
<li><strong>自定义用于生产</strong>：在生产环境中，<strong>强烈建议</strong>根据业务需求自定义一个或多个线程池。</li>
<li><strong>资源隔离是关键</strong>：为不同类型的异步任务（特别是重要程度、耗时特性不同的任务）分配独立的线程池，是保证系统稳定性的重要手段。</li>
<li><strong>合理配置参数</strong>：线程池的核心参数（<code>corePoolSize</code>, <code>maxPoolSize</code>, <code>queueCapacity</code>）需要根据任务是 <strong>CPU 密集型</strong>还是 <strong>I&#x2F;O 密集型</strong>，以及系统的负载情况来综合评估和调整。</li>
</ul>
<hr>
<h3 id="4-3-异步返回值"><a href="#4-3-异步返回值" class="headerlink" title="4.3 异步返回值"></a>4.3 异步返回值</h3><p>当一个 <code>@Async</code> 方法的返回类型是 <code>void</code> 时，它是一个“即发即忘”(fire-and-forget)的任务。调用者无法得知任务何时完成，也无法获取其执行结果或捕获其内部抛出的异常。</p>
<p>为了解决这个问题，Spring 的 <code>@Async</code> 方法支持返回特定的类型，这些类型充当了未来某个时间点才会产生的“结果占位符”。</p>
<p>主流的异步返回值类型有三种：<code>Future</code>、<code>CompletableFuture</code> 和 Spring 自带的 <code>ListenableFuture</code>。</p>
<hr>
<h4 id="4-3-1-Future：经典的异步结果句柄"><a href="#4-3-1-Future：经典的异步结果句柄" class="headerlink" title="4.3.1 Future&lt;T&gt;：经典的异步结果句柄"></a>4.3.1 <code>Future&lt;T&gt;</code>：经典的异步结果句柄</h4><p><code>java.util.concurrent.Future</code> 是 Java 5 引入的标准接口，代表一个异步计算的结果。</p>
<p><strong>工作方式：</strong></p>
<p>当调用返回 <code>Future&lt;T&gt;</code> 的 <code>@Async</code> 方法时，调用会立即返回一个 <code>Future</code> 对象。这个对象是一个“句柄”，你可以通过它来检查任务是否完成、取消任务，或者<strong>阻塞等待</strong>并获取最终的结果。</p>
<p><strong>实现示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.AsyncResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;String&gt; <span class="title function_">findUser</span><span class="params">(String username)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始查找用户: &quot;</span> + username + <span class="string">&quot; on thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;用户信息: &quot;</span> + username;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 Spring 提供的 AsyncResult 来包装结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AsyncResult</span>&lt;&gt;(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用方如何使用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callFutureTask</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程发起异步调用...&quot;</span>);</span><br><span class="line">    Future&lt;String&gt; futureResult = futureTaskService.findUser(<span class="string">&quot;JohnDoe&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!futureResult.isDone()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程正在做其他事情，同时检查异步任务是否完成...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isDone() 返回 true 后，调用 get() 不会阻塞或只会短暂阻塞</span></span><br><span class="line">    <span class="comment">// 如果在 isDone() 为 false 时调用 get()，主线程会一直阻塞直到任务完成</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureResult.get(); </span><br><span class="line">    System.out.println(<span class="string">&quot;获取到异步结果: &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>Future</code> 的局限性：</strong></p>
<ul>
<li><strong>阻塞式获取结果</strong>：<code>future.get()</code> 是一个阻塞操作。虽然任务是异步执行的，但为了获取结果，主线程最终还是得停下来等待。</li>
<li><strong>无法链式操作</strong>：你不能方便地指定“当任务A完成后，用它的结果去执行任务B”。这种编排逻辑写起来非常笨拙。</li>
<li><strong>无回调机制</strong>：<code>Future</code> 没有提供一个“任务完成后请通知我”的回调机制，你只能通过 <code>isDone()</code> 去轮询，效率低下。</li>
</ul>
<hr>
<h4 id="4-3-2-CompletableFuture：推荐的现代异步编程方式"><a href="#4-3-2-CompletableFuture：推荐的现代异步编程方式" class="headerlink" title="4.3.2 CompletableFuture&lt;T&gt;：推荐的现代异步编程方式"></a>4.3.2 <code>CompletableFuture&lt;T&gt;</code>：推荐的现代异步编程方式</h4><p><code>java.util.concurrent.CompletableFuture</code> 是 Java 8 引入的，它不仅实现了 <code>Future</code> 接口，还实现了 <code>CompletionStage</code> 接口，提供了极其强大的函数式、非阻塞的异步编程能力。<strong>它是目前处理异步返回值的最佳选择。</strong></p>
<p><strong>工作方式：</strong></p>
<p>它支持<strong>回调</strong>和<strong>链式调用</strong>。你可以定义一系列操作，当异步任务完成时，这些操作会自动被触发，整个过程可以做到非阻塞。</p>
<p><strong>实现示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureTaskService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async(&quot;taskExecutor&quot;)</span> <span class="comment">// 推荐指定一个线程池</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">processData</span><span class="params">(String data)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始处理数据: &quot;</span> + data + <span class="string">&quot; on thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        Thread.sleep(<span class="number">4000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;error&quot;</span>.equals(data)) &#123;</span><br><span class="line">            <span class="comment">// 模拟异常情况</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid data provided&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;处理结果: &quot;</span> + data.toUpperCase();</span><br><span class="line">        <span class="comment">// 使用工厂方法返回一个已完成的 CompletableFuture</span></span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：如果 <code>@Async</code> 方法内部抛出异常，Spring 会自动捕获它，并返回一个“异常完成”的 <code>CompletableFuture</code>。</p>
</blockquote>
<p><strong>调用方如何使用（展示其强大之处）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callCompletableFutureTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程发起异步调用...&quot;</span>);</span><br><span class="line">    CompletableFuture&lt;String&gt; future = completableFutureTaskService.processData(<span class="string">&quot;my-data&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链式调用：非阻塞地定义后续操作</span></span><br><span class="line">    future.thenApply(result -&gt; &#123;</span><br><span class="line">        <span class="comment">// 当 future 完成时，这个转换操作会被执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一步转换 on thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Transformed -&gt; &quot;</span> + result;</span><br><span class="line">    &#125;).thenAccept(finalResult -&gt; &#123;</span><br><span class="line">        <span class="comment">// 当上一步转换完成后，这个消费操作会被执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最终结果消费: &quot;</span> + finalResult + <span class="string">&quot; on thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">        <span class="comment">// 如果在任何一步出现异常，这个处理器会被调用</span></span><br><span class="line">        System.err.println(<span class="string">&quot;发生异常: &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 返回一个默认值或 null</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;主线程已设置好回调，继续执行自己的任务，完全不阻塞。&quot;</span>);</span><br><span class="line">    <span class="comment">// 主线程可以继续做其他事情，例如等待其他任务或直接结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>CompletableFuture</code> 的核心优势</strong>：</p>
<ul>
<li><strong>非阻塞回调</strong>：通过 <code>thenApply</code>, <code>thenAccept</code>, <code>thenRun</code> 等方法，可以定义任务完成后自动执行的逻辑。</li>
<li><strong>强大的组合能力</strong>：可以通过 <code>thenCombine</code>（组合两个异步结果）、<code>allOf</code>（等待所有任务完成）、<code>anyOf</code>（等待任一任务完成）等方法编排复杂的异步工作流。</li>
<li><strong>优雅的异常处理</strong>：通过 <code>exceptionally</code> 和 <code>handle</code> 方法，可以集中处理异步链中的异常，代码更清晰。</li>
</ul>
</blockquote>
<hr>
<h4 id="4-3-3-ListenableFuture-已过时"><a href="#4-3-3-ListenableFuture-已过时" class="headerlink" title="4.3.3 ListenableFuture&lt;T&gt; (已过时)"></a>4.3.3 <code>ListenableFuture&lt;T&gt;</code> (已过时)</h4><p>这是 Spring 框架自己提供的一个接口，在 Java 8 的 <code>CompletableFuture</code> 出现之前，它用来弥补 <code>Future</code> 缺少回调机制的不足。</p>
<p>它的工作方式是通过 <code>addCallback</code> 方法注册成功和失败的回调。</p>
<p>由于 <code>CompletableFuture</code> 的功能更全面且已成为 Java 标准，<strong><code>ListenableFuture</code> 现在已经不推荐在新项目中使用。</strong> 了解即可。</p>
<hr>
<h4 id="4-3-4-总结对比"><a href="#4-3-4-总结对比" class="headerlink" title="4.3.4 总结对比"></a>4.3.4 总结对比</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>Future&lt;T&gt;</code></th>
<th align="left"><code>CompletableFuture&lt;T&gt;</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>获取结果</strong></td>
<td align="left"><strong>阻塞式</strong> (<code>get()</code> 方法)</td>
<td align="left"><strong>非阻塞</strong> (通过回调) 或 阻塞 (<code>get()</code>)</td>
</tr>
<tr>
<td align="left"><strong>编排能力</strong></td>
<td align="left"><strong>弱</strong>，难以组合多个异步任务</td>
<td align="left"><strong>强</strong>，支持链式调用 (<code>thenApply</code>) 和组合 (<code>thenCombine</code>)</td>
</tr>
<tr>
<td align="left"><strong>异常处理</strong></td>
<td align="left">笨拙 (通过 <code>try-catch ExecutionException</code>)</td>
<td align="left"><strong>优雅</strong> (通过 <code>exceptionally</code>, <code>handle</code> 回调)</td>
</tr>
<tr>
<td align="left"><strong>回调支持</strong></td>
<td align="left">不支持</td>
<td align="left"><strong>核心特性</strong></td>
</tr>
<tr>
<td align="left"><strong>Java 版本</strong></td>
<td align="left">Java 5+</td>
<td align="left">Java 8+</td>
</tr>
<tr>
<td align="left"><strong>推荐度</strong></td>
<td align="left">不推荐用于复杂场景</td>
<td align="left"><strong>强烈推荐</strong></td>
</tr>
</tbody></table>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/10/09/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/JavaServlet/" rel="prev" title="JavaServlet">
                  <i class="fa fa-angle-left"></i> JavaServlet
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/10/17/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/HTTP%E5%8D%8F%E8%AE%AE/" rel="next" title="HTTP协议">
                  HTTP协议 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
