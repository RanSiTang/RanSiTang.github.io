<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="一、HTTP 基础入门1. 什么是 HTTP？1.1 协议的定义：计算机之间的沟通语言在深入 HTTP 之前，先要明白**“协议 (Protocol)”**是什么。  现实世界中的类比：  语言：想象一下，一个说中文的人和一个说英语的人，如果他们之间没有一个共同的语言（比如都说英语）或者一个翻译，他们就无法沟通。这个“共同的语言”就是一种协议。 交通规则：红灯停，绿灯行。这是一个所有司机都必须遵守">
<meta property="og:type" content="article">
<meta property="og:title" content="HTTP协议">
<meta property="og:url" content="http://example.com/2025/10/17/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/HTTP%E5%8D%8F%E8%AE%AE/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="一、HTTP 基础入门1. 什么是 HTTP？1.1 协议的定义：计算机之间的沟通语言在深入 HTTP 之前，先要明白**“协议 (Protocol)”**是什么。  现实世界中的类比：  语言：想象一下，一个说中文的人和一个说英语的人，如果他们之间没有一个共同的语言（比如都说英语）或者一个翻译，他们就无法沟通。这个“共同的语言”就是一种协议。 交通规则：红灯停，绿灯行。这是一个所有司机都必须遵守">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-17T08:09:23.000Z">
<meta property="article:modified_time" content="2025-10-17T09:15:27.278Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/10/17/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/HTTP%E5%8D%8F%E8%AE%AE/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/10/17/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/HTTP%E5%8D%8F%E8%AE%AE/","path":"2025/10/17/Web协议服务器/HTTP协议/","title":"HTTP协议"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>HTTP协议 | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81HTTP-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8"><span class="nav-number">1.</span> <span class="nav-text">一、HTTP 基础入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-HTTP%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">1. 什么是 HTTP？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E6%B2%9F%E9%80%9A%E8%AF%AD%E8%A8%80"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 协议的定义：计算机之间的沟通语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-HTTP-%E7%9A%84%E5%85%A8%E7%A7%B0%EF%BC%9AHyperText-Transfer-Protocol"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2. HTTP 的全称：HyperText Transfer Protocol</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-HTTP-%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E4%BD%BF%E5%91%BD%EF%BC%9A%E4%B8%BA-Web-%E8%80%8C%E7%94%9F"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3. HTTP 的诞生与使命：为 Web 而生</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-HTTP-%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">1.2.</span> <span class="nav-text">2. HTTP 在网络世界中的位置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-TCP-IP-%E5%8D%8F%E8%AE%AE%E6%97%8F%E7%AE%80%E4%BB%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1. TCP&#x2F;IP 协议族简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%A7%92%E8%89%B2"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 应用层协议的角色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-HTTP-%E4%B8%8E-TCP%E3%80%81DNS-%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84%E7%BD%91%E9%A1%B5%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 HTTP 与 TCP、DNS 的关系：一次完整的网页请求过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-HTTP-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9"><span class="nav-number">1.3.</span> <span class="nav-text">3. HTTP 的核心特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-C-S-%E6%9E%B6%E6%9E%84"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 C&#x2F;S 架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E7%AE%80%E5%8D%95%E5%8F%AF%E6%89%A9%E5%B1%95"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 简单可扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%97%A0%E7%8A%B6%E6%80%81"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3 无状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.4 可靠传输</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81HTTP-%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">二、HTTP 报文结构详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%AE%A4%E8%AF%86-URL-%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6"><span class="nav-number">2.1.</span> <span class="nav-text">1. 认识 URL (统一资源定位符)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-URL-%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.1 URL 的组成部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-URI-URL-URN-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="nav-number">2.1.2.</span> <span class="nav-text">1.2 URI, URL, URN 的区别与联系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87-Request-Message"><span class="nav-number">2.2.</span> <span class="nav-text">2. 请求报文 (Request Message)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87-Response-Message"><span class="nav-number">2.3.</span> <span class="nav-text">3. 响应报文 (Response Message)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81HTTP-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E4%B8%8E%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">3.</span> <span class="nav-text">三、HTTP 请求方法与状态码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95-Methods"><span class="nav-number">3.1.</span> <span class="nav-text">1. 请求方法 (Methods)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%8A%B6%E6%80%81%E7%A0%81-Status-Codes"><span class="nav-number">3.2.</span> <span class="nav-text">2. 状态码 (Status Codes)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81HTTP-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%89%B9%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text">四、HTTP 核心机制与特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="nav-number">4.1.</span> <span class="nav-text">1. 连接管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%EF%BC%9ACookie-%E4%B8%8E-Session"><span class="nav-number">4.2.</span> <span class="nav-text">2. 状态管理：Cookie 与 Session</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6"><span class="nav-number">4.3.</span> <span class="nav-text">3. 缓存控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86"><span class="nav-number">4.4.</span> <span class="nav-text">4. 内容协商</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81HTTP-%E5%AE%89%E5%85%A8%EF%BC%9A%E4%BB%8E-HTTP-%E5%88%B0-HTTPS-Security"><span class="nav-number">5.</span> <span class="nav-text">五、HTTP 安全：从 HTTP 到 HTTPS (Security)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-HTTP-%E7%9A%84%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9"><span class="nav-number">5.1.</span> <span class="nav-text">1. HTTP 的安全风险</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-HTTPS-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">5.2.</span> <span class="nav-text">2. HTTPS 是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-SSL-TLS-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="nav-number">5.3.</span> <span class="nav-text">3. SSL&#x2F;TLS 握手过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%B8%B8%E8%A7%81%E7%9A%84-Web-%E5%AE%89%E5%85%A8%E5%A8%81%E8%83%81%E4%B8%8E-HTTP"><span class="nav-number">5.4.</span> <span class="nav-text">4. 常见的 Web 安全威胁与 HTTP</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/17/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/HTTP%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="HTTP协议 | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          HTTP协议
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-10-17 16:09:23 / 修改时间：17:15:27" itemprop="dateCreated datePublished" datetime="2025-10-17T16:09:23+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Web%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">Web协议与服务器</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="一、HTTP-基础入门"><a href="#一、HTTP-基础入门" class="headerlink" title="一、HTTP 基础入门"></a>一、HTTP 基础入门</h1><h2 id="1-什么是-HTTP？"><a href="#1-什么是-HTTP？" class="headerlink" title="1. 什么是 HTTP？"></a>1. 什么是 HTTP？</h2><h3 id="1-1-协议的定义：计算机之间的沟通语言"><a href="#1-1-协议的定义：计算机之间的沟通语言" class="headerlink" title="1.1 协议的定义：计算机之间的沟通语言"></a>1.1 协议的定义：计算机之间的沟通语言</h3><p>在深入 HTTP 之前，先要明白**“协议 (Protocol)”**是什么。</p>
<ul>
<li><p><strong>现实世界中的类比</strong>：</p>
<ul>
<li><strong>语言</strong>：想象一下，一个说中文的人和一个说英语的人，如果他们之间没有一个共同的语言（比如都说英语）或者一个翻译，他们就无法沟通。这个“共同的语言”就是一种协议。</li>
<li><strong>交通规则</strong>：红灯停，绿灯行。这是一个所有司机都必须遵守的规则，它确保了交通的有序和安全。这个“交通规则”也是一种协议。</li>
</ul>
</li>
<li><p><strong>计算机世界中的定义</strong>：<br>在计算机网络中，<strong>协议就是一套双方或多方都必须共同遵守的规则、标准或约定</strong>。它规定了计算机之间如何建立连接、如何交换信息。</p>
<p>协议通常定义了以下内容：</p>
<ul>
<li><strong>数据格式 (Syntax)</strong>：信息的结构和格式是怎样的？（比如，先发送什么，后发送什么，用什么编码？）</li>
<li><strong>语义 (Semantics)</strong>：信息中各个部分的具体含义是什么？（比如，某个代码 <code>200</code> 代表“成功”，<code>404</code> 代表“找不到”。）</li>
<li><strong>时序 (Timing)</strong>：通信的先后顺序是怎样的？（比如，谁先发起请求？收到请求后应该做什么？）</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>一句话总结</strong>：协议就是计算机世界的“普通话”，它让不同厂商、不同系统的计算机能够互相理解，协同工作。</p>
</blockquote>
<hr>
<h3 id="1-2-HTTP-的全称：HyperText-Transfer-Protocol"><a href="#1-2-HTTP-的全称：HyperText-Transfer-Protocol" class="headerlink" title="1.2. HTTP 的全称：HyperText Transfer Protocol"></a>1.2. HTTP 的全称：HyperText Transfer Protocol</h3><p>HTTP 的全称是 <strong>HyperText Transfer Protocol</strong>，即“<strong>超文本传输协议</strong>”。我们可以把这个名字拆开来理解：</p>
<ul>
<li><strong>HyperText (超文本)</strong><ul>
<li>它不仅仅是普通的纯文本。超文本指的是包含<strong>超链接 (Hyperlink)</strong> 的文本，可以从一个文本跳转到另一个文本或资源。</li>
<li>我们今天所说的“超文本”已经是一个广义的概念，它包括了网页中的所有内容，如：文字、图片、音频、视频、CSS 样式、JavaScript 脚本等。<strong>HTML (超文本标记语言)</strong> 是创建超文本最核心的语言。</li>
</ul>
</li>
<li><strong>Transfer (传输)</strong><ul>
<li>指将数据从一个地方搬运到另一个地方的过程。在 Web 中，通常是从<strong>服务器 (Server)</strong> 传输到<strong>客户端 (Client)</strong>。</li>
</ul>
</li>
<li><strong>Protocol (协议)</strong><ul>
<li>结合我们上面对协议的定义，它就是用来规范“超文本传输”这个过程的一整套规则。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>核心定义</strong>：将以上三部分组合起来，HTTP 的核心定义就非常清晰了：<strong>HTTP 是一个用于在万维网（World Wide Web）中，从 Web 服务器传输超文本资源到本地浏览器的传输协议。</strong></p>
</blockquote>
<p>简单来说，当你打开浏览器，输入一个网址（如 <code>www.google.com</code>）并按下回车时，你的浏览器就会使用 HTTP 协议，向谷歌的服务器发送一个“请求”，告诉它“我想要你的首页”；服务器收到请求后，同样使用 HTTP 协议，将首页的 HTML、CSS、图片等资源打包成一个“响应”，发送回你的浏览器。</p>
<hr>
<h3 id="1-3-HTTP-的诞生与使命：为-Web-而生"><a href="#1-3-HTTP-的诞生与使命：为-Web-而生" class="headerlink" title="1.3. HTTP 的诞生与使命：为 Web 而生"></a>1.3. HTTP 的诞生与使命：为 Web 而生</h3><p>HTTP 不是凭空出现的，它的诞生与<strong>万维网 (World Wide Web, WWW)</strong> 紧密相连。</p>
<ul>
<li><strong>背景</strong>：在 20 世纪 80 年代末，欧洲核子研究中心 (CERN) 的科学家们面临一个难题：研究资料和文档分散在世界各地不同的计算机上，查阅和分享极为不便。</li>
<li><strong>诞生</strong>：为了解决这个问题，英国科学家<strong>蒂姆·伯纳斯-李 (Tim Berners-Lee)</strong> 在 1989-1991 年间，发明了构建现代 Web 的三项核心技术：<ol>
<li><strong>HTML (HyperText Markup Language)</strong>：一种用于创建和组织网页内容的语言。</li>
<li><strong>URL (Uniform Resource Locator)</strong>：一种为互联网上每个资源提供唯一地址的方案，俗称“网址”。</li>
<li><strong>HTTP (HyperText Transfer Protocol)</strong>：一种用于获取这些资源的协议。</li>
</ol>
</li>
<li><strong>使命</strong>：<ul>
<li><strong>HTTP 的根本使命，就是作为万维网的信使和基石，实现全球范围内信息的自由流通和链接。</strong></li>
<li>它定义了一种简单、标准化的方式，让任何一个客户端（如浏览器）都可以向任何一个服务器请求任何一种资源（通过 URL 定位），并能正确地接收和解析它。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>总结一下</strong>：HTTP 的出现，使得“点击一个链接，就能跳转到另一个页面”这个革命性的想法得以实现。它就像是 Web 世界的快递系统，负责根据你提供的地址（URL），将你想要的包裹（HTML、图片等超文本资源）准确无误地送到你的手中（浏览器）。没有 HTTP，就没有我们今天丰富多彩的互联网世界。</p>
</blockquote>
<hr>
<h2 id="2-HTTP-在网络世界中的位置"><a href="#2-HTTP-在网络世界中的位置" class="headerlink" title="2. HTTP 在网络世界中的位置"></a>2. HTTP 在网络世界中的位置</h2><p>HTTP 协议位于计算机网络协议栈的顶端——<strong>应用层</strong>。要理解这个位置的意义，我们首先需要了解整个网络世界的通信模型：<strong>TCP&#x2F;IP 协议族</strong>。</p>
<h3 id="2-1-TCP-IP-协议族简介"><a href="#2-1-TCP-IP-协议族简介" class="headerlink" title="2.1. TCP&#x2F;IP 协议族简介"></a>2.1. TCP&#x2F;IP 协议族简介</h3><p>你可以把整个互联网的通信想象成一次<strong>国际快递</strong>。从你写信，到信件最终送到国外朋友手中，中间会经过很多层级和环节，每一层都只关心自己的任务。TCP&#x2F;IP 模型就是对这个过程的标准化分层。</p>
<p>它通常被划分为四个层次，从上到下依次是：</p>
<p><strong>1. 应用层 (Application Layer)</strong></p>
<ul>
<li><strong>作用</strong>：直接为用户的应用程序提供服务。它定义了应用程序之间通信的规则。</li>
<li><strong>快递类比</strong>：<strong>你本人</strong>。你决定要寄什么东西（一封信、一个包裹），并用对方能看懂的语言（中文、英文）来书写内容。</li>
<li><strong>典型协议</strong>：<ul>
<li><strong>HTTP</strong>: 浏览网页</li>
<li><strong>FTP</strong>: 文件传输</li>
<li><strong>SMTP</strong>: 发送邮件</li>
<li><strong>DNS</strong>: 域名解析</li>
</ul>
</li>
<li><strong>HTTP 就在这一层。</strong></li>
</ul>
<p><strong>2. 传输层 (Transport Layer)</strong></p>
<ul>
<li><strong>作用</strong>：为上层（应用层）的两个主机之间提供端到端的、可靠或不可靠的数据传输服务。</li>
<li><strong>快递类比</strong>：<strong>快递公司的打包员</strong>。他不关心信件内容，只负责把你的信件装进标准信封，写上寄件人和收件人的地址、电话（即<strong>端口号</strong>），并选择是需要“签收回执”的可靠服务（TCP）还是“平信”般的快速服务（UDP）。</li>
<li><strong>典型协议</strong>：<ul>
<li><strong>TCP (Transmission Control Protocol)</strong>：传输控制协议。它是一个<strong>可靠的、面向连接</strong>的协议。HTTP、FTP、SMTP 都依赖它。</li>
<li><strong>UDP (User Datagram Protocol)</strong>：用户数据报协议。它是一个<strong>不可靠的、无连接</strong>的协议，但速度快。DNS、视频直播常用它。</li>
</ul>
</li>
</ul>
<p><strong>3. 网络层 (Network Layer &#x2F; Internet Layer)</strong></p>
<ul>
<li><strong>作用</strong>：负责将数据包从源头主机发送到目标主机，处理路由选择和网络间的寻址。</li>
<li><strong>快递类比</strong>：<strong>快递公司的物流调度中心</strong>。它不关心包裹里是什么，也不关心是否要签收，只负责根据收件地址（即 <strong>IP 地址</strong>），规划出一条从北京到纽约的最佳运输路线（走空运还是海运）。</li>
<li><strong>典型协议</strong>：<ul>
<li><strong>IP (Internet Protocol)</strong>：网际协议。它是整个 TCP&#x2F;IP 协议族的核心，所有数据最终都会被打包成 IP 数据包来传输。</li>
</ul>
</li>
</ul>
<p><strong>4. 数据链路层 &amp; 物理层 (Data Link &amp; Physical Layer)</strong></p>
<ul>
<li><strong>作用</strong>：负责在直接相连的两个节点之间传输数据。这是最底层的物理传输。</li>
<li><strong>快递类比</strong>：<strong>具体的运输工具和司机</strong>。比如开着货车把包裹从一个分拣中心送到下一个分拣中心，或者飞行员开着飞机跨越太平洋。他们只管把“一车货”从 A 点运到 B 点。</li>
<li><strong>典型协议&#x2F;技术</strong>：<ul>
<li><strong>Ethernet (以太网)</strong>, <strong>Wi-Fi</strong>, 光纤、双绞线等。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>核心思想</strong>：数据在发送时，会从上到下（应用层 -&gt; … -&gt; 物理层）逐层“打包”（封装）；在接收时，会从下到上（物理层 -&gt; … -&gt; 应用层）逐层“拆包”（解封装）。每一层都为上一层提供服务，同时使用下一层提供的服务。</p>
</blockquote>
<hr>
<h3 id="2-2-应用层协议的角色"><a href="#2-2-应用层协议的角色" class="headerlink" title="2.2 应用层协议的角色"></a>2.2 应用层协议的角色</h3><p>现在我们知道 HTTP 位于最高层的应用层，那么它的具体角色是什么？</p>
<ol>
<li><strong>定义“业务语义”</strong>：应用层协议不关心数据如何可靠传输（那是 TCP 的事），也不关心数据如何跨网络路由（那是 IP 的事）。它只关心**“我们这次通信是要干什么”**。<ul>
<li>HTTP 定义了 <code>GET</code>（获取资源）、<code>POST</code>（提交数据）等方法，这就是在定义业务目的。</li>
<li>SMTP 定义了 <code>MAIL FROM</code>（发件人）、<code>RCPT TO</code>（收件人）等命令，这是在定义邮件投递的业务。</li>
</ul>
</li>
<li><strong>规定数据格式</strong>：应用层协议明确规定了应用程序之间交换的报文（Message）应该长什么样。<ul>
<li>HTTP 规定了请求必须包含“请求行、请求头、请求体”，响应必须包含“状态行、响应头、响应体”。</li>
</ul>
</li>
<li><strong>服务于最终用户</strong>：应用层是唯一直接与用户（或用户使用的软件）交互的层。你点击浏览器的一个链接，就是触发了一个 HTTP 应用层协议的动作。</li>
</ol>
<blockquote>
<p><strong>一句话总结</strong>：HTTP 作为应用层协议，其角色就是<strong>专注于定义“浏览器”和“Web服务器”这对应用程序之间如何沟通、交换“超文本文档”这件事</strong>，而将底层的网络传输细节完全委托给 TCP&#x2F;IP 协议栈去处理。</p>
</blockquote>
<hr>
<h3 id="2-3-HTTP-与-TCP、DNS-的关系：一次完整的网页请求过程"><a href="#2-3-HTTP-与-TCP、DNS-的关系：一次完整的网页请求过程" class="headerlink" title="2.3 HTTP 与 TCP、DNS 的关系：一次完整的网页请求过程"></a>2.3 HTTP 与 TCP、DNS 的关系：一次完整的网页请求过程</h3><p>这是理解 HTTP 在网络中位置的最佳实践。让我们以你在浏览器地址栏输入 <code>http://www.example.com</code> 并按回车为例，看看发生了什么：</p>
<ol>
<li><p><strong>【应用层】DNS 解析</strong>：</p>
<ul>
<li>浏览器首先看到的是 <code>www.example.com</code> 这个<strong>域名</strong>。但计算机网络通信需要的是 <strong>IP 地址</strong>（比如 <code>93.184.216.34</code>）。</li>
<li>浏览器会向 <strong>DNS</strong> 服务器发起一个查询请求（DNS 本身也是一个应用层协议），询问“<code>www.example.com</code> 的 IP 地址是什么？”</li>
<li>DNS 服务器回答：“是 <code>93.184.216.34</code>”。</li>
<li><strong>角色</strong>：<strong>DNS 就像是互联网的“电话本”</strong>，负责将人类易记的域名转换成机器使用的 IP 地址。</li>
</ul>
</li>
<li><p><strong>【传输层】建立 TCP 连接</strong>：</p>
<ul>
<li>浏览器现在拿到了 IP 地址。HTTP 协议默认使用 80 端口。</li>
<li>浏览器会通过操作系统的 TCP 协议栈，向服务器 <code>93.184.216.34</code> 的 <code>80</code> 端口发起一个 TCP 连接请求。</li>
<li>这个过程会经历著名的“<strong>三次握手</strong>”（SYN -&gt; SYN&#x2F;ACK -&gt; ACK），以确保双方都准备好通信，建立一条可靠的连接通道。</li>
<li><strong>角色</strong>：<strong>TCP 就像是“拨通了对方的电话”</strong>，并确认对方在线，随时可以开始通话。</li>
</ul>
</li>
<li><p><strong>【应用层】发送 HTTP 请求</strong>：</p>
<ul>
<li><p>TCP 连接建立成功后，浏览器就可以开始“说话”了。</p>
</li>
<li><p>浏览器会按照 HTTP 协议定义的格式，构建一个<strong>请求报文</strong>，例如：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>浏览器将这个报文通过刚才建立好的 TCP 连接发送给服务器。</p>
</li>
</ul>
</li>
<li><p><strong>【服务器】处理请求并发送 HTTP 响应</strong>：</p>
<ul>
<li><p>Web 服务器在 <code>80</code> 端口上一直监听着。当它收到这个 HTTP 请求报文后，会进行解析。</p>
</li>
<li><p>服务器发现客户端想要根目录 <code>/</code> 的资源，于是找到对应的 <code>index.html</code> 文件，并准备一个<strong>响应报文</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1256</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span>...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器将这个响应报文通过 TCP 连接发回给浏览器。</p>
</li>
</ul>
</li>
<li><p><strong>【传输层】关闭 TCP 连接</strong>：</p>
<ul>
<li>浏览器接收完所有响应数据后，根据 HTTP 头部（如 <code>Connection: keep-alive</code>）的指示，决定是保持连接以便后续请求复用，还是通过“<strong>四次挥手</strong>”关闭这条 TCP 连接。</li>
</ul>
</li>
<li><p><strong>【应用层】浏览器渲染</strong>：</p>
<ul>
<li>浏览器收到响应报文，解析其中的 HTML 内容，并将其渲染成你看到的五彩斑斓的网页。如果 HTML 中还引用了其他资源（如 CSS 文件、图片），浏览器会<strong>重复上述过程</strong>（从第2步或第3步开始）去获取这些资源。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-HTTP-的核心特点"><a href="#3-HTTP-的核心特点" class="headerlink" title="3. HTTP 的核心特点"></a>3. HTTP 的核心特点</h2><h3 id="3-1-C-S-架构"><a href="#3-1-C-S-架构" class="headerlink" title="3.1 C&#x2F;S 架构"></a>3.1 C&#x2F;S 架构</h3><p>这是 HTTP 最基本的运作模型。</p>
<ul>
<li><strong>定义</strong>：<br>在 HTTP 通信中，角色被明确地划分为两方：<ol>
<li><strong>客户端 (Client)</strong>：发起请求的一方。它主动向服务器请求资源。我们日常使用的网页浏览器 (Chrome, Firefox)、手机 App、或者命令行工具 cURL 都属于客户端。</li>
<li><strong>服务器 (Server)</strong>：接收请求并提供响应的一方。它被动地等待客户端的请求，并根据请求内容返回相应的资源（如 HTML 页面、图片、数据等）。常见的 Web 服务器有 Apache, Nginx, Tomcat 等。</li>
</ol>
</li>
<li><strong>通信流程</strong>：<ol>
<li>通信总是由<strong>客户端</strong>发起。</li>
<li>服务器<strong>不能</strong>主动向客户端推送信息。（<em>注：这在传统 HTTP 模型中是成立的，像 WebSocket、Server-Sent Events 等技术是为了突破这一限制而出现的</em>）。</li>
<li>一次完整的交互是“客户端请求 -&gt; 服务器响应”的循环。</li>
</ol>
</li>
<li><strong>意义</strong>：<br>这种职责分离的模式极大地促进了 Web 的发展。客户端和服务器可以独立发展和演进，只要它们都遵守 HTTP 这套共同的协议。服务器可以专注于提供高性能、高可用的服务；而客户端则可以专注于提供丰富的用户界面和交互体验。</li>
</ul>
<hr>
<h3 id="3-2-简单可扩展"><a href="#3-2-简单可扩展" class="headerlink" title="3.2 简单可扩展"></a>3.2 简单可扩展</h3><p>这是 HTTP 能够长盛不衰、适应时代变化的关键。</p>
<ul>
<li><strong>简单 (Simple)</strong>：<ul>
<li>HTTP&#x2F;1.1 及之前的版本，其报文（请求和响应）是<strong>人类可读的纯文本</strong>。</li>
<li>其基本结构非常简单，由“起始行 + 头部 + 空行 + 实体”构成。这种简洁性使得早期开发者很容易实现和调试 HTTP 客户端与服务器。</li>
<li>例如，一个最简单的 <code>GET</code> 请求可以手动通过 <code>telnet</code> 工具打出来，非常直观。</li>
</ul>
</li>
<li><strong>可扩展 (Extensible)</strong>：<ul>
<li>这是 HTTP 最强大的特性。HTTP 协议的核心只定义了基本的框架（如请求方法、URL、状态码），但通过<strong>HTTP 头部 (Headers)</strong>，它可以被无限扩展。</li>
<li>头部是 <code>Key: Value</code> 格式的键值对，允许客户端和服务器之间传递任意的元数据。</li>
<li>当需要增加新功能时，通常只需要<strong>定义一个新的头部字段</strong>即可，而无需改变协议的整体结构。</li>
</ul>
</li>
<li><strong>例子</strong>：<ul>
<li>为了解决“无状态”问题，引入了 <code>Cookie</code> 和 <code>Set-Cookie</code> 头部。</li>
<li>为了提高性能，引入了 <code>Cache-Control</code> 头部用于缓存控制，引入了 <code>Content-Encoding</code> 头部用于数据压缩。</li>
<li>为了增强安全性，引入了 <code>Content-Security-Policy</code>, <code>Strict-Transport-Security</code> 等安全相关的头部。</li>
<li>开发者甚至可以自定义以 <code>X-</code> 开头的头部（现在已不推荐，可以直接使用自定义名称）来传递应用特定的信息。</li>
</ul>
</li>
<li><strong>意义</strong>：<br>可扩展性使得 HTTP 可以根据不断出现的新需求（如身份验证、缓存、数据压缩、安全策略等）添加新的头部，从而在 30 多年的发展中保持了强大的生命力。</li>
</ul>
<hr>
<h3 id="3-3-无状态"><a href="#3-3-无状态" class="headerlink" title="3.3 无状态"></a>3.3 无状态</h3><p>这个特点既是优点也是“缺点”，深刻影响了 Web 应用的开发模式。</p>
<ul>
<li><strong>定义</strong>：<br>“无状态”指的是<strong>协议本身对于事务处理没有记忆能力</strong>。每一次 HTTP 请求都是完全独立的，服务器不会保留前一次请求的任何信息。<ul>
<li>换句话说，服务器处理完一个请求并发送响应后，它就<strong>完全忘记了</strong>与这个客户端之间发生过的一切。</li>
<li>当同一个客户端再次发送请求时，服务器无法知道它就是刚才那个客户端。</li>
</ul>
</li>
<li><strong>类比</strong>：<br>可以想象成<strong>与一个记忆只有七秒的鱼对话</strong>。<ol>
<li>你问它：“你好吗？” 它回答：“我很好。” 然后它就忘了你。</li>
<li>你接着问：“我叫什么名字？” 它无法回答，因为它不记得你刚刚跟它打过招呼。</li>
<li>如果你想让它记住你，你必须在每次提问时都重新自我介绍：“你好，我叫小明。我叫什么名字？”</li>
</ol>
</li>
<li><strong>优点 (Scalability)</strong>：<ul>
<li><strong>简化服务器设计</strong>：服务器不需要花费额外的资源（如内存）来存储海量的客户端状态信息。</li>
<li><strong>提升服务器的可伸缩性</strong>：由于服务器不存储状态，任何一台服务器都可以处理任何一个客户端的请求。这使得在服务器集群中做<strong>负载均衡</strong>变得非常容易。如果一台服务器宕机，请求可以无缝切换到另一台，因为新服务器不需要任何历史上下文。</li>
</ul>
</li>
<li><strong>缺点与解决方案</strong>：<ul>
<li><strong>功能受限</strong>：然而，现代 Web 应用（如购物车、用户登录）恰恰需要“记住状态”。</li>
<li><strong>解决方案</strong>：为了弥补 HTTP 的无状态性，Web 应用通过<strong>Cookie 和 Session 机制</strong>来“创造”状态。<ul>
<li><strong>Cookie</strong>: 服务器通过 <code>Set-Cookie</code> 响应头给客户端一个“通行证”（一小段文本）。</li>
<li>之后，客户端在每次请求时都会通过 <code>Cookie</code> 请求头带上这个“通行证”。</li>
<li>服务器通过检查这个“通行证”就能识别出用户，从而维持登录状态或购物车内容。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-4-可靠传输"><a href="#3-4-可靠传输" class="headerlink" title="3.4 可靠传输"></a>3.4 可靠传输</h3><p>HTTP 本身不负责传输的可靠性，它“站在了巨人的肩膀上”。</p>
<ul>
<li><strong>定义</strong>：<br>HTTP 协议通常是构建在<strong>传输层的 TCP 协议</strong>之上的。TCP 是一个<strong>可靠的</strong>传输协议，它为 HTTP 提供了以下保障：<ol>
<li><strong>数据完整性</strong>：通过校验和机制，确保数据在传输过程中没有损坏。</li>
<li><strong>按序到达</strong>：确保数据包能够按照发送的顺序被接收端正确地重组。</li>
<li><strong>无丢失</strong>：通过确认和重传机制，确保所有发送的数据都能到达目的地。</li>
</ol>
</li>
<li><strong>类比</strong>：<br>HTTP 协议就像是<strong>写信的人</strong>，他只负责写信的内容（请求报文&#x2F;响应报文）。而 TCP 协议就像是一个<strong>非常靠谱的邮政系统</strong>。<ul>
<li>写信的人（HTTP）把信交给邮局（TCP），就完全不用担心信件会不会寄丢、会不会被撕坏、或者信件页码会不会乱掉。</li>
<li>邮政系统（TCP）会负责安全、完整、按顺序地把信送到收件人手中。</li>
</ul>
</li>
<li><strong>意义</strong>：<br>将可靠传输的任务委托给下层的 TCP，极大地简化了 HTTP 协议的设计。HTTP 的设计者可以专注于应用层面的逻辑，即如何定义和交换超文本文档，而无需处理复杂的网络传输问题。</li>
<li><strong>演进</strong>：<br>最新的 <strong>HTTP&#x2F;3 协议改为使用 QUIC 协议</strong>，而 QUIC 是基于 UDP（一个不可靠协议）构建的。但 QUIC 协议自身内部实现了类似 TCP 的可靠性、流量控制等功能，因此，从应用层的角度看，HTTP&#x2F;3 依然享受着可靠传输的保障。</li>
</ul>
<hr>
<h1 id="二、HTTP-报文结构详解"><a href="#二、HTTP-报文结构详解" class="headerlink" title="二、HTTP 报文结构详解"></a>二、HTTP 报文结构详解</h1><h2 id="1-认识-URL-统一资源定位符"><a href="#1-认识-URL-统一资源定位符" class="headerlink" title="1. 认识 URL (统一资源定位符)"></a>1. 认识 URL (统一资源定位符)</h2><p>URL，全称 <strong>Uniform Resource Locator</strong>，即“<strong>统一资源定位符</strong>”。它的作用非常直观：为互联网上的每一个资源提供一个独一无二的“地址”。就像现实世界中每家每户都有一个唯一的门牌号一样，有了 URL，浏览器才能准确地找到并访问你想要的任何资源（网页、图片、视频、API 等）。</p>
<h3 id="1-1-URL-的组成部分"><a href="#1-1-URL-的组成部分" class="headerlink" title="1.1 URL 的组成部分"></a>1.1 URL 的组成部分</h3><p>一个完整的 URL 结构看起来可能很复杂，但我们可以把它拆解成几个核心部分。以这个常见的 URL 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.example.com:443/path/to/resource?query1=value1&amp;query2=value2#section1</span><br></pre></td></tr></table></figure>

<p>下面我们逐一解析它的构成：</p>
<table>
<thead>
<tr>
<th>部分 (Part)</th>
<th>示例值</th>
<th>英文名</th>
<th>解释说明</th>
<th>是否必需</th>
</tr>
</thead>
<tbody><tr>
<td><strong>协议 (Scheme)</strong></td>
<td><code>https</code></td>
<td>Scheme &#x2F; Protocol</td>
<td>定义了客户端应该使用哪种协议来访问资源。常见的有 <code>http</code>, <code>https</code>, <code>ftp</code>, <code>file</code> 等。它必须以 <code>:</code> 结尾。</td>
<td>是</td>
</tr>
<tr>
<td><strong>分隔符</strong></td>
<td><code>://</code></td>
<td>Delimiter</td>
<td>用于分隔协议和后面的主机部分。</td>
<td>是</td>
</tr>
<tr>
<td><strong>主机 (Host)</strong></td>
<td><code>www.example.com</code></td>
<td>Host &#x2F; Domain Name</td>
<td>标识了资源所在的服务器的域名或 IP 地址。这是网络上的“门牌号”。</td>
<td>是</td>
</tr>
<tr>
<td><strong>端口 (Port)</strong></td>
<td><code>:443</code></td>
<td>Port</td>
<td>指定了服务器上用于监听请求的“窗口”或“服务台”。每个网络服务都与一个端口号关联。</td>
<td>否 (可选)</td>
</tr>
<tr>
<td><strong>路径 (Path)</strong></td>
<td><code>/path/to/resource</code></td>
<td>Path</td>
<td>描述了资源在服务器上的具体位置，类似电脑文件系统中的文件路径。以 <code>/</code> 开头。</td>
<td>否 (可选)</td>
</tr>
<tr>
<td><strong>查询 (Query)</strong></td>
<td><code>?query1=value1&amp;query2=value2</code></td>
<td>Query &#x2F; Search</td>
<td>提供给服务器的额外参数，通常用于过滤、分页或搜索。以 <code>?</code> 开始，多个参数之间用 <code>&amp;</code> 分隔。</td>
<td>否 (可选)</td>
</tr>
<tr>
<td><strong>片段 (Fragment)</strong></td>
<td><code>#section1</code></td>
<td>Fragment</td>
<td>也称为“锚点 (Anchor)”，用于定位到资源内部的某个特定部分（如网页中的某个标题）。以 <code>#</code> 开始。</td>
<td>否 (可选)</td>
</tr>
</tbody></table>
<hr>
<p><strong>各部分的详细说明：</strong></p>
<ol>
<li><strong>协议 (Scheme)</strong><ul>
<li>它告诉浏览器用什么“语言”去和服务器沟通。</li>
<li><code>http</code>: 超文本传输协议，是 Web 的基础协议，默认端口 80。</li>
<li><code>https</code>: 安全的超文本传输协议，在 HTTP 的基础上加入了 SSL&#x2F;TLS 加密，默认端口 443。</li>
<li><code>ftp</code>: 文件传输协议，用于文件上传下载。</li>
<li><code>file</code>: 用于访问本地计算机上的文件。</li>
</ul>
</li>
<li><strong>主机 (Host)</strong><ul>
<li>可以是<strong>域名</strong>（如 <code>www.google.com</code>），域名最终会通过 DNS 解析成 IP 地址。</li>
<li>也可以直接是 <strong>IP 地址</strong>（如 <code>192.168.1.1</code>）。</li>
</ul>
</li>
<li><strong>端口 (Port)</strong><ul>
<li>端口号是一个 16 位的数字（0-65535）。</li>
<li>如果 URL 中<strong>省略了端口号</strong>，浏览器会使用该协议的<strong>默认端口</strong>。<ul>
<li><code>http</code> 的默认端口是 <strong>80</strong>。</li>
<li><code>httpss</code> 的默认端口是 <strong>443</strong>。</li>
</ul>
</li>
<li>因此，<code>http://example.com</code> 等价于 <code>http://example.com:80</code>。</li>
</ul>
</li>
<li><strong>路径 (Path)</strong><ul>
<li>路径部分是大小写敏感的（除非服务器特殊配置）。</li>
<li>如果 URL 中只有主机名而没有路径（如 <code>https://www.example.com</code>），那么路径默认为根路径 <code>/</code>。</li>
</ul>
</li>
<li><strong>查询 (Query)</strong><ul>
<li>这是客户端向服务器传递动态数据的主要方式，尤其是在 <code>GET</code> 请求中。</li>
<li>格式是 <code>key=value</code> 的键值对，多个键值对用 <code>&amp;</code> 连接。</li>
<li>例如，在搜索引擎中搜索“http”，URL 可能是 <code>https://www.google.com/search?q=http</code>。这里的 <code>q=http</code> 就是查询参数。</li>
</ul>
</li>
<li><strong>片段 (Fragment)</strong><ul>
<li><strong>一个非常重要的特性是：片段部分完全由客户端（浏览器）处理，它不会被发送到服务器。</strong></li>
<li>当浏览器加载完页面后，它会查找 ID 为 <code>section1</code> 的元素，并将页面滚动到该位置。</li>
<li>这在单页应用 (SPA) 中被广泛用于实现前端路由。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-2-URI-URL-URN-的区别与联系"><a href="#1-2-URI-URL-URN-的区别与联系" class="headerlink" title="1.2 URI, URL, URN 的区别与联系"></a>1.2 URI, URL, URN 的区别与联系</h3><p>在技术文档中，你可能还会遇到 URI 和 URN两个术语。它们的关系如下：</p>
<ul>
<li><strong>URI (Uniform Resource Identifier) - 统一资源标识符</strong><ul>
<li>这是一个<strong>总称</strong>，是用来唯一标识一个资源的字符串。它的目标是**“标识”**，而不在乎如何找到它。</li>
<li>URI 分为两种类型：URL 和 URN。</li>
</ul>
</li>
<li><strong>URL (Uniform Resource Locator) - 统一资源定位符</strong><ul>
<li>我们刚刚详细讨论过。它不仅<strong>标识</strong>了一个资源，还提供了找到该资源的<strong>位置信息</strong>（即如何定位它，比如通过 <code>http</code> 协议访问哪个主机）。</li>
<li><strong>所有的 URL 都是 URI。</strong></li>
<li>例子：<code>https://example.com/mypage.html</code></li>
</ul>
</li>
<li><strong>URN (Uniform Resource Name) - 统一资源名称</strong><ul>
<li>它也用于唯一标识一个资源，但只提供资源的**“名字”**，而不关心资源在哪里或如何访问它。它的目标是提供一个持久的、与位置无关的标识。</li>
<li>URN 使用 <code>urn:</code> 作为前缀。</li>
<li>例子：<code>urn:isbn:978-0-14-103614-4</code> 这个 URN 唯一标识了乔治·奥威尔的小说《1984》的某个版本，但它没告诉你去哪个书店或网站才能买到这本书。</li>
</ul>
</li>
</ul>
<p><strong>三者的关系可以用一个简单的图来表示：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      +------------------+</span><br><span class="line">      |       URI        |  (标识符总称)</span><br><span class="line">      |  (Identifier)    |</span><br><span class="line">      +------------------+</span><br><span class="line">             /      \</span><br><span class="line">            /        \</span><br><span class="line">+----------------+  +----------------+</span><br><span class="line">|      URL       |  |      URN       | (名称)</span><br><span class="line">|  (Locator)     |  |     (Name)     |</span><br><span class="line">+----------------+  +----------------+</span><br><span class="line">(标识 + 定位)       (标识，但无定位)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-请求报文-Request-Message"><a href="#2-请求报文-Request-Message" class="headerlink" title="2. 请求报文 (Request Message)"></a>2. 请求报文 (Request Message)</h2><ul>
<li>2.1. <strong>请求行 (Request Line)</strong><ul>
<li>请求方法 (Method)</li>
<li>请求目标 (Request Target &#x2F; URI)</li>
<li>HTTP 版本 (Version)</li>
</ul>
</li>
<li>2.2. <strong>请求头 (Request Headers)</strong><ul>
<li>通用头 (General Headers)</li>
<li>请求头 (Request Headers)</li>
<li>实体头 (Entity Headers)</li>
<li><strong>常用请求头详解</strong>：<code>Host</code>, <code>User-Agent</code>, <code>Accept</code>, <code>Content-Type</code>, <code>Content-Length</code>, <code>Connection</code> 等</li>
</ul>
</li>
<li>2.3. <strong>请求体 (Request Body)</strong><ul>
<li>什么情况下会有请求体？ (如 POST, PUT)</li>
<li>常见的数据格式：<code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, <code>application/json</code></li>
</ul>
</li>
</ul>
<h2 id="3-响应报文-Response-Message"><a href="#3-响应报文-Response-Message" class="headerlink" title="3. 响应报文 (Response Message)"></a>3. 响应报文 (Response Message)</h2><ul>
<li>3.1. <strong>状态行 (Status Line)</strong><ul>
<li>HTTP 版本 (Version)</li>
<li>状态码 (Status Code)</li>
<li>原因短语 (Reason Phrase)</li>
</ul>
</li>
<li>3.2. <strong>响应头 (Response Headers)</strong><ul>
<li><strong>常用响应头详解</strong>：<code>Content-Type</code>, <code>Content-Length</code>, <code>Content-Encoding</code>, <code>Server</code>, <code>Date</code>, <code>Location</code>, <code>Set-Cookie</code> 等</li>
</ul>
</li>
<li>3.3. <strong>响应体 (Response Body)</strong><ul>
<li>服务器返回的实际资源内容 (HTML, CSS, JS, 图片, JSON 数据等)</li>
</ul>
</li>
</ul>
<hr>
<h1 id="三、HTTP-请求方法与状态码"><a href="#三、HTTP-请求方法与状态码" class="headerlink" title="三、HTTP 请求方法与状态码"></a>三、HTTP 请求方法与状态码</h1><h2 id="1-请求方法-Methods"><a href="#1-请求方法-Methods" class="headerlink" title="1. 请求方法 (Methods)"></a>1. 请求方法 (Methods)</h2><ul>
<li>1.1. <strong>GET</strong>: 获取资源</li>
<li>1.2. <strong>POST</strong>: 创建&#x2F;提交资源</li>
<li>1.3. <strong>PUT</strong>: 完整更新资源</li>
<li>1.4. <strong>DELETE</strong>: 删除资源</li>
<li>1.5. <strong>HEAD</strong>: 获取资源的元信息 (仅头部)</li>
<li>1.6. <strong>OPTIONS</strong>: 查询服务器支持的方法</li>
<li>1.7. <strong>PATCH</strong>: 部分更新资源</li>
<li>1.8. <strong>安全与幂等性</strong>：理解这些方法的关键特性</li>
</ul>
<h2 id="2-状态码-Status-Codes"><a href="#2-状态码-Status-Codes" class="headerlink" title="2. 状态码 (Status Codes)"></a>2. 状态码 (Status Codes)</h2><ul>
<li>2.1. <strong>1xx (信息性)</strong>：请求已接收，继续处理<ul>
<li><code>100 Continue</code></li>
</ul>
</li>
<li>2.2. <strong>2xx (成功)</strong>：请求已成功被服务器接收、理解、并接受<ul>
<li><code>200 OK</code>, <code>201 Created</code>, <code>204 No Content</code></li>
</ul>
</li>
<li>2.3. <strong>3xx (重定向)</strong>：需要后续操作才能完成这一请求<ul>
<li><code>301 Moved Permanently</code> (永久重定向)</li>
<li><code>302 Found</code> (临时重定向)</li>
<li><code>304 Not Modified</code> (与缓存相关)</li>
</ul>
</li>
<li>2.4. <strong>4xx (客户端错误)</strong>：请求含有词法错误或者无法被执行<ul>
<li><code>400 Bad Request</code>, <code>401 Unauthorized</code>, <code>403 Forbidden</code>, <code>404 Not Found</code></li>
</ul>
</li>
<li>2.5. <strong>5xx (服务器错误)</strong>：服务器在处理某个正确请求时发生内部错误<ul>
<li><code>500 Internal Server Error</code>, <code>502 Bad Gateway</code>, <code>503 Service Unavailable</code></li>
</ul>
</li>
</ul>
<hr>
<h1 id="四、HTTP-核心机制与特性"><a href="#四、HTTP-核心机制与特性" class="headerlink" title="四、HTTP 核心机制与特性"></a>四、HTTP 核心机制与特性</h1><h2 id="1-连接管理"><a href="#1-连接管理" class="headerlink" title="1. 连接管理"></a>1. 连接管理</h2><ul>
<li>1.1. 短连接 vs 长连接 (Persistent Connection &#x2F; Keep-Alive)</li>
<li>1.2. <code>Connection</code> 头部的作用</li>
<li>1.3. 队头阻塞问题 (Head-of-line blocking)</li>
</ul>
<h2 id="2-状态管理：Cookie-与-Session"><a href="#2-状态管理：Cookie-与-Session" class="headerlink" title="2. 状态管理：Cookie 与 Session"></a>2. 状态管理：Cookie 与 Session</h2><ul>
<li>2.1. 为什么需要状态管理？(弥补 HTTP 无状态特性)</li>
<li>2.2. <strong>Cookie</strong>：工作原理、<code>Set-Cookie</code> 与 <code>Cookie</code> 头部</li>
<li>2.3. Cookie 的属性：<code>Expires</code>, <code>Max-Age</code>, <code>Domain</code>, <code>Path</code>, <code>HttpOnly</code>, <code>Secure</code>, <code>SameSite</code></li>
<li>2.4. <strong>Session</strong>：基于 Cookie 的服务端状态管理机制</li>
</ul>
<h2 id="3-缓存控制"><a href="#3-缓存控制" class="headerlink" title="3. 缓存控制"></a>3. 缓存控制</h2><ul>
<li>3.1. 缓存的价值：提升性能、减少带宽</li>
<li>3.2. <strong>强制缓存 (Strong Caching)</strong><ul>
<li><code>Expires</code> (HTTP&#x2F;1.0)</li>
<li><code>Cache-Control: max-age</code> (HTTP&#x2F;1.1)</li>
</ul>
</li>
<li>3.3. <strong>协商缓存 (Conditional Caching)</strong><ul>
<li><code>Last-Modified</code> &amp; <code>If-Modified-Since</code></li>
<li><code>ETag</code> &amp; <code>If-None-Match</code></li>
</ul>
</li>
<li>3.4. 用户操作对缓存的影响 (F5 刷新 vs Ctrl+F5 强制刷新)</li>
</ul>
<h2 id="4-内容协商"><a href="#4-内容协商" class="headerlink" title="4. 内容协商"></a>4. 内容协商</h2><ul>
<li>4.1. 客户端通过 <code>Accept-*</code> 系列头部声明期望格式<ul>
<li><code>Accept</code>: MIME 类型</li>
<li><code>Accept-Language</code>: 语言</li>
<li><code>Accept-Encoding</code>: 压缩编码 (gzip, deflate, br)</li>
</ul>
</li>
<li>4.2. 服务器如何根据请求头选择最佳表示</li>
</ul>
<hr>
<h1 id="五、HTTP-安全：从-HTTP-到-HTTPS-Security"><a href="#五、HTTP-安全：从-HTTP-到-HTTPS-Security" class="headerlink" title="五、HTTP 安全：从 HTTP 到 HTTPS (Security)"></a>五、HTTP 安全：从 HTTP 到 HTTPS (Security)</h1><h2 id="1-HTTP-的安全风险"><a href="#1-HTTP-的安全风险" class="headerlink" title="1. HTTP 的安全风险"></a>1. HTTP 的安全风险</h2><ul>
<li>1.1. <strong>窃听风险</strong>：通信内容为明文</li>
<li>1.2. <strong>篡改风险</strong>：内容可被中间人修改</li>
<li>1.3. <strong>冒充风险</strong>：无法验证通信双方身份</li>
</ul>
<h2 id="2-HTTPS-是什么？"><a href="#2-HTTPS-是什么？" class="headerlink" title="2. HTTPS 是什么？"></a>2. HTTPS 是什么？</h2><ul>
<li>2.1. HTTPS &#x3D; HTTP + SSL&#x2F;TLS</li>
<li>2.2. SSL&#x2F;TLS 的作用：加密、身份验证、数据完整性</li>
</ul>
<h2 id="3-SSL-TLS-握手过程"><a href="#3-SSL-TLS-握手过程" class="headerlink" title="3. SSL&#x2F;TLS 握手过程"></a>3. SSL&#x2F;TLS 握手过程</h2><ul>
<li>3.1. 客户端发起请求 (Client Hello)</li>
<li>3.2. 服务器响应与证书下发 (Server Hello, Certificate)</li>
<li>3.3. 客户端验证证书、生成密钥</li>
<li>3.4. 建立安全通道，开始加密通信</li>
</ul>
<h2 id="4-常见的-Web-安全威胁与-HTTP"><a href="#4-常见的-Web-安全威胁与-HTTP" class="headerlink" title="4. 常见的 Web 安全威胁与 HTTP"></a>4. 常见的 Web 安全威胁与 HTTP</h2><ul>
<li>4.1. <strong>跨站脚本 (XSS)</strong>：与 <code>Content-Type</code> 和 <code>Content-Security-Policy</code> 头相关</li>
<li>4.2. <strong>跨站请求伪造 (CSRF)</strong>：与 Cookie 和 <code>SameSite</code> 属性相关</li>
<li>4.3. <strong>CORS (跨源资源共享)</strong>：浏览器同源策略与 <code>Access-Control-Allow-*</code> 系列头部</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/10/17/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95%E4%B8%8E%E9%9B%86%E6%88%90/" rel="prev" title="Spring全家桶-功能扩展与集成">
                  <i class="fa fa-angle-left"></i> Spring全家桶-功能扩展与集成
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
