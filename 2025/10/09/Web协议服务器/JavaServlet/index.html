<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="一、Servlet 基础与核心概念1. Servlet 是什么？1.1 定义Servlet（Server Applet，服务器端小程序）是一种运行在 Web 服务器或应用服务器上的 Java 程序。它作为客户端请求（Request）和服务器响应（Response）之间的中间层，用于生成动态的 Web 内容。 简单来说，Servlet 就是一个遵循特定规范（Servlet API）的 Java 类，">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaServlet">
<meta property="og:url" content="http://example.com/2025/10/09/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/JavaServlet/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="一、Servlet 基础与核心概念1. Servlet 是什么？1.1 定义Servlet（Server Applet，服务器端小程序）是一种运行在 Web 服务器或应用服务器上的 Java 程序。它作为客户端请求（Request）和服务器响应（Response）之间的中间层，用于生成动态的 Web 内容。 简单来说，Servlet 就是一个遵循特定规范（Servlet API）的 Java 类，">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-09T13:21:19.000Z">
<meta property="article:modified_time" content="2025-10-17T08:07:22.356Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/10/09/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/JavaServlet/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/10/09/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/JavaServlet/","path":"2025/10/09/Web协议服务器/JavaServlet/","title":"JavaServlet"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JavaServlet | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81Servlet-%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">一、Servlet 基础与核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Servlet-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">1. Servlet 是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E4%B8%8E-CGI-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 与 CGI 的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-Servlet-%E5%AE%B9%E5%99%A8%EF%BC%88Web-%E5%AE%B9%E5%99%A8%EF%BC%89"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.4 Servlet 容器（Web 容器）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">1.4.1 核心职责</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86-Lifecycle-Management"><span class="nav-number">1.1.4.1.1.</span> <span class="nav-text">1. 生命周期管理 (Lifecycle Management):</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E9%80%9A%E4%BF%A1%E6%94%AF%E6%8C%81-Communication-Support"><span class="nav-number">1.1.4.1.2.</span> <span class="nav-text">2. 通信支持 (Communication Support):</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E8%AF%B7%E6%B1%82%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%B0%81%E8%A3%85-Request-Parsing-and-Wrapping"><span class="nav-number">1.1.4.1.3.</span> <span class="nav-text">3. 请求解析与封装 (Request Parsing and Wrapping):</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86-Multithreading-Management"><span class="nav-number">1.1.4.1.4.</span> <span class="nav-text">4. 多线程管理 (Multithreading Management):</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%8F%90%E4%BE%9B%E5%85%B6%E4%BB%96-Java-EE-Jakarta-EE-%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81%EF%BC%9A"><span class="nav-number">1.1.4.1.5.</span> <span class="nav-text">5. 提供其他 Java EE &#x2F; Jakarta EE 技术支持：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-2-%E7%AE%80%E8%A6%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">1.4.2 简要工作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-3-%E5%B8%B8%E8%A7%81%E7%9A%84-Servlet-%E5%AE%B9%E5%99%A8"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">1.4.3 常见的 Servlet 容器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Servlet-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.2.</span> <span class="nav-text">2. Servlet 生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 加载与实例化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">2.1.1 触发时机</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-init-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">2.2.1 init() 方法的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-init-%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">2.2.2 init() 方法签名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">2.2.3 代码示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 处理请求</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-service-%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">2.3.1 service() 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-HttpServlet-%E7%9A%84%E8%AF%B7%E6%B1%82%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">2.3.2 HttpServlet 的请求分发机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-doGet-%E4%B8%8E-doPost-%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">2.3.3 doGet() 与 doPost() 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">2.3.4 线程安全问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E9%94%80%E6%AF%81"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 销毁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-destroy-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">2.4.1 destroy() 方法的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-destroy-%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">2.4.2 destroy() 方法签名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">2.4.3 销毁方法的调用时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-4-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">2.4.4 代码示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E8%AF%B4%E6%98%8E"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">重要说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Servlet-%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="nav-number">1.3.</span> <span class="nav-text">3. Servlet 继承体系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Servlet-%E6%8E%A5%E5%8F%A3-javax-servlet-Servlet"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 Servlet 接口 (javax.servlet.Servlet)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">3.1.1 核心职责</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95-The-Five-Methods"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">3.1.2 核心方法 (The Five Methods)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E5%BE%88%E5%B0%91%E7%9B%B4%E6%8E%A5%E5%AE%9E%E7%8E%B0%E6%AD%A4%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">3.1.3 为什么我们很少直接实现此接口？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-GenericServlet-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 GenericServlet 抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E4%B8%BB%E8%A6%81%E8%B4%A1%E7%8C%AE%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">3.2.1 主要贡献与特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8-Web-%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BB%8D%E7%84%B6%E5%BE%88%E5%B0%91%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%AE%83%EF%BC%9F"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">3.2.2 为什么在 Web 开发中仍然很少直接使用它？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-HttpServlet-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3 HttpServlet 抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF%EF%BC%9A%E8%AF%B7%E6%B1%82%E5%88%86%E5%8F%91%E5%99%A8"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">3.3.1 核心优势：请求分发器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">3.3.2 代码示例</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Servlet-%E6%A0%B8%E5%BF%83-API"><span class="nav-number">2.</span> <span class="nav-text">二、Servlet 核心 API</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-HttpServletRequest-%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.1.</span> <span class="nav-text">1. HttpServletRequest (请求对象)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BD%9C%E7%94%A8"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.1 作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E8%A1%8C%E4%BF%A1%E6%81%AF"><span class="nav-number">2.1.2.</span> <span class="nav-text">1.2 获取请求行信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%BF%A1%E6%81%AF"><span class="nav-number">2.1.3.</span> <span class="nav-text">1.3 获取请求头信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="nav-number">2.1.4.</span> <span class="nav-text">1.4 获取请求参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E4%BD%9C%E4%B8%BA%E5%9F%9F%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.1.5.</span> <span class="nav-text">1.5 作为域对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91-RequestDispatcher"><span class="nav-number">2.1.6.</span> <span class="nav-text">1.6 请求转发 (RequestDispatcher)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-HttpServletResponse-%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.2.</span> <span class="nav-text">2. HttpServletResponse (响应对象)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%BD%9C%E7%94%A8"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.1 作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E8%A1%8C"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2 设置响应行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.3 设置响应头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E4%BD%93"><span class="nav-number">2.2.4.</span> <span class="nav-text">2.4 设置响应体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%EF%BC%9A%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">2.2.5.</span> <span class="nav-text">2.5 页面跳转：重定向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91-forward-%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91-redirect-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.2.6.</span> <span class="nav-text">2.6 请求转发 (forward) 与重定向 (redirect) 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">2.2.6.1.</span> <span class="nav-text">使用场景总结：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86-State-Management"><span class="nav-number">3.</span> <span class="nav-text">三、会话管理 (State Management)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Cookie"><span class="nav-number">3.1.</span> <span class="nav-text">1. Cookie</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%AE%9A%E4%B9%89-1"><span class="nav-number">3.1.1.</span> <span class="nav-text">1.1 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">3.1.2.</span> <span class="nav-text">1.2 工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Cookie-API"><span class="nav-number">3.1.3.</span> <span class="nav-text">1.3 Cookie API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-Cookie-%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">3.1.4.</span> <span class="nav-text">1.4 Cookie 的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.1.5.</span> <span class="nav-text">1.5 优缺点及应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-%E4%BC%98%E7%82%B9"><span class="nav-number">3.1.5.1.</span> <span class="nav-text">1.5.1 优点:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-2-%E7%BC%BA%E7%82%B9"><span class="nav-number">3.1.5.2.</span> <span class="nav-text">1.5.2 缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.1.5.3.</span> <span class="nav-text">1.5.3 应用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Session-HttpSession"><span class="nav-number">3.2.</span> <span class="nav-text">2. Session (HttpSession)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%AE%9A%E4%B9%89"><span class="nav-number">3.2.1.</span> <span class="nav-text">2.1 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.2 工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Session-API"><span class="nav-number">3.2.3.</span> <span class="nav-text">2.3 Session API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-Session-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.2.4.</span> <span class="nav-text">2.4 Session 的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-Cookie-%E4%B8%8E-Session-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="nav-number">3.2.5.</span> <span class="nav-text">2.5 Cookie 与 Session 的区别与联系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81Servlet-%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="nav-number">4.</span> <span class="nav-text">四、Servlet 上下文与配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-ServletContext-%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">4.1.</span> <span class="nav-text">1. ServletContext (应用上下文)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%AE%9A%E4%B9%89-2"><span class="nav-number">4.1.1.</span> <span class="nav-text">1.1 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="nav-number">4.1.2.</span> <span class="nav-text">1.2 获取方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E4%BD%9C%E7%94%A8"><span class="nav-number">4.1.3.</span> <span class="nav-text">1.3 作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%89%E5%A4%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93"><span class="nav-number">4.2.</span> <span class="nav-text">2. 三大作用域对象总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-HttpServletRequest-request-scope"><span class="nav-number">4.2.1.</span> <span class="nav-text">2.1 HttpServletRequest (request scope)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-HttpSession-session-scope"><span class="nav-number">4.2.2.</span> <span class="nav-text">2.2 HttpSession (session scope)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-ServletContext-application-scope"><span class="nav-number">4.2.3.</span> <span class="nav-text">2.3 ServletContext (application scope)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Servlet-%E9%85%8D%E7%BD%AE"><span class="nav-number">4.3.</span> <span class="nav-text">3. Servlet 配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%EF%BC%9Aweb-xml-%E9%83%A8%E7%BD%B2%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">4.3.1.</span> <span class="nav-text">3.1 传统方式：web.xml (部署描述符)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#web-xml-%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">web.xml 示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E7%8E%B0%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%9A%E6%B3%A8%E8%A7%A3-Servlet-3-0"><span class="nav-number">4.3.2.</span> <span class="nav-text">3.2 现代方式：注解 (Servlet 3.0+)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">注解示例：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8-Filter-%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8-Listener"><span class="nav-number">5.</span> <span class="nav-text">五、过滤器 (Filter) 与监听器 (Listener)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Filter-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">5.1.</span> <span class="nav-text">1. Filter (过滤器)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%AE%9A%E4%B9%89-3"><span class="nav-number">5.1.1.</span> <span class="nav-text">1.1 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Filter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">5.1.2.</span> <span class="nav-text">1.2 Filter 生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-FilterChain-%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE"><span class="nav-number">5.1.3.</span> <span class="nav-text">1.3 FilterChain (过滤器链)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E9%85%8D%E7%BD%AE"><span class="nav-number">5.1.4.</span> <span class="nav-text">1.4 配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.1.5.</span> <span class="nav-text">1.5 典型应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Listener-%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-number">5.2.</span> <span class="nav-text">2. Listener (监听器)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%AE%9A%E4%B9%89-1"><span class="nav-number">5.2.1.</span> <span class="nav-text">2.1 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%88%86%E7%B1%BB"><span class="nav-number">5.2.2.</span> <span class="nav-text">2.2 分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E7%9B%91%E5%90%AC%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84-Listener"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">2.2.1 监听作用域对象生命周期的 Listener</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E7%9B%91%E5%90%AC%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%8F%98%E5%8C%96%E7%9A%84-Listener"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">2.2.2 监听作用域对象属性变化的 Listener</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E7%9B%91%E5%90%AC-Session-%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81%E7%9A%84-Listener"><span class="nav-number">5.2.2.3.</span> <span class="nav-text">2.2.3 监听 Session 中对象状态的 Listener</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E9%85%8D%E7%BD%AE"><span class="nav-number">5.2.3.</span> <span class="nav-text">2.3 配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.2.4.</span> <span class="nav-text">2.4 典型应用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98%E4%B8%8E%E5%AE%9E%E8%B7%B5"><span class="nav-number">6.</span> <span class="nav-text">六、高级主题与实践</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Servlet-%E4%B8%8E-JSP-%E7%9A%84%E5%85%B3%E7%B3%BB-MVC-%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.</span> <span class="nav-text">1. Servlet 与 JSP 的关系 (MVC 模式)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-JSP%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">6.1.1.</span> <span class="nav-text">1.1 JSP的本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-MVC-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.2.</span> <span class="nav-text">1.2 MVC 设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Servlet-%E4%B8%8E-JSP-%E5%9C%A8-MVC-%E4%B8%AD%E7%9A%84%E5%8D%8F%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-number">6.1.3.</span> <span class="nav-text">1.3 Servlet 与 JSP 在 MVC 中的协作流程：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD"><span class="nav-number">6.2.</span> <span class="nav-text">2. 文件上传与下载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="nav-number">6.2.1.</span> <span class="nav-text">2.1 文件上传</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E5%89%8D%E7%AB%AF%E5%87%86%E5%A4%87%EF%BC%9AHTML-%E8%A1%A8%E5%8D%95"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">2.1.1 前端准备：HTML 表单</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E5%90%8E%E7%AB%AF%E5%A4%84%E7%90%86%EF%BC%9AServlet"><span class="nav-number">6.2.1.2.</span> <span class="nav-text">2.1.2 后端处理：Servlet</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD"><span class="nav-number">6.2.2.</span> <span class="nav-text">2.2 文件下载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="nav-number">6.2.2.1.</span> <span class="nav-text">2.2.1 实现步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%BC%82%E6%AD%A5-Servlet-Servlet-3-0"><span class="nav-number">6.3.</span> <span class="nav-text">3. 异步 Servlet (Servlet 3.0+)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">6.3.1.</span> <span class="nav-text">3.1 解决的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%A0%B8%E5%BF%83-API"><span class="nav-number">6.3.2.</span> <span class="nav-text">3.2 核心 API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="nav-number">6.3.2.1.</span> <span class="nav-text">代码示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">6.3.3.</span> <span class="nav-text">3.3 应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Servlet-%E8%A7%84%E8%8C%83%E6%BC%94%E8%BF%9B"><span class="nav-number">6.4.</span> <span class="nav-text">4. Servlet 规范演进</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E4%BB%8E-javax-servlet-Java-EE-%E5%88%B0-jakarta-servlet-Jakarta-EE-%E7%9A%84%E5%8F%98%E8%BF%81"><span class="nav-number">6.4.1.</span> <span class="nav-text">4.1 从 javax.servlet.* (Java EE) 到 jakarta.servlet.* (Jakarta EE) 的变迁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%B8%8ESpring%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">6.5.</span> <span class="nav-text">5. 与Spring的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E5%AE%B9%E5%99%A8%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E7%AE%A1%E7%90%86-The-Car-Factory"><span class="nav-number">6.5.1.</span> <span class="nav-text">5.1 容器的自动化管理 (The Car Factory)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E8%AF%B7%E6%B1%82%E7%9A%84%E6%A0%B8%E5%BF%83%E5%88%86%E5%8F%91%E8%80%85%EF%BC%9ADispatcherServlet"><span class="nav-number">6.5.2.</span> <span class="nav-text">5.2 请求的核心分发者：DispatcherServlet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E8%AF%B7%E6%B1%82%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">6.5.3.</span> <span class="nav-text">5.3 一个典型请求的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E7%9B%B4%E6%8E%A5%E4%B8%8E-Servlet-API-%E4%BA%A4%E4%BA%92"><span class="nav-number">6.5.4.</span> <span class="nav-text">5.4 直接与 Servlet API 交互</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%9C%A8-Controller-%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9B%B4%E6%8E%A5%E6%B3%A8%E5%85%A5"><span class="nav-number">6.5.4.1.</span> <span class="nav-text">方式一：在 Controller 方法中直接注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E6%B3%A8%E5%86%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84-Filter-Servlet-Listener"><span class="nav-number">6.5.4.2.</span> <span class="nav-text">方式二：注册自定义的 Filter, Servlet, Listener</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/09/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/JavaServlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JavaServlet | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaServlet
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-09 21:21:19" itemprop="dateCreated datePublished" datetime="2025-10-09T21:21:19+08:00">2025-10-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 16:07:22" itemprop="dateModified" datetime="2025-10-17T16:07:22+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Web%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">Web协议与服务器</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="一、Servlet-基础与核心概念"><a href="#一、Servlet-基础与核心概念" class="headerlink" title="一、Servlet 基础与核心概念"></a>一、Servlet 基础与核心概念</h1><h2 id="1-Servlet-是什么？"><a href="#1-Servlet-是什么？" class="headerlink" title="1. Servlet 是什么？"></a>1. Servlet 是什么？</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>Servlet（Server Applet，服务器端小程序）是一种运行在 Web 服务器或应用服务器上的 <strong>Java 程序</strong>。它作为客户端请求（Request）和服务器响应（Response）之间的中间层，用于<strong>生成动态的 Web 内容</strong>。</p>
<p>简单来说，Servlet 就是一个遵循特定规范（Servlet API）的 Java 类，由一个叫做 <strong>“Servlet 容器”</strong>（如 Tomcat）的程序来加载和管理。它的核心职责就是处理客户端发来的请求，并向客户端做出响应。</p>
<p><strong>核心要点:</strong></p>
<ul>
<li><strong>Java 编写：</strong> Servlet 完全使用 Java 语言编写，因此具备 Java 跨平台的特性。</li>
<li><strong>服务器端运行：</strong> 它被部署在 Web 服务器内部，由 Servlet 容器管理其生命周期。</li>
<li><strong>处理请求与响应：</strong> 它的主要工作是接收 HTTP 请求，进行业务逻辑处理（如查询数据库、调用其他服务），然后生成 HTTP 响应（如一个 HTML 页面、JSON 数据）并返回给客户端。</li>
<li><strong>技术规范：</strong> Servlet 是一套标准的 Java API（最初在 <code>javax.servlet</code> 包中，现在是 <code>jakarta.servlet</code> 包），是 Java EE &#x2F; Jakarta EE 规范的核心组成部分，也是构建 Java Web 应用的基石。</li>
</ul>
<hr>
<h3 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2 作用"></a>1.2 作用</h3><p>Servlet 的核心作用是<strong>充当 Web 客户端和服务器端业务逻辑之间的桥梁</strong>，动态地处理请求并生成响应。它使得开发者能够使用 Java 语言来扩展 Web 服务器的功能。</p>
<p>具体来说，Servlet 的作用可以细分为以下几个方面：</p>
<ol>
<li><strong>接收和解析客户端请求：</strong><ul>
<li>从 HTTP 请求中读取和解析数据，例如：<ul>
<li>用户在表单中提交的数据 (<code>request.getParameter()</code>)。</li>
<li>URL 中的查询字符串。</li>
<li>HTTP 请求头信息（如浏览器类型、Cookie 等）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>处理业务逻辑：</strong><ul>
<li>这是 Servlet 的核心职责。它可以根据接收到的请求数据执行任何 Java 代码可以完成的任务。</li>
<li>例如：验证用户登录、与数据库交互（增删改查）、调用其他服务（如微服务、EJB）、执行复杂的计算等。</li>
</ul>
</li>
<li><strong>生成和发送动态响应：</strong><ul>
<li>根据业务逻辑的处理结果，动态地生成响应内容并将其发送回客户端。</li>
<li>响应内容可以是：<ul>
<li>一个完整的 HTML 页面。</li>
<li>JSON 或 XML 格式的数据（常用于 AJAX 和 RESTful API）。</li>
<li>一个重定向指令，让浏览器跳转到另一个页面。</li>
<li>二进制数据流，如图片、PDF 文件等。</li>
</ul>
</li>
</ul>
</li>
<li><strong>管理会话状态：</strong><ul>
<li>HTTP 协议本身是无状态的。Servlet 通过 <code>HttpSession</code> API 能够在多次请求之间跟踪和维持同一个用户的状态。</li>
<li>例如：实现用户登录状态的保持、维护购物车内容等。</li>
</ul>
</li>
<li><strong>在 MVC 模式中充当控制器 (Controller)：</strong><ul>
<li>在经典的 MVC (Model-View-Controller) 设计模式中，Servlet 扮演着<strong>控制器</strong>的角色。它接收所有用户请求，调用业务逻辑（Model），然后选择合适的视图（View，通常是 JSP）来渲染和展示结果。这是 Java Web 开发中最常见的模式。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-3-与-CGI-的对比"><a href="#1-3-与-CGI-的对比" class="headerlink" title="1.3 与 CGI 的对比"></a>1.3 与 CGI 的对比</h3><p>Servlet 的出现主要是为了解决传统 <strong>CGI (Common Gateway Interface, 通用网关接口)</strong> 技术的性能瓶颈问题。CGI 是早期用于在 Web 服务器上执行外部程序以生成动态内容的一种标准。</p>
<table>
<thead>
<tr>
<th>特性 (Feature)</th>
<th>CGI (Common Gateway Interface)</th>
<th>Servlet</th>
</tr>
</thead>
<tbody><tr>
<td><strong>工作模式</strong><br>(Working Model)</td>
<td><strong>多进程模式 (Multi-process)</strong>。<br>每次 HTTP 请求，Web 服务器都会创建一个<strong>全新的独立进程</strong>来执行 CGI 脚本。</td>
<td><strong>多线程模式 (Multi-thread)</strong>。<br>Servlet 实例在容器中<strong>只创建一次</strong>，后续每个请求都由一个<strong>独立的线程</strong>在同一个实例上处理。</td>
</tr>
<tr>
<td><strong>性能与效率</strong><br>(Performance)</td>
<td><strong>低效</strong>。<br>进程的创建和销毁是非常耗时的系统操作，会产生巨大的性能开销。</td>
<td><strong>高效</strong>。<br>线程的创建和切换开销远小于进程。Servlet 实例常驻内存，无需为每个请求重复加载和初始化。</td>
</tr>
<tr>
<td><strong>资源消耗</strong><br>(Resource Usage)</td>
<td><strong>高</strong>。<br>每个请求对应一个进程，会消耗大量的内存和 CPU 资源。</td>
<td><strong>低</strong>。<br>多个线程共享同一个 Servlet 实例的方法区和堆内存，资源利用率极高。</td>
</tr>
<tr>
<td><strong>生命周期</strong><br>(Lifecycle)</td>
<td><strong>请求即生命</strong>。<br>请求处理完毕后，CGI 进程就被销毁，无法维持状态。</td>
<td><strong>长生命周期</strong>。<br>从第一次加载到应用被卸载，Servlet 实例一直存在，可以通过 <code>init()</code> 进行资源初始化，并由容器统一管理。</td>
</tr>
<tr>
<td><strong>可扩展性</strong><br>(Scalability)</td>
<td><strong>差</strong>。<br>当并发请求量增大时，服务器会因创建大量进程而迅速达到资源极限，导致性能急剧下降。</td>
<td><strong>好</strong>。<br>能够轻松地处理成千上万的并发请求，具有优秀的扩展能力。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-4-Servlet-容器（Web-容器）"><a href="#1-4-Servlet-容器（Web-容器）" class="headerlink" title="1.4 Servlet 容器（Web 容器）"></a>1.4 Servlet 容器（Web 容器）</h3><p><strong>Servlet 容器</strong>，也常被称为 <strong>Web 容器</strong>，是一个提供了 Servlet 运行环境的软件组件。它负责管理 Servlet 的整个生命周期，并处理网络通信的底层细节。</p>
<p>简单来说，<strong>Servlet 只是一个遵循特定接口的 Java 类，它本身并不能独立运行</strong>。它必须被部署到 Servlet 容器中，由容器来加载、实例化、调用和销毁。</p>
<h4 id="1-4-1-核心职责"><a href="#1-4-1-核心职责" class="headerlink" title="1.4.1 核心职责"></a>1.4.1 核心职责</h4><h5 id="1-生命周期管理-Lifecycle-Management"><a href="#1-生命周期管理-Lifecycle-Management" class="headerlink" title="1. 生命周期管理 (Lifecycle Management):"></a>1. 生命周期管理 (Lifecycle Management):</h5><ul>
<li><strong>加载和实例化：</strong> 当容器启动或第一次接收到对某个 Servlet 的请求时，它会加载该 Servlet 类并创建一个实例。</li>
<li><strong>初始化：</strong> 调用 Servlet 实例的 <code>init()</code> 方法进行初始化。</li>
<li><strong>请求处理：</strong> 当请求到来时，调用 Servlet 实例的 <code>service()</code> 方法。</li>
<li><strong>销毁：</strong> 当容器关闭或应用被移除时，调用 Servlet 实例的 <code>destroy()</code> 方法释放资源。</li>
<li><strong>开发者不直接调用这些生命周期方法，而是由容器在特定时机自动调用。</strong></li>
</ul>
<hr>
<h5 id="2-通信支持-Communication-Support"><a href="#2-通信支持-Communication-Support" class="headerlink" title="2. 通信支持 (Communication Support):"></a>2. 通信支持 (Communication Support):</h5><ul>
<li>作为 Web 服务器的一部分或与 Web 服务器集成，负责监听特定的网络端口（如 8080）。</li>
<li>接收客户端（如浏览器）发送的 TCP 连接和 HTTP 请求数据流。</li>
<li>将 Servlet 处理后的结果打包成 HTTP 响应格式，通过网络发送回客户端。</li>
</ul>
<hr>
<h5 id="3-请求解析与封装-Request-Parsing-and-Wrapping"><a href="#3-请求解析与封装-Request-Parsing-and-Wrapping" class="headerlink" title="3. 请求解析与封装 (Request Parsing and Wrapping):"></a>3. 请求解析与封装 (Request Parsing and Wrapping):</h5><ul>
<li>容器会将原始的、基于文本的 HTTP 请求数据流解析成开发者易于使用的对象，即 <code>HttpServletRequest</code>。</li>
<li>同时，它会创建一个空的 <code>HttpServletResponse</code> 对象，供 Servlet 写入响应数据。</li>
<li>这两个对象作为参数传递给 Servlet 的 <code>service()</code> 方法。</li>
</ul>
<hr>
<h5 id="4-多线程管理-Multithreading-Management"><a href="#4-多线程管理-Multithreading-Management" class="headerlink" title="4. 多线程管理 (Multithreading Management):"></a>4. 多线程管理 (Multithreading Management):</h5><ul>
<li>Servlet 默认是<strong>单实例多线程</strong>的。容器接收到多个并发请求时，会为每个请求分配一个线程（通常来自线程池），然后这些线程<strong>共享同一个 Servlet 实例</strong>去执行 <code>service()</code> 方法。</li>
<li>这极大地提高了性能，但也要求开发者必须注意<strong>线程安全</strong>问题。</li>
</ul>
<hr>
<h5 id="5-提供其他-Java-EE-Jakarta-EE-技术支持："><a href="#5-提供其他-Java-EE-Jakarta-EE-技术支持：" class="headerlink" title="5. 提供其他 Java EE &#x2F; Jakarta EE 技术支持："></a>5. 提供其他 Java EE &#x2F; Jakarta EE 技术支持：</h5><ul>
<li>除了 Servlet，容器还负责管理和提供 JSP（JavaServer Pages）、Filter（过滤器）、Listener（监听器）等的运行环境。例如，它负责将 JSP 文件编译成 Servlet。</li>
</ul>
<hr>
<h4 id="1-4-2-简要工作流程"><a href="#1-4-2-简要工作流程" class="headerlink" title="1.4.2 简要工作流程"></a>1.4.2 简要工作流程</h4><pre><code class="highlight mermaid">sequenceDiagram
    %% 1. 客户端发送请求
    Client-&gt;&gt;Container: 1. 发送 HTTP 请求

    %% 2-5. 容器处理请求并调用 Servlet
    activate Container
    Note over Container: 2. 接收到请求
    Note over Container: 3. 根据 URL 在 web.xml/注解中查找 Servlet
    Note over Container: 4. 封装 Request 和 Response 对象
    
    Container-&gt;&gt;ThreadPool: 5a. 从线程池获取线程
    activate ThreadPool
    ThreadPool--&gt;&gt;Container: 返回工作线程
    deactivate ThreadPool
    
    Container-&gt;&gt;Servlet: 5b. 调用 service(request, response)
    activate Servlet

    %% 6. Servlet 执行业务逻辑
    Note right of Servlet: 6. 执行业务逻辑，&lt;br/&gt;并将结果写入 Response 对象
    
    %% 7-8. Servlet 返回，容器发送响应
    Servlet--&gt;&gt;Container: service() 方法执行完毕
    deactivate Servlet
    
    Container-&gt;&gt;ThreadPool: 7. 将线程归还到线程池
    activate ThreadPool
    deactivate ThreadPool
    
    Note over Container: 8a. 从 Response 对象生成 HTTP 响应
    Container--&gt;&gt;Client: 8b. 发送最终的 HTTP 响应
    deactivate Container</code></pre>

<ol>
<li>客户端（浏览器）向服务器发送一个 HTTP 请求。</li>
<li><strong>Servlet 容器</strong>（如 Tomcat）接收到这个请求。</li>
<li>容器根据请求的 URL，在 <code>web.xml</code> 或注解中查找并确定应该由哪个 Servlet 来处理。</li>
<li>容器将原始请求数据封装成 <code>HttpServletRequest</code> 对象，并创建一个 <code>HttpServletResponse</code> 对象。</li>
<li>容器从线程池中获取一个线程，调用目标 Servlet 实例的 <code>service()</code> 方法，并将 request 和 response 对象作为参数传入。</li>
<li>Servlet 在 <code>service()</code> 方法中执行业务逻辑，处理数据，并将结果写入 <code>HttpServletResponse</code> 对象。</li>
<li><code>service()</code> 方法执行完毕后，线程被归还到线程池。</li>
<li>容器从 <code>HttpServletResponse</code> 对象中生成最终的 HTTP 响应，并将其发送回客户端。</li>
</ol>
<hr>
<h4 id="1-4-3-常见的-Servlet-容器"><a href="#1-4-3-常见的-Servlet-容器" class="headerlink" title="1.4.3 常见的 Servlet 容器"></a>1.4.3 常见的 Servlet 容器</h4><ul>
<li><strong>Apache Tomcat:</strong> 最流行、最广泛使用的开源 Servlet&#x2F;JSP 容器，是 Servlet 规范的官方参考实现。</li>
<li><strong>Jetty:</strong> 一个轻量级、高度可嵌入的开源 Servlet 容器。</li>
<li><strong>GlassFish:</strong> Oracle 开发的，Jakarta EE 规范的官方参考实现，是一个完整的应用服务器。</li>
<li><strong>WildFly (原 JBoss):</strong> Red Hat 公司开发的开源应用服务器。</li>
</ul>
<hr>
<h2 id="2-Servlet-生命周期"><a href="#2-Servlet-生命周期" class="headerlink" title="2. Servlet 生命周期"></a>2. Servlet 生命周期</h2><h3 id="2-1-加载与实例化"><a href="#2-1-加载与实例化" class="headerlink" title="2.1 加载与实例化"></a>2.1 加载与实例化</h3><p>这是 Servlet 生命周期的<strong>第一个阶段</strong>。在这个阶段，Servlet 容器会找到 Servlet 对应的 <code>.class</code> 文件，将其加载到 JVM 内存中，并创建一个 Servlet 实例。</p>
<p><strong>核心要点：</strong></p>
<ul>
<li><strong>执行时机：</strong> 加载和实例化的动作<strong>只会发生一次</strong>。</li>
<li><strong>结果：</strong> 在整个 Web 应用的生命周期中，一个 Servlet 类<strong>只有一个实例</strong>存在。这也就是我们常说的 Servlet 是**“单例多线程”**模式。</li>
</ul>
<h4 id="2-1-1-触发时机"><a href="#2-1-1-触发时机" class="headerlink" title="2.1.1 触发时机"></a>2.1.1 触发时机</h4><p>Servlet 容器在何时进行加载和实例化，主要有两种情况：</p>
<ol>
<li><p><strong>第一次被访问时（默认行为）</strong></p>
<ul>
<li>这是容器的默认策略，也称为<strong>延迟加载 (Lazy Loading)</strong>。</li>
<li>当第一个匹配该 Servlet 的 HTTP 请求到来时，容器才会去创建 Servlet 实例。</li>
<li><strong>优点：</strong> 节约服务器资源，如果某个 Servlet 一直未被访问，它就不会被实例化，不会占用内存。</li>
<li><strong>缺点：</strong> 第一个访问该 Servlet 的用户会经历一个明显的延迟，因为容器需要完成加载、实例化和初始化这几个步骤。</li>
</ul>
</li>
<li><p><strong>Web 应用启动时</strong></p>
<ul>
<li><p>我们可以配置 Servlet 在 Web 应用启动时就立即被加载和实例化，也称为<strong>立即加载 (Eager Loading)</strong>。</p>
</li>
<li><p><strong>优点：</strong></p>
<ul>
<li>可以将耗时的初始化工作（如建立数据库连接池、加载配置文件等）在服务器启动时完成，确保第一个用户访问时能获得快速响应。</li>
<li>可以确保某些需要在应用启动时就运行的后台任务或服务能够被正确初始化。</li>
</ul>
</li>
<li><p><strong>配置方式：</strong></p>
<ul>
<li><strong>XML (<code>web.xml</code>)</strong>: 在 <code>&lt;servlet&gt;</code> 标签内配置 <code>&lt;load-on-startup&gt;</code>。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.example.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span> <span class="comment">&lt;!-- 数字越小，优先级越高 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注解 (<code>@WebServlet</code>)</strong>: 在注解中设置 <code>loadOnStartup</code> 属性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/myServlet&quot;, loadOnStartup = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意:</strong> <code>&lt;load-on-startup&gt;</code> 的值是一个非负整数。值越小，该 Servlet 的启动优先级越高。如果值为负数或未设置，则采用默认的延迟加载策略。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p><strong>过程简述：<strong>Servlet 容器通过 Java 的反射机制，调用 Servlet 类的</strong>公共无参构造方法</strong>来创建实例。因此，我们自定义的 Servlet 必须提供一个公共的无参构造函数（通常我们不写，Java 会提供一个默认的）。</p>
<hr>
<h3 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h3><p>这是 Servlet 生命周期的<strong>第二个阶段</strong>，紧跟在加载与实例化之后。在这个阶段，Servlet 容器会调用 Servlet 实例的 <code>init()</code> 方法。</p>
<p><strong>核心要点：</strong></p>
<ul>
<li><strong>执行时机：</strong> 在 Servlet 实例被创建后，<strong>立即执行</strong>，且在 Servlet 的整个生命周期中<strong>只会被执行一次</strong>。</li>
<li><strong>主要目的：</strong> 执行一次性的、耗时的准备工作，为后续处理请求做好准备。</li>
</ul>
<h4 id="2-2-1-init-方法的作用"><a href="#2-2-1-init-方法的作用" class="headerlink" title="2.2.1 init() 方法的作用"></a>2.2.1 <code>init()</code> 方法的作用</h4><p><code>init()</code> 方法就像一个类的构造函数，但它专门为 Servlet 的环境而设计。我们通常会重写此方法来完成以下任务：</p>
<ol>
<li><strong>加载配置文件：</strong> 读取 <code>.properties</code> 或 <code>.xml</code> 等配置文件。</li>
<li><strong>建立数据库连接：</strong> 创建数据库连接或初始化一个数据库连接池。</li>
<li><strong>初始化缓存：</strong> 将一些需要频繁访问但不常变动的数据加载到内存中，形成缓存。</li>
<li><strong>读取“初始化参数”：</strong> 获取在 <code>web.xml</code> 或注解中为该特定 Servlet 配置的参数。</li>
</ol>
<h4 id="2-2-2-init-方法签名"><a href="#2-2-2-init-方法签名" class="headerlink" title="2.2.2 init() 方法签名"></a>2.2.2 <code>init()</code> 方法签名</h4><p><code>init()</code> 方法在 <code>javax.servlet.Servlet</code> 接口中定义，其声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数 <code>ServletConfig config</code>：</strong><ul>
<li>这是 <code>init()</code> 方法最重要的部分。容器在调用 <code>init()</code> 方法时，会传入一个 <code>ServletConfig</code> 对象。</li>
<li><code>ServletConfig</code> 对象封装了该 Servlet 的配置信息。</li>
<li>通过 <code>ServletConfig</code> 对象，我们可以：<ul>
<li><code>getServletName()</code>: 获取 Servlet 的名称。</li>
<li><code>getServletContext()</code>: 获取代表整个 Web 应用的 <code>ServletContext</code> 对象。</li>
<li><strong><code>getInitParameter(String name)</code></strong>: 获取在部署描述符（<code>web.xml</code>）或注解中配置的<strong>初始化参数</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-3-代码示例"><a href="#2-2-3-代码示例" class="headerlink" title="2.2.3 代码示例"></a>2.2.3 代码示例</h4><p>假设我们在 <code>web.xml</code> 中为 Servlet 配置了初始化参数：</p>
<p><strong>web.xml 配置:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ConfigDemoServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.example.ConfigDemoServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义初始化参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>adminEmail<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>admin@example.com<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Servlet Java 代码:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigDemoServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String servletEncoding; <span class="comment">// 定义一个成员变量来存储配置信息</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 1. 【非常重要】调用父类的 init 方法，将 ServletConfig 对象保存起来</span></span><br><span class="line">        <span class="built_in">super</span>.init(config);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 通过 config 对象获取初始化参数</span></span><br><span class="line">        <span class="built_in">this</span>.servletEncoding = config.getInitParameter(<span class="string">&quot;encoding&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">adminEmail</span> <span class="operator">=</span> config.getInitParameter(<span class="string">&quot;adminEmail&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 执行初始化逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.servletEncoding == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.servletEncoding = <span class="string">&quot;ISO-8859-1&quot;</span>; <span class="comment">// 如果未配置，则使用默认值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Servlet 初始化完成...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;编码格式: &quot;</span> + <span class="built_in">this</span>.servletEncoding);</span><br><span class="line">        System.out.println(<span class="string">&quot;管理员邮箱: &quot;</span> + adminEmail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 在后续处理请求时，就可以使用在 init 方法中初始化的变量</span></span><br><span class="line">        resp.setCharacterEncoding(<span class="built_in">this</span>.servletEncoding);</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Hello, encoding is set to &quot;</span> + <span class="built_in">this</span>.servletEncoding);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>最佳实践：</strong></p>
<p>当我们重写 <code>init(ServletConfig config)</code> 方法时，<strong>强烈建议在方法的第一行调用 <code>super.init(config);</code></strong>。</p>
<p>这是因为父类 <code>GenericServlet</code> 的 <code>init()</code> 方法会将 <code>ServletConfig</code> 对象保存下来，以便我们后续可以通过 <code>getServletConfig()</code> 或 <code>getServletContext()</code> 等方法来获取它。如果不调用 <code>super.init(config)</code>，后续调用这些方法将会抛出 <code>NullPointerException</code>。</p>
</blockquote>
<hr>
<h3 id="2-3-处理请求"><a href="#2-3-处理请求" class="headerlink" title="2.3 处理请求"></a>2.3 处理请求</h3><p>这是 Servlet 生命周期的<strong>第三个阶段</strong>，也是 Servlet 存在的主要目的。一旦 Servlet 完成了实例化和初始化，它就会处于“就绪”状态，等待并处理来自客户端的请求。</p>
<p><strong>核心要点：</strong></p>
<ul>
<li><strong>执行时机：</strong> <strong>每当</strong>有一个客户端请求与该 Servlet 的 URL 匹配时，容器就会调用其服务方法。这个阶段会<strong>被重复执行无数次</strong>。</li>
<li><strong>核心方法：</strong> <code>service()</code> 方法是所有请求的入口点。</li>
<li><strong>线程模型：</strong> 容器会为每个请求分配一个线程来执行 <code>service()</code> 方法。多个线程会<strong>并发地访问同一个 Servlet 实例</strong>，因此必须注意<strong>线程安全</strong>问题。</li>
</ul>
<h4 id="2-3-1-service-方法"><a href="#2-3-1-service-方法" class="headerlink" title="2.3.1 service() 方法"></a>2.3.1 <code>service()</code> 方法</h4><p><code>Servlet</code> 接口中定义了 <code>service()</code> 方法，它是处理所有请求的起点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException;</span><br></pre></td></tr></table></figure>

<p>然而，在实际开发中，我们通常继承的是 <code>HttpServlet</code>。<code>HttpServlet</code> 对 <code>service()</code> 方法进行了重写，使其能够根据 HTTP 请求的类型（GET, POST, PUT, DELETE 等）来分发请求。</p>
<hr>
<h4 id="2-3-2-HttpServlet-的请求分发机制"><a href="#2-3-2-HttpServlet-的请求分发机制" class="headerlink" title="2.3.2 HttpServlet 的请求分发机制"></a>2.3.2 <code>HttpServlet</code> 的请求分发机制</h4><p><code>HttpServlet</code> 的 <code>service()</code> 方法内部实现了一个<strong>分发器</strong>。其工作流程如下：</p>
<ol>
<li>容器接收到请求，调用 <code>HttpServlet</code> 的 <code>service(HttpServletRequest req, HttpServletResponse res)</code> 方法。</li>
<li><code>service()</code> 方法内部会通过 <code>req.getMethod()</code> 获取请求的类型（例如 “GET” 或 “POST”）。</li>
<li>它会使用一个大的 <code>if-else</code> 或 <code>switch</code> 结构，根据请求类型，调用与之对应的 <code>doXXX()</code> 方法。<ul>
<li>如果请求是 GET，就调 用 <code>doGet(req, res)</code>。</li>
<li>如果请求是 POST，就调用 <code>doPost(req, res)</code>。</li>
<li>以此类推，还有 <code>doPut()</code>, <code>doDelete()</code> 等。</li>
</ul>
</li>
</ol>
<p><strong>这就是为什么我们通常不需要重写 <code>service()</code> 方法，而是去重写 <code>doGet()</code> 或 <code>doPost()</code> 方法。</strong></p>
<hr>
<h4 id="2-3-3-doGet-与-doPost-方法"><a href="#2-3-3-doGet-与-doPost-方法" class="headerlink" title="2.3.3 doGet() 与 doPost() 方法"></a>2.3.3 <code>doGet()</code> 与 <code>doPost()</code> 方法</h4><p>这两个是我们最常重写的方法，用于实现具体的业务逻辑。</p>
<ul>
<li><code>protected void doGet(HttpServletRequest request, HttpServletResponse response)</code><ul>
<li>处理 HTTP GET 请求。GET 请求通常用于从服务器获取数据，例如点击链接、在浏览器地址栏直接输入 URL。</li>
</ul>
</li>
<li><code>protected void doPost(HttpServletRequest request, HttpServletResponse response)</code><ul>
<li>处理 HTTP POST 请求。POST 请求通常用于向服务器提交数据，例如提交一个表单。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-3-4-线程安全问题"><a href="#2-3-4-线程安全问题" class="headerlink" title="2.3.4 线程安全问题"></a>2.3.4 线程安全问题</h4><p>这是 Servlet 中一个非常重要且容易出错的概念。</p>
<ul>
<li><strong>原因：</strong> Servlet 容器对每个 Servlet 类只创建一个实例。当多个请求同时到达时，容器会启动多个线程，这些线程<strong>共享这唯一的 Servlet 实例</strong>。</li>
<li><strong>风险：</strong> 如果你在 Servlet 中定义了<strong>成员变量 (Instance Variables)</strong>，并且在 <code>doGet()</code> 或 <code>doPost()</code> 方法中对它进行了修改操作（写操作），那么就会发生线程安全问题。多个线程可能会同时读写这个共享变量，导致数据错乱。</li>
</ul>
<p><strong>最佳实践：</strong></p>
<ol>
<li><strong>避免使用成员变量来存储请求相关的状态。</strong></li>
<li><strong>优先使用局部变量 (Local Variables)。</strong> 在 <code>doGet()</code> 或 <code>doPost()</code> 方法内部定义的变量是局部变量，它们存储在每个线程独有的栈空间中，因此是线程安全的。</li>
<li>如果确实需要使用成员变量来共享数据（例如，一个访问计数器），必须使用同步机制（如 <code>synchronized</code> 关键字或 <code>java.util.concurrent</code> 包中的锁）来保证线程安全。</li>
</ol>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个成员变量，如果对其进行写操作，需要考虑线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">accessCounter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 业务逻辑开始 ---</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取请求参数 (name 是局部变量，线程安全)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">            name = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 处理业务 (更新共享的计数器，使用原子类保证线程安全)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">currentCount</span> <span class="operator">=</span> accessCounter.incrementAndGet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 设置响应内容</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line"></span><br><span class="line">        out.println(<span class="string">&quot;&lt;html&gt;&lt;body&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;h1&gt;Hello, &quot;</span> + name + <span class="string">&quot;!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;p&gt;You are the &quot;</span> + currentCount + <span class="string">&quot; visitor.&lt;/p&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --- 业务逻辑结束 ---</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-4-销毁"><a href="#2-4-销毁" class="headerlink" title="2.4 销毁"></a>2.4 销毁</h3><p>这是 Servlet 生命周期的<strong>最后一个阶段</strong>。当 Servlet 容器决定不再需要该 Servlet 实例时（例如，服务器关闭或 Web 应用被移除），它会调用 Servlet 的 <code>destroy()</code> 方法，为实例的“死亡”做最后的清理工作。</p>
<p><strong>核心要点：</strong></p>
<ul>
<li><strong>执行时机：</strong> 在 Servlet 实例从服务中被移除之前执行。</li>
<li><strong>执行次数：</strong> 与 <code>init()</code> 方法一样，<code>destroy()</code> 方法在 Servlet 的整个生命周期中也<strong>只会被执行一次</strong>。</li>
<li><strong>主要目的：</strong> 释放 Servlet 在 <code>init()</code> 方法中创建的资源，或者在处理请求过程中持有的持久化资源。</li>
</ul>
<h4 id="2-4-1-destroy-方法的作用"><a href="#2-4-1-destroy-方法的作用" class="headerlink" title="2.4.1 destroy() 方法的作用"></a>2.4.1 <code>destroy()</code> 方法的作用</h4><p><code>destroy()</code> 方法是 <code>init()</code> 方法的对应操作。如果在 <code>init()</code> 中分配了资源，那么 <code>destroy()</code> 就是释放这些资源的最佳地点。</p>
<p>典型的清理任务包括：</p>
<ol>
<li><strong>关闭数据库连接：</strong> 关闭在 <code>init()</code> 中创建的数据库连接或销毁连接池。</li>
<li><strong>关闭文件流：</strong> 关闭打开的文件句柄或 I&#x2F;O 流。</li>
<li><strong>中断后台线程：</strong> 如果 Servlet 启动了一些后台任务线程，需要在这里优雅地停止它们。</li>
<li><strong>保存状态：</strong> 在应用关闭前，将一些内存中的状态数据（如访问计数器）持久化到文件或数据库中。</li>
</ol>
<hr>
<h4 id="2-4-2-destroy-方法签名"><a href="#2-4-2-destroy-方法签名" class="headerlink" title="2.4.2 destroy() 方法签名"></a>2.4.2 <code>destroy()</code> 方法签名</h4><p><code>destroy()</code> 方法在 <code>javax.servlet.Servlet</code> 接口中定义，其签名非常简单，没有任何参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-4-3-销毁方法的调用时机"><a href="#2-4-3-销毁方法的调用时机" class="headerlink" title="2.4.3 销毁方法的调用时机"></a>2.4.3 销毁方法的调用时机</h4><p>Servlet 容器会在以下几种情况下调用 <code>destroy()</code> 方法：</p>
<ol>
<li><strong>Web 应用被卸载（Undeployed）：</strong> 当你从容器中移除一个 Web 应用时，容器会销毁该应用中所有的 Servlet 实例。</li>
<li><strong>Servlet 容器正常关闭或停止：</strong> 当你正常关闭 Tomcat 等服务器时，容器会优雅地销毁它管理的所有 Servlet。</li>
<li><strong>重新部署（Redeploy）应用时：</strong> 在不停止服务器的情况下重新部署应用，容器会先销毁旧应用的 Servlet 实例，然后再创建新应用的实例。</li>
</ol>
<hr>
<h4 id="2-4-4-代码示例"><a href="#2-4-4-代码示例" class="headerlink" title="2.4.4 代码示例"></a>2.4.4 代码示例</h4><p>假设一个 Servlet 在初始化时打开了一个日志文件写入器，那么它必须在销毁时关闭这个写入器，以防止资源泄漏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PrintWriter logWriter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取文件真实路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">logFilePath</span> <span class="operator">=</span> getServletContext().getRealPath(<span class="string">&quot;/WEB-INF/logs/servlet.log&quot;</span>);</span><br><span class="line">            <span class="comment">// 在初始化时，打开一个文件写入器作为资源</span></span><br><span class="line">            <span class="comment">// true 表示追加模式</span></span><br><span class="line">            <span class="built_in">this</span>.logWriter = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(logFilePath, <span class="literal">true</span>));</span><br><span class="line">            logWriter.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">            logWriter.println(<span class="string">&quot;ResourceServlet initialized.&quot;</span>);</span><br><span class="line">            logWriter.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;Log file writer initialized.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;Failed to initialize log writer&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 每次请求都记录一条日志</span></span><br><span class="line">        <span class="keyword">if</span> (logWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">            logWriter.println(<span class="string">&quot;Processing a GET request at &quot;</span> + <span class="keyword">new</span> <span class="title class_">java</span>.util.Date());</span><br><span class="line">            logWriter.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Request logged.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在销毁时，关闭并释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">            logWriter.println(<span class="string">&quot;ResourceServlet is being destroyed.&quot;</span>);</span><br><span class="line">            logWriter.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">            logWriter.flush();</span><br><span class="line">            logWriter.close(); <span class="comment">// 关键步骤：关闭流</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Log file writer closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重要说明"><a href="#重要说明" class="headerlink" title="重要说明"></a>重要说明</h4><ul>
<li><code>destroy()</code> 方法的执行是<strong>不能保证</strong>的。如果 Servlet 容器异常崩溃（例如，JVM 崩溃或服务器被强制 <code>kill -9</code> 终止），<code>destroy()</code> 方法可能根本没有机会被调用。因此，它只适用于<strong>优雅关闭 (graceful shutdown)</strong> 的场景。</li>
<li>一旦 <code>destroy()</code> 方法被调用，容器就会释放对该 Servlet 实例的引用，之后它会被 Java 的垃圾回收器 (Garbage Collector) 回收。如果后续还有对该 Servlet 的请求，容器会<strong>重新创建一个新的实例</strong>，并再次执行 <code>init()</code> 方法，开始一个新的生命周期。</li>
</ul>
<hr>
<h2 id="3-Servlet-继承体系"><a href="#3-Servlet-继承体系" class="headerlink" title="3. Servlet 继承体系"></a>3. Servlet 继承体系</h2><h3 id="3-1-Servlet-接口-javax-servlet-Servlet"><a href="#3-1-Servlet-接口-javax-servlet-Servlet" class="headerlink" title="3.1 Servlet 接口 (javax.servlet.Servlet)"></a>3.1 <code>Servlet</code> 接口 (javax.servlet.Servlet)</h3><p><code>Servlet</code> 接口是整个 Servlet API 的<strong>基石和核心</strong>。它位于 <code>javax.servlet</code> (或 Jakarta EE 9+ 中的 <code>jakarta.servlet</code>) 包中，定义了一个<strong>契约 (Contract)</strong>，任何想要成为 Servlet 的 Java 类都必须直接或间接地实现这个接口。</p>
<p>这个接口是<strong>协议无关 (Protocol-Independent)</strong> 的，意味着它不局限于 HTTP 协议。理论上，它可以被用来处理任何类型的客户端&#x2F;服务器协议。</p>
<h4 id="3-1-1-核心职责"><a href="#3-1-1-核心职责" class="headerlink" title="3.1.1 核心职责"></a>3.1.1 核心职责</h4><p><code>Servlet</code> 接口的核心职责是<strong>定义 Servlet 的生命周期方法</strong>。它规定了 Servlet 容器与 Servlet 实例之间交互的标准方式。</p>
<hr>
<h4 id="3-1-2-核心方法-The-Five-Methods"><a href="#3-1-2-核心方法-The-Five-Methods" class="headerlink" title="3.1.2 核心方法 (The Five Methods)"></a>3.1.2 核心方法 (The Five Methods)</h4><p><code>Servlet</code> 接口中定义了五个方法，它们构成了 Servlet 的基本框架：</p>
<ol>
<li><code>void init(ServletConfig config) throws ServletException;</code><ul>
<li><strong>生命周期方法。</strong></li>
<li>当 Servlet 实例被创建后，容器会调用此方法进行初始化。</li>
<li>它在 Servlet 的整个生命周期中只会被调用一次。</li>
<li>参数 <code>ServletConfig</code> 包含了 Servlet 的配置信息。</li>
</ul>
</li>
<li><code>void service(ServletRequest req, ServletResponse res) throws ServletException, IOException;</code><ul>
<li><strong>生命周期方法，也是最核心的方法。</strong></li>
<li>每当有请求到达时，容器就会调用此方法来处理请求。</li>
<li>参数 <code>ServletRequest</code> 和 <code>ServletResponse</code> 封装了请求和响应信息，但它们是通用的，不包含任何特定于 HTTP 的功能。</li>
</ul>
</li>
<li><code>void destroy();</code><ul>
<li><strong>生命周期方法。</strong></li>
<li>当 Servlet 实例即将被销毁时，容器会调用此方法，用于释放资源。</li>
<li>它在 Servlet 的整个生命周期中也只会被调用一次。</li>
</ul>
</li>
<li><code>ServletConfig getServletConfig();</code><ul>
<li><strong>辅助方法。</strong></li>
<li>返回一个 <code>ServletConfig</code> 对象，该对象是容器在调用 <code>init</code> 方法时传入的。</li>
<li>通过这个方法，Servlet 可以在生命周期的任何时刻获取自己的配置信息。</li>
</ul>
</li>
<li><code>String getServletInfo();</code><ul>
<li><strong>辅助方法。</strong></li>
<li>返回一个描述 Servlet 的字符串，例如作者、版本、版权信息等。</li>
<li>这个方法主要用于管理工具，实际开发中很少使用。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-1-3-为什么我们很少直接实现此接口？"><a href="#3-1-3-为什么我们很少直接实现此接口？" class="headerlink" title="3.1.3 为什么我们很少直接实现此接口？"></a>3.1.3 为什么我们很少直接实现此接口？</h4><p>在实际的 Web 开发中，我们几乎从不直接实现 <code>Servlet</code> 接口，原因如下：</p>
<ul>
<li><strong>过于通用和底层：</strong> <code>Servlet</code> 接口是协议无关的。它的 <code>ServletRequest</code> 和 <code>ServletResponse</code> 对象没有提供处理 HTTP 特有信息（如请求方法 GET&#x2F;POST、请求头、Cookie、Session 等）的便捷方法。如果直接实现它，你需要自己去解析原始的请求数据流，这非常繁琐且容易出错。</li>
<li><strong>需要实现所有方法：</strong> 作为一个接口，你必须为它的所有五个方法都提供实现，即使你只需要用到 <code>service</code> 方法，其他方法也需要写一个空实现，这增加了样板代码。</li>
</ul>
<p>为了解决这些问题，Servlet API 提供了两个方便的实现类：<code>GenericServlet</code> 和 <code>HttpServlet</code>，它们为我们处理了大量底层工作。</p>
<hr>
<h3 id="3-2-GenericServlet-抽象类"><a href="#3-2-GenericServlet-抽象类" class="headerlink" title="3.2 GenericServlet 抽象类"></a>3.2 <code>GenericServlet</code> 抽象类</h3><p><code>GenericServlet</code> 是一个抽象类，它实现了 <code>Servlet</code> 接口和 <code>ServletConfig</code> 接口，提供了一个通用的、<strong>协议无关</strong>的 Servlet 骨架。</p>
<p>它的主要目的是<strong>简化 Servlet 的编写</strong>，让我们不必从零开始实现 <code>Servlet</code> 接口中的所有方法，从而可以更专注于业务逻辑。</p>
<h4 id="3-2-1-主要贡献与特点"><a href="#3-2-1-主要贡献与特点" class="headerlink" title="3.2.1 主要贡献与特点"></a>3.2.1 主要贡献与特点</h4><ol>
<li><strong>实现了 <code>Servlet</code> 接口：</strong><ul>
<li>它为 <code>Servlet</code> 接口中的大多数方法提供了默认的、有意义的实现。例如，<code>destroy()</code> 和 <code>getServletInfo()</code> 方法都有了默认的空实现，子类只有在需要时才需要重写它们。</li>
</ul>
</li>
<li><strong>简化了 <code>init()</code> 方法：</strong><ul>
<li><code>GenericServlet</code> 已经为我们实现了 <code>init(ServletConfig config)</code> 方法。它的主要工作就是将容器传入的 <code>ServletConfig</code> 对象保存起来，以便后续通过 <code>getServletConfig()</code> 等方法调用。</li>
<li>它还提供了一个更方便的、<strong>无参数的 <code>init()</code> 方法</strong>供子类重写。这样，我们在进行自己的初始化工作时，就无需再手动调用 <code>super.init(config)</code> 了。</li>
</ul>
</li>
<li><strong>唯一的抽象方法 <code>service()</code>：</strong><ul>
<li><code>GenericServlet</code> 将 <code>service(ServletRequest req, ServletResponse res)</code> 方法声明为 <code>abstract</code>。</li>
<li>这意味着任何继承 <code>GenericServlet</code> 的子类都<strong>必须</strong>实现这个方法，因为这正是处理请求的核心逻辑所在。</li>
</ul>
</li>
<li><strong>提供了便捷的辅助方法：</strong><ul>
<li>它实现了 <code>ServletConfig</code> 接口的所有方法，如 <code>getServletContext()</code>、<code>getInitParameter(String name)</code>、<code>getServletName()</code> 等。</li>
<li>这使得我们在 Servlet 内部可以直接调用 <code>getServletContext()</code> 来获取应用上下文，而不需要先 <code>getServletConfig().getServletContext()</code>，大大简化了代码。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-2-2-为什么在-Web-开发中仍然很少直接使用它？"><a href="#3-2-2-为什么在-Web-开发中仍然很少直接使用它？" class="headerlink" title="3.2.2 为什么在 Web 开发中仍然很少直接使用它？"></a>3.2.2 为什么在 Web 开发中仍然很少直接使用它？</h4><p>尽管 <code>GenericServlet</code> 提供了很多便利，但在基于 HTTP 协议的 Web 开发中，我们仍然很少直接继承它。主要原因是：</p>
<ul>
<li><strong>协议无关性：</strong> 它的设计目标是通用的，不依赖于任何特定协议。因此，它的核心 <code>service</code> 方法的参数是通用的 <code>ServletRequest</code> 和 <code>ServletResponse</code>。</li>
<li><strong>功能局限：</strong> 这两个通用接口<strong>没有提供处理 HTTP 协议特有信息的方法</strong>。例如，你无法直接从 <code>ServletRequest</code> 中获取请求是 GET 还是 POST，也无法从 <code>ServletResponse</code> 中设置 Cookie 或进行重定向。如果想使用这些功能，你必须先将参数强制类型转换为 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code>，这既不方便也不优雅。</li>
</ul>
<p><strong>示例代码 (不推荐用于 Web 开发):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个继承 GenericServlet 的例子，仅作演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGenericServlet</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest request, ServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须进行强制类型转换才能使用 HTTP 特有的功能</span></span><br><span class="line">        <span class="comment">// HttpServletRequest httpRequest = (HttpServletRequest) request;</span></span><br><span class="line">        <span class="comment">// String method = httpRequest.getMethod();</span></span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;This is a response from GenericServlet.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论：</strong><code>GenericServlet</code> 是一个重要的中间层，它为实现 <code>Servlet</code> 接口提供了极大的便利。但由于其协议无关的特性，它并不直接适用于处理 HTTP 请求。为了解决这个问题，Servlet API 在 <code>GenericServlet</code> 的基础上，提供了一个专门用于 HTTP 协议的子类——<code>HttpServlet</code>。</p>
<hr>
<h3 id="3-3-HttpServlet-抽象类"><a href="#3-3-HttpServlet-抽象类" class="headerlink" title="3.3 HttpServlet 抽象类"></a>3.3 <code>HttpServlet</code> 抽象类</h3><p><code>HttpServlet</code> 是一个专门为处理 <strong>HTTP 协议</strong> 而设计的抽象类，它继承自 <code>GenericServlet</code>。在实际的 Java Web 开发中，我们编写的 Servlet <strong>几乎总是</strong>直接或间接地继承自 <code>HttpServlet</code>。</p>
<p>它封装了处理 HTTP 请求的复杂性，为开发者提供了一个清晰、强大且易于使用的编程模型。</p>
<h4 id="3-3-1-核心优势：请求分发器"><a href="#3-3-1-核心优势：请求分发器" class="headerlink" title="3.3.1 核心优势：请求分发器"></a>3.3.1 核心优势：请求分发器</h4><p><code>HttpServlet</code> 最核心、最巧妙的设计在于它对 <code>service()</code> 方法的重写。它并没有将 <code>service()</code> 方法声明为抽象的，而是提供了一个具体的实现。这个 <code>service()</code> 方法不包含任何业务逻辑，而是扮演一个<strong>请求分发器 (Dispatcher)</strong> 的角色。</p>
<p>其工作流程如下：</p>
<ol>
<li><strong>接收请求：</strong> 容器调用 <code>HttpServlet</code> 的 <code>service()</code> 方法，传入 <code>ServletRequest</code> 和 <code>ServletResponse</code> 对象。</li>
<li><strong>类型转换：</strong> <code>service()</code> 方法内部首先将这两个通用的对象向下转型（cast）为 HTTP 专用的 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 对象。如果转换失败，会抛出 <code>ServletException</code>。</li>
<li><strong>获取请求方法：</strong> 它调用 <code>httpServletRequest.getMethod()</code> 来获取客户端请求的 HTTP 方法（例如 “GET”, “POST”, “PUT”, “DELETE” 等）。</li>
<li><strong>调用 <code>doXXX()</code> 方法：</strong> 根据获取到的请求方法字符串，<code>service()</code> 方法会调用与之对应的 <code>doXXX()</code> 方法。<ul>
<li>如果请求是 <strong>GET</strong>，则调用 <code>doGet(HttpServletRequest, HttpServletResponse)</code>。</li>
<li>如果请求是 <strong>POST</strong>，则调用 <code>doPost(HttpServletRequest, HttpServletResponse)</code>。</li>
<li>…以此类推。</li>
</ul>
</li>
</ol>
<p>我们作为开发者<strong>不再需要重写 <code>service()</code> 方法</strong>，只需要：</p>
<ul>
<li><strong>继承 <code>HttpServlet</code> 类。</strong></li>
<li><strong>根据需要处理的请求类型，重写相应的 <code>doXXX()</code> 方法</strong>（最常见的是 <code>doGet()</code> 和 <code>doPost()</code>）。</li>
<li>在重写的 <code>doXXX()</code> 方法中，实现具体的业务逻辑。</li>
</ul>
<p><strong>重要提示：</strong> <code>HttpServlet</code> 中这些 <code>doXXX()</code> 方法的<strong>默认实现</strong>通常是向客户端返回一个 <strong>HTTP 405 “Method Not Allowed”</strong> 的错误。这意味着，如果你想让你的 Servlet 处理 POST 请求，你就必须重写 <code>doPost()</code> 方法，否则客户端会收到一个 405 错误。</p>
<hr>
<h4 id="3-3-2-代码示例"><a href="#3-3-2-代码示例" class="headerlink" title="3.3.2 代码示例"></a>3.3.2 代码示例</h4><p>一个典型的 <code>HttpServlet</code> 子类如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 GET 请求，通常用于显示登录页面</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;&lt;h1&gt;Please Login&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;&lt;form action=&#x27;/login&#x27; method=&#x27;post&#x27;&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;Username: &lt;input type=&#x27;text&#x27; name=&#x27;username&#x27;&gt;&lt;br&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;Password: &lt;input type=&#x27;password&#x27; name=&#x27;password&#x27;&gt;&lt;br&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;&lt;input type=&#x27;submit&#x27; value=&#x27;Login&#x27;&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;&lt;/form&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 POST 请求，通常用于处理表单提交</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里实现用户名和密码的验证逻辑...</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(username) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(password)) &#123;</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;Login successful! Welcome, &quot;</span> + username);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;Login failed! Invalid username or password.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二、Servlet-核心-API"><a href="#二、Servlet-核心-API" class="headerlink" title="二、Servlet 核心 API"></a>二、Servlet 核心 API</h1><h2 id="1-HttpServletRequest-请求对象"><a href="#1-HttpServletRequest-请求对象" class="headerlink" title="1. HttpServletRequest (请求对象)"></a>1. HttpServletRequest (请求对象)</h2><h3 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h3><p><code>HttpServletRequest</code> 对象由 Servlet 容器创建，并作为参数传递给 Servlet 的 <code>service()</code>、<code>doGet()</code> 或 <code>doPost()</code> 等方法。它的核心作用是<strong>客户端发送HTTP请求的完整表示</strong>。</p>
<p>它封装了 HTTP 请求的三个主要部分：</p>
<ol>
<li><strong>请求行 (Request Line):</strong> 包括请求方法（GET, POST 等）、请求的资源路径 (URI) 和 HTTP 协议版本。</li>
<li><strong>请求头 (Request Headers):</strong> 包含一系列键值对，提供了关于客户端、请求本身和内容的元数据（如 <code>User-Agent</code>, <code>Accept</code>, <code>Cookie</code>）。</li>
<li><strong>请求体 (Request Body):</strong> 包含了客户端发送给服务器的实际数据，例如 HTML 表单提交的数据、JSON 数据等。（GET 请求通常没有请求体）。</li>
</ol>
<p><strong>关键点：</strong> 我们作为开发者<strong>从不自己创建</strong> <code>HttpServletRequest</code> 对象，而是由 Servlet 容器（如 Tomcat）为我们解析原始的网络数据流并封装好。</p>
<hr>
<h3 id="1-2-获取请求行信息"><a href="#1-2-获取请求行信息" class="headerlink" title="1.2 获取请求行信息"></a>1.2 获取请求行信息</h3><p>这些方法用于获取 HTTP 请求的第一行内容。</p>
<p>假设客户端请求的 URL 是：<code>http://localhost:8080/myapp/user/info?id=123</code></p>
<ul>
<li><code>String getMethod()</code>: 获取请求方式。<ul>
<li><strong>示例:</strong> <code>request.getMethod();</code> &#x2F;&#x2F; 返回 “GET”</li>
</ul>
</li>
<li><code>String getRequestURI()</code>: 获取请求的资源标识符路径（从项目名开始，不包括协议、主机、端口和查询参数）。<ul>
<li><strong>示例:</strong> <code>request.getRequestURI();</code> &#x2F;&#x2F; 返回 “&#x2F;myapp&#x2F;user&#x2F;info”</li>
</ul>
</li>
<li><code>StringBuffer getRequestURL()</code>: 获取客户端请求的完整 URL（不包括查询参数）。<ul>
<li><strong>示例:</strong> <code>request.getRequestURL();</code> &#x2F;&#x2F; 返回 “<a target="_blank" rel="noopener" href="http://localhost:8080/myapp/user/info">http://localhost:8080/myapp/user/info</a>“</li>
</ul>
</li>
<li><code>String getContextPath()</code>: 获取当前 Web 应用的上下文路径（即项目名）。在构建动态链接时非常有用。<ul>
<li><strong>示例:</strong> <code>request.getContextPath();</code> &#x2F;&#x2F; 返回 “&#x2F;myapp”</li>
</ul>
</li>
<li><code>String getQueryString()</code>: 获取 URL 中 <code>?</code> 后面的查询字符串。<ul>
<li><strong>示例:</strong> <code>request.getQueryString();</code> &#x2F;&#x2F; 返回 “id&#x3D;123”</li>
</ul>
</li>
<li><code>String getProtocol()</code>: 获取请求使用的协议和版本。<ul>
<li><strong>示例:</strong> <code>request.getProtocol();</code> &#x2F;&#x2F; 返回 “HTTP&#x2F;1.1”</li>
</ul>
</li>
<li><code>String getRemoteAddr()</code>: 获取客户端的 IP 地址。</li>
</ul>
<hr>
<h3 id="1-3-获取请求头信息"><a href="#1-3-获取请求头信息" class="headerlink" title="1.3 获取请求头信息"></a>1.3 获取请求头信息</h3><p>这些方法用于获取 HTTP 请求头中的键值对。</p>
<ul>
<li><p><code>String getHeader(String name)</code>: 根据头名称获取对应的头信息值。头名称不区分大小写。</p>
<ul>
<li><strong>示例:</strong> <code>String userAgent = request.getHeader(&quot;User-Agent&quot;);</code> &#x2F;&#x2F; 获取浏览器信息</li>
</ul>
</li>
<li><p><code>java.util.Enumeration&lt;String&gt; getHeaderNames()</code>: 获取所有请求头的名称集合。</p>
<ul>
<li><p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;String&gt; headerNames = request.getHeaderNames();</span><br><span class="line"><span class="keyword">while</span>(headerNames.hasMoreElements())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">headerName</span> <span class="operator">=</span> headerNames.nextElement();</span><br><span class="line">    System.out.println(headerName + <span class="string">&quot;: &quot;</span> + request.getHeader(headerName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-4-获取请求参数"><a href="#1-4-获取请求参数" class="headerlink" title="1.4 获取请求参数"></a>1.4 获取请求参数</h3><p>这是 <code>HttpServletRequest</code> 最常用的功能之一，用于获取客户端通过表单或 URL 查询字符串提交的数据。</p>
<ul>
<li><code>String getParameter(String name)</code>: 根据参数名获取参数值。这是<strong>最常用</strong>的方法。<ul>
<li>如果参数存在，返回其 <code>String</code> 类型的值。</li>
<li>如果参数不存在，返回 <code>null</code>。</li>
</ul>
</li>
<li><code>String[] getParameterValues(String name)</code>: 根据参数名获取一个参数的所有值。常用于处理复选框（checkboxes）这类可以有多个值的表单元素。<ul>
<li>返回一个 <code>String</code> 数组。</li>
<li>如果参数不存在，返回 <code>null</code>。</li>
</ul>
</li>
<li><code>java.util.Map&lt;String, String[]&gt; getParameterMap()</code>: 获取所有请求参数的 Map。<ul>
<li>Map 的键是参数名 (<code>String</code>)。</li>
<li>Map 的值是该参数对应的所有值的 <code>String</code> 数组 (<code>String[]</code>)。</li>
</ul>
</li>
</ul>
<p><strong>示例:</strong></p>
<p>假设有一个表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/register&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    Hobbies:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;reading&quot;</span>&gt;</span> Reading</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;coding&quot;</span>&gt;</span> Coding</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 Servlet 中可以这样获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>); <span class="comment">// &quot;admin&quot;</span></span><br><span class="line">String[] hobbies = request.getParameterValues(<span class="string">&quot;hobby&quot;</span>); <span class="comment">// [&quot;reading&quot;, &quot;coding&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>请求参数中文乱码问题</strong></p>
<p>这是一个经典且必须掌握的问题。</p>
<ul>
<li><p><strong>GET 请求乱码：</strong></p>
<ul>
<li>GET 请求的参数在 URL 中，其编码由服务器（如 Tomcat）的配置决定。</li>
<li><strong>解决方案：</strong> 修改 Tomcat 的 <code>server.xml</code> 文件，在 <code>&lt;Connector&gt;</code> 标签中添加 <code>URIEncoding=&quot;UTF-8&quot;</code>。这是推荐的做法。</li>
</ul>
</li>
<li><p><strong>POST 请求乱码：</strong></p>
<ul>
<li><p>POST 请求的参数在请求体中，其编码由请求头中的 <code>Content-Type</code> 决定。</p>
</li>
<li><p><strong>解决方案：</strong> 在<strong>第一次调用任何 <code>getParameter</code> 系列方法之前</strong>，设置请求体的解码字符集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// 必须在获取任何参数之前调用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-5-作为域对象"><a href="#1-5-作为域对象" class="headerlink" title="1.5 作为域对象"></a>1.5 作为域对象</h3><p><code>HttpServletRequest</code> 也是一个“域对象”，它提供了一个内部的存储空间（类似一个 Map），可以在<strong>一次请求的生命周期内</strong>传递数据。</p>
<p>这个功能是实现 MVC 模式中 <strong>Controller (Servlet) 向 View (JSP) 传递数据</strong>的核心机制。</p>
<ul>
<li><code>void setAttribute(String name, Object value)</code>: 将一个对象存入 request 域中。</li>
<li><code>Object getAttribute(String name)</code>: 根据名称从 request 域中取出对象（需要手动类型转换）。</li>
<li><code>void removeAttribute(String name)</code>: 从 request 域中移除一个对象。</li>
</ul>
<p><strong>典型场景：</strong></p>
<ol>
<li>一个 Servlet 接收到请求，从数据库查询到一个 <code>User</code> 对象。</li>
<li>Servlet 调用 <code>request.setAttribute(&quot;userInfo&quot;, userObject);</code> 将用户对象存入 request 域。</li>
<li>Servlet 通过<strong>请求转发</strong>将请求交给一个 JSP 页面。</li>
<li>JSP 页面可以通过 <code>${userInfo}</code> (EL 表达式) 或 <code>request.getAttribute(&quot;userInfo&quot;)</code> (Java 脚本) 来获取并展示这个 <code>User</code> 对象的信息。</li>
</ol>
<hr>
<h3 id="1-6-请求转发-RequestDispatcher"><a href="#1-6-请求转发-RequestDispatcher" class="headerlink" title="1.6 请求转发 (RequestDispatcher)"></a>1.6 请求转发 (<code>RequestDispatcher</code>)</h3><p>请求转发是一种<strong>服务器内部</strong>的资源跳转方式。</p>
<ul>
<li><strong>工作原理：</strong> Servlet 处理完部分逻辑后，将请求和响应对象“转发”给服务器上的另一个资源（如另一个 Servlet 或 JSP），由目标资源继续处理并最终生成响应。</li>
<li><strong>获取方式：</strong> <code>RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;/path/to/resource&quot;);</code></li>
<li><strong>执行转发：</strong> <code>dispatcher.forward(request, response);</code></li>
</ul>
<p><strong>核心特点：</strong></p>
<ol>
<li><strong>一次请求：</strong> 整个过程对于客户端来说是一次请求和一次响应。</li>
<li><strong>地址栏不变：</strong> 客户端浏览器的地址栏不会发生变化。</li>
<li><strong>数据共享：</strong> 因为使用的是同一个 request 对象，所以可以通过 <code>request.setAttribute()</code> 在转发的 Servlet 和 JSP 之间共享数据。</li>
<li><strong>服务器内部行为：</strong> 只能转发到当前 Web 应用内部的资源。</li>
</ol>
<hr>
<h2 id="2-HttpServletResponse-响应对象"><a href="#2-HttpServletResponse-响应对象" class="headerlink" title="2. HttpServletResponse (响应对象)"></a>2. HttpServletResponse (响应对象)</h2><h3 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1 作用"></a>2.1 作用</h3><p><code>HttpServletResponse</code> 对象由 Servlet 容器创建，并作为参数传递给 Servlet 的服务方法。它的核心作用是<strong>封装服务器对客户端请求的响应</strong>，让开发者能够方便地将处理结果发送回客户端（通常是浏览器）。</p>
<p>它主要用于设置 HTTP 响应的三个部分：</p>
<ol>
<li><strong>响应行 (Status Line):</strong> 包括 HTTP 协议版本、一个状态码（如 200 OK, 404 Not Found）和状态描述。</li>
<li><strong>响应头 (Response Headers):</strong> 包含一系列键值对，告诉浏览器如何处理响应内容（如 <code>Content-Type</code>, <code>Content-Length</code>, <code>Set-Cookie</code>）。</li>
<li><strong>响应体 (Response Body):</strong> 包含了要发送给客户端的实际数据，如 HTML 页面、JSON 字符串、图片数据等。</li>
</ol>
<p><strong>关键点：</strong> 与 <code>HttpServletRequest</code> 一样，我们<strong>从不自己创建</strong> <code>HttpServletResponse</code> 对象，而是由容器提供，我们负责填充它。</p>
<hr>
<h3 id="2-2-设置响应行"><a href="#2-2-设置响应行" class="headerlink" title="2.2 设置响应行"></a>2.2 设置响应行</h3><p>我们通常只关心响应行中的<strong>状态码 (Status Code)</strong>，它告诉客户端请求处理的结果。</p>
<ul>
<li><code>void setStatus(int sc)</code>: 设置响应的状态码。<ul>
<li><strong>示例:</strong> <code>response.setStatus(HttpServletResponse.SC_OK);</code> &#x2F;&#x2F; 设置状态码为 200</li>
<li><strong>示例:</strong> <code>response.setStatus(404);</code> &#x2F;&#x2F; 设置状态码为 404</li>
</ul>
</li>
</ul>
<p><strong>常用状态码：</strong></p>
<ul>
<li><code>200 OK</code>: 请求成功。</li>
<li><code>302 Found</code>: 临时重定向（<code>sendRedirect</code> 方法会自动设置这个状态码）。</li>
<li><code>304 Not Modified</code>: 客户端缓存的资源未过期。</li>
<li><code>400 Bad Request</code>: 请求语法错误。</li>
<li><code>403 Forbidden</code>: 服务器拒绝执行该请求。</li>
<li><code>404 Not Found</code>: 请求的资源不存在。</li>
<li><code>500 Internal Server Error</code>: 服务器内部发生错误。</li>
</ul>
<hr>
<h3 id="2-3-设置响应头"><a href="#2-3-设置响应头" class="headerlink" title="2.3 设置响应头"></a>2.3 设置响应头</h3><p>响应头用于向浏览器提供指令性信息。</p>
<ul>
<li><code>void setHeader(String name, String value)</code>: 设置一个指定名称的响应头。如果该头已存在，新值会覆盖旧值。</li>
<li><code>void addHeader(String name, String value)</code>: 添加一个指定名称的响应头。如果该头已存在，不会覆盖，而是添加一个新的同名头。</li>
</ul>
<p><strong>最常用的响应头设置：</strong></p>
<ol>
<li><strong><code>Content-Type</code> (内容类型):</strong><ul>
<li>这是最重要的响应头，它告诉浏览器响应体是什么类型的数据以及使用什么字符集来解码。</li>
<li>格式: <code>MIME类型;charset=编码</code></li>
<li><strong>便捷方法:</strong> <code>response.setContentType(&quot;text/html;charset=UTF-8&quot;);</code></li>
<li>如果不设置字符集，浏览器可能因解码错误而显示乱码。</li>
</ul>
</li>
<li><strong><code>Location</code> (位置):</strong><ul>
<li>与 <code>302</code> 状态码配合使用，告诉浏览器要重定向到的新地址。<code>sendRedirect</code> 方法会自动设置它。</li>
</ul>
</li>
<li><strong><code>Content-Disposition</code> (内容处置):</strong><ul>
<li>用于指示浏览器如何处理响应体，通常用于<strong>文件下载</strong>。</li>
<li><code>response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=report.xls&quot;);</code></li>
<li><code>attachment</code> 表示作为附件下载，<code>filename</code> 指定了默认的文件名。</li>
</ul>
</li>
<li><strong><code>Refresh</code> (刷新):</strong><ul>
<li>告诉浏览器在指定秒数后刷新页面，或跳转到另一个页面。</li>
<li><code>response.setHeader(&quot;Refresh&quot;, &quot;5;url=http://www.google.com&quot;);</code> &#x2F;&#x2F; 5秒后跳转到谷歌</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-4-设置响应体"><a href="#2-4-设置响应体" class="headerlink" title="2.4 设置响应体"></a>2.4 设置响应体</h3><p>响应体是发送给客户端的实际数据。Servlet 提供了两种输出流来写入响应体，<strong>但两者是互斥的，一次响应中只能使用其中一个</strong>。</p>
<ol>
<li><p><strong>字符输出流 <code>PrintWriter getWriter()</code></strong></p>
<ul>
<li>用于输出<strong>文本数据</strong>，如 HTML, XML, JSON, Plain Text。</li>
<li>它具有平台无关的 <code>print()</code> 和 <code>println()</code> 方法，非常方便。</li>
<li><strong>注意：</strong> 在调用 <code>getWriter()</code> 之前，最好先通过 <code>response.setContentType(...)</code> 或 <code>response.setCharacterEncoding(...)</code> 设置好字符编码，否则可能产生乱码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">out.println(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;body&gt;&lt;h1&gt;你好，世界！&lt;/h1&gt;&lt;/body&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字节输出流 <code>ServletOutputStream getOutputStream()</code></strong></p>
<ul>
<li>用于输出<strong>非文本的二进制数据</strong>，如图片、视频、PDF 文件、ZIP 压缩包等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line"><span class="type">ServletOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line"><span class="comment">// 从文件或其他来源读取图片字节数据，并写入到 out 流中...</span></span><br><span class="line"><span class="comment">// out.write(imageDataBytes);</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong>严重警告：</strong> 如果同时尝试调用 <code>getWriter()</code> 和 <code>getOutputStream()</code>，容器会抛出 <code>IllegalStateException</code>。</p>
</blockquote>
<hr>
<h3 id="2-5-页面跳转：重定向"><a href="#2-5-页面跳转：重定向" class="headerlink" title="2.5 页面跳转：重定向"></a>2.5 页面跳转：重定向</h3><p>重定向 (Redirect) 是一种<strong>客户端</strong>行为的跳转方式。</p>
<ul>
<li><p><strong>工作原理：</strong> 服务器向客户端发送一个特殊的响应（状态码 302 和一个 <code>Location</code> 响应头），客户端浏览器接收到这个响应后，会<strong>自动发起一个新的请求</strong>到 <code>Location</code> 头指定的 URL。</p>
</li>
<li><p><strong>实现方法:</strong> <code>void sendRedirect(String location)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理完用户注册逻辑后，重定向到登录页面</span></span><br><span class="line">response.sendRedirect(request.getContextPath() + <span class="string">&quot;/login.jsp&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-6-请求转发-forward-与重定向-redirect-的区别"><a href="#2-6-请求转发-forward-与重定向-redirect-的区别" class="headerlink" title="2.6 请求转发 (forward) 与重定向 (redirect) 的区别"></a>2.6 请求转发 (forward) 与重定向 (redirect) 的区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th><strong>请求转发 (Forward)</strong></th>
<th><strong>重定向 (Redirect)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>行为主体</strong></td>
<td><strong>服务器行为</strong>。服务器内部将请求转交给另一个资源处理。</td>
<td><strong>客户端行为</strong>。服务器建议客户端去请求另一个地址。</td>
</tr>
<tr>
<td><strong>请求次数</strong></td>
<td><strong>1 次</strong>。客户端只发起了一次请求。</td>
<td><strong>2 次</strong>。客户端先请求 Servlet，然后被告知再去请求另一个地址。</td>
</tr>
<tr>
<td><strong>地址栏变化</strong></td>
<td><strong>不变</strong>。地址栏仍然是最初请求的地址。</td>
<td><strong>改变</strong>。地址栏会更新为重定向后的新地址。</td>
</tr>
<tr>
<td><strong>数据共享</strong></td>
<td><strong>可以共享</strong>。转发过程共享同一个 <code>request</code> 对象，可以通过 <code>request.setAttribute()</code> 传递数据。</td>
<td><strong>不能共享</strong>。两次请求是完全独立的，<code>request</code> 对象不同。</td>
</tr>
<tr>
<td><strong>可以跳转的资源</strong></td>
<td>只能跳转到<strong>当前 Web 应用内部</strong>的资源。</td>
<td>可以跳转到<strong>任何有效的 URL</strong>，包括外部网站。</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td><strong>高</strong>。因为只是服务器内部的调用。</td>
<td><strong>低</strong>。因为需要经过一次客户端与服务器的网络往返。</td>
</tr>
<tr>
<td><strong>核心方法</strong></td>
<td><code>request.getRequestDispatcher(...).forward(req, res)</code></td>
<td><code>response.sendRedirect(...)</code></td>
</tr>
</tbody></table>
<h4 id="使用场景总结："><a href="#使用场景总结：" class="headerlink" title="使用场景总结："></a><strong>使用场景总结：</strong></h4><ul>
<li><strong>使用转发 (Forward):</strong><ul>
<li><strong>MVC 模式</strong>：Servlet (Controller) 处理完业务逻辑后，将数据存入 <code>request</code> 域，然后<strong>转发</strong>到 JSP (View) 进行展示。这是最典型的应用。</li>
</ul>
</li>
<li><strong>使用重定向 (Redirect):</strong><ul>
<li><strong>避免表单重复提交</strong>：当用户提交一个 POST 请求（如注册、下单）处理成功后，<strong>重定向</strong>到一个成功页面。这样即使用户刷新页面，也只是刷新成功页面（GET 请求），不会重复提交表单数据。这被称为 <strong>Post-Redirect-Get (PRG)</strong> 模式。</li>
<li><strong>跳转到外部网站</strong>。</li>
<li><strong>实现登录功能</strong>：用户访问需要登录的页面时，如果未登录，则重定向到登录页面。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="三、会话管理-State-Management"><a href="#三、会话管理-State-Management" class="headerlink" title="三、会话管理 (State Management)"></a>三、会话管理 (State Management)</h1><h2 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1. Cookie"></a>1. Cookie</h2><h3 id="1-1-定义-1"><a href="#1-1-定义-1" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><strong>Cookie</strong> 是服务器发送到客户端（浏览器）并由客户端保存在本地的一小块<strong>键值对 (key-value) 形式的文本数据</strong>。</p>
<p>当浏览器下次向同一个服务器发送请求时，它会自动将之前保存的 Cookie 数据附加在 HTTP 请求头中一并发送回去。通过这种机制，服务器就能够识别出是哪个用户，从而实现对用户状态的跟踪。</p>
<h3 id="1-2-工作原理"><a href="#1-2-工作原理" class="headerlink" title="1.2 工作原理"></a>1.2 工作原理</h3><p>Cookie 的工作原理完全基于 HTTP 协议的 <strong>请求头 (Request Headers)</strong> 和 <strong>响应头 (Response Headers)</strong>。</p>
<pre><code class="highlight mermaid">sequenceDiagram
    title Cookie 工作原理
    autonumber

    %% 1. 第一次请求 (无 Cookie) %%
    Client-&gt;&gt;Server: 发起请求 (GET /index.html)
    note right of Client: 请求头中没有 Cookie

    %% 2. 第一次响应 (设置 Cookie) %%
    activate Server
    Server--&gt;&gt;Client: 返回响应 (200 OK)
    note left of Server: 响应头包含 Set-Cookie: userID=12345
    deactivate Server
    note right of Client: 浏览器解析并保存 Cookie

    %% 增加分隔，表示后续操作 %%
    rect rgb(240, 240, 240)
        note over Client, Server: 一段时间后，用户再次访问...
    end

    %% 3. 后续请求 (携带 Cookie) %%
    Client-&gt;&gt;Server: 发起后续请求 (GET /profile.html)
    note right of Client: 请求头自动添加 Cookie: userID=12345

    %% 4. 后续响应 (服务器识别用户) %%
    activate Server
    note over Server: 读取 Cookie, 识别用户身份(ID:12345)
    Server--&gt;&gt;Client: 返回个性化响应 (例如：欢迎回来！)
    deactivate Server</code></pre>

<p><strong>流程图解:</strong></p>
<ol>
<li><strong>第一次请求 (客户端 -&gt; 服务器):</strong><ul>
<li>客户端浏览器向服务器发起一个请求。此时，请求头中<strong>没有</strong> <code>Cookie</code> 信息。</li>
</ul>
</li>
<li><strong>第一次响应 (服务器 -&gt; 客户端):</strong><ul>
<li>服务器处理完请求后，决定要为这个客户端设置一个 Cookie。</li>
<li>服务器在 HTTP <strong>响应头</strong>中添加一个 <code>Set-Cookie</code> 字段，内容是 <code>key=value</code> 以及一些可选的属性。</li>
<li>例如：<code>Set-Cookie: userID=12345</code></li>
<li>浏览器接收到这个响应后，会解析 <code>Set-Cookie</code> 头，并将这个 Cookie 保存在本地。</li>
</ul>
</li>
<li><strong>后续请求 (客户端 -&gt; 服务器):</strong><ul>
<li>当浏览器<strong>再次</strong>向同一个服务器（域名和路径匹配）发起请求时，它会自动在 HTTP <strong>请求头</strong>中添加一个 <code>Cookie</code> 字段。</li>
<li><code>Cookie</code> 字段的值就是之前服务器设置的所有相关 Cookie。</li>
<li>例如：<code>Cookie: userID=12345</code></li>
</ul>
</li>
<li><strong>后续响应 (服务器 -&gt; 客户端):</strong><ul>
<li>服务器接收到请求，读取请求头中的 <code>Cookie</code> 信息，就知道“哦，是 ID 为 12345 的用户回来了”，然后就可以根据这个 ID 执行相应的逻辑（如显示个性化内容、保持登录状态等）。</li>
</ul>
</li>
</ol>
<p>这个过程对用户是透明的，完全由浏览器和服务器自动完成。</p>
<hr>
<h3 id="1-3-Cookie-API"><a href="#1-3-Cookie-API" class="headerlink" title="1.3 Cookie API"></a>1.3 Cookie API</h3><p>在 Java Servlet 中，操作 Cookie 主要通过 <code>javax.servlet.http.Cookie</code> 类以及 <code>request</code> 和 <code>response</code> 对象上的方法。</p>
<ol>
<li><strong>创建 Cookie:</strong><ul>
<li><code>Cookie cookie = new Cookie(String name, String value);</code></li>
<li><strong>注意:</strong> Cookie 的 name 和 value <strong>不能包含</strong>中文字符、空格或特殊字符（如 <code>;</code>, <code>,</code>）。如果需要存储，必须先进行 <strong>URL 编码</strong> (<code>URLEncoder.encode()</code>)，读取时再进行解码 (<code>URLDecoder.decode()</code>)。</li>
</ul>
</li>
<li><strong>发送 Cookie 到客户端:</strong><ul>
<li><code>response.addCookie(Cookie cookie);</code></li>
<li>通过 <code>response</code> 对象将创建好的 Cookie 添加到 HTTP 响应头中。</li>
</ul>
</li>
<li><strong>从客户端请求中获取 Cookie:</strong><ul>
<li><code>Cookie[] cookies = request.getCookies();</code></li>
<li>通过 <code>request</code> 对象获取一个 <code>Cookie</code> 数组，包含了客户端本次请求发送过来的所有 Cookie。</li>
<li><strong>注意:</strong> 如果客户端没有发送任何 Cookie，此方法将返回 <code>null</code>，所以在使用前必须进行<strong>空指针判断</strong>。</li>
</ul>
</li>
<li><strong>读取 Cookie 的信息:</strong><ul>
<li><code>String name = cookie.getName();</code></li>
<li><code>String value = cookie.getValue();</code></li>
</ul>
</li>
</ol>
<p><strong>代码示例：记录用户访问次数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/visitCount&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitCountServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 尝试从请求中获/取名为 &quot;visitCount&quot; 的 Cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">targetCookie</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;visitCount&quot;</span>.equals(cookie.getName())) &#123;</span><br><span class="line">                    targetCookie = cookie;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (targetCookie != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 2. 如果 Cookie 存在，获取其值并加 1</span></span><br><span class="line">            count = Integer.parseInt(targetCookie.getValue()) + <span class="number">1</span>;</span><br><span class="line">            out.write(<span class="string">&quot;&lt;h1&gt;您好，这是您的第 &quot;</span> + count + <span class="string">&quot; 次访问！&lt;/h1&gt;&quot;</span>);</span><br><span class="line">            targetCookie.setValue(String.valueOf(count)); <span class="comment">// 更新 Cookie 的值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 如果 Cookie 不存在，说明是第一次访问</span></span><br><span class="line">            out.write(<span class="string">&quot;&lt;h1&gt;欢迎您，这是您的第一次访问！&lt;/h1&gt;&quot;</span>);</span><br><span class="line">            targetCookie = <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;visitCount&quot;</span>, String.valueOf(count));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 设置 Cookie 的有效期（例如 1 天）</span></span><br><span class="line">        targetCookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 将更新后的 Cookie 发送回客户端</span></span><br><span class="line">        response.addCookie(targetCookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-4-Cookie-的属性"><a href="#1-4-Cookie-的属性" class="headerlink" title="1.4 Cookie 的属性"></a>1.4 Cookie 的属性</h3><p>除了基本的 name 和 value，还可以设置 Cookie 的其他属性来控制其行为。</p>
<ul>
<li><code>void setMaxAge(int seconds)</code>: <strong>设置 Cookie 的有效期</strong><ul>
<li><strong>正数:</strong> 表示 Cookie 的存活秒数。Cookie 会被保存在客户端的硬盘上，浏览器关闭后依然有效。</li>
<li><strong>负数 (默认值):</strong> 表示 Cookie 仅在当前浏览器会话期间有效。Cookie 存储在浏览器内存中，一旦浏览器关闭，Cookie 就会被删除。</li>
<li><strong>零 (0):</strong> 表示<strong>立即删除</strong>该 Cookie。这是服务器端删除客户端 Cookie 的标准方法。</li>
</ul>
</li>
<li><code>void setPath(String uri)</code>: <strong>设置 Cookie 的有效路径</strong><ul>
<li>指定一个 URL 路径，只有当请求的路径是该路径或其子路径时，浏览器才会发送这个 Cookie。</li>
<li><strong>常用设置:</strong> <code>cookie.setPath(&quot;/&quot;);</code> 或 <code>cookie.setPath(request.getContextPath());</code>，使其对整个 Web 应用都有效。</li>
</ul>
</li>
<li><code>void setDomain(String pattern)</code>: <strong>设置 Cookie 的有效域名</strong><ul>
<li>用于跨子域共享 Cookie。例如，设置为 <code>.example.com</code>，则 <code>a.example.com</code> 和 <code>b.example.com</code> 都可以访问该 Cookie。</li>
</ul>
</li>
<li><code>void setHttpOnly(boolean isHttpOnly)</code>: <strong>（安全相关）</strong><ul>
<li>如果设置为 <code>true</code>，则该 Cookie <strong>不能被客户端的 JavaScript 脚本访问</strong>（通过 <code>document.cookie</code>）。这能有效防止<strong>跨站脚本攻击 (XSS)</strong> 窃取 Cookie。</li>
</ul>
</li>
<li><code>void setSecure(boolean flag)</code>: <strong>（安全相关）</strong><ul>
<li>如果 设置为 <code>true</code>，则该 Cookie <strong>只会在 HTTPS 连接中被发送</strong>，在普通的 HTTP 连接中不会被发送，可以防止在传输过程中被窃听。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-5-优缺点及应用场景"><a href="#1-5-优缺点及应用场景" class="headerlink" title="1.5 优缺点及应用场景"></a>1.5 优缺点及应用场景</h3><h4 id="1-5-1-优点"><a href="#1-5-1-优点" class="headerlink" title="1.5.1 优点:"></a>1.5.1 优点:</h4><ul>
<li><strong>API 简单：</strong> 使用起来非常方便。</li>
<li><strong>减轻服务器压力：</strong> 数据存储在客户端，不占用服务器内存。</li>
<li><strong>可持久化：</strong> 通过设置 <code>setMaxAge</code> 可以实现长时间保持状态。</li>
</ul>
<hr>
<h4 id="1-5-2-缺点"><a href="#1-5-2-缺点" class="headerlink" title="1.5.2 缺点"></a>1.5.2 缺点</h4><ul>
<li><strong>大小和数量限制：</strong> 大多数浏览器限制单个 Cookie 大小为 4KB 左右，每个域名下的 Cookie 数量也有限制（通常为 20-50 个）。</li>
<li><strong>安全性差：</strong> Cookie 以明文形式存储在客户端本地，并且在网络中明文传输，容易被窃取和篡改。<strong>绝对不能用 Cookie 存储敏感信息</strong>（如密码、银行卡号）。</li>
<li><strong>增加网络流量：</strong> 浏览器每次请求都会携带相关 Cookie，即使是请求图片、CSS 等静态资源，也会带上，造成不必要的流量浪费。</li>
<li><strong>用户可禁用：</strong> 用户可以在浏览器设置中禁用 Cookie，导致依赖 Cookie 的功能失效。</li>
</ul>
<hr>
<h4 id="1-5-3-应用场景"><a href="#1-5-3-应用场景" class="headerlink" title="1.5.3 应用场景"></a>1.5.3 应用场景</h4><ul>
<li><strong>“记住我”功能：</strong> 记录一个非敏感的、加密的用户令牌，用于下次访问时自动登录。</li>
<li><strong>购物车（早期实现）：</strong> 将商品 ID 存储在 Cookie 中，但现在更多使用 Session。</li>
<li><strong>个性化设置：</strong> 记录用户的偏好，如网站主题（白天&#x2F;夜间模式）、语言选择等。</li>
<li><strong>广告追踪：</strong> 跟踪用户在不同网站间的浏览行为，以推送相关广告。</li>
</ul>
<hr>
<h2 id="2-Session-HttpSession"><a href="#2-Session-HttpSession" class="headerlink" title="2. Session (HttpSession)"></a>2. Session (HttpSession)</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p><strong>Session (会话)</strong> 是一种<strong>服务器端</strong>的会话跟踪技术。它在服务器的内存中为每个独立的用户（客户端）开辟一块专属的存储空间，用于在多次请求之间保存和共享该用户的状态数据。</p>
<p>HTTP 协议是无状态的，服务器本身无法区分连续的两次请求是否来自同一个用户。Session 机制就是为了解决这个问题而诞生的。</p>
<p><code>HttpSession</code> 是 Servlet API 提供的用于表示 Session 的接口。</p>
<hr>
<h3 id="2-2-工作原理"><a href="#2-2-工作原理" class="headerlink" title="2.2 工作原理"></a>2.2 工作原理</h3><p>Session 的实现通常<strong>依赖于 Cookie</strong>。具体来说，它依赖一个名为 <code>JSESSIONID</code> 的特殊 Cookie。</p>
<pre><code class="highlight mermaid">sequenceDiagram
    title Java Session (JSESSIONID) 工作原理
    autonumber

    %% == 第一次交互: 创建 Session == %%

    %% 1. 第一次请求 (无 JSESSIONID) %%
    Client-&gt;&gt;Server: 发起请求 (GET /some-resource)
    note right of Client: 请求头中没有 JSESSIONID Cookie

    %% 2 &amp; 3. 服务器创建 Session 并响应 %%
    activate Server
    note over Server: 调用 request.getSession()
    note over Server: 发现无 Session ID, 执行:&lt;br/&gt;1. 创建 HttpSession 对象&lt;br/&gt;2. 生成唯一 Session ID (e.g., A5D7...)&lt;br/&gt;3. 存入内存 Map (ID -&gt; Session)
    Server--&gt;&gt;Client: 返回响应 (200 OK)
    note left of Server: 响应头包含 Set-Cookie: JSESSIONID=A5D7...
    deactivate Server
    note right of Client: 浏览器在内存中保存 JSESSIONID Cookie

    %% == 分隔符: 表示后续操作 == %%
    rect rgb(230, 240, 255)
        note over Client, Server: 后续... 用户在同一会话中继续操作
    end

    %% == 后续交互: 识别 Session == %%

    %% 4. 后续请求 (携带 JSESSIONID) %%
    Client-&gt;&gt;Server: 发起后续请求 (GET /user/profile)
    note right of Client: 请求头自动携带 Cookie: JSESSIONID=A5D7...

    %% 5. 服务器识别 Session %%
    activate Server
    note over Server: 1. 从 Cookie 读取 Session ID&lt;br/&gt;2. 在内存 Map 中查找对应的 HttpSession&lt;br/&gt;3. 成功找到, 关联到当前请求
    Server--&gt;&gt;Client: 返回与会话相关的响应 (如用户数据)
    deactivate Server
    note right of Client: 用户状态得以保持</code></pre>

<p><strong>流程图解:</strong></p>
<ol>
<li><strong>第一次请求 (客户端 -&gt; 服务器):</strong><ul>
<li>客户端浏览器向服务器发起请求。此时，请求中没有 <code>JSESSIONID</code> Cookie。</li>
</ul>
</li>
<li><strong>服务器创建 Session:</strong><ul>
<li>服务器端的 Servlet 调用 <code>request.getSession()</code> 方法。</li>
<li>容器发现当前请求没有携带有效的 Session ID，于是执行以下操作：<ul>
<li>在服务器内存中创建一个全新的 <code>HttpSession</code> 对象。</li>
<li>生成一个<strong>全局唯一的、随机的字符串</strong>作为 <strong>Session ID</strong> (例如: <code>A5D7F9G2H4J1K8L3</code>)。</li>
<li>将这个 <code>HttpSession</code> 对象和它的 Session ID 以键值对的形式存入一个全局的 Map 中。</li>
</ul>
</li>
</ul>
</li>
<li><strong>服务器响应:</strong><ul>
<li>服务器在返回给客户端的 HTTP <strong>响应头</strong>中，添加一个 <code>Set-Cookie</code> 字段，将 Session ID 发送回去。</li>
<li>例如：<code>Set-Cookie: JSESSIONID=A5D7F9G2H4J1K8L3; Path=/myapp</code></li>
<li>这个 Cookie 默认是<strong>会话级别</strong>的（<code>Max-Age</code> 为负数），意味着它存储在浏览器内存中，浏览器关闭后即失效。</li>
</ul>
</li>
<li><strong>后续请求 (客户端 -&gt; 服务器):</strong><ul>
<li>当浏览器再次向该服务器发起请求时，它会自动在 HTTP <strong>请求头</strong>中带上之前收到的 <code>JSESSIONID</code> Cookie。</li>
<li>例如：<code>Cookie: JSESSIONID=A5D7F9G2H4J1K8L3</code></li>
</ul>
</li>
<li><strong>服务器识别 Session:</strong><ul>
<li>服务器接收到请求，从 Cookie 中读取到 Session ID。</li>
<li>容器使用这个 ID 在内存的全局 Map 中查找对应的 <code>HttpSession</code> 对象。</li>
<li>如果找到了，就将这个已存在的 Session 对象与当前请求关联起来，后续的 <code>setAttribute</code> &#x2F; <code>getAttribute</code> 操作都是针对这个找到的对象。</li>
<li>这样，服务器就成功地识别了用户，并恢复了该用户的会话状态。</li>
</ul>
</li>
</ol>
<p><strong>如果客户端禁用了 Cookie 怎么办？</strong></p>
<p>作为备用方案，服务器可以使用 <strong>URL 重写 (URL Rewriting)</strong>。它会动态地将 Session ID 附加在所有页面链接的末尾，例如 <code>.../page.jsp;jsessionid=A5D7F9...</code>。这种方式不推荐，因为它不安全且会破坏 URL 的美观性。</p>
<hr>
<h3 id="2-3-Session-API"><a href="#2-3-Session-API" class="headerlink" title="2.3 Session API"></a>2.3 Session API</h3><p>主要通过 <code>request</code> 对象获取 <code>HttpSession</code> 对象，然后通过 <code>HttpSession</code> 对象进行操作。</p>
<ol>
<li><strong>获取&#x2F;创建 Session 对象:</strong><ul>
<li><code>HttpSession session = request.getSession();</code> (等同于 <code>request.getSession(true);</code>)<ul>
<li>这是<strong>最常用</strong>的方法。它的逻辑是：检查请求中是否有合法的 Session ID，如果有，则返回对应的 Session 对象；如果没有，则<strong>立即创建一个新的</strong> Session 对象并返回。</li>
</ul>
</li>
<li><code>HttpSession session = request.getSession(false);</code><ul>
<li>逻辑是：检查请求中是否有合法的 Session ID，如果有，则返回对应的 Session 对象；如果没有，<strong>不创建新的 Session</strong>，而是返回 <code>null</code>。</li>
<li>此方法常用于<strong>判断用户是否已登录</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>在 Session 中存取数据 (作为域对象):</strong><ul>
<li><code>void session.setAttribute(String name, Object value);</code><ul>
<li>将一个 Java 对象存入 Session。可以存储<strong>任何类型</strong>的对象，而不仅限于字符串。</li>
</ul>
</li>
<li><code>Object session.getAttribute(String name);</code><ul>
<li>根据名称从 Session 中获取对象。返回的是 <code>Object</code> 类型，需要进行强制类型转换。</li>
</ul>
</li>
<li><code>void session.removeAttribute(String name);</code><ul>
<li>从 Session 中移除指定的属性。</li>
</ul>
</li>
</ul>
</li>
<li><strong>管理 Session:</strong><ul>
<li><code>void session.invalidate();</code><ul>
<li><strong>使 Session 立即失效</strong>。这会清空 Session 中所有数据，并解除与客户端的绑定。这是实现**“用户注销”**功能的核心方法。</li>
</ul>
</li>
<li><code>String session.getId();</code><ul>
<li>获取 Session 的唯一 ID 字符串。</li>
</ul>
</li>
<li><code>void session.setMaxInactiveInterval(int seconds);</code><ul>
<li>设置 Session 的最大非活动时间（即超时时间），单位为秒。覆盖 <code>web.xml</code> 中的默认配置。</li>
</ul>
</li>
<li><code>int session.getMaxInactiveInterval();</code><ul>
<li>获取 Session 的超时时间。</li>
</ul>
</li>
<li><code>long session.getCreationTime();</code><ul>
<li>获取 Session 的创建时间（毫秒级时间戳）。</li>
</ul>
</li>
<li><code>boolean session.isNew();</code><ul>
<li>判断当前 Session 是否是新创建的（即客户端还不知道它的存在，ID 还未通过响应发送回去）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-4-Session-的生命周期"><a href="#2-4-Session-的生命周期" class="headerlink" title="2.4 Session 的生命周期"></a>2.4 Session 的生命周期</h3><ol>
<li><p><strong>创建 (Creation):</strong></p>
<ul>
<li>当客户端第一次访问服务器，并且代码中调用了 <code>request.getSession(true)</code> 或 <code>request.getSession()</code> 时，Session 对象被创建。</li>
</ul>
</li>
<li><p><strong>活动 (Active):</strong></p>
<ul>
<li>在 Session 的超时时间 (<code>maxInactiveInterval</code>) 内，只要客户端持续与服务器进行交互，Session 就一直处于活动状态。</li>
<li><strong>每次有效的客户端请求都会重置 Session 的计时器</strong>。例如，超时时间为 30 分钟，用户在第 29 分钟时访问了新页面，那么 Session 的生命周期会从此刻起重新再计算 30 分钟。</li>
</ul>
</li>
<li><p><strong>销毁 (Destruction):</strong><br>Session 在以下三种情况下会被销毁：</p>
<ul>
<li><p><strong>超时 (Timeout):</strong> 用户在指定的时间内（默认通常是 30 分钟，可在 <code>web.xml</code> 中配置）没有任何操作，服务器会自动销毁该 Session 以释放内存。这是最常见的销毁方式。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 web.xml 中配置全局 session 超时时间为 30 分钟 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>手动销毁 (Invalidation):</strong> 在代码中明确调用 <code>session.invalidate()</code> 方法，Session 会立即被销毁。常用于用户退出登录功能。</p>
</li>
<li><p><strong>服务器关闭 (Shutdown):</strong> 当 Web 服务器或应用正常关闭时，所有存在的 Session 都会被销毁。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-5-Cookie-与-Session-的区别与联系"><a href="#2-5-Cookie-与-Session-的区别与联系" class="headerlink" title="2.5 Cookie 与 Session 的区别与联系"></a>2.5 Cookie 与 Session 的区别与联系</h3><table>
<thead>
<tr>
<th>特性</th>
<th><strong>Cookie</strong></th>
<th><strong>Session</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据存储位置</strong></td>
<td><strong>客户端 (浏览器)</strong></td>
<td><strong>服务器端 (内存中)</strong></td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td><strong>低</strong>。数据暴露在客户端，易被窃取和篡改。</td>
<td><strong>高</strong>。数据存储在服务器，客户端只能接触到无意义的 Session ID。</td>
</tr>
<tr>
<td><strong>存储数据类型</strong></td>
<td><strong>String (字符串)</strong>，且不能包含特殊字符。</td>
<td><strong>Object (任何 Java 对象)</strong>。</td>
</tr>
<tr>
<td><strong>存储数据大小</strong></td>
<td><strong>小</strong>，单个 Cookie 约 4KB，数量也有限制。</td>
<td><strong>理论上无限制</strong>，但受限于服务器的内存大小。</td>
</tr>
<tr>
<td><strong>对服务器压力</strong></td>
<td><strong>无</strong>，不占用服务器资源。</td>
<td><strong>有</strong>，每个用户的 Session 都会占用服务器的内存资源。</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>可通过 <code>setMaxAge</code> 设置为长久有效（存硬盘），或会话级别（存内存）。</td>
<td>通常是会话级别，或由服务器超时策略决定。</td>
</tr>
<tr>
<td><strong>联系</strong></td>
<td><strong>Session 依赖 Cookie</strong> 来实现。服务器通过 <code>JSESSIONID</code> Cookie 来识别客户端对应的 Session。</td>
<td>Session 机制的实现通常需要 Cookie 的支持。</td>
</tr>
</tbody></table>
<hr>
<h1 id="四、Servlet-上下文与配置"><a href="#四、Servlet-上下文与配置" class="headerlink" title="四、Servlet 上下文与配置"></a>四、Servlet 上下文与配置</h1><h2 id="1-ServletContext-应用上下文"><a href="#1-ServletContext-应用上下文" class="headerlink" title="1. ServletContext (应用上下文)"></a>1. ServletContext (应用上下文)</h2><h3 id="1-1-定义-2"><a href="#1-1-定义-2" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><strong><code>ServletContext</code></strong> 是一个<strong>全局性的接口</strong>，它代表了<strong>整个 Web 应用</strong>本身。</p>
<p>当 Servlet 容器（如 Tomcat）启动一个 Web 应用时，它会为这个应用创建一个<strong>唯一</strong>的 <code>ServletContext</code> 实例。这个实例在 Web 应用被加载时创建，在 Web 应用被移除或服务器关闭时销毁。</p>
<p><strong>核心特性：</strong></p>
<ul>
<li><strong>唯一性：</strong> 每个 Web 应用（每个 <code>.war</code> 文件）只有一个 <code>ServletContext</code> 实例。</li>
<li><strong>全局性：</strong> 该实例被应用内的所有 Servlet、Filter 和 Listener 共享。</li>
<li><strong>生命周期：</strong> 与 Web 应用的生命周期相同。</li>
</ul>
<p>它提供了一种让应用中的不同组件（如多个 Servlet）相互通信和共享数据的方式。</p>
<hr>
<h3 id="1-2-获取方式"><a href="#1-2-获取方式" class="headerlink" title="1.2 获取方式"></a>1.2 获取方式</h3><ol>
<li><p><strong>在 Servlet 中获取：</strong></p>
<ul>
<li><p><strong>通过 <code>GenericServlet</code> 继承的方法（最常用）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过 <code>ServletConfig</code> 对象获取（通常在 <code>init</code> 方法中）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> config.getServletContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>通过 <code>HttpServletRequest</code> 对象获取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> request.getServletContext();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过 <code>HttpSession</code> 对象获取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> session.getServletContext();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 Listener 中获取：</strong></p>
<ul>
<li>在实现了 <code>ServletContextListener</code> 的监听器中，可以直接通过事件对象获取：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> sce.getServletContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="1-3-作用"><a href="#1-3-作用" class="headerlink" title="1.3 作用"></a>1.3 作用</h3><ol>
<li><p><strong>作为域对象，实现全局数据共享 (Application Scope):</strong></p>
<ul>
<li><code>ServletContext</code> 是三大作用域中范围最大的一个。存储在其中的数据，整个应用中的所有用户、所有请求都可以访问。</li>
<li><strong>API:</strong><ul>
<li><code>void setAttribute(String name, Object value)</code></li>
<li><code>Object getAttribute(String name)</code></li>
<li><code>void removeAttribute(String name)</code></li>
</ul>
</li>
<li><strong>典型应用场景：</strong><ul>
<li><strong>网站访问计数器：</strong> 可以在 <code>ServletContext</code> 中存放一个计数器，每次请求都对其加一。</li>
<li><strong>Web 应用的全局配置信息：</strong> 例如，数据库连接池对象、Spring 框架的 ApplicationContext 容器等重量级对象，通常会存储在 <code>ServletContext</code> 中，避免重复创建。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>获取全局初始化参数 (<code>&lt;context-param&gt;</code>):</strong></p>
<ul>
<li><p>可以在 <code>web.xml</code> 中配置对整个应用都有效的初始化参数，这些参数通过 <code>ServletContext</code> 来读取。</p>
</li>
<li><p><strong>web.xml 配置:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>appVersion<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Java 代码读取:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> context.getInitParameter(<span class="string">&quot;appVersion&quot;</span>); <span class="comment">// 返回 &quot;1.2.0&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这与 <code>ServletConfig</code> 的初始化参数不同，<code>ServletConfig</code> 的参数仅对单个 Servlet 有效。</p>
</li>
</ul>
</li>
<li><p><strong>获取 Web 应用中的资源:</strong></p>
<ul>
<li><p>这是 <code>ServletContext</code> 非常重要的一个功能，它允许你在不知道项目部署在服务器哪个物理位置的情况下，安全地访问项目内部的资源文件。</p>
</li>
<li><p><strong><code>InputStream getResourceAsStream(String path)</code> (推荐使用):</strong></p>
<ul>
<li>以输入流的形式返回指定路径的资源。路径必须以 <code>/</code> 开头，代表应用的根目录。</li>
<li>这是读取 <code>/WEB-INF/</code> 目录下资源（如配置文件 <code>config.properties</code>）的<strong>标准且最可靠</strong>的方式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取 /WEB-INF/classes/db.properties 文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> context.getResourceAsStream(<span class="string">&quot;/WEB-INF/classes/db.properties&quot;</span>);</span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(in);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>String getRealPath(String path)</code> (谨慎使用):</strong></p>
<ul>
<li>将一个 Web 应用的相对路径转换为服务器上的<strong>绝对物理磁盘路径</strong>。</li>
<li><strong>缺点：</strong> 如果应用是以 <code>.war</code> 包形式直接运行而没有解压，或者在某些安全限制较高的环境中，此方法可能返回 <code>null</code> 或无法正常工作。因此，<code>getResourceAsStream</code> 是更佳选择。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能返回 D:\apache-tomcat\webapps\myapp\images\logo.png</span></span><br><span class="line"><span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> context.getRealPath(<span class="string">&quot;/images/logo.png&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>记录日志:</strong></p>
<ul>
<li><code>void log(String message)</code></li>
<li>可以将日志信息写入到 Servlet 容器的日志文件中（例如 Tomcat 的 <code>logs</code> 目录下的日志），方便进行调试和问题排查。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-三大作用域对象总结"><a href="#2-三大作用域对象总结" class="headerlink" title="2. 三大作用域对象总结"></a>2. 三大作用域对象总结</h2><h3 id="2-1-HttpServletRequest-request-scope"><a href="#2-1-HttpServletRequest-request-scope" class="headerlink" title="2.1 HttpServletRequest (request scope)"></a>2.1 <code>HttpServletRequest</code> (request scope)</h3><ul>
<li><strong>作用域名称：</strong> 请求域 (Request Scope)</li>
<li><strong>生命周期：</strong><ul>
<li><strong>开始：</strong> 当客户端发起一次 HTTP 请求到达服务器时创建。</li>
<li><strong>结束：</strong> 当服务器对该请求的响应完成并发送回客户端时销毁。</li>
<li>它是<strong>生命周期最短</strong>的作用域。</li>
</ul>
</li>
<li><strong>数据共享范围：</strong><ul>
<li>仅在<strong>同一次请求</strong>的处理过程中有效。</li>
<li>数据可以在通过<strong>请求转发 (<code>forward</code>)</strong> 跳转的多个 Servlet 和 JSP 之间共享。</li>
<li>一旦请求结束（例如，通过重定向 <code>redirect</code> 或用户点击新链接），<code>request</code> 对象及其中的数据就会被销毁。</li>
</ul>
</li>
<li><strong>典型应用场景：</strong><ul>
<li><strong>MVC 模式中的数据传递：</strong> Servlet (Controller) 处理完业务逻辑，将需要展示给用户的数据（如一个 <code>User</code> 对象或一个 <code>List</code> 集合）存入 <code>request</code> 域，然后<strong>转发</strong>到 JSP (View) 页面进行渲染。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-HttpSession-session-scope"><a href="#2-2-HttpSession-session-scope" class="headerlink" title="2.2 HttpSession (session scope)"></a>2.2 <code>HttpSession</code> (session scope)</h3><ul>
<li><strong>作用域名称：</strong> 会话域 (Session Scope)</li>
<li><strong>生命周期：</strong><ul>
<li><strong>开始：</strong> 当一个用户（浏览器）首次访问应用，并且代码调用 <code>request.getSession()</code> 时创建。</li>
<li><strong>结束：</strong> 以下三种情况之一发生时销毁：<ol>
<li>会话超时（用户长时间无操作）。</li>
<li>开发者手动调用 <code>session.invalidate()</code> 方法。</li>
<li>服务器关闭或 Web 应用被卸载。</li>
</ol>
</li>
</ul>
</li>
<li><strong>数据共享范围：</strong><ul>
<li>在<strong>同一个用户（浏览器）的多次请求之间</strong>有效。</li>
<li>数据对于当前用户是私有的，其他用户无法访问。</li>
</ul>
</li>
<li><strong>典型应用场景：</strong><ul>
<li><strong>跟踪用户状态：</strong><ul>
<li><strong>用户登录：</strong> 存储用户的登录信息，判断用户是否已登录。</li>
<li><strong>购物车：</strong> 存储用户添加到购物车中的商品列表。</li>
<li><strong>在线表单：</strong> 在多步骤的表单提交中，临时保存用户已填写的信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-ServletContext-application-scope"><a href="#2-3-ServletContext-application-scope" class="headerlink" title="2.3 ServletContext (application scope)"></a>2.3 <code>ServletContext</code> (application scope)</h3><ul>
<li><strong>作用域名称：</strong> 应用域 &#x2F; 上下文域 (Application Scope)</li>
<li><strong>生命周期：</strong><ul>
<li><strong>开始：</strong> 当 Web 应用在服务器上被加载（启动）时创建。</li>
<li><strong>结束：</strong> 当 Web 应用被卸载或服务器关闭时销毁。</li>
<li>它是<strong>生命周期最长</strong>的作用域，与 Web 应用共存亡。</li>
</ul>
</li>
<li><strong>数据共享范围：</strong><ul>
<li>在<strong>整个 Web 应用的所有用户、所有请求之间</strong>共享。</li>
<li>它是全局的，任何一个用户存入的数据，其他所有用户都能访问到。</li>
</ul>
</li>
<li><strong>典型应用场景：</strong><ul>
<li><strong>存储全局性、共享性的资源：</strong><ul>
<li><strong>网站访问量计数器。</strong></li>
<li><strong>数据库连接池</strong>、<strong>Spring IoC 容器</strong>等重量级对象，只需创建一次，供整个应用使用。</li>
<li><strong>应用范围的配置信息</strong>，如从 <code>web.xml</code> 中读取的 <code>&lt;context-param&gt;</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-Servlet-配置"><a href="#3-Servlet-配置" class="headerlink" title="3. Servlet 配置"></a>3. Servlet 配置</h2><h3 id="3-1-传统方式：web-xml-部署描述符"><a href="#3-1-传统方式：web-xml-部署描述符" class="headerlink" title="3.1 传统方式：web.xml (部署描述符)"></a>3.1 传统方式：<code>web.xml</code> (部署描述符)</h3><p>在 Servlet 3.0 规范之前，<strong><code>web.xml</code> 文件是唯一</strong>的配置方式。这个文件位于 Web 应用的 <code>WEB-INF</code> 目录下，是整个应用的部署描述符 。</p>
<p>配置一个 Servlet 通常需要两个核心标签：<code>&lt;servlet&gt;</code> 和 <code>&lt;servlet-mapping&gt;</code>。</p>
<ol>
<li><strong><code>&lt;servlet&gt;</code> 标签：声明一个 Servlet</strong><ul>
<li><strong>作用：</strong> 向容器注册一个 Servlet，给它起一个内部使用的逻辑名称，并指定它的完整类路径。</li>
<li><strong>子标签：</strong><ul>
<li><code>&lt;servlet-name&gt;</code>: 为 Servlet 指定一个唯一的、自定义的名称。这个名称在 <code>web.xml</code> 内部用作引用。</li>
<li><code>&lt;servlet-class&gt;</code>: 指定该 Servlet 的<strong>完整类名</strong>（包名 + 类名）。</li>
<li><code>&lt;init-param&gt;</code>: (可选) 为该 Servlet 配置初始化参数。</li>
<li><code>&lt;load-on-startup&gt;</code>: (可选) 配置 Servlet 的加载时机。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>&lt;servlet-mapping&gt;</code> 标签：映射 Servlet 的访问路径</strong><ul>
<li><strong>作用：</strong> 将一个已声明的 Servlet 与一个或多个 URL 模式关联起来。</li>
<li><strong>子标签：</strong><ul>
<li><code>&lt;servlet-name&gt;</code>: 必须与 <code>&lt;servlet&gt;</code> 标签中定义的某个 <code>&lt;servlet-name&gt;</code> <strong>完全匹配</strong>，以此建立关联。</li>
<li><code>&lt;url-pattern&gt;</code>: 定义客户端可以通过哪个 URL 路径来访问这个 Servlet。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="web-xml-示例："><a href="#web-xml-示例：" class="headerlink" title="web.xml 示例："></a><code>web.xml</code> 示例：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1. 声明一个名为 &quot;loginServlet&quot; 的 Servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>loginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.example.web.LoginServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 配置启动时加载，数字越小优先级越高 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 将 URL &quot;/login&quot; 映射到 &quot;loginServlet&quot; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>loginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当用户访问 <code>http://.../应用名/login</code> 时，Tomcat 就会调用 <code>com.example.web.LoginServlet</code> 的 <code>service</code> 方法。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>集中管理：</strong> 所有配置集中在一个文件中，方便查看整个应用的路由结构。</li>
<li><strong>修改方便：</strong> 可以在不重新编译 Java 代码的情况下修改 URL 映射。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>繁琐：</strong> 在大型项目中，<code>web.xml</code> 文件会变得异常庞大和复杂，难以维护。</li>
<li><strong>分散：</strong> 配置信息与代码本身分离，降低了代码的内聚性。</li>
</ul>
<hr>
<h3 id="3-2-现代方式：注解-Servlet-3-0"><a href="#3-2-现代方式：注解-Servlet-3-0" class="headerlink" title="3.2 现代方式：注解 (Servlet 3.0+)"></a>3.2 现代方式：注解 (Servlet 3.0+)</h3><p>从 <strong>Servlet 3.0 规范</strong>开始，引入了注解 (Annotation) 的方式来配置 Servlet，大大简化了开发过程。<strong>这是目前主流的配置方式</strong>。</p>
<ol>
<li><strong><code>@WebServlet</code> 注解</strong><ul>
<li><strong>作用：</strong> 直接在 Servlet 的 Java 类上使用此注解，即可完成声明和映射，<strong>完全替代</strong>了 <code>web.xml</code> 中的 <code>&lt;servlet&gt;</code> 和 <code>&lt;servlet-mapping&gt;</code>。</li>
<li><strong>常用属性：</strong><ul>
<li><code>value</code> 或 <code>urlPatterns</code>: 指定一个或多个 URL 模式。这是最常用的属性。<ul>
<li>例如：<code>@WebServlet(&quot;/login&quot;)</code></li>
<li>例如：<code>@WebServlet(urlPatterns = {&quot;/user/login&quot;, &quot;/user/auth&quot;})</code></li>
</ul>
</li>
<li><code>name</code>: (可选) 相当于 <code>&lt;servlet-name&gt;</code>。如果不指定，容器会默认使用类的全名。</li>
<li><code>loadOnStartup</code>: (可选) 相当于 <code>&lt;load-on-startup&gt;</code>，用于设置加载时机。</li>
<li><code>initParams</code>: (可选) 相当于 <code>&lt;init-param&gt;</code>，用于配置初始化参数，需要与 <code>@WebInitParam</code> 注解配合使用。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>@WebInitParam</code> 注解</strong><ul>
<li><strong>作用：</strong> 用于在 <code>@WebServlet</code> 的 <code>initParams</code> 属性中定义初始化参数。</li>
<li><strong>属性：</strong> <code>name</code> 和 <code>value</code>。</li>
</ul>
</li>
</ol>
<h4 id="注解示例："><a href="#注解示例：" class="headerlink" title="注解示例："></a>注解示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 @WebServlet 注解完成所有配置</span></span><br><span class="line"><span class="meta">@WebServlet(</span></span><br><span class="line"><span class="meta">    name = &quot;loginServlet&quot;,</span></span><br><span class="line"><span class="meta">    urlPatterns = &#123;&quot;/login&quot;, &quot;/signin&quot;&#125;, // 映射了两个 URL</span></span><br><span class="line"><span class="meta">    loadOnStartup = 1,</span></span><br><span class="line"><span class="meta">    initParams = &#123;</span></span><br><span class="line"><span class="meta">        @WebInitParam(name = &quot;loginPage&quot;, value = &quot;/login.jsp&quot;),</span></span><br><span class="line"><span class="meta">        @WebInitParam(name = &quot;errorPage&quot;, value = &quot;/error.jsp&quot;)</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 读取初始化参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">loginPage</span> <span class="operator">=</span> <span class="built_in">this</span>.getInitParameter(<span class="string">&quot;loginPage&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Login Page from init param: &quot;</span> + loginPage);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;This is the Login Servlet configured by Annotation.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的效果与上面的 <code>web.xml</code> 示例完全相同，但配置与代码紧密结合，更加清晰直观。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>简洁方便：</strong> 代码量大大减少，无需繁琐的 XML 配置。</li>
<li><strong>内聚性高：</strong> 配置信息和它所配置的类放在一起，提高了代码的可读性和可维护性。</li>
<li><strong>IDE 支持良好：</strong> 现代 IDE 对注解有很好的支持，可以方便地进行导航和重构。</li>
</ul>
<hr>
<h1 id="五、过滤器-Filter-与监听器-Listener"><a href="#五、过滤器-Filter-与监听器-Listener" class="headerlink" title="五、过滤器 (Filter) 与监听器 (Listener)"></a>五、过滤器 (Filter) 与监听器 (Listener)</h1><h2 id="1-Filter-过滤器"><a href="#1-Filter-过滤器" class="headerlink" title="1. Filter (过滤器)"></a>1. Filter (过滤器)</h2><h3 id="1-1-定义-3"><a href="#1-1-定义-3" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><strong>Filter (过滤器)</strong> 是一个实现了 <code>javax.servlet.Filter</code> 接口的 Java 对象，它位于客户端请求和目标资源（如 Servlet、JSP 或静态文件）之间，用于<strong>拦截和处理请求与响应</strong>。</p>
<p><strong>核心作用：</strong></p>
<ul>
<li><strong>预处理请求：</strong> 在请求到达 Servlet 之前，可以检查、修改请求头和请求数据。</li>
<li><strong>后处理响应：</strong> 在响应发送给客户端之前，可以修改响应头和响应内容。</li>
<li><strong>拦截请求：</strong> 可以决定是否将请求继续传递给目标资源，或者直接中断请求流程（例如，用户未登录时跳转到登录页面）。</li>
</ul>
<p>Filter 是一种典型的<strong>责任链模式 (Chain of Responsibility Pattern)</strong> 的应用，它提供了一种对 Web 资源进行“横切”关注（如日志、安全、编码）的强大机制，而无需修改 Servlet 本身的代码，实现了<strong>低耦合</strong>。</p>
<hr>
<h3 id="1-2-Filter-生命周期"><a href="#1-2-Filter-生命周期" class="headerlink" title="1.2 Filter 生命周期"></a>1.2 Filter 生命周期</h3><p>Filter 的生命周期由 Servlet 容器管理，与 Servlet 非常相似，也包含三个核心方法：</p>
<ol>
<li><strong><code>void init(FilterConfig filterConfig)</code>: 初始化</strong><ul>
<li><strong>调用时机：</strong> Web 应用启动时，容器会创建 Filter 实例，并<strong>立即调用</strong> <code>init()</code> 方法。</li>
<li><strong>调用次数：</strong> 在 Filter 的整个生命周期中<strong>只调用一次</strong>。</li>
<li><strong>作用：</strong> 用于执行一次性的初始化任务，例如加载配置文件、创建数据库连接等。<code>FilterConfig</code> 对象可以用来获取初始化参数和 <code>ServletContext</code> 对象。</li>
</ul>
</li>
<li><strong><code>void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</code>: 执行过滤</strong><ul>
<li><strong>调用时机：</strong> <strong>每一次</strong>匹配该 Filter 的 URL 模式的请求到达时，容器都会调用此方法。</li>
<li><strong>调用次数：</strong> <strong>多次</strong>。这是 Filter 的核心工作方法。</li>
<li><strong>作用：</strong> 实现具体的过滤逻辑。<ul>
<li><strong><code>chain.doFilter(request, response)</code></strong> 是这个方法中最关键的一行代码。</li>
<li><strong>放行操作：</strong> 调用 <code>chain.doFilter()</code> 会将请求传递给过滤器链中的下一个 Filter，或者如果已经是最后一个 Filter，则传递给目标资源（Servlet）。</li>
<li><strong>代码位置决定处理时机：</strong><ul>
<li>在 <code>chain.doFilter()</code> <strong>之前</strong>写的代码，是对<strong>请求 (Request)</strong> 的预处理。</li>
<li>在 <code>chain.doFilter()</code> <strong>之后</strong>写的代码，是对<strong>响应 (Response)</strong> 的后处理。</li>
</ul>
</li>
<li><strong>拦截操作：</strong> 如果在方法中<strong>不调用</strong> <code>chain.doFilter()</code>，则请求将被拦截，不会继续向下传递。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>void destroy()</code>: 销毁</strong><ul>
<li><strong>调用时机：</strong> Web 应用被卸载或服务器关闭时，容器会调用 <code>destroy()</code> 方法。</li>
<li><strong>调用次数：</strong> <strong>只调用一次</strong>。</li>
<li><strong>作用：</strong> 用于释放 <code>init()</code> 方法中创建的资源，例如关闭数据库连接、文件流等。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-3-FilterChain-过滤器链"><a href="#1-3-FilterChain-过滤器链" class="headerlink" title="1.3 FilterChain (过滤器链)"></a>1.3 <code>FilterChain</code> (过滤器链)</h3><p>当一个请求的 URL 同时匹配多个 Filter 的映射规则时，Servlet 容器会将这些 Filter 按照它们在 <code>web.xml</code> 中配置的顺序（或者注解的特定顺序，但 XML 提供了更明确的控制）组织成一个<strong>过滤器链 (<code>FilterChain</code>)</strong>。</p>
<pre><code class="highlight mermaid">sequenceDiagram
    actor Client
    participant Filter1
    participant Filter2
    participant Servlet

    rect rgb(235, 245, 255)
        note over Client, Servlet: 请求阶段 (Request Flow)
        Client-&gt;&gt;+Filter1: 1. 发起 HTTP Request
        note right of Filter1: 2. 执行 chain.doFilter() 之前的代码
        Filter1-&gt;&gt;+Filter2: 3. 调用 chain.doFilter()
        note right of Filter2: 4. 执行 chain.doFilter() 之前的代码
        Filter2-&gt;&gt;+Servlet: 5. 调用 chain.doFilter()
        note right of Servlet: 6. Servlet.service() 处理请求
    end

    rect rgb(255, 245, 235)
        note over Client, Servlet: 响应阶段 (Response Flow)
        Servlet--&gt;&gt;-Filter2: 7. 生成 HTTP Response 并返回
        note left of Filter2: 8. 执行 chain.doFilter() 之后的代码
        Filter2--&gt;&gt;-Filter1: (继续返回)
        note left of Filter1: 8. 执行 chain.doFilter() 之后的代码
        Filter1--&gt;&gt;-Client: 9. 最终响应返回给客户端
    end</code></pre>

<p><strong>工作流程:</strong></p>
<ol>
<li>请求首先到达链中的第一个 Filter (<code>Filter1</code>)。</li>
<li><code>Filter1</code> 执行其 <code>doFilter()</code> 方法中 <code>chain.doFilter()</code> 之前的代码。</li>
<li><code>Filter1</code> 调用 <code>chain.doFilter()</code>，控制权转移给链中的第二个 Filter (<code>Filter2</code>)。</li>
<li><code>Filter2</code> 执行其 <code>doFilter()</code> 方法…以此类推，直到最后一个 Filter。</li>
<li>最后一个 Filter 调用 <code>chain.doFilter()</code>，请求最终到达目标 Servlet。</li>
<li>Servlet 处理请求，生成响应。</li>
<li>响应沿着<strong>相反的路径</strong>返回，依次经过链中的每个 Filter。</li>
<li>每个 Filter 执行其 <code>doFilter()</code> 方法中 <code>chain.doFilter()</code> <strong>之后</strong>的代码，可以对响应进行处理。</li>
<li>最终，响应从第一个 Filter 发送回客户端。</li>
</ol>
<hr>
<h3 id="1-4-配置"><a href="#1-4-配置" class="headerlink" title="1.4 配置"></a>1.4 配置</h3><p>与 Servlet 类似，Filter 也有两种配置方式：</p>
<ol>
<li><p><strong>传统方式 (<code>web.xml</code>)</strong></p>
<ul>
<li><strong><code>&lt;filter&gt;</code> 标签：</strong> 声明一个 Filter。<ul>
<li><code>&lt;filter-name&gt;</code>: Filter 的逻辑名称。</li>
<li><code>&lt;filter-class&gt;</code>: Filter 的完整类名。</li>
</ul>
</li>
<li><strong><code>&lt;filter-mapping&gt;</code> 标签：</strong> 映射 Filter。<ul>
<li><code>&lt;filter-name&gt;</code>: 与 <code>&lt;filter&gt;</code> 中的名称对应。</li>
<li><code>&lt;url-pattern&gt;</code>: 指定要过滤的 URL 模式（如 <code>/*</code>, <code>/admin/*</code>, <code>*.do</code>）。</li>
<li><code>&lt;dispatcher&gt;</code>: (可选) 指定 Filter 拦截的请求类型，可以是 <code>REQUEST</code> (默认), <code>FORWARD</code>, <code>INCLUDE</code>, <code>ERROR</code>。</li>
</ul>
</li>
</ul>
<p><strong><code>web.xml</code> 示例:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.example.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!-- 拦截所有请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>现代方式 (注解 <code>@WebFilter</code>)</strong></p>
<ul>
<li>在 Filter 实现类上使用 <code>@WebFilter</code> 注解即可完成配置。</li>
<li><strong>常用属性:</strong> <code>urlPatterns</code> (或 <code>value</code>), <code>filterName</code>, <code>initParams</code>, <code>dispatcherTypes</code>。</li>
</ul>
<p><strong>注解示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span> <span class="comment">// 拦截所有请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharacterEncodingFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 预处理：设置请求编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将请求传递下去</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 后处理：可以设置响应编码，但通常在 Servlet 中设置更灵活</span></span><br><span class="line">        <span class="comment">// response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// init 和 destroy 方法可以留空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="1-5-典型应用场景"><a href="#1-5-典型应用场景" class="headerlink" title="1.5 典型应用场景"></a>1.5 典型应用场景</h3><p>Filter 的应用非常广泛，是许多 Web 框架实现核心功能的基础。</p>
<ul>
<li><strong>统一字符编码 (Character Encoding Filter):</strong><ul>
<li>这是最经典的应用。创建一个 Filter 拦截所有请求，在 <code>doFilter</code> 方法中统一设置 <code>request.setCharacterEncoding(&quot;UTF-8&quot;)</code>，一劳永逸地解决全站的 POST 请求中文乱码问题。</li>
</ul>
</li>
<li><strong>用户登录验证 (Authentication Filter):</strong><ul>
<li>拦截需要登录才能访问的资源（如 <code>/admin/*</code>）。</li>
<li>检查 <code>HttpSession</code> 中是否存在用户登录信息。</li>
<li>如果存在，则调用 <code>chain.doFilter()</code> 放行。</li>
<li>如果不存在，则重定向到登录页面，并且<strong>不调用</strong> <code>chain.doFilter()</code> 来中断请求。</li>
</ul>
</li>
<li><strong>权限控制 (Authorization Filter):</strong><ul>
<li>在用户已登录的基础上，检查用户是否拥有访问特定资源的权限（如角色是管理员还是普通用户）。</li>
<li>如果没有权限，则跳转到“无权限”提示页面。</li>
</ul>
</li>
<li><strong>请求日志记录 (Logging Filter):</strong><ul>
<li>记录每个请求的详细信息，如来源 IP、请求 URL、请求参数、处理时长等，用于系统监控和问题排查。</li>
</ul>
</li>
<li><strong>数据压缩 (GZIP Compression Filter):</strong><ul>
<li>拦截响应，将响应体（如 HTML, CSS, JS）进行 GZIP 压缩，并在响应头中设置 <code>Content-Encoding: gzip</code>，可以显著减少传输大小，加快页面加载速度。</li>
</ul>
</li>
<li><strong>XSS&#x2F;CSRF 安全防护:</strong><ul>
<li>创建 Filter 来包装 <code>HttpServletRequest</code> 对象，重写 <code>getParameter()</code> 等方法，对传入的参数进行过滤和转义，防止跨站脚本攻击 (XSS)。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-Listener-监听器"><a href="#2-Listener-监听器" class="headerlink" title="2. Listener (监听器)"></a>2. Listener (监听器)</h2><h3 id="2-1-定义-1"><a href="#2-1-定义-1" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p><strong>Listener (监听器)</strong> 是一种特殊的 Java 类，它实现了 Servlet API 中特定的监听器接口。它的作用是<strong>被动地监听</strong> Web 应用中特定<strong>事件</strong>的发生，并在事件发生时执行预定义的代码。</p>
<p>你可以把它想象成一个**“事件报警器”<strong>或</strong>“订阅者”**。它在 Web 应用的生命周期中静静地等待，当它所“订阅”的事件（例如：应用启动、Session 创建、请求到达）发生时，Servlet 容器会自动通知它，并调用其相应的方法。</p>
<p><strong>核心特点：</strong></p>
<ul>
<li><strong>事件驱动 (Event-Driven):</strong> 监听器的工作模式是基于事件的，而不是像 Servlet 或 Filter 那样直接处理请求。</li>
<li><strong>被动触发:</strong> 我们不直接调用监听器的方法，而是由 Servlet 容器在特定事件发生时自动回调。</li>
<li><strong>全局监控:</strong> 监听器提供了一种从宏观层面监控和干预 Web 应用状态变化的方式。</li>
</ul>
<hr>
<h3 id="2-2-分类"><a href="#2-2-分类" class="headerlink" title="2.2 分类"></a>2.2 分类</h3><p>Servlet API 提供了多种监听器接口，根据它们监听的<strong>事件源</strong>和<strong>事件类型</strong>，主要可以分为三大类：</p>
<h4 id="2-2-1-监听作用域对象生命周期的-Listener"><a href="#2-2-1-监听作用域对象生命周期的-Listener" class="headerlink" title="2.2.1 监听作用域对象生命周期的 Listener"></a>2.2.1 监听作用域对象生命周期的 Listener</h4><p>这类监听器关注三大作用域对象（<code>ServletContext</code>, <code>HttpSession</code>, <code>ServletRequest</code>）的<strong>创建和销毁</strong>。</p>
<ul>
<li><strong><code>ServletContextListener</code> (最常用):</strong><ul>
<li><strong>监听对象:</strong> <code>ServletContext</code> (整个 Web 应用)</li>
<li><strong>事件:</strong> Web 应用的启动和关闭。</li>
<li><strong>方法:</strong><ul>
<li><code>contextInitialized(ServletContextEvent sce)</code>: 在 Web 应用<strong>被加载</strong>时调用。</li>
<li><code>contextDestroyed(ServletContextEvent sce)</code>: 在 Web 应用<strong>被卸载</strong>时调用。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>HttpSessionListener</code>:</strong><ul>
<li><strong>监听对象:</strong> <code>HttpSession</code> (用户会话)</li>
<li><strong>事件:</strong> 一个会话的创建和销毁。</li>
<li><strong>方法:</strong><ul>
<li><code>sessionCreated(HttpSessionEvent se)</code>: 在一个<strong>新会话被创建</strong>时调用。</li>
<li><code>sessionDestroyed(HttpSessionEvent se)</code>: 在一个<strong>会话失效或被销毁</strong>时调用。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>ServletRequestListener</code>:</strong><ul>
<li><strong>监听对象:</strong> <code>ServletRequest</code> (一次请求)</li>
<li><strong>事件:</strong> 一次 HTTP 请求的开始和结束。</li>
<li><strong>方法:</strong><ul>
<li><code>requestInitialized(ServletRequestEvent sre)</code>: 在一个<strong>请求到达</strong> Servlet 容器时调用。</li>
<li><code>requestDestroyed(ServletRequestEvent sre)</code>: 在一个<strong>请求处理完毕</strong>并即将离开容器时调用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-2-监听作用域对象属性变化的-Listener"><a href="#2-2-2-监听作用域对象属性变化的-Listener" class="headerlink" title="2.2.2 监听作用域对象属性变化的 Listener"></a>2.2.2 监听作用域对象属性变化的 Listener</h4><p>这类监听器关注三大作用域对象中<strong>属性 (Attribute) 的添加、移除和替换</strong>。</p>
<ul>
<li><strong><code>ServletContextAttributeListener</code>:</strong> 监听 <code>ServletContext</code> 中属性的变化。</li>
<li><strong><code>HttpSessionAttributeListener</code>:</strong> 监听 <code>HttpSession</code> 中属性的变化。</li>
<li><strong><code>ServletRequestAttributeListener</code>:</strong> 监听 <code>ServletRequest</code> 中属性的变化。</li>
<li><strong>它们都包含三个方法:</strong><ul>
<li><code>attributeAdded(...)</code>: 当调用 <code>setAttribute</code> 添加一个新属性时触发。</li>
<li><code>attributeRemoved(...)</code>: 当调用 <code>removeAttribute</code> 时触发。</li>
<li><code>attributeReplaced(...)</code>: 当调用 <code>setAttribute</code> 替换一个同名旧属性时触发。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-3-监听-Session-中对象状态的-Listener"><a href="#2-2-3-监听-Session-中对象状态的-Listener" class="headerlink" title="2.2.3 监听 Session 中对象状态的 Listener"></a>2.2.3 监听 Session 中对象状态的 Listener</h4><p>这类监听器由<strong>被存入 Session 的对象本身</strong>来实现，用于感知自己何时被绑定到 Session 或从 Session 解绑。</p>
<ul>
<li><strong><code>HttpSessionBindingListener</code>:</strong><ul>
<li>当一个<strong>实现了此接口的对象</strong>被 <code>session.setAttribute()</code> 存入 Session 或被 <code>session.removeAttribute()</code> 移除时，该对象自身的方法会被调用。</li>
<li><strong>方法:</strong> <code>valueBound(...)</code>, <code>valueUnbound(...)</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-配置"><a href="#2-3-配置" class="headerlink" title="2.3 配置"></a>2.3 配置</h3><p>与 Servlet 和 Filter 一样，监听器也支持 <code>web.xml</code> 和注解两种配置方式。</p>
<ol>
<li><p><strong>传统方式 (<code>web.xml</code>)</strong></p>
<ul>
<li>使用 <code>&lt;listener&gt;</code> 标签来声明一个监听器。</li>
<li>它只有一个子标签 <code>&lt;listener-class&gt;</code>，用于指定监听器的完整类名。</li>
</ul>
<p><strong><code>web.xml</code> 示例:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.example.listener.MyAppContextListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>现代方式 (注解 <code>@WebListener</code>)</strong></p>
<ul>
<li>在监听器实现类上添加 <code>@WebListener</code> 注解即可。</li>
<li>这是一个标记注解，没有任何属性。容器在启动时会自动扫描带有此注解的类并注册它们。</li>
</ul>
<p><strong>注解示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAppContextListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Web Application is starting up...&quot;</span>);</span><br><span class="line">        <span class="comment">// 在这里执行初始化任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Web Application is shutting down...&quot;</span>);</span><br><span class="line">        <span class="comment">// 在这里执行清理任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="2-4-典型应用场景"><a href="#2-4-典型应用场景" class="headerlink" title="2.4 典型应用场景"></a>2.4 典型应用场景</h3><p>监听器在框架和大型应用中扮演着至关重要的“引导”和“监控”角色。</p>
<ul>
<li><strong>使用 <code>ServletContextListener</code>:</strong><ul>
<li><strong>初始化全局资源 (重量级应用):</strong><ul>
<li>创建和初始化<strong>数据库连接池</strong>（如 HikariCP, C3P0）。</li>
<li>加载和解析全局<strong>配置文件</strong> (<code>.properties</code>, <code>.xml</code>)。</li>
<li>启动<strong>定时任务</strong>调度器（如 Quartz）。</li>
<li><strong>初始化 IoC 容器</strong>，例如 Spring 框架的 <code>ContextLoaderListener</code> 就是一个典型的 <code>ServletContextListener</code>，它负责在应用启动时创建和加载 Spring 的应用上下文。</li>
</ul>
</li>
<li><strong>应用关闭时释放资源：</strong> 在 <code>contextDestroyed</code> 方法中，优雅地关闭数据库连接池、停止定时任务等。</li>
</ul>
</li>
<li><strong>使用 <code>HttpSessionListener</code>:</strong><ul>
<li><strong>统计在线用户数量：</strong><ul>
<li>在 <code>sessionCreated</code> 方法中，将一个全局计数器（通常存放在 <code>ServletContext</code> 中）加一。</li>
<li>在 <code>sessionDestroyed</code> 方法中，将该计数器减一。</li>
</ul>
</li>
<li><strong>监控用户会话：</strong> 记录用户会话的创建和销毁日志，用于行为分析或问题排查。</li>
</ul>
</li>
<li><strong>使用 <code>ServletRequestListener</code>:</strong><ul>
<li><strong>记录请求处理时长：</strong> 在 <code>requestInitialized</code> 中记录开始时间戳，在 <code>requestDestroyed</code> 中记录结束时间戳，计算并记录每个请求的耗时，用于性能监控。</li>
</ul>
</li>
<li><strong>使用 <code>HttpSessionAttributeListener</code>:</strong><ul>
<li><strong>监控敏感信息：</strong> 监听 <code>HttpSession</code> 中特定属性（如用户信息、权限列表）的变化，当这些信息被修改时，记录日志以备审计。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="六、高级主题与实践"><a href="#六、高级主题与实践" class="headerlink" title="六、高级主题与实践"></a>六、高级主题与实践</h1><h2 id="1-Servlet-与-JSP-的关系-MVC-模式"><a href="#1-Servlet-与-JSP-的关系-MVC-模式" class="headerlink" title="1. Servlet 与 JSP 的关系 (MVC 模式)"></a>1. Servlet 与 JSP 的关系 (MVC 模式)</h2><h3 id="1-1-JSP的本质"><a href="#1-1-JSP的本质" class="headerlink" title="1.1 JSP的本质"></a>1.1 JSP的本质</h3><p><strong>JSP (JavaServer Pages) 的本质就是一个 Servlet。</strong></p>
<p>这可能是理解 JJSP 文件并不是直接由浏览器执行的，它是一个<strong>模板</strong>，最终会被 Servlet 容器（如 Tomcat 内置的 Jasper 引擎）转换为一个 <code>.java</code> 的 Servlet 源文件，然后编译成一个 <code>.class</code> 文件来运行。</p>
<p><strong>转换过程（第一次访问 JSP 时发生）：</strong></p>
<ol>
<li><strong>翻译 (Translate):</strong> JSP 引擎解析 <code>.jsp</code> 文件。<ul>
<li>文件中的静态 HTML 部分被转换为 Java 代码中的 <code>out.println(&quot;&lt;html&gt;...&quot;);</code> 语句。</li>
<li>JSP 脚本元素，如 Scriptlet (<code>&lt;% ... %&gt;</code>) 和表达式 (<code>&lt;%= ... %&gt;</code>)，被原样插入到生成的 Servlet 的 <code>_jspService()</code> 方法中。</li>
</ul>
</li>
<li><strong>编译 (Compile):</strong> 容器调用 Java 编译器将这个生成的 <code>.java</code> 文件编译成 <code>.class</code> 文件。</li>
<li><strong>执行 (Execute):</strong> 容器加载并执行这个编译好的 Servlet 类，其生命周期和普通 Servlet 一样。</li>
</ol>
<p><strong>为什么要有 JSP？</strong></p>
<p>JSP 的诞生是为了解决早期 Servlet 开发的一个巨大痛点：在 Servlet 的 Java 代码中通过 <code>out.println()</code> 来拼接复杂的 HTML 页面是一场噩梦，难以编写和维护。</p>
<ul>
<li><strong>Servlet 的优势：</strong> 擅长处理 Java 逻辑、控制流程、处理业务。<strong>（逻辑强，表现弱）</strong></li>
<li><strong>JSP 的优势：</strong> 擅长展示动态内容，可以在 HTML 中嵌入少量 Java 代码。<strong>（表现强，逻辑弱）</strong></li>
</ul>
<p>因此，最佳实践就是让它们各司其职。</p>
<hr>
<h3 id="1-2-MVC-设计模式"><a href="#1-2-MVC-设计模式" class="headerlink" title="1.2 MVC 设计模式"></a>1.2 MVC 设计模式</h3><p><strong>MVC (Model-View-Controller)</strong> 是一种经典的软件设计模式，旨在将应用程序的关注点分离，使其更易于维护、扩展和测试。在 Java Web 应用中，Servlet 和 JSP 完美地契合了 MVC 模式中的角色。</p>
<ul>
<li><strong>Model (模型):</strong><ul>
<li><strong>职责：</strong> 负责应用程序的<strong>业务逻辑</strong>和<strong>数据</strong>。它封装了应用的核心状态和行为，与表示层和控制层解耦。</li>
<li><strong>在 Java Web 中通常是：</strong><ul>
<li>JavaBean &#x2F; POJO (Plain Old Java Object) 用来封装数据。</li>
<li>Service 层类用来处理业务逻辑。</li>
<li>DAO (Data Access Object) 层类用来与数据库交互。</li>
</ul>
</li>
</ul>
</li>
<li><strong>View (视图):</strong><ul>
<li><strong>职责：</strong> 负责<strong>展示数据</strong>，即用户界面。它从模型中获取数据并将其呈现给用户。视图本身应包含最少的业务逻辑。</li>
<li><strong>在 Java Web 中通常是：</strong><ul>
<li><strong>JSP</strong>、HTML、Thymeleaf 等模板引擎。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Controller (控制器):</strong><ul>
<li><strong>职责：</strong> 充当<strong>调度者</strong>。它接收来自用户的请求，调用相应的模型来处理请求，然后选择合适的视图来渲染模型返回的数据，最终将视图的输出返回给用户。</li>
<li><strong>在 Java Web 中通常是：</strong><ul>
<li><strong>Servlet</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-Servlet-与-JSP-在-MVC-中的协作流程："><a href="#1-3-Servlet-与-JSP-在-MVC-中的协作流程：" class="headerlink" title="1.3 Servlet 与 JSP 在 MVC 中的协作流程："></a>1.3 Servlet 与 JSP 在 MVC 中的协作流程：</h3><pre><code class="highlight mermaid">sequenceDiagram
    title Classic Java Web MVC (Servlet + JSP) Flow

    participant Browser as 用户浏览器
    participant Servlet/Controller as 控制器
    participant Model/Service as 模型/服务
    participant JSP/View as 视图

    Browser-&gt;&gt;Servlet/Controller: 1. 发送 HTTP 请求 (GET /products?id=123)
    activate Servlet/Controller

    note over Servlet/Controller: 2. Servlet 容器将请求映射到此控制器

    Servlet/Controller-&gt;&gt;Model/Service: 3. 调用业务逻辑 (getProductById)
    activate Model/Service
    Model/Service--&gt;&gt;Servlet/Controller: 返回数据 (Product 对象)
    deactivate Model/Service

    note over Servlet/Controller: 4. 将 Product 对象存入 request 作用域

    Servlet/Controller-&gt;&gt;JSP/View: 5. 请求转发 (Forward)
    deactivate Servlet/Controller

    activate JSP/View
    note over JSP/View: 6. 渲染视图&lt;br/&gt;- 从 request 域获取数据&lt;br/&gt;- 使用 EL/JSTL 生成 HTML
    JSP/View--&gt;&gt;Browser: 7. 返回 HTML 响应
    deactivate JSP/View</code></pre>

<ol>
<li><strong>请求到达：</strong> 用户的浏览器发送一个 HTTP 请求（例如 <code>GET /products?id=123</code>）。</li>
<li><strong>控制器接收：</strong> Servlet 容器根据 <code>web.xml</code> 或 <code>@WebServlet</code> 的配置，将请求映射到一个 <strong>Servlet (Controller)</strong>。</li>
<li><strong>控制器处理：</strong><ul>
<li>Servlet 解析请求参数（<code>id=123</code>）。</li>
<li>Servlet <strong>调用 Model</strong>（例如 <code>ProductService.getProductById(123)</code>）来执行业务逻辑，获取数据。</li>
<li>Model 返回一个包含产品信息的 JavaBean (<code>Product</code> 对象)。</li>
</ul>
</li>
<li><strong>存储数据：</strong> Servlet 将从 Model 获取的数据（<code>Product</code> 对象）存入一个<strong>作用域对象</strong>中，最常用的是 <code>request</code> 域：<code>request.setAttribute(&quot;product&quot;, productObject);</code>。</li>
<li><strong>转发到视图：</strong> Servlet <strong>请求转发 (<code>forward</code>)</strong> 给一个 <strong>JSP (View)</strong> 文件，例如 <code>request.getRequestDispatcher(&quot;/WEB-INF/views/productDetail.jsp&quot;).forward(request, response);</code>。</li>
<li><strong>视图渲染：</strong><ul>
<li>JSP 页面被激活。</li>
<li>它从 <code>request</code> 域中取出之前 Servlet 存入的数据。</li>
<li>使用 JSP 标签（如 JSTL）或表达式语言（EL）将数据显示在 HTML 模板中。</li>
</ul>
</li>
<li><strong>响应返回：</strong> JSP 生成的最终 HTML 页面作为响应被发送回用户的浏览器。</li>
</ol>
<hr>
<h2 id="2-文件上传与下载"><a href="#2-文件上传与下载" class="headerlink" title="2. 文件上传与下载"></a>2. 文件上传与下载</h2><h3 id="2-1-文件上传"><a href="#2-1-文件上传" class="headerlink" title="2.1 文件上传"></a>2.1 文件上传</h3><h4 id="2-1-1-前端准备：HTML-表单"><a href="#2-1-1-前端准备：HTML-表单" class="headerlink" title="2.1.1 前端准备：HTML 表单"></a>2.1.1 前端准备：HTML 表单</h4><p>要实现文件上传，HTML <code>&lt;form&gt;</code> 必须满足以下<strong>三个条件</strong>：</p>
<ol>
<li><code>method</code> 必须为 <strong><code>post</code></strong>。</li>
<li><code>enctype</code> (encoding type) 必须设置为 <strong><code>multipart/form-data</code></strong>。这告诉服务器请求体将被分割成多个部分，每个部分代表一个表单字段或一个文件。</li>
<li>必须包含一个 <code>&lt;input type=&quot;file&quot;&gt;</code> 标签。</li>
</ol>
<p><strong>HTML 示例 (<code>upload.html</code>):</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>File Upload<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Upload a File<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">        Description: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        Select file: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uploadFile&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Upload&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-2-后端处理：Servlet"><a href="#2-1-2-后端处理：Servlet" class="headerlink" title="2.1.2 后端处理：Servlet"></a>2.1.2 后端处理：Servlet</h4><p>后端的 Servlet 需要做两件事来启用文件上传处理：</p>
<ol>
<li>在 Servlet 类上添加 <strong><code>@MultipartConfig</code></strong> 注解。这个注解会通知 Servlet 容器，该 Servlet 将会处理 <code>multipart/form-data</code> 类型的请求，容器需要预先解析好请求体，以便我们通过 API 获取文件部分。</li>
<li>使用 <code>request.getPart(String name)</code> 方法来获取上传的文件以及其他表单字段。这个方法返回一个 <code>Part</code> 对象。</li>
</ol>
<p><strong><code>Part</code> 接口的核心方法：</strong></p>
<ul>
<li><code>InputStream getInputStream()</code>: 获取上传文件的输入流，用于读取文件内容。</li>
<li><code>String getSubmittedFileName()</code>: 获取客户端上传的原始文件名。</li>
<li><code>long getSize()</code>: 获取文件的大小（字节）。</li>
<li><code>String getContentType()</code>: 获取文件的 MIME 类型（如 <code>image/jpeg</code>）。</li>
<li><code>void write(String fileName)</code>: 一个便捷方法，直接将上传的文件内容写入到服务器磁盘的指定路径。</li>
</ul>
<p><strong>Servlet 示例 (<code>UploadServlet.java</code>):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/upload&quot;)</span></span><br><span class="line"><span class="meta">@MultipartConfig(</span></span><br><span class="line"><span class="meta">    // 可以配置上传文件的限制</span></span><br><span class="line"><span class="meta">    // fileSizeThreshold = 1024 * 1024, // 1MB, 超过此大小的文件会直接写入磁盘</span></span><br><span class="line"><span class="meta">    // maxFileSize = 1024 * 1024 * 10,  // 10MB, 单个文件最大值</span></span><br><span class="line"><span class="meta">    // maxRequestSize = 1024 * 1024 * 50 // 50MB, 整个请求的最大值</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UPLOAD_DIR</span> <span class="operator">=</span> <span class="string">&quot;uploads&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取普通表单字段</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 获取文件部分</span></span><br><span class="line">        <span class="type">Part</span> <span class="variable">filePart</span> <span class="operator">=</span> request.getPart(<span class="string">&quot;uploadFile&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> filePart.getSubmittedFileName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 确定文件存储的绝对路径</span></span><br><span class="line">        <span class="comment">// getServletContext().getRealPath(&quot;&quot;) 获取 Web 应用在服务器上的部署路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">applicationPath</span> <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">uploadFilePath</span> <span class="operator">=</span> applicationPath + File.separator + UPLOAD_DIR;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建上传目录（如果不存在）</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">uploadDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(uploadFilePath);</span><br><span class="line">        <span class="keyword">if</span> (!uploadDir.exists()) &#123;</span><br><span class="line">            uploadDir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将文件写入服务器</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">savePath</span> <span class="operator">=</span> uploadFilePath + File.separator + fileName;</span><br><span class="line">        filePart.write(savePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 返回响应</span></span><br><span class="line">        response.getWriter().println(<span class="string">&quot;&lt;h1&gt;Description: &quot;</span> + description + <span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;&lt;h1&gt;File &quot;</span> + fileName + <span class="string">&quot; has been uploaded successfully!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;Saved at: &quot;</span> + savePath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-文件下载"><a href="#2-2-文件下载" class="headerlink" title="2.2 文件下载"></a>2.2 文件下载</h3><p>文件下载指的是服务器将一个文件以<strong>附件 (attachment)</strong> 的形式发送给客户端，触发浏览器的下载对话框，而不是直接在浏览器中打开。</p>
<p>核心技术是设置两个关键的 <strong>HTTP 响应头</strong>：<code>Content-Type</code> 和 <code>Content-Disposition</code>。</p>
<h4 id="2-2-1-实现步骤"><a href="#2-2-1-实现步骤" class="headerlink" title="2.2.1 实现步骤"></a>2.2.1 实现步骤</h4><ol>
<li><strong>确定要下载的文件：</strong> 通常通过请求参数（如 <code>?fileName=report.pdf</code>）来指定。</li>
<li><strong>设置 <code>Content-Type</code>:</strong> 告诉浏览器文件的 MIME 类型。可以使用 <code>getServletContext().getMimeType(fileName)</code> 来动态获取，如果无法确定，可以设置为通用的 <code>application/octet-stream</code>。</li>
<li><strong>设置 <code>Content-Disposition</code> (最关键):</strong><ul>
<li>将其值设置为 <code>attachment; filename=&quot;your_file_name&quot;</code>。</li>
<li><code>attachment</code> 指示浏览器将其作为附件处理。</li>
<li><code>filename</code> 指定了下载时默认显示的文件名。</li>
<li><strong>注意中文文件名乱码问题：</strong> 文件名需要使用 <code>URLEncoder</code> 进行编码，以符合 HTTP Header 规范。</li>
</ul>
</li>
<li><strong>读取文件并写入响应流：</strong><ul>
<li>使用 <code>FileInputStream</code> 读取服务器上的文件。</li>
<li>使用 <code>response.getOutputStream()</code> 获取字节输出流。</li>
<li>将文件内容从输入流循环读取并写入到输出流。</li>
</ul>
</li>
<li><strong>关闭资源：</strong> 确保输入输出流被正确关闭。</li>
</ol>
<p><strong>Servlet 示例 (<code>DownloadServlet.java</code>):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DownloadServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取要下载的文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;filename&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fileName == <span class="literal">null</span> || fileName.trim().isEmpty()) &#123;</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;Please specify a filename.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设文件都存储在 /WEB-INF/files/ 目录下，这是一个安全的目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;/WEB-INF/files/&quot;</span> + fileName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取文件的真实路径和 ServletContext</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> context.getRealPath(filePath);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 设置响应头</span></span><br><span class="line">        <span class="comment">// 3.1 获取文件MIME类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mimeType</span> <span class="operator">=</span> context.getMimeType(fileName);</span><br><span class="line">        <span class="keyword">if</span> (mimeType == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 无法识别类型时，使用通用二进制流</span></span><br><span class="line">            mimeType = <span class="string">&quot;application/octet-stream&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        response.setContentType(mimeType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2 设置 Content-Disposition，解决中文文件名乱码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encodedFileName</span> <span class="operator">=</span> URLEncoder.encode(fileName, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=\&quot;&quot;</span> + encodedFileName + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 读取文件并写入响应</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath);</span><br><span class="line">             <span class="type">ServletOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> response.getOutputStream()) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            <span class="type">int</span> bytesRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 如果文件不存在或读取错误</span></span><br><span class="line">            response.setStatus(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;File not found or unable to read.&quot;</span>);</span><br><span class="line">            System.err.println(<span class="string">&quot;Error downloading file: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-异步-Servlet-Servlet-3-0"><a href="#3-异步-Servlet-Servlet-3-0" class="headerlink" title="3. 异步 Servlet (Servlet 3.0+)"></a>3. 异步 Servlet (Servlet 3.0+)</h2><h3 id="3-1-解决的问题"><a href="#3-1-解决的问题" class="headerlink" title="3.1 解决的问题"></a>3.1 解决的问题</h3><p>传统的（同步）Servlet 模型是**“一个请求，一个线程，直到响应完成”**。当一个请求到达时，Servlet 容器会从其线程池中分配一个线程来处理这个请求。这个线程会全程负责执行 Servlet 的 <code>service</code> 方法，直到响应数据完全写入并发送给客户端后，该线程才会被释放并返回到线程池。</p>
<p><strong>核心问题在于：</strong> 如果 Servlet 的业务逻辑中包含<strong>耗时的、阻塞式I&#x2F;O操作</strong>（例如：调用一个缓慢的远程 Web Service、执行一个复杂的数据库查询、等待消息队列的返回），那么这个<strong>请求处理线程就会被长时间阻塞</strong>，空闲地等待，而不能去做其他任何事情。</p>
<p>当大量这样的慢请求并发到达时，容器的线程池会迅速被耗尽。所有线程都被阻塞在等待 I&#x2F;O 上，导致服务器无法再接受和处理新的请求，从而造成<strong>服务吞吐量急剧下降</strong>，甚至<strong>应用崩溃</strong>。这就是所谓的**“线程饥饿 (Thread Starvation)”**。</p>
<p><strong>异步 Servlet 的目的就是为了解决这个问题。</strong></p>
<p>它的核心思想是：<strong>将请求处理线程与耗时的业务逻辑解耦</strong>。当一个耗时操作开始时，Servlet 可以<strong>立即释放</strong>容器的请求处理线程，让它返回线程池去服务其他请求。同时，将耗时任务交给一个<strong>后台的、独立的线程池</strong>去执行。当后台任务完成后，再通过一个回调机制，将结果写回给客户端的响应流。</p>
<p><strong>一句话总结：异步 Servlet 并非让单个慢操作变快，而是通过释放关键的请求处理线程，让服务器在等待慢操作时能处理更多其他请求，从而极大地提高了应用的伸缩性 (Scalability) 和吞吐量 (Throughput)。</strong></p>
<hr>
<h3 id="3-2-核心-API"><a href="#3-2-核心-API" class="headerlink" title="3.2 核心 API"></a>3.2 核心 API</h3><p>实现异步 Servlet 主要涉及以下几个关键 API：</p>
<ol>
<li><strong>开启异步支持:</strong><ul>
<li>必须在 Servlet 配置中明确声明支持异步。</li>
<li><strong>注解方式：</strong> <code>@WebServlet(urlPatterns = &quot;/async&quot;, asyncSupported = true)</code></li>
<li><strong><code>web.xml</code> 方式：</strong> 在 <code>&lt;servlet&gt;</code> 标签中添加 <code>&lt;async-supported&gt;true&lt;/async-supported&gt;</code></li>
</ul>
</li>
<li><strong><code>request.startAsync()</code>:</strong><ul>
<li>这是启动异步处理的入口点。在 <code>doGet</code>&#x2F;<code>doPost</code> 等方法中调用它。</li>
<li>调用后，请求将进入异步模式，原始的 <code>request</code> 和 <code>response</code> 对象会被封装起来。</li>
<li>它返回一个 <code>AsyncContext</code> 对象，这是后续所有异步操作的核心。</li>
<li>一旦调用此方法，容器的请求处理线程就可以结束其 <code>service</code> 方法并被释放了。</li>
</ul>
</li>
<li><strong><code>AsyncContext</code> 对象:</strong><ul>
<li>这是异步处理的上下文环境，持有对原始请求和响应的引用。</li>
<li><strong><code>getRequest()</code> &#x2F; <code>getResponse()</code>:</strong> 从后台线程中获取原始的 <code>request</code> 和 <code>response</code> 对象。</li>
<li><strong><code>start(Runnable run)</code>:</strong> 一个便捷方法，可以将一个 <code>Runnable</code> 任务提交给容器管理的线程池去执行。</li>
<li><strong><code>dispatch(String path)</code>:</strong> 在异步任务完成后，可以将请求<strong>派发</strong>给另一个 Servlet 或 JSP 来完成最终的响应渲染。</li>
<li><strong><code>complete()</code>: (最重要)</strong> 当异步任务处理完成，并且响应数据已经写入完毕时，<strong>必须调用此方法</strong>。它会通知容器，该异步过程已结束，可以关闭连接并将响应发送给客户端。</li>
<li><strong><code>setTimeout(long timeout)</code>:</strong> 设置异步操作的超时时间（毫秒）。如果超时，会触发 <code>AsyncListener</code> 的 <code>onTimeout</code> 事件。</li>
<li><strong><code>addListener(AsyncListener listener)</code>:</strong> 添加一个异步监听器来处理超时、错误、完成等事件。</li>
</ul>
</li>
</ol>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/async&quot;, asyncSupported = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用一个独立的线程池来处理耗时任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        response.setContentType(<span class="string">&quot;text/plain;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        out.println(<span class="string">&quot;主线程: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 开始处理请求。&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 启动异步上下文</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">AsyncContext</span> <span class="variable">asyncContext</span> <span class="operator">=</span> request.startAsync();</span><br><span class="line">        <span class="comment">// 设置超时时间 (例如 10 秒)</span></span><br><span class="line">        asyncContext.setTimeout(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将耗时任务提交到后台线程池</span></span><br><span class="line">        executor.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟一个耗时的I/O操作</span></span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从 AsyncContext 获取响应对象</span></span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">asyncOut</span> <span class="operator">=</span> asyncContext.getResponse().getWriter();</span><br><span class="line">                asyncOut.println(<span class="string">&quot;后台线程: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 完成了耗时任务。&quot;</span>);</span><br><span class="line">                asyncOut.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 任务完成，必须调用 complete()</span></span><br><span class="line">                asyncContext.complete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        out.println(<span class="string">&quot;主线程: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 已释放，可以去处理其他请求了。&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-应用场景"><a href="#3-3-应用场景" class="headerlink" title="3.3 应用场景"></a>3.3 应用场景</h3><p>异步 Servlet 主要适用于<strong>I&#x2F;O密集型</strong>而非 CPU 密集型的场景。</p>
<ul>
<li><strong>调用外部 Web Service 或微服务:</strong><br>当你的应用需要调用另一个系统的 REST API 或 SOAP 服务，而对方响应较慢时，这是异步 Servlet 的完美应用场景。</li>
<li><strong>复杂的数据库操作或报表生成:</strong><br>执行需要长时间运行的数据库查询、数据聚合或生成大型报表时，可以使用异步处理，避免阻塞 Web 服务器。</li>
<li><strong>消息队列 (Message Queue) 的发布&#x2F;订阅:</strong><br>向消息中间件（如 RabbitMQ, Kafka）发送消息后，需要等待一个异步的回调或从另一个队列接收响应。</li>
<li><strong>实现长轮询 (Long Polling &#x2F; Comet):</strong><br>这是构建实时 Web 应用（如在线聊天、股票行情推送、实时通知）的一种技术。客户端发起一个请求，服务器端如果没有新数据，就<strong>挂起</strong>这个连接（通过启动异步上下文并释放线程），直到有新数据到达时，才通过 <code>AsyncContext</code> 将数据写回并 <code>complete()</code> 响应。这可以极大地节省服务器资源，是 WebSocket 出现之前的主流实时技术。</li>
<li><strong>作为API网关或代理:</strong><br>一个 Servlet 需要从多个后端服务拉取数据，然后聚合成一个响应返回。它可以异步地并行调用这些后端服务，从而缩短整体响应时间。</li>
</ul>
<hr>
<h2 id="4-Servlet-规范演进"><a href="#4-Servlet-规范演进" class="headerlink" title="4. Servlet 规范演进"></a>4. Servlet 规范演进</h2><h3 id="4-1-从-javax-servlet-Java-EE-到-jakarta-servlet-Jakarta-EE-的变迁"><a href="#4-1-从-javax-servlet-Java-EE-到-jakarta-servlet-Jakarta-EE-的变迁" class="headerlink" title="4.1 从 javax.servlet.* (Java EE) 到 jakarta.servlet.* (Jakarta EE) 的变迁"></a>4.1 从 <code>javax.servlet.*</code> (Java EE) 到 <code>jakarta.servlet.*</code> (Jakarta EE) 的变迁</h3><p>这是一个对 Java 生态系统产生深远影响的重大变化，主要是由于<strong>项目所有权的变更</strong>。</p>
<p><strong>背景：</strong></p>
<ul>
<li><strong>Java EE (Java Platform, Enterprise Edition)</strong> 最初由 Sun Microsystems 开发，后来由 <strong>Oracle</strong> 掌管。所有相关的 API 都位于 <code>javax.*</code> 包名下（<code>x</code> 代表 “extension”）。</li>
<li>2017年，Oracle 决定将 Java EE 移交给一个开源组织——<strong>Eclipse 基金会 (Eclipse Foundation)</strong> 来管理，以促进其更快的发展和社区参与。</li>
<li>项目被重新命名为 <strong>Jakarta EE</strong>。</li>
<li>由于 Oracle 拥有 <code>javax</code> 的商标权，Eclipse 基金会不能在新的 Jakarta EE 规范中继续使用这个包名来发布新版本。</li>
</ul>
<p><strong>核心变化：</strong></p>
<p>为了解决商标问题，Jakarta EE 社区决定进行一次“大爆炸”式的变更：从 <strong>Jakarta EE 9</strong> 版本开始，所有 API 的顶级包名从 <code>javax</code> 更改为 <code>jakarta</code>。</p>
<p>这对 Servlet API 意味着：</p>
<ul>
<li><p><strong>旧版本 (Servlet 4.0 及更早, 属于 Java EE 8 及更早):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>新版本 (Servlet 5.0 及更高, 属于 Jakarta EE 9 及更高):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>对开发者的影响：</strong></p>
<p>这是一个<strong>破坏性变更</strong>。当项目从基于 Java EE 8 的服务器（如 Tomcat 9）迁移到基于 Jakarta EE 9+ 的服务器（如 Tomcat 10+）时，开发者必须：</p>
<ol>
<li><strong>更新代码</strong>中的所有 <code>import</code> 语句。</li>
<li><strong>更新项目构建工具</strong>（如 Maven, Gradle）中的依赖坐标，从 <code>javax.servlet:javax.servlet-api</code> 更改为 <code>jakarta.servlet:jakarta.servlet-api</code>。</li>
</ol>
<hr>
<h2 id="5-与Spring的关系"><a href="#5-与Spring的关系" class="headerlink" title="5. 与Spring的关系"></a>5. 与Spring的关系</h2><p>现代 Spring Boot 与 Servlet 的合作模式可以总结为：<strong>Spring Boot 在 Servlet API 的基础上，构建了一个高度自动化、约定优于配置的开发框架。它为你管理了所有繁琐的底层 Servlet 配置，让你能专注于业务逻辑。</strong></p>
<h3 id="5-1-容器的自动化管理-The-Car-Factory"><a href="#5-1-容器的自动化管理-The-Car-Factory" class="headerlink" title="5.1 容器的自动化管理 (The Car Factory)"></a>5.1 容器的自动化管理 (The Car Factory)</h3><p><strong>传统方式:</strong></p>
<p>在没有 Spring Boot 的时代，你需要：</p>
<ol>
<li>编写一个 <code>Servlet</code> 类。</li>
<li>在 <code>web.xml</code> 文件中手动配置这个 <code>Servlet</code>，包括它的类路径、URL 映射 (<code>&lt;servlet-mapping&gt;</code>)、加载顺序 (<code>&lt;load-on-startup&gt;</code>) 等。</li>
<li>将你的应用打包成一个 <code>.war</code> 文件。</li>
<li>手动将这个 <code>.war</code> 文件部署到一个外部的 Servlet 容器（如 Tomcat, Jetty）中。</li>
</ol>
<p><strong>Spring Boot 方式 :</strong></p>
<p>Spring Boot 彻底改变了这一点：</p>
<ul>
<li><strong>内嵌 Servlet 容器</strong>：你不再需要外部的 Tomcat。当你引入 <code>spring-boot-starter-web</code> 依赖时，Spring Boot 会默认将 Tomcat（或 Jetty&#x2F;Undertow）作为<strong>一个库</strong>直接嵌入到你的应用中。</li>
<li><strong>启动即运行</strong>：运行 <code>main</code> 方法时，Spring Boot 会自动启动这个内嵌的 Tomcat 服务器，并把你的应用部署进去。没有了 <code>.war</code> 包和外部部署的繁琐步骤，开发和部署变得极其简单。</li>
</ul>
<hr>
<h3 id="5-2-请求的核心分发者：DispatcherServlet"><a href="#5-2-请求的核心分发者：DispatcherServlet" class="headerlink" title="5.2 请求的核心分发者：DispatcherServlet"></a>5.2 请求的核心分发者：<code>DispatcherServlet</code></h3><p>这是 Spring 与 Servlet 合作的<strong>最核心</strong>的组件。</p>
<p><strong>传统方式：</strong></p>
<p>你可能会为不同的功能编写多个 <code>Servlet</code>，比如 <code>LoginServlet</code>, <code>OrderServlet</code> 等，并在 <code>web.xml</code> 中为它们分别配置不同的 URL 映射。</p>
<p><strong>Spring Boot &#x2F; Spring MVC 方式：</strong></p>
<p>Spring Boot 遵循了 Spring MVC 的“前端控制器模式”（Front Controller Pattern）。它会自动为你注册一个<strong>唯一且核心</strong>的 Servlet，叫做 <code>DispatcherServlet</code>。</p>
<p>这个 <code>DispatcherServlet</code> 扮演着“交通总指挥”的角色：</p>
<ol>
<li><strong>接管所有请求</strong>：默认情况下，<code>DispatcherServlet</code> 会注册到应用的根路径 (<code>/</code>)，意味着几乎所有的 Web 请求都会先到达它这里。</li>
<li><strong>智能路由</strong>：<code>DispatcherServlet</code> 接收到请求后，不会自己处理业务逻辑。它会查询内部的 <strong><code>HandlerMapping</code></strong>（处理器映射），根据请求的 URL、HTTP 方法等信息，找到应该由哪个 <code>@Controller</code> 里的哪个方法来处理。</li>
<li><strong>分发执行</strong>：找到对应的处理方法（比如一个被 <code>@GetMapping(&quot;/users/{id}&quot;)</code> 注解的方法）后，<code>DispatcherServlet</code> 会调用它，并将处理结果（模型和视图，或 JSON 数据）返回给客户端。</li>
</ol>
<hr>
<h3 id="5-3-一个典型请求的生命周期"><a href="#5-3-一个典型请求的生命周期" class="headerlink" title="5.3 一个典型请求的生命周期"></a>5.3 一个典型请求的生命周期</h3><p>让我们看看一个请求在 Spring Boot 应用中是如何流转的：</p>
<pre><code class="highlight mermaid">sequenceDiagram
    title Spring Boot 请求处理流程

    participant Client as 客户端
    participant Tomcat as 内嵌 Tomcat
    participant FilterChain as Servlet 过滤器链
    participant DS as DispatcherServlet
    participant HM as HandlerMapping
    participant Controller as UserController
    participant HMC as HttpMessageConverter

    %% 1. 客户端发起请求
    Client-&gt;&gt;Tomcat: 1. 发送 HTTP 请求 (GET /api/users/123)

    %% 2 &amp; 3. Tomcat 接收并传递给过滤器链
    Tomcat-&gt;&gt;FilterChain: 2 &amp; 3. 传递请求给过滤器链
    note over FilterChain: 执行如 CharacterEncodingFilter, SecurityFilter 等

    %% 4. 请求到达 DispatcherServlet
    FilterChain-&gt;&gt;DS: 4. 请求穿过过滤器，到达 DispatcherServlet

    %% 5 &amp; 6. DispatcherServlet 查询并找到 Handler
    DS-&gt;&gt;HM: 5. 查询 HandlerMapping
    HM--&gt;&gt;DS: 6. 找到匹配的 Handler (UserController.getUserById)

    %% 7. DispatcherServlet 调用 Controller 方法
    DS-&gt;&gt;Controller: 7. 调用 getUserById(123)

    %% 8. Controller 处理并返回数据对象
    activate Controller
    note over Controller: 执行业务逻辑 (如查询数据库)
    Controller--&gt;&gt;DS: 8. 返回 User 对象
    deactivate Controller

    %% 9. DispatcherServlet 序列化对象
    DS-&gt;&gt;HMC: 9. 请求 HttpMessageConverter (Jackson) 序列化
    HMC--&gt;&gt;DS: 返回 JSON 字符串: &#123;&quot;id&quot;:123, &quot;name&quot;:&quot;...&quot;&#125;

    %% 10 &amp; 11. 响应反向穿过过滤器链
    DS-&gt;&gt;FilterChain: 10 &amp; 11. 将 JSON 响应反向传递给过滤器链
    note over FilterChain: 过滤器可对响应进行处理

    %% 12. Tomcat 将最终响应发送回客户端
    FilterChain-&gt;&gt;Tomcat: 响应穿过过滤器
    Tomcat--&gt;&gt;Client: 12. 返回最终 HTTP 响应 (200 OK + JSON Body)</code></pre>



<ol>
<li><strong>客户端</strong> 发送一个 HTTP 请求，例如 <code>GET /api/users/123</code>。</li>
<li><strong>内嵌的 Servlet 容器 (Tomcat)</strong> 接收到这个网络请求。</li>
<li>Tomcat 将请求传递给 Spring Boot 自动配置的 <strong>Servlet 过滤器链 (Filter Chain)</strong>，例如处理字符编码的 <code>CharacterEncodingFilter</code>、处理安全的 Spring Security 过滤器等。</li>
<li>请求穿过过滤器链，最终到达核心的 <strong><code>DispatcherServlet</code></strong>。</li>
<li><code>DispatcherServlet</code> 根据 <code>/api/users/123</code> 这个路径，查询 <code>HandlerMapping</code>。</li>
<li><code>HandlerMapping</code> 匹配到你编写的 <code>UserController</code> 中的 <code>getUserById(@PathVariable Long id)</code> 方法。</li>
<li><code>DispatcherServlet</code> 调用 <code>UserController</code> 的方法，并将路径中的 <code>123</code> 作为参数传入。</li>
<li>你的方法执行业务逻辑，返回一个 <code>User</code> 对象。</li>
<li>由于你的 <code>UserController</code> 通常被 <code>@RestController</code> 注解，<code>DispatcherServlet</code> 会通过 <strong><code>HttpMessageConverter</code></strong> (如 Jackson) 将 <code>User</code> 对象序列化成 JSON 字符串。</li>
<li><code>DispatcherServlet</code> 将 JSON 数据包装成一个 <code>HttpServletResponse</code>。</li>
<li>这个 Response 再反向穿过过滤器链。</li>
<li><strong>Tomcat</strong> 将最终的 HTTP 响应发送回客户端。</li>
</ol>
<p>在这个过程中，Servlet API（如 <code>HttpServletRequest</code>, <code>HttpServletResponse</code>, <code>Filter</code>）是这一切的<strong>底层基础</strong>，而 Spring Boot 和 Spring MVC 在其上构建了<strong>高层抽象</strong>（<code>@Controller</code>, <code>@GetMapping</code>, <code>@RequestBody</code> 等）。</p>
<hr>
<h3 id="5-4-直接与-Servlet-API-交互"><a href="#5-4-直接与-Servlet-API-交互" class="headerlink" title="5.4 直接与 Servlet API 交互"></a>5.4 直接与 Servlet API 交互</h3><p>虽然 Spring Boot 自动化了绝大部分工作，但它<strong>从未阻止</strong>你使用原生的 Servlet API。当你需要进行一些非常底层的、自定义的操作时，Spring Boot 提供了优雅的方式来实现。</p>
<h4 id="方式一：在-Controller-方法中直接注入"><a href="#方式一：在-Controller-方法中直接注入" class="headerlink" title="方式一：在 Controller 方法中直接注入"></a>方式一：在 Controller 方法中直接注入</h4><p>你可以直接在你的 Controller 方法参数中声明 <code>HttpServletRequest</code> 或 <code>HttpServletResponse</code>，Spring 会自动将它们注入进来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/some/path&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userAgent</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;User-Agent&quot;</span>);</span><br><span class="line">        <span class="comment">// 手动操作 response</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;User-Agent is: &quot;</span> + userAgent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="方式二：注册自定义的-Filter-Servlet-Listener"><a href="#方式二：注册自定义的-Filter-Servlet-Listener" class="headerlink" title="方式二：注册自定义的 Filter, Servlet, Listener"></a>方式二：注册自定义的 <code>Filter</code>, <code>Servlet</code>, <code>Listener</code></h4><p>如果你想添加自定义的过滤器，不需要 <code>web.xml</code>，只需要将它们声明为 Spring 的 <code>@Bean</code> 即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册一个自定义的 Filter</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean&lt;MyCustomFilter&gt; <span class="title function_">customFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        FilterRegistrationBean&lt;MyCustomFilter&gt; registrationBean = <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        registrationBean.setFilter(<span class="keyword">new</span> <span class="title class_">MyCustomFilter</span>());</span><br><span class="line">        registrationBean.addUrlPatterns(<span class="string">&quot;/api/*&quot;</span>); <span class="comment">// 只对 /api/* 路径下的请求生效</span></span><br><span class="line">        registrationBean.setOrder(<span class="number">1</span>); <span class="comment">// 设置过滤器的顺序</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的 Filter 实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCustomFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> </span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Request processing started...&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        chain.doFilter(request, response); <span class="comment">// 让请求继续向下传递</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">        System.out.println(<span class="string">&quot;Request processing finished in &quot;</span> + duration + <span class="string">&quot;ms.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的方式也适用于注册自定义的 <code>Servlet</code> (<code>ServletRegistrationBean</code>) 和 <code>Listener</code> (<code>ServletListenerRegistrationBean</code>)。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/10/06/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringSecurity/" rel="prev" title="Spring全家桶-SpringSecurity">
                  <i class="fa fa-angle-left"></i> Spring全家桶-SpringSecurity
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/10/17/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95%E4%B8%8E%E9%9B%86%E6%88%90/" rel="next" title="Spring全家桶-功能扩展与集成">
                  Spring全家桶-功能扩展与集成 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
