<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="一、Servlet 基础与核心概念1. Servlet 概述1.1 核心定义Servlet（Server Applet）是 Java EE &#x2F; Jakarta EE 规范中的核心技术之一，是一种运行在服务器端的 Java Web 组件。它由 Servlet 容器（如 Tomcat、Jetty）管理，旨在通过请求-响应（Request-Response）模型与 Web 客户端进行交互。 本">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaServlet">
<meta property="og:url" content="http://example.com/2025/10/09/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/JavaServlet/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="一、Servlet 基础与核心概念1. Servlet 概述1.1 核心定义Servlet（Server Applet）是 Java EE &#x2F; Jakarta EE 规范中的核心技术之一，是一种运行在服务器端的 Java Web 组件。它由 Servlet 容器（如 Tomcat、Jetty）管理，旨在通过请求-响应（Request-Response）模型与 Web 客户端进行交互。 本">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-09T13:21:19.000Z">
<meta property="article:modified_time" content="2025-12-29T12:02:15.198Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/10/09/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/JavaServlet/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/10/09/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/JavaServlet/","path":"2025/10/09/Web协议服务器/JavaServlet/","title":"JavaServlet"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JavaServlet | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81Servlet-%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">一、Servlet 基础与核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Servlet-%E6%A6%82%E8%BF%B0"><span class="nav-text">1. Servlet 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%B9%89"><span class="nav-text">1.1 核心定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%A0%B8%E5%BF%83%E7%89%B9%E5%BE%81"><span class="nav-text">1.2 核心特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3%E4%B8%8E%E5%8A%9F%E8%83%BD"><span class="nav-text">1.3 核心职责与功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-%E8%AF%B7%E6%B1%82%E8%A7%A3%E6%9E%90-Request-Parsing"><span class="nav-text">1.3.1 请求解析 (Request Parsing)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E8%B0%83%E5%BA%A6-Business-Logic-Dispatching"><span class="nav-text">1.3.2 业务逻辑调度 (Business Logic Dispatching)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3-%E5%8A%A8%E6%80%81%E5%93%8D%E5%BA%94%E7%94%9F%E6%88%90-Dynamic-Response-Generation"><span class="nav-text">1.3.3 动态响应生成 (Dynamic Response Generation)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-4-%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-State-Management"><span class="nav-text">1.3.4 会话状态管理 (State Management)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-5-MVC-%E6%9E%B6%E6%9E%84%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E5%99%A8-Controller-Role"><span class="nav-text">1.3.5 MVC 架构中的控制器 (Controller Role)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B%EF%BC%9AServlet-%E4%B8%8E-CGI-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-text">1.4 技术演进：Servlet 与 CGI 的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-Servlet-%E5%AE%B9%E5%99%A8%EF%BC%88Web-%E5%AE%B9%E5%99%A8%EF%BC%89"><span class="nav-text">1.5 Servlet 容器（Web 容器）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3"><span class="nav-text">1.5.1 核心职责</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86-Lifecycle-Management"><span class="nav-text">1. 生命周期管理 (Lifecycle Management):</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%8E%E5%8D%8F%E8%AE%AE%E6%8A%BD%E8%B1%A1-Network-Protocol-Abstraction"><span class="nav-text">2. 网络通信与协议抽象 (Network &amp; Protocol Abstraction):</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%AF%B9%E8%B1%A1%E5%B0%81%E8%A3%85-Object-Encapsulation"><span class="nav-text">3. 对象封装 (Object Encapsulation):</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%B9%B6%E5%8F%91%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86-Concurrency-Thread-Management"><span class="nav-text">4. 并发与线程管理 (Concurrency &amp; Thread Management):</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E8%A7%84%E8%8C%83%E6%94%AF%E6%8C%81%E4%B8%8E%E7%94%9F%E6%80%81%E9%9B%86%E6%88%90-Specification-Support"><span class="nav-text">5. 规范支持与生态集成 (Specification Support)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-2-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="nav-text">1.5.2 请求处理工作流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-3-%E4%B8%BB%E6%B5%81-Servlet-%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB"><span class="nav-text">1.5.3 主流 Servlet 容器分类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Servlet-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">2. Servlet 生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-text">2.1 加载与实例化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6"><span class="nav-text">2.1.1 核心机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E5%8A%A0%E8%BD%BD%E7%AD%96%E7%95%A5-Loading-Strategies"><span class="nav-text">2.1.2 加载策略 (Loading Strategies)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">2.2 初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E6%A0%B8%E5%BF%83%E7%89%B9%E5%BE%81%E4%B8%8E%E8%81%8C%E8%B4%A3"><span class="nav-text">2.2.1 核心特征与职责</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">2.2.2 接口定义与设计模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E9%85%8D%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9AServletConfig"><span class="nav-text">2.2.3 配置对象：ServletConfig</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-%E5%AE%9E%E6%88%98%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%8F%82%E6%95%B0%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="nav-text">2.2.4 实战示例：参数化配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"><span class="nav-text">2.3 处理请求</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B"><span class="nav-text">2.3.1 执行模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E4%B8%8E%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="nav-text">2.3.2 核心方法与分发机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-Concurrency-Thread-Safety"><span class="nav-text">2.3.3 并发控制与线程安全 (Concurrency &amp; Thread Safety)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%A3%8E%E9%99%A9%E6%A0%B9%E6%BA%90%EF%BC%9AJVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM"><span class="nav-text">1. 风险根源：JVM 内存模型 (JMM)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">2. 线程安全最佳实践</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%8F%8D%E9%9D%A2%E6%95%99%E6%9D%90%E4%B8%8E%E4%BF%AE%E6%AD%A3%E7%A4%BA%E4%BE%8B"><span class="nav-text">3. 反面教材与修正示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E9%94%80%E6%AF%81"><span class="nav-text">2.4 销毁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-%E6%A0%B8%E5%BF%83%E7%89%B9%E5%BE%81%E4%B8%8E%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91"><span class="nav-text">2.4.1 核心特征与执行逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-%E4%B8%BB%E8%A6%81%E8%81%8C%E8%B4%A3%EF%BC%9A%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE-Resource-Deallocation"><span class="nav-text">2.4.2 主要职责：资源释放 (Resource Deallocation)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-%E8%A7%A6%E5%8F%91%E5%9C%BA%E6%99%AF"><span class="nav-text">2.4.3 触发场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-4-%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%BA%A6%E6%9D%9F-Reliability-Constraints"><span class="nav-text">2.4.4 可靠性约束 (Reliability Constraints)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-5-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E9%97%AD%E7%8E%AF"><span class="nav-text">2.4.5 代码示例：资源管理闭环</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%85%A8%E6%99%AF%E5%9B%BE"><span class="nav-text">2.5 生命周期全景图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Servlet-%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="nav-text">3. Servlet 继承体系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%A0%B9%E6%8E%A5%E5%8F%A3%EF%BC%9Ajavax-servlet-Servlet"><span class="nav-text">3.1 根接口：javax.servlet.Servlet</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3"><span class="nav-text">3.1.1 核心职责</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-text">3.1.2 接口方法详解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-%E7%9B%B4%E6%8E%A5%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-text">3.1.3 直接实现接口的局限性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E4%B8%AD%E9%97%B4%E5%B1%82%E6%8A%BD%E8%B1%A1%EF%BC%9AGenericServlet"><span class="nav-text">3.2 中间层抽象：GenericServlet</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%A0%B8%E5%BF%83%E8%B4%A1%E7%8C%AE"><span class="nav-text">3.2.1 架构设计与核心贡献</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E4%B8%BA%E4%BB%80%E4%B9%88-Web-%E5%BC%80%E5%8F%91%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%BB%A7%E6%89%BF%E5%AE%83%EF%BC%9F"><span class="nav-text">3.2.2 为什么 Web 开发不直接继承它？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%8D%8F%E8%AE%AE%E4%B8%93%E7%94%A8%E5%B1%82%EF%BC%9AHttpServlet"><span class="nav-text">3.3 协议专用层：HttpServlet</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E4%B8%8E%E8%AF%B7%E6%B1%82%E5%88%86%E5%8F%91"><span class="nav-text">3.3.1 核心设计：模板方法与请求分发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E5%BC%80%E5%8F%91%E8%8C%83%E5%BC%8F%EF%BC%9A%E5%8F%AA%E9%87%8D%E5%86%99-doXXX"><span class="nav-text">3.3.2 开发范式：只重写 doXXX</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-%E5%AE%9E%E6%88%98%E7%A4%BA%E4%BE%8B"><span class="nav-text">3.3.3 实战示例</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Servlet-%E6%A0%B8%E5%BF%83-API"><span class="nav-text">二、Servlet 核心 API</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-HttpServletRequest-%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1"><span class="nav-text">1. HttpServletRequest (请求对象)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BD%9C%E7%94%A8"><span class="nav-text">1.1 作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E8%A1%8C%E4%BF%A1%E6%81%AF"><span class="nav-text">1.2 获取请求行信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%BF%A1%E6%81%AF"><span class="nav-text">1.3 获取请求头信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="nav-text">1.4 获取请求参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E4%BD%9C%E4%B8%BA%E5%9F%9F%E5%AF%B9%E8%B1%A1"><span class="nav-text">1.5 作为域对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91-RequestDispatcher"><span class="nav-text">1.6 请求转发 (RequestDispatcher)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-HttpServletResponse-%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1"><span class="nav-text">2. HttpServletResponse (响应对象)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%BD%9C%E7%94%A8"><span class="nav-text">2.1 作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E8%A1%8C"><span class="nav-text">2.2 设置响应行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="nav-text">2.3 设置响应头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E4%BD%93"><span class="nav-text">2.4 设置响应体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%EF%BC%9A%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-text">2.5 页面跳转：重定向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91-forward-%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91-redirect-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">2.6 请求转发 (forward) 与重定向 (redirect) 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-text">使用场景总结：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86-State-Management"><span class="nav-text">三、会话管理 (State Management)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Cookie"><span class="nav-text">1. Cookie</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-Cookie-API"><span class="nav-text">1.1 Cookie API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Cookie-%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-text">1.2 Cookie 的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E4%BC%98%E7%BC%BA%E7%82%B9%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">1.3 优缺点及应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-%E4%BC%98%E7%82%B9"><span class="nav-text">1.3.1 优点:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-%E7%BC%BA%E7%82%B9"><span class="nav-text">1.3.2 缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">1.3.3 应用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Session-HttpSession"><span class="nav-text">2. Session (HttpSession)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Session-API"><span class="nav-text">2.1 Session API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Session-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">2.2 Session 的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Cookie-%E4%B8%8E-Session-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="nav-text">2.3 Cookie 与 Session 的区别与联系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81Servlet-%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="nav-text">四、Servlet 上下文与配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-ServletContext-%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-text">1. ServletContext (应用上下文)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%AE%9A%E4%B9%89"><span class="nav-text">1.1 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="nav-text">1.2 获取方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E4%BD%9C%E7%94%A8"><span class="nav-text">1.3 作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%89%E5%A4%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93"><span class="nav-text">2. 三大作用域对象总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-HttpServletRequest-request-scope"><span class="nav-text">2.1 HttpServletRequest (request scope)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-HttpSession-session-scope"><span class="nav-text">2.2 HttpSession (session scope)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-ServletContext-application-scope"><span class="nav-text">2.3 ServletContext (application scope)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Servlet-%E9%85%8D%E7%BD%AE"><span class="nav-text">3. Servlet 配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%EF%BC%9Aweb-xml-%E9%83%A8%E7%BD%B2%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-text">3.1 传统方式：web.xml (部署描述符)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E7%8E%B0%E4%BB%A3%E6%96%B9%E5%BC%8F%EF%BC%9A%E6%B3%A8%E8%A7%A3-Servlet-3-0"><span class="nav-text">3.2 现代方式：注解 (Servlet 3.0+)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8-Filter-%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8-Listener"><span class="nav-text">五、过滤器 (Filter) 与监听器 (Listener)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Filter-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-text">1. Filter (过滤器)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%AE%9A%E4%B9%89-1"><span class="nav-text">1.1 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Filter-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">1.2 Filter 生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-FilterChain-%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE"><span class="nav-text">1.3 FilterChain (过滤器链)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E9%85%8D%E7%BD%AE"><span class="nav-text">1.4 配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">1.5 典型应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Listener-%E7%9B%91%E5%90%AC%E5%99%A8"><span class="nav-text">2. Listener (监听器)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%AE%9A%E4%B9%89"><span class="nav-text">2.1 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%88%86%E7%B1%BB"><span class="nav-text">2.2 分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E7%9B%91%E5%90%AC%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84-Listener"><span class="nav-text">2.2.1 监听作用域对象生命周期的 Listener</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E7%9B%91%E5%90%AC%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%8F%98%E5%8C%96%E7%9A%84-Listener"><span class="nav-text">2.2.2 监听作用域对象属性变化的 Listener</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E7%9B%91%E5%90%AC-Session-%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81%E7%9A%84-Listener"><span class="nav-text">2.2.3 监听 Session 中对象状态的 Listener</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E9%85%8D%E7%BD%AE"><span class="nav-text">2.3 配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">2.4 典型应用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98%E4%B8%8E%E5%AE%9E%E8%B7%B5"><span class="nav-text">六、高级主题与实践</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Servlet-%E4%B8%8E-JSP-%E7%9A%84%E5%85%B3%E7%B3%BB-MVC-%E6%A8%A1%E5%BC%8F"><span class="nav-text">1. Servlet 与 JSP 的关系 (MVC 模式)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-JSP%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-text">1.1 JSP的本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-MVC-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">1.2 MVC 设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Servlet-%E4%B8%8E-JSP-%E5%9C%A8-MVC-%E4%B8%AD%E7%9A%84%E5%8D%8F%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-text">1.3 Servlet 与 JSP 在 MVC 中的协作流程：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD"><span class="nav-text">2. 文件上传与下载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="nav-text">2.1 文件上传</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E5%89%8D%E7%AB%AF%E5%87%86%E5%A4%87%EF%BC%9AHTML-%E8%A1%A8%E5%8D%95"><span class="nav-text">2.1.1 前端准备：HTML 表单</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E5%90%8E%E7%AB%AF%E5%A4%84%E7%90%86%EF%BC%9AServlet"><span class="nav-text">2.1.2 后端处理：Servlet</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD"><span class="nav-text">2.2 文件下载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="nav-text">2.2.1 实现步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%BC%82%E6%AD%A5-Servlet-Servlet-3-0"><span class="nav-text">3. 异步 Servlet (Servlet 3.0+)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">3.1 解决的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%A0%B8%E5%BF%83-API"><span class="nav-text">3.2 核心 API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="nav-text">代码示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">3.3 应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Servlet-%E8%A7%84%E8%8C%83%E6%BC%94%E8%BF%9B"><span class="nav-text">4. Servlet 规范演进</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E4%BB%8E-javax-servlet-Java-EE-%E5%88%B0-jakarta-servlet-Jakarta-EE-%E7%9A%84%E5%8F%98%E8%BF%81"><span class="nav-text">4.1 从 javax.servlet.* (Java EE) 到 jakarta.servlet.* (Jakarta EE) 的变迁</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/09/Web%E5%8D%8F%E8%AE%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/JavaServlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JavaServlet | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaServlet
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-09 21:21:19" itemprop="dateCreated datePublished" datetime="2025-10-09T21:21:19+08:00">2025-10-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-29 20:02:15" itemprop="dateModified" datetime="2025-12-29T20:02:15+08:00">2025-12-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Web%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">Web协议与服务器</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="一、Servlet-基础与核心概念"><a href="#一、Servlet-基础与核心概念" class="headerlink" title="一、Servlet 基础与核心概念"></a>一、Servlet 基础与核心概念</h1><h2 id="1-Servlet-概述"><a href="#1-Servlet-概述" class="headerlink" title="1. Servlet 概述"></a>1. Servlet 概述</h2><h3 id="1-1-核心定义"><a href="#1-1-核心定义" class="headerlink" title="1.1 核心定义"></a>1.1 核心定义</h3><p>Servlet（Server Applet）是 Java EE &#x2F; Jakarta EE 规范中的核心技术之一，是一种运行在服务器端的 <strong>Java Web 组件</strong>。它由 Servlet 容器（如 Tomcat、Jetty）管理，旨在通过<strong>请求-响应（Request-Response）模型</strong>与 Web 客户端进行交互。</p>
<p><strong>本质上</strong>，Servlet 是一个遵循特定接口规范（<code>javax.servlet.Servlet</code> 或 <code>jakarta.servlet.Servlet</code>）的 Java 类。它不直接由 JVM 独立运行，而是托管于 Servlet 容器中，由容器控制其全生命周期。</p>
<hr>
<h3 id="1-2-核心特征"><a href="#1-2-核心特征" class="headerlink" title="1.2 核心特征"></a>1.2 核心特征</h3><p>Servlet 具备以下关键技术特征：</p>
<ul>
<li><strong>平台无关性 (Platform Independence)</strong>：基于 Java 语言编写，具备“一次编写，到处运行”的跨平台能力。</li>
<li><strong>容器托管 (Container Managed)</strong>：Servlet 对象不由开发者手动实例化（<code>new</code>），而是由 Web 容器负责加载、初始化 (<code>init</code>)、调用 (<code>service</code>) 以及销毁 (<code>destroy</code>)。</li>
<li><strong>多线程模型 (Multithreading)</strong>：<strong>这是 Servlet 高性能的关键。</strong> 默认情况下，Servlet 容器仅创建一个 Servlet 实例，通过通过多线程机制（Thread Pool）并发处理多个客户端请求。</li>
<li><strong>标准规范 (Standardization)</strong>：Servlet 是构建 Java Web 应用的基石。诸如 Spring MVC 等高级框架，底层均基于 Servlet API 构建。</li>
</ul>
<hr>
<h3 id="1-3-核心职责与功能"><a href="#1-3-核心职责与功能" class="headerlink" title="1.3 核心职责与功能"></a>1.3 核心职责与功能</h3><p>Servlet 在 Web 架构中承担着<strong>请求处理器</strong>的角色，其主要职责涵盖以下五个维度：</p>
<h4 id="1-3-1-请求解析-Request-Parsing"><a href="#1-3-1-请求解析-Request-Parsing" class="headerlink" title="1.3.1 请求解析 (Request Parsing)"></a>1.3.1 请求解析 (Request Parsing)</h4><p>Servlet 通过 <code>ServletRequest</code> 对象接收并解析客户端发起的 HTTP 请求，包括：</p>
<ul>
<li><strong>数据获取</strong>：提取 URL 参数、表单提交数据 (<code>Form Data</code>) 以及请求体 (<code>Body</code>) 中的 JSON&#x2F;XML 数据。</li>
<li><strong>环境识别</strong>：读取 HTTP 请求头 (<code>Header</code>)，获取浏览器类型、编码格式、Token 认证信息等。</li>
</ul>
<h4 id="1-3-2-业务逻辑调度-Business-Logic-Dispatching"><a href="#1-3-2-业务逻辑调度-Business-Logic-Dispatching" class="headerlink" title="1.3.2 业务逻辑调度 (Business Logic Dispatching)"></a>1.3.2 业务逻辑调度 (Business Logic Dispatching)</h4><p>Servlet 不应直接包含复杂的业务代码，而是作为调度的入口：</p>
<ul>
<li>执行基础的输入验证。</li>
<li>调用后端的业务逻辑层（Service Layer）或数据访问层（DAO）。</li>
<li>集成第三方服务（如调用微服务接口、消息队列等）。</li>
</ul>
<h4 id="1-3-3-动态响应生成-Dynamic-Response-Generation"><a href="#1-3-3-动态响应生成-Dynamic-Response-Generation" class="headerlink" title="1.3.3 动态响应生成 (Dynamic Response Generation)"></a>1.3.3 动态响应生成 (Dynamic Response Generation)</h4><p>根据业务处理结果，Servlet 通过 <code>ServletResponse</code> 对象构建 HTTP 响应：</p>
<ul>
<li><strong>内容渲染</strong>：输出 HTML 页面、JSON 数据结构、XML 文档或二进制流（如文件下载、图片验证码）。</li>
<li><strong>状态控制</strong>：设置 HTTP 状态码（如 200 OK, 404 Not Found, 500 Error）。</li>
<li><strong>流控制</strong>：执行服务器端转发 (<code>Forward</code>) 或 客户端重定向 (<code>Redirect</code>)。</li>
</ul>
<h4 id="1-3-4-会话状态管理-State-Management"><a href="#1-3-4-会话状态管理-State-Management" class="headerlink" title="1.3.4 会话状态管理 (State Management)"></a>1.3.4 会话状态管理 (State Management)</h4><p>鉴于 HTTP 协议的无状态特性，Servlet 提供了机制来维护用户状态：</p>
<ul>
<li>利用 <code>HttpSession</code> 接口在多次请求间追踪用户会话（如登录状态维持）。</li>
<li>操作 <code>Cookie</code> 进行客户端数据的存储与读取。</li>
</ul>
<h4 id="1-3-5-MVC-架构中的控制器-Controller-Role"><a href="#1-3-5-MVC-架构中的控制器-Controller-Role" class="headerlink" title="1.3.5 MVC 架构中的控制器 (Controller Role)"></a>1.3.5 MVC 架构中的控制器 (Controller Role)</h4><p>在标准的 MVC (Model-View-Controller) 设计模式中，Servlet 充当 <strong>Controller（控制器）</strong> 的角色：</p>
<ul>
<li>接收用户请求（View 层的输入）。</li>
<li>调用模型（Model）处理数据。</li>
<li>选择合适的视图（View，如 JSP、Thymeleaf）进行展示。</li>
<li><em>注：在 Spring MVC 中，<code>DispatcherServlet</code> 即为这一角色的核心实现。</em></li>
</ul>
<hr>
<h3 id="1-4-技术演进：Servlet-与-CGI-的对比"><a href="#1-4-技术演进：Servlet-与-CGI-的对比" class="headerlink" title="1.4 技术演进：Servlet 与 CGI 的对比"></a>1.4 技术演进：Servlet 与 CGI 的对比</h3><p>Servlet 的诞生旨在解决早期 <strong>CGI (Common Gateway Interface)</strong> 技术在处理高并发场景下的架构缺陷。二者的核心差异在于<strong>进程模型</strong>与<strong>线程模型</strong>的区别。</p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">CGI (Common Gateway Interface)</th>
<th align="left">Servlet</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>并发模型</strong></td>
<td align="left"><strong>多进程模型 (Process-per-Request)</strong><br>服务器为每个 HTTP 请求 <code>fork</code> 一个新的操作系统进程。</td>
<td align="left"><strong>单实例多线程模型 (Thread-per-Request)</strong><br>Servlet 实例通常是单例的，容器通过线程池分配独立的线程来处理并发请求。</td>
</tr>
<tr>
<td align="left"><strong>系统开销</strong></td>
<td align="left"><strong>高 (High Overhead)</strong><br>进程的创建、销毁以及进程间上下文切换（Context Switch）消耗大量 CPU 和内存资源。</td>
<td align="left"><strong>低 (Lightweight)</strong><br>线程是轻量级的调度单元。Servlet 实例常驻内存，无需重复初始化，线程切换开销远低于进程。</td>
</tr>
<tr>
<td align="left"><strong>内存效率</strong></td>
<td align="left"><strong>低</strong><br>每个进程拥有独立的内存空间，难以共享资源，内存占用随请求量线性飙升。</td>
<td align="left"><strong>高</strong><br>所有请求线程共享 JVM 的堆内存和方法区，极大地提高了内存利用率。</td>
</tr>
<tr>
<td align="left"><strong>数据持久性</strong></td>
<td align="left"><strong>无状态 (Stateless)</strong><br>进程销毁后，其内部状态即丢失，无法直接在请求间保持状态。</td>
<td align="left"><strong>可控状态</strong><br>Servlet 实例生命周期长，可通过成员变量（需注意线程安全）或外部存储维护状态。</td>
</tr>
<tr>
<td align="left"><strong>扩展能力</strong></td>
<td align="left"><strong>受限</strong><br>受限于操作系统的最大进程数，难以应对高并发流量。</td>
<td align="left"><strong>强</strong><br>配合非阻塞 I&#x2F;O (NIO) 和线程池调优，可支撑成千上万的并发连接。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-5-Servlet-容器（Web-容器）"><a href="#1-5-Servlet-容器（Web-容器）" class="headerlink" title="1.5 Servlet 容器（Web 容器）"></a>1.5 Servlet 容器（Web 容器）</h3><p><strong>Servlet 容器</strong>，也常被称为 <strong>Web 容器</strong>，是 Servlet 的<strong>运行时环境</strong>。它负责管理 Servlet 组件的生命周期，提供网络服务，并实现 Servlet 规范定义的各种接口。</p>
<p><strong>本质上</strong>，Servlet 仅仅是实现了特定接口的 Java 类，无法独立执行。Servlet 容器充当了 Web 服务器与 Java 业务逻辑之间的<strong>宿主</strong>，实现了<strong>控制反转</strong>——即由容器控制程序的执行流程，而非由组件自身控制。</p>
<h4 id="1-5-1-核心职责"><a href="#1-5-1-核心职责" class="headerlink" title="1.5.1 核心职责"></a>1.5.1 核心职责</h4><h5 id="1-生命周期管理-Lifecycle-Management"><a href="#1-生命周期管理-Lifecycle-Management" class="headerlink" title="1. 生命周期管理 (Lifecycle Management):"></a>1. 生命周期管理 (Lifecycle Management):</h5><ul>
<li><strong>IoC 机制</strong>：容器全权负责 Servlet 类的加载 (<code>Loading</code>)、实例化 (<code>Instantiation</code>)、初始化 (<code>init</code>)、服务调用 (<code>service</code>) 以及最终的销毁 (<code>destroy</code>)。</li>
<li><strong>资源管控</strong>：容器决定何时创建实例、何时回收资源，开发者仅需编写业务逻辑，无需手动管理对象生命周期。</li>
</ul>
<hr>
<h5 id="2-网络通信与协议抽象-Network-Protocol-Abstraction"><a href="#2-网络通信与协议抽象-Network-Protocol-Abstraction" class="headerlink" title="2. 网络通信与协议抽象 (Network &amp; Protocol Abstraction):"></a>2. 网络通信与协议抽象 (Network &amp; Protocol Abstraction):</h5><ul>
<li><strong>通信端点</strong>：监听网络端口（如 TCP 8080），建立 socket 连接。</li>
<li><strong>协议解析</strong>：处理 HTTP&#x2F;HTTPS 协议的握手、报文读取和封装，屏蔽底层的 TCP&#x2F;IP 细节。</li>
</ul>
<hr>
<h5 id="3-对象封装-Object-Encapsulation"><a href="#3-对象封装-Object-Encapsulation" class="headerlink" title="3. 对象封装 (Object Encapsulation):"></a>3. 对象封装 (Object Encapsulation):</h5><ul>
<li><strong>请求封装</strong>：将原始的 HTTP 请求报文（文本&#x2F;二进制流）解析并封装为面向对象的 <code>HttpServletRequest</code>。</li>
<li><strong>响应构建</strong>：提供 <code>HttpServletResponse</code> 对象供 Servlet 写入数据，容器负责后续将对象转换为符合 HTTP 协议的响应报文发送给客户端。</li>
</ul>
<hr>
<h5 id="4-并发与线程管理-Concurrency-Thread-Management"><a href="#4-并发与线程管理-Concurrency-Thread-Management" class="headerlink" title="4. 并发与线程管理 (Concurrency &amp; Thread Management):"></a>4. 并发与线程管理 (Concurrency &amp; Thread Management):</h5><ul>
<li><strong>线程池机制</strong>：容器维护一个工作线程池 (Worker Thread Pool)。</li>
<li><strong>请求分配</strong>：当请求到达时，容器从池中借用一个空闲线程，执行 Servlet 的 <code>service()</code> 方法；请求结束后，线程归还线程池。这避免了频繁创建和销毁线程的开销。</li>
<li><strong>线程安全警示</strong>：由于是<strong>单实例多线程</strong>运行，开发者必须确保 Servlet 的实例变量（成员变量）是线程安全的，或者完全避免使用实例变量。</li>
</ul>
<hr>
<h5 id="5-规范支持与生态集成-Specification-Support"><a href="#5-规范支持与生态集成-Specification-Support" class="headerlink" title="5. 规范支持与生态集成 (Specification Support)"></a>5. <strong>规范支持与生态集成 (Specification Support)</strong></h5><ul>
<li>提供完整的 Jakarta EE &#x2F; Java EE Web Profile 支持，包括 JSP 引擎、Filter 链管理、Listener 事件监听、Session 会话管理以及安全认证机制。</li>
</ul>
<hr>
<h4 id="1-5-2-请求处理工作流"><a href="#1-5-2-请求处理工作流" class="headerlink" title="1.5.2 请求处理工作流"></a>1.5.2 请求处理工作流</h4><p>以下流程展示了容器如何调度 Servlet 处理一次 HTTP 请求：</p>
<pre><code class="highlight mermaid">sequenceDiagram
    participant Client as 客户端 (Browser)
    participant Container as Servlet 容器 (Engine)
    participant ThreadPool as 线程池 (Thread Pool)
    participant Servlet as Servlet 实例

    %% 1. 建立连接
    Client-&gt;&gt;Container: 1. 发送 HTTP 请求 (TCP Connect)

    activate Container
    %% 2. 路由映射
    Note over Container: 2. URL 路由映射 (Mapping)&lt;br/&gt;根据 web.xml 或 @WebServlet 查找目标 Servlet

    %% 3. 对象封装
    Note over Container: 3. 协议解析与对象封装&lt;br/&gt;创建 HttpServletRequest/Response

    %% 4. 线程调度
    Container-&gt;&gt;ThreadPool: 4. 申请工作线程
    activate ThreadPool
    ThreadPool--&gt;&gt;Container: 返回空闲线程 (Worker Thread)
    deactivate ThreadPool

    %% 5. 调用业务
    Container-&gt;&gt;Servlet: 5. 调用 service(req, resp)
    activate Servlet
    
    Note right of Servlet: 6. 业务逻辑执行&lt;br/&gt;读取 Request，写入 Response

    Servlet--&gt;&gt;Container: service() 返回
    deactivate Servlet

    %% 6. 资源回收与响应
    Container-&gt;&gt;ThreadPool: 7. 线程归还
    activate ThreadPool
    deactivate ThreadPool

    Note over Container: 8. 响应报文生成&lt;br/&gt;将 Response 对象转换为 HTTP 报文
    Container--&gt;&gt;Client: 9. 发送 HTTP 响应 (TCP Data)
    deactivate Container</code></pre>

<p><strong>关键步骤解析：</strong></p>
<ol>
<li><strong>路由映射 (URL Mapping)</strong>：容器根据请求 URL 匹配配置（XML 或注解），确定由哪一个 Servlet 类处理。</li>
<li><strong>线程分配 (Thread Allocation)</strong>：容器利用线程池实现并发处理，确保高吞吐量。</li>
<li><strong>业务执行 (Execution)</strong>：Servlet 的 <code>service()</code> 方法被调用，根据 HTTP Method (GET&#x2F;POST) 分发到 <code>doGet</code>&#x2F;<code>doPost</code> 等具体方法。</li>
</ol>
<hr>
<h4 id="1-5-3-主流-Servlet-容器分类"><a href="#1-5-3-主流-Servlet-容器分类" class="headerlink" title="1.5.3 主流 Servlet 容器分类"></a>1.5.3 主流 Servlet 容器分类</h4><p>在实际开发中，通常根据功能范围将容器分为两类：</p>
<ol>
<li><strong>Servlet 容器 &#x2F; Web 服务器 (Servlet Containers)</strong><ul>
<li><em>特点</em>：轻量级，专注于 Servlet&#x2F;JSP 规范，启动速度快。</li>
<li><em>代表</em>：<ul>
<li><strong>Apache Tomcat</strong>：市场占有率最高，Spring Boot 默认嵌入的容器，Servlet 规范的参考实现。</li>
<li><strong>Eclipse Jetty</strong>：以长连接和异步处理能力著称，常用于对 WebSocket 支持要求高的场景。</li>
</ul>
</li>
</ul>
</li>
<li><strong>应用服务器 (Application Servers)</strong><ul>
<li><em>特点</em>：重量级，支持完整的 Java EE &#x2F; Jakarta EE 规范（包含 EJB, JTA, JMS 等企业级功能）。</li>
<li><em>代表</em>：<ul>
<li><strong>WildFly</strong> (前身 JBoss)：Red Hat 推出的高性能应用服务器。</li>
<li><strong>GlassFish</strong> &#x2F; <strong>Payara</strong>：Jakarta EE 的参考实现。</li>
<li><strong>WebLogic</strong> (Oracle) &#x2F; <strong>WebSphere</strong> (IBM)：商用级应用服务器，用于大型传统企业架构。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-Servlet-生命周期"><a href="#2-Servlet-生命周期" class="headerlink" title="2. Servlet 生命周期"></a>2. Servlet 生命周期</h2><p>Servlet 的生命周期完全由 Servlet 容器（如 Tomcat）控制。容器负责 Servlet 的<strong>加载、实例化、初始化、服务调度以及销毁</strong>。</p>
<h3 id="2-1-加载与实例化"><a href="#2-1-加载与实例化" class="headerlink" title="2.1 加载与实例化"></a>2.1 加载与实例化</h3><p>此阶段是将 Servlet 类文件转化为内存中可运行对象的过程。容器通过 Java 的 <strong>类加载器 (ClassLoader)</strong> 加载 Servlet 类，并利用 <strong>反射机制 (Reflection)</strong> 创建实例。</p>
<h4 id="2-1-1-核心机制"><a href="#2-1-1-核心机制" class="headerlink" title="2.1.1 核心机制"></a>2.1.1 核心机制</h4><ol>
<li><strong>单实例模式 (Singleton Pattern)</strong><ul>
<li>对于同一个 Servlet 映射，容器在整个应用生命周期中<strong>仅创建一个实例</strong>。</li>
<li>该实例常驻内存，处理所有指向该 Servlet 的请求。</li>
<li><strong>推论</strong>：由于是单例，<code>service()</code> 方法会被多个线程并发调用，因此 Servlet <strong>不是线程安全的</strong>，开发时需避免使用非线程安全的实例变量。</li>
</ul>
</li>
<li><strong>反射构建 (Reflection Construction)</strong><ul>
<li>容器通过调用 <code>Class.newInstance()</code> 或相关反射 API 来创建对象。</li>
<li><strong>约束</strong>：自定义 Servlet 类<strong>必须提供公共的无参构造函数 (Public No-Arg Constructor)</strong>。如果开发者定义了带参构造函数而覆盖了默认构造函数，必须显式补全无参构造函数，否则容器会抛出 <code>InstantiationException</code>。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-1-2-加载策略-Loading-Strategies"><a href="#2-1-2-加载策略-Loading-Strategies" class="headerlink" title="2.1.2 加载策略 (Loading Strategies)"></a>2.1.2 加载策略 (Loading Strategies)</h4><p>Servlet 的加载时机取决于配置策略，主要分为<strong>延迟加载</strong>和<strong>预加载</strong>两种模式：</p>
<p><strong>1. 延迟加载 (Lazy Loading &#x2F; On-Demand)</strong></p>
<ul>
<li><strong>定义</strong>：这是 Servlet 容器的<strong>默认行为</strong>。容器启动时仅加载核心组件，只有当客户端<strong>第一次</strong>向该 Servlet 发起请求时，容器才触发加载和实例化流程。</li>
<li><strong>适用场景</strong>：非核心业务、访问频率较低的功能模块。</li>
<li><strong>优缺点分析</strong>：<ul>
<li><em>优势</em>：加快服务器启动速度，减少闲置资源的内存占用。</li>
<li><em>劣势</em>：首位访问的用户需等待 Servlet 初始化完成，存在“首个请求延迟 (First Request Latency)”现象。</li>
</ul>
</li>
</ul>
<p><strong>2. 预加载 (Eager Loading &#x2F; Pre-loading)</strong></p>
<ul>
<li><p><strong>定义</strong>：在 Web 应用启动阶段（Deployment Phase），容器即刻完成 Servlet 的加载与实例化。</p>
</li>
<li><p><strong>配置参数</strong>：<code>load-on-startup</code>。</p>
</li>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li>核心业务模块，要求对所有用户提供即时响应。</li>
<li>需要在应用启动时执行初始化任务的组件（如：加载全局配置文件、初始化数据库连接池、启动定时任务）。</li>
</ul>
</li>
<li><p><strong>配置实现</strong>：</p>
<ul>
<li><p><strong>方式 A：基于 XML 配置 (<code>web.xml</code>)</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 值为非负整数：0 或正整数表示启动时加载 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数值越小，优先级越高，越先被实例化 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方式 B：基于注解配置 (<code>@WebServlet</code>)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loadOnStartup 默认为 -1 (延迟加载)，设置为 &gt;=0 即开启预加载</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/init&quot;, loadOnStartup = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemInitServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>技术细节 (Technical Note):</strong></p>
<p><code>load-on-startup</code> 的值决定了实例化的顺序。</p>
<ul>
<li><strong>负数</strong>（或省略）：采用延迟加载。</li>
<li><strong>0 或 正整数</strong>：采用预加载。<strong>数值越小，优先级越高</strong>（例如，设置为 0 的 Servlet 会比设置为 1 的先实例化）。这对于解决 Servlet 之间的初始化依赖关系至关重要。</li>
</ul>
</blockquote>
<hr>
<h3 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h3><p>初始化是 Servlet 生命周期中至关重要的<strong>资源就绪阶段</strong>。在实例化完成后，容器会立即调用 Servlet 的 <code>init</code> 方法，标志着该 Servlet 正式进入服务状态。</p>
<h4 id="2-2-1-核心特征与职责"><a href="#2-2-1-核心特征与职责" class="headerlink" title="2.2.1 核心特征与职责"></a>2.2.1 核心特征与职责</h4><ul>
<li><strong>执行语义</strong>：初始化过程在 Servlet 的全生命周期中<strong>仅执行一次</strong>。</li>
<li><strong>状态转换</strong>：此方法执行成功前，Servlet 处于“不可用”状态；执行成功后，Servlet 转换为“就绪”状态，方可接受客户端请求。</li>
<li><strong>主要职责</strong>：<ul>
<li><strong>外部配置读取</strong>：加载业务特定的初始化参数（Init Parameters）。</li>
<li><strong>重资源构建</strong>：建立数据库连接池、加载机器学习模型、读取静态字典表等高开销资源。</li>
<li><strong>环境依赖检查</strong>：校验运行所需的系统属性或外部服务是否可用。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-2-接口定义与设计模式"><a href="#2-2-2-接口定义与设计模式" class="headerlink" title="2.2.2 接口定义与设计模式"></a>2.2.2 接口定义与设计模式</h4><p>在 <code>javax.servlet.Servlet</code> 接口及其实现类 <code>GenericServlet</code> 中，<code>init</code> 方法的设计体现了 <strong>模板方法模式 (Template Method Pattern)</strong> 的思想，提供了两种重写方式：</p>
<ol>
<li><strong><code>void init(ServletConfig config)</code> (接口定义)</strong><ul>
<li>这是生命周期的入口方法。容器直接调用此方法，并传入 <code>ServletConfig</code> 对象。</li>
<li><strong>注意</strong>：如果在自定义 Servlet 中重写此方法，<strong>必须显式调用 <code>super.init(config)</code></strong>。</li>
<li><em>原理</em>：父类 <code>GenericServlet</code> 在此方法中将 <code>config</code> 对象存储为成员变量。若不调用父类方法，后续调用 <code>getServletConfig()</code> 或 <code>getServletContext()</code> 将抛出 <code>NullPointerException</code>。</li>
</ul>
</li>
<li><strong><code>void init()</code> (便利方法)</strong><ul>
<li>这是 <code>GenericServlet</code> 提供的一个无参、空实现的便利方法。</li>
<li><code>GenericServlet</code> 的 <code>init(ServletConfig)</code> 实现中，在完成配置对象保存后，会自动调用这个无参的 <code>init()</code>。</li>
<li><strong>最佳实践</strong>：<strong>推荐重写此无参方法</strong>。这样既能确保 <code>ServletConfig</code> 被正确保存，又无需开发者手动处理 <code>super.init(config)</code> 的调用，代码更简洁安全。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-2-3-配置对象：ServletConfig"><a href="#2-2-3-配置对象：ServletConfig" class="headerlink" title="2.2.3 配置对象：ServletConfig"></a>2.2.3 配置对象：ServletConfig</h4><p><code>ServletConfig</code> 是一个<strong>域对象 (Scope Object)</strong>，它封装了当前 Servlet 实例的<strong>独有配置信息</strong>。</p>
<ul>
<li><strong>作用域 (Scope)</strong>：仅限于当前 Servlet 实例，不同 Servlet 之间的 Config 对象互不可见。</li>
<li><strong>核心 API</strong>：<ul>
<li><code>String getInitParameter(String name)</code>：获取特定的初始化参数值。</li>
<li><code>Enumeration&lt;String&gt; getInitParameterNames()</code>：获取所有参数名的枚举。</li>
<li><code>ServletContext getServletContext()</code>：获取全局的应用上下文对象（用于组件间通信）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-4-实战示例：参数化配置"><a href="#2-2-4-实战示例：参数化配置" class="headerlink" title="2.2.4 实战示例：参数化配置"></a>2.2.4 实战示例：参数化配置</h4><p>通过配置将硬编码（Hard-coding）移除，提升代码的可维护性。</p>
<p><strong>1. 部署描述符配置 (<code>web.xml</code>)</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>EmailServiceServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.example.core.EmailServiceServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 初始化参数：仅该 Servlet 可见 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>smtpServer<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>smtp.corporate.com<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>retryCount<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2. Servlet 实现代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailServiceServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String smtpServer;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> retryCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 推荐重写无参 init() 方法</span></span><br><span class="line"><span class="comment">     * 此时 super.init(config) 已被父类自动执行，可直接使用 getInitParameter()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 1. 获取配置信息 (Config Retrieval)</span></span><br><span class="line">        <span class="comment">// 父类 GenericServlet 实现了 ServletConfig 接口，可直接调用 getInitParameter</span></span><br><span class="line">        <span class="built_in">this</span>.smtpServer = <span class="built_in">this</span>.getInitParameter(<span class="string">&quot;smtpServer&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">retryCountStr</span> <span class="operator">=</span> <span class="built_in">this</span>.getInitParameter(<span class="string">&quot;retryCount&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 校验与默认值处理 (Validation &amp; Defaults)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.smtpServer == <span class="literal">null</span> || <span class="built_in">this</span>.smtpServer.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;Critical Error: &#x27;smtpServer&#x27; parameter is missing.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.retryCount = (retryCountStr != <span class="literal">null</span>) ? Integer.parseInt(retryCountStr) : <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            <span class="comment">// 记录日志并使用默认值</span></span><br><span class="line">            log(<span class="string">&quot;Invalid retryCount format, defaulting to 1&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.retryCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 资源初始化日志</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;EmailService initialized [Server: %s, Retries: %d]%n&quot;</span>, smtpServer, retryCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>异常处理提示：</strong></p>
<p><code>init</code> 方法声明抛出 <code>ServletException</code>。如果在初始化过程中遇到致命错误（如关键配置缺失、数据库连接失败），应直接抛出该异常。容器捕获到异常后，将标记该 Servlet 为不可用，后续请求将不会分发给它，从而避免应用在错误状态下运行。</p>
</blockquote>
<hr>
<h3 id="2-3-处理请求"><a href="#2-3-处理请求" class="headerlink" title="2.3 处理请求"></a>2.3 处理请求</h3><p>这是 Servlet 生命周期中的<strong>服务执行阶段</strong>，也是 Web 应用的核心价值所在。</p>
<h4 id="2-3-1-执行模型"><a href="#2-3-1-执行模型" class="headerlink" title="2.3.1 执行模型"></a>2.3.1 执行模型</h4><ul>
<li><strong>高频并发</strong>：与初始化阶段的“单次执行”不同，此阶段的方法会被<strong>重复调用无数次</strong>。</li>
<li><strong>多线程分发</strong>：对于每一个匹配的 HTTP 请求，Servlet 容器会从线程池中分配一个工作线程，调用 Servlet 实例的 <code>service()</code> 方法。</li>
<li><strong>共享实例</strong>：由于 Servlet 是单例的，所有并发线程操作的都是同一个 Java 对象。这意味着 <code>service()</code> 方法及其调用的业务方法必须是<strong>可重入的 (Reentrant)</strong> 和<strong>线程安全的 (Thread-Safe)</strong>。</li>
</ul>
<hr>
<h4 id="2-3-2-核心方法与分发机制"><a href="#2-3-2-核心方法与分发机制" class="headerlink" title="2.3.2 核心方法与分发机制"></a>2.3.2 核心方法与分发机制</h4><p>Servlet 的请求处理遵循<strong>模板方法模式 (Template Method Pattern)</strong>，通过分层调用实现协议适配。</p>
<ol>
<li><strong>接口层：<code>service(ServletRequest, ServletResponse)</code></strong><ul>
<li>定义在 <code>javax.servlet.Servlet</code> 接口中。</li>
<li>这是容器调用的直接入口，参数是通用的 Servlet 请求&#x2F;响应对象，不特定于 HTTP 协议。</li>
</ul>
</li>
<li><strong>抽象类层：<code>service(HttpServletRequest, HttpServletResponse)</code></strong><ul>
<li>在 <code>HttpServlet</code> 抽象类中重载的方法。</li>
<li>它将通用对象强制转换为 HTTP 协议专用的 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code>。</li>
<li>随后调用内部的<strong>请求分发器 (Dispatcher)</strong> 逻辑。</li>
</ul>
</li>
<li><strong>分发逻辑 (The Dispatcher Logic)</strong><ul>
<li><code>HttpServlet</code> 的 <code>service</code> 方法会解析 HTTP 请求方法（Method），如 GET、POST、PUT 等。</li>
<li>根据 Method 类型，动态反射调用对应的 <code>doXXX()</code> 方法：<ul>
<li><code>GET</code> -&gt; <code>doGet()</code></li>
<li><code>POST</code> -&gt; <code>doPost()</code></li>
<li><code>PUT</code> -&gt; <code>doPut()</code></li>
<li>…</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>开发规范：</strong></p>
<p>在开发基于 HTTP 的 Servlet 时，<strong>不建议重写 <code>service</code> 方法</strong>。正确的做法是根据业务需求，重写具体的 <code>doGet</code> 或 <code>doPost</code> 等方法。这既保留了 HTTP 协议的标准处理流程（如处理 <code>HEAD</code> 请求或 <code>Last-Modified</code> 头），又简化了代码结构。</p>
</blockquote>
<hr>
<h4 id="2-3-3-并发控制与线程安全-Concurrency-Thread-Safety"><a href="#2-3-3-并发控制与线程安全-Concurrency-Thread-Safety" class="headerlink" title="2.3.3 并发控制与线程安全 (Concurrency &amp; Thread Safety)"></a>2.3.3 并发控制与线程安全 (Concurrency &amp; Thread Safety)</h4><p>这是 Servlet 开发中最容易引发生产事故（如数据污染、竞态条件）的领域。</p>
<h5 id="1-风险根源：JVM-内存模型-JMM"><a href="#1-风险根源：JVM-内存模型-JMM" class="headerlink" title="1. 风险根源：JVM 内存模型 (JMM)"></a>1. 风险根源：JVM 内存模型 (JMM)</h5><ul>
<li>在 JVM 中，Servlet 实例存储在<strong>堆内存 (Heap)</strong>。</li>
<li>Servlet 的<strong>成员变量 (Instance Variables)</strong> 属于对象状态的一部分，被所有访问该实例的线程共享。</li>
<li>当多线程并发修改同一个成员变量时，若无同步控制，将导致<strong>数据不一致</strong>。</li>
</ul>
<h5 id="2-线程安全最佳实践"><a href="#2-线程安全最佳实践" class="headerlink" title="2. 线程安全最佳实践"></a>2. 线程安全最佳实践</h5><ul>
<li><strong>原则 A：无状态化 (Statelessness)</strong><ul>
<li><strong>推荐</strong>：尽量不要在 Servlet 中定义成员变量。</li>
<li><strong>替代</strong>：将所有与请求相关的数据（如用户参数、中间计算结果）定义为方法内的<strong>局部变量 (Local Variables)</strong>。局部变量存储在<strong>线程栈 (Thread Stack)</strong> 中，每个线程独享，天然线程安全。</li>
</ul>
</li>
<li><strong>原则 B：只读共享 (Read-Only Sharing)</strong><ul>
<li>如果必须定义成员变量（如 Service 层的依赖注入对象），确保它们在初始化后是<strong>不可变 (Immutable)</strong> 的，或者仅执行读操作。</li>
</ul>
</li>
<li><strong>原则 C：同步控制 (Synchronization)</strong><ul>
<li>如果必须修改共享状态（如全局计数器），必须使用同步机制。</li>
<li><em>推荐</em>：使用 JDK <code>java.util.concurrent.atomic</code> 包下的原子类（如 <code>AtomicInteger</code>, <code>AtomicLong</code>），性能优于 <code>synchronized</code> 关键字。</li>
</ul>
</li>
</ul>
<h5 id="3-反面教材与修正示例"><a href="#3-反面教材与修正示例" class="headerlink" title="3. 反面教材与修正示例"></a>3. 反面教材与修正示例</h5><ul>
<li><p><strong>危险代码 (非线程安全)</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 危险！成员变量被所有请求共享</span></span><br><span class="line">    <span class="keyword">private</span> String username; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(...)</span> &#123;</span><br><span class="line">        <span class="comment">// 线程 A 刚写入，可能被线程 B 覆盖，导致 A 读取到 B 的数据</span></span><br><span class="line">        <span class="built_in">this</span>.username = request.getParameter(<span class="string">&quot;user&quot;</span>); </span><br><span class="line">        process(<span class="built_in">this</span>.username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修正代码 (线程安全)</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 安全：只读的无状态依赖对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">    <span class="comment">// 安全：原子类处理共享状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">requestCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> &#123;</span><br><span class="line">        <span class="comment">// 安全：局部变量，线程栈独享</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;user&quot;</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 安全：原子操作</span></span><br><span class="line">        requestCount.incrementAndGet();</span><br><span class="line">        </span><br><span class="line">        userService.process(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-4-销毁"><a href="#2-4-销毁" class="headerlink" title="2.4 销毁"></a>2.4 销毁</h3><p>这是 Servlet 生命周期的终结阶段。当 Servlet 容器决定将 Servlet 实例从服务中移除时，会调用 <code>destroy()</code> 方法。此阶段是<strong>防止资源泄漏 (Resource Leak)</strong> 的最后一道防线。</p>
<h4 id="2-4-1-核心特征与执行逻辑"><a href="#2-4-1-核心特征与执行逻辑" class="headerlink" title="2.4.1 核心特征与执行逻辑"></a>2.4.1 核心特征与执行逻辑</h4><ul>
<li><strong>单次执行</strong>：与 <code>init()</code> 方法对应，<code>destroy()</code> 在 Servlet 实例的整个生命周期中<strong>仅执行一次</strong>。</li>
<li><strong>执行前置条件</strong>：容器在调用 <code>destroy()</code> 之前，会确保所有当前正在运行的 <code>service()</code> 线程都已结束，或者等待超时。这意味着在 <code>destroy()</code> 执行时，理论上不再有新的请求进入该 Servlet。</li>
<li><strong>GC 前奏</strong>：<code>destroy()</code> 方法执行完毕后，容器将释放对该 Servlet 实例的引用。随后，该实例将变为<strong>不可达对象 (Unreachable Object)</strong>，等待 JVM 垃圾回收器 (Garbage Collector) 进行内存回收。</li>
</ul>
<hr>
<h4 id="2-4-2-主要职责：资源释放-Resource-Deallocation"><a href="#2-4-2-主要职责：资源释放-Resource-Deallocation" class="headerlink" title="2.4.2 主要职责：资源释放 (Resource Deallocation)"></a>2.4.2 主要职责：资源释放 (Resource Deallocation)</h4><p><code>destroy()</code> 方法的核心职责是<strong>清理</strong>。如果在 <code>init()</code> 阶段分配了任何非内存资源（Non-memory resources）或由 Servlet 持有的外部连接，必须在此阶段显式释放。</p>
<p>常见清理任务包括：</p>
<ol>
<li><strong>I&#x2F;O 资源释放</strong>：关闭文件句柄、网络套接字 (Sockets)。</li>
<li><strong>持久化连接断开</strong>：关闭数据库连接池、消息队列连接（如果这些资源是 Servlet 独占的）。</li>
<li><strong>并发任务终止</strong>：停止在 Servlet 中启动的后台线程、定时任务调度器 (Scheduler)，防止 Web 应用停止后后台线程仍在运行（即防止<strong>线程泄漏</strong>）。</li>
<li><strong>状态持久化</strong>：将内存中的统计数据或会话数据同步写入磁盘或数据库。</li>
</ol>
<hr>
<h4 id="2-4-3-触发场景"><a href="#2-4-3-触发场景" class="headerlink" title="2.4.3 触发场景"></a>2.4.3 触发场景</h4><p>Servlet 容器在以下情况会触发销毁流程：</p>
<ol>
<li><strong>应用卸载 (Undeployment)</strong>：管理员从容器中手动移除 Web 应用。</li>
<li><strong>容器关闭 (Shutdown)</strong>：Web 服务器（如 Tomcat）正常执行停止命令。</li>
<li><strong>热部署 (Hot Deployment)</strong>：在不重启服务器的情况下，更新了 <code>.class</code> 文件或配置文件，容器会先销毁旧实例，再重新加载新实例。</li>
</ol>
<hr>
<h4 id="2-4-4-可靠性约束-Reliability-Constraints"><a href="#2-4-4-可靠性约束-Reliability-Constraints" class="headerlink" title="2.4.4 可靠性约束 (Reliability Constraints)"></a>2.4.4 可靠性约束 (Reliability Constraints)</h4><p><strong>注意：<code>destroy()</code> 方法的执行并非绝对保证。</strong></p>
<ul>
<li><strong>优雅关闭 (Graceful Shutdown)</strong>：只有在容器正常关闭或通过管理命令卸载应用时，<code>destroy()</code> 才会执行。</li>
<li><strong>强制终止 (Abrupt Termination)</strong>：如果服务器进程被操作系统强制杀死（如 <code>kill -9</code>）、电源断电或 JVM 发生崩溃 (Crash)，<code>destroy()</code> 方法<strong>不会被执行</strong>。</li>
<li><strong>设计建议</strong>：对于关键业务数据，不应完全依赖 <code>destroy()</code> 进行持久化。应采用实时写入或预写日志 (WAL) 等机制来保证数据一致性。</li>
</ul>
<hr>
<h4 id="2-4-5-代码示例：资源管理闭环"><a href="#2-4-5-代码示例：资源管理闭环" class="headerlink" title="2.4.5 代码示例：资源管理闭环"></a>2.4.5 代码示例：资源管理闭环</h4><p>以下代码展示了如何在生命周期的开始和结束阶段形成资源管理的闭环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceManagerServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PrintWriter auditLogWriter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化阶段：申请资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟打开一个审计日志文件流</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">logPath</span> <span class="operator">=</span> getServletContext().getRealPath(<span class="string">&quot;/WEB-INF/logs/audit.log&quot;</span>);</span><br><span class="line">            <span class="comment">// append = true 表示追加模式</span></span><br><span class="line">            <span class="built_in">this</span>.auditLogWriter = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(logPath, <span class="literal">true</span>));</span><br><span class="line">            <span class="built_in">this</span>.log(<span class="string">&quot;Resources initialized successfully.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 初始化失败，抛出异常，阻止 Servlet 启动</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;Fatal: Failed to open log file.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务阶段：使用资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 记录请求日志</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.auditLogWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 注意：多线程环境下写文件需考虑同步，此处仅为逻辑演示</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.auditLogWriter.println(<span class="string">&quot;Access at: &quot;</span> + System.currentTimeMillis());</span><br><span class="line">                <span class="built_in">this</span>.auditLogWriter.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Request processed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁阶段：释放资源</span></span><br><span class="line"><span class="comment">     * 必须进行非空判断 (Null Check) 和异常捕获</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.auditLogWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.log(<span class="string">&quot;Closing audit log writer...&quot;</span>);</span><br><span class="line">            <span class="comment">// 显式关闭流，释放文件句柄</span></span><br><span class="line">            <span class="built_in">this</span>.auditLogWriter.close();</span><br><span class="line">            <span class="built_in">this</span>.auditLogWriter = <span class="literal">null</span>; <span class="comment">// 帮助 GC 回收</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.log(<span class="string">&quot;Servlet destroyed and resources released.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-5-生命周期全景图"><a href="#2-5-生命周期全景图" class="headerlink" title="2.5 生命周期全景图"></a>2.5 生命周期全景图</h3><pre><code class="highlight mermaid">stateDiagram-v2
    [*] --&gt; DoesNotExist
    
    DoesNotExist --&gt; Instantiated: 1.加载类与实例化 (Constructor)
    Instantiated --&gt; Ready: 2.初始化 (init)
    
    state Ready &#123;
        [*] --&gt; Serving
        Serving --&gt; Serving: 3.处理请求 (service/doGet/doPost)
        Note right of Serving: 多线程并发处理&lt;br/&gt;重复执行无数次
    &#125;
    
    Ready --&gt; Destroyed: 4.销毁 (destroy)
    Destroyed --&gt; DoesNotExist: 5.垃圾回收 (GC)</code></pre>

<hr>
<h2 id="3-Servlet-继承体系"><a href="#3-Servlet-继承体系" class="headerlink" title="3. Servlet 继承体系"></a>3. Servlet 继承体系</h2><p>Servlet API 的设计采用了经典的<strong>接口继承与抽象类实现</strong>的架构。这一体系保证了核心规范的统一性，同时为特定协议（如 HTTP）提供了灵活的扩展能力。</p>
<h3 id="3-1-根接口：javax-servlet-Servlet"><a href="#3-1-根接口：javax-servlet-Servlet" class="headerlink" title="3.1 根接口：javax.servlet.Servlet"></a>3.1 根接口：<code>javax.servlet.Servlet</code></h3><p><code>Servlet</code> 接口是整个 Servlet API 的<strong>顶层抽象</strong>和<strong>根接口</strong>。它定义了 Servlet 容器（如 Tomcat）与 Servlet 组件之间交互的<strong>行为契约 (Behavioral Contract)</strong>。</p>
<h4 id="3-1-1-核心职责"><a href="#3-1-1-核心职责" class="headerlink" title="3.1.1 核心职责"></a>3.1.1 核心职责</h4><ol>
<li><strong>协议无关性 (Protocol-Agnostic)</strong>：<ul>
<li>该接口的设计完全独立于传输层协议。它定义的 <code>ServletRequest</code> 和 <code>ServletResponse</code> 是通用的输入输出封装，不包含任何特定于 HTTP（如 Header、Cookie、Method）的细节。</li>
<li>理论上，该接口可用于处理 FTP、SMTP 或自定义协议的请求，虽然在实际应用中绝大多数是 HTTP。</li>
</ul>
</li>
<li><strong>生命周期管控 (Lifecycle Management)</strong>：<ul>
<li>接口强制规定了组件的生命周期模型（初始化 -&gt; 服务 -&gt; 销毁）。容器通过调用这些标准化方法来控制组件的状态流转。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-1-2-接口方法详解"><a href="#3-1-2-接口方法详解" class="headerlink" title="3.1.2 接口方法详解"></a>3.1.2 接口方法详解</h4><p><code>Servlet</code> 接口包含五个核心方法，根据功能可将其归纳为两类：<strong>生命周期方法</strong>和<strong>辅助访问方法</strong>。</p>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">方法签名</th>
<th align="left">职责描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>生命周期</strong></td>
<td align="left"><code>void init(ServletConfig config)</code></td>
<td align="left"><strong>初始化</strong>。<br>容器在实例化 Servlet 后调用的第一个方法。传入的 <code>ServletConfig</code> 包含了该组件的配置参数。此方法在生命周期中<strong>仅调用一次</strong>。</td>
</tr>
<tr>
<td align="left"><strong>生命周期</strong></td>
<td align="left"><code>void service(ServletRequest req, ServletResponse res)</code></td>
<td align="left"><strong>服务入口</strong>。<br>处理业务请求的核心方法。容器为每个请求分配线程并调用此方法。它是<strong>多线程并发</strong>执行的入口，需保证线程安全。</td>
</tr>
<tr>
<td align="left"><strong>生命周期</strong></td>
<td align="left"><code>void destroy()</code></td>
<td align="left"><strong>销毁</strong>。<br>容器在卸载 Servlet 实例前调用的最后一步。用于释放文件句柄、数据库连接等资源。此方法在生命周期中<strong>仅调用一次</strong>。</td>
</tr>
<tr>
<td align="left"><strong>辅助访问</strong></td>
<td align="left"><code>ServletConfig getServletConfig()</code></td>
<td align="left"><strong>获取配置</strong>。<br>返回 <code>init</code> 阶段传入的配置对象。通过它可获取初始化参数 (<code>init-param</code>) 和全局上下文 (<code>ServletContext</code>)。</td>
</tr>
<tr>
<td align="left"><strong>辅助访问</strong></td>
<td align="left"><code>String getServletInfo()</code></td>
<td align="left"><strong>获取信息</strong>。<br>返回描述 Servlet 的元数据（如作者、版本）。通常用于管理控制台展示，实际业务中较少使用。</td>
</tr>
</tbody></table>
<hr>
<h4 id="3-1-3-直接实现接口的局限性"><a href="#3-1-3-直接实现接口的局限性" class="headerlink" title="3.1.3 直接实现接口的局限性"></a>3.1.3 直接实现接口的局限性</h4><p>在 Web 应用开发中，开发者<strong>极少</strong>直接实现 <code>Servlet</code> 接口，主要基于以下工程化考量：</p>
<ol>
<li><p><strong>协议适配成本高 (Protocol Adaptation Cost)</strong></p>
<ul>
<li><p><code>service</code> 方法接收的是通用的 <code>ServletRequest</code>。要处理 HTTP 请求，开发者必须在方法内部手动进行<strong>类型强制转换 (Downcasting)</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">httpReq</span> <span class="operator">=</span> (HttpServletRequest) req; <span class="comment">// 繁琐且易错</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>缺乏对 HTTP 语义（如 method 分发、Session 管理）的原生支持。</p>
</li>
</ul>
</li>
<li><p><strong>样板代码冗余 (Boilerplate Code)</strong></p>
<ul>
<li>作为接口，实现类必须实现所有 5 个方法。</li>
<li>即使业务只需要 <code>service</code> 方法，也不得不为空方法（如 <code>getServletInfo</code>、<code>destroy</code>）编写无意义的空实现，导致代码信噪比降低。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-2-中间层抽象：GenericServlet"><a href="#3-2-中间层抽象：GenericServlet" class="headerlink" title="3.2 中间层抽象：GenericServlet"></a>3.2 中间层抽象：<code>GenericServlet</code></h3><p><code>javax.servlet.GenericServlet</code> 是一个实现了 <code>Servlet</code> 接口的<strong>抽象类</strong>。</p>
<p>它是 Servlet 架构中的<strong>协议中立层</strong>。它的核心职责是利用 <strong>适配器模式 (Adapter Pattern)</strong> 为 <code>Servlet</code> 接口提供通用的默认实现，屏蔽了非核心方法的复杂性，使开发者能够专注于业务逻辑。</p>
<h4 id="3-2-1-架构设计与核心贡献"><a href="#3-2-1-架构设计与核心贡献" class="headerlink" title="3.2.1 架构设计与核心贡献"></a>3.2.1 架构设计与核心贡献</h4><p><code>GenericServlet</code> 在继承体系中起到了承上启下的作用，其核心设计亮点包括：</p>
<ol>
<li><strong>接口适配与默认实现 (Interface Adaptation)</strong><ul>
<li>它实现了 <code>Servlet</code> 接口中除 <code>service()</code> 之外的所有方法（<code>init</code>, <code>destroy</code>, <code>getServletConfig</code>, <code>getServletInfo</code>）。</li>
<li><strong>优势</strong>：子类继承它后，不再被强制要求实现 <code>destroy()</code> 等方法，消除了大量空实现的样板代码。</li>
</ul>
</li>
<li><strong>Config 对象的代理 (Delegate Pattern)</strong><ul>
<li>它同时实现了 <code>ServletConfig</code> 接口。</li>
<li><strong>机制</strong>：它内部持有一个 <code>ServletConfig</code> 引用，并将 <code>getServletContext()</code>、<code>getInitParameter()</code> 等方法的调用<strong>代理</strong>给这个内部引用。</li>
<li><strong>效果</strong>：在 Servlet 内部，开发者可以直接调用 <code>this.getInitParameter(&quot;name&quot;)</code>，而无需繁琐地写成 <code>this.getServletConfig().getInitParameter(&quot;name&quot;)</code>。</li>
</ul>
</li>
<li><strong>生命周期的模板化扩展</strong><ul>
<li>它保留了 <code>init(ServletConfig)</code> 的标准实现（保存 Config 对象），并引入了一个新增的、受保护的 <strong>无参 <code>init()</code> 方法</strong>。</li>
<li><strong>设计意图</strong>：这是一个扩展点。子类只需重写无参 <code>init()</code> 即可完成初始化逻辑，既无需关心 <code>super.init(config)</code> 的调用，又避免了覆盖核心初始化流程的风险。</li>
</ul>
</li>
<li><strong>唯一的抽象契约</strong><ul>
<li>它将 <code>service(ServletRequest, ServletResponse)</code> 方法保留为 <strong><code>abstract</code></strong>。</li>
<li>这表明尽管提供了基础骨架，但“如何处理请求”这一核心业务逻辑，仍然必须由具体的子类来实现。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-2-2-为什么-Web-开发不直接继承它？"><a href="#3-2-2-为什么-Web-开发不直接继承它？" class="headerlink" title="3.2.2 为什么 Web 开发不直接继承它？"></a>3.2.2 为什么 Web 开发不直接继承它？</h4><p>尽管 <code>GenericServlet</code> 简化了开发，但在构建 Web 应用时，直接继承它并非最佳选择。其局限性源于其设计的<strong>协议无关性 (Protocol-Independence)</strong>。</p>
<ul>
<li><p><strong>缺乏 HTTP 语义支持</strong>：<br><code>service</code> 方法的参数是通用的 <code>ServletRequest</code> 和 <code>ServletResponse</code>。这些接口不包含任何 HTTP 协议特有的方法（如 <code>getMethod()</code>, <code>getHeader()</code>, <code>addCookie()</code>）。</p>
</li>
<li><p><strong>类型强转风险</strong>：<br>若要在 <code>GenericServlet</code> 中处理 HTTP 请求，开发者被迫进行显式的<strong>向下转型 (Downcasting)</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 繁琐且破坏了类型安全的优雅性</span></span><br><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">httpReq</span> <span class="operator">=</span> (HttpServletRequest) req; </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分发逻辑缺失</strong>：<br>它没有内置针对 GET、POST 等 HTTP 方法的分发逻辑，开发者需要手动编写复杂的 <code>if-else</code> 判断。</p>
</li>
</ul>
<hr>
<h3 id="3-3-协议专用层：HttpServlet"><a href="#3-3-协议专用层：HttpServlet" class="headerlink" title="3.3 协议专用层：HttpServlet"></a>3.3 协议专用层：<code>HttpServlet</code></h3><p><code>javax.servlet.http.HttpServlet</code> 是 Servlet API 中最核心的抽象类，它继承自 <code>GenericServlet</code>，专门针对 <strong>HTTP&#x2F;1.1 协议</strong>进行了扩展和封装。</p>
<p>它是现代 Java Web 开发事实上的基类。绝大多数 Servlet 组件都<strong>必须</strong>继承此类，以利用其内置的 HTTP 协议处理能力。</p>
<h4 id="3-3-1-核心设计：模板方法与请求分发"><a href="#3-3-1-核心设计：模板方法与请求分发" class="headerlink" title="3.3.1 核心设计：模板方法与请求分发"></a>3.3.1 核心设计：模板方法与请求分发</h4><p><code>HttpServlet</code> 的设计精髓在于它对 <strong>模板方法模式 (Template Method Pattern)</strong> 的应用。它并未强迫子类实现所有逻辑，而是定义了一套基于 HTTP Method 的分发骨架。</p>
<p><strong>工作原理 (The Dispatching Mechanism)：</strong></p>
<ol>
<li><strong>入口重载 (Entry Point Overloading)</strong><br><code>HttpServlet</code> 重写了 <code>GenericServlet</code> 的 <code>service(ServletRequest, ServletResponse)</code> 方法。在此方法内部，它首先将通用的 Request&#x2F;Response 对象<strong>向下转型 (Downcasting)</strong> 为 HTTP 专用的 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code>。</li>
<li><strong>受保护的协议服务方法 (Protected Protocol Service)</strong><br>转型成功后，它调用了一个重载的、受保护的 <code>service(HttpServletRequest, HttpServletResponse)</code> 方法。<strong>这才是 HTTP 处理逻辑的真正入口</strong>。</li>
<li><strong>方法分发 (Method Dispatching)</strong><br>在受保护的 <code>service</code> 方法内部，代码读取 HTTP 请求行中的 <strong>Method</strong> 字段（如 <code>GET</code>, <code>POST</code>, <code>PUT</code>）。基于此字段，通过一系列 <code>if-else</code> 判断，将请求路由到对应的 <code>doXXX()</code> 方法：<ul>
<li><code>GET</code> 请求 → 调用 <code>doGet()</code></li>
<li><code>POST</code> 请求 → 调用 <code>doPost()</code></li>
<li><code>PUT</code> 请求 → 调用 <code>doPut()</code></li>
<li><code>DELETE</code> 请求 → 调用 <code>doDelete()</code></li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-3-2-开发范式：只重写-doXXX"><a href="#3-3-2-开发范式：只重写-doXXX" class="headerlink" title="3.3.2 开发范式：只重写 doXXX"></a>3.3.2 开发范式：只重写 doXXX</h4><p>基于上述设计，<code>HttpServlet</code> 确立了标准的 Servlet 开发范式：</p>
<ol>
<li><strong>不要重写 <code>service</code> 方法</strong>：除非你需要拦截所有请求进行预处理（通常这由 Filter 完成）或处理非标准 HTTP 方法。重写 <code>service</code> 会破坏内置的分发机制和对 <code>HEAD</code>、<code>OPTIONS</code> 等辅助方法的默认处理。</li>
<li><strong>按需重写 <code>doGet</code> &#x2F; <code>doPost</code></strong>：根据业务需求，仅重写你需要支持的 HTTP 方法。</li>
</ol>
<blockquote>
<p><strong>关于 HTTP 405 (Method Not Allowed)</strong></p>
<p><code>HttpServlet</code> 中所有 <code>doXXX()</code> 方法的<strong>默认实现</strong>都是直接返回 HTTP 405 状态码。</p>
<ul>
<li><strong>含义</strong>：服务器知道了请求的目标资源，但请求的方法（如 POST）不被允许。</li>
<li><strong>场景</strong>：如果你只重写了 <code>doGet()</code>，但客户端发起了一个 <code>POST</code> 请求，父类的 <code>doPost()</code> 默认实现就会被执行，从而向客户端返回 405 错误。这是一种符合 HTTP 协议规范的安全设计。</li>
</ul>
</blockquote>
<hr>
<h4 id="3-3-3-实战示例"><a href="#3-3-3-实战示例" class="headerlink" title="3.3.3 实战示例"></a>3.3.3 实战示例</h4><p>以下代码展示了如何利用 <code>HttpServlet</code> 处理登录场景，体现了 GET（获取视图）与 POST（提交数据）的分离。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 GET 请求：负责数据的读取或页面的展示 (Idempotent &amp; Safe)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置响应类型，防止中文乱码</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 实际开发中通常转发给 JSP/Thymeleaf，此处仅演示直接输出</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        out.println(<span class="string">&quot;&lt;html&gt;&lt;body&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;h2&gt;System Login&lt;/h2&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;form action=&#x27;/login&#x27; method=&#x27;POST&#x27;&gt;&quot;</span>); <span class="comment">// 指向同 URL 的 POST 方法</span></span><br><span class="line">        out.println(<span class="string">&quot;User: &lt;input type=&#x27;text&#x27; name=&#x27;username&#x27;/&gt;&lt;br/&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;Pass: &lt;input type=&#x27;password&#x27; name=&#x27;password&#x27;/&gt;&lt;br/&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;input type=&#x27;submit&#x27; value=&#x27;Sign In&#x27;/&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 POST 请求：负责数据的修改或状态的变更 (Non-Idempotent)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 设置请求体编码 (必须在读取参数前设置)</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 获取表单数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">pass</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 业务逻辑处理</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(user) &amp;&amp; <span class="string">&quot;secret&quot;</span>.equals(pass)) &#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;&lt;h3&gt;Login Successful. Welcome &quot;</span> + user + <span class="string">&quot;&lt;/h3&gt;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 登录失败，通常重定向回登录页或输出错误</span></span><br><span class="line">            resp.setStatus(HttpServletResponse.SC_UNAUTHORIZED); <span class="comment">// 设置 401 状态码</span></span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;&lt;h3 style=&#x27;color:red&#x27;&gt;Invalid Credentials&lt;/h3&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="二、Servlet-核心-API"><a href="#二、Servlet-核心-API" class="headerlink" title="二、Servlet 核心 API"></a>二、Servlet 核心 API</h1><h2 id="1-HttpServletRequest-请求对象"><a href="#1-HttpServletRequest-请求对象" class="headerlink" title="1. HttpServletRequest (请求对象)"></a>1. HttpServletRequest (请求对象)</h2><h3 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h3><p><code>HttpServletRequest</code> 对象由 Servlet 容器创建，并作为参数传递给 Servlet 的 <code>service()</code>、<code>doGet()</code> 或 <code>doPost()</code> 等方法。它的核心作用是<strong>客户端发送HTTP请求的完整表示</strong>。</p>
<p>它封装了 HTTP 请求的三个主要部分：</p>
<ol>
<li><strong>请求行 (Request Line):</strong> 包括请求方法（GET, POST 等）、请求的资源路径 (URI) 和 HTTP 协议版本。</li>
<li><strong>请求头 (Request Headers):</strong> 包含一系列键值对，提供了关于客户端、请求本身和内容的元数据（如 <code>User-Agent</code>, <code>Accept</code>, <code>Cookie</code>）。</li>
<li><strong>请求体 (Request Body):</strong> 包含了客户端发送给服务器的实际数据，例如 HTML 表单提交的数据、JSON 数据等。（GET 请求通常没有请求体）。</li>
</ol>
<p><strong>关键点：</strong> 我们作为开发者<strong>从不自己创建</strong> <code>HttpServletRequest</code> 对象，而是由 Servlet 容器（如 Tomcat）为我们解析原始的网络数据流并封装好。</p>
<hr>
<h3 id="1-2-获取请求行信息"><a href="#1-2-获取请求行信息" class="headerlink" title="1.2 获取请求行信息"></a>1.2 获取请求行信息</h3><p>这些方法用于获取 HTTP 请求的第一行内容。</p>
<p>假设客户端请求的 URL 是：<code>http://localhost:8080/myapp/user/info?id=123</code></p>
<ul>
<li><code>String getMethod()</code>: 获取请求方式。<ul>
<li><strong>示例:</strong> <code>request.getMethod();</code> &#x2F;&#x2F; 返回 “GET”</li>
</ul>
</li>
<li><code>String getRequestURI()</code>: 获取请求的资源标识符路径（从项目名开始，不包括协议、主机、端口和查询参数）。<ul>
<li><strong>示例:</strong> <code>request.getRequestURI();</code> &#x2F;&#x2F; 返回 “&#x2F;myapp&#x2F;user&#x2F;info”</li>
</ul>
</li>
<li><code>StringBuffer getRequestURL()</code>: 获取客户端请求的完整 URL（不包括查询参数）。<ul>
<li><strong>示例:</strong> <code>request.getRequestURL();</code> &#x2F;&#x2F; 返回 “<a target="_blank" rel="noopener" href="http://localhost:8080/myapp/user/info">http://localhost:8080/myapp/user/info</a>“</li>
</ul>
</li>
<li><code>String getContextPath()</code>: 获取当前 Web 应用的上下文路径（即项目名）。在构建动态链接时非常有用。<ul>
<li><strong>示例:</strong> <code>request.getContextPath();</code> &#x2F;&#x2F; 返回 “&#x2F;myapp”</li>
</ul>
</li>
<li><code>String getQueryString()</code>: 获取 URL 中 <code>?</code> 后面的查询字符串。<ul>
<li><strong>示例:</strong> <code>request.getQueryString();</code> &#x2F;&#x2F; 返回 “id&#x3D;123”</li>
</ul>
</li>
<li><code>String getProtocol()</code>: 获取请求使用的协议和版本。<ul>
<li><strong>示例:</strong> <code>request.getProtocol();</code> &#x2F;&#x2F; 返回 “HTTP&#x2F;1.1”</li>
</ul>
</li>
<li><code>String getRemoteAddr()</code>: 获取客户端的 IP 地址。</li>
</ul>
<hr>
<h3 id="1-3-获取请求头信息"><a href="#1-3-获取请求头信息" class="headerlink" title="1.3 获取请求头信息"></a>1.3 获取请求头信息</h3><p>这些方法用于获取 HTTP 请求头中的键值对。</p>
<ul>
<li><p><code>String getHeader(String name)</code>: 根据头名称获取对应的头信息值。头名称不区分大小写。</p>
<ul>
<li><strong>示例:</strong> <code>String userAgent = request.getHeader(&quot;User-Agent&quot;);</code> &#x2F;&#x2F; 获取浏览器信息</li>
</ul>
</li>
<li><p><code>java.util.Enumeration&lt;String&gt; getHeaderNames()</code>: 获取所有请求头的名称集合。</p>
<ul>
<li><p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;String&gt; headerNames = request.getHeaderNames();</span><br><span class="line"><span class="keyword">while</span>(headerNames.hasMoreElements())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">headerName</span> <span class="operator">=</span> headerNames.nextElement();</span><br><span class="line">    System.out.println(headerName + <span class="string">&quot;: &quot;</span> + request.getHeader(headerName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-4-获取请求参数"><a href="#1-4-获取请求参数" class="headerlink" title="1.4 获取请求参数"></a>1.4 获取请求参数</h3><p>这是 <code>HttpServletRequest</code> 最常用的功能之一，用于获取客户端通过表单或 URL 查询字符串提交的数据。</p>
<ul>
<li><code>String getParameter(String name)</code>: 根据参数名获取参数值。这是<strong>最常用</strong>的方法。<ul>
<li>如果参数存在，返回其 <code>String</code> 类型的值。</li>
<li>如果参数不存在，返回 <code>null</code>。</li>
</ul>
</li>
<li><code>String[] getParameterValues(String name)</code>: 根据参数名获取一个参数的所有值。常用于处理复选框（checkboxes）这类可以有多个值的表单元素。<ul>
<li>返回一个 <code>String</code> 数组。</li>
<li>如果参数不存在，返回 <code>null</code>。</li>
</ul>
</li>
<li><code>java.util.Map&lt;String, String[]&gt; getParameterMap()</code>: 获取所有请求参数的 Map。<ul>
<li>Map 的键是参数名 (<code>String</code>)。</li>
<li>Map 的值是该参数对应的所有值的 <code>String</code> 数组 (<code>String[]</code>)。</li>
</ul>
</li>
</ul>
<p><strong>示例:</strong></p>
<p>假设有一个表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/register&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    Hobbies:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;reading&quot;</span>&gt;</span> Reading</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;coding&quot;</span>&gt;</span> Coding</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 Servlet 中可以这样获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>); <span class="comment">// &quot;admin&quot;</span></span><br><span class="line">String[] hobbies = request.getParameterValues(<span class="string">&quot;hobby&quot;</span>); <span class="comment">// [&quot;reading&quot;, &quot;coding&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>请求参数中文乱码问题</strong></p>
<p>这是一个经典且必须掌握的问题。</p>
<ul>
<li><p><strong>GET 请求乱码：</strong></p>
<ul>
<li>GET 请求的参数在 URL 中，其编码由服务器（如 Tomcat）的配置决定。</li>
<li><strong>解决方案：</strong> 修改 Tomcat 的 <code>server.xml</code> 文件，在 <code>&lt;Connector&gt;</code> 标签中添加 <code>URIEncoding=&quot;UTF-8&quot;</code>。这是推荐的做法。</li>
</ul>
</li>
<li><p><strong>POST 请求乱码：</strong></p>
<ul>
<li><p>POST 请求的参数在请求体中，其编码由请求头中的 <code>Content-Type</code> 决定。</p>
</li>
<li><p><strong>解决方案：</strong> 在<strong>第一次调用任何 <code>getParameter</code> 系列方法之前</strong>，设置请求体的解码字符集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// 必须在获取任何参数之前调用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-5-作为域对象"><a href="#1-5-作为域对象" class="headerlink" title="1.5 作为域对象"></a>1.5 作为域对象</h3><p><code>HttpServletRequest</code> 也是一个“域对象”，它提供了一个内部的存储空间（类似一个 Map），可以在<strong>一次请求的生命周期内</strong>传递数据。</p>
<p>这个功能是实现 MVC 模式中 <strong>Controller (Servlet) 向 View (JSP) 传递数据</strong>的核心机制。</p>
<ul>
<li><code>void setAttribute(String name, Object value)</code>: 将一个对象存入 request 域中。</li>
<li><code>Object getAttribute(String name)</code>: 根据名称从 request 域中取出对象（需要手动类型转换）。</li>
<li><code>void removeAttribute(String name)</code>: 从 request 域中移除一个对象。</li>
</ul>
<p><strong>典型场景：</strong></p>
<ol>
<li>一个 Servlet 接收到请求，从数据库查询到一个 <code>User</code> 对象。</li>
<li>Servlet 调用 <code>request.setAttribute(&quot;userInfo&quot;, userObject);</code> 将用户对象存入 request 域。</li>
<li>Servlet 通过<strong>请求转发</strong>将请求交给一个 JSP 页面。</li>
<li>JSP 页面可以通过 <code>${userInfo}</code> (EL 表达式) 或 <code>request.getAttribute(&quot;userInfo&quot;)</code> (Java 脚本) 来获取并展示这个 <code>User</code> 对象的信息。</li>
</ol>
<hr>
<h3 id="1-6-请求转发-RequestDispatcher"><a href="#1-6-请求转发-RequestDispatcher" class="headerlink" title="1.6 请求转发 (RequestDispatcher)"></a>1.6 请求转发 (<code>RequestDispatcher</code>)</h3><p>请求转发是一种<strong>服务器内部</strong>的资源跳转方式。</p>
<ul>
<li><strong>工作原理：</strong> Servlet 处理完部分逻辑后，将请求和响应对象“转发”给服务器上的另一个资源（如另一个 Servlet 或 JSP），由目标资源继续处理并最终生成响应。</li>
<li><strong>获取方式：</strong> <code>RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;/path/to/resource&quot;);</code></li>
<li><strong>执行转发：</strong> <code>dispatcher.forward(request, response);</code></li>
</ul>
<p><strong>核心特点：</strong></p>
<ol>
<li><strong>一次请求：</strong> 整个过程对于客户端来说是一次请求和一次响应。</li>
<li><strong>地址栏不变：</strong> 客户端浏览器的地址栏不会发生变化。</li>
<li><strong>数据共享：</strong> 因为使用的是同一个 request 对象，所以可以通过 <code>request.setAttribute()</code> 在转发的 Servlet 和 JSP 之间共享数据。</li>
<li><strong>服务器内部行为：</strong> 只能转发到当前 Web 应用内部的资源。</li>
</ol>
<hr>
<h2 id="2-HttpServletResponse-响应对象"><a href="#2-HttpServletResponse-响应对象" class="headerlink" title="2. HttpServletResponse (响应对象)"></a>2. HttpServletResponse (响应对象)</h2><h3 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1 作用"></a>2.1 作用</h3><p><code>HttpServletResponse</code> 对象由 Servlet 容器创建，并作为参数传递给 Servlet 的服务方法。它的核心作用是<strong>封装服务器对客户端请求的响应</strong>，让开发者能够方便地将处理结果发送回客户端（通常是浏览器）。</p>
<p>它主要用于设置 HTTP 响应的三个部分：</p>
<ol>
<li><strong>响应行 (Status Line):</strong> 包括 HTTP 协议版本、一个状态码（如 200 OK, 404 Not Found）和状态描述。</li>
<li><strong>响应头 (Response Headers):</strong> 包含一系列键值对，告诉浏览器如何处理响应内容（如 <code>Content-Type</code>, <code>Content-Length</code>, <code>Set-Cookie</code>）。</li>
<li><strong>响应体 (Response Body):</strong> 包含了要发送给客户端的实际数据，如 HTML 页面、JSON 字符串、图片数据等。</li>
</ol>
<p><strong>关键点：</strong> 与 <code>HttpServletRequest</code> 一样，我们<strong>从不自己创建</strong> <code>HttpServletResponse</code> 对象，而是由容器提供，我们负责填充它。</p>
<hr>
<h3 id="2-2-设置响应行"><a href="#2-2-设置响应行" class="headerlink" title="2.2 设置响应行"></a>2.2 设置响应行</h3><p>我们通常只关心响应行中的<strong>状态码 (Status Code)</strong>，它告诉客户端请求处理的结果。</p>
<ul>
<li><code>void setStatus(int sc)</code>: 设置响应的状态码。<ul>
<li><strong>示例:</strong> <code>response.setStatus(HttpServletResponse.SC_OK);</code> &#x2F;&#x2F; 设置状态码为 200</li>
<li><strong>示例:</strong> <code>response.setStatus(404);</code> &#x2F;&#x2F; 设置状态码为 404</li>
</ul>
</li>
</ul>
<p><strong>常用状态码：</strong></p>
<ul>
<li><code>200 OK</code>: 请求成功。</li>
<li><code>302 Found</code>: 临时重定向（<code>sendRedirect</code> 方法会自动设置这个状态码）。</li>
<li><code>304 Not Modified</code>: 客户端缓存的资源未过期。</li>
<li><code>400 Bad Request</code>: 请求语法错误。</li>
<li><code>403 Forbidden</code>: 服务器拒绝执行该请求。</li>
<li><code>404 Not Found</code>: 请求的资源不存在。</li>
<li><code>500 Internal Server Error</code>: 服务器内部发生错误。</li>
</ul>
<hr>
<h3 id="2-3-设置响应头"><a href="#2-3-设置响应头" class="headerlink" title="2.3 设置响应头"></a>2.3 设置响应头</h3><p>响应头用于向浏览器提供指令性信息。</p>
<ul>
<li><code>void setHeader(String name, String value)</code>: 设置一个指定名称的响应头。如果该头已存在，新值会覆盖旧值。</li>
<li><code>void addHeader(String name, String value)</code>: 添加一个指定名称的响应头。如果该头已存在，不会覆盖，而是添加一个新的同名头。</li>
</ul>
<p><strong>最常用的响应头设置：</strong></p>
<ol>
<li><strong><code>Content-Type</code> (内容类型):</strong><ul>
<li>这是最重要的响应头，它告诉浏览器响应体是什么类型的数据以及使用什么字符集来解码。</li>
<li>格式: <code>MIME类型;charset=编码</code></li>
<li><strong>便捷方法:</strong> <code>response.setContentType(&quot;text/html;charset=UTF-8&quot;);</code></li>
<li>如果不设置字符集，浏览器可能因解码错误而显示乱码。</li>
</ul>
</li>
<li><strong><code>Location</code> (位置):</strong><ul>
<li>与 <code>302</code> 状态码配合使用，告诉浏览器要重定向到的新地址。<code>sendRedirect</code> 方法会自动设置它。</li>
</ul>
</li>
<li><strong><code>Content-Disposition</code> (内容处置):</strong><ul>
<li>用于指示浏览器如何处理响应体，通常用于<strong>文件下载</strong>。</li>
<li><code>response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=report.xls&quot;);</code></li>
<li><code>attachment</code> 表示作为附件下载，<code>filename</code> 指定了默认的文件名。</li>
</ul>
</li>
<li><strong><code>Refresh</code> (刷新):</strong><ul>
<li>告诉浏览器在指定秒数后刷新页面，或跳转到另一个页面。</li>
<li><code>response.setHeader(&quot;Refresh&quot;, &quot;5;url=http://www.google.com&quot;);</code> &#x2F;&#x2F; 5秒后跳转到谷歌</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-4-设置响应体"><a href="#2-4-设置响应体" class="headerlink" title="2.4 设置响应体"></a>2.4 设置响应体</h3><p>响应体是发送给客户端的实际数据。Servlet 提供了两种输出流来写入响应体，<strong>但两者是互斥的，一次响应中只能使用其中一个</strong>。</p>
<ol>
<li><p><strong>字符输出流 <code>PrintWriter getWriter()</code></strong></p>
<ul>
<li>用于输出<strong>文本数据</strong>，如 HTML, XML, JSON, Plain Text。</li>
<li>它具有平台无关的 <code>print()</code> 和 <code>println()</code> 方法，非常方便。</li>
<li><strong>注意：</strong> 在调用 <code>getWriter()</code> 之前，最好先通过 <code>response.setContentType(...)</code> 或 <code>response.setCharacterEncoding(...)</code> 设置好字符编码，否则可能产生乱码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">out.println(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;body&gt;&lt;h1&gt;你好，世界！&lt;/h1&gt;&lt;/body&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字节输出流 <code>ServletOutputStream getOutputStream()</code></strong></p>
<ul>
<li>用于输出<strong>非文本的二进制数据</strong>，如图片、视频、PDF 文件、ZIP 压缩包等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line"><span class="type">ServletOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line"><span class="comment">// 从文件或其他来源读取图片字节数据，并写入到 out 流中...</span></span><br><span class="line"><span class="comment">// out.write(imageDataBytes);</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong>严重警告：</strong> 如果同时尝试调用 <code>getWriter()</code> 和 <code>getOutputStream()</code>，容器会抛出 <code>IllegalStateException</code>。</p>
</blockquote>
<hr>
<h3 id="2-5-页面跳转：重定向"><a href="#2-5-页面跳转：重定向" class="headerlink" title="2.5 页面跳转：重定向"></a>2.5 页面跳转：重定向</h3><p>重定向 (Redirect) 是一种<strong>客户端</strong>行为的跳转方式。</p>
<ul>
<li><p><strong>工作原理：</strong> 服务器向客户端发送一个特殊的响应（状态码 302 和一个 <code>Location</code> 响应头），客户端浏览器接收到这个响应后，会<strong>自动发起一个新的请求</strong>到 <code>Location</code> 头指定的 URL。</p>
</li>
<li><p><strong>实现方法:</strong> <code>void sendRedirect(String location)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理完用户注册逻辑后，重定向到登录页面</span></span><br><span class="line">response.sendRedirect(request.getContextPath() + <span class="string">&quot;/login.jsp&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-6-请求转发-forward-与重定向-redirect-的区别"><a href="#2-6-请求转发-forward-与重定向-redirect-的区别" class="headerlink" title="2.6 请求转发 (forward) 与重定向 (redirect) 的区别"></a>2.6 请求转发 (forward) 与重定向 (redirect) 的区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th><strong>请求转发 (Forward)</strong></th>
<th><strong>重定向 (Redirect)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>行为主体</strong></td>
<td><strong>服务器行为</strong>。服务器内部将请求转交给另一个资源处理。</td>
<td><strong>客户端行为</strong>。服务器建议客户端去请求另一个地址。</td>
</tr>
<tr>
<td><strong>请求次数</strong></td>
<td><strong>1 次</strong>。客户端只发起了一次请求。</td>
<td><strong>2 次</strong>。客户端先请求 Servlet，然后被告知再去请求另一个地址。</td>
</tr>
<tr>
<td><strong>地址栏变化</strong></td>
<td><strong>不变</strong>。地址栏仍然是最初请求的地址。</td>
<td><strong>改变</strong>。地址栏会更新为重定向后的新地址。</td>
</tr>
<tr>
<td><strong>数据共享</strong></td>
<td><strong>可以共享</strong>。转发过程共享同一个 <code>request</code> 对象，可以通过 <code>request.setAttribute()</code> 传递数据。</td>
<td><strong>不能共享</strong>。两次请求是完全独立的，<code>request</code> 对象不同。</td>
</tr>
<tr>
<td><strong>可以跳转的资源</strong></td>
<td>只能跳转到<strong>当前 Web 应用内部</strong>的资源。</td>
<td>可以跳转到<strong>任何有效的 URL</strong>，包括外部网站。</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td><strong>高</strong>。因为只是服务器内部的调用。</td>
<td><strong>低</strong>。因为需要经过一次客户端与服务器的网络往返。</td>
</tr>
<tr>
<td><strong>核心方法</strong></td>
<td><code>request.getRequestDispatcher(...).forward(req, res)</code></td>
<td><code>response.sendRedirect(...)</code></td>
</tr>
</tbody></table>
<h4 id="使用场景总结："><a href="#使用场景总结：" class="headerlink" title="使用场景总结："></a><strong>使用场景总结：</strong></h4><ul>
<li><strong>使用转发 (Forward):</strong><ul>
<li><strong>MVC 模式</strong>：Servlet (Controller) 处理完业务逻辑后，将数据存入 <code>request</code> 域，然后<strong>转发</strong>到 JSP (View) 进行展示。这是最典型的应用。</li>
</ul>
</li>
<li><strong>使用重定向 (Redirect):</strong><ul>
<li><strong>避免表单重复提交</strong>：当用户提交一个 POST 请求（如注册、下单）处理成功后，<strong>重定向</strong>到一个成功页面。这样即使用户刷新页面，也只是刷新成功页面（GET 请求），不会重复提交表单数据。这被称为 <strong>Post-Redirect-Get (PRG)</strong> 模式。</li>
<li><strong>跳转到外部网站</strong>。</li>
<li><strong>实现登录功能</strong>：用户访问需要登录的页面时，如果未登录，则重定向到登录页面。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="三、会话管理-State-Management"><a href="#三、会话管理-State-Management" class="headerlink" title="三、会话管理 (State Management)"></a>三、会话管理 (State Management)</h1><h2 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1. Cookie"></a>1. Cookie</h2><p>在HTTP中介绍了Cookie的定义以及工作原理，那么在开发中如何使用呢</p>
<h3 id="1-1-Cookie-API"><a href="#1-1-Cookie-API" class="headerlink" title="1.1 Cookie API"></a>1.1 Cookie API</h3><p>在 Java Servlet 中，操作 Cookie 主要通过 <code>javax.servlet.http.Cookie</code> 类以及 <code>request</code> 和 <code>response</code> 对象上的方法。</p>
<ol>
<li><strong>创建 Cookie:</strong><ul>
<li><code>Cookie cookie = new Cookie(String name, String value);</code></li>
<li><strong>注意:</strong> Cookie 的 name 和 value <strong>不能包含</strong>中文字符、空格或特殊字符（如 <code>;</code>, <code>,</code>）。如果需要存储，必须先进行 <strong>URL 编码</strong> (<code>URLEncoder.encode()</code>)，读取时再进行解码 (<code>URLDecoder.decode()</code>)。</li>
</ul>
</li>
<li><strong>发送 Cookie 到客户端:</strong><ul>
<li><code>response.addCookie(Cookie cookie);</code></li>
<li>通过 <code>response</code> 对象将创建好的 Cookie 添加到 HTTP 响应头中。</li>
</ul>
</li>
<li><strong>从客户端请求中获取 Cookie:</strong><ul>
<li><code>Cookie[] cookies = request.getCookies();</code></li>
<li>通过 <code>request</code> 对象获取一个 <code>Cookie</code> 数组，包含了客户端本次请求发送过来的所有 Cookie。</li>
<li><strong>注意:</strong> 如果客户端没有发送任何 Cookie，此方法将返回 <code>null</code>，所以在使用前必须进行<strong>空指针判断</strong>。</li>
</ul>
</li>
<li><strong>读取 Cookie 的信息:</strong><ul>
<li><code>String name = cookie.getName();</code></li>
<li><code>String value = cookie.getValue();</code></li>
</ul>
</li>
</ol>
<p><strong>代码示例：记录用户访问次数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/visitCount&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitCountServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 尝试从请求中获/取名为 &quot;visitCount&quot; 的 Cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">targetCookie</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;visitCount&quot;</span>.equals(cookie.getName())) &#123;</span><br><span class="line">                    targetCookie = cookie;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (targetCookie != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 2. 如果 Cookie 存在，获取其值并加 1</span></span><br><span class="line">            count = Integer.parseInt(targetCookie.getValue()) + <span class="number">1</span>;</span><br><span class="line">            out.write(<span class="string">&quot;&lt;h1&gt;您好，这是您的第 &quot;</span> + count + <span class="string">&quot; 次访问！&lt;/h1&gt;&quot;</span>);</span><br><span class="line">            targetCookie.setValue(String.valueOf(count)); <span class="comment">// 更新 Cookie 的值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 如果 Cookie 不存在，说明是第一次访问</span></span><br><span class="line">            out.write(<span class="string">&quot;&lt;h1&gt;欢迎您，这是您的第一次访问！&lt;/h1&gt;&quot;</span>);</span><br><span class="line">            targetCookie = <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;visitCount&quot;</span>, String.valueOf(count));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 设置 Cookie 的有效期（例如 1 天）</span></span><br><span class="line">        targetCookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 将更新后的 Cookie 发送回客户端</span></span><br><span class="line">        response.addCookie(targetCookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-2-Cookie-的属性"><a href="#1-2-Cookie-的属性" class="headerlink" title="1.2 Cookie 的属性"></a>1.2 Cookie 的属性</h3><p>除了基本的 name 和 value，还可以设置 Cookie 的其他属性来控制其行为。</p>
<ul>
<li><code>void setMaxAge(int seconds)</code>: <strong>设置 Cookie 的有效期</strong><ul>
<li><strong>正数:</strong> 表示 Cookie 的存活秒数。Cookie 会被保存在客户端的硬盘上，浏览器关闭后依然有效。</li>
<li><strong>负数 (默认值):</strong> 表示 Cookie 仅在当前浏览器会话期间有效。Cookie 存储在浏览器内存中，一旦浏览器关闭，Cookie 就会被删除。</li>
<li><strong>零 (0):</strong> 表示<strong>立即删除</strong>该 Cookie。这是服务器端删除客户端 Cookie 的标准方法。</li>
</ul>
</li>
<li><code>void setPath(String uri)</code>: <strong>设置 Cookie 的有效路径</strong><ul>
<li>指定一个 URL 路径，只有当请求的路径是该路径或其子路径时，浏览器才会发送这个 Cookie。</li>
<li><strong>常用设置:</strong> <code>cookie.setPath(&quot;/&quot;);</code> 或 <code>cookie.setPath(request.getContextPath());</code>，使其对整个 Web 应用都有效。</li>
</ul>
</li>
<li><code>void setDomain(String pattern)</code>: <strong>设置 Cookie 的有效域名</strong><ul>
<li>用于跨子域共享 Cookie。例如，设置为 <code>.example.com</code>，则 <code>a.example.com</code> 和 <code>b.example.com</code> 都可以访问该 Cookie。</li>
</ul>
</li>
<li><code>void setHttpOnly(boolean isHttpOnly)</code>: <strong>（安全相关）</strong><ul>
<li>如果设置为 <code>true</code>，则该 Cookie <strong>不能被客户端的 JavaScript 脚本访问</strong>（通过 <code>document.cookie</code>）。这能有效防止<strong>跨站脚本攻击 (XSS)</strong> 窃取 Cookie。</li>
</ul>
</li>
<li><code>void setSecure(boolean flag)</code>: <strong>（安全相关）</strong><ul>
<li>如果 设置为 <code>true</code>，则该 Cookie <strong>只会在 HTTPS 连接中被发送</strong>，在普通的 HTTP 连接中不会被发送，可以防止在传输过程中被窃听。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-优缺点及应用场景"><a href="#1-3-优缺点及应用场景" class="headerlink" title="1.3 优缺点及应用场景"></a>1.3 优缺点及应用场景</h3><h4 id="1-3-1-优点"><a href="#1-3-1-优点" class="headerlink" title="1.3.1 优点:"></a>1.3.1 优点:</h4><ul>
<li><strong>API 简单：</strong> 使用起来非常方便。</li>
<li><strong>减轻服务器压力：</strong> 数据存储在客户端，不占用服务器内存。</li>
<li><strong>可持久化：</strong> 通过设置 <code>setMaxAge</code> 可以实现长时间保持状态。</li>
</ul>
<hr>
<h4 id="1-3-2-缺点"><a href="#1-3-2-缺点" class="headerlink" title="1.3.2 缺点"></a>1.3.2 缺点</h4><ul>
<li><strong>大小和数量限制：</strong> 大多数浏览器限制单个 Cookie 大小为 4KB 左右，每个域名下的 Cookie 数量也有限制（通常为 20-50 个）。</li>
<li><strong>安全性差：</strong> Cookie 以明文形式存储在客户端本地，并且在网络中明文传输，容易被窃取和篡改。<strong>绝对不能用 Cookie 存储敏感信息</strong>（如密码、银行卡号）。</li>
<li><strong>增加网络流量：</strong> 浏览器每次请求都会携带相关 Cookie，即使是请求图片、CSS 等静态资源，也会带上，造成不必要的流量浪费。</li>
<li><strong>用户可禁用：</strong> 用户可以在浏览器设置中禁用 Cookie，导致依赖 Cookie 的功能失效。</li>
</ul>
<hr>
<h4 id="1-3-3-应用场景"><a href="#1-3-3-应用场景" class="headerlink" title="1.3.3 应用场景"></a>1.3.3 应用场景</h4><ul>
<li><strong>“记住我”功能：</strong> 记录一个非敏感的、加密的用户令牌，用于下次访问时自动登录。</li>
<li><strong>购物车（早期实现）：</strong> 将商品 ID 存储在 Cookie 中，但现在更多使用 Session。</li>
<li><strong>个性化设置：</strong> 记录用户的偏好，如网站主题（白天&#x2F;夜间模式）、语言选择等。</li>
<li><strong>广告追踪：</strong> 跟踪用户在不同网站间的浏览行为，以推送相关广告。</li>
</ul>
<hr>
<h2 id="2-Session-HttpSession"><a href="#2-Session-HttpSession" class="headerlink" title="2. Session (HttpSession)"></a>2. Session (HttpSession)</h2><h3 id="2-1-Session-API"><a href="#2-1-Session-API" class="headerlink" title="2.1 Session API"></a>2.1 Session API</h3><p>主要通过 <code>request</code> 对象获取 <code>HttpSession</code> 对象，然后通过 <code>HttpSession</code> 对象进行操作。</p>
<ol>
<li><strong>获取&#x2F;创建 Session 对象:</strong><ul>
<li><code>HttpSession session = request.getSession();</code> (等同于 <code>request.getSession(true);</code>)<ul>
<li>这是<strong>最常用</strong>的方法。它的逻辑是：检查请求中是否有合法的 Session ID，如果有，则返回对应的 Session 对象；如果没有，则<strong>立即创建一个新的</strong> Session 对象并返回。</li>
</ul>
</li>
<li><code>HttpSession session = request.getSession(false);</code><ul>
<li>逻辑是：检查请求中是否有合法的 Session ID，如果有，则返回对应的 Session 对象；如果没有，<strong>不创建新的 Session</strong>，而是返回 <code>null</code>。</li>
<li>此方法常用于<strong>判断用户是否已登录</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>在 Session 中存取数据 (作为域对象):</strong><ul>
<li><code>void session.setAttribute(String name, Object value);</code><ul>
<li>将一个 Java 对象存入 Session。可以存储<strong>任何类型</strong>的对象，而不仅限于字符串。</li>
</ul>
</li>
<li><code>Object session.getAttribute(String name);</code><ul>
<li>根据名称从 Session 中获取对象。返回的是 <code>Object</code> 类型，需要进行强制类型转换。</li>
</ul>
</li>
<li><code>void session.removeAttribute(String name);</code><ul>
<li>从 Session 中移除指定的属性。</li>
</ul>
</li>
</ul>
</li>
<li><strong>管理 Session:</strong><ul>
<li><code>void session.invalidate();</code><ul>
<li><strong>使 Session 立即失效</strong>。这会清空 Session 中所有数据，并解除与客户端的绑定。这是实现**“用户注销”**功能的核心方法。</li>
</ul>
</li>
<li><code>String session.getId();</code><ul>
<li>获取 Session 的唯一 ID 字符串。</li>
</ul>
</li>
<li><code>void session.setMaxInactiveInterval(int seconds);</code><ul>
<li>设置 Session 的最大非活动时间（即超时时间），单位为秒。覆盖 <code>web.xml</code> 中的默认配置。</li>
</ul>
</li>
<li><code>int session.getMaxInactiveInterval();</code><ul>
<li>获取 Session 的超时时间。</li>
</ul>
</li>
<li><code>long session.getCreationTime();</code><ul>
<li>获取 Session 的创建时间（毫秒级时间戳）。</li>
</ul>
</li>
<li><code>boolean session.isNew();</code><ul>
<li>判断当前 Session 是否是新创建的（即客户端还不知道它的存在，ID 还未通过响应发送回去）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-2-Session-的生命周期"><a href="#2-2-Session-的生命周期" class="headerlink" title="2.2 Session 的生命周期"></a>2.2 Session 的生命周期</h3><ol>
<li><p><strong>创建 (Creation):</strong></p>
<ul>
<li>当客户端第一次访问服务器，并且代码中调用了 <code>request.getSession(true)</code> 或 <code>request.getSession()</code> 时，Session 对象被创建。</li>
</ul>
</li>
<li><p><strong>活动 (Active):</strong></p>
<ul>
<li>在 Session 的超时时间 (<code>maxInactiveInterval</code>) 内，只要客户端持续与服务器进行交互，Session 就一直处于活动状态。</li>
<li><strong>每次有效的客户端请求都会重置 Session 的计时器</strong>。例如，超时时间为 30 分钟，用户在第 29 分钟时访问了新页面，那么 Session 的生命周期会从此刻起重新再计算 30 分钟。</li>
</ul>
</li>
<li><p><strong>销毁 (Destruction):</strong><br>Session 在以下三种情况下会被销毁：</p>
<ul>
<li><p><strong>超时 (Timeout):</strong> 用户在指定的时间内（默认通常是 30 分钟，可在 <code>web.xml</code> 中配置）没有任何操作，服务器会自动销毁该 Session 以释放内存。这是最常见的销毁方式。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 web.xml 中配置全局 session 超时时间为 30 分钟 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>手动销毁 (Invalidation):</strong> 在代码中明确调用 <code>session.invalidate()</code> 方法，Session 会立即被销毁。常用于用户退出登录功能。</p>
</li>
<li><p><strong>服务器关闭 (Shutdown):</strong> 当 Web 服务器或应用正常关闭时，所有存在的 Session 都会被销毁。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-3-Cookie-与-Session-的区别与联系"><a href="#2-3-Cookie-与-Session-的区别与联系" class="headerlink" title="2.3 Cookie 与 Session 的区别与联系"></a>2.3 Cookie 与 Session 的区别与联系</h3><table>
<thead>
<tr>
<th>特性</th>
<th><strong>Cookie</strong></th>
<th><strong>Session</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据存储位置</strong></td>
<td><strong>客户端 (浏览器)</strong></td>
<td><strong>服务器端 (内存中)</strong></td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td><strong>低</strong>。数据暴露在客户端，易被窃取和篡改。</td>
<td><strong>高</strong>。数据存储在服务器，客户端只能接触到无意义的 Session ID。</td>
</tr>
<tr>
<td><strong>存储数据类型</strong></td>
<td><strong>String (字符串)</strong>，且不能包含特殊字符。</td>
<td><strong>Object (任何 Java 对象)</strong>。</td>
</tr>
<tr>
<td><strong>存储数据大小</strong></td>
<td><strong>小</strong>，单个 Cookie 约 4KB，数量也有限制。</td>
<td><strong>理论上无限制</strong>，但受限于服务器的内存大小。</td>
</tr>
<tr>
<td><strong>对服务器压力</strong></td>
<td><strong>无</strong>，不占用服务器资源。</td>
<td><strong>有</strong>，每个用户的 Session 都会占用服务器的内存资源。</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>可通过 <code>setMaxAge</code> 设置为长久有效（存硬盘），或会话级别（存内存）。</td>
<td>通常是会话级别，或由服务器超时策略决定。</td>
</tr>
<tr>
<td><strong>联系</strong></td>
<td><strong>Session 依赖 Cookie</strong> 来实现。服务器通过 <code>JSESSIONID</code> Cookie 来识别客户端对应的 Session。</td>
<td>Session 机制的实现通常需要 Cookie 的支持。</td>
</tr>
</tbody></table>
<hr>
<h1 id="四、Servlet-上下文与配置"><a href="#四、Servlet-上下文与配置" class="headerlink" title="四、Servlet 上下文与配置"></a>四、Servlet 上下文与配置</h1><h2 id="1-ServletContext-应用上下文"><a href="#1-ServletContext-应用上下文" class="headerlink" title="1. ServletContext (应用上下文)"></a>1. ServletContext (应用上下文)</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><strong><code>ServletContext</code></strong> 是一个<strong>全局性的接口</strong>，它代表了<strong>整个 Web 应用</strong>本身。 </p>
<p>当 Servlet 容器（如 Tomcat）启动一个 Web 应用时，它会为这个应用创建一个<strong>唯一</strong>的 <code>ServletContext</code> 实例。这个实例在 Web 应用被加载时创建，在 Web 应用被移除或服务器关闭时销毁。</p>
<p><strong>核心特性：</strong></p>
<ul>
<li><strong>唯一性：</strong> 每个 Web 应用（每个 <code>.war</code> 文件）只有一个 <code>ServletContext</code> 实例。</li>
<li><strong>全局性：</strong> 该实例被应用内的所有 Servlet、Filter 和 Listener 共享。</li>
<li><strong>生命周期：</strong> 与 Web 应用的生命周期相同。</li>
</ul>
<p>它提供了一种让应用中的不同组件（如多个 Servlet）相互通信和共享数据的方式。</p>
<hr>
<h3 id="1-2-获取方式"><a href="#1-2-获取方式" class="headerlink" title="1.2 获取方式"></a>1.2 获取方式</h3><ol>
<li><p><strong>在 Servlet 中获取：</strong></p>
<ul>
<li><p><strong>通过 <code>GenericServlet</code> 继承的方法（最常用）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过 <code>ServletConfig</code> 对象获取（通常在 <code>init</code> 方法中）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> config.getServletContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>通过 <code>HttpServletRequest</code> 对象获取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> request.getServletContext();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过 <code>HttpSession</code> 对象获取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> session.getServletContext();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 Listener 中获取：</strong></p>
<ul>
<li>在实现了 <code>ServletContextListener</code> 的监听器中，可以直接通过事件对象获取：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> sce.getServletContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="1-3-作用"><a href="#1-3-作用" class="headerlink" title="1.3 作用"></a>1.3 作用</h3><ol>
<li><p><strong>作为域对象，实现全局数据共享 (Application Scope):</strong></p>
<ul>
<li><code>ServletContext</code> 是三大作用域中范围最大的一个。存储在其中的数据，整个应用中的所有用户、所有请求都可以访问。</li>
<li><strong>API:</strong><ul>
<li><code>void setAttribute(String name, Object value)</code></li>
<li><code>Object getAttribute(String name)</code></li>
<li><code>void removeAttribute(String name)</code></li>
</ul>
</li>
<li><strong>典型应用场景：</strong><ul>
<li><strong>网站访问计数器：</strong> 可以在 <code>ServletContext</code> 中存放一个计数器，每次请求都对其加一。</li>
<li><strong>Web 应用的全局配置信息：</strong> 例如，数据库连接池对象、Spring 框架的 ApplicationContext 容器等重量级对象，通常会存储在 <code>ServletContext</code> 中，避免重复创建。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>获取全局初始化参数 (<code>&lt;context-param&gt;</code>):</strong></p>
<ul>
<li><p>可以在 <code>web.xml</code> 中配置对整个应用都有效的初始化参数，这些参数通过 <code>ServletContext</code> 来读取。</p>
</li>
<li><p><strong>web.xml 配置:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>appVersion<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Java 代码读取:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> context.getInitParameter(<span class="string">&quot;appVersion&quot;</span>); <span class="comment">// 返回 &quot;1.2.0&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这与 <code>ServletConfig</code> 的初始化参数不同，<code>ServletConfig</code> 的参数仅对单个 Servlet 有效。</p>
</li>
</ul>
</li>
<li><p><strong>获取 Web 应用中的资源:</strong></p>
<ul>
<li><p>这是 <code>ServletContext</code> 非常重要的一个功能，它允许你在不知道项目部署在服务器哪个物理位置的情况下，安全地访问项目内部的资源文件。</p>
</li>
<li><p><strong><code>InputStream getResourceAsStream(String path)</code> (推荐使用):</strong></p>
<ul>
<li>以输入流的形式返回指定路径的资源。路径必须以 <code>/</code> 开头，代表应用的根目录。</li>
<li>这是读取 <code>/WEB-INF/</code> 目录下资源（如配置文件 <code>config.properties</code>）的<strong>标准且最可靠</strong>的方式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取 /WEB-INF/classes/db.properties 文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> context.getResourceAsStream(<span class="string">&quot;/WEB-INF/classes/db.properties&quot;</span>);</span><br><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.load(in);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>String getRealPath(String path)</code> (谨慎使用):</strong></p>
<ul>
<li>将一个 Web 应用的相对路径转换为服务器上的<strong>绝对物理磁盘路径</strong>。</li>
<li><strong>缺点：</strong> 如果应用是以 <code>.war</code> 包形式直接运行而没有解压，或者在某些安全限制较高的环境中，此方法可能返回 <code>null</code> 或无法正常工作。因此，<code>getResourceAsStream</code> 是更佳选择。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能返回 D:\apache-tomcat\webapps\myapp\images\logo.png</span></span><br><span class="line"><span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> context.getRealPath(<span class="string">&quot;/images/logo.png&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>记录日志:</strong></p>
<ul>
<li><code>void log(String message)</code></li>
<li>可以将日志信息写入到 Servlet 容器的日志文件中（例如 Tomcat 的 <code>logs</code> 目录下的日志），方便进行调试和问题排查。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-三大作用域对象总结"><a href="#2-三大作用域对象总结" class="headerlink" title="2. 三大作用域对象总结"></a>2. 三大作用域对象总结</h2><h3 id="2-1-HttpServletRequest-request-scope"><a href="#2-1-HttpServletRequest-request-scope" class="headerlink" title="2.1 HttpServletRequest (request scope)"></a>2.1 <code>HttpServletRequest</code> (request scope)</h3><ul>
<li><strong>作用域名称：</strong> 请求域 (Request Scope)</li>
<li><strong>生命周期：</strong><ul>
<li><strong>开始：</strong> 当客户端发起一次 HTTP 请求到达服务器时创建。</li>
<li><strong>结束：</strong> 当服务器对该请求的响应完成并发送回客户端时销毁。</li>
<li>它是<strong>生命周期最短</strong>的作用域。</li>
</ul>
</li>
<li><strong>数据共享范围：</strong><ul>
<li>仅在<strong>同一次请求</strong>的处理过程中有效。</li>
<li>数据可以在通过<strong>请求转发 (<code>forward</code>)</strong> 跳转的多个 Servlet 和 JSP 之间共享。</li>
<li>一旦请求结束（例如，通过重定向 <code>redirect</code> 或用户点击新链接），<code>request</code> 对象及其中的数据就会被销毁。</li>
</ul>
</li>
<li><strong>典型应用场景：</strong><ul>
<li><strong>MVC 模式中的数据传递：</strong> Servlet (Controller) 处理完业务逻辑，将需要展示给用户的数据（如一个 <code>User</code> 对象或一个 <code>List</code> 集合）存入 <code>request</code> 域，然后<strong>转发</strong>到 JSP (View) 页面进行渲染。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-HttpSession-session-scope"><a href="#2-2-HttpSession-session-scope" class="headerlink" title="2.2 HttpSession (session scope)"></a>2.2 <code>HttpSession</code> (session scope)</h3><ul>
<li><strong>作用域名称：</strong> 会话域 (Session Scope)</li>
<li><strong>生命周期：</strong><ul>
<li><strong>开始：</strong> 当一个用户（浏览器）首次访问应用，并且代码调用 <code>request.getSession()</code> 时创建。</li>
<li><strong>结束：</strong> 以下三种情况之一发生时销毁：<ol>
<li>会话超时（用户长时间无操作）。</li>
<li>开发者手动调用 <code>session.invalidate()</code> 方法。</li>
<li>服务器关闭或 Web 应用被卸载。</li>
</ol>
</li>
</ul>
</li>
<li><strong>数据共享范围：</strong><ul>
<li>在<strong>同一个用户（浏览器）的多次请求之间</strong>有效。</li>
<li>数据对于当前用户是私有的，其他用户无法访问。</li>
</ul>
</li>
<li><strong>典型应用场景：</strong><ul>
<li><strong>跟踪用户状态：</strong><ul>
<li><strong>用户登录：</strong> 存储用户的登录信息，判断用户是否已登录。</li>
<li><strong>购物车：</strong> 存储用户添加到购物车中的商品列表。</li>
<li><strong>在线表单：</strong> 在多步骤的表单提交中，临时保存用户已填写的信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-ServletContext-application-scope"><a href="#2-3-ServletContext-application-scope" class="headerlink" title="2.3 ServletContext (application scope)"></a>2.3 <code>ServletContext</code> (application scope)</h3><ul>
<li><strong>作用域名称：</strong> 应用域 &#x2F; 上下文域 (Application Scope)</li>
<li><strong>生命周期：</strong><ul>
<li><strong>开始：</strong> 当 Web 应用在服务器上被加载（启动）时创建。</li>
<li><strong>结束：</strong> 当 Web 应用被卸载或服务器关闭时销毁。</li>
<li>它是<strong>生命周期最长</strong>的作用域，与 Web 应用共存亡。</li>
</ul>
</li>
<li><strong>数据共享范围：</strong><ul>
<li>在<strong>整个 Web 应用的所有用户、所有请求之间</strong>共享。</li>
<li>它是全局的，任何一个用户存入的数据，其他所有用户都能访问到。</li>
</ul>
</li>
<li><strong>典型应用场景：</strong><ul>
<li><strong>存储全局性、共享性的资源：</strong><ul>
<li><strong>网站访问量计数器。</strong></li>
<li><strong>数据库连接池</strong>、<strong>Spring IoC 容器</strong>等重量级对象，只需创建一次，供整个应用使用。</li>
<li><strong>应用范围的配置信息</strong>，如从 <code>web.xml</code> 中读取的 <code>&lt;context-param&gt;</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-Servlet-配置"><a href="#3-Servlet-配置" class="headerlink" title="3. Servlet 配置"></a>3. Servlet 配置</h2><h3 id="3-1-传统方式：web-xml-部署描述符"><a href="#3-1-传统方式：web-xml-部署描述符" class="headerlink" title="3.1 传统方式：web.xml (部署描述符)"></a>3.1 传统方式：<code>web.xml</code> (部署描述符)</h3><p>在 Servlet 3.0 规范之前，<strong><code>web.xml</code> 文件是唯一</strong>的配置方式。这个文件位于 Web 应用的 <code>WEB-INF</code> 目录下，是整个应用的部署描述符 。</p>
<p>配置一个 Servlet 通常需要两个核心标签：<code>&lt;servlet&gt;</code> 和 <code>&lt;servlet-mapping&gt;</code>。</p>
<ol>
<li><strong><code>&lt;servlet&gt;</code> 标签：声明一个 Servlet</strong><ul>
<li><strong>作用：</strong> 向容器注册一个 Servlet，给它起一个内部使用的逻辑名称，并指定它的完整类路径。</li>
<li><strong>子标签：</strong><ul>
<li><code>&lt;servlet-name&gt;</code>: 为 Servlet 指定一个唯一的、自定义的名称。这个名称在 <code>web.xml</code> 内部用作引用。</li>
<li><code>&lt;servlet-class&gt;</code>: 指定该 Servlet 的<strong>完整类名</strong>（包名 + 类名）。</li>
<li><code>&lt;init-param&gt;</code>: (可选) 为该 Servlet 配置初始化参数。</li>
<li><code>&lt;load-on-startup&gt;</code>: (可选) 配置 Servlet 的加载时机。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>&lt;servlet-mapping&gt;</code> 标签：映射 Servlet 的访问路径</strong><ul>
<li><strong>作用：</strong> 将一个已声明的 Servlet 与一个或多个 URL 模式关联起来。</li>
<li><strong>子标签：</strong><ul>
<li><code>&lt;servlet-name&gt;</code>: 必须与 <code>&lt;servlet&gt;</code> 标签中定义的某个 <code>&lt;servlet-name&gt;</code> <strong>完全匹配</strong>，以此建立关联。</li>
<li><code>&lt;url-pattern&gt;</code>: 定义客户端可以通过哪个 URL 路径来访问这个 Servlet。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong><code>web.xml</code> 示例：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1. 声明一个名为 &quot;loginServlet&quot; 的 Servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>loginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.example.web.LoginServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 配置启动时加载，数字越小优先级越高 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 将 URL &quot;/login&quot; 映射到 &quot;loginServlet&quot; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>loginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当用户访问 <code>http://.../应用名/login</code> 时，Tomcat 就会调用 <code>com.example.web.LoginServlet</code> 的 <code>service</code> 方法。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>集中管理：</strong> 所有配置集中在一个文件中，方便查看整个应用的路由结构。</li>
<li><strong>修改方便：</strong> 可以在不重新编译 Java 代码的情况下修改 URL 映射。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>繁琐：</strong> 在大型项目中，<code>web.xml</code> 文件会变得异常庞大和复杂，难以维护。</li>
<li><strong>分散：</strong> 配置信息与代码本身分离，降低了代码的内聚性。</li>
</ul>
<hr>
<h3 id="3-2-现代方式：注解-Servlet-3-0"><a href="#3-2-现代方式：注解-Servlet-3-0" class="headerlink" title="3.2 现代方式：注解 (Servlet 3.0+)"></a>3.2 现代方式：注解 (Servlet 3.0+)</h3><p>从 <strong>Servlet 3.0 规范</strong>开始，引入了注解的方式来配置 Servlet，大大简化了开发过程。<strong>这是目前主流的配置方式</strong>。</p>
<ol>
<li><strong><code>@WebServlet</code> 注解</strong><ul>
<li><strong>作用：</strong> 直接在 Servlet 的 Java 类上使用此注解，即可完成声明和映射，<strong>完全替代</strong>了 <code>web.xml</code> 中的 <code>&lt;servlet&gt;</code> 和 <code>&lt;servlet-mapping&gt;</code>。</li>
<li><strong>常用属性：</strong><ul>
<li><code>value</code> 或 <code>urlPatterns</code>: 指定一个或多个 URL 模式。这是最常用的属性。<ul>
<li>例如：<code>@WebServlet(&quot;/login&quot;)</code></li>
<li>例如：<code>@WebServlet(urlPatterns = {&quot;/user/login&quot;, &quot;/user/auth&quot;})</code></li>
</ul>
</li>
<li><code>name</code>: (可选) 相当于 <code>&lt;servlet-name&gt;</code>。如果不指定，容器会默认使用类的全名。</li>
<li><code>loadOnStartup</code>: (可选) 相当于 <code>&lt;load-on-startup&gt;</code>，用于设置加载时机。</li>
<li><code>initParams</code>: (可选) 相当于 <code>&lt;init-param&gt;</code>，用于配置初始化参数，需要与 <code>@WebInitParam</code> 注解配合使用。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>@WebInitParam</code> 注解</strong><ul>
<li><strong>作用：</strong> 用于在 <code>@WebServlet</code> 的 <code>initParams</code> 属性中定义初始化参数。</li>
<li><strong>属性：</strong> <code>name</code> 和 <code>value</code>。</li>
</ul>
</li>
</ol>
<p><strong>注解示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 @WebServlet 注解完成所有配置</span></span><br><span class="line"><span class="meta">@WebServlet(</span></span><br><span class="line"><span class="meta">    name = &quot;loginServlet&quot;,</span></span><br><span class="line"><span class="meta">    urlPatterns = &#123;&quot;/login&quot;, &quot;/signin&quot;&#125;, // 映射了两个 URL</span></span><br><span class="line"><span class="meta">    loadOnStartup = 1,</span></span><br><span class="line"><span class="meta">    initParams = &#123;</span></span><br><span class="line"><span class="meta">        @WebInitParam(name = &quot;loginPage&quot;, value = &quot;/login.jsp&quot;),</span></span><br><span class="line"><span class="meta">        @WebInitParam(name = &quot;errorPage&quot;, value = &quot;/error.jsp&quot;)</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 读取初始化参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">loginPage</span> <span class="operator">=</span> <span class="built_in">this</span>.getInitParameter(<span class="string">&quot;loginPage&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Login Page from init param: &quot;</span> + loginPage);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;This is the Login Servlet configured by Annotation.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的效果与上面的 <code>web.xml</code> 示例完全相同，但配置与代码紧密结合，更加清晰直观。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>简洁方便：</strong> 代码量大大减少，无需繁琐的 XML 配置。</li>
<li><strong>内聚性高：</strong> 配置信息和它所配置的类放在一起，提高了代码的可读性和可维护性。</li>
<li><strong>IDE 支持良好：</strong> 现代 IDE 对注解有很好的支持，可以方便地进行导航和重构。</li>
</ul>
<hr>
<h1 id="五、过滤器-Filter-与监听器-Listener"><a href="#五、过滤器-Filter-与监听器-Listener" class="headerlink" title="五、过滤器 (Filter) 与监听器 (Listener)"></a>五、过滤器 (Filter) 与监听器 (Listener)</h1><h2 id="1-Filter-过滤器"><a href="#1-Filter-过滤器" class="headerlink" title="1. Filter (过滤器)"></a>1. Filter (过滤器)</h2><h3 id="1-1-定义-1"><a href="#1-1-定义-1" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p><strong>Filter (过滤器)</strong> 是一个实现了 <code>javax.servlet.Filter</code> 接口的 Java 对象，它位于客户端请求和目标资源（如 Servlet、JSP 或静态文件）之间，用于<strong>拦截和处理请求与响应</strong>。</p>
<p><strong>核心作用：</strong></p>
<ul>
<li><strong>预处理请求：</strong> 在请求到达 Servlet 之前，可以检查、修改请求头和请求数据。</li>
<li><strong>后处理响应：</strong> 在响应发送给客户端之前，可以修改响应头和响应内容。</li>
<li><strong>拦截请求：</strong> 可以决定是否将请求继续传递给目标资源，或者直接中断请求流程（例如，用户未登录时跳转到登录页面）。</li>
</ul>
<p>Filter 是一种典型的<strong>责任链模式 (Chain of Responsibility Pattern)</strong> 的应用，它提供了一种对 Web 资源进行“横切”关注（如日志、安全、编码）的强大机制，而无需修改 Servlet 本身的代码，实现了<strong>低耦合</strong>。</p>
<hr>
<h3 id="1-2-Filter-生命周期"><a href="#1-2-Filter-生命周期" class="headerlink" title="1.2 Filter 生命周期"></a>1.2 Filter 生命周期</h3><p>Filter 的生命周期由 Servlet 容器管理，与 Servlet 非常相似，也包含三个核心方法：</p>
<ol>
<li><strong><code>void init(FilterConfig filterConfig)</code>: 初始化</strong><ul>
<li><strong>调用时机：</strong> Web 应用启动时，容器会创建 Filter 实例，并<strong>立即调用</strong> <code>init()</code> 方法。</li>
<li><strong>调用次数：</strong> 在 Filter 的整个生命周期中<strong>只调用一次</strong>。</li>
<li><strong>作用：</strong> 用于执行一次性的初始化任务，例如加载配置文件、创建数据库连接等。<code>FilterConfig</code> 对象可以用来获取初始化参数和 <code>ServletContext</code> 对象。</li>
</ul>
</li>
<li><strong><code>void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</code>: 执行过滤</strong><ul>
<li><strong>调用时机：</strong> <strong>每一次</strong>匹配该 Filter 的 URL 模式的请求到达时，容器都会调用此方法。</li>
<li><strong>调用次数：</strong> <strong>多次</strong>。这是 Filter 的核心工作方法。</li>
<li><strong>作用：</strong> 实现具体的过滤逻辑。<ul>
<li><strong><code>chain.doFilter(request, response)</code></strong> 是这个方法中最关键的一行代码。</li>
<li><strong>放行操作：</strong> 调用 <code>chain.doFilter()</code> 会将请求传递给过滤器链中的下一个 Filter，或者如果已经是最后一个 Filter，则传递给目标资源（Servlet）。</li>
<li><strong>代码位置决定处理时机：</strong><ul>
<li>在 <code>chain.doFilter()</code> <strong>之前</strong>写的代码，是对<strong>请求 (Request)</strong> 的预处理。</li>
<li>在 <code>chain.doFilter()</code> <strong>之后</strong>写的代码，是对<strong>响应 (Response)</strong> 的后处理。</li>
</ul>
</li>
<li><strong>拦截操作：</strong> 如果在方法中<strong>不调用</strong> <code>chain.doFilter()</code>，则请求将被拦截，不会继续向下传递。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>void destroy()</code>: 销毁</strong><ul>
<li><strong>调用时机：</strong> Web 应用被卸载或服务器关闭时，容器会调用 <code>destroy()</code> 方法。</li>
<li><strong>调用次数：</strong> <strong>只调用一次</strong>。</li>
<li><strong>作用：</strong> 用于释放 <code>init()</code> 方法中创建的资源，例如关闭数据库连接、文件流等。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-3-FilterChain-过滤器链"><a href="#1-3-FilterChain-过滤器链" class="headerlink" title="1.3 FilterChain (过滤器链)"></a>1.3 <code>FilterChain</code> (过滤器链)</h3><p>当一个请求的 URL 同时匹配多个 Filter 的映射规则时，Servlet 容器会将这些 Filter 按照它们在 <code>web.xml</code> 中配置的顺序（或者注解的特定顺序，但 XML 提供了更明确的控制）组织成一个<strong>过滤器链 (<code>FilterChain</code>)</strong>。</p>
<pre><code class="highlight mermaid">sequenceDiagram
    actor Client
    participant Filter1
    participant Filter2
    participant Servlet

    rect rgb(235, 245, 255)
        note over Client, Servlet: 请求阶段 (Request Flow)
        Client-&gt;&gt;+Filter1: 1. 发起 HTTP Request
        note right of Filter1: 2. 执行 chain.doFilter() 之前的代码
        Filter1-&gt;&gt;+Filter2: 3. 调用 chain.doFilter()
        note right of Filter2: 4. 执行 chain.doFilter() 之前的代码
        Filter2-&gt;&gt;+Servlet: 5. 调用 chain.doFilter()
        note right of Servlet: 6. Servlet.service() 处理请求
    end

    rect rgb(255, 245, 235)
        note over Client, Servlet: 响应阶段 (Response Flow)
        Servlet--&gt;&gt;-Filter2: 7. 生成 HTTP Response 并返回
        note left of Filter2: 8. 执行 chain.doFilter() 之后的代码
        Filter2--&gt;&gt;-Filter1: (继续返回)
        note left of Filter1: 8. 执行 chain.doFilter() 之后的代码
        Filter1--&gt;&gt;-Client: 9. 最终响应返回给客户端
    end</code></pre>

<p><strong>工作流程:</strong></p>
<ol>
<li>请求首先到达链中的第一个 Filter (<code>Filter1</code>)。</li>
<li><code>Filter1</code> 执行其 <code>doFilter()</code> 方法中 <code>chain.doFilter()</code> 之前的代码。</li>
<li><code>Filter1</code> 调用 <code>chain.doFilter()</code>，控制权转移给链中的第二个 Filter (<code>Filter2</code>)。</li>
<li><code>Filter2</code> 执行其 <code>doFilter()</code> 方法…以此类推，直到最后一个 Filter。</li>
<li>最后一个 Filter 调用 <code>chain.doFilter()</code>，请求最终到达目标 Servlet。</li>
<li>Servlet 处理请求，生成响应。</li>
<li>响应沿着<strong>相反的路径</strong>返回，依次经过链中的每个 Filter。</li>
<li>每个 Filter 执行其 <code>doFilter()</code> 方法中 <code>chain.doFilter()</code> <strong>之后</strong>的代码，可以对响应进行处理。</li>
<li>最终，响应从第一个 Filter 发送回客户端。</li>
</ol>
<hr>
<h3 id="1-4-配置"><a href="#1-4-配置" class="headerlink" title="1.4 配置"></a>1.4 配置</h3><p>与 Servlet 类似，Filter 也有两种配置方式：</p>
<ol>
<li><p><strong>传统方式 (<code>web.xml</code>)</strong></p>
<ul>
<li><strong><code>&lt;filter&gt;</code> 标签：</strong> 声明一个 Filter。<ul>
<li><code>&lt;filter-name&gt;</code>: Filter 的逻辑名称。</li>
<li><code>&lt;filter-class&gt;</code>: Filter 的完整类名。</li>
</ul>
</li>
<li><strong><code>&lt;filter-mapping&gt;</code> 标签：</strong> 映射 Filter。<ul>
<li><code>&lt;filter-name&gt;</code>: 与 <code>&lt;filter&gt;</code> 中的名称对应。</li>
<li><code>&lt;url-pattern&gt;</code>: 指定要过滤的 URL 模式（如 <code>/*</code>, <code>/admin/*</code>, <code>*.do</code>）。</li>
<li><code>&lt;dispatcher&gt;</code>: (可选) 指定 Filter 拦截的请求类型，可以是 <code>REQUEST</code> (默认), <code>FORWARD</code>, <code>INCLUDE</code>, <code>ERROR</code>。</li>
</ul>
</li>
</ul>
<p><strong><code>web.xml</code> 示例:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.example.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!-- 拦截所有请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>现代方式 (注解 <code>@WebFilter</code>)</strong></p>
<ul>
<li>在 Filter 实现类上使用 <code>@WebFilter</code> 注解即可完成配置。</li>
<li><strong>常用属性:</strong> <code>urlPatterns</code> (或 <code>value</code>), <code>filterName</code>, <code>initParams</code>, <code>dispatcherTypes</code>。</li>
</ul>
<p><strong>注解示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span> <span class="comment">// 拦截所有请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharacterEncodingFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 预处理：设置请求编码</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将请求传递下去</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 后处理：可以设置响应编码，但通常在 Servlet 中设置更灵活</span></span><br><span class="line">        <span class="comment">// response.setContentType(&quot;text/html;charset=UTF-8&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// init 和 destroy 方法可以留空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="1-5-典型应用场景"><a href="#1-5-典型应用场景" class="headerlink" title="1.5 典型应用场景"></a>1.5 典型应用场景</h3><p>Filter 的应用非常广泛，是许多 Web 框架实现核心功能的基础。</p>
<ul>
<li><strong>统一字符编码 (Character Encoding Filter):</strong><ul>
<li>这是最经典的应用。创建一个 Filter 拦截所有请求，在 <code>doFilter</code> 方法中统一设置 <code>request.setCharacterEncoding(&quot;UTF-8&quot;)</code>，一劳永逸地解决全站的 POST 请求中文乱码问题。</li>
</ul>
</li>
<li><strong>用户登录验证 (Authentication Filter):</strong><ul>
<li>拦截需要登录才能访问的资源（如 <code>/admin/*</code>）。</li>
<li>检查 <code>HttpSession</code> 中是否存在用户登录信息。</li>
<li>如果存在，则调用 <code>chain.doFilter()</code> 放行。</li>
<li>如果不存在，则重定向到登录页面，并且<strong>不调用</strong> <code>chain.doFilter()</code> 来中断请求。</li>
</ul>
</li>
<li><strong>权限控制 (Authorization Filter):</strong><ul>
<li>在用户已登录的基础上，检查用户是否拥有访问特定资源的权限（如角色是管理员还是普通用户）。</li>
<li>如果没有权限，则跳转到“无权限”提示页面。</li>
</ul>
</li>
<li><strong>请求日志记录 (Logging Filter):</strong><ul>
<li>记录每个请求的详细信息，如来源 IP、请求 URL、请求参数、处理时长等，用于系统监控和问题排查。</li>
</ul>
</li>
<li><strong>数据压缩 (GZIP Compression Filter):</strong><ul>
<li>拦截响应，将响应体（如 HTML, CSS, JS）进行 GZIP 压缩，并在响应头中设置 <code>Content-Encoding: gzip</code>，可以显著减少传输大小，加快页面加载速度。</li>
</ul>
</li>
<li><strong>XSS&#x2F;CSRF 安全防护:</strong><ul>
<li>创建 Filter 来包装 <code>HttpServletRequest</code> 对象，重写 <code>getParameter()</code> 等方法，对传入的参数进行过滤和转义，防止跨站脚本攻击 (XSS)。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-Listener-监听器"><a href="#2-Listener-监听器" class="headerlink" title="2. Listener (监听器)"></a>2. Listener (监听器)</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p><strong>Listener (监听器)</strong> 是一种特殊的 Java 类，它实现了 Servlet API 中特定的监听器接口。它的作用是<strong>被动地监听</strong> Web 应用中特定<strong>事件</strong>的发生，并在事件发生时执行预定义的代码。</p>
<p>你可以把它想象成一个**“事件报警器”<strong>或</strong>“订阅者”**。它在 Web 应用的生命周期中静静地等待，当它所“订阅”的事件（例如：应用启动、Session 创建、请求到达）发生时，Servlet 容器会自动通知它，并调用其相应的方法。</p>
<p><strong>核心特点：</strong></p>
<ul>
<li><strong>事件驱动 (Event-Driven):</strong> 监听器的工作模式是基于事件的，而不是像 Servlet 或 Filter 那样直接处理请求。</li>
<li><strong>被动触发:</strong> 我们不直接调用监听器的方法，而是由 Servlet 容器在特定事件发生时自动回调。</li>
<li><strong>全局监控:</strong> 监听器提供了一种从宏观层面监控和干预 Web 应用状态变化的方式。</li>
</ul>
<hr>
<h3 id="2-2-分类"><a href="#2-2-分类" class="headerlink" title="2.2 分类"></a>2.2 分类</h3><p>Servlet API 提供了多种监听器接口，根据它们监听的<strong>事件源</strong>和<strong>事件类型</strong>，主要可以分为三大类：</p>
<h4 id="2-2-1-监听作用域对象生命周期的-Listener"><a href="#2-2-1-监听作用域对象生命周期的-Listener" class="headerlink" title="2.2.1 监听作用域对象生命周期的 Listener"></a>2.2.1 监听作用域对象生命周期的 Listener</h4><p>这类监听器关注三大作用域对象（<code>ServletContext</code>, <code>HttpSession</code>, <code>ServletRequest</code>）的<strong>创建和销毁</strong>。</p>
<ul>
<li><strong><code>ServletContextListener</code> (最常用):</strong><ul>
<li><strong>监听对象:</strong> <code>ServletContext</code> (整个 Web 应用)</li>
<li><strong>事件:</strong> Web 应用的启动和关闭。</li>
<li><strong>方法:</strong><ul>
<li><code>contextInitialized(ServletContextEvent sce)</code>: 在 Web 应用<strong>被加载</strong>时调用。</li>
<li><code>contextDestroyed(ServletContextEvent sce)</code>: 在 Web 应用<strong>被卸载</strong>时调用。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>HttpSessionListener</code>:</strong><ul>
<li><strong>监听对象:</strong> <code>HttpSession</code> (用户会话)</li>
<li><strong>事件:</strong> 一个会话的创建和销毁。</li>
<li><strong>方法:</strong><ul>
<li><code>sessionCreated(HttpSessionEvent se)</code>: 在一个<strong>新会话被创建</strong>时调用。</li>
<li><code>sessionDestroyed(HttpSessionEvent se)</code>: 在一个<strong>会话失效或被销毁</strong>时调用。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>ServletRequestListener</code>:</strong><ul>
<li><strong>监听对象:</strong> <code>ServletRequest</code> (一次请求)</li>
<li><strong>事件:</strong> 一次 HTTP 请求的开始和结束。</li>
<li><strong>方法:</strong><ul>
<li><code>requestInitialized(ServletRequestEvent sre)</code>: 在一个<strong>请求到达</strong> Servlet 容器时调用。</li>
<li><code>requestDestroyed(ServletRequestEvent sre)</code>: 在一个<strong>请求处理完毕</strong>并即将离开容器时调用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-2-监听作用域对象属性变化的-Listener"><a href="#2-2-2-监听作用域对象属性变化的-Listener" class="headerlink" title="2.2.2 监听作用域对象属性变化的 Listener"></a>2.2.2 监听作用域对象属性变化的 Listener</h4><p>这类监听器关注三大作用域对象中<strong>属性 (Attribute) 的添加、移除和替换</strong>。</p>
<ul>
<li><strong><code>ServletContextAttributeListener</code>:</strong> 监听 <code>ServletContext</code> 中属性的变化。</li>
<li><strong><code>HttpSessionAttributeListener</code>:</strong> 监听 <code>HttpSession</code> 中属性的变化。</li>
<li><strong><code>ServletRequestAttributeListener</code>:</strong> 监听 <code>ServletRequest</code> 中属性的变化。</li>
<li><strong>它们都包含三个方法:</strong><ul>
<li><code>attributeAdded(...)</code>: 当调用 <code>setAttribute</code> 添加一个新属性时触发。</li>
<li><code>attributeRemoved(...)</code>: 当调用 <code>removeAttribute</code> 时触发。</li>
<li><code>attributeReplaced(...)</code>: 当调用 <code>setAttribute</code> 替换一个同名旧属性时触发。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-3-监听-Session-中对象状态的-Listener"><a href="#2-2-3-监听-Session-中对象状态的-Listener" class="headerlink" title="2.2.3 监听 Session 中对象状态的 Listener"></a>2.2.3 监听 Session 中对象状态的 Listener</h4><p>这类监听器由<strong>被存入 Session 的对象本身</strong>来实现，用于感知自己何时被绑定到 Session 或从 Session 解绑。</p>
<ul>
<li><strong><code>HttpSessionBindingListener</code>:</strong><ul>
<li>当一个<strong>实现了此接口的对象</strong>被 <code>session.setAttribute()</code> 存入 Session 或被 <code>session.removeAttribute()</code> 移除时，该对象自身的方法会被调用。</li>
<li><strong>方法:</strong> <code>valueBound(...)</code>, <code>valueUnbound(...)</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-3-配置"><a href="#2-3-配置" class="headerlink" title="2.3 配置"></a>2.3 配置</h3><p>与 Servlet 和 Filter 一样，监听器也支持 <code>web.xml</code> 和注解两种配置方式。</p>
<ol>
<li><p><strong>传统方式 (<code>web.xml</code>)</strong></p>
<ul>
<li>使用 <code>&lt;listener&gt;</code> 标签来声明一个监听器。</li>
<li>它只有一个子标签 <code>&lt;listener-class&gt;</code>，用于指定监听器的完整类名。</li>
</ul>
<p><strong><code>web.xml</code> 示例:</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.example.listener.MyAppContextListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>现代方式 (注解 <code>@WebListener</code>)</strong></p>
<ul>
<li>在监听器实现类上添加 <code>@WebListener</code> 注解即可。</li>
<li>这是一个标记注解，没有任何属性。容器在启动时会自动扫描带有此注解的类并注册它们。</li>
</ul>
<p><strong>注解示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAppContextListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Web Application is starting up...&quot;</span>);</span><br><span class="line">        <span class="comment">// 在这里执行初始化任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Web Application is shutting down...&quot;</span>);</span><br><span class="line">        <span class="comment">// 在这里执行清理任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="2-4-典型应用场景"><a href="#2-4-典型应用场景" class="headerlink" title="2.4 典型应用场景"></a>2.4 典型应用场景</h3><p>监听器在框架和大型应用中扮演着至关重要的“引导”和“监控”角色。</p>
<ul>
<li><strong>使用 <code>ServletContextListener</code>:</strong><ul>
<li><strong>初始化全局资源 (重量级应用):</strong><ul>
<li>创建和初始化<strong>数据库连接池</strong>（如 HikariCP, C3P0）。</li>
<li>加载和解析全局<strong>配置文件</strong> (<code>.properties</code>, <code>.xml</code>)。</li>
<li>启动<strong>定时任务</strong>调度器（如 Quartz）。</li>
<li><strong>初始化 IoC 容器</strong>，例如 Spring 框架的 <code>ContextLoaderListener</code> 就是一个典型的 <code>ServletContextListener</code>，它负责在应用启动时创建和加载 Spring 的应用上下文。</li>
</ul>
</li>
<li><strong>应用关闭时释放资源：</strong> 在 <code>contextDestroyed</code> 方法中，优雅地关闭数据库连接池、停止定时任务等。</li>
</ul>
</li>
<li><strong>使用 <code>HttpSessionListener</code>:</strong><ul>
<li><strong>统计在线用户数量：</strong><ul>
<li>在 <code>sessionCreated</code> 方法中，将一个全局计数器（通常存放在 <code>ServletContext</code> 中）加一。</li>
<li>在 <code>sessionDestroyed</code> 方法中，将该计数器减一。</li>
</ul>
</li>
<li><strong>监控用户会话：</strong> 记录用户会话的创建和销毁日志，用于行为分析或问题排查。</li>
</ul>
</li>
<li><strong>使用 <code>ServletRequestListener</code>:</strong><ul>
<li><strong>记录请求处理时长：</strong> 在 <code>requestInitialized</code> 中记录开始时间戳，在 <code>requestDestroyed</code> 中记录结束时间戳，计算并记录每个请求的耗时，用于性能监控。</li>
</ul>
</li>
<li><strong>使用 <code>HttpSessionAttributeListener</code>:</strong><ul>
<li><strong>监控敏感信息：</strong> 监听 <code>HttpSession</code> 中特定属性（如用户信息、权限列表）的变化，当这些信息被修改时，记录日志以备审计。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="六、高级主题与实践"><a href="#六、高级主题与实践" class="headerlink" title="六、高级主题与实践"></a>六、高级主题与实践</h1><h2 id="1-Servlet-与-JSP-的关系-MVC-模式"><a href="#1-Servlet-与-JSP-的关系-MVC-模式" class="headerlink" title="1. Servlet 与 JSP 的关系 (MVC 模式)"></a>1. Servlet 与 JSP 的关系 (MVC 模式)</h2><h3 id="1-1-JSP的本质"><a href="#1-1-JSP的本质" class="headerlink" title="1.1 JSP的本质"></a>1.1 JSP的本质</h3><p><strong>JSP (JavaServer Pages) 的本质就是一个 Servlet。</strong></p>
<p>这可能是理解 JSP 文件并不是直接由浏览器执行的，它是一个<strong>模板</strong>，最终会被 Servlet 容器（如 Tomcat 内置的 Jasper 引擎）转换为一个 <code>.java</code> 的 Servlet 源文件，然后编译成一个 <code>.class</code> 文件来运行。</p>
<p><strong>转换过程（第一次访问 JSP 时发生）：</strong></p>
<ol>
<li><strong>翻译 (Translate):</strong> JSP 引擎解析 <code>.jsp</code> 文件。<ul>
<li>文件中的静态 HTML 部分被转换为 Java 代码中的 <code>out.println(&quot;&lt;html&gt;...&quot;);</code> 语句。</li>
<li>JSP 脚本元素，如 Scriptlet (<code>&lt;% ... %&gt;</code>) 和表达式 (<code>&lt;%= ... %&gt;</code>)，被原样插入到生成的 Servlet 的 <code>_jspService()</code> 方法中。</li>
</ul>
</li>
<li><strong>编译 (Compile):</strong> 容器调用 Java 编译器将这个生成的 <code>.java</code> 文件编译成 <code>.class</code> 文件。</li>
<li><strong>执行 (Execute):</strong> 容器加载并执行这个编译好的 Servlet 类，其生命周期和普通 Servlet 一样。</li>
</ol>
<p><strong>为什么要有 JSP？</strong></p>
<p>JSP 的诞生是为了解决早期 Servlet 开发的一个巨大痛点：在 Servlet 的 Java 代码中通过 <code>out.println()</code> 来拼接复杂的 HTML 页面是一场噩梦，难以编写和维护。</p>
<ul>
<li><strong>Servlet 的优势：</strong> 擅长处理 Java 逻辑、控制流程、处理业务。<strong>（逻辑强，表现弱）</strong></li>
<li><strong>JSP 的优势：</strong> 擅长展示动态内容，可以在 HTML 中嵌入少量 Java 代码。<strong>（表现强，逻辑弱）</strong></li>
</ul>
<p>因此，最佳实践就是让它们各司其职。</p>
<hr>
<h3 id="1-2-MVC-设计模式"><a href="#1-2-MVC-设计模式" class="headerlink" title="1.2 MVC 设计模式"></a>1.2 MVC 设计模式</h3><p><strong>MVC (Model-View-Controller)</strong> 是一种经典的软件设计模式，旨在将应用程序的关注点分离，使其更易于维护、扩展和测试。在 Java Web 应用中，Servlet 和 JSP 完美地契合了 MVC 模式中的角色。</p>
<ul>
<li><strong>Model (模型):</strong><ul>
<li><strong>职责：</strong> 负责应用程序的<strong>业务逻辑</strong>和<strong>数据</strong>。它封装了应用的核心状态和行为，与表示层和控制层解耦。</li>
<li><strong>在 Java Web 中通常是：</strong><ul>
<li>JavaBean &#x2F; POJO (Plain Old Java Object) 用来封装数据。</li>
<li>Service 层类用来处理业务逻辑。</li>
<li>DAO (Data Access Object) 层类用来与数据库交互。</li>
</ul>
</li>
</ul>
</li>
<li><strong>View (视图):</strong><ul>
<li><strong>职责：</strong> 负责<strong>展示数据</strong>，即用户界面。它从模型中获取数据并将其呈现给用户。视图本身应包含最少的业务逻辑。</li>
<li><strong>在 Java Web 中通常是：</strong><ul>
<li><strong>JSP</strong>、HTML、Thymeleaf 等模板引擎。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Controller (控制器):</strong><ul>
<li><strong>职责：</strong> 充当<strong>调度者</strong>。它接收来自用户的请求，调用相应的模型来处理请求，然后选择合适的视图来渲染模型返回的数据，最终将视图的输出返回给用户。</li>
<li><strong>在 Java Web 中通常是：</strong><ul>
<li><strong>Servlet</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-3-Servlet-与-JSP-在-MVC-中的协作流程："><a href="#1-3-Servlet-与-JSP-在-MVC-中的协作流程：" class="headerlink" title="1.3 Servlet 与 JSP 在 MVC 中的协作流程："></a>1.3 Servlet 与 JSP 在 MVC 中的协作流程：</h3><pre><code class="highlight mermaid">sequenceDiagram
    title Classic Java Web MVC (Servlet + JSP) Flow

    participant Browser as 用户浏览器
    participant Servlet/Controller as 控制器
    participant Model/Service as 模型/服务
    participant JSP/View as 视图

    Browser-&gt;&gt;Servlet/Controller: 1. 发送 HTTP 请求 (GET /products?id=123)
    activate Servlet/Controller

    note over Servlet/Controller: 2. Servlet 容器将请求映射到此控制器

    Servlet/Controller-&gt;&gt;Model/Service: 3. 调用业务逻辑 (getProductById)
    activate Model/Service
    Model/Service--&gt;&gt;Servlet/Controller: 返回数据 (Product 对象)
    deactivate Model/Service

    note over Servlet/Controller: 4. 将 Product 对象存入 request 作用域

    Servlet/Controller-&gt;&gt;JSP/View: 5. 请求转发 (Forward)
    deactivate Servlet/Controller

    activate JSP/View
    note over JSP/View: 6. 渲染视图&lt;br/&gt;- 从 request 域获取数据&lt;br/&gt;- 使用 EL/JSTL 生成 HTML
    JSP/View--&gt;&gt;Browser: 7. 返回 HTML 响应
    deactivate JSP/View</code></pre>

<ol>
<li><strong>请求到达：</strong> 用户的浏览器发送一个 HTTP 请求（例如 <code>GET /products?id=123</code>）。</li>
<li><strong>控制器接收：</strong> Servlet 容器根据 <code>web.xml</code> 或 <code>@WebServlet</code> 的配置，将请求映射到一个 <strong>Servlet (Controller)</strong>。</li>
<li><strong>控制器处理：</strong><ul>
<li>Servlet 解析请求参数（<code>id=123</code>）。</li>
<li>Servlet <strong>调用 Model</strong>（例如 <code>ProductService.getProductById(123)</code>）来执行业务逻辑，获取数据。</li>
<li>Model 返回一个包含产品信息的 JavaBean (<code>Product</code> 对象)。</li>
</ul>
</li>
<li><strong>存储数据：</strong> Servlet 将从 Model 获取的数据（<code>Product</code> 对象）存入一个<strong>作用域对象</strong>中，最常用的是 <code>request</code> 域：<code>request.setAttribute(&quot;product&quot;, productObject);</code>。</li>
<li><strong>转发到视图：</strong> Servlet <strong>请求转发 (<code>forward</code>)</strong> 给一个 <strong>JSP (View)</strong> 文件，例如 <code>request.getRequestDispatcher(&quot;/WEB-INF/views/productDetail.jsp&quot;).forward(request, response);</code>。</li>
<li><strong>视图渲染：</strong><ul>
<li>JSP 页面被激活。</li>
<li>它从 <code>request</code> 域中取出之前 Servlet 存入的数据。</li>
<li>使用 JSP 标签（如 JSTL）或表达式语言（EL）将数据显示在 HTML 模板中。</li>
</ul>
</li>
<li><strong>响应返回：</strong> JSP 生成的最终 HTML 页面作为响应被发送回用户的浏览器。</li>
</ol>
<hr>
<h2 id="2-文件上传与下载"><a href="#2-文件上传与下载" class="headerlink" title="2. 文件上传与下载"></a>2. 文件上传与下载</h2><h3 id="2-1-文件上传"><a href="#2-1-文件上传" class="headerlink" title="2.1 文件上传"></a>2.1 文件上传</h3><h4 id="2-1-1-前端准备：HTML-表单"><a href="#2-1-1-前端准备：HTML-表单" class="headerlink" title="2.1.1 前端准备：HTML 表单"></a>2.1.1 前端准备：HTML 表单</h4><p>要实现文件上传，HTML <code>&lt;form&gt;</code> 必须满足以下<strong>三个条件</strong>：</p>
<ol>
<li><code>method</code> 必须为 <strong><code>post</code></strong>。</li>
<li><code>enctype</code> (encoding type) 必须设置为 <strong><code>multipart/form-data</code></strong>。这告诉服务器请求体将被分割成多个部分，每个部分代表一个表单字段或一个文件。</li>
<li>必须包含一个 <code>&lt;input type=&quot;file&quot;&gt;</code> 标签。</li>
</ol>
<p><strong>HTML 示例 (<code>upload.html</code>):</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>File Upload<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Upload a File<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">        Description: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        Select file: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uploadFile&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Upload&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-2-后端处理：Servlet"><a href="#2-1-2-后端处理：Servlet" class="headerlink" title="2.1.2 后端处理：Servlet"></a>2.1.2 后端处理：Servlet</h4><p>后端的 Servlet 需要做两件事来启用文件上传处理：</p>
<ol>
<li>在 Servlet 类上添加 <strong><code>@MultipartConfig</code></strong> 注解。这个注解会通知 Servlet 容器，该 Servlet 将会处理 <code>multipart/form-data</code> 类型的请求，容器需要预先解析好请求体，以便我们通过 API 获取文件部分。</li>
<li>使用 <code>request.getPart(String name)</code> 方法来获取上传的文件以及其他表单字段。这个方法返回一个 <code>Part</code> 对象。</li>
</ol>
<p><strong><code>Part</code> 接口的核心方法：</strong></p>
<ul>
<li><code>InputStream getInputStream()</code>: 获取上传文件的输入流，用于读取文件内容。</li>
<li><code>String getSubmittedFileName()</code>: 获取客户端上传的原始文件名。</li>
<li><code>long getSize()</code>: 获取文件的大小（字节）。</li>
<li><code>String getContentType()</code>: 获取文件的 MIME 类型（如 <code>image/jpeg</code>）。</li>
<li><code>void write(String fileName)</code>: 一个便捷方法，直接将上传的文件内容写入到服务器磁盘的指定路径。</li>
</ul>
<p><strong>Servlet 示例 (<code>UploadServlet.java</code>):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/upload&quot;)</span></span><br><span class="line"><span class="meta">@MultipartConfig(</span></span><br><span class="line"><span class="meta">    // 可以配置上传文件的限制</span></span><br><span class="line"><span class="meta">    // fileSizeThreshold = 1024 * 1024, // 1MB, 超过此大小的文件会直接写入磁盘</span></span><br><span class="line"><span class="meta">    // maxFileSize = 1024 * 1024 * 10,  // 10MB, 单个文件最大值</span></span><br><span class="line"><span class="meta">    // maxRequestSize = 1024 * 1024 * 50 // 50MB, 整个请求的最大值</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UPLOAD_DIR</span> <span class="operator">=</span> <span class="string">&quot;uploads&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取普通表单字段</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 获取文件部分</span></span><br><span class="line">        <span class="type">Part</span> <span class="variable">filePart</span> <span class="operator">=</span> request.getPart(<span class="string">&quot;uploadFile&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> filePart.getSubmittedFileName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 确定文件存储的绝对路径</span></span><br><span class="line">        <span class="comment">// getServletContext().getRealPath(&quot;&quot;) 获取 Web 应用在服务器上的部署路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">applicationPath</span> <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">uploadFilePath</span> <span class="operator">=</span> applicationPath + File.separator + UPLOAD_DIR;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建上传目录（如果不存在）</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">uploadDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(uploadFilePath);</span><br><span class="line">        <span class="keyword">if</span> (!uploadDir.exists()) &#123;</span><br><span class="line">            uploadDir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将文件写入服务器</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">savePath</span> <span class="operator">=</span> uploadFilePath + File.separator + fileName;</span><br><span class="line">        filePart.write(savePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 返回响应</span></span><br><span class="line">        response.getWriter().println(<span class="string">&quot;&lt;h1&gt;Description: &quot;</span> + description + <span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;&lt;h1&gt;File &quot;</span> + fileName + <span class="string">&quot; has been uploaded successfully!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;Saved at: &quot;</span> + savePath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-文件下载"><a href="#2-2-文件下载" class="headerlink" title="2.2 文件下载"></a>2.2 文件下载</h3><p>文件下载指的是服务器将一个文件以<strong>附件 (attachment)</strong> 的形式发送给客户端，触发浏览器的下载对话框，而不是直接在浏览器中打开。</p>
<p>核心技术是设置两个关键的 <strong>HTTP 响应头</strong>：<code>Content-Type</code> 和 <code>Content-Disposition</code>。</p>
<h4 id="2-2-1-实现步骤"><a href="#2-2-1-实现步骤" class="headerlink" title="2.2.1 实现步骤"></a>2.2.1 实现步骤</h4><ol>
<li><strong>确定要下载的文件：</strong> 通常通过请求参数（如 <code>?fileName=report.pdf</code>）来指定。</li>
<li><strong>设置 <code>Content-Type</code>:</strong> 告诉浏览器文件的 MIME 类型。可以使用 <code>getServletContext().getMimeType(fileName)</code> 来动态获取，如果无法确定，可以设置为通用的 <code>application/octet-stream</code>。</li>
<li><strong>设置 <code>Content-Disposition</code> (最关键):</strong><ul>
<li>将其值设置为 <code>attachment; filename=&quot;your_file_name&quot;</code>。</li>
<li><code>attachment</code> 指示浏览器将其作为附件处理。</li>
<li><code>filename</code> 指定了下载时默认显示的文件名。</li>
<li><strong>注意中文文件名乱码问题：</strong> 文件名需要使用 <code>URLEncoder</code> 进行编码，以符合 HTTP Header 规范。</li>
</ul>
</li>
<li><strong>读取文件并写入响应流：</strong><ul>
<li>使用 <code>FileInputStream</code> 读取服务器上的文件。</li>
<li>使用 <code>response.getOutputStream()</code> 获取字节输出流。</li>
<li>将文件内容从输入流循环读取并写入到输出流。</li>
</ul>
</li>
<li><strong>关闭资源：</strong> 确保输入输出流被正确关闭。</li>
</ol>
<p><strong>Servlet 示例 (<code>DownloadServlet.java</code>):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DownloadServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取要下载的文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;filename&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fileName == <span class="literal">null</span> || fileName.trim().isEmpty()) &#123;</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;Please specify a filename.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设文件都存储在 /WEB-INF/files/ 目录下，这是一个安全的目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;/WEB-INF/files/&quot;</span> + fileName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取文件的真实路径和 ServletContext</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> context.getRealPath(filePath);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 设置响应头</span></span><br><span class="line">        <span class="comment">// 3.1 获取文件MIME类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mimeType</span> <span class="operator">=</span> context.getMimeType(fileName);</span><br><span class="line">        <span class="keyword">if</span> (mimeType == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 无法识别类型时，使用通用二进制流</span></span><br><span class="line">            mimeType = <span class="string">&quot;application/octet-stream&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        response.setContentType(mimeType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2 设置 Content-Disposition，解决中文文件名乱码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encodedFileName</span> <span class="operator">=</span> URLEncoder.encode(fileName, <span class="string">&quot;UTF-8&quot;</span>).replaceAll(<span class="string">&quot;\\+&quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=\&quot;&quot;</span> + encodedFileName + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 读取文件并写入响应</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath);</span><br><span class="line">             <span class="type">ServletOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> response.getOutputStream()) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            <span class="type">int</span> bytesRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 如果文件不存在或读取错误</span></span><br><span class="line">            response.setStatus(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;File not found or unable to read.&quot;</span>);</span><br><span class="line">            System.err.println(<span class="string">&quot;Error downloading file: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-异步-Servlet-Servlet-3-0"><a href="#3-异步-Servlet-Servlet-3-0" class="headerlink" title="3. 异步 Servlet (Servlet 3.0+)"></a>3. 异步 Servlet (Servlet 3.0+)</h2><h3 id="3-1-解决的问题"><a href="#3-1-解决的问题" class="headerlink" title="3.1 解决的问题"></a>3.1 解决的问题</h3><p>传统的（同步）Servlet 模型是**“一个请求，一个线程，直到响应完成”**。当一个请求到达时，Servlet 容器会从其线程池中分配一个线程来处理这个请求。这个线程会全程负责执行 Servlet 的 <code>service</code> 方法，直到响应数据完全写入并发送给客户端后，该线程才会被释放并返回到线程池。</p>
<p><strong>核心问题在于：</strong> 如果 Servlet 的业务逻辑中包含<strong>耗时的、阻塞式I&#x2F;O操作</strong>（例如：调用一个缓慢的远程 Web Service、执行一个复杂的数据库查询、等待消息队列的返回），那么这个<strong>请求处理线程就会被长时间阻塞</strong>，空闲地等待，而不能去做其他任何事情。</p>
<p>当大量这样的慢请求并发到达时，容器的线程池会迅速被耗尽。所有线程都被阻塞在等待 I&#x2F;O 上，导致服务器无法再接受和处理新的请求，从而造成<strong>服务吞吐量急剧下降</strong>，甚至<strong>应用崩溃</strong>。这就是所谓的**“线程饥饿 (Thread Starvation)”**。</p>
<p><strong>异步 Servlet 的目的就是为了解决这个问题。</strong></p>
<p>它的核心思想是：<strong>将请求处理线程与耗时的业务逻辑解耦</strong>。当一个耗时操作开始时，Servlet 可以<strong>立即释放</strong>容器的请求处理线程，让它返回线程池去服务其他请求。同时，将耗时任务交给一个<strong>后台的、独立的线程池</strong>去执行。当后台任务完成后，再通过一个回调机制，将结果写回给客户端的响应流。</p>
<p><strong>一句话总结：异步 Servlet 并非让单个慢操作变快，而是通过释放关键的请求处理线程，让服务器在等待慢操作时能处理更多其他请求，从而极大地提高了应用的伸缩性 (Scalability) 和吞吐量 (Throughput)。</strong></p>
<hr>
<h3 id="3-2-核心-API"><a href="#3-2-核心-API" class="headerlink" title="3.2 核心 API"></a>3.2 核心 API</h3><p>实现异步 Servlet 主要涉及以下几个关键 API：</p>
<ol>
<li><strong>开启异步支持:</strong><ul>
<li>必须在 Servlet 配置中明确声明支持异步。</li>
<li><strong>注解方式：</strong> <code>@WebServlet(urlPatterns = &quot;/async&quot;, asyncSupported = true)</code></li>
<li><strong><code>web.xml</code> 方式：</strong> 在 <code>&lt;servlet&gt;</code> 标签中添加 <code>&lt;async-supported&gt;true&lt;/async-supported&gt;</code></li>
</ul>
</li>
<li><strong><code>request.startAsync()</code>:</strong><ul>
<li>这是启动异步处理的入口点。在 <code>doGet</code>&#x2F;<code>doPost</code> 等方法中调用它。</li>
<li>调用后，请求将进入异步模式，原始的 <code>request</code> 和 <code>response</code> 对象会被封装起来。</li>
<li>它返回一个 <code>AsyncContext</code> 对象，这是后续所有异步操作的核心。</li>
<li>一旦调用此方法，容器的请求处理线程就可以结束其 <code>service</code> 方法并被释放了。</li>
</ul>
</li>
<li><strong><code>AsyncContext</code> 对象:</strong><ul>
<li>这是异步处理的上下文环境，持有对原始请求和响应的引用。</li>
<li><strong><code>getRequest()</code> &#x2F; <code>getResponse()</code>:</strong> 从后台线程中获取原始的 <code>request</code> 和 <code>response</code> 对象。</li>
<li><strong><code>start(Runnable run)</code>:</strong> 一个便捷方法，可以将一个 <code>Runnable</code> 任务提交给容器管理的线程池去执行。</li>
<li><strong><code>dispatch(String path)</code>:</strong> 在异步任务完成后，可以将请求<strong>派发</strong>给另一个 Servlet 或 JSP 来完成最终的响应渲染。</li>
<li><strong><code>complete()</code>: (最重要)</strong> 当异步任务处理完成，并且响应数据已经写入完毕时，<strong>必须调用此方法</strong>。它会通知容器，该异步过程已结束，可以关闭连接并将响应发送给客户端。</li>
<li><strong><code>setTimeout(long timeout)</code>:</strong> 设置异步操作的超时时间（毫秒）。如果超时，会触发 <code>AsyncListener</code> 的 <code>onTimeout</code> 事件。</li>
<li><strong><code>addListener(AsyncListener listener)</code>:</strong> 添加一个异步监听器来处理超时、错误、完成等事件。</li>
</ul>
</li>
</ol>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/async&quot;, asyncSupported = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用一个独立的线程池来处理耗时任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        </span><br><span class="line">        response.setContentType(<span class="string">&quot;text/plain;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        out.println(<span class="string">&quot;主线程: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 开始处理请求。&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 启动异步上下文</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">AsyncContext</span> <span class="variable">asyncContext</span> <span class="operator">=</span> request.startAsync();</span><br><span class="line">        <span class="comment">// 设置超时时间 (例如 10 秒)</span></span><br><span class="line">        asyncContext.setTimeout(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将耗时任务提交到后台线程池</span></span><br><span class="line">        executor.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟一个耗时的I/O操作</span></span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从 AsyncContext 获取响应对象</span></span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">asyncOut</span> <span class="operator">=</span> asyncContext.getResponse().getWriter();</span><br><span class="line">                asyncOut.println(<span class="string">&quot;后台线程: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 完成了耗时任务。&quot;</span>);</span><br><span class="line">                asyncOut.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 3. 任务完成，必须调用 complete()</span></span><br><span class="line">                asyncContext.complete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        out.println(<span class="string">&quot;主线程: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 已释放，可以去处理其他请求了。&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-应用场景"><a href="#3-3-应用场景" class="headerlink" title="3.3 应用场景"></a>3.3 应用场景</h3><p>异步 Servlet 主要适用于<strong>I&#x2F;O密集型</strong>而非 CPU 密集型的场景。</p>
<ul>
<li><strong>调用外部 Web Service 或微服务:</strong><br>当你的应用需要调用另一个系统的 REST API 或 SOAP 服务，而对方响应较慢时，这是异步 Servlet 的完美应用场景。</li>
<li><strong>复杂的数据库操作或报表生成:</strong><br>执行需要长时间运行的数据库查询、数据聚合或生成大型报表时，可以使用异步处理，避免阻塞 Web 服务器。</li>
<li><strong>消息队列 (Message Queue) 的发布&#x2F;订阅:</strong><br>向消息中间件（如 RabbitMQ, Kafka）发送消息后，需要等待一个异步的回调或从另一个队列接收响应。</li>
<li><strong>实现长轮询 (Long Polling &#x2F; Comet):</strong><br>这是构建实时 Web 应用（如在线聊天、股票行情推送、实时通知）的一种技术。客户端发起一个请求，服务器端如果没有新数据，就<strong>挂起</strong>这个连接（通过启动异步上下文并释放线程），直到有新数据到达时，才通过 <code>AsyncContext</code> 将数据写回并 <code>complete()</code> 响应。这可以极大地节省服务器资源，是 WebSocket 出现之前的主流实时技术。</li>
<li><strong>作为API网关或代理:</strong><br>一个 Servlet 需要从多个后端服务拉取数据，然后聚合成一个响应返回。它可以异步地并行调用这些后端服务，从而缩短整体响应时间。</li>
</ul>
<hr>
<h2 id="4-Servlet-规范演进"><a href="#4-Servlet-规范演进" class="headerlink" title="4. Servlet 规范演进"></a>4. Servlet 规范演进</h2><h3 id="4-1-从-javax-servlet-Java-EE-到-jakarta-servlet-Jakarta-EE-的变迁"><a href="#4-1-从-javax-servlet-Java-EE-到-jakarta-servlet-Jakarta-EE-的变迁" class="headerlink" title="4.1 从 javax.servlet.* (Java EE) 到 jakarta.servlet.* (Jakarta EE) 的变迁"></a>4.1 从 <code>javax.servlet.*</code> (Java EE) 到 <code>jakarta.servlet.*</code> (Jakarta EE) 的变迁</h3><p>这是一个对 Java 生态系统产生深远影响的重大变化，主要是由于<strong>项目所有权的变更</strong>。</p>
<p><strong>背景：</strong></p>
<ul>
<li><strong>Java EE (Java Platform, Enterprise Edition)</strong> 最初由 Sun Microsystems 开发，后来由 <strong>Oracle</strong> 掌管。所有相关的 API 都位于 <code>javax.*</code> 包名下（<code>x</code> 代表 “extension”）。</li>
<li>2017年，Oracle 决定将 Java EE 移交给一个开源组织——<strong>Eclipse 基金会 (Eclipse Foundation)</strong> 来管理，以促进其更快的发展和社区参与。</li>
<li>项目被重新命名为 <strong>Jakarta EE</strong>。</li>
<li>由于 Oracle 拥有 <code>javax</code> 的商标权，Eclipse 基金会不能在新的 Jakarta EE 规范中继续使用这个包名来发布新版本。</li>
</ul>
<p><strong>核心变化：</strong></p>
<p>为了解决商标问题，Jakarta EE 社区决定进行一次“大爆炸”式的变更：从 <strong>Jakarta EE 9</strong> 版本开始，所有 API 的顶级包名从 <code>javax</code> 更改为 <code>jakarta</code>。</p>
<p>这对 Servlet API 意味着：</p>
<ul>
<li><p><strong>旧版本 (Servlet 4.0 及更早, 属于 Java EE 8 及更早):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>新版本 (Servlet 5.0 及更高, 属于 Jakarta EE 9 及更高):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>对开发者的影响：</strong></p>
<p>这是一个<strong>破坏性变更</strong>。当项目从基于 Java EE 8 的服务器（如 Tomcat 9）迁移到基于 Jakarta EE 9+ 的服务器（如 Tomcat 10+）时，开发者必须：</p>
<ol>
<li><strong>更新代码</strong>中的所有 <code>import</code> 语句。</li>
<li><strong>更新项目构建工具</strong>（如 Maven, Gradle）中的依赖坐标，从 <code>javax.servlet:javax.servlet-api</code> 更改为 <code>jakarta.servlet:jakarta.servlet-api</code>。</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/10/06/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringSecurity/" rel="prev" title="Spring全家桶-SpringSecurity">
                  <i class="fa fa-angle-left"></i> Spring全家桶-SpringSecurity
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/10/17/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95%E4%B8%8E%E9%9B%86%E6%88%90/" rel="next" title="Spring全家桶-功能扩展与集成">
                  Spring全家桶-功能扩展与集成 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
