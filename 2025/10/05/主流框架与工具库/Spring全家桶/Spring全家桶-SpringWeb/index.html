<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="三、SpringWeb1. Spring MVC (同步阻塞模型)1.1 核心工作流程Spring MVC（Model-View-Controller）是一个基于前端控制器模式 (Front Controller Pattern) 设计的Web框架。在这个模式中，所有的Web请求都会首先被一个单一的、核心的Servlet所拦截，然后由它来负责将请求分发给后续的组件进行处理。这个核心的Servlet">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring全家桶-SpringWeb">
<meta property="og:url" content="http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringWeb/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="三、SpringWeb1. Spring MVC (同步阻塞模型)1.1 核心工作流程Spring MVC（Model-View-Controller）是一个基于前端控制器模式 (Front Controller Pattern) 设计的Web框架。在这个模式中，所有的Web请求都会首先被一个单一的、核心的Servlet所拦截，然后由它来负责将请求分发给后续的组件进行处理。这个核心的Servlet">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-05T06:27:02.000Z">
<meta property="article:modified_time" content="2025-10-17T03:09:51.530Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringWeb/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringWeb/","path":"2025/10/05/主流框架与工具库/Spring全家桶/Spring全家桶-SpringWeb/","title":"Spring全家桶-SpringWeb"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Spring全家桶-SpringWeb | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81SpringWeb"><span class="nav-text">三、SpringWeb</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Spring-MVC-%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B"><span class="nav-text">1. Spring MVC (同步阻塞模型)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">1.1 核心工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-text">1.1.1 核心组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3-%E4%B9%9D%E5%A4%A7%E6%AD%A5%E9%AA%A4"><span class="nav-text">1.1.2 工作流程详解 (九大步骤)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="nav-text">1.2 常用注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E7%B1%BB%E7%BA%A7%E5%88%AB%E6%B3%A8%E8%A7%A3-Class-level-Annotations"><span class="nav-text">1.2.1 类级别注解 (Class-level Annotations)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E6%B3%A8%E8%A7%A3-Request-Mapping-Annotations"><span class="nav-text">1.2.2 请求映射注解 (Request Mapping Annotations)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-RequestMapping-%E4%B8%8E-RestController-%E7%9A%84%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93"><span class="nav-text">1.2.3 @RequestMapping 与 @RestController 的关系总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86"><span class="nav-text">1.3 请求参数处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="nav-text">1.3.1 参数绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-RequestParam-%E6%8F%90%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="nav-text">1. @RequestParam - 提取请求参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-PathVariable-%E6%8F%90%E5%8F%96%E8%B7%AF%E5%BE%84%E5%8F%98%E9%87%8F"><span class="nav-text">2. @PathVariable - 提取路径变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-RequestBody-%E6%8F%90%E5%8F%96%E8%AF%B7%E6%B1%82%E4%BD%93"><span class="nav-text">3. @RequestBody - 提取请求体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-RequestHeader-%E6%8F%90%E5%8F%96%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="nav-text">4. @RequestHeader - 提取请求头</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-CookieValue-%E6%8F%90%E5%8F%96Cookie%E5%80%BC"><span class="nav-text">5. @CookieValue - 提取Cookie值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E6%97%A0%E6%B3%A8%E8%A7%A3%E7%9A%84POJO%E7%BB%91%E5%AE%9A-%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE%E5%88%B0%E5%AF%B9%E8%B1%A1"><span class="nav-text">6. 无注解的POJO绑定 - 表单数据到对象</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C"><span class="nav-text">1.3.2 数据校验</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E4%BE%9D%E8%B5%96"><span class="nav-text">1. 核心依赖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="nav-text">2. 如何使用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E5%9C%A8DTO%E4%B8%8A%E6%B7%BB%E5%8A%A0%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3"><span class="nav-text">a. 在DTO上添加校验注解</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E5%9C%A8Controller%E6%96%B9%E6%B3%95%E4%B8%8A%E5%BC%80%E5%90%AF%E6%A0%A1%E9%AA%8C"><span class="nav-text">b. 在Controller方法上开启校验</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%A0%A1%E9%AA%8C%E5%A4%B1%E8%B4%A5"><span class="nav-text">3. 全局异常处理校验失败</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-Valid-vs-Validated"><span class="nav-text">4. @Valid vs @Validated</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86"><span class="nav-text">1.4 响应处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-ResponseEntity"><span class="nav-text">1.4.1 ResponseEntity</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-ResponseEntity%EF%BC%9F"><span class="nav-text">1. 什么是 ResponseEntity？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-ResponseEntity-%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-text">2. ResponseEntity 的组成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8-ResponseEntity"><span class="nav-text">3. 如何创建和使用 ResponseEntity</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-%E6%9C%80%E5%B8%B8%E7%94%A8"><span class="nav-text">a. 使用静态工厂方法 (最常用)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E4%BD%BF%E7%94%A8%E9%93%BE%E5%BC%8F%E6%9E%84%E5%BB%BA%E5%99%A8-%E6%9B%B4%E7%81%B5%E6%B4%BB"><span class="nav-text">b. 使用链式构建器 (更灵活)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-ResponseEntity-%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF"><span class="nav-text">4. ResponseEntity 的核心优势</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-2-JSON%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">1.4.2 JSON序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="nav-text">1. 什么是序列化与反序列化？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Spring-Boot-%E4%B8%8E-Jackson-%E7%9A%84%E6%97%A0%E7%BC%9D%E9%9B%86%E6%88%90"><span class="nav-text">2. Spring Boot 与 Jackson 的无缝集成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Jackson-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="nav-text">3. Jackson 常用注解</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E6%8E%A7%E5%88%B6%E5%AD%97%E6%AE%B5%E7%9A%84%E5%8C%85%E5%90%AB%E4%B8%8E%E6%8E%92%E9%99%A4"><span class="nav-text">a. 控制字段的包含与排除</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E6%8E%A7%E5%88%B6%E5%AD%97%E6%AE%B5%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="nav-text">b. 控制字段的名称</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-%E6%8E%A7%E5%88%B6%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-text">c. 控制日期和时间的格式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#d-%E6%8E%A7%E5%88%B6%E6%9E%9A%E4%B8%BE-Enum-%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">d. 控制枚举 (Enum) 的序列化</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%85%A8%E5%B1%80%E5%AE%9A%E5%88%B6-ObjectMapper"><span class="nav-text">4. 全局定制 ObjectMapper</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-Web%E5%B1%82%E9%80%9A%E7%94%A8%E5%8A%9F%E8%83%BD"><span class="nav-text">1.5 Web层通用功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">1.5.1 全局异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-text">1. 为什么需要全局异常处理？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3"><span class="nav-text">2. 核心注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-text">3. 实现一个全局异常处理器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">4. 工作流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E4%BC%98%E5%8A%BF%E6%80%BB%E7%BB%93"><span class="nav-text">5. 优势总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-2-%E8%BF%87%E6%BB%A4%E5%99%A8-Filter-vs-%E6%8B%A6%E6%88%AA%E5%99%A8-Interceptor"><span class="nav-text">1.5.2 过滤器 (Filter) vs 拦截器 (Interceptor)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%BF%87%E6%BB%A4%E5%99%A8-Filter"><span class="nav-text">1. 过滤器 (Filter)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%BD%92%E5%B1%9E"><span class="nav-text">a. 核心定义与归属</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-text">b. 工作流程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E5%9C%A8Spring-Boot%E4%B8%AD"><span class="nav-text">c. 实现方式 (在Spring Boot中)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#d-%E5%8A%9F%E8%83%BD%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">d. 功能与适用场景</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%8B%A6%E6%88%AA%E5%99%A8-Interceptor"><span class="nav-text">2. 拦截器 (Interceptor)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%BD%92%E5%B1%9E-1"><span class="nav-text">a. 核心定义与归属</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-1"><span class="nav-text">b. 工作流程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E5%9C%A8Spring-Boot%E4%B8%AD-1"><span class="nav-text">c. 实现方式 (在Spring Boot中)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#d-%E5%8A%9F%E8%83%BD%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-text">d. 功能与适用场景</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="nav-text">3. 总结与对比</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-3-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD"><span class="nav-text">1.5.3 文件上传与下载</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="nav-text">1. 文件上传</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E5%89%8D%E7%AB%AF%E5%87%86%E5%A4%87-HTML-Form"><span class="nav-text">a. 前端准备 (HTML Form)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-Spring-Boot-%E9%85%8D%E7%BD%AE-application-yml"><span class="nav-text">b. Spring Boot 配置 (application.yml)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-%E5%90%8E%E7%AB%AFController%E5%AE%9E%E7%8E%B0"><span class="nav-text">c. 后端Controller实现</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD-File-Download"><span class="nav-text">2. 文件下载 (File Download)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%80%BB%E7%BB%93"><span class="nav-text">3. 总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-4-CORS-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB"><span class="nav-text">1.5.4 CORS(跨域资源共享)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%9F"><span class="nav-text">1. 什么是跨域？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-CORS-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB-%E6%9C%BA%E5%88%B6"><span class="nav-text">2. CORS (跨域资源共享) 机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%9C%A8Spring-Boot%E4%B8%AD%E8%A7%A3%E5%86%B3CORS%E9%97%AE%E9%A2%98"><span class="nav-text">3. 在Spring Boot中解决CORS问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E5%B1%80%E9%83%A8%E9%85%8D%E7%BD%AE-CrossOrigin-%E6%B3%A8%E8%A7%A3"><span class="nav-text">a. 局部配置: @CrossOrigin 注解</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE-WebMvcConfigurer-%E6%8E%A8%E8%8D%90"><span class="nav-text">b. 全局配置: WebMvcConfigurer (推荐)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-RESTful-API-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-text">1.6 RESTful API 设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-1-REST%E7%9A%84%E5%85%AD%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BA%A6%E6%9D%9F"><span class="nav-text">1.6.1 REST的六大核心约束</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8-Client-Server"><span class="nav-text">1. 客户端-服务器 (Client-Server)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%97%A0%E7%8A%B6%E6%80%81-Stateless"><span class="nav-text">2. 无状态 (Stateless)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%8F%AF%E7%BC%93%E5%AD%98-Cacheable"><span class="nav-text">3. 可缓存 (Cacheable)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E7%BB%9F%E4%B8%80%E6%8E%A5%E5%8F%A3-Uniform-Interface"><span class="nav-text">4. 统一接口 (Uniform Interface)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E5%88%86%E5%B1%82%E7%B3%BB%E7%BB%9F-Layered-System"><span class="nav-text">5. 分层系统 (Layered System)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E6%8C%89%E9%9C%80%E7%BC%96%E7%A0%81-Code-On-Demand-%E5%8F%AF%E9%80%89%E7%BA%A6%E6%9D%9F"><span class="nav-text">6. 按需编码 (Code-On-Demand) - 可选约束</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">1.6.2 生产环境中的最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%B2%BE%E5%BF%83%E8%AE%BE%E8%AE%A1URI"><span class="nav-text">1. 精心设计URI</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%8F%90%E4%BE%9B%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E9%94%99%E8%AF%AF%E5%93%8D%E5%BA%94"><span class="nav-text">2. 提供结构化的错误响应</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8HTTPS"><span class="nav-text">3. 强制使用HTTPS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%98%8E%E7%A1%AEAPI%E5%A5%91%E7%BA%A6-API-Contract"><span class="nav-text">4. 明确API契约 (API Contract)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Spring-WebFlux-%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B"><span class="nav-text">2. Spring WebFlux (异步非阻塞模型)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%9F-Reactive-Streams%E8%A7%84%E8%8C%83"><span class="nav-text">2.1 什么是响应式编程？(Reactive Streams规范)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E4%BB%8E%E4%B8%80%E4%B8%AA%E2%80%9C%E6%8B%89%E2%80%9D%E4%B8%8E%E2%80%9C%E6%8E%A8%E2%80%9D%E7%9A%84%E6%AF%94%E5%96%BB%E5%BC%80%E5%A7%8B"><span class="nav-text">2.1.1 从一个“拉”与“推”的比喻开始</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E6%AD%A3%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="nav-text">2.1.2 响应式编程的正式定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-Reactive-Streams-%E8%A7%84%E8%8C%83"><span class="nav-text">2.1.3 Reactive Streams 规范</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%A0%B8%E5%BF%83API-Project-Reactor"><span class="nav-text">2.2 核心API(Project Reactor)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-Flux-%E5%A4%84%E7%90%86-0-%E5%88%B0-N-%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-text">2.2.1 Flux&lt;T&gt; - 处理 0 到 N 个元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-Mono-%E5%A4%84%E7%90%86-0-%E6%88%96-1-%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-text">2.2.2 Mono&lt;T&gt; - 处理 0 或 1 个元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9A%E8%AE%A2%E9%98%85-Subscription-%E4%B8%8E%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC"><span class="nav-text">2.2.3 核心概念：订阅 (Subscription) 与惰性求值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6-Operators"><span class="nav-text">2.2.4 常用操作符 (Operators)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%BD%AC%E6%8D%A2-Transforming"><span class="nav-text">1. 转换 (Transforming)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%BF%87%E6%BB%A4-Filtering"><span class="nav-text">2. 过滤 (Filtering)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E7%BB%84%E5%90%88-Combining"><span class="nav-text">3. 组合 (Combining)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-Error-Handling"><span class="nav-text">4. 错误处理 (Error Handling)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E9%98%BB%E5%A1%9E%E6%93%8D%E4%BD%9C-Blocking-%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8%EF%BC%81"><span class="nav-text">5. 阻塞操作 (Blocking) - 谨慎使用！</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E4%B8%A4%E7%A7%8D%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-text">2.3 两种编程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%BC%8F"><span class="nav-text">2.3.1 注解驱动模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A%E7%86%9F%E6%82%89%E7%9A%84%E9%85%8D%E6%96%B9%EF%BC%8C%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%91%B3%E9%81%93"><span class="nav-text">1. 核心思想：熟悉的配方，响应式的味道</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%A0%B9%E6%9C%AC%E6%80%A7%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-text">2. 根本性的区别：返回类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84-UserController"><span class="nav-text">3. 示例：一个响应式的 UserController</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%BA%95%E5%B1%82%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B"><span class="nav-text">4. 底层执行模型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E5%87%BD%E6%95%B0%E5%BC%8F%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F"><span class="nav-text">2.3.2 函数式路由模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A%E8%B7%AF%E7%94%B1%E5%8D%B3%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A4%84%E7%90%86%E5%8D%B3%E5%87%BD%E6%95%B0"><span class="nav-text">1. 核心思想：路由即函数，处理即函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B8%8EAPI"><span class="nav-text">2. 核心组件与API</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%A8%A1%E5%BC%8F%E9%87%8D%E5%86%99-UserController"><span class="nav-text">3. 示例：使用函数式模式重写 UserController</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E4%BC%98%E5%8A%BF%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">4. 优势与适用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-WebClient-%E5%93%8D%E5%BA%94%E5%BC%8FHTTP%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-text">2.4 WebClient (响应式HTTP客户端)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-%E4%BB%80%E4%B9%88%E6%98%AF-WebClient%EF%BC%9F"><span class="nav-text">2.4.1 什么是 WebClient？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-WebClient%EF%BC%9F"><span class="nav-text">2.4.2 如何使用 WebClient？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA-WebClient-%E5%AE%9E%E4%BE%8B"><span class="nav-text">1. 创建 WebClient 实例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%9E%84%E5%BB%BA%E5%B9%B6%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82-Fluent-API"><span class="nav-text">2. 构建并发送请求 (Fluent API)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94"><span class="nav-text">3. 处理响应</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-%E5%90%8C%E6%AD%A5%E8%B0%83%E7%94%A8-WebClient"><span class="nav-text">2.4.3 同步调用 WebClient</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringWeb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Spring全家桶-SpringWeb | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring全家桶-SpringWeb
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-05 14:27:02" itemprop="dateCreated datePublished" datetime="2025-10-05T14:27:02+08:00">2025-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 11:09:51" itemprop="dateModified" datetime="2025-10-17T11:09:51+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/" itemprop="url" rel="index"><span itemprop="name">Spring全家桶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="三、SpringWeb"><a href="#三、SpringWeb" class="headerlink" title="三、SpringWeb"></a>三、SpringWeb</h1><h2 id="1-Spring-MVC-同步阻塞模型"><a href="#1-Spring-MVC-同步阻塞模型" class="headerlink" title="1. Spring MVC (同步阻塞模型)"></a>1. Spring MVC (同步阻塞模型)</h2><h3 id="1-1-核心工作流程"><a href="#1-1-核心工作流程" class="headerlink" title="1.1 核心工作流程"></a>1.1 核心工作流程</h3><p>Spring MVC（Model-View-Controller）是一个基于<strong>前端控制器模式 (Front Controller Pattern)</strong> 设计的Web框架。在这个模式中，所有的Web请求都会首先被一个<strong>单一的、核心的Servlet</strong>所拦截，然后由它来负责将请求<strong>分发</strong>给后续的组件进行处理。这个核心的Servlet就是 <strong><code>DispatcherServlet</code></strong>。</p>
<p><code>DispatcherServlet</code> 就像一个机场的**“总调度塔”**，它本身不处理具体的业务逻辑（比如查询用户信息、创建订单），但它负责指挥和协调，确保每一个到来的请求（航班）都能被正确地引导到对应的处理器（登机口），并最终返回正确的响应（乘客到达目的地）。</p>
<h4 id="1-1-1-核心组件"><a href="#1-1-1-核心组件" class="headerlink" title="1.1.1 核心组件"></a>1.1.1 核心组件</h4><p>在深入流程之前，我们先认识一下参与这个流程的几位“关键角色”：</p>
<ol>
<li><strong><code>DispatcherServlet</code> (前端控制器)</strong>:<ul>
<li><strong>职责</strong>: 整个流程的<strong>核心</strong>和<strong>入口</strong>。接收所有HTTP请求，并负责协调各个组件的工作。</li>
</ul>
</li>
<li><strong><code>HandlerMapping</code> (处理器映射器)</strong>:<ul>
<li><strong>职责</strong>: 负责<strong>查找处理器</strong>。<code>DispatcherServlet</code> 会询问它：“对于这个URL的请求，我应该交给哪个处理器（Controller的方法）来处理？”</li>
<li>它会根据请求的URL、HTTP方法等信息，从容器中找到最匹配的 <code>HandlerMethod</code>（包含了Controller实例和对应的方法信息）。</li>
</ul>
</li>
<li><strong><code>HandlerAdapter</code> (处理器适配器)</strong>:<ul>
<li><strong>职责</strong>: 负责<strong>执行处理器</strong>。由于处理器（Handler）的形式多种多样（可能是实现了某个接口的类，也可能是一个被注解标记的方法），<code>DispatcherServlet</code> 自身并不知道如何去调用它们。</li>
<li><code>HandlerAdapter</code> 就像一个**“万能插座转换器”**，它能够适配并以一种标准化的方式去调用任何类型的处理器，并返回一个 <code>ModelAndView</code> 对象。</li>
</ul>
</li>
<li><strong><code>Handler</code> (处理器)</strong>:<ul>
<li><strong>职责</strong>: <strong>处理具体的业务逻辑</strong>。这通常就是我们编写的 <strong><code>Controller</code> 类中的方法</strong>。</li>
<li>它会接收请求参数，调用Service层处理业务，并准备好模型数据（Model）和视图信息（View）。</li>
</ul>
</li>
<li><strong><code>ModelAndView</code> (模型与视图)</strong>:<ul>
<li><strong>职责</strong>: 一个<strong>封装了模型数据和视图信息的容器</strong>。</li>
<li><strong>Model</strong>: 一个Map，包含了需要传递给视图进行渲染的数据（例如，从数据库查出的用户信息）。</li>
<li><strong>View</strong>: 一个逻辑视图名（如 <code>&quot;user/detail&quot;</code>）或一个具体的视图对象。</li>
</ul>
</li>
<li><strong><code>ViewResolver</code> (视图解析器)</strong>:<ul>
<li><strong>职责</strong>: 负责<strong>解析视图</strong>。<code>DispatcherServlet</code> 会拿着 <code>ModelAndView</code> 中的逻辑视图名（如 <code>&quot;user/detail&quot;</code>）去询问 <code>ViewResolver</code>：“这个逻辑名对应的真实视图文件在哪里？”</li>
<li><code>ViewResolver</code> 会根据预先配置好的规则（如添加前缀<code>/WEB-INF/views/</code>和后缀<code>.jsp</code>），将逻辑视图名解析成一个具体的 <code>View</code> 对象（如一个JSP文件或Thymeleaf模板）。</li>
</ul>
</li>
<li><strong><code>View</code> (视图)</strong>:<ul>
<li><strong>职责</strong>: <strong>渲染模型数据</strong>。<code>View</code> 对象接收到模型数据后，负责将数据填充到视图模板中，最终生成HTML等响应内容，返回给客户端。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="1-1-2-工作流程详解-九大步骤"><a href="#1-1-2-工作流程详解-九大步骤" class="headerlink" title="1.1.2 工作流程详解 (九大步骤)"></a>1.1.2 工作流程详解 (九大步骤)</h4><p>下面是当一个HTTP请求（例如 <code>GET /users/123</code>）到达时，Spring MVC内部发生的详细步骤：</p>
<pre><code class="highlight mermaid">sequenceDiagram
    actor Client

    title Spring MVC DispatcherServlet 工作流程
    Client-&gt;&gt;+DS: 1. HTTP Request
    
    DS-&gt;&gt;HM: 2. 查询能处理请求的Handler
    HM--&gt;&gt;DS: 3. 返回HandlerExecutionChain (含Controller方法和Interceptors)

    DS-&gt;&gt;+HA: 4. 请求HandlerAdapter执行Handler
    
    note right of HA: 执行拦截器的 preHandle 方法
    HA-&gt;&gt;I: 5a. Interceptor.preHandle()
    I--&gt;&gt;HA: (若返回false, 则中断流程)

    note right of HA: 参数解析、数据转换、数据校验等
    HA-&gt;&gt;+C: 5b. 通过反射调用Controller方法
    
    C--&gt;&gt;-HA: 6. Controller处理后返回ModelAndView
    
    note right of HA: 执行拦截器的 postHandle 方法
    HA-&gt;&gt;I: 7a. Interceptor.postHandle()
    I--&gt;&gt;HA: 
    
    HA--&gt;&gt;-DS: 7b. 返回ModelAndView给DispatcherServlet

    DS-&gt;&gt;+VR: 8. 请求ViewResolver解析视图
    VR--&gt;&gt;-DS: 返回具体的View对象

    DS-&gt;&gt;+V: 9a. 使用Model数据渲染View
    V--&gt;&gt;-DS: 返回渲染后的响应 (如HTML)

    note left of Client: 视图渲染完毕后
    DS-&gt;&gt;I: 9b. 执行Interceptor.afterCompletion()
    I--&gt;&gt;DS: 
    
    DS--&gt;&gt;-Client: 9c. 响应客户端</code></pre>

<ol>
<li><strong>请求到达 <code>DispatcherServlet</code></strong>:<ul>
<li>用户的HTTP请求被Web服务器（如Tomcat）接收，并根据 <code>web.xml</code> (或Spring Boot的自动配置) 的映射规则，将请求转发给 <code>DispatcherServlet</code>。</li>
</ul>
</li>
<li><strong><code>DispatcherServlet</code> 查询 <code>HandlerMapping</code></strong>:<ul>
<li><code>DispatcherServlet</code> 将请求（<code>HttpServletRequest</code>）交给已注册的 <code>HandlerMapping</code> 实例（通常是 <code>RequestMappingHandlerMapping</code>），询问谁能处理这个请求。</li>
</ul>
</li>
<li><strong><code>HandlerMapping</code> 返回处理器执行链 (<code>HandlerExecutionChain</code>)</strong>:<ul>
<li><code>HandlerMapping</code> 遍历其内部维护的URL与Controller方法的映射关系，找到最匹配的 <code>HandlerMethod</code>。</li>
<li>它不仅返回这个处理器方法，还会返回一个包含所有适用于该请求的<strong>拦截器 (Interceptors)</strong> 的执行链。</li>
</ul>
</li>
<li><strong><code>DispatcherServlet</code> 请求 <code>HandlerAdapter</code> 执行 <code>Handler</code></strong>:<ul>
<li><code>DispatcherServlet</code> 根据找到的 <code>HandlerMethod</code>，选择一个能够处理这种类型Handler的 <code>HandlerAdapter</code>（通常是 <code>RequestMappingHandlerAdapter</code>）。</li>
<li>然后，<code>DispatcherServlet</code> 将请求、响应以及处理器执行链交给这个 <code>HandlerAdapter</code>。</li>
</ul>
</li>
<li><strong><code>HandlerAdapter</code> 调用 <code>Handler</code></strong>:<ul>
<li><code>HandlerAdapter</code> 在调用真正的 <code>Handler</code> (Controller方法) <strong>之前</strong>，会先按顺序执行拦截器的 <code>preHandle</code> 方法。</li>
<li>接着，<code>HandlerAdapter</code> 会进行一系列准备工作，如<strong>参数解析</strong>（将HTTP请求中的参数绑定到Controller方法的参数上）、<strong>数据转换</strong>、<strong>数据校验</strong>等。</li>
<li>一切准备就绪后，它会通过<strong>反射</strong>调用我们编写的Controller方法。</li>
</ul>
</li>
<li><strong><code>Handler</code> (Controller方法) 处理并返回 <code>ModelAndView</code></strong>:<ul>
<li>Controller方法执行业务逻辑，与Service、Repository层交互。</li>
<li>处理完成后，它会将结果数据放入一个 <code>Model</code> 对象，并指定一个逻辑视图名，最终将它们封装成一个 <code>ModelAndView</code> 对象返回给 <code>HandlerAdapter</code>。</li>
<li>(在RESTful场景下，如果方法被 <code>@ResponseBody</code> 注解，会直接返回数据对象，流程会发生变化，跳过视图解析阶段)。</li>
</ul>
</li>
<li><strong><code>HandlerAdapter</code> 返回 <code>ModelAndView</code> 给 <code>DispatcherServlet</code></strong>:<ul>
<li><code>HandlerAdapter</code> 在接收到 <code>ModelAndView</code> 后，会按逆序执行拦截器的 <code>postHandle</code> 方法。</li>
<li>最后，<code>HandlerAdapter</code> 将 <code>ModelAndView</code> 返回给 <code>DispatcherServlet</code>。</li>
</ul>
</li>
<li><strong><code>DispatcherServlet</code> 请求 <code>ViewResolver</code> 解析视图</strong>:<ul>
<li><code>DispatcherServlet</code> 从 <code>ModelAndView</code> 中取出逻辑视图名。</li>
<li>它会遍历所有已注册的 <code>ViewResolver</code>，请求它们将这个逻辑视图名解析为一个具体的 <code>View</code> 对象。</li>
</ul>
</li>
<li><strong><code>View</code> 渲染并响应</strong>:<ul>
<li><code>DispatcherServlet</code> 拿到 <code>View</code> 对象后，将 <code>ModelAndView</code> 中的模型数据传递给它。</li>
<li><code>View</code> 对象（如一个JSP页面）使用模型数据进行渲染，生成最终的HTML响应体。</li>
<li>在视图渲染完成后，<code>DispatcherServlet</code> 会执行拦截器的 <code>afterCompletion</code> 方法（通常用于资源清理）。</li>
<li>最后，<code>DispatcherServlet</code> 将完整的HTTP响应返回给客户端浏览器。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-2-常用注解"><a href="#1-2-常用注解" class="headerlink" title="1.2 常用注解"></a>1.2 常用注解</h3><h4 id="1-2-1-类级别注解-Class-level-Annotations"><a href="#1-2-1-类级别注解-Class-level-Annotations" class="headerlink" title="1.2.1 类级别注解 (Class-level Annotations)"></a>1.2.1 类级别注解 (Class-level Annotations)</h4><p>这类注解通常用在Controller类上，用于声明该类的职责。</p>
<ul>
<li><p><strong><code>@Controller</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 这是最基础的Web控制器注解。它继承自 <code>@Component</code>，因此被 <code>@Controller</code> 标记的类会自动被组件扫描发现并注册为Spring Bean。</li>
<li><strong>职责</strong>: 表明这个类是一个<strong>传统的MVC控制器</strong>。它内部的方法通常会返回一个<strong>逻辑视图名</strong>（如<code>&quot;user/list&quot;</code>），然后由 <code>ViewResolver</code> 解析为具体的视图（如JSP或Thymeleaf模板）进行页面渲染。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user/profile&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserProfile</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;user&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;userProfile&quot;</span>; <span class="comment">// 返回逻辑视图名，将被解析为 userProfile.html 或 .jsp</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@RestController</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 一个<strong>复合注解</strong>，它由 <code>@Controller</code> 和 <code>@ResponseBody</code> 组合而成。</li>
<li><strong>职责</strong>: 专门用于构建 <strong>RESTful API</strong>。被 <code>@RestController</code> 标记的类，其内部所有被 <code>@RequestMapping</code> 系列注解标记的方法，都会<strong>自动应用 <code>@ResponseBody</code> 的效果</strong>。这意味着方法的返回值将直接被序列化（通常为JSON格式）并写入HTTP响应体中，而不是去解析视图。</li>
<li>这是现代前后端分离架构中的<strong>首选</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRestController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 返回User对象，Spring会通过Jackson自动将其序列化为JSON</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-2-2-请求映射注解-Request-Mapping-Annotations"><a href="#1-2-2-请求映射注解-Request-Mapping-Annotations" class="headerlink" title="1.2.2 请求映射注解 (Request Mapping Annotations)"></a>1.2.2 请求映射注解 (Request Mapping Annotations)</h4><p>这类注解用于将HTTP请求映射到具体的Controller处理方法上。</p>
<ul>
<li><p><strong><code>@RequestMapping</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 最通用、最基础的映射注解。它可以用于<strong>类级别</strong>和<strong>方法级别</strong>。<ul>
<li><strong>类级别</strong>: 为该控制器下的所有方法提供一个<strong>公共的URL前缀</strong>。</li>
<li><strong>方法级别</strong>: 定义处理具体请求的路径。</li>
</ul>
</li>
<li><strong>属性</strong>:<ul>
<li><code>value</code> 或 <code>path</code>: 指定请求的URL路径（支持Ant风格的通配符，如 <code>*</code>, <code>**</code>, <code>?</code>）。</li>
<li><code>method</code>: 指定HTTP请求方法，如 <code>RequestMethod.GET</code>, <code>RequestMethod.POST</code>。</li>
<li><code>params</code>: 要求请求中必须包含指定的参数，如 <code>params=&quot;myParam=myValue&quot;</code>。</li>
<li><code>headers</code>: 要求请求头必须包含指定的信息。</li>
<li><code>consumes</code>: 指定请求体的内容类型（Content-Type），如 <code>consumes=&quot;application/json&quot;</code>。</li>
<li><code>produces</code>: 指定响应体的内容类型，如 <code>produces=&quot;application/json&quot;</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/v1/products&quot;)</span> <span class="comment">// 类级别映射</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;&quot;, method = RequestMethod.GET)</span> <span class="comment">// 方法级别映射</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">getAllProducts</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;, method = RequestMethod.POST, consumes = &quot;application/json&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">updateProduct</span><span class="params">(<span class="meta">@PathVariable</span> Long id, <span class="meta">@RequestBody</span> Product product)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@RequestMapping</code> 的快捷注解 (Shortcut Annotations)</strong>:<br>为了简化开发，Spring提供了针对不同HTTP方法的专用快捷注解。它们在功能上与 <code>@RequestMapping(method = ...)</code> 等价，但代码更简洁、语义更清晰。</p>
<ul>
<li><strong><code>@GetMapping</code></strong>: 映射HTTP GET请求。</li>
<li><strong><code>@PostMapping</code></strong>: 映射HTTP POST请求。</li>
<li><strong><code>@PutMapping</code></strong>: 映射HTTP PUT请求。</li>
<li><strong><code>@DeleteMapping</code></strong>: 映射HTTP DELETE请求。</li>
<li><strong><code>@PatchMapping</code></strong>: 映射HTTP PATCH请求。</li>
</ul>
<p><strong>使用快捷注解重构上面的例子</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/v1/products&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span> <span class="comment">// 更简洁</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">getAllProducts</span><span class="params">()</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/&#123;id&#125;&quot;)</span> <span class="comment">// consumes属性依然可以添加</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">updateProduct</span><span class="params">(<span class="meta">@PathVariable</span> Long id, <span class="meta">@RequestBody</span> Product product)</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-2-3-RequestMapping-与-RestController-的关系总结"><a href="#1-2-3-RequestMapping-与-RestController-的关系总结" class="headerlink" title="1.2.3 @RequestMapping 与 @RestController 的关系总结"></a>1.2.3 <code>@RequestMapping</code> 与 <code>@RestController</code> 的关系总结</h4><table>
<thead>
<tr>
<th align="left">类注解</th>
<th align="left">方法注解</th>
<th align="left">返回值处理方式</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>@Controller</code></td>
<td align="left"><code>@RequestMapping</code></td>
<td align="left"><strong>默认解析为视图</strong>。如果方法想返回数据，需要<strong>额外</strong>加<code>@ResponseBody</code>。</td>
<td align="left">传统的MVC，服务端渲染</td>
</tr>
<tr>
<td align="left"><code>@RestController</code></td>
<td align="left"><code>@GetMapping</code>等</td>
<td align="left"><strong>默认直接返回数据 (JSON&#x2F;XML)</strong>。所有方法隐式地应用了<code>@ResponseBody</code>。</td>
<td align="left"><strong>RESTful API</strong>，前后端分离</td>
</tr>
</tbody></table>
<p>在现代Web开发中，<code>@RestController</code> 及其配套的 <code>@GetMapping</code>, <code>@PostMapping</code> 等快捷注解，是构建后端API服务时最常用的组合。</p>
<hr>
<h3 id="1-3-请求参数处理"><a href="#1-3-请求参数处理" class="headerlink" title="1.3 请求参数处理"></a>1.3 请求参数处理</h3><h4 id="1-3-1-参数绑定"><a href="#1-3-1-参数绑定" class="headerlink" title="1.3.1 参数绑定"></a>1.3.1 参数绑定</h4><p>参数绑定（或称请求参数处理）是Spring MVC框架的一项强大功能。它的核心任务是将<strong>HTTP请求中的数据（如URL路径变量、查询参数、请求体等）自动地提取出来，进行必要的类型转换，并赋值给Controller处理方法的参数</strong>。这使得开发者可以像调用普通Java方法一样来编写Controller，而无需手动去解析底层的 <code>HttpServletRequest</code> 对象。</p>
<p>以下是用于参数绑定的最常用注解：</p>
<hr>
<h5 id="1-RequestParam-提取请求参数"><a href="#1-RequestParam-提取请求参数" class="headerlink" title="1. @RequestParam - 提取请求参数"></a>1. <code>@RequestParam</code> - 提取请求参数</h5><ul>
<li><p><strong>作用</strong>: 用于从<strong>查询字符串 (Query String)</strong> 或 <strong>POST表单数据 (<code>x-www-form-urlencoded</code>)</strong> 中提取参数。</p>
</li>
<li><p><strong>常见场景</strong>: <code>GET /users?name=alice&amp;age=30</code> 或 <code>POST /login</code> (表单提交)。</p>
</li>
<li><p><strong>核心属性</strong>:</p>
<ul>
<li><code>value</code> 或 <code>name</code>: 指定要绑定的请求参数的名称。如果方法参数名与请求参数名一致，此属性可以省略。</li>
<li><code>required</code>: 布尔值，表示该参数是否<strong>必需</strong>。默认为 <code>true</code>，如果请求中不包含该参数，会抛出异常。设为 <code>false</code> 则为可选参数。</li>
<li><code>defaultValue</code>: 字符串，提供一个<strong>默认值</strong>。当参数为可选 (<code>required=false</code>) 且请求中未提供该参数时，会使用此默认值。<strong>注意：<code>defaultValue</code> 隐含了 <code>required=false</code> 的效果</strong>。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">findUser</span><span class="params">(</span></span><br><span class="line"><span class="params">    // <span class="number">1.</span> 基本用法 (参数名与方法变量名一致)</span></span><br><span class="line">    String name,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 指定请求参数名，并设为可选</span></span><br><span class="line">    <span class="meta">@RequestParam(name = &quot;user_age&quot;, required = false)</span> Integer age,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提供默认值</span></span><br><span class="line">    <span class="meta">@RequestParam(defaultValue = &quot;1&quot;)</span> <span class="type">int</span> page,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 接收多个同名参数到一个List中</span></span><br><span class="line">    <span class="meta">@RequestParam(&quot;roles&quot;)</span> List&lt;String&gt; roles <span class="comment">// e.g., ?roles=admin&amp;roles=user</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不带注解的情况</strong>: 如果一个简单类型的参数（如 <code>String</code>, <code>int</code>）没有加任何注解，Spring MVC会<strong>默认</strong>把它当作 <code>@RequestParam</code> 来处理（且 <code>required=false</code>）。</p>
</li>
</ul>
<hr>
<h5 id="2-PathVariable-提取路径变量"><a href="#2-PathVariable-提取路径变量" class="headerlink" title="2. @PathVariable - 提取路径变量"></a>2. <code>@PathVariable</code> - 提取路径变量</h5><ul>
<li><p><strong>作用</strong>: 用于从<strong>URL路径</strong>中提取值。这在RESTful API设计中非常常见，用于表示对特定资源的访问。</p>
</li>
<li><p><strong>常见场景</strong>: <code>GET /users/123</code> 或 <code>DELETE /orders/order-abc</code>。</p>
</li>
<li><p><strong>URL模板</strong>: 路径中需要使用 <code>{}</code> 占位符来定义变量。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users/&#123;userId&#125;/orders/&#123;orderId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Order <span class="title function_">getOrderDetails</span><span class="params">(</span></span><br><span class="line"><span class="params">    // 将URL中的 &#123;userId&#125; 绑定到 Long类型的 userId 参数</span></span><br><span class="line"><span class="params">    <span class="meta">@PathVariable</span> Long userId,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">    // 如果占位符名称与参数名不一致，需要显式指定</span></span><br><span class="line"><span class="params">    <span class="meta">@PathVariable(&quot;orderId&quot;)</span> String orderIdentifier</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">// ... find order by userId and orderIdentifier</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="3-RequestBody-提取请求体"><a href="#3-RequestBody-提取请求体" class="headerlink" title="3. @RequestBody - 提取请求体"></a>3. <code>@RequestBody</code> - 提取请求体</h5><ul>
<li><p><strong>作用</strong>: 将<strong>整个HTTP请求体 (Request Body)</strong> 的内容读取出来，并通过 <code>HttpMessageConverter</code> (通常是 <code>Jackson2HttpMessageConverter</code>) 将其<strong>反序列化</strong>为一个Java对象（POJO）。</p>
</li>
<li><p><strong>核心要求</strong>: 一个Controller方法中，<strong>最多只能有一个</strong> <code>@RequestBody</code> 注解。</p>
</li>
<li><p><strong>常见场景</strong>: 接收 <code>POST</code>, <code>PUT</code>, <code>PATCH</code> 请求中发送的 <code>application/json</code> 或 <code>application/xml</code> 数据。</p>
</li>
<li><p><strong>示例</strong>:</p>
<ul>
<li><p><strong>客户端发送的JSON</strong>:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bob&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pwd&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bob@example.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Controller方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/users/register&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">registerUser</span><span class="params">(</span></span><br><span class="line"><span class="params">    // 将请求体JSON反序列化为 UserDTO 对象</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestBody</span> UserDTO userDto</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">// ... process userDto object</span></span><br><span class="line">    System.out.println(userDto.getUsername());</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;User registered successfully&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-RequestHeader-提取请求头"><a href="#4-RequestHeader-提取请求头" class="headerlink" title="4. @RequestHeader - 提取请求头"></a>4. <code>@RequestHeader</code> - 提取请求头</h5><ul>
<li><p><strong>作用</strong>: 用于读取HTTP请求头 (Header) 中的特定值。</p>
</li>
<li><p><strong>属性</strong>: 与 <code>@RequestParam</code> 类似，也支持 <code>name</code>, <code>required</code>, <code>defaultValue</code>。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/api/info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">(</span></span><br><span class="line"><span class="params">    // 读取 <span class="string">&quot;User-Agent&quot;</span> 请求头</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">    // 读取一个可选的 <span class="string">&quot;X-Custom-Header&quot;</span>，提供默认值</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(name = &quot;X-Custom-Header&quot;, defaultValue = &quot;default&quot;)</span> String customHeader,</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">    // 将所有请求头注入到一个Map中</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader</span> Map&lt;String, String&gt; allHeaders</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;User-Agent: &quot;</span> + userAgent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-CookieValue-提取Cookie值"><a href="#5-CookieValue-提取Cookie值" class="headerlink" title="5. @CookieValue - 提取Cookie值"></a>5. <code>@CookieValue</code> - 提取Cookie值</h5><ul>
<li><p><strong>作用</strong>: 用于从HTTP请求的Cookie中读取特定<code>name</code>的值。</p>
</li>
<li><p><strong>属性</strong>: 与 <code>@RequestParam</code> 类似，也支持 <code>name</code>, <code>required</code>, <code>defaultValue</code>。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/profile&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserProfile</span><span class="params">(</span></span><br><span class="line"><span class="params">    // 读取名为 <span class="string">&quot;sessionId&quot;</span> 的cookie</span></span><br><span class="line"><span class="params">    <span class="meta">@CookieValue(&quot;sessionId&quot;)</span> String sessionId,</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">    // 读取一个可选的cookie</span></span><br><span class="line"><span class="params">    <span class="meta">@CookieValue(name = &quot;theme&quot;, required = false)</span> String theme</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="comment">// ... use sessionId to find user session</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Profile for session: &quot;</span> + sessionId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="6-无注解的POJO绑定-表单数据到对象"><a href="#6-无注解的POJO绑定-表单数据到对象" class="headerlink" title="6. 无注解的POJO绑定 - 表单数据到对象"></a>6. 无注解的POJO绑定 - 表单数据到对象</h5><ul>
<li><p><strong>作用</strong>: 当请求是 <code>GET</code> 的查询参数或 <code>POST</code> 的 <code>x-www-form-urlencoded</code> 表单数据时，Spring MVC可以<strong>自动</strong>将这些参数<strong>按名称匹配</strong>并绑定到一个POJO对象的字段上。</p>
</li>
<li><p><strong>要求</strong>: POJO类必须有<strong>无参构造函数</strong>和对应字段的<strong>setter方法</strong>。</p>
</li>
<li><p><strong>示例</strong>:</p>
<ul>
<li><p><strong>请求</strong>: <code>POST /users/create</code>，请求体为 <code>username=carol&amp;email=carol@example.com</code></p>
</li>
<li><p><strong>POJO类 (<code>UserCreateForm.java</code>)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserCreateForm</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">// Getters and Setters ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Controller方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/users/create&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">createUser</span><span class="params">(UserCreateForm form)</span> &#123; <span class="comment">// 无需任何注解</span></span><br><span class="line">    <span class="comment">// Spring会自动 new UserCreateForm(), 然后调用 setUsername(&quot;carol&quot;) 和 setEmail(&quot;carol@example.com&quot;)</span></span><br><span class="line">    System.out.println(form.getUsername());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;User created&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-2-数据校验"><a href="#1-3-2-数据校验" class="headerlink" title="1.3.2 数据校验"></a>1.3.2 数据校验</h4><p>数据校验的目的是确保客户端发送到后端的数据符合预定义的规则。例如，用户名不能为空、邮箱必须符合格式、年龄必须是正整数等。如果在业务逻辑代码中手动进行大量的<code>if-else</code>判断来做校验，会使代码变得臃肿、重复且难以维护。</p>
<p>Spring MVC 深度集成了 <strong>Bean Validation (JSR-303 &#x2F; JSR-380)</strong> 规范，允许我们通过<strong>声明式注解</strong>的方式来定义校验规则，并通过框架自动执行校验。</p>
<p><strong>Hibernate Validator</strong> 是 Bean Validation 规范最流行、也是Spring Boot默认集成的实现库。</p>
<h5 id="1-核心依赖"><a href="#1-核心依赖" class="headerlink" title="1. 核心依赖"></a>1. 核心依赖</h5><p>要使用数据校验功能，首先需要确保项目中包含了 <code>spring-boot-starter-validation</code> 依赖。通常情况下，如果你引入了 <code>spring-boot-starter-web</code>，这个校验依赖已经<strong>被传递性地包含</strong>进来了，无需额外添加。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-如何使用"><a href="#2-如何使用" class="headerlink" title="2. 如何使用"></a>2. 如何使用</h5><p>数据校验的使用通常分为两步：</p>
<ol>
<li><strong>在DTO&#x2F;VO上添加校验注解</strong>：在需要被校验的Java Bean（通常是用于接收请求体的DTO - Data Transfer Object）的字段上，添加JSR-303&#x2F;380规范定义的校验注解。</li>
<li><strong>在Controller方法上开启校验</strong>：在Controller方法的对应参数上，添加 <code>@Valid</code> 或 <code>@Validated</code> 注解，来触发对该对象的校验。</li>
</ol>
<h6 id="a-在DTO上添加校验注解"><a href="#a-在DTO上添加校验注解" class="headerlink" title="a. 在DTO上添加校验注解"></a>a. 在DTO上添加校验注解</h6><p>我们创建一个 <code>UserRegisterDTO</code> 来接收用户注册的请求数据，并为其添加校验规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.constraints.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisterDTO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Size(min = 4, max = 20, message = &quot;用户名长度必须在4到20个字符之间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;密码不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[\\s\\S]&#123;8,16&#125;$&quot;, </span></span><br><span class="line"><span class="meta">             message = &quot;密码必须8-16位，且包含大小写字母和数字&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;年龄不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Min(value = 18, message = &quot;年龄必须大于等于18岁&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 100, message = &quot;年龄不能超过100岁&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;邮箱不能为空&quot;)</span></span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式不正确&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 嵌套对象校验</span></span><br><span class="line">    <span class="meta">@Valid</span> <span class="comment">// 必须加上@Valid，才会对嵌套对象进行校验</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">        <span class="meta">@NotBlank</span></span><br><span class="line">        <span class="keyword">private</span> String street;</span><br><span class="line">        <span class="meta">@NotBlank</span></span><br><span class="line">        <span class="keyword">private</span> String city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>常用的校验注解 (位于 <code>javax.validation.constraints</code> 包下)</strong>:</p>
<table>
<thead>
<tr>
<th align="left">注解</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>@NotNull</code></strong></td>
<td align="left">验证对象不能为 <code>null</code>。</td>
</tr>
<tr>
<td align="left"><strong><code>@NotBlank</code></strong></td>
<td align="left">验证字符串<strong>不能为 <code>null</code> 且去除首尾空格后长度必须大于0</strong>。 (专用于字符串)</td>
</tr>
<tr>
<td align="left"><strong><code>@NotEmpty</code></strong></td>
<td align="left">验证对象<strong>不能为 <code>null</code> 且大小&#x2F;长度必须大于0</strong>。 (可用于String, Collection, Map, Array)</td>
</tr>
<tr>
<td align="left"><strong><code>@Size(min, max)</code></strong></td>
<td align="left">验证对象（String, Collection, Map, Array）的大小&#x2F;长度是否在指定范围内。</td>
</tr>
<tr>
<td align="left"><strong><code>@Min(value)</code></strong></td>
<td align="left">验证数字是否大于等于指定值。</td>
</tr>
<tr>
<td align="left"><strong><code>@Max(value)</code></strong></td>
<td align="left">验证数字是否小于等于指定值。</td>
</tr>
<tr>
<td align="left"><strong><code>@Email</code></strong></td>
<td align="left">验证字符串是否为合法的Email格式。</td>
</tr>
<tr>
<td align="left"><strong><code>@Pattern(regexp)</code></strong></td>
<td align="left">验证字符串是否匹配指定的正则表达式。</td>
</tr>
<tr>
<td align="left"><strong><code>@Past</code> &#x2F; <code>@Future</code></strong></td>
<td align="left">验证日期是否为过去或将来的日期。</td>
</tr>
<tr>
<td align="left"><strong><code>@Valid</code></strong></td>
<td align="left"><strong>用于嵌套对象</strong>。标记在一个字段上，表示需要<strong>级联校验</strong>这个字段所引用的对象的内部规则。</td>
</tr>
</tbody></table>
<hr>
<h6 id="b-在Controller方法上开启校验"><a href="#b-在Controller方法上开启校验" class="headerlink" title="b. 在Controller方法上开启校验"></a>b. 在Controller方法上开启校验</h6><p>在Controller方法中，我们在需要校验的参数（通常是被 <code>@RequestBody</code> 标记的对象）前面加上 <code>@Valid</code> 或 <code>@Validated</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">registerUser</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserRegisterDTO userDto,</span></span><br><span class="line"><span class="params">        BindingResult bindingResult // 紧跟在校验对象后面，用于接收校验结果</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        <span class="comment">// 方式一：手动处理校验结果 (灵活)</span></span><br><span class="line">        <span class="keyword">if</span> (bindingResult.hasErrors()) &#123;</span><br><span class="line">            <span class="comment">// 获取第一个错误信息并返回</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">firstError</span> <span class="operator">=</span> bindingResult.getAllErrors().get(<span class="number">0</span>).getDefaultMessage();</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.badRequest().body(firstError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果校验通过，则执行业务逻辑</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;User registered successfully!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>BindingResult</code> 对象</strong>:</p>
<ul>
<li>这是一个<strong>可选的</strong>参数，它必须<strong>紧跟在</strong>被校验的参数后面。</li>
<li>它的作用是<strong>捕获</strong>校验过程中产生的所有错误信息。</li>
<li>如果Controller方法中包含了 <code>BindingResult</code> 参数，当校验失败时，<strong>Spring MVC不会立即抛出异常</strong>，而是将错误信息填充到 <code>BindingResult</code> 中，然后继续执行方法体。这给了我们<strong>手动处理和定制错误响应</strong>的机会。</li>
<li>如果<strong>没有</strong> <code>BindingResult</code> 参数，一旦校验失败，Spring MVC会立即抛出 <code>MethodArgumentNotValidException</code> 异常，请求流程中断。</li>
</ul>
<hr>
<h5 id="3-全局异常处理校验失败"><a href="#3-全局异常处理校验失败" class="headerlink" title="3. 全局异常处理校验失败"></a>3. 全局异常处理校验失败</h5><p>手动在每个Controller方法中检查 <code>BindingResult</code> 是一种重复劳动。更好的实践是使用全局异常处理器（<code>@RestControllerAdvice</code>）来统一捕获 <code>MethodArgumentNotValidException</code> 并返回一个结构化的错误响应，在1.5.1 全局异常处理中会有详细说明。</p>
<hr>
<h5 id="4-Valid-vs-Validated"><a href="#4-Valid-vs-Validated" class="headerlink" title="4. @Valid vs @Validated"></a>4. <code>@Valid</code> vs <code>@Validated</code></h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>@Valid</code> (JSR-303标准)</th>
<th align="left"><code>@Validated</code> (Spring特有)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>来源</strong></td>
<td align="left"><code>javax.validation</code></td>
<td align="left"><code>org.springframework.validation.annotation</code></td>
</tr>
<tr>
<td align="left"><strong>功能</strong></td>
<td align="left">标准的校验功能</td>
<td align="left">继承了<code>@Valid</code>的所有功能，并提供了<strong>分组校验</strong>的能力。</td>
</tr>
<tr>
<td align="left"><strong>使用位置</strong></td>
<td align="left">方法参数、字段、构造函数参数</td>
<td align="left">方法参数、字段、构造函数参数、<strong>类、方法</strong></td>
</tr>
<tr>
<td align="left"><strong>分组校验</strong></td>
<td align="left">不支持</td>
<td align="left"><strong>支持</strong>。允许定义不同的校验组，在不同场景下应用不同的校验规则。</td>
</tr>
</tbody></table>
<p><strong>分组校验示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义分组接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnCreate</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnUpdate</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在DTO中使用groups属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDTO</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull(groups = OnUpdate.class)</span> <span class="comment">// id在更新时不能为空</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(groups = &#123;OnCreate.class, OnUpdate.class&#125;)</span> <span class="comment">// username在创建和更新时都不能为空</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 在Controller中指定要校验的分组</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(<span class="meta">@Validated(OnCreate.class)</span> <span class="meta">@RequestBody</span> UserDTO user)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(<span class="meta">@Validated(OnUpdate.class)</span> <span class="meta">@RequestBody</span> UserDTO user)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：在简单的校验场景中，<code>@Valid</code> 和 <code>@Validated</code> 可以互换。当你需要更高级的分组校验功能时，必须使用 <code>@Validated</code>。在Spring环境中，使用 <code>@Validated</code> 通常是更好的选择。</p>
<hr>
<h3 id="1-4-响应处理"><a href="#1-4-响应处理" class="headerlink" title="1.4 响应处理"></a>1.4 响应处理</h3><h4 id="1-4-1-ResponseEntity"><a href="#1-4-1-ResponseEntity" class="headerlink" title="1.4.1 ResponseEntity"></a>1.4.1 <code>ResponseEntity</code></h4><h5 id="1-什么是-ResponseEntity？"><a href="#1-什么是-ResponseEntity？" class="headerlink" title="1. 什么是 ResponseEntity？"></a>1. 什么是 <code>ResponseEntity</code>？</h5><p><code>ResponseEntity</code> 是 Spring 提供的一个泛型类，它代表了<strong>整个 HTTP 响应</strong>。通过使用它，你可以完全控制响应的<strong>状态码 (Status Code)</strong>、<strong>响应头 (Headers)</strong> 和<strong>响应体 (Body)</strong>。</p>
<p>在简单的场景中，<code>@RestController</code> 的方法可以直接返回一个POJO（如 <code>User</code> 对象），Spring 会默认：</p>
<ul>
<li><strong>状态码</strong>: <code>200 OK</code></li>
<li><strong>响应头</strong>: <code>Content-Type: application/json</code> (通常)</li>
<li><strong>响应体</strong>: POJO 序列化后的 JSON 字符串</li>
</ul>
<p>但是，现实世界的 API 需要更丰富的表达能力。例如：</p>
<ul>
<li>成功创建资源后，应该返回 <code>201 Created</code> 状态码，并在 <code>Location</code> 头中提供新资源的URL。</li>
<li>请求的资源不存在时，应该返回 <code>404 Not Found</code> 状态码，并且响应体可能为空。</li>
<li>请求处理成功但无需返回内容时（如删除操作），应该返回 <code>204 No Content</code> 状态码。</li>
<li>需要添加自定义的响应头，如缓存控制（<code>Cache-Control</code>）或认证令牌。</li>
</ul>
<p><strong><code>ResponseEntity</code> 就是为了满足这些精细化控制需求而生的。</strong></p>
<hr>
<h5 id="2-ResponseEntity-的组成"><a href="#2-ResponseEntity-的组成" class="headerlink" title="2. ResponseEntity 的组成"></a>2. <code>ResponseEntity</code> 的组成</h5><p><code>ResponseEntity&lt;T&gt;</code> 包含了三个核心部分：</p>
<ol>
<li><strong><code>T body</code></strong>: 响应体。泛型 <code>T</code> 代表了响应体的数据类型，可以是任何Java对象（POJO、List、Map等），也可以是 <code>Void</code>（表示没有响应体）。</li>
<li><strong><code>HttpStatus status</code></strong>: HTTP 状态码。这是一个枚举类，包含了所有标准的HTTP状态码，如 <code>HttpStatus.OK</code>, <code>HttpStatus.CREATED</code>, <code>HttpStatus.NOT_FOUND</code> 等。</li>
<li><strong><code>HttpHeaders headers</code></strong>: HTTP 响应头。一个可以方便地添加和设置各种响应头的对象。</li>
</ol>
<hr>
<h5 id="3-如何创建和使用-ResponseEntity"><a href="#3-如何创建和使用-ResponseEntity" class="headerlink" title="3. 如何创建和使用 ResponseEntity"></a>3. 如何创建和使用 <code>ResponseEntity</code></h5><p>Spring 提供了非常便利的<strong>静态工厂方法</strong>和<strong>链式构建器 (Builder)</strong> 来创建 <code>ResponseEntity</code> 实例。</p>
<h6 id="a-使用静态工厂方法-最常用"><a href="#a-使用静态工厂方法-最常用" class="headerlink" title="a. 使用静态工厂方法 (最常用)"></a>a. 使用静态工厂方法 (最常用)</h6><p>这些方法通常以状态码命名，非常直观。</p>
<ul>
<li><p><strong>返回 200 OK</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findById(id);</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ResponseEntity.ok() 创建一个状态码为 200 的响应</span></span><br><span class="line">        <span class="comment">// .body(user) 可以省略，直接 ResponseEntity.ok(user)</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().body(user); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回 404 Not Found</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...接上例</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ResponseEntity.notFound() 创建一个状态码为 404 的响应</span></span><br><span class="line">    <span class="comment">// .build() 用于构建一个没有响应体的 ResponseEntity</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.notFound().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回 201 Created (创建资源)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User newUser)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">savedUser</span> <span class="operator">=</span> userService.save(newUser);</span><br><span class="line">    <span class="comment">// 构建新资源的URI，用于放入Location头</span></span><br><span class="line">    <span class="type">URI</span> <span class="variable">location</span> <span class="operator">=</span> ServletUriComponentsBuilder.fromCurrentRequest()</span><br><span class="line">            .path(<span class="string">&quot;/&#123;id&#125;&quot;</span>)</span><br><span class="line">            .buildAndExpand(savedUser.getId())</span><br><span class="line">            .toUri();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ResponseEntity.created(uri) 创建一个 201 状态码的响应，并自动设置 Location 头</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.created(location).body(savedUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回 204 No Content (无内容)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">    userService.deleteById(id);</span><br><span class="line">    <span class="comment">// ResponseEntity.noContent() 创建一个 204 状态码的响应</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回 400 Bad Request (错误请求)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserDTO userDto)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 假设某些业务逻辑校验失败</span></span><br><span class="line">    <span class="keyword">if</span> (userService.isUsernameTaken(userDto.getUsername())) &#123;</span><br><span class="line">         <span class="comment">// ResponseEntity.badRequest() 创建一个 400 状态码的响应</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.badRequest().body(<span class="string">&quot;Username is already taken.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="b-使用链式构建器-更灵活"><a href="#b-使用链式构建器-更灵活" class="headerlink" title="b. 使用链式构建器 (更灵活)"></a>b. 使用链式构建器 (更灵活)</h6><p>如果你需要设置更复杂的状态码或自定义响应头，可以使用构建器模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/custom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">customResponse</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.status(HttpStatus.ACCEPTED) <span class="comment">// 设置状态码为 202 Accepted</span></span><br><span class="line">            .header(<span class="string">&quot;X-Custom-Header&quot;</span>, <span class="string">&quot;MyCustomValue&quot;</span>) <span class="comment">// 添加自定义响应头</span></span><br><span class="line">            .header(HttpHeaders.CACHE_CONTROL, <span class="string">&quot;max-age=3600&quot;</span>) <span class="comment">// 添加标准的响应头</span></span><br><span class="line">            .body(<span class="string">&quot;This is a custom response body.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-ResponseEntity-的核心优势"><a href="#4-ResponseEntity-的核心优势" class="headerlink" title="4. ResponseEntity 的核心优势"></a>4. <code>ResponseEntity</code> 的核心优势</h5><ol>
<li><strong>完全的HTTP响应控制</strong>: 让你能够精确控制状态码、响应头和响应体，是实现真正RESTful API的基石。</li>
<li><strong>代码可读性强</strong>: <code>ResponseEntity.ok()</code>, <code>ResponseEntity.notFound()</code> 等方法让代码的意图一目了然，明确表达了API的返回契约。</li>
<li><strong>灵活性</strong>: 无论是简单的成功响应，还是复杂的带自定义头的错误响应，<code>ResponseEntity</code> 都能优雅地处理。</li>
<li><strong>遵循RESTful最佳实践</strong>: 正确使用HTTP状态码是RESTful设计的重要原则。<code>ResponseEntity</code> 鼓励并简化了这一实践。</li>
</ol>
<p><strong>总结</strong></p>
<p>在现代基于Spring的REST API开发中，<strong>将Controller方法的返回类型声明为 <code>ResponseEntity&lt;T&gt;</code> 是一种最佳实践</strong>。它将HTTP协议的细节以一种优雅、类型安全的方式暴露给开发者，使得我们能够构建出更专业、更健壮、更符合Web标准的应用程序接口。</p>
<hr>
<h4 id="1-4-2-JSON序列化"><a href="#1-4-2-JSON序列化" class="headerlink" title="1.4.2 JSON序列化"></a>1.4.2 <code>JSON序列化</code></h4><h5 id="1-什么是序列化与反序列化？"><a href="#1-什么是序列化与反序列化？" class="headerlink" title="1. 什么是序列化与反序列化？"></a>1. 什么是序列化与反序列化？</h5><p>在Web API的上下文中：</p>
<ul>
<li><strong>序列化 (Serialization)</strong>:<ul>
<li><strong>过程</strong>: 将服务端的 <strong>Java 对象</strong>（如 <code>User</code>、<code>List&lt;Product&gt;</code>）转换为一种可以在网络上传输的、标准化的<strong>文本格式</strong>（通常是 <strong>JSON</strong> 字符串）的过程。</li>
<li><strong>方向</strong>: <code>Java Object -&gt; JSON String</code></li>
<li><strong>何时发生</strong>: 当 <code>@RestController</code> 的方法返回一个Java对象时，Spring MVC会在将响应写入HTTP响应体之前，自动对其进行序列化。</li>
</ul>
</li>
<li><strong>反序列化 (Deserialization)</strong>:<ul>
<li><strong>过程</strong>: 将从客户端HTTP请求体中接收到的 <strong>JSON 字符串</strong>，转换为服务端能够理解和处理的 <strong>Java 对象</strong>的过程。</li>
<li><strong>方向</strong>: <code>JSON String -&gt; Java Object</code></li>
<li><strong>何时发生</strong>: 当Controller方法的参数被 <code>@RequestBody</code> 注解标记时，Spring MVC会自动读取请求体中的JSON数据，并将其反序列化为指定的Java对象。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-Spring-Boot-与-Jackson-的无缝集成"><a href="#2-Spring-Boot-与-Jackson-的无缝集成" class="headerlink" title="2. Spring Boot 与 Jackson 的无缝集成"></a>2. Spring Boot 与 Jackson 的无缝集成</h5><p>Spring Boot 默认选择 <strong>Jackson</strong> (<code>jackson-databind</code> 库)作为其首选的JSON处理库。当你引入 <code>spring-boot-starter-web</code> 或 <code>spring-boot-starter-webflux</code> 时，Jackson 相关的依赖已经被自动包含进来了。</p>
<p>Spring Boot 的自动配置机制会为你完成所有繁琐的整合工作：</p>
<ol>
<li><strong>自动配置 <code>ObjectMapper</code></strong>:<ul>
<li><code>ObjectMapper</code> 是 Jackson 库中进行序列化和反序列化的核心类。</li>
<li>Spring Boot 会自动创建一个预配置好的 <code>ObjectMapper</code> Bean，并将其注册到IoC容器中。这个默认的 <code>ObjectMapper</code> 已经配置了许多最佳实践，比如：<ul>
<li>忽略JSON中未知属性（避免因客户端多传了字段而导致反序列化失败）。</li>
<li>正确处理Java 8的日期时间类型（<code>LocalDate</code>, <code>LocalDateTime</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>自动注册 <code>MappingJackson2HttpMessageConverter</code></strong>:<ul>
<li>这是一个 <code>HttpMessageConverter</code> 的实现，它专门使用 <code>ObjectMapper</code> 来处理 <code>application/json</code> 类型的HTTP请求和响应。</li>
<li>正是这个转换器，在背后默默地为你完成了所有的序列化和反序列化工作。</li>
</ul>
</li>
</ol>
<p><strong>整个过程对开发者是完全透明的</strong>。你只需要在Controller中返回或接收Java对象，Spring Boot和Jackson会处理好剩下的一切。</p>
<hr>
<h5 id="3-Jackson-常用注解"><a href="#3-Jackson-常用注解" class="headerlink" title="3. Jackson 常用注解"></a>3. Jackson 常用注解</h5><p>尽管默认配置已经很好用，但在很多场景下，我们需要对JSON的转换过程进行更精细的控制。Jackson提供了一系列强大的注解来实现这一点。这些注解通常加在<strong>POJO类的字段或getter&#x2F;setter方法</strong>上。</p>
<h6 id="a-控制字段的包含与排除"><a href="#a-控制字段的包含与排除" class="headerlink" title="a. 控制字段的包含与排除"></a>a. 控制字段的包含与排除</h6><ul>
<li><p><strong><code>@JsonIgnore</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 在序列化和反序列化时，<strong>完全忽略</strong>被此注解标记的字段。</li>
<li><strong>场景</strong>: 常用于忽略敏感信息（如密码）或内部状态字段。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">// 这个字段永远不会出现在JSON中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@JsonInclude(JsonInclude.Include.NON_NULL)</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 在序列化时，<strong>只包含那些值不为 <code>null</code> 的字段</strong>。</li>
<li><strong>场景</strong>: 节省网络带宽，使JSON响应更紧凑。可以标记在类上，对所有字段生效；也可以标记在单个字段上。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description; <span class="comment">// 如果description为null，则JSON中不会有这个key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(其他选项如 <code>NON_EMPTY</code>, <code>NON_DEFAULT</code> 也很有用)</p>
</li>
<li><p><strong><code>@JsonIgnoreProperties({&quot;prop1&quot;, &quot;prop2&quot;})</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 在类级别使用，指定一个<strong>要忽略的字段列表</strong>。</li>
<li><strong>场景</strong>: 当你无法修改源码（如第三方库的类）但又想忽略其某些字段时，可以通过Mixin技术配合使用。也常用于解决双向引用导致的无限递归问题。</li>
</ul>
</li>
</ul>
<hr>
<h6 id="b-控制字段的名称"><a href="#b-控制字段的名称" class="headerlink" title="b. 控制字段的名称"></a>b. 控制字段的名称</h6><ul>
<li><p><strong><code>@JsonProperty(&quot;custom_name&quot;)</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 为Java字段指定一个<strong>自定义的JSON属性名</strong>。</li>
<li><strong>场景</strong>: 当Java的命名规范（camelCase，如 <code>firstName</code>）与前端或API契约要求的命名规范（snake_case，如 <code>first_name</code>）不一致时。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@JsonProperty(&quot;first_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 序列化结果: &#123;&quot;first_name&quot;: &quot;...&quot;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="c-控制日期和时间的格式"><a href="#c-控制日期和时间的格式" class="headerlink" title="c. 控制日期和时间的格式"></a>c. 控制日期和时间的格式</h6><ul>
<li><p><strong><code>@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 精确控制 <code>Date</code>, <code>Calendar</code>, <code>LocalDateTime</code> 等日期时间类型在JSON中的格式。</li>
<li><strong>场景</strong>: 统一API的日期时间格式，避免因默认格式（如时间戳或ISO-8601）不满足需求而产生的问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 序列化结果: &#123;&quot;createTime&quot;: &quot;2023-10-27 15:30:00&quot;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="d-控制枚举-Enum-的序列化"><a href="#d-控制枚举-Enum-的序列化" class="headerlink" title="d. 控制枚举 (Enum) 的序列化"></a>d. 控制枚举 (Enum) 的序列化</h6><ul>
<li><p><strong><code>@JsonValue</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 指定使用枚举中的<strong>哪个方法或字段的返回值</strong>作为其JSON表示。</li>
<li><strong>场景</strong>: 默认枚举序列化为它的名字（<code>&quot;PENDING&quot;</code>），如果你想序列化为它的某个属性（如一个整数代码 <code>1</code>）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    PENDING(<span class="number">1</span>, <span class="string">&quot;待处理&quot;</span>),</span><br><span class="line">    PROCESSING(<span class="number">2</span>, <span class="string">&quot;处理中&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 构造函数 ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@JsonValue</span> <span class="comment">// 指定使用getCode()的返回值进行序列化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 序列化结果: 1 (而不是 &quot;PENDING&quot;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="4-全局定制-ObjectMapper"><a href="#4-全局定制-ObjectMapper" class="headerlink" title="4. 全局定制 ObjectMapper"></a>4. 全局定制 <code>ObjectMapper</code></h5><p>如果你想对所有JSON序列化&#x2F;反序列化行为进行统一的、全局的配置（例如，所有日期都按特定格式，所有<code>null</code>值都不序列化），而不是在每个POJO上都加注解，你可以通过自定义 <code>ObjectMapper</code> Bean 来实现。</p>
<p>在Spring Boot中，最推荐的方式是定义一个 <code>Jackson2ObjectMapperBuilderCustomizer</code> Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.SerializationFeature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.jackson.Jackson2ObjectMapperBuilderCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JacksonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Jackson2ObjectMapperBuilderCustomizer <span class="title function_">jsonCustomizer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder -&gt; &#123;</span><br><span class="line">            <span class="comment">// 全局设置：序列化时，所有为null的字段都不参与</span></span><br><span class="line">            builder.serializationInclusion(JsonInclude.Include.NON_NULL);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 全局设置：美化输出（开发时有用，生产环境建议关闭以节省带宽）</span></span><br><span class="line">            builder.featuresToEnable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 全局设置：禁用将日期序列化为时间戳的行为</span></span><br><span class="line">            builder.featuresToDisable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 全局设置：所有Date类型的日期格式</span></span><br><span class="line">            builder.dateFormat(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，你可以在不侵入业务POJO的情况下，实现对JSON行为的全局统一控制。</p>
<p><strong>总结</strong></p>
<p>JSON序列化是现代Web API的“通用语言”。Spring Boot通过与Jackson的深度集成，提供了“零配置”的开箱即用体验。同时，通过丰富的注解和灵活的全局配置，Jackson也赋予了开发者完全掌控JSON数据格式的能力，以满足各种复杂的业务需求。</p>
<hr>
<h3 id="1-5-Web层通用功能"><a href="#1-5-Web层通用功能" class="headerlink" title="1.5 Web层通用功能"></a>1.5 Web层通用功能</h3><h4 id="1-5-1-全局异常处理"><a href="#1-5-1-全局异常处理" class="headerlink" title="1.5.1 全局异常处理"></a>1.5.1 全局异常处理</h4><h5 id="1-为什么需要全局异常处理？"><a href="#1-为什么需要全局异常处理？" class="headerlink" title="1. 为什么需要全局异常处理？"></a>1. 为什么需要全局异常处理？</h5><p>在Web应用开发中，异常是不可避免的。例如：</p>
<ul>
<li><strong>业务异常</strong>: 用户名已存在、余额不足、订单不存在等。</li>
<li><strong>参数校验异常</strong>: 客户端传入的参数不符合格式 (<code>MethodArgumentNotValidException</code>)。</li>
<li><strong>认证&#x2F;授权异常</strong>: 用户未登录、权限不足 (<code>AccessDeniedException</code>)。</li>
<li><strong>系统异常</strong>: 空指针 (<code>NullPointerException</code>)、数据库连接失败等。</li>
</ul>
<p>如果不对这些异常进行处理，Spring Boot的默认行为通常是向客户端返回一个包含大量堆栈信息的、不友好的HTML错误页面（或JSON错误对象）。</p>
<p><strong>默认的错误响应示例</strong>:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-10-27T08:30:00.123+00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Internal Server Error&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;trace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.lang.NullPointerException: ... (长长的堆栈信息) ...&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;...&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/api/users/123&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>这种默认响应的问题</strong>:</p>
<ol>
<li><strong>用户体验差</strong>: 暴露了技术细节，用户看不懂也无法处理。</li>
<li><strong>安全风险</strong>: 堆栈信息可能会泄露服务器的内部实现、库版本等敏感信息。</li>
<li><strong>格式不统一</strong>: 不同的异常可能导致不同格式的响应，不利于前端统一处理。</li>
</ol>
<p><strong>全局异常处理的目标</strong>：创建一个<strong>统一的、集中的机制</strong>来捕获应用程序中抛出的各种异常，并根据异常的类型，返回<strong>结构化的、对客户端友好的、统一格式的错误响应</strong>。</p>
<hr>
<h5 id="2-核心注解"><a href="#2-核心注解" class="headerlink" title="2. 核心注解"></a>2. 核心注解</h5><p>Spring MVC提供了两个核心注解来实现全局异常处理：</p>
<ul>
<li><strong><code>@ControllerAdvice</code></strong> (或其变体 <code>@RestControllerAdvice</code>)<ul>
<li><strong>作用</strong>: 这是一个<strong>组件注解</strong>，用于标记一个类。被标记的类会成为一个<strong>全局的增强控制器</strong>。</li>
<li><strong>职责</strong>: 它可以**“横切”**到所有的（或指定的）<code>@Controller</code> 或 <code>@RestController</code> 上，用于集中处理那些原本需要在多个Controller中重复编写的逻辑，最典型的就是异常处理和全局数据绑定。</li>
<li><strong><code>@RestControllerAdvice</code></strong>: 是 <code>@ControllerAdvice</code> 和 <code>@ResponseBody</code> 的组合。它表示这个类中的所有 <code>@ExceptionHandler</code> 方法的返回值都将直接序列化为JSON并写入响应体，这在构建RESTful API时是首选。</li>
</ul>
</li>
<li><strong><code>@ExceptionHandler</code></strong><ul>
<li><strong>作用</strong>: 用于标记一个<strong>方法</strong>，这个方法必须定义在 <code>@ControllerAdvice</code> 类中（或单个 <code>@Controller</code> 类中）。</li>
<li><strong>职责</strong>: 声明这个方法是用来<strong>处理特定类型的异常</strong>的。你可以在注解的 <code>value</code> 属性中指定它能处理的一个或多个异常类。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-实现一个全局异常处理器"><a href="#3-实现一个全局异常处理器" class="headerlink" title="3. 实现一个全局异常处理器"></a>3. 实现一个全局异常处理器</h5><p>下面是一个典型的全局异常处理器的实现步骤和示例：</p>
<p><strong>Step 1: 创建一个全局异常处理类</strong></p>
<p>创建一个类，并使用 <code>@RestControllerAdvice</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @RestControllerAdvice 会自动扫描所有被@RestController或@Controller标记的类</span></span><br><span class="line"><span class="comment">// 也可以指定扫描范围，如 @RestControllerAdvice(basePackages = &quot;com.example.controller&quot;)</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="comment">// ... 在这里定义异常处理方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Step 2: 编写针对不同异常的处理方法</strong></p>
<p>在类中，为不同类型的异常编写相应的处理方法，并使用 <code>@ExceptionHandler</code> 标记。</p>
<p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理自定义的业务异常 (例如，资源未找到)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ResourceNotFoundException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span> <span class="comment">// 直接指定HTTP状态码</span></span><br><span class="line">    <span class="keyword">public</span> ErrorResponse <span class="title function_">handleResourceNotFoundException</span><span class="params">(ResourceNotFoundException ex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(<span class="number">404</span>, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理参数校验异常 (<span class="doctag">@Valid</span>)</span></span><br><span class="line"><span class="comment">     * 这是最常用的异常处理之一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, String&gt;&gt; <span class="title function_">handleValidationExceptions</span><span class="params">(MethodArgumentNotValidException ex)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; errors = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        ex.getBindingResult().getFieldErrors().forEach(error -&gt; </span><br><span class="line">            errors.put(error.getField(), error.getDefaultMessage())</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(errors, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理其他所有未被捕获的系统级异常 (兜底方案)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorResponse&gt; <span class="title function_">handleGlobalException</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">        <span class="comment">// 在实际项目中，这里应该记录详细的错误日志</span></span><br><span class="line">        <span class="comment">// log.error(&quot;Unhandled exception occurred&quot;, ex); </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向客户端返回一个通用的、模糊的错误信息，隐藏内部细节</span></span><br><span class="line">        <span class="type">ErrorResponse</span> <span class="variable">errorResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(<span class="number">500</span>, <span class="string">&quot;Internal Server Error. Please contact support.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的错误响应体结构</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ErrorResponse</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">        <span class="keyword">private</span> String message;</span><br><span class="line">        <span class="comment">// constructor, getters, setters</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自定义的业务异常类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ResourceNotFoundException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ResourceNotFoundException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-工作流程"><a href="#4-工作流程" class="headerlink" title="4. 工作流程"></a>4. 工作流程</h5><ol>
<li>当任何一个 <code>@Controller</code> 的方法在执行过程中抛出一个<strong>未被<code>try-catch</code>捕获</strong>的异常时，该异常会被Spring MVC的 <code>DispatcherServlet</code> 捕获。</li>
<li><code>DispatcherServlet</code> 会查找所有已注册的 <code>@ControllerAdvice</code> Bean。</li>
<li>它会遍历这些Advice类中的所有 <code>@ExceptionHandler</code> 方法，寻找一个<strong>最匹配</strong>当前抛出异常类型的处理方法。<ul>
<li><strong>匹配规则</strong>: 优先选择最精确匹配的异常类型。例如，如果抛出的是 <code>ResourceNotFoundException</code>，它会优先匹配 <code>handleResourceNotFoundException</code>，而不是更通用的 <code>handleGlobalException</code>。</li>
</ul>
</li>
<li>一旦找到匹配的处理方法，Spring MVC就会调用该方法。</li>
<li>该方法的返回值（通常是一个 <code>ResponseEntity</code> 或被 <code>@ResponseStatus</code> 标记的对象）会被用来构建最终的HTTP响应，返回给客户端。</li>
</ol>
<hr>
<h5 id="5-优势总结"><a href="#5-优势总结" class="headerlink" title="5. 优势总结"></a>5. 优势总结</h5><ol>
<li><strong>代码解耦和集中化</strong>: 将异常处理逻辑从业务代码（Controller）中完全分离出来，避免了在每个Controller方法中都写<code>try-catch</code>块，使得业务代码更纯粹、更专注于其核心职责。</li>
<li><strong>统一的错误响应格式</strong>: 确保了无论发生何种错误，API返回给客户端的错误信息都遵循统一的、预先定义好的结构，极大地简化了前端的处理逻辑。</li>
<li><strong>提升安全性</strong>: 避免了直接暴露系统内部的堆栈信息，只向外部提供有意义的、安全的错误提示。</li>
<li><strong>可维护性高</strong>: 当需要修改错误处理逻辑或错误响应格式时，只需修改全局异常处理器这一个地方即可。</li>
</ol>
<p><strong>最佳实践</strong>: 在任何生产级的Spring Boot项目中，都应该实现一个健壮的 <code>GlobalExceptionHandler</code>，它至少应该能处理：</p>
<ul>
<li><strong>参数校验异常</strong> (<code>MethodArgumentNotValidException</code>)</li>
<li><strong>自定义的业务异常</strong> (继承自 <code>RuntimeException</code>)</li>
<li><strong>一个通用的 <code>Exception</code> 兜底处理器</strong></li>
</ul>
<hr>
<h4 id="1-5-2-过滤器-Filter-vs-拦截器-Interceptor"><a href="#1-5-2-过滤器-Filter-vs-拦截器-Interceptor" class="headerlink" title="1.5.2 过滤器 (Filter) vs 拦截器 (Interceptor)"></a>1.5.2 过滤器 (Filter) vs 拦截器 (Interceptor)</h4><h5 id="1-过滤器-Filter"><a href="#1-过滤器-Filter" class="headerlink" title="1. 过滤器 (Filter)"></a><strong>1. 过滤器 (Filter)</strong></h5><h6 id="a-核心定义与归属"><a href="#a-核心定义与归属" class="headerlink" title="a. 核心定义与归属"></a><strong>a. 核心定义与归属</strong></h6><ul>
<li><strong>归属</strong>: <strong>Servlet规范</strong> 的一部分，定义在 <code>javax.servlet.Filter</code> 接口中。</li>
<li><strong>定位</strong>: 它是Java Web技术栈中的一个<strong>底层</strong>组件，不依赖于任何特定的Web框架（如Spring MVC）。理论上，任何实现了Servlet规范的Web容器（如Tomcat, Jetty）都支持Filter。</li>
<li><strong>工作层面</strong>: 工作在 <strong>Servlet容器层面</strong>，在请求进入 <code>DispatcherServlet</code> <strong>之前</strong>，以及响应从 <code>DispatcherServlet</code> 返回 <strong>之后</strong>被调用。</li>
</ul>
<h6 id="b-工作流程"><a href="#b-工作流程" class="headerlink" title="b. 工作流程"></a><strong>b. 工作流程</strong></h6><p>Filter构成了一个<strong>责任链 (Chain of Responsibility)</strong>。一个请求在到达目标Servlet（在Spring MVC中就是<code>DispatcherServlet</code>）之前，会依次穿过这个链上的所有Filter。</p>
<p><strong>请求流程</strong>:</p>
<p><code>Request</code> -&gt; <code>Filter1.doFilter()</code> -&gt; <code>Filter2.doFilter()</code> -&gt; … -&gt; <code>DispatcherServlet</code></p>
<p><strong>响应流程</strong>:</p>
<p><code>Request</code> &lt;- <code>Filter1.doFilter()</code> &lt;- <code>Filter2.doFilter()</code> &lt;- … &lt;- <code>DispatcherServlet</code></p>
<p><code>doFilter(ServletRequest, ServletResponse, FilterChain)</code> 方法是其核心：</p>
<ul>
<li>在 <code>chain.doFilter(request, response)</code> <strong>之前</strong>的代码，是在<strong>请求处理前</strong>执行的。</li>
<li><code>chain.doFilter(request, response)</code> 这行代码的作用是将请求<strong>传递给链中的下一个Filter</strong>，如果已经是最后一个Filter，则传递给目标Servlet。</li>
<li>在 <code>chain.doFilter(request, response)</code> <strong>之后</strong>的代码，是在<strong>响应返回时</strong>执行的。</li>
</ul>
<h6 id="c-实现方式-在Spring-Boot中"><a href="#c-实现方式-在Spring-Boot中" class="headerlink" title="c. 实现方式 (在Spring Boot中)"></a><strong>c. 实现方式 (在Spring Boot中)</strong></h6><ol>
<li>创建一个类实现 <code>javax.servlet.Filter</code> 接口。</li>
<li>使用 <code>@Component</code> 将其注册为Bean，Spring Boot会自动发现并配置它。</li>
<li>可以使用 <code>@Order</code> 注解来指定多个Filter之间的执行顺序（值越小，优先级越高）。</li>
</ol>
<p><strong>示例：一个简单的日志Filter</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span> <span class="comment">// 设置执行顺序为1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Filter: Request received for URL: &quot;</span> + req.getRequestURI());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将请求传递下去</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">        System.out.println(<span class="string">&quot;Filter: Request processed in &quot;</span> + duration + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// init() 和 destroy() 方法可以留空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="d-功能与适用场景"><a href="#d-功能与适用场景" class="headerlink" title="d. 功能与适用场景"></a><strong>d. 功能与适用场景</strong></h6><p>由于Filter工作在非常靠前的位置，它能够：</p>
<ul>
<li><strong>修改请求和响应对象</strong>: 在请求到达Servlet之前，可以替换或包装 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 对象。</li>
<li><strong>访问原始的HTTP信息</strong>: 可以获取到最原始的请求数据，不受任何框架处理。</li>
<li><strong>进行请求拦截与重定向</strong>: 在 <code>chain.doFilter()</code> 调用之前，可以直接中断请求流程，例如进行重定向或返回错误响应。</li>
</ul>
<p><strong>适用场景</strong>:</p>
<ul>
<li><strong>全局编码转换</strong>: 如设置所有请求和响应的字符编码为UTF-8。</li>
<li><strong>XSS&#x2F;CSRF防护</strong>: 对所有请求的参数进行安全过滤。</li>
<li><strong>GZIP压缩</strong>: 对响应内容进行压缩。</li>
<li><strong>实现CORS跨域</strong>: 在响应中添加CORS相关的头信息。</li>
<li><strong>记录所有请求的访问日志 (Access Log)</strong>。</li>
</ul>
<hr>
<h5 id="2-拦截器-Interceptor"><a href="#2-拦截器-Interceptor" class="headerlink" title="2. 拦截器 (Interceptor)"></a><strong>2. 拦截器 (Interceptor)</strong></h5><h6 id="a-核心定义与归属-1"><a href="#a-核心定义与归属-1" class="headerlink" title="a. 核心定义与归属"></a><strong>a. 核心定义与归属</strong></h6><ul>
<li><strong>归属</strong>: <strong>Spring MVC框架</strong> 的一部分，定义在 <code>org.springframework.web.servlet.HandlerInterceptor</code> 接口中。</li>
<li><strong>定位</strong>: 它是Spring MVC<strong>专属</strong>的组件，依赖于Spring的IoC容器。</li>
<li><strong>工作层面</strong>: 工作在 <strong>Spring MVC框架层面</strong>，在请求进入 <code>DispatcherServlet</code> <strong>之后</strong>，但在 <code>Controller</code> 的方法被调用 <strong>之前&#x2F;之后</strong>被调用。</li>
</ul>
<h6 id="b-工作流程-1"><a href="#b-工作流程-1" class="headerlink" title="b. 工作流程"></a><strong>b. 工作流程</strong></h6><p>拦截器提供了更精细的控制点，它有三个核心方法：</p>
<ol>
<li><strong><code>preHandle(request, response, handler)</code></strong>:<ul>
<li><strong>调用时机</strong>: 在 <code>HandlerAdapter</code> 调用 <code>Controller</code> 方法<strong>之前</strong>执行。</li>
<li><strong>返回值</strong>: 返回 <code>true</code> 表示继续执行后续的拦截器和Controller；返回 <code>false</code> 表示<strong>中断请求</strong>，后续的拦截器和Controller都不会被执行。</li>
<li><strong>用途</strong>: 主要用于<strong>权限认证、登录校验</strong>等。</li>
</ul>
</li>
<li><strong><code>postHandle(request, response, handler, modelAndView)</code></strong>:<ul>
<li><strong>调用时机</strong>: 在 <code>Controller</code> 方法<strong>执行之后</strong>，但在<strong>视图渲染之前</strong>执行。</li>
<li><strong>用途</strong>: 可以在视图渲染前，对<strong>模型数据 (<code>ModelAndView</code>) 进行修改</strong>或添加公共的属性。</li>
</ul>
</li>
<li><strong><code>afterCompletion(request, response, handler, ex)</code></strong>:<ul>
<li><strong>调用时机</strong>: 在整个请求处理完成（包括<strong>视图渲染之后</strong>）执行。</li>
<li><strong>用途</strong>: 主要用于<strong>资源清理</strong>、<strong>记录异常日志</strong>、<strong>性能监控</strong>等。无论请求处理过程中是否发生异常，这个方法<strong>都会被调用</strong>（前提是<code>preHandle</code>返回<code>true</code>）。</li>
</ul>
</li>
</ol>
<h6 id="c-实现方式-在Spring-Boot中-1"><a href="#c-实现方式-在Spring-Boot中-1" class="headerlink" title="c. 实现方式 (在Spring Boot中)"></a><strong>c. 实现方式 (在Spring Boot中)</strong></h6><ol>
<li>创建一个类实现 <code>HandlerInterceptor</code> 接口。</li>
<li>创建一个配置类实现 <code>WebMvcConfigurer</code> 接口。</li>
<li>重写 <code>addInterceptors(InterceptorRegistry registry)</code> 方法，将自定义的拦截器注册到Spring MVC中，并可以指定要拦截的URL路径模式。</li>
</ol>
<p><strong>示例：一个简单的认证拦截器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 实现 HandlerInterceptor</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (token != <span class="literal">null</span> &amp;&amp; token.equals(<span class="string">&quot;valid-token&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Interceptor: Authentication passed.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 放行</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Interceptor: Authentication failed.&quot;</span>);</span><br><span class="line">            response.setStatus(<span class="number">401</span>); <span class="comment">// 设置未授权状态码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 中断请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 注册 Interceptor</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthInterceptor authInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(authInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/api/**&quot;</span>) <span class="comment">// 指定拦截以/api/开头的路径</span></span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/api/login&quot;</span>); <span class="comment">// 排除登录接口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="d-功能与适用场景-1"><a href="#d-功能与适用场景-1" class="headerlink" title="d. 功能与适用场景"></a><strong>d. 功能与适用场景</strong></h6><p>由于拦截器工作在Spring MVC内部，它能够：</p>
<ul>
<li><strong>访问到处理器信息</strong>: <code>preHandle</code> 方法的 <code>handler</code> 参数是 <code>HandlerMethod</code> 对象，可以获取到即将要调用的Controller、方法、方法上的注解等详细信息。</li>
<li><strong>访问和修改<code>ModelAndView</code></strong>: 在 <code>postHandle</code> 中可以修改即将渲染到视图的数据。</li>
<li><strong>利用Spring的IoC容器</strong>: 拦截器本身就是一个Bean，可以方便地注入其他Service等Bean来执行复杂的业务逻辑。</li>
</ul>
<p><strong>适用场景</strong>:</p>
<ul>
<li><strong>用户登录状态校验</strong>。</li>
<li><strong>接口权限验证</strong>。</li>
<li><strong>向<code>Model</code>中添加公共数据</strong>（如网站的全局导航信息）。</li>
<li><strong>记录接口的调用日志</strong>（包含哪个Controller的哪个方法被调用）。</li>
<li><strong>性能监控</strong>（计算Controller方法的执行时间）。</li>
</ul>
<hr>
<h5 id="3-总结与对比"><a href="#3-总结与对比" class="headerlink" title="3. 总结与对比"></a>3. 总结与对比</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">过滤器 (Filter)</th>
<th align="left">拦截器 (Interceptor)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>归属</strong></td>
<td align="left"><strong>Servlet规范</strong>，不依赖Spring</td>
<td align="left"><strong>Spring MVC框架</strong>的一部分，依赖Spring</td>
</tr>
<tr>
<td align="left"><strong>执行时机</strong></td>
<td align="left">在<code>DispatcherServlet</code><strong>之前&#x2F;之后</strong>，更靠前</td>
<td align="left">在<code>Controller</code>方法<strong>之前&#x2F;之中&#x2F;之后</strong>，更靠后</td>
</tr>
<tr>
<td align="left"><strong>控制粒度</strong></td>
<td align="left"><strong>粗粒度</strong>。只能访问原始的<code>Request</code>和<code>Response</code>。</td>
<td align="left"><strong>细粒度</strong>。可以访问<code>HandlerMethod</code>、<code>ModelAndView</code>等框架内部对象。</td>
</tr>
<tr>
<td align="left"><strong>功能范围</strong></td>
<td align="left">能处理所有进入Servlet容器的请求，包括<strong>静态资源</strong>。</td>
<td align="left"><strong>只能处理</strong>经过<code>DispatcherServlet</code>的请求，默认不处理静态资源。</td>
</tr>
<tr>
<td align="left"><strong>依赖注入</strong></td>
<td align="left">本身是Bean，可以注入其他Bean，但无法直接获取Spring MVC上下文信息。</td>
<td align="left">本身是Bean，可以方便地注入Service等，并能获取Spring MVC上下文。</td>
</tr>
<tr>
<td align="left"><strong>典型用途</strong></td>
<td align="left">编码、CORS、安全过滤、GZIP压缩</td>
<td align="left">登录校验、权限控制、日志记录、性能监控</td>
</tr>
</tbody></table>
<p><strong>一句话总结</strong>:</p>
<ul>
<li>如果你想做一些<strong>与框架无关</strong>的、<strong>针对所有HTTP请求</strong>的底层操作，请使用<strong>过滤器 (Filter)</strong>。</li>
<li>如果你想做一些<strong>与Spring MVC应用相关</strong>的、<strong>需要访问Controller或模型数据</strong>的精细化控制，请使用<strong>拦截器 (Interceptor)</strong>。</li>
</ul>
<hr>
<h4 id="1-5-3-文件上传与下载"><a href="#1-5-3-文件上传与下载" class="headerlink" title="1.5.3 文件上传与下载"></a>1.5.3 文件上传与下载</h4><p>Spring Boot 对文件上传进行了自动配置，使得处理上传文件变得非常简单。核心是使用 <code>MultipartFile</code> 接口来接收上传的文件数据。</p>
<h5 id="1-文件上传"><a href="#1-文件上传" class="headerlink" title="1. 文件上传"></a>1. 文件上传</h5><h6 id="a-前端准备-HTML-Form"><a href="#a-前端准备-HTML-Form" class="headerlink" title="a. 前端准备 (HTML Form)"></a>a. 前端准备 (HTML Form)</h6><p>要实现文件上传，前端的HTML表单必须满足三个条件：</p>
<ol>
<li><code>method</code> 必须是 <strong><code>POST</code></strong>。</li>
<li><code>enctype</code> (encoding type) 必须设置为 <strong><code>multipart/form-data</code></strong>。这告诉浏览器要以二进制的形式分段上传数据，而不是普通的文本。</li>
<li><code>input</code> 标签的 <code>type</code> 必须是 <strong><code>file</code></strong>。</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>File Upload Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Upload a Single File<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/upload/single&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Upload<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Upload Multiple Files<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/upload/multiple&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &#x27;multiple&#x27; attribute allows selecting multiple files --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;files&quot;</span> <span class="attr">multiple</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Upload<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h6 id="b-Spring-Boot-配置-application-yml"><a href="#b-Spring-Boot-配置-application-yml" class="headerlink" title="b. Spring Boot 配置 (application.yml)"></a>b. Spring Boot 配置 (application.yml)</h6><p>Spring Boot 允许你配置一些文件上传的限制，这对于防止恶意的大文件上传非常重要。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">multipart:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 默认开启</span></span><br><span class="line">      <span class="comment"># 单个文件的最大大小，默认1MB</span></span><br><span class="line">      <span class="attr">max-file-size:</span> <span class="string">10MB</span></span><br><span class="line">      <span class="comment"># 单次请求的总文件大小，默认10MB</span></span><br><span class="line">      <span class="attr">max-request-size:</span> <span class="string">100MB</span></span><br><span class="line">      <span class="comment"># 文件写入磁盘的阈值，超过这个大小会先写入临时文件，默认0</span></span><br><span class="line">      <span class="comment"># file-size-threshold: 2KB</span></span><br><span class="line">      <span class="comment"># 上传文件的临时存储目录</span></span><br><span class="line">      <span class="comment"># location: /path/to/temp</span></span><br></pre></td></tr></table></figure>

<hr>
<h6 id="c-后端Controller实现"><a href="#c-后端Controller实现" class="headerlink" title="c. 后端Controller实现"></a>c. 后端Controller实现</h6><p>在Controller中，我们使用 <code>@RequestParam</code> 注解，并将参数类型声明为 <code>MultipartFile</code> 或 <code>MultipartFile[]</code> 来接收文件。</p>
<p><strong>i. 处理单个文件上传</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">uploadDir</span> <span class="operator">=</span> <span class="string">&quot;D:/uploads/&quot;</span>; <span class="comment">// 文件存储目录，请替换为实际路径</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload/single&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">uploadSingleFile</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.badRequest().body(<span class="string">&quot;Please select a file to upload.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取原始文件名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">            <span class="comment">// 获取文件扩展名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">            <span class="comment">// 生成新的唯一文件名，防止重名覆盖</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">newFileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + extension;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建目标文件</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(uploadDir + newFileName);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 确保目录存在</span></span><br><span class="line">            <span class="keyword">if</span> (!dest.getParentFile().exists()) &#123;</span><br><span class="line">                dest.getParentFile().mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将上传的文件内容写入到目标文件</span></span><br><span class="line">            file.transferTo(dest);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;File uploaded successfully: &quot;</span> + newFileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 记录异常日志</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.internalServerError().body(<span class="string">&quot;File upload failed: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>MultipartFile</code> 接口常用方法</strong>:</p>
<ul>
<li><code>String getOriginalFilename()</code>: 获取上传文件的原始名称。</li>
<li><code>String getContentType()</code>: 获取文件的MIME类型，如 <code>image/jpeg</code>。</li>
<li><code>long getSize()</code>: 获取文件的大小（字节）。</li>
<li><code>byte[] getBytes()</code>: 获取文件的字节数组。</li>
<li><code>InputStream getInputStream()</code>: 获取文件的输入流。</li>
<li><code>void transferTo(File dest)</code>: <strong>最常用</strong>的方法，将文件内容快速保存到目标文件。</li>
<li><code>boolean isEmpty()</code>: 判断是否上传了空文件。</li>
</ul>
<p><strong>ii. 处理多个文件上传</strong></p>
<p>处理多个文件时，只需将参数类型改为 <code>MultipartFile[]</code> 或 <code>List&lt;MultipartFile&gt;</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload/multiple&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">uploadMultipleFiles</span><span class="params">(<span class="meta">@RequestParam(&quot;files&quot;)</span> MultipartFile[] files)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (files.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.badRequest().body(<span class="string">&quot;Please select at least one file.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; uploadedFileNames = Arrays.stream(files)</span><br><span class="line">            .map(file -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// ... (与单文件上传类似的保存逻辑) ...</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">newFileName</span> <span class="operator">=</span> saveFile(file); <span class="comment">// 假设saveFile是封装好的保存方法</span></span><br><span class="line">                    <span class="keyword">return</span> newFileName;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;failed-to-upload-&quot;</span> + file.getOriginalFilename();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;Files uploaded: &quot;</span> + uploadedFileNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-文件下载-File-Download"><a href="#2-文件下载-File-Download" class="headerlink" title="2. 文件下载 (File Download)"></a><strong>2. 文件下载 (File Download)</strong></h5><p>文件下载的本质是：后端Controller从服务器的某个位置（文件系统、数据库、对象存储等）读取文件内容，然后将其作为HTTP响应体返回给客户端，并设置特定的<strong>响应头</strong>，告诉浏览器这是一个需要下载的文件，而不是直接在页面上显示。</p>
<p>关键的响应头是 <code>Content-Disposition</code>。</p>
<p>我们可以使用 <code>ResponseEntity&lt;Resource&gt;</code> 来实现文件下载，这是最灵活、最推荐的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDownloadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Path</span> <span class="variable">fileStorageLocation</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:/uploads/&quot;</span>).toAbsolutePath().normalize();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/download/&#123;fileName:.+&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Resource&gt; <span class="title function_">downloadFile</span><span class="params">(<span class="meta">@PathVariable</span> String fileName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 构建文件路径</span></span><br><span class="line">            <span class="type">Path</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="built_in">this</span>.fileStorageLocation.resolve(fileName).normalize();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 创建一个Resource对象来代表文件</span></span><br><span class="line">            <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(filePath.toUri());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 检查文件是否存在且可读</span></span><br><span class="line">            <span class="keyword">if</span> (!resource.exists() || !resource.isReadable()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;File not found or is not readable: &quot;</span> + fileName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 设置Content-Disposition响应头</span></span><br><span class="line">            <span class="comment">//    &quot;attachment&quot; 表示作为附件下载</span></span><br><span class="line">            <span class="comment">//    &quot;filename&quot; 是下载时显示的文件名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> <span class="string">&quot;application/octet-stream&quot;</span>; <span class="comment">// 通用的二进制流类型</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">headerValue</span> <span class="operator">=</span> <span class="string">&quot;attachment; filename=\&quot;&quot;</span> + resource.getFilename() + <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.ok()</span><br><span class="line">                    .contentType(MediaType.parseMediaType(contentType))</span><br><span class="line">                    .header(HttpHeaders.CONTENT_DISPOSITION, headerValue)</span><br><span class="line">                    .body(resource);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;File path error&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解析</strong>:</p>
<ol>
<li><strong><code>{fileName:.+}</code></strong>: 路径变量中的 <code>:.+</code> 是一个正则表达式，确保文件名中如果包含 <code>.</code> (点号) 也能被正确匹配。</li>
<li><strong><code>Resource</code> 接口</strong>: Spring提供的资源抽象接口，<code>UrlResource</code> 是其一个实现，用于从文件系统、URL等位置加载资源。</li>
<li><strong><code>HttpHeaders.CONTENT_DISPOSITION</code></strong>:<ul>
<li>这是文件下载的<strong>核心</strong>。</li>
<li><code>attachment</code>: 告诉浏览器这是一个需要下载的附件，浏览器会弹出“另存为”对话框。</li>
<li>如果设置为 <code>inline</code>，浏览器会尝试在页面内直接显示文件（例如PDF、图片）。</li>
<li><code>filename=&quot;...&quot;</code>: 指定下载时默认的文件名。为了处理文件名中的特殊字符，最好用双引号包裹。</li>
</ul>
</li>
<li><strong><code>MediaType.APPLICATION_OCTET_STREAM</code></strong>:<ul>
<li>这是一个通用的MIME类型，表示未知的二进制数据。它通常会强制浏览器触发下载。</li>
<li>如果你知道文件的确切类型（如<code>image/jpeg</code>），设置具体的MediaType会更好。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h5><p>Spring MVC 极大地简化了文件上传和下载的处理。</p>
<ul>
<li><strong>上传</strong>: 通过 <code>MultipartFile</code> 和 <code>multipart/form-data</code>，结合简单的配置，即可轻松接收文件。</li>
<li><strong>下载</strong>: 通过 <code>ResponseEntity&lt;Resource&gt;</code>，并正确设置 <code>Content-Disposition</code> 响应头，可以实现健壮、灵活的文件下载功能。</li>
</ul>
<hr>
<h4 id="1-5-4-CORS-跨域资源共享"><a href="#1-5-4-CORS-跨域资源共享" class="headerlink" title="1.5.4 CORS(跨域资源共享)"></a>1.5.4 CORS(跨域资源共享)</h4><h5 id="1-什么是跨域？"><a href="#1-什么是跨域？" class="headerlink" title="1. 什么是跨域？"></a>1. 什么是跨域？</h5><p><strong>跨域 (Cross-Origin)</strong> 是由浏览器的<strong>同源策略 (Same-Origin Policy)</strong> 引起的一种安全限制。</p>
<p><strong>同源策略</strong>规定：一个源（Origin）的网页脚本，在未经允许的情况下，不能访问另一个源的资源。</p>
<p><strong>什么是“源 (Origin)”？</strong></p>
<p>一个源由三个部分组成：<strong>协议 (Protocol) + 域名 (Host) + 端口 (Port)</strong>。</p>
<p>只要这三者中<strong>有任何一个不同</strong>，就被认为是<strong>跨域</strong>。</p>
<p><strong>示例</strong>:</p>
<p>假设当前页面的源是 <code>http://app.example.com:8080</code></p>
<table>
<thead>
<tr>
<th align="left">要请求的URL</th>
<th align="left">是否跨域</th>
<th align="left">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>http://app.example.com:8080/data</code></td>
<td align="left"><strong>否</strong></td>
<td align="left">同源</td>
</tr>
<tr>
<td align="left"><code>https://app.example.com:8080/data</code></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>协议</strong>不同 (http vs https)</td>
</tr>
<tr>
<td align="left"><code>http://api.example.com:8080/data</code></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>域名</strong>不同 (app vs api)</td>
</tr>
<tr>
<td align="left"><code>http://app.example.com:9090/data</code></td>
<td align="left"><strong>是</strong></td>
<td align="left"><strong>端口</strong>不同 (8080 vs 9090)</td>
</tr>
</tbody></table>
<p><strong>常见的前后端分离开发场景</strong>:</p>
<ul>
<li>前端应用（如Vue, React）运行在 <code>http://localhost:3000</code>。</li>
<li>后端Spring Boot API运行在 <code>http://localhost:8080</code>。</li>
<li>前端代码通过AJAX（如<code>fetch</code>, <code>axios</code>）请求后端API时，由于<strong>端口不同</strong>，就构成了<strong>跨域请求</strong>。</li>
</ul>
<p><strong>跨域限制的是什么？</strong></p>
<p>浏览器<strong>实际上已经发送了请求</strong>，并且<strong>后端服务器也已经处理并返回了响应</strong>。但是，浏览器在接收到响应后，会检查响应头，如果发现不符合CORS规范，就会<strong>拦截这个响应</strong>，不允许前端JavaScript代码读取它，并在控制台抛出CORS相关的错误。</p>
<hr>
<h5 id="2-CORS-跨域资源共享-机制"><a href="#2-CORS-跨域资源共享-机制" class="headerlink" title="2. CORS (跨域资源共享) 机制"></a>2. CORS (跨域资源共享) 机制</h5><p>CORS 是一种W3C标准，它允许服务器在HTTP响应头中添加一些额外的字段，来**“告诉”浏览器，我允许来自指定源的跨域请求**。</p>
<p>CORS请求分为两类：</p>
<ul>
<li><strong>简单请求 (Simple Request)</strong>:<ul>
<li>满足特定条件（如GET&#x2F;HEAD&#x2F;POST方法，Content-Type为特定值等）的请求。</li>
<li>浏览器直接发送实际请求，并在请求头中携带 <code>Origin</code> 字段，表明请求来源。</li>
<li>服务器在响应头中返回 <code>Access-Control-Allow-Origin</code> 字段。如果该字段的值包含了请求的<code>Origin</code>（或者是<code>*</code>），浏览器就认为跨域访问被允许。</li>
</ul>
</li>
<li><strong>非简单请求 (Preflighted Request)</strong>:<ul>
<li>不满足简单请求条件的请求，例如 <code>PUT</code>, <code>DELETE</code> 方法，或者 <code>Content-Type</code> 为 <code>application/json</code> 的 <code>POST</code> 请求。</li>
<li>浏览器会先发送一个<strong>预检请求 (Preflight Request)</strong>，这是一个 <strong><code>OPTIONS</code></strong> 方法的请求。</li>
<li>这个<code>OPTIONS</code>请求会询问服务器：“我接下来要用<code>PUT</code>方法，带着<code>Content-Type: application/json</code>头来请求<code>/api/users/1</code>，你允许吗？”</li>
<li>服务器如果允许，需要在<code>OPTIONS</code>请求的响应头中返回 <code>Access-Control-Allow-Origin</code>, <code>Access-Control-Allow-Methods</code>, <code>Access-Control-Allow-Headers</code> 等字段来表明许可。</li>
<li>浏览器收到<code>OPTIONS</code>的成功响应后，<strong>才会发送真正的<code>PUT</code>请求</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-在Spring-Boot中解决CORS问题"><a href="#3-在Spring-Boot中解决CORS问题" class="headerlink" title="3. 在Spring Boot中解决CORS问题"></a>3. 在Spring Boot中解决CORS问题</h5><p>Spring MVC 提供了非常优雅的方式来配置CORS，主要有两种：<strong>局部配置</strong>和<strong>全局配置</strong>。</p>
<h6 id="a-局部配置-CrossOrigin-注解"><a href="#a-局部配置-CrossOrigin-注解" class="headerlink" title="a. 局部配置: @CrossOrigin 注解"></a><strong>a. 局部配置: <code>@CrossOrigin</code> 注解</strong></h6><p>这是最简单、最快捷的方式，用于对<strong>单个Controller</strong>或<strong>单个方法</strong>开放跨域。</p>
<ul>
<li><p><strong>作用</strong>: 在 <code>@RestController</code> 类或 <code>@RequestMapping</code> 方法上添加 <code>@CrossOrigin</code> 注解。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.CrossOrigin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="comment">// 对整个Controller下的所有方法都生效</span></span><br><span class="line"><span class="meta">@CrossOrigin(origins = &quot;http://localhost:3000&quot;, maxAge = 3600)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDataController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/data&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Some data from backend&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/public-data&quot;)</span></span><br><span class="line">    <span class="comment">// 如果类上已经有注解，方法上的注解会覆盖类的配置</span></span><br><span class="line">    <span class="meta">@CrossOrigin</span> <span class="comment">// 不指定origins，默认允许所有源</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPublicData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Public data&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>常用属性</strong>:</p>
<ul>
<li><code>origins</code> (或 <code>value</code>): 字符串数组，允许的源列表。<code>&quot;*&quot;</code> 表示允许所有源（生产环境慎用）。</li>
<li><code>methods</code>: 允许的HTTP方法，如 <code>RequestMethod.GET</code>, <code>RequestMethod.POST</code>。</li>
<li><code>allowedHeaders</code>: 允许的请求头。</li>
<li><code>exposedHeaders</code>: 允许前端JS访问的响应头。默认情况下，前端只能访问一些简单响应头。</li>
<li><code>allowCredentials</code>: 是否允许发送Cookie。默认为<code>&quot;false&quot;</code>。设为<code>&quot;true&quot;</code>时，<code>origins</code>不能为<code>&quot;*&quot;</code>，必须指定具体的源。</li>
<li><code>maxAge</code>: 预检请求的缓存时间（秒）。</li>
</ul>
</li>
</ul>
<hr>
<h6 id="b-全局配置-WebMvcConfigurer-推荐"><a href="#b-全局配置-WebMvcConfigurer-推荐" class="headerlink" title="b. 全局配置: WebMvcConfigurer (推荐)"></a><strong>b. 全局配置: <code>WebMvcConfigurer</code> (推荐)</strong></h6><p>当整个应用都需要统一的CORS策略时，全局配置是最佳实践。这避免了在每个Controller上都重复添加 <code>@CrossOrigin</code> 注解。</p>
<ul>
<li><p><strong>作用</strong>: 创建一个配置类，实现 <code>WebMvcConfigurer</code> 接口，并重写 <code>addCorsMappings</code> 方法。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>) <span class="comment">// 1. 对所有路径应用CORS配置</span></span><br><span class="line">                .allowedOrigins(<span class="string">&quot;http://localhost:3000&quot;</span>, <span class="string">&quot;http://prod.example.com&quot;</span>) <span class="comment">// 2. 允许的源</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>) <span class="comment">// 3. 允许的方法</span></span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>) <span class="comment">// 4. 允许的请求头</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>) <span class="comment">// 5. 是否允许发送Cookie</span></span><br><span class="line">                .maxAge(<span class="number">3600</span>); <span class="comment">// 6. 预检请求的有效期</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代码解析</strong>:</p>
<ol>
<li><code>addMapping(&quot;/**&quot;)</code>: 指定CORS配置应用的路径模式。<code>/**</code> 表示应用到所有接口。你也可以指定更具体的路径，如 <code>/api/**</code>。</li>
<li><code>allowedOrigins(...)</code>: 指定允许跨域请求的来源。</li>
<li><code>allowedMethods(...)</code>: 指定允许的HTTP方法。</li>
<li><code>allowedHeaders(&quot;*&quot;)</code>: <code>*</code> 表示允许所有请求头。</li>
<li><code>allowCredentials(true)</code>: 允许客户端携带认证信息（如Cookie）。</li>
<li><code>maxAge(3600)</code>: 设置预检请求的缓存时间为1小时，在此期间内，浏览器对相同的跨域请求无需再发送<code>OPTIONS</code>预检。</li>
</ol>
</li>
</ul>
<p><strong>全局配置 vs. 局部配置</strong>:</p>
<ul>
<li><strong>全局配置</strong>是管理整个应用CORS策略的首选，因为它<strong>集中、统一、易于维护</strong>。</li>
<li><strong>局部 <code>@CrossOrigin</code> 注解</strong>适用于对<strong>特定接口</strong>进行<strong>临时或特殊</strong>的CORS设置，可以作为全局配置的补充或覆盖。</li>
</ul>
<hr>
<h3 id="1-6-RESTful-API-设计原则"><a href="#1-6-RESTful-API-设计原则" class="headerlink" title="1.6 RESTful API 设计原则"></a>1.6 RESTful API 设计原则</h3><p>RESTful是一种架构风格，其核心是遵循一系列<strong>架构约束 (Architectural Constraints)</strong>。当一个系统完全遵循这些约束时，它就是RESTful的。这些约束旨在创建一个可伸缩、高性能、可靠且易于演进的分布式系统。</p>
<h4 id="1-6-1-REST的六大核心约束"><a href="#1-6-1-REST的六大核心约束" class="headerlink" title="1.6.1 REST的六大核心约束"></a>1.6.1 REST的六大核心约束</h4><h5 id="1-客户端-服务器-Client-Server"><a href="#1-客户端-服务器-Client-Server" class="headerlink" title="1. 客户端-服务器 (Client-Server)"></a>1. 客户端-服务器 (Client-Server)</h5><ul>
<li><strong>约束</strong>: 客户端和服务器的关注点必须完全分离。</li>
<li><strong>解读</strong>:<ul>
<li><strong>客户端</strong>负责用户界面和用户体验（UI&#x2F;UX）。</li>
<li><strong>服务器</strong>负责数据存储、业务逻辑和安全。</li>
<li>它们之间仅通过一个标准化的接口（HTTP）进行通信。</li>
</ul>
</li>
<li><strong>带来的好处</strong>:<ul>
<li><strong>独立演进</strong>: 前端团队和后端团队可以独立开发、测试和部署，只要双方遵守API契约。</li>
<li><strong>多平台支持</strong>: 同一个后端API可以为Web应用、移动App（iOS&#x2F;Android）、桌面应用等多种客户端提供服务。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-无状态-Stateless"><a href="#2-无状态-Stateless" class="headerlink" title="2. 无状态 (Stateless)"></a>2. 无状态 (Stateless)</h5><ul>
<li><strong>约束</strong>: 从客户端到服务器的每个请求都必须包含处理该请求所需的所有信息。服务器不能在多次请求之间存储任何关于客户端的上下文（会话状态）。</li>
<li><strong>解读</strong>:<ul>
<li>如果需要认证，客户端必须在<strong>每个请求</strong>中都携带身份凭证（例如，放在<code>Authorization</code>头中的JWT）。</li>
<li>服务器处理完请求后，“忘记”关于这个客户端的一切。</li>
</ul>
</li>
<li><strong>带来的好处</strong>:<ul>
<li><strong>高可靠性</strong>: 如果一个服务器实例失败，请求可以无缝地路由到另一个实例，因为服务器不依赖本地会话数据。</li>
<li><strong>高可伸缩性</strong>: 易于进行负载均衡和水平扩展。</li>
<li><strong>简化服务器设计</strong>: 服务器不需要管理复杂的会话状态。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-可缓存-Cacheable"><a href="#3-可缓存-Cacheable" class="headerlink" title="3. 可缓存 (Cacheable)"></a>3. 可缓存 (Cacheable)</h5><ul>
<li><strong>约束</strong>: 服务器的响应必须能够被标记为<strong>可缓存</strong>或<strong>不可缓存</strong>。</li>
<li><strong>解读</strong>:<ul>
<li>对于那些不经常变化的数据（如产品目录、配置信息），服务器应该在响应头中通过<code>Cache-Control</code>, <code>Expires</code>, <code>ETag</code>, <code>Last-Modified</code>等字段，明确告知客户端或中间代理（如CDN、反向代理）这个响应可以被缓存多久。</li>
</ul>
</li>
<li><strong>带来的好处</strong>:<ul>
<li><strong>提升性能</strong>: 客户端可以直接从本地缓存获取数据，减少网络延迟。</li>
<li><strong>降低服务器负载</strong>: 大量请求被缓存层拦截，减少了对后端服务器的直接访问。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-统一接口-Uniform-Interface"><a href="#4-统一接口-Uniform-Interface" class="headerlink" title="4. 统一接口 (Uniform Interface)"></a>4. 统一接口 (Uniform Interface)</h5><p>这是REST最核心的约束，它本身又包含四个子约束，旨在简化和解耦架构。</p>
<ul>
<li><p><strong>4.1 资源的标识 (Identification of Resources)</strong>:</p>
<ul>
<li>使用URI来唯一标识资源。URI的设计应稳定、语义清晰，并使用名词。</li>
</ul>
</li>
<li><p><strong>4.2 通过表现层来操作资源 (Manipulation of Resources Through Representations)</strong>:</p>
<ul>
<li>客户端通过获取和操作资源的表现层（如JSON）来与资源交互。一个资源的表现层应该包含足够的信息来修改或删除该资源。</li>
</ul>
</li>
<li><p><strong>4.3 自描述消息 (Self-descriptive Messages)</strong>:</p>
<ul>
<li>每个消息（请求&#x2F;响应）都应包含足够的信息来描述如何处理它。</li>
<li>例如，使用<code>Content-Type</code>头来指明消息体的媒体类型（如<code>application/json</code>），使用HTTP方法（<code>GET</code>, <code>POST</code>）来指明操作意图。</li>
</ul>
</li>
<li><p><strong>4.4 超媒体作为应用状态的引擎 (Hypermedia as the Engine of Application State - HATEOAS)</strong>:</p>
<ul>
<li><p>这是REST成熟度模型的最高级别。</p>
</li>
<li><p>客户端无需硬编码API的URI结构。相反，服务器的响应中应该提供相关操作的<strong>链接 (Links)</strong>，引导客户端进行下一步操作。</p>
</li>
<li><p><strong>示例</strong>: 获取一个订单信息的响应：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;orderId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xyz-123&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shipped&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">59.99</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_links&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;self&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/orders/xyz-123&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;customer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/customers/567&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tracking&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;href&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/tracking/xyz-123&quot;</span> <span class="punctuation">&#125;</span> <span class="comment">// 提供了查询物流的链接</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>好处</strong>: 极大地降低了客户端和服务器的耦合度。如果服务器的URL结构发生变化，只要<code>_links</code>中的链接是正确的，客户端就可以自适应，无需修改代码。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="5-分层系统-Layered-System"><a href="#5-分层系统-Layered-System" class="headerlink" title="5. 分层系统 (Layered System)"></a>5. 分层系统 (Layered System)</h5><ul>
<li><strong>约束</strong>: 客户端通常不知道它连接的是最终的服务器，还是中间的某个代理。</li>
<li><strong>解读</strong>: 可以在客户端和服务器之间插入多个中间层，如负载均衡器、API网关、安全代理、缓存服务器等。这些中间层可以提供安全、负载均衡、缓存等功能，而不会影响客户端和服务器之间的通信。</li>
<li><strong>好处</strong>: 增强了系统的可伸缩性和安全性。</li>
</ul>
<hr>
<h5 id="6-按需编码-Code-On-Demand-可选约束"><a href="#6-按需编码-Code-On-Demand-可选约束" class="headerlink" title="6. 按需编码 (Code-On-Demand) - 可选约束"></a>6. 按需编码 (Code-On-Demand) - 可选约束</h5><ul>
<li><strong>约束</strong>: 服务器可以通过向客户端发送可执行代码（如JavaScript）来临时扩展或自定义客户端的功能。</li>
<li><strong>解读</strong>: 这是RESTful约束中唯一一个<strong>可选</strong>的。现代Web应用的单页应用（SPA）就是这个约束的典型例子。</li>
</ul>
<hr>
<h4 id="1-6-2-生产环境中的最佳实践"><a href="#1-6-2-生产环境中的最佳实践" class="headerlink" title="1.6.2 生产环境中的最佳实践"></a>1.6.2 生产环境中的最佳实践</h4><h5 id="1-精心设计URI"><a href="#1-精心设计URI" class="headerlink" title="1. 精心设计URI"></a><strong>1. 精心设计URI</strong></h5><ul>
<li><strong>使用kebab-case（短横线分隔命名法）</strong>: <code>GET /product-catalogs/electronic-devices</code>，而不是<code>productCatalogs</code>。它更易读且符合URL的传统。</li>
<li><strong>避免在URI中暴露数据库主键</strong>: 使用业务上唯一的、不透明的标识符（如UUID）代替自增ID，如 <code>/users/f47ac10b-58cc-4372-a567-0e02b2c3d479</code>。</li>
</ul>
<hr>
<h5 id="2-提供结构化的错误响应"><a href="#2-提供结构化的错误响应" class="headerlink" title="2. 提供结构化的错误响应"></a><strong>2. 提供结构化的错误响应</strong></h5><p>当API出错时，不要只返回一个简单的字符串。提供一个结构化的JSON错误对象。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="string">&quot;User not found&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;USER_NOT_FOUND&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The user with ID &#x27;123&#x27; does not exist.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;documentationUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://api.example.com/docs/errors#USER_NOT_FOUND&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-强制使用HTTPS"><a href="#3-强制使用HTTPS" class="headerlink" title="3. 强制使用HTTPS"></a><strong>3. 强制使用HTTPS</strong></h5><p>所有API通信都应该使用HTTPS来加密，以防止中间人攻击和数据窃听。</p>
<hr>
<h5 id="4-明确API契约-API-Contract"><a href="#4-明确API契约-API-Contract" class="headerlink" title="4. 明确API契约 (API Contract)"></a><strong>4. 明确API契约 (API Contract)</strong></h5><p>使用 <strong>OpenAPI (Swagger)</strong> 或 <strong>API Blueprint</strong> 等工具来定义和文档化你的API。这会生成一份清晰的API契约，便于前端、后端和测试团队之间的协作，并可以自动生成客户端代码和API文档。</p>
<hr>
<h2 id="2-Spring-WebFlux-异步非阻塞模型"><a href="#2-Spring-WebFlux-异步非阻塞模型" class="headerlink" title="2. Spring WebFlux (异步非阻塞模型)"></a>2. Spring WebFlux (异步非阻塞模型)</h2><h3 id="2-1-什么是响应式编程？-Reactive-Streams规范"><a href="#2-1-什么是响应式编程？-Reactive-Streams规范" class="headerlink" title="2.1 什么是响应式编程？(Reactive Streams规范)"></a>2.1 什么是响应式编程？(Reactive Streams规范)</h3><h4 id="2-1-1-从一个“拉”与“推”的比喻开始"><a href="#2-1-1-从一个“拉”与“推”的比喻开始" class="headerlink" title="2.1.1 从一个“拉”与“推”的比喻开始"></a>2.1.1 从一个“拉”与“推”的比喻开始</h4><p>想象一下你去一家餐厅吃饭的两种不同模式：</p>
<ul>
<li><p><strong>模式一：传统同步阻塞 (拉模式 - Pull Model)</strong></p>
<ol>
<li>你（<strong>消费者线程</strong>）向服务员（<strong>数据源&#x2F;生产者</strong>）点了一份菜（<strong>请求数据</strong>）。</li>
<li>你<strong>坐在原地死等</strong>，什么也不干，直到服务员把菜端上来。这个等待的过程就是<strong>阻塞 (Blocking)</strong>。</li>
<li>如果服务员很忙，或者厨房出菜很慢，你就得一直等下去。你的时间（线程资源）被白白浪费了。</li>
<li>菜来了，你吃了，然后再点下一份，继续死等…</li>
</ol>
<ul>
<li><strong>特点</strong>:<ul>
<li><strong>主动拉取</strong>: 你主动向服务员要菜。</li>
<li><strong>同步</strong>: 你必须等一份菜来了才能点下一份。</li>
<li><strong>阻塞</strong>: 在等待时，你被“卡住”了，无法做其他事。</li>
<li><strong>资源浪费</strong>: 你的时间（线程）在等待中被占用。</li>
</ul>
</li>
<li><strong>这就是传统的同步阻塞编程模型，比如 <code>InputStream.read()</code> 或 <code>RestTemplate</code>。</strong></li>
</ul>
</li>
<li><p><strong>模式二：响应式异步非阻塞 (推模式 - Push Model)</strong></p>
<ol>
<li>你（<strong>消费者&#x2F;订阅者</strong>）告诉服务员（<strong>数据源&#x2F;发布者</strong>）：“这是我的菜单，请按照顺序，做好了就<strong>一道一道给我送过来</strong>。在我等菜的时候，<strong>我会去看书</strong>（做其他事）。”</li>
<li>你和服务员之间建立了一个**“订阅”**关系。</li>
<li>厨房（<strong>数据生产者</strong>）每做好一道菜，服务员就<strong>主动把菜推给你</strong>（<strong>数据推送</strong>）。</li>
<li>当菜送到你面前时，你会<strong>收到一个通知</strong>（<strong>事件回调</strong>），你放下书，吃了这道菜，然后继续看书。你<strong>没有被“卡住”</strong>。</li>
<li>你甚至可以告诉服务员：“我有点饱了，<strong>先别上那么快</strong>”（<strong>背压&#x2F;回压 - Backpressure</strong>）。</li>
</ol>
<ul>
<li><strong>特点</strong>:<ul>
<li><strong>被动接收</strong>: 你不主动要，而是等待服务员主动送。</li>
<li><strong>异步</strong>: 你点完菜就可以做别的事，菜来了再处理。</li>
<li><strong>非阻塞</strong>: 你的时间（线程）没有被等待卡住。</li>
<li><strong>事件驱动</strong>: “菜来了”就是一个事件，触发你“吃”这个动作。</li>
<li><strong>流量控制</strong>: 你可以控制上菜的速度。</li>
</ul>
</li>
<li><strong>这就是响应式编程的核心思想。</strong></li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-2-响应式编程的正式定义"><a href="#2-1-2-响应式编程的正式定义" class="headerlink" title="2.1.2 响应式编程的正式定义"></a>2.1.2 响应式编程的正式定义</h4><p><strong>响应式编程 (Reactive Programming)</strong> 是一种<strong>面向数据流 (Data Streams) 和变化传播 (Propagation of Change)</strong> 的<strong>异步编程范式</strong>。</p>
<p>让我们拆解这个定义：</p>
<ul>
<li><strong>异步编程范式</strong>: 意味着操作不会立即返回结果，而是在未来某个时间点通过回调、事件等方式通知你结果。</li>
<li><strong>面向数据流 (Data Streams)</strong>:<ul>
<li>在响应式编程中，<strong>任何东西都可以被看作是一个数据流</strong>。</li>
<li>一个数据流是一个<strong>按时间排序的事件序列</strong>。这些事件可以是：<ol>
<li><strong>值 (Value)</strong>: 数据项，比如一次数据库查询的结果行、一次HTTP请求的字节块、一次鼠标点击。</li>
<li><strong>错误 (Error)</strong>: 一个表示流中发生错误的信号。</li>
<li><strong>完成 (Completion)</strong>: 一个表示流已经结束的信号。</li>
</ol>
</li>
<li>这个流可以是<strong>有限的</strong>（比如读取文件内容），也可以是<strong>无限的</strong>（比如鼠标点击事件流）。</li>
</ul>
</li>
<li><strong>变化传播 (Propagation of Change)</strong>:<ul>
<li>这是响应式编程的“响应”二字的由来。</li>
<li>你不对数据流本身进行操作，而是定义一套**“处理规则”<strong>（一系列操作符，如<code>map</code>, <code>filter</code>等），然后将这些规则</strong>“附加”**到数据流上。</li>
<li>当数据流中出现新的数据时，这个变化会自动地、<strong>像涟漪一样</strong>穿过你定义的整个处理链，最终产生结果。你只需要**“响应”**这些变化即可。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<p>假设有一个代表用户输入的数据流 <code>inputStream</code>：</p>
<ul>
<li><p><strong>传统命令式编程</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我要主动地、一步一步地去操作</span></span><br><span class="line"><span class="keyword">for</span> (String line : lines) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!line.isEmpty()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">transformed</span> <span class="operator">=</span> line.toUpperCase();</span><br><span class="line">        System.out.println(transformed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>响应式声明式编程</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我只声明处理规则，数据来了会自动按规则流动</span></span><br><span class="line">inputStream</span><br><span class="line">    .filter(line -&gt; !line.isEmpty()) <span class="comment">// 规则1：过滤掉空行</span></span><br><span class="line">    .map(String::toUpperCase)        <span class="comment">// 规则2：转换为大写</span></span><br><span class="line">    .subscribe(System.out::println); <span class="comment">// 规则3：最终处理方式是打印出来</span></span><br></pre></td></tr></table></figure>

<p>在这个响应式例子中，我们定义了一个处理管道。只有当<code>subscribe</code>被调用时，数据才开始流动。每当<code>inputStream</code>产生一个新数据，它就会自动流经<code>filter</code>和<code>map</code>，最后到达<code>subscribe</code>。</p>
</li>
</ul>
<hr>
<h4 id="2-1-3-Reactive-Streams-规范"><a href="#2-1-3-Reactive-Streams-规范" class="headerlink" title="2.1.3 Reactive Streams 规范"></a>2.1.3 Reactive Streams 规范</h4><p>由于不同的公司和开源社区（如Netflix, Pivotal, Lightbend）都开发了自己的响应式库（RxJava, Project Reactor, Akka Streams），为了确保这些库之间可以<strong>互操作</strong>，他们共同制定了一套标准——<strong>Reactive Streams 规范</strong>。</p>
<p><strong>这套规范非常小，只定义了四个核心接口</strong>:</p>
<ol>
<li><strong><code>Publisher&lt;T&gt;</code> (发布者)</strong><ul>
<li>角色: <strong>数据生产者</strong>。</li>
<li>它只有一个方法: <code>subscribe(Subscriber&lt;? super T&gt; s)</code>。</li>
<li>作用: 允许一个 <code>Subscriber</code> 来“订阅”它。</li>
</ul>
</li>
<li><strong><code>Subscriber&lt;T&gt;</code> (订阅者)</strong><ul>
<li>角色: <strong>数据消费者</strong>。</li>
<li>它有四个方法，定义了它如何**“响应”**来自 <code>Publisher</code> 的事件：<ul>
<li><code>onSubscribe(Subscription s)</code>: 订阅成功时被调用，<code>Publisher</code> 会传递一个 <code>Subscription</code> 对象。</li>
<li><code>onNext(T t)</code>: 接收到一个新的数据项时被调用。</li>
<li><code>onError(Throwable t)</code>: 发生错误时被调用。</li>
<li><code>onComplete()</code>: 数据流正常结束时被调用。</li>
</ul>
</li>
<li><code>onNext</code>, <code>onError</code>, <code>onComplete</code> 都是<strong>终止信号</strong>，一个流最多只会触发其中一个。</li>
</ul>
</li>
<li><strong><code>Subscription</code> (订阅关系)</strong><ul>
<li>角色: <strong>连接 <code>Publisher</code> 和 <code>Subscriber</code> 的桥梁</strong>。</li>
<li>它代表了一个<strong>唯一的</strong>订阅关系。</li>
<li>它有两个方法:<ul>
<li><code>request(long n)</code>: <strong>这是实现背压 (Backpressure) 的核心</strong>。<code>Subscriber</code> 通过调用这个方法来告诉 <code>Publisher</code>：“我准备好了，请再给我 <code>n</code> 个数据”。</li>
<li><code>cancel()</code>: <code>Subscriber</code> 用来取消订阅。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>Processor&lt;T, R&gt;</code> (处理器)</strong><ul>
<li>角色: <strong>处理阶段</strong>，它既是 <code>Subscriber</code> 又是 <code>Publisher</code>。</li>
<li>它订阅上游的 <code>Publisher</code>，对数据进行处理，然后再将处理后的结果发布给下游的 <code>Subscriber</code>。<code>map</code>, <code>filter</code> 等操作符在内部就是通过 <code>Processor</code> 实现的。</li>
</ul>
</li>
</ol>
<p><strong>规范的核心原则</strong>:</p>
<ul>
<li><strong>异步非阻塞</strong>: 所有操作都是异步的。</li>
<li><strong>背压 (Backpressure)</strong>: <strong>数据流的速度由 <code>Subscriber</code> (消费者) 来控制，而不是 <code>Publisher</code> (生产者)</strong>。<code>Publisher</code> 只有在 <code>Subscriber</code> 通过 <code>subscription.request(n)</code> 请求数据时，才能推送最多 <code>n</code> 个数据。这可以有效防止因消费者处理速度慢于生产者而导致的内存溢出（<code>OutOfMemoryError</code>）。</li>
</ul>
<hr>
<h3 id="2-2-核心API-Project-Reactor"><a href="#2-2-核心API-Project-Reactor" class="headerlink" title="2.2 核心API(Project Reactor)"></a>2.2 核心API(Project Reactor)</h3><p>Project Reactor 是 Pivotal（Spring 的母公司）开发的一个实现了 Reactive Streams 规范的、功能强大的响应式编程库。它提供了两种核心的、专门用于处理异步数据流的 <code>Publisher</code> 实现：<strong><code>Mono</code></strong> 和 <strong><code>Flux</code></strong>。</p>
<p>你可以把 <code>Mono</code> 和 <code>Flux</code> 理解为 Java 8 <code>Stream</code> API 的<strong>异步、响应式</strong>版本。它们都提供了一套极其丰富的<strong>操作符 (Operators)</strong>，用于以<strong>声明式</strong>的方式来处理数据流。</p>
<hr>
<h4 id="2-2-1-Flux-处理-0-到-N-个元素"><a href="#2-2-1-Flux-处理-0-到-N-个元素" class="headerlink" title="2.2.1 Flux&lt;T&gt; - 处理 0 到 N 个元素"></a>2.2.1 <code>Flux&lt;T&gt;</code> - 处理 0 到 N 个元素</h4><ul>
<li><p><strong>定义</strong>: <code>Flux</code> 是一个可以发出 <strong>0 到 N 个</strong>元素的异步序列（数据流）的 <code>Publisher</code>。</p>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li>处理一个<strong>集合</strong>或<strong>数组</strong>中的所有元素。</li>
<li>从数据库查询返回的<strong>多行结果</strong>。</li>
<li>一个持续不断的<strong>事件流</strong>（如消息队列的消息、服务器推送事件SSE）。</li>
<li>HTTP响应中分块（chunked）传输的数据体。</li>
</ul>
</li>
<li><p><strong>生命周期事件</strong>: 一个 <code>Flux</code> 流会按顺序发出：</p>
<ol>
<li><code>onSubscribe</code> (一次)</li>
<li><code>onNext</code> (<strong>0次或多次</strong>)</li>
<li><code>onComplete</code> (最多一次) <strong>或</strong> <code>onError</code> (最多一次)</li>
</ol>
</li>
<li><p><strong>创建 <code>Flux</code> (静态工厂方法)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 从固定元素创建</span></span><br><span class="line">Flux&lt;String&gt; flux1 = Flux.just(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 从集合或数组创建</span></span><br><span class="line">List&lt;String&gt; fruits = Arrays.asList(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line">Flux&lt;String&gt; flux2 = Flux.fromIterable(fruits);</span><br><span class="line">Flux&lt;String&gt; flux3 = Flux.fromArray(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 从一个范围创建</span></span><br><span class="line">Flux&lt;Integer&gt; flux4 = Flux.range(<span class="number">1</span>, <span class="number">5</span>); <span class="comment">// 发出 1, 2, 3, 4, 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建一个空的Flux</span></span><br><span class="line">Flux&lt;Object&gt; emptyFlux = Flux.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 创建一个只发出错误的Flux</span></span><br><span class="line">Flux&lt;Object&gt; errorFlux = Flux.error(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Something went wrong&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 创建一个定时发出的Flux (每100ms发出一个从0开始递增的long值)</span></span><br><span class="line">Flux&lt;Long&gt; intervalFlux = Flux.interval(Duration.ofMillis(<span class="number">100</span>)); </span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-2-Mono-处理-0-或-1-个元素"><a href="#2-2-2-Mono-处理-0-或-1-个元素" class="headerlink" title="2.2.2 Mono&lt;T&gt; - 处理 0 或 1 个元素"></a>2.2.2 <code>Mono&lt;T&gt;</code> - 处理 0 或 1 个元素</h4><ul>
<li><p><strong>定义</strong>: <code>Mono</code> 是一个最多只能发出 <strong>0 个或 1 个</strong>元素的异步序列的 <code>Publisher</code>。</p>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li>当你确定一个异步操作<strong>最多只会返回一个结果</strong>时。</li>
<li>一个只返回单个实体的API调用（如 <code>findById</code>）。</li>
<li>一个异步计算的最终结果（如 <code>CompletableFuture</code>）。</li>
<li>一个表示**“完成”但没有具体值**的操作（<code>Mono&lt;Void&gt;</code>），例如保存或删除操作。</li>
</ul>
</li>
<li><p><strong>生命周期事件</strong>: 一个 <code>Mono</code> 流会按顺序发出：</p>
<ol>
<li><code>onSubscribe</code> (一次)</li>
<li><code>onNext</code> (<strong>0次或1次</strong>)</li>
<li><code>onComplete</code> (最多一次) <strong>或</strong> <code>onError</code> (最多一次)</li>
</ol>
</li>
<li><p><strong>创建 <code>Mono</code> (静态工厂方法)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 从一个可能为null的元素创建</span></span><br><span class="line">Mono&lt;String&gt; mono1 = Mono.just(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">Mono&lt;String&gt; emptyMonoFromNull = Mono.justOrEmpty(<span class="literal">null</span>); <span class="comment">// 返回一个空的Mono</span></span><br><span class="line">Mono&lt;String&gt; monoFromOptional = Mono.justOrEmpty(Optional.of(<span class="string">&quot;Apple&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个空的Mono (只发出 onComplete 信号)</span></span><br><span class="line">Mono&lt;Void&gt; emptyMono = Mono.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建一个只发出错误的Mono</span></span><br><span class="line">Mono&lt;Object&gt; errorMono = Mono.error(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Something went wrong&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 从 Supplier 创建 (延迟执行)</span></span><br><span class="line">Mono&lt;String&gt; supplierMono = Mono.fromSupplier(() -&gt; <span class="string">&quot;Hello from Supplier&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 从 Callable 或 CompletableFuture 创建</span></span><br><span class="line">Mono&lt;String&gt; futureMono = Mono.fromFuture(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello from Future&quot;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-3-核心概念：订阅-Subscription-与惰性求值"><a href="#2-2-3-核心概念：订阅-Subscription-与惰性求值" class="headerlink" title="2.2.3 核心概念：订阅 (Subscription) 与惰性求值"></a>2.2.3 核心概念：订阅 (Subscription) 与惰性求值</h4><p><strong>“冷”发布者 (Cold Publisher)</strong>:</p>
<ul>
<li><code>Flux</code> 和 <code>Mono</code> 默认都是**“冷”的**。这意味着，在你<strong>没有调用 <code>subscribe()</code></strong> 方法之前，<strong>什么都不会发生</strong>。</li>
<li>你通过各种操作符（<code>map</code>, <code>filter</code>等）构建起来的，只是一个<strong>执行计划</strong>或**“数据处理流水线”**的蓝图。</li>
<li>只有当最终的 <code>subscribe()</code> 被调用时，数据才真正开始从源头（<code>Publisher</code>）流动，并穿过整个处理链。</li>
<li>每次有新的订阅者 <code>subscribe()</code>，都会从头开始一个新的数据流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; pipeline = Flux.just(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">        .map(String::toUpperCase)</span><br><span class="line">        .log(); <span class="comment">// log()是一个有副作用的操作符，用于观察事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pipeline.subscribe(); // 如果没有这一行，控制台什么都不会打印！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当调用subscribe时，数据才开始流动</span></span><br><span class="line">pipeline.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// [ INFO] (main) | onSubscribe([Synchronous Fuseable] FluxArray.ArraySubscription)</span></span><br><span class="line"><span class="comment">// [ INFO] (main) | request(unbounded)</span></span><br><span class="line"><span class="comment">// [ INFO] (main) | onNext(A)</span></span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// [ INFO] (main) | onNext(B)</span></span><br><span class="line"><span class="comment">// B</span></span><br><span class="line"><span class="comment">// [ INFO] (main) | onNext(C)</span></span><br><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="comment">// [ INFO] (main) | onComplete()</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-4-常用操作符-Operators"><a href="#2-2-4-常用操作符-Operators" class="headerlink" title="2.2.4 常用操作符 (Operators)"></a>2.2.4 常用操作符 (Operators)</h4><p>Reactor 提供了极其丰富的操作符，用于以声明式的方式组合和处理数据流。下面是一些最常用的操作符类别：</p>
<h5 id="1-转换-Transforming"><a href="#1-转换-Transforming" class="headerlink" title="1. 转换 (Transforming)"></a>1. 转换 (Transforming)</h5><ul>
<li><p><strong><code>map(Function&lt;T, R&gt;)</code></strong>: <strong>1对1同步转换</strong>。将流中的每个元素 T 转换为另一个元素 R。类似于 <code>Stream.map</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).map(i -&gt; i * <span class="number">10</span>).subscribe(System.out::println); <span class="comment">// 输出 10, 20, 30</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>flatMap(Function&lt;T, Publisher&lt;R&gt;&gt;)</code></strong>: <strong>1对多异步转换</strong>。将每个元素 T 转换为一个新的流 <code>Publisher&lt;R&gt;</code>，然后将所有这些新流<strong>合并 (flatten)</strong> 成一个单一的流。这是<strong>处理异步调用的核心</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 findOrdersByUser(user) 是一个返回 Flux&lt;Order&gt; 的异步方法</span></span><br><span class="line">Flux&lt;User&gt; users = Flux.just(user1, user2);</span><br><span class="line">Flux&lt;Order&gt; allOrders = users.flatMap(user -&gt; findOrdersByUser(user));</span><br></pre></td></tr></table></figure>

<p><code>flatMap</code> 不保证顺序，它会交错地发出元素。如果需要保持顺序，使用 <code>concatMap</code>。</p>
</li>
</ul>
<hr>
<h5 id="2-过滤-Filtering"><a href="#2-过滤-Filtering" class="headerlink" title="2. 过滤 (Filtering)"></a>2. 过滤 (Filtering)</h5><ul>
<li><p><strong><code>filter(Predicate&lt;T&gt;)</code></strong>: 根据条件过滤流中的元素。类似于 <code>Stream.filter</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).subscribe(System.out::println); <span class="comment">// 输出 2, 4, 6, 8, 10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>take(long n)</code></strong>: 只取流中的前 n 个元素。</p>
</li>
<li><p><strong><code>distinct()</code></strong>: 去除重复的元素。</p>
</li>
</ul>
<hr>
<h5 id="3-组合-Combining"><a href="#3-组合-Combining" class="headerlink" title="3. 组合 (Combining)"></a>3. 组合 (Combining)</h5><ul>
<li><p><strong><code>mergeWith(Publisher&lt;T&gt;)</code></strong>: 将两个流合并成一个，元素按它们到达的时间交错发出。</p>
</li>
<li><p><strong><code>zipWith(Publisher&lt;U&gt;, BiFunction&lt;T, U, V&gt;)</code></strong>: 将两个流的元素<strong>按顺序两两配对</strong>，并应用一个函数来组合它们。输出流的长度取决于最短的输入流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; names = Flux.just(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">Flux&lt;Integer&gt; ages = Flux.just(<span class="number">30</span>, <span class="number">25</span>);</span><br><span class="line">Flux&lt;String&gt; zipped = names.zipWith(ages, (name, age) -&gt; name + <span class="string">&quot; is &quot;</span> + age + <span class="string">&quot; years old.&quot;</span>);</span><br><span class="line"><span class="comment">// 输出: &quot;Alice is 30 years old.&quot;, &quot;Bob is 25 years old.&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="4-错误处理-Error-Handling"><a href="#4-错误处理-Error-Handling" class="headerlink" title="4. 错误处理 (Error Handling)"></a>4. 错误处理 (Error Handling)</h5><ul>
<li><strong><code>onErrorReturn(T fallbackValue)</code></strong>: 当发生错误时，返回一个默认值并正常完成流。</li>
<li><strong><code>onErrorResume(Function&lt;Throwable, Publisher&lt;T&gt;&gt;)</code></strong>: 当发生错误时，订阅一个新的备用流 <code>Publisher&lt;T&gt;</code>。</li>
<li><strong><code>retry(long n)</code></strong>: 当发生错误时，重新订阅上游流，最多重试 n 次。</li>
</ul>
<hr>
<h5 id="5-阻塞操作-Blocking-谨慎使用！"><a href="#5-阻塞操作-Blocking-谨慎使用！" class="headerlink" title="5. 阻塞操作 (Blocking) - 谨慎使用！"></a>5. 阻塞操作 (Blocking) - 谨慎使用！</h5><p>在响应式编程中应<strong>尽量避免阻塞</strong>。但有时在测试或与遗留代码集成时，可能需要阻塞等待结果。</p>
<ul>
<li><strong><code>block()</code></strong>: <strong>阻塞</strong>当前线程，直到 <code>Mono</code> 发出元素（或完成&#x2F;出错），并返回该元素。</li>
<li><strong><code>blockFirst()</code> &#x2F; <code>blockLast()</code></strong>: 阻塞直到 <code>Flux</code> 发出第一个&#x2F;最后一个元素。</li>
</ul>
<p><strong>警告</strong>: <strong>绝对不要在由Netty等管理的非阻塞线程（如WebFlux的请求处理线程）中调用阻塞操作！</strong> 这会严重破坏响应式模型的性能优势，甚至导致线程饥饿和应用假死。</p>
<hr>
<h3 id="2-3-两种编程模型"><a href="#2-3-两种编程模型" class="headerlink" title="2.3 两种编程模型"></a>2.3 两种编程模型</h3><h4 id="2-3-1-注解驱动模式"><a href="#2-3-1-注解驱动模式" class="headerlink" title="2.3.1 注解驱动模式"></a>2.3.1 注解驱动模式</h4><h5 id="1-核心思想：熟悉的配方，响应式的味道"><a href="#1-核心思想：熟悉的配方，响应式的味道" class="headerlink" title="1. 核心思想：熟悉的配方，响应式的味道"></a>1. 核心思想：熟悉的配方，响应式的味道</h5><p>Spring WebFlux 的注解驱动模式在设计上<strong>刻意与 Spring MVC 保持了高度的一致性</strong>。其核心思想是让已经熟悉 Spring MVC 的开发者能够以最小的学习成本，快速上手响应式Web开发。</p>
<p>这意味着，你用来构建 Spring MVC 控制器的绝大部分注解，在 WebFlux 中<strong>完全适用</strong>。</p>
<p><strong>可以重用的核心注解包括</strong>:</p>
<ul>
<li><strong>类级别</strong>: <code>@RestController</code>, <code>@Controller</code></li>
<li><strong>请求映射</strong>: <code>@RequestMapping</code>, <code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code>, <code>@PatchMapping</code></li>
<li><strong>参数绑定</strong>: <code>@PathVariable</code>, <code>@RequestParam</code>, <code>@RequestHeader</code>, <code>@RequestBody</code>, <code>@CookieValue</code></li>
</ul>
<p>你可以像写MVC Controller一样组织你的代码结构。</p>
<hr>
<h5 id="2-根本性的区别：返回类型"><a href="#2-根本性的区别：返回类型" class="headerlink" title="2. 根本性的区别：返回类型"></a>2. 根本性的区别：返回类型</h5><p>尽管注解相同，但两者在<strong>编程模型</strong>上有着根本性的区别，这主要体现在<strong>Controller方法的返回类型</strong>上。</p>
<ul>
<li><strong>Spring MVC (同步阻塞)</strong>:<ul>
<li>方法返回的是<strong>具体的数据</strong>，如 <code>User</code>, <code>List&lt;User&gt;</code>, <code>ResponseEntity&lt;User&gt;</code>。</li>
<li>当方法被调用时，它会<strong>阻塞</strong>当前线程，直到数据准备就绪（例如，数据库查询完成），然后将完整的数据返回。</li>
</ul>
</li>
<li><strong>Spring WebFlux (异步非阻塞)</strong>:<ul>
<li>方法返回的是一个<strong>发布者 (Publisher)</strong>，即 <strong><code>Mono&lt;T&gt;</code></strong> 或 <strong><code>Flux&lt;T&gt;</code></strong>。</li>
<li>你返回的不是数据本身，而是一个**“数据的承诺”<strong>或</strong>“未来数据的持有者”**。</li>
<li>方法在定义完这个“数据承诺”（即构建好响应式管道）后会<strong>立即返回</strong>，<strong>不会阻塞</strong>请求处理线程。</li>
<li>Spring WebFlux 框架会**“订阅 (subscribe)”** 你返回的 <code>Mono</code> 或 <code>Flux</code>。当数据源（如数据库、外部API）在未来某个时间点准备好数据后，数据会被<strong>推送 (push)</strong> 到这个管道中，最终由框架写入HTTP响应。</li>
</ul>
</li>
</ul>
<p><strong>返回类型总结</strong>:</p>
<ul>
<li>返回 <strong><code>Mono&lt;T&gt;</code></strong>: 当你预期API会返回 <strong>0个或1个</strong> 结果时。例如，<code>findById</code>, <code>createUser</code>。</li>
<li>返回 <strong><code>Flux&lt;T&gt;</code></strong>: 当你预期API会返回 <strong>0个或多个</strong> 结果时。例如，<code>findAll</code>, <code>searchByName</code>。</li>
<li>返回 <strong><code>Mono&lt;Void&gt;</code></strong>: 当操作成功但<strong>无需返回任何内容</strong>时。例如，<code>deleteById</code>。</li>
<li>返回 <strong><code>Mono&lt;ResponseEntity&lt;T&gt;&gt;</code></strong>: 当你需要精细化控制响应状态码或响应头时，可以将 <code>ResponseEntity</code> 包装在 <code>Mono</code> 中。</li>
</ul>
<hr>
<h5 id="3-示例：一个响应式的-UserController"><a href="#3-示例：一个响应式的-UserController" class="headerlink" title="3. 示例：一个响应式的 UserController"></a>3. 示例：一个响应式的 <code>UserController</code></h5><p>让我们通过一个具体的例子来对比和理解。</p>
<p><strong><code>User.java</code> (POJO)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的User领域对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// constructor, getters, setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>UserController.java</code> (WebFlux Controller)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/reactive/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一个DAO/Repository</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, User&gt; userDb = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">()</span> &#123;</span><br><span class="line">        userDb.put(<span class="number">1L</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">        userDb.put(<span class="number">2L</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2L</span>, <span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有用户 (返回多个元素 -&gt; Flux)</span></span><br><span class="line"><span class="comment">     * 使用 text/event-stream，可以观察到数据是逐条流式返回的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;User&gt; <span class="title function_">getAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Flux.fromIterable 将集合转换为Flux</span></span><br><span class="line">        <span class="comment">// delayElements 模拟每个元素之间有1秒的延迟，以体现&quot;流&quot;的特性</span></span><br><span class="line">        <span class="keyword">return</span> Flux.fromIterable(userDb.values())</span><br><span class="line">                   .delayElements(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID获取单个用户 (返回0或1个元素 -&gt; Mono)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ResponseEntity&lt;User&gt;&gt; <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDb.get(id);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Mono.just 将一个对象包装成Mono</span></span><br><span class="line">            <span class="comment">// 返回 Mono&lt;ResponseEntity&gt; 来控制状态码</span></span><br><span class="line">            <span class="keyword">return</span> Mono.just(ResponseEntity.ok(user));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Mono.just 包装一个404的ResponseEntity</span></span><br><span class="line">            <span class="keyword">return</span> Mono.just(ResponseEntity.notFound().build());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个新用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userMono 请求体也是一个Publisher (Mono&lt;User&gt;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回创建后的用户 (Mono&lt;User&gt;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.CREATED)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> Mono&lt;User&gt; userMono)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用flatMap来处理异步数据</span></span><br><span class="line">        <span class="keyword">return</span> userMono.flatMap(user -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟生成ID并保存</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">newId</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            user.setId(newId);</span><br><span class="line">            userDb.put(newId, user);</span><br><span class="line">            <span class="comment">// 返回包含新用户的Mono</span></span><br><span class="line">            <span class="keyword">return</span> Mono.just(user);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-底层执行模型"><a href="#4-底层执行模型" class="headerlink" title="4. 底层执行模型"></a>4. 底层执行模型</h5><p>这个模式的背后是完全不同的线程模型。</p>
<ul>
<li><strong>Spring MVC</strong>: 默认情况下，基于Servlet API，通常采用**“一个线程处理一个请求”**的模型。如果请求中的I&#x2F;O操作（如数据库查询）阻塞了，那么这个线程也会被阻塞，直到I&#x2F;O完成。在高并发下，这会导致大量线程被创建和占用，成为系统瓶颈。</li>
<li><strong>Spring WebFlux</strong>: 通常运行在<strong>非阻塞I&#x2F;O服务器</strong>（如Netty）之上。它使用<strong>少量固定的线程（Event Loop）</strong> 来处理大量的并发请求。<ol>
<li>一个请求到达，Event Loop线程接收它。</li>
<li>该线程调用你的Controller方法。</li>
<li>Controller方法<strong>快速返回</strong>一个<code>Mono</code>或<code>Flux</code>（定义了处理流程），<strong>线程立即被释放</strong>，去处理下一个请求。</li>
<li>当响应式管道中的I&#x2F;O操作（如响应式数据库驱动）完成时，会通过<strong>回调</strong>通知Netty。</li>
<li>Event Loop线程再次被唤醒，将结果数据写入响应。</li>
</ol>
</li>
</ul>
<p><strong>核心优势</strong>：线程永远不会因为等待I&#x2F;O而阻塞，从而可以用更少的线程资源支撑更高的并发量。</p>
<hr>
<h4 id="2-3-2-函数式路由模式"><a href="#2-3-2-函数式路由模式" class="headerlink" title="2.3.2 函数式路由模式"></a>2.3.2 函数式路由模式</h4><h5 id="1-核心思想：路由即函数，处理即函数"><a href="#1-核心思想：路由即函数，处理即函数" class="headerlink" title="1. 核心思想：路由即函数，处理即函数"></a>1. 核心思想：路由即函数，处理即函数</h5><p>函数式路由模式完全摒弃了注解，将Web层的两个核心职责——**路由（Routing）**和**处理（Handling）**——显式地定义为两个独立的函数接口：</p>
<ol>
<li><strong><code>RouterFunction&lt;T extends ServerResponse&gt;</code> (路由函数)</strong>:<ul>
<li><strong>职责</strong>: 负责<strong>定义路由规则</strong>。它的作用等同于 <code>@RequestMapping</code> 注解。</li>
<li><strong>本质</strong>: 它是一个接收 <code>ServerRequest</code> 对象作为输入，返回一个 <code>Mono&lt;HandlerFunction&gt;</code> 作为输出的函数。</li>
<li><strong>工作流程</strong>: 当一个请求进来时，<code>RouterFunction</code> 会被调用。它会检查这个请求是否与自己定义的规则（如路径、HTTP方法、请求头等）匹配。<ul>
<li>如果<strong>匹配</strong>，它就返回一个包裹在 <code>Mono</code> 中的 <code>HandlerFunction</code>，告诉框架“这个请求应该由这个Handler来处理”。</li>
<li>如果<strong>不匹配</strong>，它就返回一个空的 <code>Mono</code> (<code>Mono.empty()</code>)，框架会继续尝试下一个路由规则。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>HandlerFunction&lt;T extends ServerResponse&gt;</code> (处理函数)</strong>:<ul>
<li><strong>职责</strong>: 负责<strong>处理具体的业务逻辑</strong>。它的作用等同于 <code>@Controller</code> 中的方法体。</li>
<li><strong>本质</strong>: 它是一个接收 <code>ServerRequest</code> 对象作为输入，返回一个 <code>Mono&lt;ServerResponse&gt;</code> 作为输出的函数。</li>
<li><strong>工作流程</strong>: 当路由匹配成功后，这个函数被调用。它从 <code>ServerRequest</code> 中提取数据（路径变量、参数、请求体），执行业务逻辑，并构建一个 <code>ServerResponse</code>（包含了状态码、响应头、响应体）包装在 <code>Mono</code> 中返回。</li>
</ul>
</li>
</ol>
<p><strong>对比注解模式</strong>:</p>
<table>
<thead>
<tr>
<th align="left">职责</th>
<th align="left">注解驱动模式</th>
<th align="left">函数式路由模式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>路由</strong></td>
<td align="left"><code>@RequestMapping</code> 及其变体</td>
<td align="left"><code>RouterFunction</code></td>
</tr>
<tr>
<td align="left"><strong>处理</strong></td>
<td align="left"><code>@Controller</code> 中的方法</td>
<td align="left"><code>HandlerFunction</code></td>
</tr>
<tr>
<td align="left"><strong>耦合方式</strong></td>
<td align="left">注解将路由和处理耦合在方法上</td>
<td align="left">路由和处理是两个独立的函数，通过配置将它们组合在一起</td>
</tr>
</tbody></table>
<hr>
<h5 id="2-核心组件与API"><a href="#2-核心组件与API" class="headerlink" title="2. 核心组件与API"></a>2. 核心组件与API</h5><p>为了方便地构建这两个函数，Spring WebFlux 提供了一些实用的工具类：</p>
<ul>
<li><strong><code>RouterFunctions</code></strong>:<ul>
<li>一个<strong>工具类</strong>，提供了大量的静态方法来创建 <code>RouterFunction</code>。</li>
<li><code>route()</code>: 创建路由的入口。</li>
<li><code>nest()</code>: 用于创建嵌套路由，相当于类级别的 <code>@RequestMapping</code>。</li>
<li><code>and()</code> &#x2F; <code>andRoute()</code>: 用于将多个路由规则组合在一起。</li>
</ul>
</li>
<li><strong><code>RequestPredicates</code></strong>:<ul>
<li>一个<strong>工具类</strong>，提供了各种用于匹配请求的<strong>谓词 (Predicate)</strong>。</li>
<li><code>GET(pattern)</code>: 匹配GET方法和指定路径。</li>
<li><code>POST(pattern)</code>, <code>PUT(pattern)</code>, <code>DELETE(pattern)</code> 等。</li>
<li><code>accept(MediaType)</code>: 匹配 <code>Accept</code> 请求头。</li>
<li><code>contentType(MediaType)</code>: 匹配 <code>Content-Type</code> 请求头。</li>
<li><code>path(pattern)</code>: 只匹配路径。</li>
</ul>
</li>
<li><strong><code>ServerRequest</code></strong>:<ul>
<li>对 <code>HttpServletRequest</code> 的响应式、不可变封装。</li>
<li>提供了获取路径变量、查询参数、请求头、请求体 (<code>bodyToMono</code>, <code>bodyToFlux</code>) 的响应式方法。</li>
</ul>
</li>
<li><strong><code>ServerResponse</code></strong>:<ul>
<li>对 <code>HttpServletResponse</code> 的响应式、不可变封装。</li>
<li>提供了一个<strong>流式的构建器 (Builder)</strong> 来创建响应，可以方便地设置状态码、响应头、响应体等。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-示例：使用函数式模式重写-UserController"><a href="#3-示例：使用函数式模式重写-UserController" class="headerlink" title="3. 示例：使用函数式模式重写 UserController"></a>3. 示例：使用函数式模式重写 <code>UserController</code></h5><p>我们将之前注解模式的 <code>UserController</code> 用函数式的方式重写，通常会把路由定义和处理逻辑分开。</p>
<p><strong>Step 1: 创建 <code>UserHandler</code> (处理逻辑)</strong></p>
<p>这个类不依赖任何Spring MVC的注解，是一个纯粹的业务处理类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerResponse;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 仍然是一个Spring Bean，以便注入其他服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设有一个响应式的 UserService</span></span><br><span class="line">    <span class="comment">// @Autowired</span></span><br><span class="line">    <span class="comment">// private UserService userService;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟的DAO/Repository</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, User&gt; userDb = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        userDb.put(<span class="number">1L</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1L</span>, <span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">        userDb.put(<span class="number">2L</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2L</span>, <span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理获取所有用户的请求 (HandlerFunction)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title function_">getAllUsers</span><span class="params">(ServerRequest request)</span> &#123;</span><br><span class="line">        Flux&lt;User&gt; users = Flux.fromIterable(userDb.values());</span><br><span class="line">        <span class="keyword">return</span> ServerResponse.ok()</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                .body(users, User.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理根据ID获取用户的请求 (HandlerFunction)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title function_">getUserById</span><span class="params">(ServerRequest request)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> Long.valueOf(request.pathVariable(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDb.get(id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ServerResponse.ok()</span><br><span class="line">                    .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                    .body(Mono.just(user), User.class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ServerResponse.notFound().build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理创建用户的请求 (HandlerFunction)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title function_">createUser</span><span class="params">(ServerRequest request)</span> &#123;</span><br><span class="line">        Mono&lt;User&gt; userMono = request.bodyToMono(User.class);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> userMono.flatMap(user -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟保存</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">newId</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            user.setId(newId);</span><br><span class="line">            userDb.put(newId, user);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> ServerResponse.status(HttpStatus.CREATED)</span><br><span class="line">                    .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                    .body(Mono.just(user), User.class);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Step 2: 创建 <code>UserRouter</code> (路由定义)</strong></p>
<p>这个类使用 <code>@Configuration</code> 和 <code>@Bean</code> 来定义路由规则，并将它们与 <code>UserHandler</code> 中的方法关联起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunction;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.RouterFunctions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.server.ServerResponse;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.RequestPredicates.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.RouterFunctions.route;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title function_">userRoutes</span><span class="params">(UserHandler userHandler)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> route(GET(<span class="string">&quot;/functional/users&quot;</span>), userHandler::getAllUsers)</span><br><span class="line">                .andRoute(GET(<span class="string">&quot;/functional/users/&#123;id&#125;&quot;</span>), userHandler::getUserById)</span><br><span class="line">                .andRoute(POST(<span class="string">&quot;/functional/users&quot;</span>), userHandler::createUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以使用嵌套路由，更清晰</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title function_">nestedUserRoutes</span><span class="params">(UserHandler userHandler)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RouterFunctions.nest(path(<span class="string">&quot;/functional/v2/users&quot;</span>),</span><br><span class="line">                route(GET(<span class="string">&quot;&quot;</span>), userHandler::getAllUsers)</span><br><span class="line">                .andRoute(GET(<span class="string">&quot;/&#123;id&#125;&quot;</span>), userHandler::getUserById)</span><br><span class="line">                .andRoute(POST(<span class="string">&quot;&quot;</span>), userHandler::createUser)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码解析</strong>:</p>
<ul>
<li>我们定义了一个类型为 <code>RouterFunction&lt;ServerResponse&gt;</code> 的Bean。Spring WebFlux会自动检测到这个Bean并用它来处理请求。</li>
<li><code>route(RequestPredicate, HandlerFunction)</code> 是核心方法，它将一个请求谓词和一个处理函数绑定在一起。</li>
<li><code>userHandler::getAllUsers</code> 是Java 8的方法引用，它指向了 <code>UserHandler</code> 中的 <code>getAllUsers</code> 方法，非常简洁。</li>
<li><code>nest()</code> 方法可以将一组路由规则嵌套在一个公共的路径前缀下，使得代码结构更清晰。</li>
</ul>
<hr>
<h5 id="4-优势与适用场景"><a href="#4-优势与适用场景" class="headerlink" title="4. 优势与适用场景"></a><strong>4. 优势与适用场景</strong></h5><p><strong>优势</strong>:</p>
<ol>
<li><strong>更高的灵活性和控制力</strong>: 路由规则是普通的Java代码，你可以使用任何编程逻辑（<code>if-else</code>, 循环, Stream API）来动态地构建路由，这是注解无法做到的。</li>
<li><strong>更好的性能（理论上）</strong>: 由于绕过了注解的反射扫描和解析过程，函数式路由在启动时和运行时的开销理论上更小。对于需要处理极高吞吐量的微服务网关等场景，这可能是一个优势。</li>
<li><strong>函数式编程风格</strong>: 代码更加声明式和不可变，易于测试和推理。<code>HandlerFunction</code> 只是一个接收 <code>ServerRequest</code> 返回 <code>Mono&lt;ServerResponse&gt;</code> 的函数，单元测试非常简单。</li>
<li><strong>关注点分离</strong>: 路由逻辑和业务处理逻辑被清晰地分离在不同的类中，职责更单一。</li>
</ol>
<p><strong>适用场景</strong>:</p>
<ul>
<li>需要构建高度动态或复杂的路由规则。</li>
<li>对性能有极致要求的场景。</li>
<li>偏爱函数式编程风格，追求更强类型安全和代码控制力的团队。</li>
<li>构建轻量级的、专注于代理或路由的微服务。</li>
</ul>
<hr>
<h3 id="2-4-WebClient-响应式HTTP客户端"><a href="#2-4-WebClient-响应式HTTP客户端" class="headerlink" title="2.4 WebClient (响应式HTTP客户端)"></a>2.4 WebClient (响应式HTTP客户端)</h3><h4 id="2-4-1-什么是-WebClient？"><a href="#2-4-1-什么是-WebClient？" class="headerlink" title="2.4.1 什么是 WebClient？"></a>2.4.1 什么是 <code>WebClient</code>？</h4><p><code>WebClient</code> 是 Spring 5 中引入的一个<strong>现代化的、响应式的、非阻塞的HTTP客户端</strong>。它是作为传统的、同步阻塞的 <code>RestTemplate</code> 的替代品而设计的。</p>
<ul>
<li><strong>定位</strong>: Spring WebFlux 官方推荐的HTTP请求工具。</li>
<li><strong>核心特性</strong>:<ul>
<li><strong>非阻塞I&#x2F;O</strong>: 底层基于Netty等非阻塞I&#x2F;O库，发送请求时不会阻塞当前线程。</li>
<li><strong>响应式API</strong>: 它的API设计完全基于Project Reactor的 <code>Mono</code> 和 <code>Flux</code>，可以无缝地集成到响应式处理链中。</li>
<li><strong>流式处理</strong>: 能够高效地处理大量的或持续的数据流（如文件上传下载、Server-Sent Events）。</li>
<li><strong>函数式风格</strong>: 提供了一个流畅的、链式调用的函数式API来构建和发送请求。</li>
</ul>
</li>
</ul>
<p><strong><code>RestTemplate</code> vs <code>WebClient</code></strong>:</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>RestTemplate</code> (维护模式)</th>
<th align="left"><code>WebClient</code> (推荐)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>编程模型</strong></td>
<td align="left"><strong>同步阻塞</strong></td>
<td align="left"><strong>异步非阻塞</strong></td>
</tr>
<tr>
<td align="left"><strong>返回类型</strong></td>
<td align="left">直接返回具体对象 (<code>User</code>, <code>String</code>)</td>
<td align="left">返回 <code>Mono&lt;T&gt;</code> 或 <code>Flux&lt;T&gt;</code> (数据的“承诺”)</td>
</tr>
<tr>
<td align="left"><strong>线程模型</strong></td>
<td align="left">每个请求占用一个线程直到响应返回</td>
<td align="left">使用少量Event Loop线程处理大量并发请求</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">传统的Spring MVC应用、简单的同步调用</td>
<td align="left"><strong>Spring WebFlux应用</strong>、高并发微服务间通信、流式API</td>
</tr>
<tr>
<td align="left"><strong>状态</strong></td>
<td align="left">Spring官方已将其置于<strong>维护模式</strong>，不再添加新功能。</td>
<td align="left">Spring官方<strong>主推</strong>的现代HTTP客户端。</td>
</tr>
</tbody></table>
<hr>
<h4 id="2-4-2-如何使用-WebClient？"><a href="#2-4-2-如何使用-WebClient？" class="headerlink" title="2.4.2 如何使用 WebClient？"></a>2.4.2 如何使用 <code>WebClient</code>？</h4><p>使用 <code>WebClient</code> 通常分为三步：</p>
<ol>
<li><strong>创建 <code>WebClient</code> 实例</strong></li>
<li><strong>构建 HTTP 请求</strong></li>
<li><strong>处理响应</strong></li>
</ol>
<h5 id="1-创建-WebClient-实例"><a href="#1-创建-WebClient-实例" class="headerlink" title="1. 创建 WebClient 实例"></a>1. 创建 <code>WebClient</code> 实例</h5><p><code>WebClient</code> 实例是<strong>线程安全的</strong>和<strong>不可变的</strong>，因此通常建议在应用中创建一个<strong>单例</strong>的 <code>WebClient</code> Bean，并根据需要进行复用。</p>
<p><strong>方式一：使用默认设置创建</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WebClient</span> <span class="variable">client</span> <span class="operator">=</span> WebClient.create();</span><br></pre></td></tr></table></figure>

<p><strong>方式二：指定基础URL创建</strong></p>
<p>这是最常见的方式，可以为所有从此客户端发出的请求设置一个公共的基础URL。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WebClient</span> <span class="variable">client</span> <span class="operator">=</span> WebClient.create(<span class="string">&quot;http://api.example.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>方式三：使用构建器进行高级定制 (推荐)</strong></p>
<p>通过 <code>WebClient.builder()</code> 可以进行更详细的配置，如设置默认请求头、超时、过滤器等。</p>
<p><strong>在 <code>@Configuration</code> 类中创建 <code>WebClient</code> Bean</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.client.WebClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebClientConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebClient <span class="title function_">webClient</span><span class="params">(WebClient.Builder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                .baseUrl(<span class="string">&quot;http://api.example.com&quot;</span>) <span class="comment">// 设置基础URL</span></span><br><span class="line">                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) <span class="comment">// 设置默认请求头</span></span><br><span class="line">                .defaultHeader(<span class="string">&quot;X-App-Name&quot;</span>, <span class="string">&quot;MyCoolApp&quot;</span>)</span><br><span class="line">                <span class="comment">// ... 还可以设置超时、过滤器、负载均衡等</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring Boot会自动配置一个 <code>WebClient.Builder</code> Bean，我们可以在配置类中直接注入并使用它。这样做的好处是可以保留Spring Boot对<code>WebClient</code>的自动配置（如编解码器等）。</p>
</blockquote>
<hr>
<h5 id="2-构建并发送请求-Fluent-API"><a href="#2-构建并发送请求-Fluent-API" class="headerlink" title="2. 构建并发送请求 (Fluent API)"></a>2. 构建并发送请求 (Fluent API)</h5><p><code>WebClient</code> 的API是链式调用的，非常流畅。</p>
<p><strong>请求构建流程</strong>:</p>
<ol>
<li><strong>指定HTTP方法</strong>: <code>.get()</code>, <code>.post()</code>, <code>.put()</code>, <code>.delete()</code> …</li>
<li><strong>指定URI</strong>: <code>.uri(&quot;/users/{id}&quot;, 123)</code>。URI是相对于基础URL的。</li>
<li><strong>设置请求头 (可选)</strong>: <code>.header(&quot;Authorization&quot;, &quot;Bearer ...&quot;)</code>。</li>
<li><strong>设置请求体 (对于POST&#x2F;PUT)</strong>: <code>.bodyValue(object)</code> 或 <code>.body(publisher, class)</code>。</li>
<li><strong>发送请求</strong>: <code>.retrieve()</code>。</li>
<li><strong>处理响应</strong>: <code>.bodyToMono(class)</code> 或 <code>.bodyToFlux(class)</code>。</li>
</ol>
<hr>
<h5 id="3-处理响应"><a href="#3-处理响应" class="headerlink" title="3. 处理响应"></a>3. 处理响应</h5><p><code>WebClient</code> 提供了两种主要的方式来处理响应：<code>retrieve()</code> 和 <code>exchangeToMono</code>&#x2F;<code>exchangeToFlux</code>。</p>
<p><strong>i. 使用 <code>retrieve()</code> (最常用、最简单)</strong></p>
<p><code>retrieve()</code> 方法是处理响应最直接的方式。它会自动检查 <code>4xx</code> 和 <code>5xx</code> 系列的状态码，如果遇到，会直接将 <code>Mono</code> 或 <code>Flux</code> 转换为<strong>错误信号</strong> (<code>onError</code>)，并抛出 <code>WebClientResponseException</code>。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ApiService</span><span class="params">(WebClient webClient)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.webClient = webClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取单个用户 (返回 Mono)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;User&gt; <span class="title function_">getUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.webClient.get()</span><br><span class="line">                .uri(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>, id)</span><br><span class="line">                .retrieve()</span><br><span class="line">                <span class="comment">// 将响应体转换为 Mono&lt;User&gt;</span></span><br><span class="line">                .bodyToMono(User.class)</span><br><span class="line">                .doOnError(e -&gt; System.err.println(<span class="string">&quot;Failed to fetch user: &quot;</span> + e.getMessage()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有用户 (返回 Flux)</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;User&gt; <span class="title function_">getAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.webClient.get()</span><br><span class="line">                .uri(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">                .retrieve()</span><br><span class="line">                <span class="comment">// 将响应体转换为 Flux&lt;User&gt;</span></span><br><span class="line">                .bodyToFlux(User.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新用户 (使用 POST 并发送请求体)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;User&gt; <span class="title function_">createUser</span><span class="params">(User newUser)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.webClient.post()</span><br><span class="line">                .uri(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">                .bodyValue(newUser) <span class="comment">// bodyValue() 用于发送一个普通对象</span></span><br><span class="line">                .retrieve()</span><br><span class="line">                .bodyToMono(User.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ii. 使用 <code>exchangeToMono</code> &#x2F; <code>exchangeToFlux</code> (高级用法)</strong></p>
<p><code>exchangeTo...</code> 方法提供了对响应的<strong>完全控制权</strong>，包括状态码和响应头。它<strong>不会</strong>自动处理错误状态码，你需要自己检查。</p>
<p>这在你需要根据不同的状态码执行不同逻辑时非常有用。</p>
<p><strong>示例：根据状态码进行不同处理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title function_">getUserWithCustomErrorHandling</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.webClient.get()</span><br><span class="line">            .uri(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>, id)</span><br><span class="line">            .exchangeToMono(response -&gt; &#123;</span><br><span class="line">                <span class="comment">// response 是 ClientResponse 对象</span></span><br><span class="line">                <span class="keyword">if</span> (response.statusCode().is2xxSuccessful()) &#123;</span><br><span class="line">                    <span class="comment">// 如果是2xx成功，正常转换响应体</span></span><br><span class="line">                    <span class="keyword">return</span> response.bodyToMono(User.class);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.statusCode().equals(HttpStatus.NOT_FOUND)) &#123;</span><br><span class="line">                    <span class="comment">// 如果是404，返回一个空的Mono</span></span><br><span class="line">                    <span class="keyword">return</span> Mono.empty();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 其他错误情况，创建一个自定义的异常并放入错误信号</span></span><br><span class="line">                    <span class="keyword">return</span> response.createException()</span><br><span class="line">                            .flatMap(ex -&gt; Mono.error(<span class="keyword">new</span> <span class="title class_">MyCustomException</span>(<span class="string">&quot;API call failed&quot;</span>, ex)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-4-3-同步调用-WebClient"><a href="#2-4-3-同步调用-WebClient" class="headerlink" title="2.4.3 同步调用 WebClient"></a>2.4.3 同步调用 <code>WebClient</code></h4><p>虽然 <code>WebClient</code> 是为异步而生，但在某些特殊情况（如与遗留的同步代码集成、或在简单的命令行应用中），你可能需要阻塞等待结果。可以通过 <code>.block()</code> 方法实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// !!! 警告：仅在非响应式上下文中使用，如main方法或测试中 !!!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syncCall</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> webClient.get()</span><br><span class="line">                .uri(<span class="string">&quot;/users/1&quot;</span>)</span><br><span class="line">                .retrieve()</span><br><span class="line">                .bodyToMono(User.class)</span><br><span class="line">                .block(Duration.ofSeconds(<span class="number">5</span>)); <span class="comment">// 阻塞最多5秒等待结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Synchronously fetched user: &quot;</span> + user);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (WebClientResponseException e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Error: &quot;</span> + e.getRawStatusCode() + <span class="string">&quot; - &quot;</span> + e.getResponseBodyAsString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>再次强调</strong>：<strong>永远不要在WebFlux的Controller或任何响应式管道中调用 <code>.block()</code></strong>。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringBoot/" rel="prev" title="Spring全家桶-SpringBoot">
                  <i class="fa fa-angle-left"></i> Spring全家桶-SpringBoot
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringData/" rel="next" title="Spring全家桶-SpringData">
                  Spring全家桶-SpringData <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
