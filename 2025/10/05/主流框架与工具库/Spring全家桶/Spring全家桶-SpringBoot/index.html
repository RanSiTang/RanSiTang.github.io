<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="二、SpringBootSpring Boot 是一个用来简化 Spring 应用创建和开发的框架，让你能快速地搭建和运行独立的、生产级别的 Java 应用程序。 1. SpringBoot核心1.1 四大核心特性1.1.1 起步依赖1. 问题背景：没有Starter的“黑暗时代”在 Spring Boot 出现之前，如果我们想用 Spring Framework 构建一个 Web 应用，需要经历">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring全家桶-SpringBoot">
<meta property="og:url" content="http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringBoot/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="二、SpringBootSpring Boot 是一个用来简化 Spring 应用创建和开发的框架，让你能快速地搭建和运行独立的、生产级别的 Java 应用程序。 1. SpringBoot核心1.1 四大核心特性1.1.1 起步依赖1. 问题背景：没有Starter的“黑暗时代”在 Spring Boot 出现之前，如果我们想用 Spring Framework 构建一个 Web 应用，需要经历">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-05T06:24:40.000Z">
<meta property="article:modified_time" content="2025-10-17T03:09:37.345Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringBoot/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringBoot/","path":"2025/10/05/主流框架与工具库/Spring全家桶/Spring全家桶-SpringBoot/","title":"Spring全家桶-SpringBoot"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Spring全家桶-SpringBoot | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81SpringBoot"><span class="nav-text">二、SpringBoot</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-SpringBoot%E6%A0%B8%E5%BF%83"><span class="nav-text">1. SpringBoot核心</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="nav-text">1.1 四大核心特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E8%B5%B7%E6%AD%A5%E4%BE%9D%E8%B5%96"><span class="nav-text">1.1.1 起步依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF%EF%BC%9A%E6%B2%A1%E6%9C%89Starter%E7%9A%84%E2%80%9C%E9%BB%91%E6%9A%97%E6%97%B6%E4%BB%A3%E2%80%9D"><span class="nav-text">1. 问题背景：没有Starter的“黑暗时代”</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9ASpring-Boot-Starter"><span class="nav-text">2. 解决方案：Spring Boot Starter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A%E4%BC%A0%E9%80%92%E6%80%A7%E4%BE%9D%E8%B5%96-Transitive-Dependencies"><span class="nav-text">3. 工作原理：传递性依赖 (Transitive Dependencies)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF"><span class="nav-text">4. 带来的核心优势</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A"><span class="nav-text">5. 命名约定</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%B7%E6%AD%A5%E4%BE%9D%E8%B5%96"><span class="nav-text">6. 自定义起步依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BB%84%E6%88%90"><span class="nav-text">a). 核心概念与组成</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAmy-greeting-spring-boot-starter"><span class="nav-text">b). 创建一个my-greeting-spring-boot-starter</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E6%80%BB%E7%BB%93"><span class="nav-text">7. 总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="nav-text">1.1.2 自动配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF%EF%BC%9AStarter%E4%B9%8B%E5%90%8E%E8%BF%98%E7%BC%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1. 问题背景：Starter之后还缺什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9ASpring-Boot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="nav-text">2. 解决方案：Spring Boot 自动配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-text">3. 工作原理：三大核心组件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9ADataSource%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="nav-text">4. 一个完整的例子：DataSource的自动配置流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%80%BB%E7%BB%93"><span class="nav-text">5. 总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-%E5%B5%8C%E5%85%A5%E5%BC%8FWeb%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">1.1.3 嵌入式Web服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF%EF%BC%9A%E4%BC%A0%E7%BB%9F%E7%9A%84Web%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F"><span class="nav-text">1. 问题背景：传统的Web应用部署方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9ASpring-Boot%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">2. 解决方案：Spring Boot的嵌入式服务器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%89%93%E5%8C%85%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8F%98%E9%9D%A9"><span class="nav-text">3. 打包与运行方式的变革</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF-1"><span class="nav-text">4. 带来的核心优势</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%88%87%E6%8D%A2"><span class="nav-text">5. 服务器的切换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E6%80%BB%E7%BB%93"><span class="nav-text">6. 总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-4-%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="nav-text">1.1.4 外部化配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF%EF%BC%9A%E7%A1%AC%E7%BC%96%E7%A0%81%E9%85%8D%E7%BD%AE%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="nav-text">1. 问题背景：硬编码配置的弊端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9ASpring-Boot%E7%9A%84%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="nav-text">2. 解决方案：Spring Boot的外部化配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Spring-Boot%E6%94%AF%E6%8C%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%BA%90"><span class="nav-text">3. Spring Boot支持的配置源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE"><span class="nav-text">4. 如何在代码中使用配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%80%BB%E7%BB%93-1"><span class="nav-text">5. 总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-SpringBootApplication%E6%B3%A8%E8%A7%A3%E5%88%A8%E6%9E%90"><span class="nav-text">1.2 @SpringBootApplication注解刨析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-SpringBootConfiguration"><span class="nav-text">1.2.1 @SpringBootConfiguration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-EnableAutoConfiguration"><span class="nav-text">1.2.2 @EnableAutoConfiguration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-ComponentScan"><span class="nav-text">3. @ComponentScan</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E6%80%BB%E7%BB%93"><span class="nav-text">1.2.3 总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span class="nav-text">1.2.4 自定义属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-SpringApplication-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="nav-text">1.3 SpringApplication 启动流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%9ASpringApplication-%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">第一阶段：SpringApplication 实例初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%9Arun-%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-%E6%A0%B8%E5%BF%83"><span class="nav-text">第二阶段：run() 方法执行流程 (核心)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-text">流程图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="nav-text">2. 配置文件详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-application-properties-vs-application-yml"><span class="nav-text">2.1 application.properties vs application.yml</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-application-properties"><span class="nav-text">2.1.1 application.properties</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-application-yml-yaml"><span class="nav-text">2.1.2 application.yml (.yaml)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-%E5%AF%B9%E6%AF%94%E4%B8%8E%E6%80%BB%E7%BB%93"><span class="nav-text">2.1.3 对比与总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-Profiles-application-dev-yml-application-prod-yml"><span class="nav-text">2.2 多环境配置 (Profiles) - application-dev.yml, application-prod.yml</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%EF%BC%9F"><span class="nav-text">2.2.1 为什么需要多环境配置？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-Profile%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">2.2.2 Profile的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E5%90%8D%E7%9A%84Profile%E9%85%8D%E7%BD%AE-application-profile-yml"><span class="nav-text">1. 基于文件名的Profile配置 (application-{profile}.yml)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-YAML%E6%96%87%E6%A1%A3%E5%88%86%E9%9A%94%E7%AC%A6%E6%96%B9%E5%BC%8F"><span class="nav-text">2. YAML文档分隔符方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E5%A6%82%E4%BD%95%E6%BF%80%E6%B4%BB%E6%8C%87%E5%AE%9A%E7%9A%84Profile%EF%BC%9F"><span class="nav-text">2.2.3 如何激活指定的Profile？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-%E5%9C%A8Java%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8Profile-Profile-%E6%B3%A8%E8%A7%A3"><span class="nav-text">2.2.4 在Java代码中使用Profile (@Profile 注解)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">2.3 配置加载优先级</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%BA%90%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%97%E8%A1%A8-%E7%94%B1%E9%AB%98%E5%88%B0%E4%BD%8E"><span class="nav-text">2.3.1 核心配置源优先级列表 (由高到低)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E7%A4%BA%E4%BE%8B"><span class="nav-text">2.3.2 示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">2.3.3 总结与最佳实践</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5"><span class="nav-text">2.4 属性注入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-Value%E6%B3%A8%E5%85%A5%E5%8D%95%E4%B8%AA%E5%B1%9E%E6%80%A7"><span class="nav-text">2.4.1 @Value注入单个属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-text">1. 基本语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">2. 使用示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%8F%90%E4%BE%9B%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-text">3. 提供默认值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-SpEL-Spring-Expression-Language-%E6%94%AF%E6%8C%81"><span class="nav-text">4. SpEL (Spring Expression Language) 支持</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-Value-vs-ConfigurationProperties"><span class="nav-text">5. @Value vs @ConfigurationProperties</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-ConfigurationProperties"><span class="nav-text">2.4.2 @ConfigurationProperties</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">1. 核心思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-text">2. 基本用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="nav-text">3. 核心特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">4. 总结与最佳实践</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%9B%91%E6%8E%A7%E4%B8%8E%E7%AE%A1%E7%90%86-Actuator"><span class="nav-text">3. 监控与管理(Actuator)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Actuator%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">3.1 Actuator是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%B9%89"><span class="nav-text">3.1.1 核心定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E5%BA%94%E7%94%A8%E7%9A%84%E2%80%9C%E9%BB%91%E7%9B%92%E2%80%9D%E5%9B%B0%E5%A2%83"><span class="nav-text">3.1.2 解决的问题：应用的“黑盒”困境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-text">3.1.3 工作原理与核心组件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%AB%AF%E7%82%B9-Endpoints"><span class="nav-text">1. 端点 (Endpoints)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%81%A5%E5%BA%B7%E6%8C%87%E7%A4%BA%E5%99%A8-Health-Indicators"><span class="nav-text">2. 健康指示器 (Health Indicators)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Actuator%EF%BC%9F"><span class="nav-text">3.1.4 如何使用 Actuator？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%B7%BB%E5%8A%A0-spring-boot-starter-actuator-%E4%BE%9D%E8%B5%96"><span class="nav-text">1. 添加 spring-boot-starter-actuator 依赖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E9%85%8D%E7%BD%AE%E7%AB%AF%E7%82%B9%E7%9A%84%E6%9A%B4%E9%9C%B2"><span class="nav-text">2. 配置端点的暴露</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-5-Actuator-%E5%B8%A6%E6%9D%A5%E7%9A%84%E4%BB%B7%E5%80%BC"><span class="nav-text">3.1.5 Actuator 带来的价值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%B8%B8%E7%94%A8%E7%AB%AF%E7%82%B9-Endpoints-%E4%BB%8B%E7%BB%8D"><span class="nav-text">3.2 常用端点 (Endpoints) 介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-health-%E5%BA%94%E7%94%A8%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5"><span class="nav-text">3.2.1 &#x2F;health - 应用健康检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-info-%E5%BA%94%E7%94%A8%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="nav-text">3.2.2 &#x2F;info - 应用基本信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-metrics-%E8%AF%A6%E7%BB%86%E5%BA%A6%E9%87%8F%E6%8C%87%E6%A0%87"><span class="nav-text">3.2.3 &#x2F;metrics - 详细度量指标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-beans-Spring%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84Bean"><span class="nav-text">3.2.4 &#x2F;beans - Spring容器中的Bean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-5-env-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="nav-text">3.2.5 &#x2F;env - 环境变量与配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-6-loggers-%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB%E7%AE%A1%E7%90%86"><span class="nav-text">3.2.6 &#x2F;loggers - 日志级别管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-7-%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%AB%AF%E7%82%B9"><span class="nav-text">3.2.7 其他常用端点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%AE%9A%E5%88%B6%E5%8C%96Actuator%E7%AB%AF%E7%82%B9"><span class="nav-text">3.3 定制化Actuator端点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E5%AE%9A%E5%88%B6%E7%8E%B0%E6%9C%89%E7%AB%AF%E7%82%B9"><span class="nav-text">3.3.1 定制现有端点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AE%9A%E5%88%B6-health-%E7%AB%AF%E7%82%B9-%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89-HealthIndicator"><span class="nav-text">1. 定制 &#x2F;health 端点 (编写自定义 HealthIndicator)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%AE%9A%E5%88%B6-info-%E7%AB%AF%E7%82%B9-%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89-InfoContributor"><span class="nav-text">2. 定制 &#x2F;info 端点 (编写自定义 InfoContributor)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E5%88%9B%E5%BB%BA%E5%85%A8%E6%96%B0%E7%AB%AF%E7%82%B9-%E5%AE%9E%E7%8E%B0-Endpoint"><span class="nav-text">3.3.2 创建全新端点 (实现 @Endpoint)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-%E5%AE%89%E5%85%A8%E4%B8%8E%E6%9A%B4%E9%9C%B2%E7%AD%96%E7%95%A5%E5%AE%9A%E5%88%B6"><span class="nav-text">3.3.3 安全与暴露策略定制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%B2%BE%E7%BB%86%E5%8C%96%E6%9A%B4%E9%9C%B2"><span class="nav-text">1. 精细化暴露</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BF%AE%E6%94%B9%E5%9F%BA%E7%A1%80%E8%B7%AF%E5%BE%84%E5%92%8C%E7%AB%AF%E5%8F%A3"><span class="nav-text">2. 修改基础路径和端口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E9%9B%86%E6%88%90Spring-Security"><span class="nav-text">3. 集成Spring Security</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringBoot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Spring全家桶-SpringBoot | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring全家桶-SpringBoot
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-05 14:24:40" itemprop="dateCreated datePublished" datetime="2025-10-05T14:24:40+08:00">2025-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 11:09:37" itemprop="dateModified" datetime="2025-10-17T11:09:37+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/" itemprop="url" rel="index"><span itemprop="name">Spring全家桶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="二、SpringBoot"><a href="#二、SpringBoot" class="headerlink" title="二、SpringBoot"></a>二、SpringBoot</h1><p><strong>Spring Boot 是一个用来简化 Spring 应用创建和开发的框架，让你能快速地搭建和运行独立的、生产级别的 Java 应用程序。</strong></p>
<h2 id="1-SpringBoot核心"><a href="#1-SpringBoot核心" class="headerlink" title="1. SpringBoot核心"></a>1. SpringBoot核心</h2><h3 id="1-1-四大核心特性"><a href="#1-1-四大核心特性" class="headerlink" title="1.1 四大核心特性"></a>1.1 四大核心特性</h3><h4 id="1-1-1-起步依赖"><a href="#1-1-1-起步依赖" class="headerlink" title="1.1.1 起步依赖"></a>1.1.1 起步依赖</h4><h5 id="1-问题背景：没有Starter的“黑暗时代”"><a href="#1-问题背景：没有Starter的“黑暗时代”" class="headerlink" title="1. 问题背景：没有Starter的“黑暗时代”"></a>1. 问题背景：没有Starter的“黑暗时代”</h5><p>在 Spring Boot 出现之前，如果我们想用 Spring Framework 构建一个 Web 应用，需要经历一个繁琐且易错的过程：</p>
<ol>
<li><strong>手动添加大量依赖</strong>：我们需要在 <code>pom.xml</code> (Maven) 或 <code>build.gradle</code> (Gradle) 中手动添加一长串的依赖项，例如：<ul>
<li>核心Spring框架：<code>spring-core</code>, <code>spring-beans</code>, <code>spring-context</code></li>
<li>Web功能：<code>spring-web</code>, <code>spring-webmvc</code></li>
<li>Servlet容器：<code>tomcat-embed-core</code>, <code>tomcat-embed-el</code></li>
<li>…可能还有日志、校验等其他库。</li>
</ul>
</li>
<li><strong>管理复杂的版本兼容性</strong>：你需要确保你添加的所有库版本之间都是相互兼容的。如果版本不匹配，轻则出现警告，重则应用在运行时直接崩溃。这个过程被称为**“依赖地狱 (Dependency Hell)”**。</li>
<li><strong>编写大量的模板配置</strong>：添加完依赖后，还需要编写大量的XML或Java配置来把这些组件整合起来，比如配置 <code>DispatcherServlet</code>、视图解析器、Jackson的 <code>ObjectMapper</code> 等。</li>
</ol>
<p>这个过程不仅耗时，而且对于新手来说门槛极高，任何一个环节出错都可能导致项目无法启动。</p>
<hr>
<h5 id="2-解决方案：Spring-Boot-Starter"><a href="#2-解决方案：Spring-Boot-Starter" class="headerlink" title="2. 解决方案：Spring Boot Starter"></a>2. 解决方案：Spring Boot Starter</h5><p>Spring Boot Starter 的出现，就是为了彻底解决上述问题。</p>
<p><strong>核心定义</strong>：一个<strong>起步依赖 (Starter)</strong> 本质上是一个<strong>精心策划的、一站式的依赖描述符（通常是一个Maven项目&#x2F;POM）</strong>。它将构建特定类型应用（如Web、数据访问、消息队列）所需的一整套通用依赖项<strong>打包</strong>在一起。</p>
<hr>
<h5 id="3-工作原理：传递性依赖-Transitive-Dependencies"><a href="#3-工作原理：传递性依赖-Transitive-Dependencies" class="headerlink" title="3. 工作原理：传递性依赖 (Transitive Dependencies)"></a>3. 工作原理：传递性依赖 (Transitive Dependencies)</h5><p>Starter 本身通常是一个**“空壳”**。它里面几乎没有Java代码，其真正的价值在于它的 <code>pom.xml</code> 文件。</p>
<p>当你引入一个 Starter 时，例如 <code>spring-boot-starter-web</code>，Maven或Gradle会利用<strong>传递性依赖</strong>机制，自动将这个Starter的<code>pom.xml</code>中声明的所有相关依赖项全部下载并添加到你的项目中。</p>
<p><strong>以 <code>spring-boot-starter-web</code> 为例：</strong></p>
<p>当你只在 <code>pom.xml</code> 中添加了这一行：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你实际上获得了以下所有核心依赖（版本由Spring Boot统一管理）：</p>
<ul>
<li><code>spring-boot-starter</code>：核心Starter，提供了自动配置、日志和YAML支持。</li>
<li><code>spring-boot-starter-json</code>：提供了对JSON的读写支持，内部依赖了 <code>jackson-databind</code>。</li>
<li><code>spring-boot-starter-tomcat</code>：提供了内嵌的Tomcat服务器。</li>
<li><code>spring-web</code> 和 <code>spring-webmvc</code>：Spring MVC框架的核心。</li>
<li><code>hibernate-validator</code>：提供了数据校验的支持。</li>
</ul>
<p><strong>版本管理</strong>：所有这些依赖的版本号，都由 <code>spring-boot-dependencies</code> 这个特殊的 “parent POM” 统一管理。Spring Boot 团队对这些版本组合进行了大量的测试，确保它们之间完美兼容。你无需再为版本号操心。</p>
<hr>
<h5 id="4-带来的核心优势"><a href="#4-带来的核心优势" class="headerlink" title="4. 带来的核心优势"></a>4. 带来的核心优势</h5><ol>
<li><strong>极简的依赖管理</strong>：<ul>
<li><strong>之前</strong>：需要添加 5-10 个或更多的 <code>&lt;dependency&gt;</code> 标签。</li>
<li><strong>现在</strong>：只需要添加 1 个 <code>&lt;dependency&gt;</code> 标签。</li>
</ul>
</li>
<li><strong>杜绝版本冲突</strong>：<ul>
<li><strong>之前</strong>：开发者需要像“排雷”一样手动协调版本。</li>
<li><strong>现在</strong>：版本由Spring Boot官方统一管理和测试，开箱即用，稳定可靠。</li>
</ul>
</li>
<li><strong>功能开箱即用</strong>：<ul>
<li>引入Starter不仅是添加了JAR包，它还常常与Spring Boot的<strong>自动配置</strong>特性联动。例如，一旦 <code>spring-boot-starter-web</code> 被引入，Spring Boot就会自动为你配置好 <code>DispatcherServlet</code>、<code>Tomcat</code> 服务器等Web环境所需的一切，让应用可以直接启动并处理HTTP请求。</li>
</ul>
</li>
<li><strong>加速项目启动和原型开发</strong>：<ul>
<li>开发者可以快速地搭建起一个具备特定功能（Web、JPA、Redis等）的应用原型，而无需陷入繁琐的配置细节中。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="5-命名约定"><a href="#5-命名约定" class="headerlink" title="5. 命名约定"></a>5. 命名约定</h5><ul>
<li><strong>官方Starter</strong>：由Spring Boot团队维护，命名格式为 <code>spring-boot-starter-*</code>，例如 <code>spring-boot-starter-data-jpa</code>。</li>
<li><strong>社区&#x2F;第三方Starter</strong>：由社区或第三方公司提供，为了避免混淆，官方推荐的命名格式为 <code>*-spring-boot-starter</code>，例如 <code>mybatis-spring-boot-starter</code>。</li>
</ul>
<hr>
<h5 id="6-自定义起步依赖"><a href="#6-自定义起步依赖" class="headerlink" title="6. 自定义起步依赖"></a>6. 自定义起步依赖</h5><h6 id="a-核心概念与组成"><a href="#a-核心概念与组成" class="headerlink" title="a). 核心概念与组成"></a>a). 核心概念与组成</h6><p>一个标准的自定义Starter通常由<strong>两个模块</strong>组成，这是最佳实践：</p>
<ol>
<li><strong><code>xxx-spring-boot-autoconfigure</code> 模块</strong>:<ul>
<li><strong>核心功能模块</strong>。它包含了所有自动配置的代码、<code>@ConfigurationProperties</code>类以及需要被注册为Bean的业务类。</li>
<li><strong>这是Starter的“大脑”</strong>。它负责判断在何种条件下（<code>@ConditionalOn...</code>），应该创建哪些Bean，以及如何配置它们。</li>
</ul>
</li>
<li><strong><code>xxx-spring-boot-starter</code> 模块</strong>:<ul>
<li><strong>依赖聚合模块</strong>。这个模块本身<strong>几乎没有任何代码</strong>。</li>
<li>它的唯一作用就是在 <code>pom.xml</code> 中<strong>聚合依赖</strong>。它会依赖于上面的 <code>autoconfigure</code> 模块，以及其他任何这个功能所需要的第三方库。</li>
<li><strong>这是用户唯一需要关心的模块</strong>。用户在他的项目中，只需要引入这一个Starter依赖，就能获得所有功能。</li>
</ul>
</li>
</ol>
<p><strong>为什么要分成两个模块？</strong></p>
<p>这是为了<strong>关注点分离</strong>。<code>autoconfigure</code>模块负责实现所有逻辑，而<code>starter</code>模块只负责提供一个简单的依赖入口。用户只需要依赖<code>starter</code>，而不需要关心具体的自动配置实现，使得依赖关系更清晰。</p>
<hr>
<h6 id="b-创建一个my-greeting-spring-boot-starter"><a href="#b-创建一个my-greeting-spring-boot-starter" class="headerlink" title="b). 创建一个my-greeting-spring-boot-starter"></a>b). 创建一个<code>my-greeting-spring-boot-starter</code></h6><p>我们的目标是创建一个Starter，它能提供一个<code>GreetingService</code> Bean。这个Bean的行为可以通过 <code>application.properties</code> 进行配置。</p>
<p><strong>最终效果</strong>：</p>
<ol>
<li><p>用户只需在项目中引入我们的<code>my-greeting-spring-boot-starter</code>依赖。</p>
</li>
<li><p>用户可以在<code>application.properties</code>中配置问候语的前缀和后缀，如：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my.greeting.prefix</span>=<span class="string">Hi, </span></span><br><span class="line"><span class="attr">my.greeting.suffix</span>=<span class="string">. Welcome!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用户可以在自己的代码中直接 <code>@Autowired</code> 注入 <code>GreetingService</code> 并使用它。</p>
</li>
</ol>
<hr>
<p><strong>步骤 1: 创建项目结构 (Maven)</strong></p>
<p>首先，创建一个父Maven项目，并在其中创建两个子模块 。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my-greeting-starter-parent</span><br><span class="line">├── pom.xml</span><br><span class="line">├── my-greeting-spring-boot-autoconfigure</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src/main/java/...</span><br><span class="line">│   └── src/main/resources/...</span><br><span class="line">└── my-greeting-spring-boot-starter</span><br><span class="line">    └── pom.xml</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>父 <code>pom.xml</code></strong>: 管理公共的版本信息。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-greeting-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span> <span class="comment">&lt;!-- 请使用合适的版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-greeting-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>my-greeting-spring-boot-starter<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><strong>步骤 2: 实现 <code>autoconfigure</code> 模块</strong></p>
<p>这是我们的核心工作区。</p>
<p><strong>1. <code>pom.xml</code> for <code>autoconfigure</code></strong></p>
<p>这个模块需要依赖Spring Boot的自动配置处理器。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-greeting-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-greeting-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入Spring Boot自动配置核心包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入配置属性处理器，用于生成配置元数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 创建属性配置类 (<code>GreetingProperties.java</code>)</strong></p>
<p>这个类用于映射 <code>application.properties</code>中的配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.greeting.autoconfigure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;my.greeting&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The prefix of the greeting message.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> <span class="string">&quot;Hello, &quot;</span>; <span class="comment">// 提供默认值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The suffix of the greeting message.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> <span class="string">&quot;!&quot;</span>; <span class="comment">// 提供默认值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPrefix</span><span class="params">()</span> &#123; <span class="keyword">return</span> prefix; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrefix</span><span class="params">(String prefix)</span> &#123; <span class="built_in">this</span>.prefix = prefix; &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSuffix</span><span class="params">()</span> &#123; <span class="keyword">return</span> suffix; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuffix</span><span class="params">(String suffix)</span> &#123; <span class="built_in">this</span>.suffix = suffix; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Tip</strong>: 添加JavaDoc注释，<code>spring-boot-configuration-processor</code>会自动生成<code>spring-configuration-metadata.json</code>文件，为IDE提供配置提示。</p>
</blockquote>
<p><strong>3. 创建业务服务类 (<code>GreetingService.java</code>)</strong></p>
<p>这是我们想提供给用户的核心服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.greeting.autoconfigure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String prefix;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String suffix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GreetingService</span><span class="params">(String prefix, String suffix)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.prefix = prefix;</span><br><span class="line">        <span class="built_in">this</span>.suffix = suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">greet</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prefix + name + suffix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 创建自动配置类 (<code>GreetingAutoConfiguration.java</code>)</strong></p>
<p>这是Starter的灵魂！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.greeting.autoconfigure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 启用我们定义的属性类，使其生效</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(GreetingProperties.class)</span></span><br><span class="line"><span class="comment">// 条件注解：只有当配置文件中 my.greeting.enabled=true (或未设置) 时，此配置才生效</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;my.greeting&quot;, name = &quot;enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入属性类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GreetingProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GreetingAutoConfiguration</span><span class="params">(GreetingProperties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> GreetingService <span class="title function_">greetingService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用配置的属性来创建GreetingService的Bean</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GreetingService</span>(properties.getPrefix(), properties.getSuffix());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>@ConditionalOnProperty</code></strong> 非常关键！<code>matchIfMissing = true</code> 表示如果用户没有配置<code>my.greeting.enabled</code>，则默认此条件满足（即默认启用），这是一种很好的设计。</p>
</blockquote>
<p><strong>5. 创建 <code>spring.factories</code> 文件</strong></p>
<p>这是Spring Boot发现我们自动配置类的入口。</p>
<p>在 <code>src/main/resources/META-INF/</code> 目录下创建 <code>spring.factories</code> 文件。</p>
<p><strong>路径</strong>: <code>my-greeting-spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories</code></p>
<p><strong>内容</strong>:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Auto Configuration</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.example.greeting.autoconfigure.GreetingAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果类名很长，可以使用 <code>\</code> 来换行。确保类的完整路径名是正确的。</p>
</blockquote>
<p>至此，<code>autoconfigure</code>模块就完成了。</p>
<hr>
<p><strong>步骤 3: 实现 <code>starter</code> 模块</strong></p>
<p>这个模块非常简单。</p>
<p><strong>1. <code>pom.xml</code> for <code>starter</code></strong></p>
<p>它只需要依赖于<code>autoconfigure</code>模块。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-greeting-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-greeting-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这个模块的唯一职责就是传递依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-greeting-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个模块甚至不需要<code>src</code>目录。</p>
<hr>
<p><strong>步骤 4: 构建和安装</strong></p>
<p>在父项目的根目录下，执行Maven命令，将我们的Starter安装到本地仓库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>步骤 5: 使用我们的自定义Starter</strong></p>
<p>现在，我们可以像使用官方Starter一样使用它了。</p>
<p><strong>1. 创建一个新的Spring Boot应用</strong></p>
<p><strong>2. 在 <code>pom.xml</code> 中引入我们的Starter</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-greeting-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 在 <code>application.properties</code> 中进行配置</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义问候语</span></span><br><span class="line"><span class="attr">my.greeting.prefix</span>=<span class="string">Welcome, Mr/Ms. </span></span><br><span class="line"><span class="attr">my.greeting.suffix</span>=<span class="string">. Have a nice day!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 如果想禁用这个功能，可以设置</span></span><br><span class="line"><span class="comment"># my.greeting.enabled=false</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 在代码中使用 <code>GreetingService</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demouser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.greeting.autoconfigure.GreetingService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoUserApplication</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GreetingService greetingService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoUserApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (greetingService != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> greetingService.greet(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;GreetingService not available.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Welcome, Mr/Ms. Alice. Have a nice day!</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h5><p><strong>起步依赖 (Starters) 是 Spring Boot “约定优于配置” 理念的基石</strong>。它通过将复杂的依赖关系和版本管理封装起来，将开发者从繁琐的配置工作中解放出来，使其能够更专注于业务逻辑的实现。这是Spring Boot能够如此流行和高效的关键原因之一。</p>
<hr>
<h4 id="1-1-2-自动配置"><a href="#1-1-2-自动配置" class="headerlink" title="1.1.2 自动配置"></a>1.1.2 自动配置</h4><h5 id="1-问题背景：Starter之后还缺什么？"><a href="#1-问题背景：Starter之后还缺什么？" class="headerlink" title="1. 问题背景：Starter之后还缺什么？"></a>1. 问题背景：Starter之后还缺什么？</h5><p>在上一节的**起步依赖 (Starter)<strong>解决了</strong>“需要哪些依赖”**的问题，帮我们自动引入了一整套JAR包。但仅仅有JAR包是不够的。</p>
<p>在传统的Spring应用中，即使引入了所有依赖，我们仍然需要手动编写大量的Java配置（或XML）来“激活”和“组装”这些依赖中的组件。例如，引入了<code>spring-boot-starter-jdbc</code>后，我们还需要手动配置：</p>
<ul>
<li><code>DataSource</code> Bean (数据源)</li>
<li><code>JdbcTemplate</code> Bean</li>
<li><code>PlatformTransactionManager</code> Bean (事务管理器)</li>
</ul>
<p>我们需要告诉Spring：“我引入了数据库驱动和连接池，请帮我创建一个<code>DataSource</code>；我还想用<code>JdbcTemplate</code>来操作数据库，也请帮我创建一个实例并把<code>DataSource</code>注入进去。”</p>
<p>这个“告诉”的过程，就是<strong>配置</strong>。如果每个项目都需要重复编写这些几乎一模一样的“样板代码”，那效率依然很低。</p>
<hr>
<h5 id="2-解决方案：Spring-Boot-自动配置"><a href="#2-解决方案：Spring-Boot-自动配置" class="headerlink" title="2. 解决方案：Spring Boot 自动配置"></a>2. 解决方案：Spring Boot 自动配置</h5><p>自动配置的核心思想是：<strong>Spring Boot 尝试根据你项目中引入的依赖（即类路径下的JAR包），自动猜测你可能需要哪些Bean，并智能地为你创建和配置好它们。</strong></p>
<hr>
<h5 id="3-工作原理：三大核心组件"><a href="#3-工作原理：三大核心组件" class="headerlink" title="3. 工作原理：三大核心组件"></a>3. 工作原理：三大核心组件</h5><p>Spring Boot的自动配置魔法主要依赖于以下三个组件的协同工作：</p>
<p><strong>A. <code>@SpringBootApplication</code> 注解</strong></p>
<p>这是我们启动类的入口注解，它是一个复合注解，其中最重要的一个元注解是：</p>
<ul>
<li><strong><code>@EnableAutoConfiguration</code></strong>：这个注解是<strong>开启自动配置功能的总开关</strong>。它告诉Spring Boot：“请启动你的智能探测模式，开始自动配置吧！”</li>
</ul>
<p><strong>B. <code>spring.factories</code> 文件</strong></p>
<p><code>@EnableAutoConfiguration</code> 是如何知道有哪些自动配置可以应用的呢？答案就在<code>spring-boot-autoconfigure.jar</code>这个JAR包里的 <code>META-INF/spring.factories</code> 文件中。</p>
<ul>
<li><p><strong>这是一个“自动配置清单”</strong>。打开这个文件，你会看到一个巨大的列表，以键值对的形式存在：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span></span><br><span class="line"><span class="string"># ... 还有几百行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring Boot启动时，会加载所有JAR包中<code>META-INF/spring.factories</code>文件里<code>EnableAutoConfiguration</code>键下的<strong>所有配置类</strong>。</p>
</li>
</ul>
<p><strong>C. 条件化配置 (<code>@ConditionalOn...</code>)</strong></p>
<p>Spring Boot加载了上百个自动配置类，但显然我们不需要所有的功能。那么Spring Boot是如何决定哪个配置类应该生效呢？<strong>答案是：条件判断</strong>。</p>
<ul>
<li><strong>每一个自动配置类（如 <code>DataSourceAutoConfiguration</code>）都被 <code>@ConditionalOn...</code> 系列注解所标记。</strong></li>
<li>这些注解定义了该配置类生效的<strong>条件</strong>。只有当<strong>所有条件都满足</strong>时，这个自动配置类才会生效，它内部定义的<code>@Bean</code>才会被创建。</li>
</ul>
<p><strong>常见的条件注解：</strong></p>
<table>
<thead>
<tr>
<th align="left">注解</th>
<th align="left">描述</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>@ConditionalOnClass</code></strong></td>
<td align="left"><strong>类路径下存在指定的类</strong>时，条件满足。 (这是最常用的)</td>
<td align="left"><code>@ConditionalOnClass(DataSource.class)</code>: 只有当有数据源实现时才生效</td>
</tr>
<tr>
<td align="left"><strong><code>@ConditionalOnMissingBean</code></strong></td>
<td align="left"><strong>容器中不存在指定类型的Bean</strong>时，条件满足。 (防止用户自定义的Bean被覆盖)</td>
<td align="left"><code>@ConditionalOnMissingBean(DataSource.class)</code>: 如果用户自己配了数据源，我就不配了</td>
</tr>
<tr>
<td align="left"><strong><code>@ConditionalOnBean</code></strong></td>
<td align="left"><strong>容器中已存在指定类型的Bean</strong>时，条件满足。</td>
<td align="left"><code>@ConditionalOnBean(DataSource.class)</code>: 只有数据源存在时，才配JdbcTemplate</td>
</tr>
<tr>
<td align="left"><strong><code>@ConditionalOnProperty</code></strong></td>
<td align="left"><strong>配置文件中有指定的属性且值匹配</strong>时，条件满足。</td>
<td align="left"><code>@ConditionalOnProperty(name=&quot;spring.jpa.open-in-view&quot;, havingValue=&quot;true&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong><code>@ConditionalOnResource</code></strong></td>
<td align="left"><strong>类路径下存在指定的资源文件</strong>时，条件满足。</td>
<td align="left"><code>@ConditionalOnResource(resources=&quot;classpath:db/migration&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong><code>@ConditionalOnWebApplication</code></strong></td>
<td align="left"><strong>当前是一个Web应用</strong>时，条件满足。</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left"><strong><code>@ConditionalOnExpression</code></strong></td>
<td align="left">**SpEL表达式返回<code>true</code>**时，条件满足。 (最灵活)</td>
<td align="left"><code>@ConditionalOnExpression(&quot;${spring.jmx.enabled:true}&quot;)</code></td>
</tr>
</tbody></table>
<hr>
<h5 id="4-一个完整的例子：DataSource的自动配置流程"><a href="#4-一个完整的例子：DataSource的自动配置流程" class="headerlink" title="4. 一个完整的例子：DataSource的自动配置流程"></a>4. 一个完整的例子：<code>DataSource</code>的自动配置流程</h5><ol>
<li><strong>启动</strong>：你的应用启动，<code>@SpringBootApplication</code> 中的 <code>@EnableAutoConfiguration</code> 生效。</li>
<li><strong>加载清单</strong>：Spring Boot读取所有<code>spring.factories</code>文件，加载了包括 <code>DataSourceAutoConfiguration</code> 在内的上百个配置类。</li>
<li><strong>条件判断</strong>：轮到 <code>DataSourceAutoConfiguration</code> 进行判断了：<ul>
<li><strong>检查 <code>@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })</code></strong>: 你在<code>pom.xml</code>中加入了<code>spring-boot-starter-jdbc</code>，它传递依赖了<code>HikariCP.jar</code> (一个DataSource实现)，所以类路径下存在<code>DataSource.class</code>。<strong>条件满足</strong>。</li>
<li><strong>检查 <code>@ConditionalOnMissingBean(DataSource.class)</code></strong>: Spring Boot会检查容器里是不是已经有一个<code>DataSource</code>类型的Bean了。因为你没有自己手动配置，所以<strong>条件满足</strong>。</li>
</ul>
</li>
<li><strong>生效</strong>：所有条件都满足，<code>DataSourceAutoConfiguration</code> 这个配置类<strong>正式生效</strong>。</li>
<li><strong>创建Bean</strong>：Spring Boot开始执行 <code>DataSourceAutoConfiguration</code> 内部被<code>@Bean</code>注解的方法，该方法会读取你的<code>application.properties</code>中的<code>spring.datasource.url</code>等属性，为你创建一个配置好的<code>DataSource</code> Bean，并放入IoC容器。</li>
</ol>
<p><strong>用户覆盖</strong>：如果你在自己的<code>@Configuration</code>类里手动配置了一个<code>DataSource</code> Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">myCustomDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... 你的自定义配置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyDataSource</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在第3步中，<code>@ConditionalOnMissingBean(DataSource.class)</code> 的条件就会<strong>不满足</strong>，<code>DataSourceAutoConfiguration</code> 就会<strong>自动失效</strong>，完全尊重你的自定义配置。</p>
<hr>
<h5 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h5><p><strong>自动配置是Spring Boot“约定优于配置”理念的终极体现</strong>。它通过**<code>@EnableAutoConfiguration</code><strong>、</strong><code>spring.factories</code><strong>和</strong><code>@ConditionalOn...</code>**三驾马车的协同工作，实现了对项目依赖的智能分析和对Bean的按需、动态配置。这使得开发者可以从大量的样板配置中解脱出来，真正做到“引入即用，按需覆盖”。</p>
<hr>
<h4 id="1-1-3-嵌入式Web服务器"><a href="#1-1-3-嵌入式Web服务器" class="headerlink" title="1.1.3 嵌入式Web服务器"></a>1.1.3 嵌入式Web服务器</h4><h5 id="1-问题背景：传统的Web应用部署方式"><a href="#1-问题背景：传统的Web应用部署方式" class="headerlink" title="1. 问题背景：传统的Web应用部署方式"></a>1. 问题背景：传统的Web应用部署方式</h5><p>在 Spring Boot 出现之前，开发和部署一个Java Web应用通常遵循以下步骤：</p>
<ol>
<li><strong>项目打包</strong>：将整个Web应用（包括所有Java类、资源文件、库文件和<code>WEB-INF/web.xml</code>）打包成一个 <strong>WAR (Web Application Archive)</strong> 文件。</li>
<li><strong>准备外部服务器</strong>：需要在服务器上预先安装并配置一个独立的 <strong>Servlet 容器</strong>，最常见的就是 <strong>Apache Tomcat</strong>。此外还有 Jetty、Undertow 等。</li>
<li><strong>手动部署</strong>：运维人员需要将打好的 WAR 包<strong>复制</strong>到 Tomcat 的 <code>webapps</code> 目录下。</li>
<li><strong>启动服务器</strong>：启动外部的 Tomcat 服务器。Tomcat 会自动解压并加载 WAR 包，启动Web应用。</li>
</ol>
<p><strong>这种传统方式的痛点：</strong></p>
<ul>
<li><strong>环境依赖重</strong>：应用无法独立运行，它强依赖于外部的服务器环境。开发、测试和生产环境的Tomcat版本和配置可能不一致，导致“在我机器上是好的”问题。</li>
<li><strong>部署流程繁琐</strong>：需要下载、安装、配置服务器，然后是“打包-&gt;拷贝-&gt;启动”的部署流程，自动化程度低，效率不高。</li>
<li><strong>应用臃肿</strong>：WAR 包的结构相对复杂。</li>
<li><strong>不符合微服务理念</strong>：在微服务架构中，我们希望每个服务都是一个独立的、自包含的、可以快速启动和销毁的进程。传统部署方式显然过于“笨重”。</li>
</ul>
<hr>
<h5 id="2-解决方案：Spring-Boot的嵌入式服务器"><a href="#2-解决方案：Spring-Boot的嵌入式服务器" class="headerlink" title="2. 解决方案：Spring Boot的嵌入式服务器"></a>2. 解决方案：Spring Boot的嵌入式服务器</h5><p>Spring Boot 彻底颠覆了这种模式。它的核心思想是：<strong>“应用自带服务器，而不是将应用部署到服务器”</strong>。</p>
<ul>
<li><strong>核心定义</strong>：嵌入式Web服务器意味着 <strong>Servlet容器（如Tomcat）不再是一个需要外部安装的独立软件，而是作为一个普通的库（JAR包）被直接包含在你的应用程序中</strong>。</li>
<li><strong>工作原理</strong>：<ol>
<li>当你引入 <code>spring-boot-starter-web</code> 这个起步依赖时，它会通过传递性依赖，自动将 <code>spring-boot-starter-tomcat</code> 添加到你的项目中。</li>
<li><code>spring-boot-starter-tomcat</code> 依赖了 <code>tomcat-embed-core.jar</code>, <code>tomcat-embed-el.jar</code> 等Tomcat的核心库文件。</li>
<li>当你的Spring Boot应用通过 <code>main</code> 方法启动时，Spring Boot的自动配置机制会检测到类路径下存在Tomcat的JAR包。</li>
<li><code>ServletWebServerFactoryAutoConfiguration</code> 这个自动配置类就会生效，它会在<strong>应用程序内部</strong>，通过<strong>Java代码</strong>来<strong>启动一个Tomcat实例</strong>，并完成所有必要的配置（如设置端口、上下文路径等）。</li>
<li>最后，Spring Boot会将自己的核心组件 <code>DispatcherServlet</code> 注册到这个内嵌的Tomcat实例中。</li>
</ol>
</li>
</ul>
<p>整个过程对开发者是完全透明的。你所做的，仅仅是运行了一个普通的Java <code>main</code> 方法。</p>
<hr>
<h5 id="3-打包与运行方式的变革"><a href="#3-打包与运行方式的变革" class="headerlink" title="3. 打包与运行方式的变革"></a>3. 打包与运行方式的变革</h5><p>由于服务器被内嵌了，Spring Boot应用的打包和运行方式也发生了根本性的变化：</p>
<ul>
<li><p><strong>打包成可执行JAR (Executable JAR)</strong>：Spring Boot应用通常被打包成一个<strong>单一的、可执行的JAR文件</strong>。这个JAR文件包含了你所有的业务代码、依赖库，以及<strong>嵌入式服务器本身</strong>。</p>
</li>
<li><p><strong>简化运行</strong>：部署和运行这个应用变得异常简单，只需要一个Java环境即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只需要一行命令，应用就带着自己的Tomcat服务器启动了</span></span><br><span class="line">java -jar my-application.jar </span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="4-带来的核心优势-1"><a href="#4-带来的核心优势-1" class="headerlink" title="4. 带来的核心优势"></a>4. 带来的核心优势</h5><ol>
<li><strong>环境无关，独立运行</strong>：<ul>
<li>应用是<strong>自包含的 (self-contained)</strong>，不再依赖任何外部的Web服务器。只要有JRE，就可以处处运行，彻底解决了环境不一致的问题。</li>
</ul>
</li>
<li><strong>部署极简，运维友好</strong>：<ul>
<li>部署过程从“打包-&gt;拷贝-&gt;启动外部服务器”简化为“上传单个JAR文件-&gt;执行<code>java -jar</code>命令”。</li>
<li>这对于自动化部署（CI&#x2F;CD）、容器化（Docker）和云原生环境极为友好。</li>
</ul>
</li>
<li><strong>开发体验佳</strong>：<ul>
<li>开发者可以直接在IDE中像运行普通Java程序一样启动和调试Web应用，无需配置和管理外部Tomcat，开发效率大大提升。</li>
</ul>
</li>
<li><strong>微服务架构的完美匹配</strong>：<ul>
<li>每个微服务都可以打包成一个独立的、轻量级的可执行JAR，易于管理、水平扩展和快速迭代。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="5-服务器的切换"><a href="#5-服务器的切换" class="headerlink" title="5. 服务器的切换"></a>5. 服务器的切换</h5><p>Spring Boot不仅默认集成了Tomcat，还支持Jetty和Undertow。切换服务器非常简单，只需在 <code>pom.xml</code> 中进行简单的修改。</p>
<p>例如，想从Tomcat切换到Undertow：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1. 排除默认的Tomcat依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2. 添加Undertow的Starter依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>只需这样修改，你的应用下次启动时，内部运行的就会是Undertow服务器，而你的业务代码无需任何改动。</p>
<hr>
<h5 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h5><p><strong>嵌入式Web服务器是Spring Boot实现快速开发和简化部署的“杀手锏”</strong>。它将复杂的服务器管理工作完全内化，让开发者可以像开发普通Java应用一样开发Web应用。这种“应用自带服务器”的模式，不仅极大地提升了开发和运维效率，也完美契-合了现代微服务和云原生架构的理念。</p>
<hr>
<h4 id="1-1-4-外部化配置"><a href="#1-1-4-外部化配置" class="headerlink" title="1.1.4 外部化配置"></a>1.1.4 外部化配置</h4><h5 id="1-问题背景：硬编码配置的弊端"><a href="#1-问题背景：硬编码配置的弊端" class="headerlink" title="1. 问题背景：硬编码配置的弊端"></a>1. 问题背景：硬编码配置的弊端</h5><p>在软件开发中，我们经常需要处理一些可变的配置信息，例如：</p>
<ul>
<li>数据库连接URL、用户名、密码</li>
<li>服务器端口号</li>
<li>第三方API的密钥</li>
<li>日志级别</li>
<li>功能开关（Feature Toggles）</li>
</ul>
<p>最糟糕的做法是将这些值<strong>硬编码 (Hard-coded)</strong> 在代码中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是非常糟糕的实践！</span></span><br><span class="line"><span class="type">int</span> <span class="variable">serverPort</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">dbUrl</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/prod_db&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>硬编码的弊端显而易见：</strong></p>
<ol>
<li><strong>缺乏灵活性</strong>：如果需要将应用从开发环境部署到生产环境，数据库地址变了，端口号也变了。这时你必须<strong>修改源代码，重新编译、打包和部署</strong>整个应用。这个过程既耗时又风险高。</li>
<li><strong>安全性差</strong>：将敏感信息（如密码、密钥）直接写入代码，意味着任何能看到源码的人都能看到这些机密。</li>
<li><strong>难以管理</strong>：配置散落在代码的各个角落，难以集中查看和修改。</li>
</ol>
<hr>
<h5 id="2-解决方案：Spring-Boot的外部化配置"><a href="#2-解决方案：Spring-Boot的外部化配置" class="headerlink" title="2. 解决方案：Spring Boot的外部化配置"></a>2. 解决方案：Spring Boot的外部化配置</h5><p>Spring Boot的外部化配置机制，就是为了解决这个问题。</p>
<ul>
<li><strong>核心定义</strong>：外部化配置允许你<strong>将配置信息从应用程序代码中分离出来，存储在外部文件中或环境中</strong>。这样，你可以在<strong>不修改任何代码</strong>的情况下，通过改变外部配置来影响和控制应用程序的行为。</li>
<li><strong>形象的比喻</strong>：<ul>
<li>你的应用程序就像一台<strong>精密的机器</strong>（比如一台数控机床）。</li>
<li><strong>硬编码</strong>就像是把机器的运行参数（切割速度、钻头尺寸）<strong>焊死</strong>在机器内部。每次想加工不同零件，都得把机器拆开重新焊接。</li>
<li><strong>外部化配置</strong>则像为这台机器提供了一个<strong>控制面板</strong>（<code>application.properties</code>文件）和<strong>外部接口</strong>（环境变量）。操作员（运维人员）只需在控制面板上调整参数，或者通过接口发送指令，就能让机器执行不同的任务，而无需触碰机器内部的任何线路。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-Spring-Boot支持的配置源"><a href="#3-Spring-Boot支持的配置源" class="headerlink" title="3. Spring Boot支持的配置源"></a>3. Spring Boot支持的配置源</h5><p>Spring Boot非常强大，它支持从多种不同的外部位置加载配置。这些配置源按<strong>优先级</strong>从高到低排列（高优先级的配置会覆盖低优先级的同名配置）：</p>
<ol>
<li><p><strong>命令行参数 (Command-Line Arguments)</strong></p>
<ul>
<li>在启动应用时通过命令行直接传入。</li>
<li>示例：<code>java -jar my-app.jar --server.port=9090</code></li>
<li><strong>优先级最高</strong>，常用于临时覆盖特定配置。</li>
</ul>
</li>
<li><p><strong>Java系统属性 ( <code>System.getProperties()</code> )</strong></p>
<ul>
<li>通过 <code>-D</code> 参数设置。</li>
<li>示例：<code>java -Dserver.port=9090 -jar my-app.jar</code></li>
</ul>
</li>
<li><p><strong>操作系统环境变量 (OS Environment Variables)</strong></p>
<ul>
<li>配置在操作系统级别的变量。</li>
<li>格式需要转换：<code>SERVER_PORT=9090</code> 会被自动映射为 <code>server.port</code>。</li>
</ul>
</li>
<li><p><strong>JAR包外部的 <code>application-{profile}.properties</code> 或 <code>application-{profile}.yml</code> 文件</strong></p>
<ul>
<li><p>与JAR包放在<strong>同一目录</strong>下的配置文件。</p>
</li>
<li><p>这是<strong>生产环境中最常用的覆盖方式</strong>。运维人员可以直接在服务器上创建或修改这个文件，而无需解压JAR包。</p>
</li>
<li><p>示例：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/opt/app/</span><br><span class="line">├── my-app.jar</span><br><span class="line">└── application.properties  &lt;-- 这个文件的优先级高于JAR包内部的</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>JAR包内部的 <code>application-{profile}.properties</code> 或 <code>application-{profile}.yml</code> 文件</strong></p>
<ul>
<li>打包在 <code>src/main/resources</code> 目录下的，针对不同环境（profile）的配置文件，如 <code>application-dev.properties</code>，<code>application-prod.properties</code>。</li>
</ul>
</li>
<li><p><strong>JAR包内部的 <code>application.properties</code> 或 <code>application.yml</code> 文件</strong></p>
<ul>
<li>打包在 <code>src/main/resources</code> 目录下的默认配置文件。通常存放一些通用的、默认的配置。</li>
<li><strong>优先级最低</strong>。</li>
</ul>
</li>
<li><p><strong><code>@PropertySource</code> 注解</strong></p>
<ul>
<li>可以在<code>@Configuration</code>类上通过此注解加载额外的自定义配置文件。</li>
</ul>
</li>
</ol>
<p><strong>优先级规则总结</strong>：<strong>离代码越“远”的配置，优先级越高</strong>。命令行（最远） &gt; 包外文件 &gt; 包内文件（最近）。这个设计哲学使得运维人员可以轻松地在外部覆盖掉开发者在代码包里设置的默认值。</p>
<hr>
<h5 id="4-如何在代码中使用配置"><a href="#4-如何在代码中使用配置" class="headerlink" title="4. 如何在代码中使用配置"></a>4. 如何在代码中使用配置</h5><p>Spring Boot提供了两种主要的方式来将这些外部配置注入到你的Bean中：</p>
<p><strong>A. <code>@Value</code> 注解</strong></p>
<ul>
<li><p>用于注入<strong>单个</strong>配置属性。</p>
</li>
<li><p>语法：<code>@Value(&quot;${property.name:defaultValue}&quot;)</code></p>
<ul>
<li><code>${...}</code> 是占位符语法。</li>
<li><code>:defaultValue</code> 是可选的，当配置项不存在时，会使用这个默认值。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfigReader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;myapp.custom.greeting:Hello World&#125;&quot;)</span> <span class="comment">// 提供默认值</span></span><br><span class="line">    <span class="keyword">private</span> String greetingMessage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Server Port: &quot;</span> + serverPort);</span><br><span class="line">        System.out.println(<span class="string">&quot;Greeting: &quot;</span> + greetingMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>B. <code>@ConfigurationProperties</code> 注解（更推荐）</strong></p>
<ul>
<li><p>用于将<strong>一组</strong>相关的配置属性<strong>批量</strong>、<strong>类型安全</strong>地绑定到一个Java对象（POJO）上。</p>
</li>
<li><p><strong>优势</strong>：</p>
<ol>
<li><strong>类型安全</strong>：如果配置文件中的值无法转换为目标类型（如把”abc”配给<code>int</code>类型），应用启动时会报错。</li>
<li><strong>结构化</strong>：将相关的配置组织在一个类中，代码更清晰。</li>
<li><strong>强大的IDE支持</strong>：IDE可以为<code>@ConfigurationProperties</code>类提供自动补全和元数据提示。</li>
</ol>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li><p><strong><code>application.properties</code></strong>:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">myapp.auth.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="attr">myapp.auth.password</span>=<span class="string">secret123</span></span><br><span class="line"><span class="attr">myapp.auth.timeout</span>=<span class="string">30s</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>属性绑定类 <code>AuthConfig.java</code></strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;myapp.auth&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Duration timeout; <span class="comment">// Spring Boot能自动转换 &quot;30s&quot; 为 Duration 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在其他地方使用</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AuthConfig authConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 直接使用 authConfig 对象的属性</span></span><br><span class="line">    System.out.println(authConfig.getUsername());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h5 id="5-总结-1"><a href="#5-总结-1" class="headerlink" title="5. 总结"></a>5. 总结</h5><p><strong>外部化配置是构建健壮、可维护、适应多环境部署的应用程序的基石</strong>。Spring Boot通过其<strong>分层的配置加载机制</strong>和便捷的<strong>属性注入方式（<code>@Value</code> 和 <code>@ConfigurationProperties</code>）</strong>，提供了一套极其强大和灵活的配置解决方案。这使得同一份应用程序代码，无需任何修改，就能通过外部配置的调整，无缝地在开发、测试、生产等不同环境中运行。</p>
<hr>
<h3 id="1-2-SpringBootApplication注解刨析"><a href="#1-2-SpringBootApplication注解刨析" class="headerlink" title="1.2 @SpringBootApplication注解刨析"></a>1.2 <code>@SpringBootApplication</code>注解刨析</h3><p><code>@SpringBootApplication</code> 是一个典型的 Spring <strong>复合注解 (Composite Annotation)</strong>。它由其他三个核心注解组合而成。目的是为了简化配置，让开发者只需一个注解就能开启 Spring Boot 的所有核心功能。</p>
<p>我们可以通过查看其源码来一探究竟：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="comment">// 核心在这里！下面三个注解才是它的真身</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    <span class="comment">// ... 注解的属性定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中我们可以清晰地看到，<code>@SpringBootApplication</code> 主要由以下三个注解构成：</p>
<ol>
<li><code>@SpringBootConfiguration</code></li>
<li><code>@EnableAutoConfiguration</code></li>
<li><code>@ComponentScan</code></li>
</ol>
<p>下面我们来逐一剖析这“三位一体”的真正含义。</p>
<hr>
<h4 id="1-2-1-SpringBootConfiguration"><a href="#1-2-1-SpringBootConfiguration" class="headerlink" title="1.2.1 @SpringBootConfiguration"></a>1.2.1 <code>@SpringBootConfiguration</code></h4><ul>
<li><p><strong>作用</strong>：声明当前类是一个 <strong>Spring Boot 的配置类</strong>。</p>
</li>
<li><p><strong>深层剖析</strong>：我们再次点进 <code>@SpringBootConfiguration</code> 的源码会发现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">// &lt;-- 核心在这里！</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它本质上就是 Spring 框架的 <strong><code>@Configuration</code></strong> 注解。</p>
</li>
<li><p><strong>意义</strong>：</p>
<ol>
<li><strong>语义化</strong>：它在语义上表明这是一个Spring Boot应用的主配置类，而不仅仅是一个普通的Spring配置类。</li>
<li><strong>Bean定义</strong>：被 <code>@Configuration</code> 标记的类，意味着我们可以在这个类中使用 <code>@Bean</code> 注解来手动定义和注册Bean到IoC容器中。</li>
<li><strong>单例保证</strong>：Spring 会为 <code>@Configuration</code> 类创建一个CGLIB代理，以确保通过方法调用获取Bean时能遵循其作用域（如单例）。</li>
</ol>
</li>
</ul>
<p><strong>一句话总结 <code>@SpringBootConfiguration</code></strong>：它就是 <code>@Configuration</code>，表明启动类本身也是一个IoC容器的配置源。</p>
<hr>
<h4 id="1-2-2-EnableAutoConfiguration"><a href="#1-2-2-EnableAutoConfiguration" class="headerlink" title="1.2.2 @EnableAutoConfiguration"></a>1.2.2 <code>@EnableAutoConfiguration</code></h4><ul>
<li><strong>作用</strong>：这是 <strong>开启自动配置功能的主开关</strong>。</li>
<li><strong>深层剖析</strong>：它通过 <code>@Import(AutoConfigurationImportSelector.class)</code> 来实现其核心功能。<ul>
<li><code>AutoConfigurationImportSelector</code> 这个类会去扫描所有引入的JAR包中 <code>META-INF/spring.factories</code> 文件。</li>
<li>它会找到 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 这个键所对应的所有自动配置类（如 <code>DataSourceAutoConfiguration</code>, <code>WebMvcAutoConfiguration</code> 等）。</li>
<li>然后，它会将这个庞大的配置类列表加载到Spring IoC容器中。</li>
<li>最后，每个自动配置类会根据自身的 <code>@ConditionalOn...</code> 条件来判断自己是否应该生效。</li>
</ul>
</li>
</ul>
<p><strong>一句话总结 <code>@EnableAutoConfiguration</code></strong>：它负责启动Spring Boot的自动配置引擎，让Spring Boot根据类路径的依赖来智能地配置应用。</p>
<hr>
<h4 id="3-ComponentScan"><a href="#3-ComponentScan" class="headerlink" title="3. @ComponentScan"></a><strong>3. <code>@ComponentScan</code></strong></h4><ul>
<li><strong>作用</strong>：开启 <strong>组件扫描</strong>，自动发现并注册被特定注解（如<code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code>）标记的类为Bean。</li>
<li><strong>深层剖析</strong>：<ul>
<li><strong>默认扫描范围</strong>：<code>@SpringBootApplication</code> 中的 <code>@ComponentScan</code> <strong>没有指定 <code>basePackages</code> 属性</strong>。在这种情况下，它的默认扫描范围是<strong>当前启动类所在的包及其所有子包</strong>。</li>
<li><strong>最佳实践</strong>：正是因为这个默认行为，官方强烈建议将启动类放在一个<strong>根包 (root package)</strong> 下，例如 <code>com.example.myapp</code>。这样，你所有的业务代码（如 <code>com.example.myapp.controller</code>, <code>com.example.myapp.service</code>）都会自然而然地被扫描到。</li>
</ul>
</li>
</ul>
<p><strong>目录结构示例 (推荐):</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">com</span><br><span class="line">└── example</span><br><span class="line">    └── myapp</span><br><span class="line">        ├── Application.java          &lt;-- 启动类在这里</span><br><span class="line">        ├── controller</span><br><span class="line">        │   └── UserController.java</span><br><span class="line">        ├── service</span><br><span class="line">        │   └── UserServiceImpl.java</span><br><span class="line">        └── repository</span><br><span class="line">            └── UserRepository.java</span><br></pre></td></tr></table></figure>

<p>在这个结构中，<code>Application.java</code> 上的 <code>@ComponentScan</code> 会自动扫描到 <code>controller</code>, <code>service</code>, <code>repository</code> 包下的所有组件。</p>
<p><strong>一句话总结 <code>@ComponentScan</code></strong>：它负责扫描并注册我们自己编写的业务类Bean。</p>
<hr>
<h4 id="1-2-3-总结"><a href="#1-2-3-总结" class="headerlink" title="1.2.3 总结"></a>1.2.3 总结</h4><p><code>@SpringBootApplication</code> 这个看似简单的注解，实际上协同完成了Spring Boot应用初始化的三大核心任务：</p>
<table>
<thead>
<tr>
<th align="left">注解</th>
<th align="left">扮演的角色</th>
<th align="left">职责</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>@SpringBootConfiguration</code></strong></td>
<td align="left"><strong>配置源 (Configuration Source)</strong></td>
<td align="left">将启动类自身标识为一个配置类，允许在其中定义 <code>@Bean</code>。</td>
</tr>
<tr>
<td align="left"><strong><code>@EnableAutoConfiguration</code></strong></td>
<td align="left"><strong>配置引擎 (Engine)</strong></td>
<td align="left">开启自动配置，让Spring Boot根据依赖智能地“猜测”并配置所需的Bean。</td>
</tr>
<tr>
<td align="left"><strong><code>@ComponentScan</code></strong></td>
<td align="left"><strong>扫描器 (Scanner)</strong></td>
<td align="left">扫描并注册我们自己编写的 <code>@Component</code> 等业务Bean。</td>
</tr>
</tbody></table>
<p>这三个注解共同作用，使得Spring Boot应用能够：</p>
<ol>
<li><strong>自我配置</strong>（通过 <code>@EnableAutoConfiguration</code>）。</li>
<li><strong>发现我们自己的组件</strong>（通过 <code>@ComponentScan</code>）。</li>
<li><strong>允许我们进行额外的自定义配置</strong>（通过 <code>@SpringBootConfiguration</code> 和 <code>@Bean</code>）。</li>
</ol>
<p>最终，它们将所有自动配置的Bean和我们自己定义的Bean汇集到同一个Spring IoC容器中，构建出一个功能完备的应用程序。</p>
<hr>
<h4 id="1-2-4-自定义属性"><a href="#1-2-4-自定义属性" class="headerlink" title="1.2.4 自定义属性"></a>1.2.4 自定义属性</h4><p><code>@SpringBootApplication</code> 注解还提供了一些属性，允许我们进行微调，最常用的是 <code>exclude</code>：</p>
<ul>
<li><p><strong><code>exclude</code></strong>：如果我们想禁用某个特定的自动配置，可以使用这个属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用数据源的自动配置</span></span><br><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这在某些特定场景下（比如你想完全手动控制数据源配置）非常有用。</p>
<hr>
<h3 id="1-3-SpringApplication-启动流程"><a href="#1-3-SpringApplication-启动流程" class="headerlink" title="1.3 SpringApplication 启动流程"></a>1.3 SpringApplication 启动流程</h3><p>我们所有Spring Boot应用的入口都是一个简单的 <code>main</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(MyApplication.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这行看似简单的 <code>SpringApplication.run()</code> 代码，背后隐藏了一个精心设计的、高度可扩展的启动流程。整个流程可以分为两大阶段：</p>
<ol>
<li><strong><code>SpringApplication</code> 实例的初始化阶段</strong></li>
<li><strong><code>run()</code> 方法的执行阶段</strong></li>
</ol>
<hr>
<h4 id="第一阶段：SpringApplication-实例初始化"><a href="#第一阶段：SpringApplication-实例初始化" class="headerlink" title="第一阶段：SpringApplication 实例初始化"></a><strong>第一阶段：<code>SpringApplication</code> 实例初始化</strong></h4><p>在 <code>run()</code> 方法被调用时，首先会创建一个 <code>SpringApplication</code> 的实例。这个构造函数的过程主要是为后续的启动做准备工作。</p>
<p><code>public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</code></p>
<p>这个构造函数主要做了以下几件重要的事情：</p>
<ol>
<li><strong>确定应用类型 (Deduce Web Application Type)</strong>:<ul>
<li>Spring Boot 会检查类路径中是否存在特定的类来判断当前应用的类型。</li>
<li>如果 classpath 中存在 <code>DispatcherHandler</code> 并且不存在 <code>DispatcherServlet</code>，则应用类型为 <strong><code>REACTIVE</code></strong> (响应式Web应用)。</li>
<li>如果两者都不存在，则应用类型为 <strong><code>NONE</code></strong> (非Web应用)。</li>
<li>否则，默认类型为 <strong><code>SERVLET</code></strong> (基于Servlet的传统Web应用)。</li>
<li>这个判断结果会决定后续是启动内嵌的Tomcat&#x2F;Jetty还是Netty，或者不启动任何Web服务器。</li>
</ul>
</li>
<li><strong>加载 <code>ApplicationContextInitializer</code>(应用上下文初始化器)</strong><ul>
<li>从 <code>META-INF/spring.factories</code> 文件中加载所有 <code>ApplicationContextInitializer</code> 的实现类。</li>
<li><code>ApplicationContextInitializer</code> 允许我们在 <code>ApplicationContext</code> <strong>刷新（refresh）之前</strong>，对其进行一些编程方式的初始化操作，是一个非常早期的扩展点。例如，注册额外的属性源。</li>
</ul>
</li>
<li><strong>加载 <code>ApplicationListener</code>(应用监听器)</strong><ul>
<li>同样从 <code>META-INF/spring.factories</code> 文件中加载所有 <code>ApplicationListener</code> 的实现类。</li>
<li><code>ApplicationListener</code> 用于监听 <code>SpringApplication</code> 在启动过程中发布的各种事件（如 <code>ApplicationStartingEvent</code>, <code>ApplicationReadyEvent</code> 等），从而在特定阶段执行自定义逻辑。</li>
<li>这些加载到的 Initializer 和 Listener 会被缓存到 <code>SpringApplication</code> 实例的成员变量中，等待后续在 <code>run</code> 阶段被调用。</li>
</ul>
</li>
<li><strong>确定主启动类 (Deduce Main Application Class)</strong>:<ul>
<li>通过分析当前的线程调用栈（<code>new RuntimeException().getStackTrace()</code>），推断出哪个类包含了 <code>main</code> 方法，并将其记录下来。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="第二阶段：run-方法执行流程-核心"><a href="#第二阶段：run-方法执行流程-核心" class="headerlink" title="第二阶段：run() 方法执行流程 (核心)"></a><strong>第二阶段：<code>run()</code> 方法执行流程 (核心)</strong></h4><p><code>run()</code> 方法是整个启动过程的核心，它编排了所有步骤，最终返回一个完全配置好的 <code>ApplicationContext</code>。</p>
<p>我们可以将其核心步骤概括为以下几点：</p>
<p><strong>Step 1: 创建并启动 <code>StopWatch</code></strong></p>
<ul>
<li>Spring Boot 使用 <code>StopWatch</code> 来记录整个启动过程各个阶段的耗时，方便开发者进行性能分析。</li>
</ul>
<p><strong>Step 2: 准备 <code>SpringApplicationRunListeners</code></strong></p>
<ul>
<li>这是一个关键的事件发布机制，它允许我们在启动过程的各个生命周期节点发布事件。</li>
<li>首先从<code>spring.factories</code>，加载所有 <code>SpringApplicationRunListener</code> 的实现类（默认是 <code>EventPublishingRunListener</code>）。</li>
<li><code>EventPublishingRunListener</code> 的作用就是将 Spring Boot 内部事件转化为标准的 Spring <code>ApplicationEvent</code>，并广播给所有在第一阶段注册的 <code>ApplicationListener</code>。</li>
<li>调用所有 <code>RunListener</code> 的 <code>starting()</code> 方法，标志着启动流程正式开始，<strong>发布 <code>ApplicationStartingEvent</code> 事件</strong>（但环境还未准备好）。</li>
</ul>
<p><strong>Step 3: 准备环境 (<code>Environment</code>)</strong></p>
<ul>
<li>根据之前推断的应用类型，创建一个合适的 <code>Environment</code> 对象（例如，<code>StandardServletEnvironment</code>）。</li>
<li><strong>配置加载</strong>：<code>Environment</code> 负责管理应用的配置信息。它会加载和合并来自各种属性源（PropertySource）的配置，包括：<ol>
<li>命令行参数 (<code>--server.port=9090</code>)。</li>
<li>JVM 系统属性 (<code>-D...</code>)。</li>
<li>操作系统环境变量。</li>
<li><code>application-{profile}.properties</code> 或 <code>.yml</code> 文件。</li>
<li><code>application.properties</code> 或 <code>.yml</code> 文件。</li>
<li><code>@PropertySource</code> 注解指定的配置文件。</li>
<li>默认属性。<br>（注意：优先级从上到下依次降低）</li>
</ol>
</li>
<li><strong>后处理</strong>：调用从 <code>spring.factories</code> 中加载的 <code>EnvironmentPostProcessor</code>，允许对 <code>Environment</code> 进行进一步的编程化修改。</li>
<li>将准备好的 <code>Environment</code> 绑定到 <code>SpringApplication</code> 实例。</li>
<li>调用 <code>RunListener</code> 的 <code>environmentPrepared()</code> 方法，并发布 <strong><code>ApplicationEnvironmentPreparedEvent</code></strong> 事件，通知监听者环境已经准备就绪，可以进行一些基于环境的调整了。</li>
</ul>
<p><strong>Step 4: 打印 Banner</strong></p>
<ul>
<li>读取 classpath 下的 <code>banner.txt</code> 文件（如果存在），并将 Spring Boot 的横幅打印到控制台。可以通过 <code>spring.main.banner-mode</code> 配置来控制其行为（<code>console</code>, <code>log</code>, <code>off</code>）。</li>
</ul>
<p><strong>Step 5: 创建 <code>ApplicationContext</code> (应用上下文)</strong></p>
<ul>
<li>根据第一阶段推断出的<strong>应用类型</strong>（<code>SERVLET</code>, <code>REACTIVE</code>, <code>NONE</code>），创建对应的 <code>ApplicationContext</code> 实例。<ul>
<li>Web应用 (<code>SERVLET</code>): 创建 <code>AnnotationConfigServletWebServerApplicationContext</code>。</li>
<li>响应式Web应用 (<code>REACTIVE</code>): 创建 <code>AnnotationConfigReactiveWebServerApplicationContext</code>。</li>
<li>非Web应用 (<code>NONE</code>): 创建 <code>AnnotationConfigApplicationContext</code>。</li>
</ul>
</li>
</ul>
<p><strong>Step 6: <code>prepareContext</code> - 上下文预处理</strong></p>
<p>在刷新上下文之前，进行一系列准备工作：</p>
<ul>
<li>将前面创建好的 <code>Environment</code> 设置到 <code>ApplicationContext</code> 中。</li>
<li>调用所有在第一阶段加载的 <strong><code>ApplicationContextInitializer</code></strong> 的 <code>initialize</code> 方法，对上下文进行定制化处理。</li>
<li>调用 <code>RunListener</code> 的 <code>contextPrepared()</code> 方法，并发布 <strong><code>ApplicationContextInitializedEvent</code></strong> 事件。</li>
<li>将主启动类（如 <code>MyApplication.class</code>）加载到 <code>ApplicationContext</code> 中，这是配置的入口点。</li>
<li>调用 <code>RunListener</code> 的 <code>contextLoaded()</code> 方法，并发布 <strong><code>ApplicationPreparedEvent</code></strong> 事件。</li>
</ul>
<p><strong>Step 7: <code>refreshContext</code> - 刷新上下文</strong></p>
<ul>
<li>这是整个启动流程<strong>最核心、最耗时</strong>的一步。它会调用 <code>ApplicationContext.refresh()</code> 方法。</li>
<li><strong><code>prepareRefresh()</code></strong>: 准备刷新，设置上下文状态。</li>
<li><strong><code>obtainFreshBeanFactory()</code></strong>: 创建 <code>DefaultListableBeanFactory</code>，也就是 Bean 工厂，用于管理所有的 Bean 定义和实例。</li>
<li><strong><code>prepareBeanFactory()</code></strong>: 对 Bean 工厂进行配置，比如设置类加载器、添加默认的 <code>BeanPostProcessor</code> 等。</li>
<li><strong><code>postProcessBeanFactory()</code></strong>: 子类扩展点。对于 Web 应用，这里会添加与 Web 相关的 <code>BeanPostProcessor</code>。</li>
<li><strong><code>invokeBeanFactoryPostProcessors()</code></strong>: <strong>【关键】</strong> 调用所有注册的 <code>BeanFactoryPostProcessor</code>。这是自动配置的核心，<code>@Configuration</code> 注解的解析、<code>@ComponentScan</code> 的扫描、<code>@Bean</code> 方法的定义、<code>@EnableAutoConfiguration</code> 的触发都在这一步完成。Spring Boot 的自动配置类就是通过这个机制生效的。</li>
<li><strong><code>registerBeanPostProcessors()</code></strong>: <strong>【关键】</strong> 注册所有 <code>BeanPostProcessor</code>。这些处理器会在 Bean 初始化前、后对 Bean 实例进行干预，例如处理 <code>@Autowired</code> 依赖注入、AOP 代理的创建等。</li>
<li><strong><code>initMessageSource()</code></strong>: 初始化国际化消息源。</li>
<li><strong><code>initApplicationEventMulticaster()</code></strong>: 初始化事件广播器。</li>
<li><strong><code>onRefresh()</code></strong>: <strong>【关键】</strong> 子类扩展点。对于 Web 应用 (<code>ServletWebServerApplicationContext</code>)，这一步会 <strong>创建并启动内嵌的 Web 服务器</strong> (如 Tomcat, Jetty)。</li>
<li><strong><code>registerListeners()</code></strong>: 注册 <code>ApplicationListener</code> 监听器。</li>
<li><strong><code>finishBeanFactoryInitialization()</code></strong>: <strong>【关键】</strong> 实例化所有剩余的非懒加载单例 Bean。此时，IoC 容器中定义的绝大部分 Bean 都会被创建和初始化，依赖注入也在这里完成。</li>
<li><strong><code>finishRefresh()</code></strong>: 完成刷新过程，发布 <strong><code>ContextRefreshedEvent</code></strong> 事件，标志着 IoC 容器已经准备就绪。</li>
</ul>
<p><strong>Step 8: <code>afterRefresh</code> 回调</strong></p>
<ul>
<li>提供一个空的模板方法，留给子类扩展。</li>
</ul>
<p><strong>Step 9: 发布 <code>ApplicationStartedEvent</code> 事件</strong></p>
<ul>
<li>调用 <code>RunListener</code> 的 <code>started()</code> 方法，并发布 <strong><code>ApplicationStartedEvent</code></strong> 事件。</li>
</ul>
<p><strong>Step 10: 调用 <code>ApplicationRunner</code> 和 <code>CommandLineRunner</code></strong></p>
<ul>
<li>从 <code>ApplicationContext</code> 中获取所有 <code>ApplicationRunner</code> 和 <code>CommandLineRunner</code> 类型的 Bean。</li>
<li>对它们进行排序（<code>@Order</code>）。</li>
<li>依次调用它们的 <code>run</code> 方法。这通常用于执行应用启动后需要立即运行的一些自定义任务（如加载初始数据、启动定时任务等）。</li>
</ul>
<p><strong>Step 11: 发布 <code>ApplicationReadyEvent</code> 事件</strong></p>
<ul>
<li>调用 <code>RunListener</code> 的 <code>ready()</code> 方法 (在 Spring Boot 2.5 及以后版本中，原 <code>running</code> 方法被重命名为 <code>ready</code>)，并发布 <strong><code>ApplicationReadyEvent</code></strong> 事件。这标志着应用已完全启动，并准备好接收请求。</li>
<li>如果启动过程中出现异常，则会发布 <code>ApplicationFailedEvent</code> 事件。</li>
</ul>
<p><strong>Step 12: 返回 <code>ApplicationContext</code></strong></p>
<ul>
<li><code>run()</code> 方法执行结束，返回创建并刷新好的 <code>ApplicationContext</code> 实例。</li>
</ul>
<hr>
<h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><pre><code class="highlight mermaid">flowchart TD
    subgraph 第一阶段: SpringApplication 构造函数
        direction TB
        A_Start(new SpringApplication) --&gt; A1[&quot;1.确定Web应用类型&lt;br&gt;(SERVLET/REACTIVE/NONE)&quot;];
        A1 --&gt; A2[&quot;2.从 spring.factories 加载&lt;br/&gt;ApplicationContextInitializer&quot;];
        A2 --&gt; A3[&quot;3.从 spring.factories 加载&lt;br/&gt;ApplicationListener&quot;];
        A3 --&gt; A4[&quot;4.推断主启动类 (main class)&quot;];
    end

    subgraph &quot;第二阶段: run() 方法核心流程&quot;
        direction TB
        B_Run(&quot;SpringApplication.run()&quot;) --&gt; B1[Step 1: 启动StopWatch计时];
        B1 --&gt; B2&#123;&quot;Step 2: 准备 SpringApplicationRunListeners&quot;&#125;;
        B2 --&gt; B2_Event(发布 ApplicationStartingEvent):::event;
        
        B2_Event --&gt; B3[&quot;Step 3: 准备 Environment&lt;br/&gt;加载各级配置文件(yml/properties等)&quot;];
        B3 --&gt; B3_Event(发布 ApplicationEnvironmentPreparedEvent):::event;

        B3_Event --&gt; B4[Step 4: 打印 Banner];
        B4 --&gt; B5&#123;Step 5: 根据应用类型&lt;br&gt;创建 ApplicationContext&#125;;
        
        subgraph &quot;Step 6: prepareContext - 上下文预处理&quot;
            B5 -- SERVLET/REACTIVE/NONE --&gt; B6_1[设置Environment];
            B6_1 --&gt; B6_2[调用所有 ApplicationContextInitializer];
            B6_2 --&gt; B6_2_Event(发布 ApplicationContextInitializedEvent):::event;
            B6_2_Event --&gt; B6_3[加载主启动类等配置源];
            B6_3 --&gt; B6_3_Event(发布 ApplicationPreparedEvent):::event;
        end
        
        subgraph &quot;Step 7: refreshContext - 刷新上下文 (最核心)&quot;
            B6_3_Event --&gt; B7_1[&quot;invokeBeanFactoryPostProcessors&lt;br/&gt;&lt;b&gt;@EnableAutoConfiguration 生效&lt;/b&gt;&quot;]:::critical;
            B7_1 --&gt; B7_2[&quot;registerBeanPostProcessors&lt;br/&gt;&lt;b&gt;处理 @Autowired, AOP代理&lt;/b&gt;&quot;]:::critical;
            B7_2 --&gt; B7_3[&quot;onRefresh&lt;br/&gt;&lt;b&gt;启动内嵌Web服务器 (Tomcat)&lt;/b&gt;&quot;]:::critical;
            B7_3 --&gt; B7_4[&quot;finishBeanFactoryInitialization&lt;br/&gt;&lt;b&gt;实例化所有单例Bean&lt;/b&gt;&quot;]:::critical;
            B7_4 --&gt; B7_4_Event(发布 ContextRefreshedEvent):::event;
        end

        B7_4_Event --&gt; B8[Step 8: afterRefresh 回调];
        B8 --&gt; B9_Event(Step 9: 发布 ApplicationStartedEvent):::event;
        
        B9_Event --&gt; B10[&quot;Step 10: 调用所有&lt;br/&gt;ApplicationRunner 和 CommandLineRunner&quot;];
        B10 --&gt; B11_Event(Step 11: 发布 ApplicationReadyEvent&lt;br/&gt;&lt;b&gt;应用启动完成，准备接收请求&lt;/b&gt;):::event;
        
        B11_Event --&gt; B12_End(&quot;run()方法结束&lt;br&gt;返回ConfigurableApplicationContext&quot;);
        
        B_Run -- 启动异常 --&gt; B_Failed_Event(发布 ApplicationFailedEvent):::event_fail;
    end
    
    A4 --&gt; B_Run;

    %% 样式定义
    classDef event fill:#d4edda,stroke:#155724,stroke-width:2px;
    classDef event_fail fill:#f8d7da,stroke:#721c24,stroke-width:2px;
    classDef critical fill:#fff3cd,stroke:#856404,stroke-width:2px,font-weight:bold;</code></pre>

<hr>
<h2 id="2-配置文件详解"><a href="#2-配置文件详解" class="headerlink" title="2. 配置文件详解"></a>2. 配置文件详解</h2><h3 id="2-1-application-properties-vs-application-yml"><a href="#2-1-application-properties-vs-application-yml" class="headerlink" title="2.1 application.properties vs application.yml"></a>2.1 <code>application.properties</code> vs <code>application.yml</code></h3><p>Spring Boot 允许开发者使用两种主流的格式来编写配置文件：传统的 <code>.properties</code> 文件和更现代的 <code>.yml</code> (或 <code>.yaml</code>) 文件。两者在功能上是等价的，都可以用来定义应用的配置属性，但它们在<strong>语法、可读性和结构化数据表达</strong>方面存在显著差异。</p>
<p>当项目中同时存在 <code>application.properties</code> 和 <code>application.yml</code> 文件时，<strong><code>.properties</code> 文件的优先级更高</strong>。</p>
<hr>
<h4 id="2-1-1-application-properties"><a href="#2-1-1-application-properties" class="headerlink" title="2.1.1 application.properties"></a>2.1.1 <code>application.properties</code></h4><p>这是Java世界中最传统、最经典的配置文件格式，继承自 <code>java.util.Properties</code> 类。</p>
<ul>
<li><p><strong>语法</strong>：<strong>键值对 (Key-Value) 格式</strong>。</p>
<ul>
<li>使用 <code>=</code> 或 <code>:</code> 作为键和值的分隔符。</li>
<li>键（Key）通常采用点分（dot-separated）命名法来表示层级关系，例如 <code>spring.datasource.url</code>。</li>
</ul>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>语法简单、直观，对于扁平化的、非复杂的配置非常友好。</li>
<li>所有的配置项都是独立的行，结构一目了然。</li>
<li>原生被Java支持，无需引入额外的依赖。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器配置</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="attr">server.servlet.context-path</span>=<span class="string">/myapp</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 数据库配置 (层级关系通过前缀来体现)</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/testdb</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 自定义配置</span></span><br><span class="line"><span class="attr">myapp.author</span>=<span class="string">Alice</span></span><br><span class="line"><span class="attr">myapp.version</span>=<span class="string">1.0.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><p><strong>冗余</strong>：当配置具有深层级的结构时，每一行都需要重复写很长的前缀（如 <code>spring.datasource.</code>），显得非常冗余。</p>
</li>
<li><p><strong>结构不直观</strong>：虽然通过前缀表示了层级，但视觉上仍然是扁平的，无法一眼看出配置项之间的父子关系。</p>
</li>
<li><p><strong>对复杂数据结构支持不佳</strong>：配置一个列表（List）或Map相对繁琐。</p>
<ul>
<li><p><strong>配置列表 (List&#x2F;Array)</strong>:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">myapp.servers[0]</span>=<span class="string">dev.example.com</span></span><br><span class="line"><span class="attr">myapp.servers[1]</span>=<span class="string">qa.example.com</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置Map</strong>:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">myapp.users.alice.name</span>=<span class="string">Alice</span></span><br><span class="line"><span class="attr">myapp.users.alice.age</span>=<span class="string">30</span></span><br><span class="line"><span class="attr">myapp.users.bob.name</span>=<span class="string">Bob</span></span><br><span class="line"><span class="attr">myapp.users.bob.age</span>=<span class="string">25</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-2-application-yml-yaml"><a href="#2-1-2-application-yml-yaml" class="headerlink" title="2.1.2 application.yml (.yaml)"></a>2.1.2 <code>application.yml</code> (<code>.yaml</code>)</h4><p>YAML (YAML Ain’t Markup Language) 是一种以<strong>数据为中心</strong>的标记语言，被设计用来提供极高的人类可读性。Spring Boot通过集成 <code>SnakeYAML</code> 库来支持YAML格式。</p>
<ul>
<li><p><strong>语法</strong>：<strong>树状结构 (Tree Structure)</strong>。</p>
<ul>
<li>使用 <strong>缩进 (indentation)</strong> 来表示层级关系。<strong>注意：缩进必须使用空格，不能使用Tab键，且同一层级的缩进空格数必须一致</strong>。</li>
<li>使用 <code>:</code> 后面跟一个空格来分隔键和值。</li>
<li>使用 <code>-</code> (短横线) 后跟一个空格来表示列表（数组）中的一个元素。</li>
</ul>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li><strong>简洁、无冗余</strong>：共享相同前缀的配置项被自然地组织在一起，无需重复书写。</li>
<li><strong>结构清晰</strong>：层级关系通过缩进一目了然，非常适合表达复杂的、结构化的配置数据。</li>
<li><strong>可读性极高</strong>：更接近自然语言的表达方式。</li>
</ul>
</li>
<li><p><strong>示例 (与上面的 <code>.properties</code> 完全等价)</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务器配置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/myapp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库配置 (层级关系通过缩进体现)</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/testdb</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义配置</span></span><br><span class="line"><span class="attr">myapp:</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">Alice</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对复杂数据结构的支持非常优雅</strong>：</p>
<ul>
<li><p><strong>配置列表 (List&#x2F;Array)</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">myapp:</span></span><br><span class="line">  <span class="attr">servers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">dev.example.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">qa.example.com</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置Map</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">myapp:</span></span><br><span class="line">  <span class="attr">users:</span></span><br><span class="line">    <span class="attr">alice:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">Alice</span></span><br><span class="line">      <span class="attr">age:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">bob:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">Bob</span></span><br><span class="line">      <span class="attr">age:</span> <span class="number">25</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置对象列表 (List of Objects)</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">myapp:</span></span><br><span class="line">  <span class="attr">employees:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Carol</span></span><br><span class="line">      <span class="attr">email:</span> <span class="string">carol@example.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">David</span></span><br><span class="line">      <span class="attr">email:</span> <span class="string">david@example.com</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-1-3-对比与总结"><a href="#2-1-3-对比与总结" class="headerlink" title="2.1.3 对比与总结"></a>2.1.3 对比与总结</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>application.properties</code></th>
<th align="left"><code>application.yml</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>语法</strong></td>
<td align="left"><strong>键值对</strong>，使用 <code>=</code> 或 <code>:</code> 分隔</td>
<td align="left"><strong>树状&#x2F;层级结构</strong>，使用<strong>空格缩进</strong>表示层级</td>
</tr>
<tr>
<td align="left"><strong>结构</strong></td>
<td align="left"><strong>扁平化</strong>，通过点分前缀模拟层级</td>
<td align="left"><strong>结构化</strong>，层级关系一目了然</td>
</tr>
<tr>
<td align="left"><strong>可读性</strong></td>
<td align="left">较好，但层级深时较差</td>
<td align="left"><strong>极高</strong>，更接近自然语言</td>
</tr>
<tr>
<td align="left"><strong>冗余度</strong></td>
<td align="left"><strong>高</strong>，需要重复书写长前缀</td>
<td align="left"><strong>低</strong>，共享前缀</td>
</tr>
<tr>
<td align="left"><strong>复杂数据</strong></td>
<td align="left">支持，但语法相对繁琐 (如 <code>list[0]</code>)</td>
<td align="left"><strong>非常优雅</strong>，使用 <code>-</code> 表示列表，天然支持嵌套对象</td>
</tr>
<tr>
<td align="left"><strong>注意事项</strong></td>
<td align="left">字符需要转义</td>
<td align="left"><strong>缩进必须使用空格，不能用Tab</strong>。语法对格式要求严格。</td>
</tr>
<tr>
<td align="left"><strong>优先级</strong></td>
<td align="left"><strong>高</strong> (当两者共存时)</td>
<td align="left"><strong>低</strong> (当两者共存时)</td>
</tr>
</tbody></table>
<p><strong>如何选择？</strong></p>
<ul>
<li><strong>对于新项目和追求高可读性的团队，强烈推荐使用 <code>application.yml</code></strong>。它的结构化特性在管理复杂的微服务配置时优势巨大。</li>
<li><strong>对于配置非常简单、扁平化的项目，或者习惯了传统 <code>.properties</code> 格式的开发者</strong>，使用 <code>.properties</code> 也是完全可以的，它的简单直接也是一种优点。</li>
<li>在一些<strong>自动化脚本或工具</strong>中，逐行解析 <code>.properties</code> 文件可能比解析复杂的YAML树更容易。</li>
</ul>
<p>在现代Spring Boot开发中，<code>application.yml</code> 已经成为事实上的主流选择，因为它更好地适应了现代应用配置日益增长的复杂性。</p>
<hr>
<h3 id="2-2-多环境配置-Profiles-application-dev-yml-application-prod-yml"><a href="#2-2-多环境配置-Profiles-application-dev-yml-application-prod-yml" class="headerlink" title="2.2 多环境配置 (Profiles) - application-dev.yml, application-prod.yml"></a>2.2 多环境配置 (Profiles) - <code>application-dev.yml</code>, <code>application-prod.yml</code></h3><h4 id="2-2-1-为什么需要多环境配置？"><a href="#2-2-1-为什么需要多环境配置？" class="headerlink" title="2.2.1 为什么需要多环境配置？"></a>2.2.1 为什么需要多环境配置？</h4><p>在软件开发的完整生命周期中，一个应用程序通常会在多个不同的环境中运行。每个环境的配置项（尤其是数据库连接、服务器地址、第三方服务密钥等）都大相径庭。</p>
<p>典型的环境包括：</p>
<ul>
<li><strong>开发环境 (Development - <code>dev</code>)</strong>:<ul>
<li><strong>用途</strong>: 开发者本地开发和调试。</li>
<li><strong>配置特点</strong>:<ul>
<li>数据库通常是本地的MySQL、H2内存数据库或测试库。</li>
<li>日志级别通常设为 <code>DEBUG</code> 以便查看详细信息。</li>
<li>可能会开启热部署、禁用缓存等便于开发的功能。</li>
<li>服务器端口可能使用默认的8080。</li>
</ul>
</li>
</ul>
</li>
<li><strong>测试环境 (Testing - <code>test</code> &#x2F; <code>qa</code>)</strong>:<ul>
<li><strong>用途</strong>: 测试团队进行功能测试、集成测试和回归测试。</li>
<li><strong>配置特点</strong>:<ul>
<li>连接到专门的测试数据库，里面的数据可以随意修改。</li>
<li>第三方服务（如支付、短信）可能连接到沙箱或模拟（mock）环境。</li>
<li>配置与生产环境尽量接近，但数据是隔离的。</li>
</ul>
</li>
</ul>
</li>
<li><strong>生产环境 (Production - <code>prod</code>)</strong>:<ul>
<li><strong>用途</strong>: 最终面向用户的线上运行环境。</li>
<li><strong>配置特点</strong>:<ul>
<li>连接到生产环境的数据库，数据真实且重要。</li>
<li>日志级别通常设为 <code>INFO</code> 或 <code>WARN</code>，以减少性能开销。</li>
<li>性能优化相关的配置（如启用缓存、GZIP压缩）会被开启。</li>
<li>服务器端口通常是80或443（通过反向代理）。</li>
<li>安全性要求最高。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果将所有环境的配置都写在一起，通过注释来切换，那将是一场灾难：容易出错、难以管理、且有泄露生产环境敏感信息的风险。<strong>Profile机制</strong>就是Spring提供的一套优雅的解决方案，用于管理和切换不同环境的配置。</p>
<hr>
<h4 id="2-2-2-Profile的实现方式"><a href="#2-2-2-Profile的实现方式" class="headerlink" title="2.2.2 Profile的实现方式"></a>2.2.2 Profile的实现方式</h4><p>Spring Boot的Profile机制允许你将不同环境的配置隔离在不同的文件中，然后在应用启动时指定激活哪个环境（Profile），Spring Boot就会加载对应环境的专属配置。</p>
<h5 id="1-基于文件名的Profile配置-application-profile-yml"><a href="#1-基于文件名的Profile配置-application-profile-yml" class="headerlink" title="1. 基于文件名的Profile配置 (application-{profile}.yml)"></a>1. 基于文件名的Profile配置 (<code>application-{profile}.yml</code>)</h5><p>这是最常用、最直观的方式。</p>
<p><strong>步骤 1: 创建多个Profile配置文件</strong></p>
<p>在 <code>src/main/resources</code> 目录下，除了主配置文件 <code>application.yml</code>，我们再为每个环境创建一个专属的配置文件，遵循 <code>application-{profile名称}.yml</code> 的命名规范。</p>
<ul>
<li><p><code>application.yml</code> (主&#x2F;通用配置文件):</p>
<ul>
<li>存放所有环境<strong>共享</strong>的配置。</li>
<li>也可以在这里指定<strong>默认</strong>激活的Profile。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是所有环境都通用的配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">my-cool-app</span></span><br><span class="line">  <span class="comment"># 指定默认激活的环境为dev, 如果没有通过其他方式指定，则加载dev配置</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">encoding:</span></span><br><span class="line">      <span class="attr">charset:</span> <span class="string">UTF-8</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>application-dev.yml</code> (开发环境配置):</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/dev_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">password</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>application-prod.yml</code> (生产环境配置):</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># 实际生产中通常由Nginx等代理</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://prod-server:3306/prod_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">prod_user</span></span><br><span class="line">    <span class="comment"># 敏感信息通常通过环境变量或配置中心注入，而不是写在文件里</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;PROD_DB_PASSWORD&#125;</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">INFO</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>加载规则</strong>：</p>
<p>当一个Profile（如 <code>dev</code>）被激活时，Spring Boot会<strong>同时加载</strong> <code>application.yml</code> 和 <code>application-dev.yml</code>。如果两个文件中存在相同的配置项（如<code>server.port</code>），<strong>Profile专属配置文件 (<code>application-dev.yml</code>) 中的值会覆盖主配置文件 (<code>application.yml</code>) 中的值</strong>。</p>
<hr>
<h5 id="2-YAML文档分隔符方式"><a href="#2-YAML文档分隔符方式" class="headerlink" title="2. YAML文档分隔符方式"></a>2. YAML文档分隔符方式</h5><p>YAML语法允许在一个文件中使用 <code>---</code> 分隔符来定义多个文档。Spring Boot支持这种方式来管理多环境配置。</p>
<ul>
<li><p><strong><code>application.yml</code> (单一文件)</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个文档：通用配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">my-cool-app</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span> <span class="comment"># 这是一个默认端口</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 第二个文档：dev环境配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">dev</span> <span class="comment"># 指定这个文档在dev profile激活时生效</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/dev_db</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 第三个文档：prod环境配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">      <span class="attr">on-profile:</span> <span class="string">prod</span> <span class="comment"># 指定这个文档在prod profile激活时生效</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://prod-server:3306/prod_db</span></span><br></pre></td></tr></table></figure>

<p>这种方式将所有配置集中在一个文件里，优点是管理单个文件更方便，缺点是当配置非常多时，文件会变得很长，不如多文件方式清晰。</p>
</li>
</ul>
<hr>
<h4 id="2-2-3-如何激活指定的Profile？"><a href="#2-2-3-如何激活指定的Profile？" class="headerlink" title="2.2.3 如何激活指定的Profile？"></a>2.2.3 如何激活指定的Profile？</h4><p>激活Profile的方式有多种，同样遵循<strong>高优先级覆盖低优先级</strong>的原则。</p>
<ol>
<li><p><strong>在 <code>application.yml</code> 中指定 (优先级最低)</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>命令行参数 (推荐用于部署脚本)</strong></p>
<ul>
<li>这是<strong>最常用</strong>的在服务器上指定环境的方式。</li>
<li><code>java -jar my-app.jar --spring.profiles.active=prod</code></li>
</ul>
</li>
<li><p><strong>Java系统属性</strong></p>
<ul>
<li><code>java -Dspring.profiles.active=prod -jar my-app.jar</code></li>
</ul>
</li>
<li><p><strong>操作系统环境变量</strong></p>
<ul>
<li>在服务器上设置环境变量 <code>SPRING_PROFILES_ACTIVE=prod</code>，然后直接运行 <code>java -jar my-app.jar</code>。</li>
</ul>
</li>
<li><p><strong>在IDE中配置 (用于开发)</strong></p>
<ul>
<li>在IntelliJ IDEA或Eclipse的运行配置中，可以设置”Active profiles”为你想要的开发环境，如 <code>dev</code>。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="2-2-4-在Java代码中使用Profile-Profile-注解"><a href="#2-2-4-在Java代码中使用Profile-Profile-注解" class="headerlink" title="2.2.4 在Java代码中使用Profile (@Profile 注解)"></a>2.2.4 在Java代码中使用Profile (<code>@Profile</code> 注解)</h4><p>Profile不仅可以用来管理配置文件，还可以用来<strong>有条件地创建Bean</strong>。</p>
<p><code>@Profile</code> 注解可以标记在 <code>@Configuration</code> 类或 <code>@Bean</code> 方法上，表示只有当指定的Profile被激活时，这个配置类或Bean才会被创建。</p>
<p><strong>示例</strong>：我们希望在开发环境(<code>dev</code>)使用一个内存数据库(H2)，而在生产环境(<code>prod</code>)使用MySQL。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个Bean只有在dev profile激活时才会被创建</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">devDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ... 配置并返回一个连接到H2的DataSource</span></span><br><span class="line">        System.out.println(<span class="string">&quot;DEV DataSource is created.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">H2DataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个Bean只有在prod profile激活时才会被创建</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;prod&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">prodDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ... 配置并返回一个连接到MySQL的DataSource</span></span><br><span class="line">        System.out.println(<span class="string">&quot;PROD DataSource is created.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MySqlDataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// @Profile注解也支持复杂的逻辑表达式</span></span><br><span class="line">    <span class="comment">// @Profile(&quot;!prod&quot;) // 非prod环境</span></span><br><span class="line">    <span class="comment">// @Profile(&quot;dev | test&quot;) // dev或test环境</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，根据启动时激活的Profile，Spring容器中只会存在一个<code>DataSource</code>类型的Bean，实现了环境隔离。</p>
<hr>
<h3 id="2-3-配置加载优先级"><a href="#2-3-配置加载优先级" class="headerlink" title="2.3 配置加载优先级"></a>2.3 配置加载优先级</h3><p>Spring Boot 的外部化配置功能之所以强大，很大一部分原因在于它设计了一套<strong>层次分明、逻辑清晰的优先级加载机制</strong>。这意味着你可以把默认配置放在项目内部，然后在不同的部署环境中通过更高优先级的配置源来覆盖它，而无需修改任何代码。</p>
<p>Spring Boot 会从多个位置加载配置属性，这些位置形成了一个有序的优先级列表。<strong>排在列表越前面的（优先级越高），其配置项就会覆盖排在后面的同名配置项</strong>。</p>
<p>以下是官方文档中列出的一个精简但核心的优先级顺序列表，<strong>从高到低</strong>排列：</p>
<hr>
<h4 id="2-3-1-核心配置源优先级列表-由高到低"><a href="#2-3-1-核心配置源优先级列表-由高到低" class="headerlink" title="2.3.1 核心配置源优先级列表 (由高到低)"></a>2.3.1 核心配置源优先级列表 (由高到低)</h4><p><strong>1. 开发时工具 (Devtools)</strong></p>
<ul>
<li>如果你使用了 <code>spring-boot-devtools</code>，在 <code>~/.config/spring-boot/</code> 目录下的全局配置。这主要用于本地开发，优先级非常高。</li>
</ul>
<p><strong>2. 单元测试中的 <code>@TestPropertySource</code> 注解</strong></p>
<ul>
<li>在进行单元测试或集成测试时，通过 <code>@TestPropertySource</code> 注解指定的属性，优先级极高，专门用于覆盖测试环境的配置。</li>
</ul>
<p><strong>3. <code>@SpringBootTest</code> 的 <code>properties</code> 属性</strong></p>
<ul>
<li>同样在测试中，<code>@SpringBootTest(properties = &quot;my.prop=test&quot;)</code> 这种方式指定的属性。</li>
</ul>
<hr>
<p><strong>4. 命令行参数 (Command-line arguments)</strong></p>
<ul>
<li><strong>这是日常使用中优先级最高的配置方式</strong>。</li>
<li>通过 <code>java -jar my-app.jar --server.port=9000 --my.prop=value</code> 形式传入。</li>
<li><code>--</code> 后面的参数会被解析为配置属性。</li>
<li><strong>用途</strong>：在启动时临时覆盖某个特定配置，非常适合自动化部署脚本。</li>
</ul>
<p><strong>5. <code>SPRING_APPLICATION_JSON</code></strong></p>
<ul>
<li>来自于系统环境变量或Java系统属性的JSON字符串。</li>
<li>示例：<code>SPRING_APPLICATION_JSON=&#39;{&quot;server&quot;:{&quot;port&quot;:9000}}&#39;</code></li>
<li>允许以结构化的方式传入配置。</li>
</ul>
<p><strong>6. <code>ServletConfig</code> 和 <code>ServletContext</code> 的初始化参数</strong></p>
<ul>
<li>在传统的WAR包部署方式中，从 <code>web.xml</code> 或Servlet容器配置中获取。</li>
</ul>
<p><strong>7. JNDI属性 (<code>java:comp/env</code>)</strong></p>
<ul>
<li>从Java命名和目录接口中获取，常见于传统的应用服务器环境。</li>
</ul>
<hr>
<p><strong>8. Java系统属性 (<code>System.getProperties()</code>)</strong></p>
<ul>
<li>通过 <code>-D</code> 参数在启动JVM时传入。</li>
<li>示例：<code>java -Dserver.port=9000 -jar my-app.jar</code></li>
</ul>
<p><strong>9. 操作系统环境变量 (OS environment variables)</strong></p>
<ul>
<li>从操作系统的环境变量中读取。</li>
<li><strong>命名规则</strong>：Spring Boot 会将环境变量的格式进行转换。例如：<ul>
<li><code>SERVER_PORT</code> -&gt; <code>server.port</code></li>
<li><code>MY_APP_DATABASE_URL</code> -&gt; <code>my.app.database.url</code></li>
<li><code>MY_APP_SERVER_LIST[0]</code> -&gt; <code>my.app.server.list[0]</code></li>
</ul>
</li>
<li><strong>用途</strong>：在容器化环境（如Docker, Kubernetes）中，通过环境变量来注入配置是一种非常普遍和推荐的做法。</li>
</ul>
<hr>
<p><strong>10. <code>random.\*</code> 属性</strong></p>
<ul>
<li><code>RandomValuePropertySource</code> 提供的随机值，如 <code>random.int</code>, <code>random.uuid</code>。</li>
</ul>
<p><strong>11. JAR包外部的 <code>application-{profile}.properties</code> 或 <code>.yml</code> 文件</strong></p>
<ul>
<li><strong>这是生产环境中覆盖配置最常用的方式之一</strong>。</li>
<li>指的是与你的可执行JAR包<strong>放在同一个目录下</strong>的配置文件。</li>
<li>Spring Boot 会先加载profile特定的文件（如<code>application-prod.yml</code>），再加载通用的文件（<code>application.yml</code>）。</li>
</ul>
<p><strong>12. JAR包内部的 <code>application-{profile}.properties</code> 或 <code>.yml</code> 文件</strong></p>
<ul>
<li><p>打包在 <code>src/main/resources</code> 目录下的，针对不同环境（profile）的配置文件。</p>
</li>
<li><p>这是我们在开发时为不同环境预设配置的地方。</p>
</li>
</ul>
<p><strong>13. <code>@PropertySource</code> 注解</strong></p>
<ul>
<li><p>在 <code>@Configuration</code> 类上通过此注解显式加载的配置文件。</p>
</li>
<li><p><strong>注意</strong>：通过 <code>@PropertySource</code> 加载的配置优先级较低，无法覆盖<code>application.properties</code>中定义的属性。它更多是作为一种补充。</p>
</li>
</ul>
<p><strong>14. 默认属性 (<code>SpringApplication.setDefaultProperties</code>)</strong></p>
<ul>
<li><p>通过代码 <code>new SpringApplicationBuilder().properties(&quot;...&quot;).run()</code> 设置的默认属性。</p>
</li>
<li><p><strong>这是优先级最低的配置方式</strong>。</p>
</li>
</ul>
<hr>
<h4 id="2-3-2-示例"><a href="#2-3-2-示例" class="headerlink" title="2.3.2 示例"></a>2.3.2 示例</h4><p>假设你的项目中有以下配置：</p>
<ol>
<li><p><strong>JAR包内部 <code>src/main/resources/application.yml</code></strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># 默认端口</span></span><br><span class="line"><span class="attr">myapp:</span></span><br><span class="line">  <span class="attr">greeting:</span> <span class="string">&quot;Hello from default config&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>JAR包外部 <code>/opt/app/application.yml</code></strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运维人员在服务器上放了一个配置文件</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># 覆盖为80端口</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>操作系统环境变量</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置了一个环境变量</span></span><br><span class="line"><span class="built_in">export</span> MYAPP_GREETING=<span class="string">&quot;Hello from environment variable&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动命令</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在启动时，又通过命令行参数指定了端口</span></span><br><span class="line">java -jar my-app.jar --server.port=9090</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>那么，最终应用生效的配置是什么？</strong></p>
<ul>
<li><code>server.port</code>: <strong><code>9090</code></strong><ul>
<li><strong>分析</strong>: 命令行参数 (<code>9090</code>) 的优先级 <strong>最高</strong>，覆盖了包外文件 (<code>80</code>) 和包内文件 (<code>8080</code>) 的所有同名配置。</li>
</ul>
</li>
<li><code>myapp.greeting</code>: <strong><code>&quot;Hello from environment variable&quot;</code></strong><ul>
<li><strong>分析</strong>: 操作系统环境变量 (<code>&quot;Hello from environment variable&quot;</code>) 的优先级 <strong>高于</strong> 包内文件 (<code>&quot;Hello from default config&quot;</code>)。由于没有更高优先级的配置（如命令行参数）来覆盖它，所以环境变量的值生效。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-3-3-总结与最佳实践"><a href="#2-3-3-总结与最佳实践" class="headerlink" title="2.3.3 总结与最佳实践"></a>2.3.3 总结与最佳实践</h4><ol>
<li><p><strong>代码内 (JAR包内)</strong>:</p>
<ul>
<li>在 <code>application.yml</code> 中放置<strong>通用的、安全的默认配置</strong>。</li>
<li>在 <code>application-{profile}.yml</code> 中放置<strong>特定环境的、非敏感的默认配置</strong>（如开发环境的数据库地址）。</li>
</ul>
</li>
<li><p><strong>代码外 (部署时)</strong>:</p>
<ul>
<li><p>对于<strong>敏感信息</strong>（如数据库密码、API密钥），<strong>强烈推荐</strong>使用<strong>操作系统环境变量</strong>或<strong>配置中心</strong>来注入。这避免了将机密信息硬编码在任何文件中。</p>
</li>
<li><p>对于<strong>非敏感但需要经常调整</strong>的配置（如线程池大小、功能开关），可以在<strong>JAR包同级目录下</strong>放置 <code>application.yml</code> 或 <code>config/application.yml</code> 文件，方便运维人员修改。</p>
</li>
<li><p>对于<strong>临时调试或一次性任务</strong>，使用<strong>命令行参数</strong>是最便捷的方式。</p>
</li>
</ul>
</li>
</ol>
<p>深刻理解这个优先级顺序，可以让你在复杂的部署环境中游刃有余地管理应用的配置，确保正确的配置在正确的环境中生效。</p>
<hr>
<h3 id="2-4-属性注入"><a href="#2-4-属性注入" class="headerlink" title="2.4 属性注入"></a>2.4 属性注入</h3><h4 id="2-4-1-Value注入单个属性"><a href="#2-4-1-Value注入单个属性" class="headerlink" title="2.4.1 @Value注入单个属性"></a>2.4.1 <code>@Value</code>注入单个属性</h4><p><code>@Value</code> 注解是 Spring 框架提供的一种依赖注入机制，它允许我们将外部配置源（如 <code>.properties</code> &#x2F; <code>.yml</code> 文件、环境变量、系统属性等）中的<strong>单个值</strong>直接注入到 Spring Bean 的字段、方法参数或构造函数参数中。</p>
<h5 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h5><p><code>@Value</code> 的核心语法是使用占位符 <code>${...}</code> 来引用一个配置属性的键（Key）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;property.key&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String propertyValue;</span><br></pre></td></tr></table></figure>

<p>当 Spring IoC 容器在初始化一个包含 <code>@Value</code> 注解的 Bean 时，它会：</p>
<ol>
<li>从已加载的所有配置源中（根据优先级顺序）查找键为 <code>property.key</code> 的属性。</li>
<li>找到后，将其值赋给 <code>propertyValue</code> 这个字段。</li>
<li>如果找不到该属性，应用程序在启动时会抛出 <code>IllegalArgumentException</code> 异常，导致启动失败。</li>
</ol>
<hr>
<h5 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="2. 使用示例"></a>2. 使用示例</h5><p>假设我们有以下 <code>application.yml</code> 配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">myapp:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&quot;My Awesome App&quot;</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">&quot;1.2.3&quot;</span></span><br><span class="line">  <span class="attr">feature-enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">thread-pool:</span></span><br><span class="line">    <span class="attr">core-size:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>我们可以创建一个组件来读取这些配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppInfoReader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入字符串类型</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;myapp.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spring会自动进行类型转换，将 &quot;1.2.3&quot; 转为 String</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;myapp.version&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appVersion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入布尔类型，&quot;true&quot; 会被转为 boolean true</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;myapp.feature-enabled&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isFeatureEnabled;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入整型</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入深层级的属性</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;myapp.thread-pool.core-size&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> corePoolSize;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAppInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Application Name: &quot;</span> + appName);</span><br><span class="line">        System.out.println(<span class="string">&quot;Version: &quot;</span> + appVersion);</span><br><span class="line">        System.out.println(<span class="string">&quot;Feature Enabled: &quot;</span> + isFeatureEnabled);</span><br><span class="line">        System.out.println(<span class="string">&quot;Server Port: &quot;</span> + serverPort);</span><br><span class="line">        System.out.println(<span class="string">&quot;Core Pool Size: &quot;</span> + corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-提供默认值"><a href="#3-提供默认值" class="headerlink" title="3. 提供默认值"></a>3. 提供默认值</h5><p>为了避免因某个配置项缺失而导致应用启动失败，<code>@Value</code> 允许我们提供一个默认值。语法是在键后面加上冒号 <code>:</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;property.key:defaultValue&#125;&quot;)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果 <code>property.key</code> 存在</strong>，则注入其配置值。</li>
<li><strong>如果 <code>property.key</code> 不存在</strong>，则注入 <code>defaultValue</code>，应用会正常启动。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果配置文件中没有 myapp.author，author 字段将被赋值为 &quot;Unknown&quot;</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;myapp.author:Unknown&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认值也可以是数字、布尔值等</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;myapp.timeout:3000&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> timeoutInMillis;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：即使提供了默认值，如果配置项存在但为空（例如 <code>myapp.author=</code>），那么注入的将是空字符串 <code>&quot;&quot;</code>，而不是默认值 <code>&quot;Unknown&quot;</code>。</p>
<hr>
<h5 id="4-SpEL-Spring-Expression-Language-支持"><a href="#4-SpEL-Spring-Expression-Language-支持" class="headerlink" title="4. SpEL (Spring Expression Language) 支持"></a>4. SpEL (Spring Expression Language) 支持</h5><p><code>@Value</code> 的功能远不止于简单的属性占位符。它还支持强大的 <strong>Spring 表达式语言 (SpEL)</strong>，语法是 <code>#{...}</code>。这允许我们执行一些动态的计算或引用其他Bean的属性。</p>
<p><strong>SpEL 常见用法</strong>：</p>
<ul>
<li><p><strong>引用其他Bean的属性</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有一个名为 systemProperties 的Bean (它是一个Map)</span></span><br><span class="line"><span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;java.home&#x27;]&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String javaHome;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>执行方法调用</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;someBean.getSomeValue().toUpperCase()&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String uppercaseValue;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进行数学运算</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;1 + 2&#125;&quot;)</span> <span class="comment">// 注入 3</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> result;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>组合属性占位符和SpEL</strong>:<br>我们可以将 <code>${...}</code> 和 <code>#{...}</code> 结合使用，先解析属性，再用SpEL处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从配置中读取一个逗号分隔的字符串，然后用SpEL将其分割成一个List</span></span><br><span class="line"><span class="comment">// application.properties: myapp.servers=host1,host2,host3</span></span><br><span class="line"><span class="meta">@Value(&quot;#&#123;&#x27;$&#123;myapp.servers&#125;&#x27;.split(&#x27;,&#x27;)&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; serverList;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="5-Value-vs-ConfigurationProperties"><a href="#5-Value-vs-ConfigurationProperties" class="headerlink" title="5. @Value vs @ConfigurationProperties"></a>5. <code>@Value</code> vs <code>@ConfigurationProperties</code></h5><p>虽然 <code>@Value</code> 很方便，但在某些场景下，<code>@ConfigurationProperties</code> 是更好的选择。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>@Value</code></th>
<th align="left"><code>@ConfigurationProperties</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>注入粒度</strong></td>
<td align="left"><strong>单个</strong>属性注入</td>
<td align="left"><strong>批量</strong>、<strong>结构化</strong>的属性绑定到一个对象上</td>
</tr>
<tr>
<td align="left"><strong>类型安全</strong></td>
<td align="left">较弱。如果类型转换失败，错误信息可能不够明确。</td>
<td align="left"><strong>强</strong>。提供复杂的类型转换和校验，失败时有清晰的错误报告。</td>
</tr>
<tr>
<td align="left"><strong>松散绑定 (Relaxed Binding)</strong></td>
<td align="left"><strong>不支持</strong>。属性键必须<strong>精确匹配</strong> (<code>feature-enabled</code> 必须写成 <code>feature-enabled</code>)。</td>
<td align="left"><strong>支持</strong>。<code>feature-enabled</code>, <code>featureEnabled</code>, <code>FEATURE_ENABLED</code> 都能匹配到 <code>featureEnabled</code> 字段。</td>
</tr>
<tr>
<td align="left"><strong>JSR-303 校验</strong></td>
<td align="left">不支持。</td>
<td align="left">支持。可以在属性类上使用<code>@Validated</code>和<code>@NotNull</code>等注解进行校验。</td>
</tr>
<tr>
<td align="left"><strong>SpEL 支持</strong></td>
<td align="left"><strong>支持</strong>。</td>
<td align="left">不支持。</td>
</tr>
</tbody></table>
<p><strong>选择建议</strong>：</p>
<ul>
<li>当你只需要注入<strong>一两个简单</strong>的、非结构化的配置项时，使用 <code>@Value</code> 非常快捷方便。</li>
<li>当你的配置项具有<strong>层级结构</strong>、数量较多，并且希望获得更好的<strong>类型安全</strong>和<strong>IDE支持</strong>时，<strong>强烈推荐使用 <code>@ConfigurationProperties</code></strong>。</li>
</ul>
<hr>
<h4 id="2-4-2-ConfigurationProperties"><a href="#2-4-2-ConfigurationProperties" class="headerlink" title="2.4.2 @ConfigurationProperties"></a>2.4.2 <code>@ConfigurationProperties</code></h4><p><code>@ConfigurationProperties</code> 注解是 Spring Boot 提供的一种将外部配置文件中的<strong>一组相关属性</strong>，以<strong>类型安全</strong>的方式<strong>批量绑定</strong>到一个Java对象（通常是POJO）上的强大机制。</p>
<p>它解决了 <code>@Value</code> 注解在处理大量、结构化配置时显得分散和繁琐的问题，提供了更优雅、更健壮的配置管理方案。</p>
<h5 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h5><p><code>@ConfigurationProperties</code> 的核心思想是**“约定优于配置”<strong>和</strong>“面向对象”**。</p>
<ul>
<li><strong>约定</strong>：你定义一个Java类，其<strong>字段名</strong>与配置文件中的<strong>属性键</strong>相对应。</li>
<li><strong>面向对象</strong>：将一组相关的配置（如数据库连接的所有参数）封装在一个单一的、内聚的对象中，而不是将它们散落在代码的各个角落。</li>
</ul>
<hr>
<h5 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2. 基本用法"></a>2. 基本用法</h5><p>使用 <code>@ConfigurationProperties</code> 通常涉及三个步骤：</p>
<p><strong>Step 1: 创建一个属性绑定类 (Properties Class)</strong></p>
<p>创建一个普通的Java类（POJO），用来承载配置信息。这个类需要为每个属性提供标准的 <code>getter</code> 和 <code>setter</code> 方法。</p>
<p><strong>Step 2: 使用 <code>@ConfigurationProperties</code> 注解</strong></p>
<p>在该类上添加 <code>@ConfigurationProperties</code> 注解，并通过 <code>prefix</code> 属性指定要绑定的配置属性的<strong>公共前缀</strong>。</p>
<p><strong>Step 3: 将该类注册为 Spring Bean</strong></p>
<p>为了让Spring Boot能够扫描到并处理这个属性类，你需要将它声明为一个Bean。最简单的方式是在类上添加 <code>@Component</code> 注解。</p>
<p><strong>示例</strong>：</p>
<p>假设我们有以下 <code>application.yml</code> 配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app:</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.example.com</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">587</span></span><br><span class="line">    <span class="attr">auth:</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">user@example.com</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">secret-password</span></span><br><span class="line">    <span class="attr">recipients:</span> <span class="comment"># 列表</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">admin@example.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">support@example.com</span></span><br><span class="line">    <span class="attr">headers:</span> <span class="comment"># Map</span></span><br><span class="line">      <span class="attr">X-Priority:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">X-Mailer:</span> <span class="string">MyAppMailer</span></span><br></pre></td></tr></table></figure>

<p>我们可以创建一个 <code>MailProperties</code> 类来绑定这组配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app.mail&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 邮件服务器主机地址. */</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 邮件服务器端口. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 认证信息 (这是一个嵌套对象). */</span></span><br><span class="line">    <span class="keyword">private</span> Auth auth;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 默认收件人列表. */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; recipients;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 自定义邮件头信息. */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; headers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嵌套的静态内部类，用于映射 auth 配置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Auth</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Auth 的 Getters and Setters</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123; <span class="keyword">return</span> username; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123; <span class="built_in">this</span>.username = username; &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123; <span class="keyword">return</span> password; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123; <span class="built_in">this</span>.password = password; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MailProperties 的 Getters and Setters</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHost</span><span class="params">()</span> &#123; <span class="keyword">return</span> host; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHost</span><span class="params">(String host)</span> &#123; <span class="built_in">this</span>.host = host; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPort</span><span class="params">()</span> &#123; <span class="keyword">return</span> port; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPort</span><span class="params">(<span class="type">int</span> port)</span> &#123; <span class="built_in">this</span>.port = port; &#125;</span><br><span class="line">    <span class="keyword">public</span> Auth <span class="title function_">getAuth</span><span class="params">()</span> &#123; <span class="keyword">return</span> auth; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuth</span><span class="params">(Auth auth)</span> &#123; <span class="built_in">this</span>.auth = auth; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getRecipients</span><span class="params">()</span> &#123; <span class="keyword">return</span> recipients; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRecipients</span><span class="params">(List&lt;String&gt; recipients)</span> &#123; <span class="built_in">this</span>.recipients = recipients; &#125;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">getHeaders</span><span class="params">()</span> &#123; <span class="keyword">return</span> headers; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeaders</span><span class="params">(Map&lt;String, String&gt; headers)</span> &#123; <span class="built_in">this</span>.headers = headers; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在其他地方使用</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MailProperties mailProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EmailService</span><span class="params">(MailProperties mailProperties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mailProperties = mailProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending email via host: &quot;</span> + mailProperties.getHost());</span><br><span class="line">        System.out.println(<span class="string">&quot;Username: &quot;</span> + mailProperties.getAuth().getUsername());</span><br><span class="line">        System.out.println(<span class="string">&quot;Recipients: &quot;</span> + mailProperties.getRecipients());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-核心特性"><a href="#3-核心特性" class="headerlink" title="3. 核心特性"></a>3. 核心特性</h5><p><strong>a. 松散绑定 (Relaxed Binding)</strong></p>
<p>这是 <code>@ConfigurationProperties</code> 一个非常强大的特性。它在匹配属性键和Java字段名时，不要求完全精确匹配，支持多种命名风格的转换。</p>
<p>例如，以下所有格式的配置键，都能成功绑定到Java字段 <code>myProperty</code> 上：</p>
<table>
<thead>
<tr>
<th align="left">配置文件中的Key</th>
<th align="left">对应的Java字段名</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>app.my-property</code> (kebab-case)</td>
<td align="left"><code>myProperty</code></td>
</tr>
<tr>
<td align="left"><code>app.my_property</code> (snake_case)</td>
<td align="left"><code>myProperty</code></td>
</tr>
<tr>
<td align="left"><code>app.myProperty</code> (camelCase)</td>
<td align="left"><code>myProperty</code></td>
</tr>
<tr>
<td align="left"><code>APP_MY_PROPERTY</code> (screaming snake_case, 用于环境变量)</td>
<td align="left"><code>myProperty</code></td>
</tr>
</tbody></table>
<p>官方推荐在 <code>.yml</code> 或 <code>.properties</code> 中使用 <strong>kebab-case (短横线分隔)</strong> 风格，因为它最易读。</p>
<p><strong>b. JSR-303 数据校验</strong></p>
<p>你可以结合使用 <code>javax.validation</code> 注解（如 <code>@NotNull</code>, <code>@Min</code>, <code>@Email</code>）和 <code>@Validated</code> 注解，让Spring Boot在绑定属性时自动进行数据校验。如果校验失败，应用启动会失败并给出明确的错误提示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.annotation.Validated;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotEmpty;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Min;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app.mail&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span> <span class="comment">// 开启校验</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty</span> <span class="comment">// 校验host不能为空字符串</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min(1025)</span> <span class="comment">// 端口号必须大于1024</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span> <span class="comment">// 校验auth对象不能为null</span></span><br><span class="line">    <span class="keyword">private</span> Auth auth;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>c. 强大的类型转换</strong></p>
<p>Spring Boot的类型转换服务非常强大，能自动处理很多复杂的转换，例如：</p>
<ul>
<li><code>&quot;10s&quot;</code> -&gt; <code>java.time.Duration</code></li>
<li><code>&quot;2KB&quot;</code> -&gt; <code>org.springframework.util.unit.DataSize</code></li>
<li><code>&quot;com.example.MyClass&quot;</code> -&gt; <code>java.lang.Class&lt;?&gt;</code></li>
<li>逗号分隔的字符串 -&gt; <code>List&lt;String&gt;</code></li>
</ul>
<p><strong>d. 启用 <code>@ConfigurationProperties</code> 的另一种方式</strong></p>
<p>除了在属性类上加 <code>@Component</code>，你还可以在一个 <code>@Configuration</code> 类上使用 <code>@EnableConfigurationProperties</code> 来激活一个或多个属性类。这种方式的好处是属性类本身可以是一个纯粹的POJO，不依赖于Spring的任何注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 属性类 (纯POJO)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app.mail&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailProperties</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MailProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 这样，MailProperties 就会被自动注册为一个Bean</span></span><br><span class="line">    <span class="comment">// 并且可以在这个配置类中直接注入它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-总结与最佳实践"><a href="#4-总结与最佳实践" class="headerlink" title="4. 总结与最佳实践"></a>4. 总结与最佳实践</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>@Value</code></th>
<th align="left"><code>@ConfigurationProperties</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>用途</strong></td>
<td align="left">注入单个、离散的属性值</td>
<td align="left">绑定一组结构化的、相关的配置属性</td>
</tr>
<tr>
<td align="left"><strong>代码风格</strong></td>
<td align="left">分散在各个类的字段上</td>
<td align="left">集中在一个专门的属性类中，内聚性高</td>
</tr>
<tr>
<td align="left"><strong>类型安全</strong></td>
<td align="left">较弱</td>
<td align="left"><strong>强</strong>，支持复杂的类型转换和校验</td>
</tr>
<tr>
<td align="left"><strong>松散绑定</strong></td>
<td align="left">不支持</td>
<td align="left"><strong>支持</strong>，代码和配置的命名风格可以解耦</td>
</tr>
<tr>
<td align="left"><strong>IDE支持</strong></td>
<td align="left">有限</td>
<td align="left"><strong>极好</strong>，提供配置键的自动补全、提示和元数据生成</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong>：</p>
<ul>
<li><strong>优先使用 <code>@ConfigurationProperties</code></strong>：对于任何一组（即使只有两三个）相关的配置，都应该优先考虑使用 <code>@ConfigurationProperties</code>。这会让你的代码更健壮、更易于维护和测试。</li>
<li><strong><code>@Value</code> 的适用场景</strong>：只在需要注入单个、与其他配置无强关联的简单值时，或者需要利用其SpEL能力时，才使用 <code>@Value</code>。</li>
</ul>
<hr>
<h2 id="3-监控与管理-Actuator"><a href="#3-监控与管理-Actuator" class="headerlink" title="3. 监控与管理(Actuator)"></a>3. 监控与管理(Actuator)</h2><h3 id="3-1-Actuator是什么？"><a href="#3-1-Actuator是什么？" class="headerlink" title="3.1 Actuator是什么？"></a>3.1 Actuator是什么？</h3><h4 id="3-1-1-核心定义"><a href="#3-1-1-核心定义" class="headerlink" title="3.1.1 核心定义"></a>3.1.1 核心定义</h4><p>Spring Boot <strong>Actuator</strong>（直译为“执行器”或“驱动器”），它的核心功能是为你的应用程序添加一系列<strong>生产就绪 (Production-Ready) 的特性</strong>，主要用于<strong>监控和管理</strong>正在运行中的应用程序。 能让你在<strong>不停止应用</strong>的情况下，通过HTTP端点（Endpoints）或JMX（Java Management Extensions），轻松地窥探应用程序的内部状态、运行状况和各种度量指标。</p>
<hr>
<h4 id="3-1-2-解决的问题：应用的“黑盒”困境"><a href="#3-1-2-解决的问题：应用的“黑盒”困境" class="headerlink" title="3.1.2 解决的问题：应用的“黑盒”困境"></a>3.1.2 解决的问题：应用的“黑盒”困境</h4><p>想象一下，一个没有监控的应用被部署到生产服务器上后，它就像一个**“黑盒”**：</p>
<ul>
<li><strong>它还活着吗？</strong> 应用进程还在，但它是否能正常处理业务？是不是已经僵死或陷入了死循环？</li>
<li><strong>它健康吗？</strong> 数据库连接是否正常？消息队列是否通畅？磁盘空间是否充足？</li>
<li><strong>它内部发生了什么？</strong> 加载了哪些Bean？当前的环境变量和配置是什么？最近的HTTP请求是成功了还是失败了？JVM内存使用情况如何？</li>
<li><strong>如何优雅地关闭它？</strong> 直接 <code>kill</code> 吗？这可能会导致正在处理的数据丢失。</li>
</ul>
<p>在没有Actuator的时代，开发者和运维人员需要自己编写大量的代码、集成各种第三方库（如Metrics, JMX MBeans）来回答这些问题。这个过程不仅繁琐，而且缺乏统一的标准。</p>
<p><strong>Actuator 的出现，就是为了打开这个“黑盒”，为所有Spring Boot应用提供一套标准化的、开箱即用的监控和管理解决方案。</strong></p>
<hr>
<h4 id="3-1-3-工作原理与核心组件"><a href="#3-1-3-工作原理与核心组件" class="headerlink" title="3.1.3 工作原理与核心组件"></a>3.1.3 工作原理与核心组件</h4><p>Actuator 的工作原理非常简单，它通过Spring Boot的自动配置机制，向你的应用中自动注册一系列特殊的基础设施Bean。其中最核心的两个组件是：</p>
<h5 id="1-端点-Endpoints"><a href="#1-端点-Endpoints" class="headerlink" title="1. 端点 (Endpoints)"></a>1. 端点 (Endpoints)</h5><ul>
<li><strong>定义</strong>：一个<strong>端点</strong>就是 Actuator 暴露出的一个<strong>特定监控或管理功能的入口</strong>。每个端点都专注于一个方面的信息，例如 <code>/health</code> 端点用于检查应用健康状况，<code>/metrics</code> 端点用于提供详细的度量指标。</li>
<li><strong>暴露方式</strong>：默认情况下，Actuator 主要通过 <strong>HTTP</strong> 和 <strong>JMX</strong> 两种方式暴露这些端点。<ul>
<li><strong>HTTP</strong>: 你可以通过访问特定的URL（如 <code>http://localhost:8081/actuator/health</code>）来获取JSON格式的监控数据。这是最常用、最直观的方式，也便于与各种监控系统（如Prometheus, Zabbix, Nagios）集成。</li>
<li><strong>JMX</strong>: 可以通过JConsole、VisualVM等JMX客户端连接到应用进程，以树状结构查看和管理应用。</li>
</ul>
</li>
</ul>
<h5 id="2-健康指示器-Health-Indicators"><a href="#2-健康指示器-Health-Indicators" class="headerlink" title="2. 健康指示器 (Health Indicators)"></a>2. 健康指示器 (Health Indicators)</h5><ul>
<li>这是 <code>/health</code> 端点的核心组成部分。Spring Boot Actuator 内置了大量的 <code>HealthIndicator</code> 实现，用于自动检查应用所依赖的各种外部资源的状态。</li>
<li><strong>常见的 <code>HealthIndicator</code></strong>:<ul>
<li><code>DataSourceHealthIndicator</code>: 检查数据库连接是否正常。</li>
<li><code>RedisHealthIndicator</code>: 检查Redis连接是否正常。</li>
<li><code>DiskSpaceHealthIndicator</code>: 检查磁盘空间是否低于阈值。</li>
<li><code>RabbitHealthIndicator</code>: 检查RabbitMQ连接。</li>
<li><code>PingHealthIndicator</code>: 一个基本的指示器，表示应用自身是启动的。</li>
</ul>
</li>
<li>当访问 <code>/health</code> 端点时，Actuator会汇总所有已启用的 <code>HealthIndicator</code> 的检查结果。只有当<strong>所有</strong>指示器的状态都是 <code>UP</code> 时，总的健康状态才是 <code>UP</code>。任何一个指示器状态为 <code>DOWN</code>，总状态就会变为 <code>DOWN</code>。</li>
</ul>
<hr>
<h4 id="3-1-4-如何使用-Actuator？"><a href="#3-1-4-如何使用-Actuator？" class="headerlink" title="3.1.4 如何使用 Actuator？"></a>3.1.4 如何使用 Actuator？</h4><h5 id="1-添加-spring-boot-starter-actuator-依赖"><a href="#1-添加-spring-boot-starter-actuator-依赖" class="headerlink" title="1. 添加 spring-boot-starter-actuator 依赖"></a>1. 添加 <code>spring-boot-starter-actuator</code> 依赖</h5><p>在你的 <code>pom.xml</code> 中添加起步依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一旦添加了这个依赖，Spring Boot的自动配置就会生效，为你注册所有Actuator相关的Bean。</p>
<hr>
<h5 id="2-配置端点的暴露"><a href="#2-配置端点的暴露" class="headerlink" title="2. 配置端点的暴露"></a>2. 配置端点的暴露</h5><p>出于安全考虑，Spring Boot 2.x 及以上版本，<strong>默认只通过HTTP暴露 <code>/health</code> 和 <code>/info</code> 两个端点</strong>。如果你想暴露更多的端点（如 <code>/metrics</code>, <code>/beans</code> 等），需要在 <code>application.yml</code> 中进行配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="comment"># 暴露所有端点，用 &#x27;*&#x27;</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">        <span class="comment"># 也可以指定暴露哪些，例如: include: health,info,metrics,beans</span></span><br><span class="line">        <span class="comment"># 如果想排除某些端点，可以用 exclude</span></span><br><span class="line">        <span class="comment"># exclude: env,beans</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># （可选）如果想修改Actuator端点的基础路径 (默认为 /actuator)</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">health:</span></span><br><span class="line">      <span class="comment"># （可选）配置health端点显示更多细节</span></span><br><span class="line">      <span class="comment"># NEVER: 不显示, WHEN_AUTHORIZED: 授权用户看, ALWAYS: 总是显示</span></span><br><span class="line">      <span class="attr">show-details:</span> <span class="string">always</span> </span><br></pre></td></tr></table></figure>

<p>完成这两步后，重启你的应用，就可以通过 <code>http://localhost:8080/actuator</code> 来查看所有已暴露的端点列表了。</p>
<hr>
<h4 id="3-1-5-Actuator-带来的价值"><a href="#3-1-5-Actuator-带来的价值" class="headerlink" title="3.1.5 Actuator 带来的价值"></a>3.1.5 Actuator 带来的价值</h4><ol>
<li><strong>标准化的应用洞察力</strong>: 提供了一套统一的接口来了解应用的内部状态，无需为每个项目重复发明轮子。</li>
<li><strong>DevOps 和 SRE 的利器</strong>: 为运维和网站可靠性工程师提供了强大的工具，用于自动化监控、健康检查、告警和故障排查。</li>
<li><strong>与监控生态无缝集成</strong>: Actuator 的 <code>/prometheus</code> 端点可以直接输出Prometheus格式的指标，<code>/health</code> 端点可以被Kubernetes的存活探针（Liveness Probe）和就绪探针（Readiness Probe）直接使用。</li>
<li><strong>动态管理能力</strong>: 一些端点（如 <code>/loggers</code>）甚至允许你在<strong>运行时</strong>动态修改应用的配置（如调整某个类的日志级别），而无需重启应用，这对于线上问题排查非常有用。</li>
</ol>
<hr>
<h3 id="3-2-常用端点-Endpoints-介绍"><a href="#3-2-常用端点-Endpoints-介绍" class="headerlink" title="3.2 常用端点 (Endpoints) 介绍"></a>3.2 常用端点 (Endpoints) 介绍</h3><p>当你在 <code>application.yml</code> 中通过 <code>management.endpoints.web.exposure.include=&quot;*&quot;</code> 暴露了所有Web端点后，你就可以通过访问 <code>http://&lt;host&gt;:&lt;port&gt;/actuator/{endpoint-id}</code> 来获取各种信息。</p>
<hr>
<h4 id="3-2-1-health-应用健康检查"><a href="#3-2-1-health-应用健康检查" class="headerlink" title="3.2.1 /health - 应用健康检查"></a>3.2.1 <code>/health</code> - 应用健康检查</h4><ul>
<li><p><strong>路径</strong>: <code>/actuator/health</code></p>
</li>
<li><p><strong>用途</strong>: <strong>这是最重要的端点之一</strong>。它用于检查应用程序的整体健康状况，是自动化监控系统（如负载均衡器、服务发现组件、Kubernetes探针）判断应用是否存活和就绪的核心依据。</p>
</li>
<li><p><strong>返回信息</strong>:</p>
<ul>
<li><p>它会聚合所有已配置的 <code>HealthIndicator</code>（健康指示器）的状态。</p>
</li>
<li><p><strong>默认配置下</strong>，它只返回一个总的 <code>status</code> 字段，值为 <code>UP</code> 或 <code>DOWN</code>。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UP&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>当 <code>management.endpoint.health.show-details=always</code> 时</strong>，它会返回详细的组件健康信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UP&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;components&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;db&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UP&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;database&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MySQL&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;validationQuery&quot;</span><span class="punctuation">:</span> <span class="string">&quot;isValid()&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;diskSpace&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UP&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">123456789</span><span class="punctuation">,</span> <span class="attr">&quot;free&quot;</span><span class="punctuation">:</span> <span class="number">12345678</span><span class="punctuation">,</span> <span class="attr">&quot;threshold&quot;</span><span class="punctuation">:</span> <span class="number">10485760</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ping&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UP&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;redis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UP&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6.2.5&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>只要有一个组件的 <code>status</code> 是 <code>DOWN</code>，总的 <code>status</code> 就会是 <code>DOWN</code>。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-2-info-应用基本信息"><a href="#3-2-2-info-应用基本信息" class="headerlink" title="3.2.2 /info - 应用基本信息"></a>3.2.2 <code>/info</code> - 应用基本信息</h4><ul>
<li><p><strong>路径</strong>: <code>/actuator/info</code></p>
</li>
<li><p><strong>用途</strong>: 提供一些通用的、非敏感的应用程序信息。这些信息通常是静态的，用于快速识别应用的版本、构建信息等。</p>
</li>
<li><p><strong>返回信息</strong>: 默认情况下是空的 <code>{}</code>。你需要自己在 <code>application.yml</code> 中配置 <code>info.*</code> 属性，或者通过构建工具插件自动生成。</p>
</li>
<li><p><strong>示例配置 (<code>application.yml</code>)</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">My</span> <span class="string">Awesome</span> <span class="string">App</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">This</span> <span class="string">is</span> <span class="string">a</span> <span class="string">demo</span> <span class="string">application</span> <span class="string">for</span> <span class="string">Spring</span> <span class="string">Boot</span> <span class="string">Actuator.</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">  <span class="attr">contact:</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">devteam@example.com</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回结果</strong>:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;app&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;My Awesome App&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This is a demo application for Spring Boot Actuator.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;contact&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;devteam@example.com&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自动生成构建信息</strong>: 在<code>pom.xml</code>中加入 <code>spring-boot-maven-plugin</code> 的 <code>build-info</code> 目标，可以自动将Git提交信息、构建时间等加入到 <code>/info</code> 端点。</p>
</li>
</ul>
<hr>
<h4 id="3-2-3-metrics-详细度量指标"><a href="#3-2-3-metrics-详细度量指标" class="headerlink" title="3.2.3 /metrics - 详细度量指标"></a>3.2.3 <code>/metrics</code> - 详细度量指标</h4><ul>
<li><p><strong>路径</strong>: <code>/actuator/metrics</code></p>
</li>
<li><p><strong>用途</strong>: <strong>性能监控和问题排查的核心</strong>。它提供了大量关于应用程序运行时的详细度量指标，如JVM内存使用、CPU使用率、HTTP请求统计等。</p>
</li>
<li><p><strong>使用方式</strong>:</p>
<ul>
<li><p>访问 <code>/actuator/metrics</code> 会列出所有<strong>可用的度量指标名称</strong>。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;names&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;jvm.memory.used&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;jvm.gc.pause&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;http.server.requests&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;process.cpu.usage&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;system.cpu.count&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// ... 还有很多</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>访问 <code>/actuator/metrics/{metric-name}</code> 来获取某个具体指标的详细数据。例如 <code>/actuator/metrics/jvm.memory.used</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jvm.memory.used&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The amount of used memory&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;baseUnit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bytes&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;measurements&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;statistic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;VALUE&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">1.23456789E8</span> <span class="punctuation">&#125;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;availableTags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;area&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;values&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;heap&quot;</span><span class="punctuation">,</span> <span class="string">&quot;nonheap&quot;</span><span class="punctuation">]</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;values&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;G1 Old Gen&quot;</span><span class="punctuation">,</span> <span class="string">&quot;G1 Survivor Space&quot;</span><span class="punctuation">,</span> ... <span class="punctuation">]</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>你可以使用标签（Tags）来筛选数据，例如：<code>/actuator/metrics/http.server.requests?tag=status:200&amp;tag=uri:/api/users</code> 可以查看特定URI和状态码的请求统计。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-4-beans-Spring容器中的Bean"><a href="#3-2-4-beans-Spring容器中的Bean" class="headerlink" title="3.2.4 /beans - Spring容器中的Bean"></a>3.2.4 <code>/beans</code> - Spring容器中的Bean</h4><ul>
<li><p><strong>路径</strong>: <code>/actuator/beans</code></p>
</li>
<li><p><strong>用途</strong>: 展示Spring IoC容器中所有已加载的Bean的完整列表。这对于调试和理解应用的组件构成非常有用。</p>
</li>
<li><p><strong>返回信息</strong>: 返回一个包含所有Bean信息的JSON数组。每个Bean的信息包括：</p>
<ul>
<li><code>bean</code>: Bean的名称&#x2F;ID。</li>
<li><code>aliases</code>: Bean的别名。</li>
<li><code>scope</code>: Bean的作用域（如 <code>singleton</code>, <code>prototype</code>）。</li>
<li><code>type</code>: Bean的完整类名。</li>
<li><code>resource</code>: Bean定义的来源（例如，哪个配置类）。</li>
<li><code>dependencies</code>: 该Bean依赖的其他Bean。</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;contexts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;application-1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;beans&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;myController&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;aliases&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span> <span class="string">&quot;singleton&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.example.MyController&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;file [/path/to/classes/com.example.MyController.class]&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;myService&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// ... 其他所有Bean</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-2-5-env-环境变量与配置"><a href="#3-2-5-env-环境变量与配置" class="headerlink" title="3.2.5 /env - 环境变量与配置"></a>3.2.5 <code>/env</code> - 环境变量与配置</h4><ul>
<li><strong>路径</strong>: <code>/actuator/env</code></li>
<li><strong>用途</strong>: 显示应用程序当前生效的所有环境属性。这包括来自操作系统、JVM、配置文件、命令行等所有来源的配置。</li>
<li><strong>返回信息</strong>:<ul>
<li>它会列出所有激活的Profile（<code>activeProfiles</code>）。</li>
<li>它会按优先级顺序列出所有的属性源（<code>propertySources</code>），并显示每个源中的具体属性。</li>
<li><strong>安全警告</strong>: <code>/env</code> 端点可能会暴露<strong>敏感信息</strong>（如数据库密码、API密钥），因此在生产环境中必须<strong>谨慎暴露</strong>，或者通过配置<code>management.endpoint.env.keys-to-sanitize</code>来对敏感键进行脱敏处理。</li>
</ul>
</li>
<li><strong>获取单个属性</strong>: 访问 <code>/actuator/env/{property-name}</code> 可以获取单个属性的值，例如 <code>/actuator/env/server.port</code>。</li>
</ul>
<hr>
<h4 id="3-2-6-loggers-日志级别管理"><a href="#3-2-6-loggers-日志级别管理" class="headerlink" title="3.2.6 /loggers - 日志级别管理"></a>3.2.6 <code>/loggers</code> - 日志级别管理</h4><ul>
<li><p><strong>路径</strong>: <code>/actuator/loggers</code></p>
</li>
<li><p><strong>用途</strong>: <strong>动态管理应用的日志级别，无需重启</strong>。这是线上问题排查的“神器”。</p>
</li>
<li><p><strong>使用方式</strong>:</p>
<ul>
<li><p><strong><code>GET /actuator/loggers</code></strong>: 获取所有logger的当前配置级别。</p>
</li>
<li><p><strong><code>GET /actuator/loggers/{logger-name}</code></strong>: 获取指定logger（包名或类名）的配置级别。</p>
<ul>
<li>例如：<code>GET /actuator/loggers/com.example.service</code></li>
</ul>
</li>
<li><p><strong><code>POST /actuator/loggers/{logger-name}</code></strong>: <strong>修改</strong>指定logger的日志级别。</p>
<ul>
<li><p><strong>请求体 (JSON)</strong>: <code>{&quot;configuredLevel&quot;: &quot;DEBUG&quot;}</code></p>
</li>
<li><p><strong>示例 (使用curl)</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">-d <span class="string">&#x27;&#123;&quot;configuredLevel&quot;: &quot;DEBUG&quot;&#125;&#x27;</span> \</span><br><span class="line">http://localhost:8080/actuator/loggers/com.example.service</span><br></pre></td></tr></table></figure>

<p>执行后，<code>com.example.service</code> 包下的所有类的日志输出级别会立即变为<code>DEBUG</code>。将<code>configuredLevel</code>设为<code>null</code>可以重置为默认级别。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-7-其他常用端点"><a href="#3-2-7-其他常用端点" class="headerlink" title="3.2.7 其他常用端点"></a>3.2.7 其他常用端点</h4><ul>
<li><strong><code>/mappings</code></strong>: 显示所有 <code>@RequestMapping</code> 的路径映射信息，包括哪个Controller的哪个方法处理哪个URL。</li>
<li><strong><code>/threaddump</code></strong>: 生成并返回当前应用的线程转储信息，用于分析线程死锁、性能瓶颈等问题。</li>
<li><strong><code>/heapdump</code></strong>: 生成并下载一个JVM堆转储文件（<code>hprof</code>格式），用于分析内存泄漏问题。<strong>这是一个重量级操作，请谨慎在生产环境使用</strong>。</li>
<li><strong><code>/shutdown</code></strong>: 通过<code>POST</code>请求可以<strong>优雅地关闭</strong>应用程序。默认是禁用的，需要通过<code>management.endpoint.shutdown.enabled=true</code>开启。</li>
</ul>
<hr>
<h3 id="3-3-定制化Actuator端点"><a href="#3-3-定制化Actuator端点" class="headerlink" title="3.3 定制化Actuator端点"></a>3.3 定制化Actuator端点</h3><h4 id="3-3-1-定制现有端点"><a href="#3-3-1-定制现有端点" class="headerlink" title="3.3.1 定制现有端点"></a>3.3.1 定制现有端点</h4><h5 id="1-定制-health-端点-编写自定义-HealthIndicator"><a href="#1-定制-health-端点-编写自定义-HealthIndicator" class="headerlink" title="1. 定制 /health 端点 (编写自定义 HealthIndicator)"></a>1. 定制 <code>/health</code> 端点 (编写自定义 <code>HealthIndicator</code>)</h5><p>这是最常见的定制需求。当你的应用依赖于一些Spring Boot没有内置健康检查的外部服务时（例如一个特定的RPC服务、一个文件系统挂载点、一个自定义的第三方API），你可以通过实现 <code>HealthIndicator</code> 接口来创建自己的健康检查逻辑。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li>创建一个类实现 <code>HealthIndicator</code> 接口。</li>
<li>实现 <code>health()</code> 方法。这个方法需要返回一个 <code>Health</code> 对象。</li>
<li>使用 <code>Health.up()</code>、<code>Health.down()</code>、<code>Health.outOfService()</code> 等构建器来创建返回结果。</li>
<li>可以使用 <code>.withDetail(&quot;key&quot;, &quot;value&quot;)</code> 来添加详细信息。</li>
<li>将这个类注册为一个Spring Bean (通常使用 <code>@Component</code> 注解)。</li>
</ol>
<p><strong>示例：检查一个外部API是否可用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.health.Health;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.health.HealthIndicator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;myExternalApi&quot;)</span> <span class="comment">// Bean的名字会成为health组件的key</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExternalApiHealthIndicator</span> <span class="keyword">implements</span> <span class="title class_">HealthIndicator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Health <span class="title function_">health</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试调用外部API的某个状态检查接口</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">apiUrl</span> <span class="operator">=</span> <span class="string">&quot;https://api.example.com/status&quot;</span>;</span><br><span class="line">            <span class="comment">// 假设API成功时返回 &quot;OK&quot;</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> restTemplate.getForObject(apiUrl, String.class);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equalsIgnoreCase(response)) &#123;</span><br><span class="line">                <span class="comment">// 如果API正常，返回UP状态，并带上一些额外信息</span></span><br><span class="line">                <span class="keyword">return</span> Health.up().withDetail(<span class="string">&quot;url&quot;</span>, apiUrl).withDetail(<span class="string">&quot;status&quot;</span>, <span class="string">&quot;Available&quot;</span>).build();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果API返回非预期内容，返回DOWN状态</span></span><br><span class="line">                <span class="keyword">return</span> Health.down().withDetail(<span class="string">&quot;url&quot;</span>, apiUrl).withDetail(<span class="string">&quot;response&quot;</span>, response).build();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 如果调用过程中发生异常，返回DOWN状态，并带上异常信息</span></span><br><span class="line">            <span class="keyword">return</span> Health.down(e).withDetail(<span class="string">&quot;error&quot;</span>, e.getMessage()).build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>效果</strong>：重启应用后，再次访问 <code>/actuator/health</code>，你会在 <code>components</code> 字段下看到一个名为 <code>myExternalApi</code> 的新条目，显示你自定义的健康检查结果。</p>
<hr>
<h5 id="2-定制-info-端点-编写自定义-InfoContributor"><a href="#2-定制-info-端点-编写自定义-InfoContributor" class="headerlink" title="2. 定制 /info 端点 (编写自定义 InfoContributor)"></a>2. 定制 <code>/info</code> 端点 (编写自定义 <code>InfoContributor</code>)</h5><p>与<code>/health</code>类似，你可以通过实现 <code>InfoContributor</code> 接口，动态地向 <code>/info</code> 端点添加信息。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li>创建一个类实现 <code>InfoContributor</code> 接口。</li>
<li>实现 <code>contribute()</code> 方法，通过 <code>builder</code> 对象添加信息。</li>
<li>将这个类注册为一个Spring Bean。</li>
</ol>
<p><strong>示例：添加当前激活的Spring Profiles到 <code>/info</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.info.Info;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.info.InfoContributor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActiveProfilesInfoContributor</span> <span class="keyword">implements</span> <span class="title class_">InfoContributor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ActiveProfilesInfoContributor</span><span class="params">(Environment environment)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contribute</span><span class="params">(Info.Builder builder)</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前激活的profiles添加到info端点的一个&quot;activeProfiles&quot;键下</span></span><br><span class="line">        builder.withDetail(<span class="string">&quot;activeProfiles&quot;</span>, Arrays.asList(environment.getActiveProfiles()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>效果</strong>：重启应用后，访问 <code>/actuator/info</code>，会看到新增的 <code>activeProfiles</code> 字段。</p>
<hr>
<h4 id="3-3-2-创建全新端点-实现-Endpoint"><a href="#3-3-2-创建全新端点-实现-Endpoint" class="headerlink" title="3.3.2 创建全新端点 (实现 @Endpoint)"></a>3.3.2 创建全新端点 (实现 <code>@Endpoint</code>)</h4><p>如果你需要一个完全自定义的管理功能，你可以创建自己的Actuator端点。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li>创建一个类，并使用 <code>@Endpoint(id = &quot;...&quot;)</code> 注解标记它。<code>id</code> 属性将成为端点的路径（如 <code>id = &quot;custom&quot;</code>，路径就是 <code>/actuator/custom</code>）。</li>
<li>将这个类注册为一个Spring Bean (<code>@Component</code>)。</li>
<li>在类中创建方法，并使用 <code>@ReadOperation</code>, <code>@WriteOperation</code>, <code>@DeleteOperation</code> 来标记它们，分别对应HTTP的GET, POST, DELETE方法。</li>
<li>方法的参数可以用来接收URL路径变量 (<code>@Selector</code>) 或请求参数。</li>
</ol>
<p><strong>示例：创建一个 <code>/sessions</code> 端点来查看和管理用户会话</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.endpoint.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Endpoint(id = &quot;sessions&quot;)</span> <span class="comment">// 端点ID为 &quot;sessions&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionsEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一个Session存储</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; sessions = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟添加一些初始会话</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SessionsEndpoint</span><span class="params">()</span> &#123;</span><br><span class="line">        sessions.put(<span class="string">&quot;user-alice&quot;</span>, <span class="string">&quot;alice-session-id-123&quot;</span>);</span><br><span class="line">        sessions.put(<span class="string">&quot;user-bob&quot;</span>, <span class="string">&quot;bob-session-id-456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应 GET /actuator/sessions</span></span><br><span class="line">    <span class="meta">@ReadOperation</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">getAllSessions</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sessions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应 GET /actuator/sessions/&#123;username&#125;</span></span><br><span class="line">    <span class="comment">// @Selector会将路径变量注入到方法参数中</span></span><br><span class="line">    <span class="meta">@ReadOperation</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSessionByUsername</span><span class="params">(<span class="meta">@Selector</span> String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sessions.get(<span class="string">&quot;user-&quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应 POST /actuator/sessions/&#123;username&#125;</span></span><br><span class="line">    <span class="comment">// @WriteOperation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOrUpdateSession</span><span class="params">(<span class="meta">@Selector</span> String username, String sessionId)</span> &#123;</span><br><span class="line">        sessions.put(<span class="string">&quot;user-&quot;</span> + username, sessionId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应 DELETE /actuator/sessions/&#123;username&#125;</span></span><br><span class="line">    <span class="meta">@DeleteOperation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteSession</span><span class="params">(<span class="meta">@Selector</span> String username)</span> &#123;</span><br><span class="line">        sessions.remove(<span class="string">&quot;user-&quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用</strong>：</p>
<ul>
<li><code>GET /actuator/sessions</code>: 返回所有会话。</li>
<li><code>GET /actuator/sessions/alice</code>: 返回alice的会话ID。</li>
<li><code>POST /actuator/sessions/charlie</code> (请求体为<code>{&quot;sessionId&quot;: &quot;charlie-session-id-789&quot;}</code>): 新增charlie的会话。</li>
<li><code>DELETE /actuator/sessions/bob</code>: 删除bob的会话。</li>
</ul>
<p><strong>不要忘记暴露新端点</strong>：</p>
<p>需要在 <code>application.yml</code> 中将新端点加入暴露列表：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">health,info,sessions</span> <span class="comment"># 别忘了加上 sessions</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-3-3-安全与暴露策略定制"><a href="#3-3-3-安全与暴露策略定制" class="headerlink" title="3.3.3 安全与暴露策略定制"></a>3.3.3 安全与暴露策略定制</h4><p>Actuator端点可能会暴露敏感信息，因此对其进行安全控制非常重要。</p>
<h5 id="1-精细化暴露"><a href="#1-精细化暴露" class="headerlink" title="1. 精细化暴露"></a>1. 精细化暴露</h5><p>如前所述，使用 <code>include</code> 和 <code>exclude</code> 来精确控制哪些端点通过Web暴露。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">health,info,prometheus</span> <span class="comment"># 只暴露这三个</span></span><br><span class="line">        <span class="comment"># exclude: beans,env # 明确排除这两个</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-修改基础路径和端口"><a href="#2-修改基础路径和端口" class="headerlink" title="2. 修改基础路径和端口"></a>2. 修改基础路径和端口</h5><p>你可以将Actuator端点运行在一个与主应用不同的端口上，以实现网络层面的隔离。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span> <span class="comment"># Actuator端点将运行在8081端口</span></span><br><span class="line">    <span class="attr">address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment"># 只允许本地访问</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">base-path:</span> <span class="string">/manage</span> <span class="comment"># 将基础路径从 /actuator 改为 /manage</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-集成Spring-Security"><a href="#3-集成Spring-Security" class="headerlink" title="3. 集成Spring Security"></a>3. 集成Spring Security</h5><p>如果你的项目中引入了<code>spring-boot-starter-security</code>，<strong>Actuator的所有端点（除了<code>/health</code>和<code>/info</code>）默认都会被安全机制保护</strong>。你需要提供正确的认证信息（如用户名密码）才能访问。</p>
<p>你可以通过Spring Security的配置，为Actuator端点定义更精细的访问规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActuatorSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.requestMatcher(EndpointRequest.toAnyEndpoint()) <span class="comment">// 匹配所有Actuator端点</span></span><br><span class="line">            .authorizeRequests(requests -&gt; requests</span><br><span class="line">                .requestMatchers(EndpointRequest.to(ShutdownEndpoint.class))</span><br><span class="line">                .hasRole(<span class="string">&quot;ADMIN&quot;</span>) <span class="comment">// /shutdown端点需要ADMIN角色</span></span><br><span class="line">                .anyRequest().permitAll() <span class="comment">// 其他端点允许所有认证用户访问</span></span><br><span class="line">            )</span><br><span class="line">            .httpBasic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个配置要求访问<code>/shutdown</code>端点需要<code>ADMIN</code>角色，而访问其他端点只需通过HTTP Basic认证即可。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/09/29/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringFramework/" rel="prev" title="Spring全家桶-SpringFramework">
                  <i class="fa fa-angle-left"></i> Spring全家桶-SpringFramework
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringWeb/" rel="next" title="Spring全家桶-SpringWeb">
                  Spring全家桶-SpringWeb <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
