<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="一、SpringMVC 核心概念与演进1. Web开发演进史Web 开发一直在解决一个核心矛盾：业务逻辑（Java 代码）与 页面展示（HTML 代码）的耦合问题。 第一阶段：Servlet 史前时代（由 Java 硬写 HTML） 地位：Web 的底层基石，但现代开发中不再直接写它。   工作模式：所有的请求处理、数据库连接、甚至 HTML 标签的拼接，全部堆在一个 Java 类（Servlet">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring全家桶-SpringMVC">
<meta property="og:url" content="http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringMVC/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="一、SpringMVC 核心概念与演进1. Web开发演进史Web 开发一直在解决一个核心矛盾：业务逻辑（Java 代码）与 页面展示（HTML 代码）的耦合问题。 第一阶段：Servlet 史前时代（由 Java 硬写 HTML） 地位：Web 的底层基石，但现代开发中不再直接写它。   工作模式：所有的请求处理、数据库连接、甚至 HTML 标签的拼接，全部堆在一个 Java 类（Servlet">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-05T06:27:02.000Z">
<meta property="article:modified_time" content="2026-02-02T07:44:25.250Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringMVC/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringMVC/","path":"2025/10/05/主流框架与工具库/Spring全家桶/Spring全家桶-SpringMVC/","title":"Spring全家桶-SpringMVC"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Spring全家桶-SpringMVC | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81SpringMVC-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%BC%94%E8%BF%9B"><span class="nav-text">一、SpringMVC 核心概念与演进</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Web%E5%BC%80%E5%8F%91%E6%BC%94%E8%BF%9B%E5%8F%B2"><span class="nav-text">1. Web开发演进史</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%9AServlet-%E5%8F%B2%E5%89%8D%E6%97%B6%E4%BB%A3%EF%BC%88%E7%94%B1-Java-%E7%A1%AC%E5%86%99-HTML%EF%BC%89"><span class="nav-text">第一阶段：Servlet 史前时代（由 Java 硬写 HTML）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%9AJSP-%E6%97%B6%E4%BB%A3%EF%BC%88Model-1-%E6%B7%B7%E6%B2%8C%E6%9C%9F%EF%BC%89"><span class="nav-text">第二阶段：JSP 时代（Model 1 - 混沌期）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E7%AA%81%E5%9B%B4%EF%BC%9AMVC-%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="nav-text">概念突围：MVC 模式的诞生</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%EF%BC%9AMVC-%E5%90%AF%E8%92%99%E6%97%B6%E4%BB%A3%EF%BC%88Model-2-Servlet-JSP%EF%BC%89"><span class="nav-text">第三阶段：MVC 启蒙时代（Model 2 - Servlet + JSP）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%EF%BC%9A%E4%BC%A0%E7%BB%9F-MVC-%E6%A1%86%E6%9E%B6%E6%97%B6%E4%BB%A3%EF%BC%88SSM-Spring-Boot-Thymeleaf%EF%BC%89"><span class="nav-text">第四阶段：传统 MVC 框架时代（SSM &#x2F; Spring Boot + Thymeleaf）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E9%98%B6%E6%AE%B5%EF%BC%9A%E7%8E%B0%E4%BB%A3-MVC-%E4%B8%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%EF%BC%88RESTful-API%EF%BC%89"><span class="nav-text">第五阶段：现代 MVC 与前后端分离（RESTful API）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%BA%91%E5%8E%9F%E7%94%9F%EF%BC%88Microservices-Reactive%EF%BC%89"><span class="nav-text">第六阶段：微服务与云原生（Microservices &amp; Reactive）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-SpringMVC-%E6%A6%82%E5%BF%B5"><span class="nav-text">2. SpringMVC 概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AFSpringMVC"><span class="nav-text">2.1 什么是SpringMVC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Servlet-3-0-%E4%B8%8E-SpringMVC-%E7%9A%84%E5%8E%BB-XML-%E5%8C%96"><span class="nav-text">2.2  Servlet 3.0 与 SpringMVC 的去 XML 化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E5%8F%B2%E5%89%8D%E6%97%B6%E4%BB%A3%EF%BC%9Aweb-xml-%E7%9A%84%E5%9E%84%E6%96%AD"><span class="nav-text">2.2.1 史前时代：web.xml 的垄断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E5%8F%98%E9%9D%A9%E7%82%B9%EF%BC%9ASPI-%E6%9C%BA%E5%88%B6%E4%B8%8E-ServletContainerInitializer"><span class="nav-text">2.2.2 变革点：SPI 机制与 ServletContainerInitializer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-SpringMVC-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E2%80%9C%E9%9B%B6-XML%E2%80%9D%E5%90%AF%E5%8A%A8%EF%BC%9F"><span class="nav-text">2.2.3 SpringMVC 如何实现“零 XML”启动？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">二、核心架构与执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="nav-text">1. 核心组件详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-text">1.1 核心组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E5%89%8D%E7%AB%AF%E6%8E%A7%E5%88%B6%E5%99%A8-DispatcherServlet"><span class="nav-text">1.1.1 前端控制器 (DispatcherServlet)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E5%A4%84%E7%90%86%E5%99%A8%E6%98%A0%E5%B0%84%E5%99%A8-HandlerMapping"><span class="nav-text">1.1.2 处理器映射器 (HandlerMapping)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-%E5%A4%84%E7%90%86%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8-HandlerAdapter"><span class="nav-text">1.1.3 处理器适配器 (HandlerAdapter)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-4-%E5%A4%84%E7%90%86%E5%99%A8-Handler"><span class="nav-text">1.1.4 处理器 (Handler)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-5-%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8%EF%BC%88HttpMessageConverter%EF%BC%89"><span class="nav-text">1.1.5  消息转换器（HttpMessageConverter）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E4%B8%BA%E4%BB%80%E4%B9%88-HttpMessageConverter-%E6%9B%BF%E4%BB%A3%E4%BA%86-ViewResolver%EF%BC%9F"><span class="nav-text">1.2 为什么 HttpMessageConverter 替代了 ViewResolver？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E8%BE%85%E5%8A%A9%E7%BB%84%E4%BB%B6"><span class="nav-text">1.3 辅助组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-HandlerExceptionResolver-%E5%BC%82%E5%B8%B8%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-text">1.3.1 HandlerExceptionResolver (异常解析器)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-MultipartResolver-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-text">1.3.2 MultipartResolver (文件上传解析器)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">2. 执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-text">2.1 流程图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="nav-text">2.2 执行流程详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%9A%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84"><span class="nav-text">第一阶段：请求映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%9A%E4%B8%9A%E5%8A%A1%E6%89%A7%E8%A1%8C%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-text">第二阶段：业务执行与数据序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%EF%BC%9A%E8%AF%B7%E6%B1%82%E7%BB%93%E6%9D%9F"><span class="nav-text">第三阶段：请求结束</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E7%BA%A7%E8%A7%A3%E6%9E%90"><span class="nav-text">3. 执行流程源码级解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-DispatcherServlet-doDispatch-%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="nav-text">3.1 DispatcherServlet.doDispatch 源码深度解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E6%BA%90%E7%A0%81%E9%AA%A8%E6%9E%B6"><span class="nav-text">3.1.1 源码骨架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90"><span class="nav-text">3.1.2 关键步骤深度剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-getHandler-%E5%AF%BB%E6%89%BE-Handler"><span class="nav-text">1. getHandler() - 寻找 Handler</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-ha-handle-%E9%80%82%E9%85%8D%E5%99%A8%E6%89%A7%E8%A1%8C"><span class="nav-text">2. ha.handle() - 适配器执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-processDispatchResult-%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%85%9C%E5%BA%95"><span class="nav-text">3. processDispatchResult() - 结果处理与异常兜底</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E4%BB%8E-Request-%E5%88%B0-Controller-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="nav-text">3.2 从 Request 到 Controller 方法参数绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Controller-%E8%BF%94%E5%9B%9E%E5%80%BC%E8%BD%AC-JSON-%E5%93%8D%E5%BA%94-Output"><span class="nav-text">3.3 Controller 返回值转 JSON 响应 (Output)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1%E4%B8%8E-RESTful-%E8%AE%BE%E8%AE%A1"><span class="nav-text">三、请求路由与 RESTful 设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-RESTful-API%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97"><span class="nav-text">1. RESTful API设计指南</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">1.1 核心概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%88%E5%85%AD%E5%A4%A7%E8%A6%81%E7%B4%A0%EF%BC%89"><span class="nav-text">1.2 核心设计原则（六大要素）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-URI-%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%90%8D%E8%AF%8D-vs-%E5%8A%A8%E8%AF%8D%EF%BC%89"><span class="nav-text">1.2.1 URI 设计（名词 vs 动词）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-HTTP-%E5%8A%A8%E8%AF%8D"><span class="nav-text">1.2.2 HTTP 动词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-HTTP-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-text">1.2.3 HTTP 状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4-%E6%97%A0%E7%8A%B6%E6%80%81"><span class="nav-text">1.2.4 无状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-5-%E7%BB%9F%E4%B8%80%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F"><span class="nav-text">1.2.5 统一接口返回格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-6-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><span class="nav-text">1.2.6 版本控制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-RequestMapping-%E6%98%A0%E5%B0%84%E8%AF%A6%E8%A7%A3"><span class="nav-text">2. @RequestMapping 映射详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%B3%A8%E8%A7%A3%E6%A6%82%E8%BF%B0"><span class="nav-text">2.1 注解概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%A0%87%E6%B3%A8%E4%BD%8D%E7%BD%AE%E4%B8%8E%E8%B7%AF%E5%BE%84%E7%BB%A7%E6%89%BF"><span class="nav-text">2.2 标注位置与路径继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-URL-%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="nav-text">2.3 URL 路径匹配规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E7%B2%BE%E7%A1%AE%E5%8C%B9%E9%85%8D"><span class="nav-text">2.3.1 精确匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-Ant-%E9%A3%8E%E6%A0%BC%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-text">2.3.2 Ant 风格通配符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-%E5%8D%A0%E4%BD%8D%E7%AC%A6%E5%8C%B9%E9%85%8D"><span class="nav-text">2.3.3 占位符匹配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-HTTP-%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E9%99%90%E5%AE%9A"><span class="nav-text">2.4 HTTP 请求方式限定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E4%B8%8E%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%99%90%E5%AE%9A"><span class="nav-text">2.5 请求参数与请求头限定</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1-params-%E5%B1%9E%E6%80%A7%EF%BC%88%E9%99%90%E5%AE%9A%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%EF%BC%89"><span class="nav-text">2.5.1 params 属性（限定请求参数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-headers-%E5%B1%9E%E6%80%A7%EF%BC%88%E9%99%90%E5%AE%9A%E8%AF%B7%E6%B1%82%E5%A4%B4%EF%BC%89"><span class="nav-text">2.5.2 headers 属性（限定请求头）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="nav-text">四、请求数据绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%AE%80%E5%8D%95%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="nav-text">1. 简单参数绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%99%AE%E9%80%9A%E5%8F%82%E6%95%B0%EF%BC%9A-RequestParam"><span class="nav-text">1.1 普通参数：@RequestParam</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0%EF%BC%9A-PathVariable"><span class="nav-text">1.2 路径参数：@PathVariable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%8E-Cookie"><span class="nav-text">1.3 请求头与 Cookie</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%A4%8D%E6%9D%82%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="nav-text">2. 复杂参数绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-POJO-%E8%87%AA%E5%8A%A8%E5%B0%81%E8%A3%85"><span class="nav-text">2.1 POJO 自动封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-JSON-%E8%AF%B7%E6%B1%82%E4%BD%93%EF%BC%9A-RequestBody"><span class="nav-text">2.2 JSON 请求体：@RequestBody</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%89%B9%E6%AE%8A%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86"><span class="nav-text">3. 特殊参数处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86"><span class="nav-text">3.1 日期时间处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E9%9B%86%E5%90%88%E7%BB%91%E5%AE%9A%E7%9A%84%E2%80%9C%E5%9D%91%E2%80%9D"><span class="nav-text">3.2 集合绑定的“坑”</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E9%97%AE%E9%A2%98%E7%8E%B0%E8%B1%A1"><span class="nav-text">3.2.1 问题现象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E4%BD%BF%E7%94%A8-RequestParam-%E6%B3%A8%E8%A7%A3%EF%BC%88%E7%94%A8%E4%BA%8E%E7%AE%80%E5%8D%95%E5%8F%82%E6%95%B0%EF%BC%89"><span class="nav-text">3.2.2 使用 @RequestParam 注解（用于简单参数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E4%BD%BF%E7%94%A8-RequestBody-%E6%B3%A8%E8%A7%A3%EF%BC%88%E7%94%A8%E4%BA%8E%E5%A4%8D%E6%9D%82%E5%8F%82%E6%95%B0%EF%BC%89"><span class="nav-text">3.2.3 使用 @RequestBody 注解（用于复杂参数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-%E5%8C%85%E8%A3%85%E5%9C%A8-POJO-%E5%AF%B9%E8%B1%A1%E4%B8%AD%EF%BC%88%E7%94%A8%E4%BA%8E%E5%A4%8D%E6%9D%82%E8%A1%A8%E5%8D%95%EF%BC%89"><span class="nav-text">3.2.4 包装在 POJO 对象中（用于复杂表单）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E8%8E%B7%E5%8F%96%E5%8E%9F%E7%94%9F-API"><span class="nav-text">3.3 获取原生 API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8E%9F%E7%94%9F-API%EF%BC%9F"><span class="nav-text">3.3.1 为什么需要原生 API？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="nav-text">3.3.2 获取方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">3.3.3 代码示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E8%AF%B7%E6%B1%82%E4%B9%B1%E7%A0%81"><span class="nav-text">4. 请求乱码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E4%B9%B1%E7%A0%81%E6%A0%B9%E6%BA%90"><span class="nav-text">4.1 乱码根源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E7%8E%B0%E4%BB%A3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9ACharacterEncodingFilter"><span class="nav-text">4.2 现代解决方案：CharacterEncodingFilter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="nav-text">4.3 配置方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="nav-text">五、响应数据处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-JSON-%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94"><span class="nav-text">1. JSON 数据响应</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-ResponseBody-%E4%B8%8E-RestController"><span class="nav-text">1.1 @ResponseBody 与 @RestController</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%B8%B8%E8%A7%81-JSON-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%B3%A8%E8%A7%A3"><span class="nav-text">1.2 常见 JSON 格式化注解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-HTTP-%E5%8D%8F%E8%AE%AE%E6%8E%A7%E5%88%B6%EF%BC%9AResponseEntity"><span class="nav-text">2. HTTP 协议控制：ResponseEntity</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AF-ResponseEntity%EF%BC%9F"><span class="nav-text">2.1 什么是 ResponseEntity？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AE%83"><span class="nav-text">2.2 为什么需要它</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-text">2.3 基本用法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E9%93%BE%E5%BC%8F%E6%9E%84%E5%BB%BA%E9%A3%8E%E6%A0%BC"><span class="nav-text">2.3.1 链式构建风格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E6%9E%84%E9%80%A0%E5%99%A8%E9%A3%8E%E6%A0%BC"><span class="nav-text">2.3.2 构造器风格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="nav-text">2.3.3 自定义响应头</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%EF%BC%88%E4%BC%A0%E7%BB%9FSSR%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-text">3. 页面跳转（传统SSR模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E8%BF%94%E5%9B%9E-String-%E8%A7%86%E5%9B%BE%E5%90%8D"><span class="nav-text">3.1 返回 String (视图名)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E8%BD%AC%E5%8F%91-forward-%E4%B8%8E-%E9%87%8D%E5%AE%9A%E5%90%91-redirect"><span class="nav-text">3.2 转发 (forward:) 与 重定向 (redirect:)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%AE%9E%E6%88%98"><span class="nav-text">六、高级功能与实战</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">1. 全局异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%EF%BC%9A-RestControllerAdvice"><span class="nav-text">1.1 核心注解：@RestControllerAdvice</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%AE%9E%E6%88%98%EF%BC%9A%E6%9E%84%E5%BB%BA%E7%BB%9F%E4%B8%80%E9%94%99%E8%AF%AF%E5%93%8D%E5%BA%94%E4%BD%93%E7%B3%BB"><span class="nav-text">1.2 实战：构建统一错误响应体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">1.3 底层原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="nav-text">2. 拦截器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%9F"><span class="nav-text">2.1 什么是拦截器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%8B%A6%E6%88%AA%E5%99%A8-vs-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-text">2.2 拦截器 vs 过滤器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">2.3 三大核心方法 (生命周期)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%AE%9E%E6%88%98%EF%BC%9A%E7%99%BB%E5%BD%95%E6%9D%83%E9%99%90%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="nav-text">2.4 实战：登录权限拦截器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-%E7%BC%96%E5%86%99%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="nav-text">2.4.1 编写拦截器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-%E9%85%8D%E7%BD%AE-%E6%B3%A8%E5%86%8C%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%88-Java-Config-%EF%BC%89"><span class="nav-text">2.4.2 配置&#x2F;注册拦截器（ Java Config ）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB-CORS"><span class="nav-text">3. 跨域资源共享 (CORS)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1%EF%BC%9A%E5%B1%80%E9%83%A8%E6%B3%A8%E8%A7%A3-%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E7%94%A8"><span class="nav-text">3.1 解决方案 1：局部注解 (开发调试用)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2%EF%BC%9A%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE-%E7%94%9F%E4%BA%A7%E6%8E%A8%E8%8D%90"><span class="nav-text">3.2 解决方案 2：全局配置 (生产推荐)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C-Validation-JSR-303"><span class="nav-text">4. 参数校验 (Validation &#x2F; JSR-303)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%9F%BA%E7%A1%80%E4%BE%9D%E8%B5%96%E4%B8%8E%E6%A6%82%E5%BF%B5"><span class="nav-text">4.1 基础依赖与概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%E4%BE%9D%E8%B5%96%E5%BC%95%E5%85%A5"><span class="nav-text">4.1.1 依赖引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-%E5%B8%B8%E7%94%A8%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3-%E6%A0%87%E6%B3%A8%E5%9C%A8-DTO-POJO-%E5%B1%9E%E6%80%A7%E4%B8%8A"><span class="nav-text">4.1.2 常用校验注解 (标注在 DTO&#x2F;POJO 属性上)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Controller-%E5%B1%82%E5%BC%80%E5%90%AF%E6%A0%A1%E9%AA%8C-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">4.2 Controller 层开启校验 (最佳实践)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E5%86%99%E6%B3%95%E4%B8%80%EF%BC%9A%E6%89%8B%E5%8A%A8%E5%A4%84%E7%90%86-%E4%BC%A0%E7%BB%9F-%E4%B8%8D%E6%8E%A8%E8%8D%90"><span class="nav-text">4.2.1 写法一：手动处理 (传统&#x2F;不推荐)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E5%86%99%E6%B3%95%E4%BA%8C%EF%BC%9A%E8%87%AA%E5%8A%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8-%E7%8E%B0%E4%BB%A3-%E6%8E%A8%E8%8D%90"><span class="nav-text">4.2.2 写法二：自动抛出异常 (现代&#x2F;推荐)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C-Group-Validation"><span class="nav-text">4.3 分组校验 (Group Validation)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E5%AE%9A%E4%B9%89%E5%88%86%E7%BB%84%E6%8E%A5%E5%8F%A3-%E7%A9%BA%E6%8E%A5%E5%8F%A3"><span class="nav-text">4.3.1 定义分组接口 (空接口)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%E5%9C%A8-DTO-%E4%B8%8A%E6%8C%87%E5%AE%9A%E5%88%86%E7%BB%84"><span class="nav-text">4.3.2 在 DTO 上指定分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-%E5%9C%A8-Controller-%E4%B8%AD%E6%8C%87%E5%AE%9A%E5%88%86%E7%BB%84"><span class="nav-text">4.3.3 在 Controller 中指定分组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3-%E8%BF%9B%E9%98%B6"><span class="nav-text">4.4 自定义校验注解 (进阶)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD"><span class="nav-text">5. 文件上传与下载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="nav-text">5.1 文件上传</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-%E5%89%8D%E7%AB%AF%E8%A1%A8%E5%8D%95%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-text">5.1.1 前端表单三要素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-%E4%BE%9D%E8%B5%96%E5%BC%95%E5%85%A5-pom-xml-SSM-%E5%9C%BA%E6%99%AF"><span class="nav-text">5.1.2 依赖引入 (pom.xml - SSM 场景)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-SpringMVC-%E9%85%8D%E7%BD%AE-spring-mvc-xml-SSM-%E5%9C%BA%E6%99%AF"><span class="nav-text">5.1.3 SpringMVC 配置 (spring-mvc.xml - SSM 场景)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-Controller-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">5.1.4 Controller 代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD"><span class="nav-text">5.2 文件下载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-%E4%B8%8B%E8%BD%BD%E8%BE%85%E5%8A%A9%E4%BE%9D%E8%B5%96"><span class="nav-text">5.2.1 下载辅助依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0-%E5%B0%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD"><span class="nav-text">5.2.2 核心实现 (小文件下载)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3-%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E4%BC%98%E5%8C%96-StreamingResponseBody"><span class="nav-text">5.2.3 大文件下载优化 (StreamingResponseBody)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%AE%9E%E6%88%98%E9%81%BF%E5%9D%91%EF%BC%9A%E8%99%9A%E6%8B%9F%E8%B7%AF%E5%BE%84%E6%98%A0%E5%B0%84"><span class="nav-text">5.3 实战避坑：虚拟路径映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E5%A4%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="nav-text">5.4 多文件上传</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3%E5%89%96%E6%9E%90%EF%BC%9AMultipartFile-%E4%B8%8E-Part"><span class="nav-text">5.5 核心接口剖析：MultipartFile 与 Part</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-1-%E4%BB%80%E4%B9%88%E6%98%AF-MultipartFile%EF%BC%9F"><span class="nav-text">5.5.1 什么是 MultipartFile？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-2-MultipartFile-%E4%B8%8E-Part-%E7%9A%84%E5%85%B3%E7%B3%BB-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-text">5.5.2 MultipartFile 与 Part 的关系 (适配器模式)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E7%94%A8-MultipartFile-%E8%80%8C%E4%B8%8D%E6%98%AF-Part%EF%BC%9F"><span class="nav-text">5.5.3 为什么推荐用 MultipartFile 而不是 Part？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81SpringMVC-%E9%85%8D%E7%BD%AE%E8%BF%9B%E5%8C%96%E8%AE%BA%EF%BC%88%E4%BB%8E-SSM-%E5%88%B0-Boot%EF%BC%89"><span class="nav-text">七、SpringMVC 配置进化论（从 SSM 到 Boot）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%E7%9A%84%E6%BC%94%E5%8F%98"><span class="nav-text">1. 配置方式的演变</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-Web-xml-SpringXML-%E8%80%83%E5%8F%A4%E7%BA%A7-1-0-%E6%97%B6%E4%BB%A3"><span class="nav-text">1.1 Web.xml + SpringXML (考古级 - 1.0 时代)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Java-Config-%E5%85%A8%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F-%E5%8E%9F%E7%90%86%E7%BA%A7-2-0-%E6%97%B6%E4%BB%A3"><span class="nav-text">1.2 Java Config 全注解方式 (原理级 - 2.0 时代)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E6%9B%BF%E4%BB%A3-web-xml-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-text">1.2.1 替代 web.xml 的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E6%9B%BF%E4%BB%A3-spring-mvc-xml-%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">1.2.2 替代 spring-mvc.xml 的方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-WebMvcConfigurer-%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3-%E6%A0%B8%E5%BF%83%E9%87%8D%E7%82%B9"><span class="nav-text">2. WebMvcConfigurer 接口详解 (核心重点)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AF-WebMvcConfigurer%EF%BC%9F"><span class="nav-text">2.1 什么是 WebMvcConfigurer？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%E5%AE%9E%E6%88%98"><span class="nav-text">2.2 常用配置方法实战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%80%BB%E7%BB%93%EF%BC%9A%E4%BB%8E-SSM-%E5%88%B0-Boot-%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="nav-text">2.3 总结：从 SSM 到 Boot 的映射关系</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringMVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Spring全家桶-SpringMVC | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring全家桶-SpringMVC
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-05 14:27:02" itemprop="dateCreated datePublished" datetime="2025-10-05T14:27:02+08:00">2025-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2026-02-02 15:44:25" itemprop="dateModified" datetime="2026-02-02T15:44:25+08:00">2026-02-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/" itemprop="url" rel="index"><span itemprop="name">Spring全家桶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="一、SpringMVC-核心概念与演进"><a href="#一、SpringMVC-核心概念与演进" class="headerlink" title="一、SpringMVC 核心概念与演进"></a>一、SpringMVC 核心概念与演进</h1><h2 id="1-Web开发演进史"><a href="#1-Web开发演进史" class="headerlink" title="1. Web开发演进史"></a>1. Web开发演进史</h2><p>Web 开发一直在解决一个核心矛盾：<strong>业务逻辑（Java 代码）与 页面展示（HTML 代码）的耦合问题。</strong></p>
<h3 id="第一阶段：Servlet-史前时代（由-Java-硬写-HTML）"><a href="#第一阶段：Servlet-史前时代（由-Java-硬写-HTML）" class="headerlink" title="第一阶段：Servlet 史前时代（由 Java 硬写 HTML）"></a>第一阶段：Servlet 史前时代（由 Java 硬写 HTML）</h3><blockquote>
<p><em><strong>地位</strong>：Web 的底层基石，但现代开发中不再直接写它。</em></p>
</blockquote>
<ul>
<li><p><strong>工作模式</strong>：<br>所有的请求处理、数据库连接、甚至 HTML 标签的拼接，全部堆在一个 Java 类（Servlet）里。</p>
</li>
<li><p><strong>代码示例（伪代码）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> &#123;</span><br><span class="line">    resp.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">    <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">    <span class="comment">// 噩梦开始：在 Java 字符串里拼 HTML</span></span><br><span class="line">    out.println(<span class="string">&quot;&lt;html&gt;&lt;body&gt;&quot;</span>);</span><br><span class="line">    out.println(<span class="string">&quot;&lt;h1&gt;你好，&quot;</span> + username + <span class="string">&quot;&lt;/h1&gt;&quot;</span>); </span><br><span class="line">    out.println(<span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>痛点</strong>：</p>
<ol>
<li><strong>开发地狱</strong>：修改一个页面样式需要重新编译 Java 代码。</li>
<li><strong>维护困难</strong>：逻辑代码和 HTML 标签混杂，可读性为零。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="第二阶段：JSP-时代（Model-1-混沌期）"><a href="#第二阶段：JSP-时代（Model-1-混沌期）" class="headerlink" title="第二阶段：JSP 时代（Model 1 - 混沌期）"></a>第二阶段：JSP 时代（Model 1 - 混沌期）</h3><blockquote>
<p><em><strong>地位</strong>：已淘汰。但在极老的旧项目中可能看到。</em></p>
</blockquote>
<ul>
<li><p><strong>工作模式</strong>：<br>为了解决 Servlet 拼 HTML 的痛苦，Sun 推出了 JSP。允许在 HTML 里写 Java 代码。结果导致人们把 SQL、逻辑全写在页面里。</p>
</li>
<li><p><strong>架构流程</strong>：</p>
<ul>
<li>Client -&gt; JSP (接收请求 -&gt; 调 Java Bean 查数据库 -&gt; 渲染页面) -&gt; Client</li>
</ul>
</li>
<li><p><strong>代码示例（JSP）</strong>：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 直接在页面里连数据库，写逻辑 --&gt;</span><br><span class="line">&lt;% </span><br><span class="line">   <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(...);</span><br><span class="line">   <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;h1&gt;你好，&lt;%= name %&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>痛点</strong>：</p>
<ol>
<li><strong>职责不清</strong>：JSP 既当爹（逻辑）又当妈（视图），极其臃肿。</li>
<li><strong>无法测试</strong>：业务逻辑嵌在 HTML 里，根本没法写单元测试。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="概念突围：MVC-模式的诞生"><a href="#概念突围：MVC-模式的诞生" class="headerlink" title="概念突围：MVC 模式的诞生"></a>概念突围：MVC 模式的诞生</h3><p><strong>面对 JSP 里几千行混杂着 SQL、Java 和 HTML 的“面条代码”，开发者们痛定思痛，引入了经典的软件架构模式——MVC。</strong></p>
<blockquote>
<p><strong>地位</strong>：软件工程的里程碑。它制定了“各司其职”的规则，一直沿用至今。</p>
</blockquote>
<p>MVC 全称 <strong>Model-View-Controller</strong>，它的核心目的是<strong>关注点分离</strong>。</p>
<ul>
<li><strong>M - Model（模型）</strong>：<ul>
<li><strong>职责</strong>：负责处理业务逻辑（Service）、保存数据状态（Entity）、与数据库交互（DAO）。</li>
<li><strong>特点</strong>：它不知道网页长什么样，只管数据对不对。</li>
</ul>
</li>
<li><strong>V - View（视图）</strong>：<ul>
<li><strong>职责</strong>：负责将数据展示给用户（HTML&#x2F;JSP&#x2F;JSON）。</li>
<li><strong>特点</strong>：它不应该包含复杂的逻辑，越傻瓜越好，只负责“显示”。</li>
</ul>
</li>
<li><strong>C - Controller（控制器）</strong>：<ul>
<li><strong>职责</strong>：负责接收用户请求，命令 Model 处理业务，然后选择一个 View 将结果返回给用户。</li>
<li><strong>特点</strong>：起到桥梁作用，把 M 和 V 粘合起来。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="第三阶段：MVC-启蒙时代（Model-2-Servlet-JSP）"><a href="#第三阶段：MVC-启蒙时代（Model-2-Servlet-JSP）" class="headerlink" title="第三阶段：MVC 启蒙时代（Model 2 - Servlet + JSP）"></a>第三阶段：MVC 启蒙时代（Model 2 - Servlet + JSP）</h3><blockquote>
<p><em><strong>地位</strong>：MVC 思想的雏形，现代框架的底层原理。</em></p>
</blockquote>
<ul>
<li><strong>工作模式</strong>：<br>开始有了明确分工。<ul>
<li><strong>Servlet (Controller)</strong>：接收请求，调 Service 处理数据，把数据塞进 <code>request</code>，<strong>转发</strong>给 JSP。</li>
<li><strong>JSP (View)</strong>：只负责用 EL 表达式 (<code>${user.name}</code>) 显示数据，不写逻辑。</li>
</ul>
</li>
<li><strong>痛点</strong>：<br>虽然结构清晰了，但原生 Servlet 开发太繁琐（手动获取参数、手动类型转换、if-else 满天飞），导致开发效率低。</li>
</ul>
<hr>
<h3 id="第四阶段：传统-MVC-框架时代（SSM-Spring-Boot-Thymeleaf）"><a href="#第四阶段：传统-MVC-框架时代（SSM-Spring-Boot-Thymeleaf）" class="headerlink" title="第四阶段：传统 MVC 框架时代（SSM &#x2F; Spring Boot + Thymeleaf）"></a>第四阶段：传统 MVC 框架时代（SSM &#x2F; Spring Boot + Thymeleaf）</h3><blockquote>
<p><em><strong>地位</strong>：服务端渲染 (SSR)的巅峰。目前用于企业内部系统、SEO 要求高的官网。</em></p>
</blockquote>
<ul>
<li><p><strong>工作模式</strong>：<br>引入 <strong>Spring MVC</strong>。它用一个核心 Servlet (<code>DispatcherServlet</code>) 揽下了所有脏活累活。开发者只需写简单的 Controller。<br><strong>此时，后端依然控制着页面跳转，返回的是“页面视图”。</strong></p>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span> <span class="comment">// 注意：这里是 @Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.find();</span><br><span class="line">        model.addAttribute(<span class="string">&quot;u&quot;</span>, user); <span class="comment">// 把数据塞给视图</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user_detail&quot;</span>; <span class="comment">// 返回视图名称，Spring 去找 user_detail.html</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>痛点（导致进化的原因）</strong>：</p>
<ol>
<li><strong>移动端无法适配</strong>：后端返回的是 HTML 网页，iOS 和 Android App 根本看不懂，它们需要 JSON 数据。</li>
<li><strong>前端受制于人</strong>：前端写好 HTML 必须交给后端改写成模板（Thymeleaf&#x2F;JSP），前后端耦合紧密，联调效率低。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="第五阶段：现代-MVC-与前后端分离（RESTful-API）"><a href="#第五阶段：现代-MVC-与前后端分离（RESTful-API）" class="headerlink" title="第五阶段：现代 MVC 与前后端分离（RESTful API）"></a>第五阶段：现代 MVC 与前后端分离（RESTful API）</h3><blockquote>
<p><strong>地位</strong>：<strong>当前主流</strong>。90% 的互联网公司开发模式。</p>
</blockquote>
<p>这是一个分水岭。<strong>后端不再负责“画”页面，只负责“给”数据。</strong></p>
<ul>
<li><p><strong>工作模式</strong>：</p>
<ul>
<li><strong>后端</strong>：Spring Boot 提供 RESTful 接口，返回 <strong>JSON</strong> 数据。</li>
<li><strong>前端</strong>：Vue&#x2F;React&#x2F;Angular 独立部署，通过 HTTP 请求调用后端接口，拿到 JSON 后自己渲染页面。</li>
<li><strong>MVC 的变化</strong>：在后端视角里，View 层退化为 JSON 序列化器。</li>
</ul>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span> <span class="comment">// 核心变化：@ResponseBody + @Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApiController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 直接返回 Java 对象</span></span><br><span class="line">        <span class="comment">// Spring Boot 会自动使用 Jackson 将其转换为 JSON：&#123;&quot;id&quot;:1, &quot;name&quot;:&quot;张三&quot;&#125;</span></span><br><span class="line">        <span class="keyword">return</span> userService.findById(id); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优势</strong>：</p>
<ol>
<li><strong>多端通用</strong>：一套接口，Web、手机 App、小程序通吃。</li>
<li><strong>并行开发</strong>：前后端约定好 API 文档后，可以同时开工，互不干扰。</li>
<li><strong>生态丰富</strong>：前端工程化飞速发展，用户体验远超传统网页。</li>
</ol>
</li>
<li><p><strong>新挑战（痛点）</strong>：</p>
<ol>
<li><strong>跨域问题 (CORS)</strong>：前后端域名不同，需要配置跨域许可。</li>
<li><strong>鉴权变复杂</strong>：传统的 Session 不好用了，需要引入 JWT (JSON Web Token) 或 OAuth2。</li>
<li><strong>沟通成本</strong>：接口文档如果写得不好，前后端容易扯皮。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="第六阶段：微服务与云原生（Microservices-Reactive）"><a href="#第六阶段：微服务与云原生（Microservices-Reactive）" class="headerlink" title="第六阶段：微服务与云原生（Microservices &amp; Reactive）"></a>第六阶段：微服务与云原生（Microservices &amp; Reactive）</h3><blockquote>
<p><strong>地位</strong>：架构师&#x2F;高级开发领域。用于高并发、大规模系统。</p>
</blockquote>
<p>当单体应用大到难以维护时，MVC 架构被拆分为微服务。</p>
<ul>
<li><strong>工作模式</strong>：<ul>
<li><strong>拆分</strong>：原来的一个大 MVC 项目被拆成“用户服务”、“订单服务”、“支付服务”。</li>
<li><strong>网关 (Gateway)</strong>：Controller 的入口功能被统一的网关层接管。</li>
<li><strong>响应式 (WebFlux)</strong>：为了极致性能，抛弃 Servlet 线程模型，改用异步非阻塞（Netty）。</li>
</ul>
</li>
<li><strong>核心特征</strong>：<ul>
<li>HTTP 变成了 RPC 调用（Feign &#x2F; Dubbo）。</li>
<li>返回的不再是对象，而是流（<code>Mono&lt;User&gt;</code>, <code>Flux&lt;Order&gt;</code>）。</li>
</ul>
</li>
<li><strong>痛点</strong>：<br>分布式事务、服务治理、链路追踪等复杂性急剧增加。</li>
</ul>
<hr>
<h2 id="2-SpringMVC-概念"><a href="#2-SpringMVC-概念" class="headerlink" title="2. SpringMVC 概念"></a>2. SpringMVC 概念</h2><h3 id="2-1-什么是SpringMVC"><a href="#2-1-什么是SpringMVC" class="headerlink" title="2.1 什么是SpringMVC"></a>2.1 什么是SpringMVC</h3><blockquote>
<p><em>官方定义：Spring Web MVC is the original web framework built on the Servlet API and has been included in the Spring Framework from the very beginning.</em></p>
</blockquote>
<ul>
<li><strong>通俗解释</strong>：<br>SpringMVC 是 Spring 框架中的一个<strong>模块</strong>（子项目），专门用于构建 Web 应用。它基于 <strong>Servlet API</strong> 构建，严格遵循 <strong>MVC 设计模式</strong>。</li>
<li><strong>核心地位</strong>：它不是一个独立存在的框架，而是 Spring 生态系统的一部分。这意味着它<strong>天生就能无缝集成 Spring 的核心功能</strong>。</li>
</ul>
<hr>
<h3 id="2-2-Servlet-3-0-与-SpringMVC-的去-XML-化"><a href="#2-2-Servlet-3-0-与-SpringMVC-的去-XML-化" class="headerlink" title="2.2  Servlet 3.0 与 SpringMVC 的去 XML 化"></a>2.2  Servlet 3.0 与 SpringMVC 的去 XML 化</h3><p>标志着 <code>web.xml</code> 时代的终结和“全注解&#x2F;JavaConfig”时代的开启。</p>
<h4 id="2-2-1-史前时代：web-xml-的垄断"><a href="#2-2-1-史前时代：web-xml-的垄断" class="headerlink" title="2.2.1 史前时代：web.xml 的垄断"></a>2.2.1 史前时代：web.xml 的垄断</h4><p>在 Servlet 3.0（Java EE 6）之前，Tomcat 启动时<strong>必须</strong>读取 <code>WEB-INF/web.xml</code>。我们需要在这个文件中手动配置 <code>DispatcherServlet</code>，否则容器根本不知道如何分发请求。这是物理层面的限制。</p>
<hr>
<h4 id="2-2-2-变革点：SPI-机制与-ServletContainerInitializer"><a href="#2-2-2-变革点：SPI-机制与-ServletContainerInitializer" class="headerlink" title="2.2.2 变革点：SPI 机制与 ServletContainerInitializer"></a>2.2.2 变革点：SPI 机制与 ServletContainerInitializer</h4><p>Servlet 3.0 规范引入了一个新特性：<strong>SPI (Service Provider Interface)</strong> 扩展机制。</p>
<ul>
<li><strong>原理</strong>：Tomcat（或任何 Servlet 容器）在启动时，会扫描所有 jar 包下的 <code>META-INF/services/javax.servlet.ServletContainerInitializer</code> 文件。</li>
<li><strong>作用</strong>：这个文件里指定了哪些类需要在容器启动时自动执行。</li>
</ul>
<hr>
<h4 id="2-2-3-SpringMVC-如何实现“零-XML”启动？"><a href="#2-2-3-SpringMVC-如何实现“零-XML”启动？" class="headerlink" title="2.2.3 SpringMVC 如何实现“零 XML”启动？"></a>2.2.3 SpringMVC 如何实现“零 XML”启动？</h4><p>SpringMVC 利用了这个特性，彻底抛弃了 <code>web.xml</code>。执行链路如下：</p>
<ol>
<li><strong>容器启动</strong>：Tomcat 启动，扫描 jar 包。</li>
<li><strong>发现 SPI</strong>：在 <code>spring-web.jar</code> 中找到了 <code>META-INF/services/javax.servlet.ServletContainerInitializer</code> 文件。</li>
<li><strong>加载入口</strong>：该文件指向了 <code>SpringServletContainerInitializer</code> 类。</li>
<li><strong>回调执行</strong>：Tomcat 实例化这个类，并调用它的 <code>onStartup()</code> 方法。</li>
<li><strong>用户代码介入</strong>：Spring 的这个初始化器会去扫描用户代码中实现了 <code>WebApplicationInitializer</code> 接口的类（比如我们常用的 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 或 Spring Boot 的启动类逻辑），并执行其中的配置。</li>
</ol>
<hr>
<h1 id="二、核心架构与执行流程"><a href="#二、核心架构与执行流程" class="headerlink" title="二、核心架构与执行流程"></a>二、核心架构与执行流程</h1><h2 id="1-核心组件详解"><a href="#1-核心组件详解" class="headerlink" title="1. 核心组件详解"></a>1. 核心组件详解</h2><h3 id="1-1-核心组件"><a href="#1-1-核心组件" class="headerlink" title="1.1 核心组件"></a>1.1 核心组件</h3><h4 id="1-1-1-前端控制器-DispatcherServlet"><a href="#1-1-1-前端控制器-DispatcherServlet" class="headerlink" title="1.1.1 前端控制器 (DispatcherServlet)"></a>1.1.1 前端控制器 (DispatcherServlet)</h4><ul>
<li><strong>地位</strong>：<strong>整个 SpringMVC 框架的核心调度中心</strong>。</li>
<li><strong>作用</strong>：<ul>
<li>负责接收客户端发送的 HTTP 请求。</li>
<li>作为统一的访问入口，它并不直接处理业务，而是根据请求信息分发给其他组件（如 HandlerMapping、HandlerAdapter 等）进行处理。</li>
<li>负责协调各个组件的执行流程，并将最终响应结果返回给客户端。</li>
</ul>
</li>
<li><strong>源码位置</strong>：<code>org.springframework.web.servlet.DispatcherServlet</code></li>
<li><strong>注意事项</strong>：<ul>
<li>需要在 <code>web.xml</code> 或 Java 配置类（继承 <code>AbstractAnnotationConfigDispatcherServletInitializer</code>）中进行配置。</li>
<li>它继承自 <code>HttpServlet</code>，其核心处理逻辑位于 <code>doDispatch()</code> 方法中。</li>
<li>在初始化时会加载并实例化 SpringMVC 的其他组件。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-2-处理器映射器-HandlerMapping"><a href="#1-1-2-处理器映射器-HandlerMapping" class="headerlink" title="1.1.2 处理器映射器 (HandlerMapping)"></a>1.1.2 处理器映射器 (HandlerMapping)</h4><ul>
<li><strong>地位</strong>：<strong>请求路由解析组件</strong>。</li>
<li><strong>作用</strong>：<ul>
<li>根据请求的 URL、Method（GET&#x2F;POST）等信息，查找对应的处理器（Handler）。</li>
<li>返回一个 <strong>处理器执行链 (HandlerExecutionChain)</strong>。该链不仅包含具体的处理器对象，还包含配置在该请求上的所有 <strong>拦截器 (HandlerInterceptor)</strong>。</li>
</ul>
</li>
<li><strong>核心实现</strong>：<ul>
<li><code>RequestMappingHandlerMapping</code>：目前最常用的实现，专门处理 <code>@RequestMapping</code> 注解映射。</li>
<li><code>BeanNameUrlHandlerMapping</code>：早期实现，根据 Bean 的名称进行 URL 匹配。</li>
</ul>
</li>
<li><strong>注意事项</strong>：<ul>
<li>SpringMVC 容器中可以同时存在多个 HandlerMapping，<code>DispatcherServlet</code> 会按照优先级（Order）依次查找，直到找到能处理该请求的 HandlerMapping。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-3-处理器适配器-HandlerAdapter"><a href="#1-1-3-处理器适配器-HandlerAdapter" class="headerlink" title="1.1.3 处理器适配器 (HandlerAdapter)"></a>1.1.3 处理器适配器 (HandlerAdapter)</h4><ul>
<li><strong>地位</strong>：<strong>执行适配组件</strong>。</li>
<li><strong>作用</strong>：<ul>
<li>负责<strong>真正调用</strong>处理器（Handler）中的方法。</li>
<li><strong>参数解析与绑定</strong>：它在调用 Handler 方法前，会利用 <code>HandlerMethodArgumentResolver</code> 对 HTTP 请求中的参数（Param, Header, Body 等）进行解析，并绑定到方法的形式参数上（包括数据类型转换）。</li>
<li><strong>返回值处理</strong>：调用完成后，将 Handler 的返回值（如 <code>ModelAndView</code> 或 <code>@ResponseBody</code> 数据）利用 <code>HandlerMethodReturnValueHandler</code> 进行处理。</li>
</ul>
</li>
<li><strong>核心实现</strong>：<code>RequestMappingHandlerAdapter</code>。</li>
<li><strong>架构意义</strong>：<ul>
<li>实现了处理器（Handler）与前端控制器（DispatcherServlet）的解耦。无论 Handler 是 Servlet、Controller 接口实现类还是 POJO 方法，DispatcherServlet 仅需调用适配器的统一接口 <code>handle()</code>，无需关心具体的调用细节。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-4-处理器-Handler"><a href="#1-1-4-处理器-Handler" class="headerlink" title="1.1.4 处理器 (Handler)"></a>1.1.4 处理器 (Handler)</h4><ul>
<li><strong>地位</strong>：<strong>业务逻辑处理器</strong>。</li>
<li><strong>作用</strong>：<ul>
<li>即我们自己编写的 <strong>Controller</strong> 层代码。</li>
<li>负责接收适配器传递的参数，调用业务层（Service）逻辑，处理数据，并返回处理结果（逻辑视图名或 JSON&#x2F;XML 数据）。</li>
</ul>
</li>
<li><strong>注意事项</strong>：<ul>
<li>Handler 在 SpringMVC 中并没有强制特定的接口限制（早期需实现 <code>Controller</code> 接口，但在注解驱动开发中通常是一个普通的 POJO）。</li>
<li>Handler 的执行由 <code>HandlerAdapter</code> 驱动，而不是由 <code>DispatcherServlet</code> 直接反射调用。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-5-消息转换器（HttpMessageConverter）"><a href="#1-1-5-消息转换器（HttpMessageConverter）" class="headerlink" title="1.1.5  消息转换器（HttpMessageConverter）"></a>1.1.5  消息转换器（HttpMessageConverter）</h4><blockquote>
<p><em><strong>注意</strong>：在 RESTful API 开发中，</em><code>ViewResolver</code> <em>(视图解析器)的已被</em> <code>HttpMessageConverter</code> <em>取代。</em></p>
</blockquote>
<ul>
<li><strong>地位</strong>：<strong>数据转换处理器</strong></li>
<li><strong>作用</strong>：<ul>
<li>负责 <strong>“Java 对象”</strong> 与 <strong>“HTTP 数据流”</strong> 之间的相互转换。</li>
</ul>
</li>
<li><strong>双向转换机制</strong>：<ul>
<li><strong>Read (Input)</strong>：处理请求。当 Controller 参数带有 <code>@RequestBody</code> 时，Converter 将 HTTP 请求体（InputStream, 通常是 JSON）转换为 Java 对象。</li>
<li><strong>Write (Output)</strong>：处理响应。当 Controller 方法带有 <code>@ResponseBody</code> 或类上有 <code>@RestController</code> 时，Converter 将方法的返回值（Java Object）序列化为响应体（OutputStream, 通常是 JSON）。</li>
</ul>
</li>
<li><strong>核心实现</strong>：<ul>
<li><code>MappingJackson2HttpMessageConverter</code>：<strong>默认且最重要</strong>。利用 Jackson 库将 Java 对象转为 JSON。</li>
<li><code>StringHttpMessageConverter</code>：处理字符串类型。</li>
<li><code>ByteArrayHttpMessageConverter</code>：处理文件下载&#x2F;二进制流。</li>
</ul>
</li>
<li><strong>内容协商</strong>：<ul>
<li>它如何知道转成 JSON 还是 XML？</li>
<li>取决于请求头中的 <code>Accept</code> (例如 <code>application/json</code>) 和服务器端的配置。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-为什么-HttpMessageConverter-替代了-ViewResolver？"><a href="#1-2-为什么-HttpMessageConverter-替代了-ViewResolver？" class="headerlink" title="1.2 为什么 HttpMessageConverter 替代了 ViewResolver？"></a>1.2 为什么 HttpMessageConverter 替代了 ViewResolver？</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">ViewResolver (传统模式)</th>
<th align="left">HttpMessageConverter (现代模式)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>触发场景</strong></td>
<td align="left">方法返回 String (视图名) 或 ModelAndView</td>
<td align="left">方法标记 <code>@ResponseBody</code> &#x2F; <code>@RestController</code></td>
</tr>
<tr>
<td align="left"><strong>处理对象</strong></td>
<td align="left">JSP, Thymeleaf, Freemarker</td>
<td align="left">JSON, XML, String, Byte[]</td>
</tr>
<tr>
<td align="left"><strong>核心逻辑</strong></td>
<td align="left">服务端渲染 HTML (SSR)</td>
<td align="left">序列化数据对象</td>
</tr>
<tr>
<td align="left"><strong>客户端接收</strong></td>
<td align="left">完整的 HTML 页面</td>
<td align="left">纯数据，由前端 JS 渲染</td>
</tr>
<tr>
<td align="left"><strong>当下地位</strong></td>
<td align="left">次要 (用于部分后台管理系统或 SEO 需求)</td>
<td align="left"><strong>核心 (95% 的业务场景)</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="1-3-辅助组件"><a href="#1-3-辅助组件" class="headerlink" title="1.3 辅助组件"></a>1.3 辅助组件</h3><h4 id="1-3-1-HandlerExceptionResolver-异常解析器"><a href="#1-3-1-HandlerExceptionResolver-异常解析器" class="headerlink" title="1.3.1 HandlerExceptionResolver (异常解析器)"></a>1.3.1 HandlerExceptionResolver (异常解析器)</h4><ul>
<li><strong>地位</strong>：<strong>全局异常处理策略接口</strong>。</li>
<li><strong>作用</strong>：<ul>
<li>负责捕获在 Controller 执行过程中（包括拦截器 <code>preHandle</code> 之后）抛出的未处理异常。</li>
<li>将异常映射到具体的视图（View）或错误响应数据（JSON），从而避免直接向用户展示不友好的 Java 堆栈信息。</li>
<li>实现了异常处理逻辑与业务逻辑的解耦。</li>
</ul>
</li>
<li><strong>核心实现</strong>：<ul>
<li><code>ExceptionHandlerExceptionResolver</code>：SpringMVC 默认且最重要的实现，负责处理 <code>@ExceptionHandler</code> 注解。</li>
<li><code>ResponseStatusExceptionResolver</code>：处理 <code>@ResponseStatus</code> 注解的异常。</li>
<li><code>DefaultHandlerExceptionResolver</code>：处理 SpringMVC 内部的标准异常（如 405 Method Not Allowed）。</li>
</ul>
</li>
<li><strong>注意事项</strong>：<ul>
<li><strong>优先级</strong>：容器中可能存在多个异常解析器，它们按照 Order 属性排序执行。</li>
<li><strong>开发实践</strong>：现代 SpringMVC 开发通常结合 <code>@ControllerAdvice</code> 和 <code>@ExceptionHandler</code> 来实现全局统一的异常处理。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-2-MultipartResolver-文件上传解析器"><a href="#1-3-2-MultipartResolver-文件上传解析器" class="headerlink" title="1.3.2 MultipartResolver (文件上传解析器)"></a>1.3.2 MultipartResolver (文件上传解析器)</h4><ul>
<li><strong>地位</strong>：<strong>多部分请求解析策略</strong>。</li>
<li><strong>作用</strong>：<ul>
<li>检测当前 HTTP 请求的 <code>Content-Type</code> 是否为 <code>multipart/form-data</code>。</li>
<li>将标准的 <code>HttpServletRequest</code> 包装成 <code>MultipartHttpServletRequest</code>。</li>
<li>解析请求体中的文件数据，封装为 <code>MultipartFile</code> 对象，方便开发者读取文件内容、文件名及保存文件。</li>
</ul>
</li>
<li><strong>核心实现</strong>：<ul>
<li><code>StandardServletMultipartResolver</code>：基于 Servlet 3.0+ 标准 API 实现（推荐，无需额外依赖）。</li>
<li><code>CommonsMultipartResolver</code>：基于 Apache Commons FileUpload 组件实现（传统方式，需引入依赖）。</li>
</ul>
</li>
<li><strong>注意事项</strong>：<ul>
<li><strong>Bean 名称限制</strong>：在 Spring 配置文件中配置该 Bean 时，<strong>id 必须命名为 <code>multipartResolver</code></strong>。<code>DispatcherServlet</code> 在初始化时是根据名称（ByName）而不是类型查找该组件的。</li>
<li><strong>配置参数</strong>：通常需要配置最大上传大小（maxUploadSize）和内存缓冲区大小。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-执行流程"><a href="#2-执行流程" class="headerlink" title="2. 执行流程"></a>2. 执行流程</h2><h3 id="2-1-流程图"><a href="#2-1-流程图" class="headerlink" title="2.1 流程图"></a>2.1 流程图</h3><p>下面是当一个HTTP请求（例如 <code>GET /users/123</code>）到达时，Spring MVC内部发生的详细步骤：</p>
<pre><code class="highlight mermaid">sequenceDiagram
    actor Client

    title Spring MVC DispatcherServlet 工作流程
    Client-&gt;&gt;+DS: 1. HTTP Request (JSON/Params)
    
    DS-&gt;&gt;HM: 2. 查询能处理请求的Handler
    HM--&gt;&gt;DS: 3. 返回HandlerExecutionChain (含Controller方法和Interceptors)

    DS-&gt;&gt;+HA: 4. 请求HandlerAdapter执行Handler
    
    note right of HA: 执行拦截器的 preHandle 方法
    HA-&gt;&gt;I: 5a. Interceptor.preHandle()
    I--&gt;&gt;HA: (若返回false, 则中断流程)

    note right of HA: 参数解析、数据转换、数据校验等
    HA-&gt;&gt;+C: 5b. 通过反射调用Controller方法 (@RestController)
    
    C-&gt;&gt;S: 调用 Service 业务逻辑
    S--&gt;&gt;C: 返回业务对象

    note right of C: 关键步骤：消息转换
    C-&gt;&gt;HMC: 6a. 触发 HttpMessageConverter
    note right of HMC: 将对象序列化为 JSON
    HMC--&gt;&gt;C: 写入 HTTP Response Body

    C--&gt;&gt;-HA: 6b. 方法执行结束 (通常返回 null 或 Empty ModelAndView)
    note right of HA: 执行拦截器的 postHandle
    HA-&gt;&gt;I: 7. Interceptor.postHandle()
    note right of I: (REST场景下ModelAndView通常为空&lt;br&gt;很少在此操作)
    I--&gt;&gt;HA: 
    
    HA--&gt;&gt;-DS: 8. 执行结束返回

    note left of DS: 无需视图解析，直接处理后续
    DS-&gt;&gt;I: 9a. 执行Interceptor.afterCompletion()
    I--&gt;&gt;DS: 
    
    DS--&gt;&gt;-Client: 9b. 响应客户端 (application/json)</code></pre>

<hr>
<h3 id="2-2-执行流程详解"><a href="#2-2-执行流程详解" class="headerlink" title="2.2 执行流程详解"></a>2.2 执行流程详解</h3><h4 id="第一阶段：请求映射"><a href="#第一阶段：请求映射" class="headerlink" title="第一阶段：请求映射"></a>第一阶段：请求映射</h4><ol>
<li><strong>请求到达前端控制器 (<code>DispatcherServlet</code>)</strong><ul>
<li>客户端发送请求（通常携带 JSON 数据或 URL 参数）。</li>
<li>请求首先到达 Web 服务器（如 Tomcat），被 <code>DispatcherServlet</code> 拦截。</li>
</ul>
</li>
<li><strong>查找处理器 (<code>HandlerMapping</code>)</strong><ul>
<li><code>DispatcherServlet</code> 携带请求信息查询 <code>HandlerMapping</code>。</li>
<li><strong>核心动作</strong>：系统根据 URL（如 <code>/user/login</code>）匹配找到对应的 <code>HandlerMethod</code>（Controller 中的方法）。</li>
<li><strong>产出</strong>：返回一个 <strong>执行链 (<code>HandlerExecutionChain</code>)</strong>。<ul>
<li><em>注意</em>：这个链包含两部分：<strong>目标处理器 (Handler)</strong> + <strong>拦截器集合 (Interceptors)</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>请求适配器 (<code>HandlerAdapter</code>)</strong><ul>
<li><code>DispatcherServlet</code> 根据 Handler 的类型，寻找支持该 Handler 的适配器（通常是 <code>RequestMappingHandlerAdapter</code>）。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="第二阶段：业务执行与数据序列化"><a href="#第二阶段：业务执行与数据序列化" class="headerlink" title="第二阶段：业务执行与数据序列化"></a>第二阶段：业务执行与数据序列化</h4><ol>
<li>**前置拦截 **<ul>
<li>在执行 Handler 之前，按顺序执行所有拦截器的 <code>preHandle()</code> 方法。如果拦截器返回 <code>false</code>，流程直接中断。（常用于 Token 校验、CORS 检查、限流）。</li>
</ul>
</li>
<li>**参数绑定与反序列化 **<ul>
<li><strong>关键点</strong>：如果参数带有 <code>@RequestBody</code>，<code>HandlerAdapter</code> 会使用 <code>HttpMessageConverter</code>（如 Jackson）将请求体中的 <strong>JSON 字符串反序列化为 Java 对象</strong>。</li>
<li>同时处理 <code>@PathVariable</code>, <code>@RequestParam</code> 等参数。</li>
</ul>
</li>
<li><strong>反射执行与响应写入</strong><ul>
<li>一切准备就绪后，适配器通过 <strong>反射机制 (Reflection)</strong> 调用 Controller 方法，执行业务逻辑。</li>
<li><strong>核心差异</strong>：方法返回一个纯 Java 对象（如 <code>User</code>, <code>Result&lt;T&gt;</code>, <code>List&lt;Data&gt;</code>），而不是 <code>ModelAndView</code>。</li>
</ul>
</li>
<li><strong>消息转换 (<code>HttpMessageConverter</code>)</strong><ul>
<li>由于方法被 <code>@ResponseBody</code> 注解（或类被 <code>@RestController</code> 注解），Spring <strong>不再寻找视图</strong>。</li>
<li>Spring 找到合适的 <code>HttpMessageConverter</code>（通常是 <code>MappingJackson2HttpMessageConverter</code>）。</li>
<li><strong>动作</strong>：将 Controller 返回的 Java 对象 <strong>序列化为 JSON 格式</strong>。</li>
<li><strong>输出</strong>：直接将 JSON 数据写入 <code>HttpServletResponse</code> 的输出流中，并设置 Content-Type 为 <code>application/json</code>。</li>
</ul>
</li>
<li><strong>后置拦截 (<code>postHandle</code>)</strong><ul>
<li>适配器在返回前，按逆序执行拦截器的 <code>postHandle()</code> 方法。</li>
<li><em>注意</em>：在 REST 场景下，由于数据已经写入响应流且视图为 null，这个方法的作用大大降低（无法再修改响应体内容）。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="第三阶段：请求结束"><a href="#第三阶段：请求结束" class="headerlink" title="第三阶段：请求结束"></a>第三阶段：请求结束</h4><ol>
<li><strong>跳过视图解析</strong><ul>
<li><strong>直接跳过</strong>传统流程中的 <code>ViewResolver</code> 解析和 JSP&#x2F;HTML 渲染步骤。</li>
</ul>
</li>
<li><strong>最终清理 (<code>afterCompletion</code>)</strong><ul>
<li>不管成功还是异常，执行拦截器的 <code>afterCompletion</code> 方法（用于记录 API 耗时日志、清理 ThreadLocal 资源等）。</li>
</ul>
</li>
<li><strong>响应客户端</strong><ul>
<li>客户端收到标准的 JSON 响应。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-执行流程源码级解析"><a href="#3-执行流程源码级解析" class="headerlink" title="3. 执行流程源码级解析"></a>3. 执行流程源码级解析</h2><h3 id="3-1-DispatcherServlet-doDispatch-源码深度解析"><a href="#3-1-DispatcherServlet-doDispatch-源码深度解析" class="headerlink" title="3.1 DispatcherServlet.doDispatch 源码深度解析"></a>3.1 DispatcherServlet.doDispatch 源码深度解析</h3><h4 id="3-1-1-源码骨架"><a href="#3-1-1-源码骨架" class="headerlink" title="3.1.1 源码骨架"></a>3.1.1 源码骨架</h4><p><code>doDispatch</code> 是 SpringMVC 处理请求的<strong>主入口</strong>。它协调各个组件完成任务，代码逻辑非常清晰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">    <span class="comment">// 执行链 (包含 Controller 方法 + 一组拦截器)</span></span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">	<span class="comment">// 是否是文件上传    </span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Step 1: 检查文件上传</span></span><br><span class="line">            <span class="comment">// 如果是 multipart/form-data，将 request 包装为 MultipartHttpServletRequest</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 2:【寻址】获取处理器执行链 (HandlerMapping)</span></span><br><span class="line">            <span class="comment">// 作用：根据 URL 找到 Controller 方法，并把配置好的拦截器(Interceptor)加进来</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果找不到 Handler (404)，抛异常或通过 response 报错</span></span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 3:【适配】获取处理器适配器 (HandlerAdapter)</span></span><br><span class="line">            <span class="comment">// 作用：找到能执行这个 Handler 的“转换插头” (如 RequestMappingHandlerAdapter)</span></span><br><span class="line">            <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 4: 处理 GET 请求缓存头 (Last-Modified, ETag) - 非核心逻辑</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 5:【拦截器】执行 preHandle (正序)</span></span><br><span class="line">            <span class="comment">// 场景：登录校验、限流。如果返回 false，流程直接中断 (return)</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 6:【执行】适配器执行 Handler (核心业务逻辑)</span></span><br><span class="line">            <span class="comment">// 详情：反射调用 Controller 方法。参数绑定、JSON 读写都在这里完成。</span></span><br><span class="line">            <span class="comment">// 注意：</span></span><br><span class="line">            <span class="comment">// 1. 传统页面开发：返回 ModelAndView 对象。</span></span><br><span class="line">            <span class="comment">// 2. RESTful开发 (@ResponseBody)：MessageConverter 已将 JSON 写入响应流，mv 为 null。</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 7: 处理默认视图名 (仅针对无 @ResponseBody 且返回 void 的情况)</span></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 8:【拦截器】执行 postHandle (逆序)</span></span><br><span class="line">            <span class="comment">// 场景：统一修改 ModelAndView (如添加全局菜单数据)。RESTful 场景下基本不用。</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex; <span class="comment">// 暂存 Controller 层抛出的异常</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 9:【收尾】处理调度结果 (渲染视图 或 处理异常)</span></span><br><span class="line">        <span class="comment">// 核心方法：processDispatchResult</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="comment">// 兜底异常处理</span></span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Step 10: 资源清理 (清理 ThreadLocal，清理上传临时文件)</span></span><br><span class="line">        <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">            cleanupMultipart(processedRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-2-关键步骤深度剖析"><a href="#3-1-2-关键步骤深度剖析" class="headerlink" title="3.1.2 关键步骤深度剖析"></a>3.1.2 关键步骤深度剖析</h4><h5 id="1-getHandler-寻找-Handler"><a href="#1-getHandler-寻找-Handler" class="headerlink" title="1. getHandler() - 寻找 Handler"></a>1. <code>getHandler()</code> - 寻找 Handler</h5><ul>
<li><strong>逻辑</strong>：遍历容器中所有的 <code>HandlerMapping</code> 实现类（最常用的是 <code>RequestMappingHandlerMapping</code>）。</li>
<li><strong>产出</strong>：它返回的不是简单的 Controller 对象，而是 <strong><code>HandlerExecutionChain</code></strong>。<ul>
<li><strong>链条包含</strong> &#x3D; <code>Handler</code> (Controller 方法) + <code>Interceptor List</code> (所有匹配 URL 的拦截器)。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-ha-handle-适配器执行"><a href="#2-ha-handle-适配器执行" class="headerlink" title="2. ha.handle() - 适配器执行"></a>2. <code>ha.handle()</code> - 适配器执行</h5><ul>
<li><strong>黑盒内部</strong>：这是 SpringMVC 最“脏”最“累”的地方。</li>
<li><strong>RESTful 场景下的核心动作</strong>：<ol>
<li><strong>参数解析 (<code>ArgumentResolver</code>)</strong>：<ul>
<li>看到 <code>@RequestBody</code> -&gt; 呼叫 <code>MessageConverter</code> 把 InputStream 转为 Java Object。</li>
<li>看到 <code>@PathVariable</code> -&gt; 从 URL 解析参数。</li>
</ul>
</li>
<li><strong>方法调用</strong>：反射执行你的 Controller 代码。</li>
<li><strong>返回值处理 (<code>ReturnValueHandler</code>)</strong>：<ul>
<li>看到 <code>@ResponseBody</code> -&gt; 呼叫 <code>MessageConverter</code> 把 Java Object 转为 JSON 写回 Response。</li>
<li><strong>关键点</strong>：一旦写入 Response，它会告诉 DispatcherServlet：“活干完了，不用渲染视图了”，于是返回 <code>mv = null</code>。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h5 id="3-processDispatchResult-结果处理与异常兜底"><a href="#3-processDispatchResult-结果处理与异常兜底" class="headerlink" title="3. processDispatchResult() - 结果处理与异常兜底"></a>3. <code>processDispatchResult()</code> - 结果处理与异常兜底</h5><p>这是流程的收尾阶段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(..., ModelAndView mv, Exception exception)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 如果前面有异常 (exception != null)</span></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用全局异常解析器 (HandlerExceptionResolver)</span></span><br><span class="line">        <span class="comment">// 尝试解析异常，返回一个新的错误页面的 ModelAndView</span></span><br><span class="line">        processHandlerException(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 如果 mv 不为空 (说明是跳转页面，不是 @ResponseBody)</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">        <span class="comment">// 【渲染核心】调用 ViewResolver 解析视图并渲染</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 执行拦截器的 afterCompletion (无论成功失败都执行)</span></span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">        mappedHandler.triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-2-从-Request-到-Controller-方法参数绑定"><a href="#3-2-从-Request-到-Controller-方法参数绑定" class="headerlink" title="3.2 从 Request 到 Controller 方法参数绑定"></a>3.2 从 Request 到 Controller 方法参数绑定</h3><p><strong>场景</strong>：前端发送 JSON 请求，后端 Controller 使用 <code>@RequestBody User user</code> 接收。</p>
<p><strong>疑问</strong>：谁负责把 InputStream 里的 JSON 字符串变成 Java 里的 <code>User</code> 对象？</p>
<p><strong>核心类</strong>：<code>RequestMappingHandlerAdapter</code> -&gt; <code>ServletInvocableHandlerMethod</code></p>
<p><strong>源码步骤拆解</strong>：</p>
<ol>
<li><strong>适配器执行 (<code>ha.handle</code>)</strong>：<br>适配器调用 <code>invokeHandlerMethod</code> 方法。</li>
<li><strong>参数解析器寻址 (<code>ArgumentResolver</code>)</strong>：<br>Spring 维护了一个 <code>HandlerMethodArgumentResolver</code> 列表（参数解析器链）。它会遍历 Controller 方法的每一个参数，询问“谁能处理这个参数？”<ul>
<li>对于 <code>@RequestParam</code>，由 <code>RequestParamMethodArgumentResolver</code> 处理。</li>
<li>对于 <code>@RequestBody</code>，由 <strong><code>RequestResponseBodyMethodProcessor</code></strong> 处理（<strong>重点</strong>）。</li>
</ul>
</li>
<li><strong>JSON 反序列化</strong>：<br><code>RequestResponseBodyMethodProcessor</code> 的 <code>resolveArgument</code> 方法被调用：<ul>
<li>它会找到合适的 <code>HttpMessageConverter</code>（通常是 <code>MappingJackson2HttpMessageConverter</code>）。</li>
<li>调用 Converter 的 <code>read()</code> 方法。</li>
<li>Jackson 底层调用 <code>ObjectMapper.readValue(inputStream, User.class)</code>。</li>
<li><strong>结果</strong>：流数据变成了 Java 对象。</li>
</ul>
</li>
<li><strong>参数注入</strong>：<br>反射调用 Controller 方法，将转换好的对象传入。</li>
</ol>
<hr>
<h3 id="3-3-Controller-返回值转-JSON-响应-Output"><a href="#3-3-Controller-返回值转-JSON-响应-Output" class="headerlink" title="3.3 Controller 返回值转 JSON 响应 (Output)"></a>3.3 Controller 返回值转 JSON 响应 (Output)</h3><p><strong>场景</strong>：Controller 方法返回 <code>User</code> 对象，且标记了 <code>@ResponseBody</code> 或 <code>@RestController</code>。</p>
<p><strong>疑问</strong>：返回的 <code>User</code> 对象去哪了？它是怎么变成 JSON 字符串写回浏览器的？</p>
<p><strong>核心类</strong>：依然是 <strong><code>RequestResponseBodyMethodProcessor</code></strong> （它既是参数解析器，也是返回值处理器）。</p>
<p><strong>源码步骤拆解</strong>：</p>
<ol>
<li><strong>返回值处理器寻址 (<code>ReturnValueHandler</code>)</strong>：<br>方法执行完毕后，拿到返回值（Java Object）。Spring 遍历 <code>HandlerMethodReturnValueHandler</code> 列表。<ul>
<li>因为方法上有 <code>@ResponseBody</code>，所以 <strong><code>RequestResponseBodyMethodProcessor</code></strong> 再次举手说：“我来处理！”</li>
</ul>
</li>
<li><strong>处理返回值 (<code>handleReturnValue</code>)</strong>：<br>该类内部调用 <code>writeWithMessageConverters()</code> 方法。</li>
<li><strong>内容协商 (Content Negotiation)</strong>：<ul>
<li>Spring 会检查 Request 的 <code>Accept</code> 头（比如前端说我想要 <code>application/json</code>）。</li>
<li>Spring 检查 Server 端配置的 Converter 列表，看谁能支持写出这种格式。</li>
</ul>
</li>
<li><strong>JSON 序列化与写入</strong>：<ul>
<li>选定 <code>MappingJackson2HttpMessageConverter</code>。</li>
<li>调用 Converter 的 <code>write()</code> 方法。</li>
<li>Jackson 底层调用 <code>ObjectMapper.writeValue(outputStream, userObject)</code>。</li>
<li><strong>关键动作</strong>：数据被直接写入 <code>HttpServletResponse</code> 的输出流。</li>
</ul>
</li>
<li><strong>流程结束</strong>：<ul>
<li>因为数据已经写完了，所以 <code>ha.handle()</code> 方法返回的 <code>ModelAndView</code> 对象为 <strong><code>null</code></strong>。</li>
<li>回到 <code>doDispatch</code> 的后续流程中，视图渲染步骤（ViewResolver）会被跳过。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="三、请求路由与-RESTful-设计"><a href="#三、请求路由与-RESTful-设计" class="headerlink" title="三、请求路由与 RESTful 设计"></a>三、请求路由与 RESTful 设计</h1><h2 id="1-RESTful-API设计指南"><a href="#1-RESTful-API设计指南" class="headerlink" title="1. RESTful API设计指南"></a>1. RESTful API设计指南</h2><h3 id="1-1-核心概念"><a href="#1-1-核心概念" class="headerlink" title="1.1 核心概念"></a>1.1 核心概念</h3><p>RESTful 风格的核心思想是<strong>面向资源</strong>。</p>
<ol>
<li><strong>资源（Resources）</strong>：网络上的一个实体，比如用户、订单、商品。每个资源都有一个唯一的标识符（URI）。</li>
<li><strong>表现层（Representation）</strong>：资源呈现出来的形式，通常是 JSON 或 XML。在Java后端中，目前绝大多数情况使用 JSON。</li>
<li><strong>状态转换（State Transfer）</strong>：客户端通过HTTP动词（GET, POST等）操作服务器端的资源，从而引起资源状态的改变。</li>
</ol>
<hr>
<h3 id="1-2-核心设计原则（六大要素）"><a href="#1-2-核心设计原则（六大要素）" class="headerlink" title="1.2 核心设计原则（六大要素）"></a>1.2 核心设计原则（六大要素）</h3><h4 id="1-2-1-URI-设计（名词-vs-动词）"><a href="#1-2-1-URI-设计（名词-vs-动词）" class="headerlink" title="1.2.1 URI 设计（名词 vs 动词）"></a>1.2.1 URI 设计（名词 vs 动词）</h4><ul>
<li><strong>原则</strong>：URI 中只包含<strong>名词</strong>（资源），不包含动词。动词由 HTTP Method 承载。</li>
<li><strong>规范</strong>：<ul>
<li>使用复数名词：<code>/users</code> 比 <code>/user</code> 更符合集合的概念。</li>
<li>使用连字符 <code>-</code> 代替下划线 <code>_</code>。</li>
<li>全部使用小写字母。</li>
<li>层级结构：<code>/resources/{id}/sub-resources</code>。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">错误示范 (RPC风格)</th>
<th align="left">正确示范 (RESTful风格)</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>/getAllUsers</code></td>
<td align="left"><code>GET /users</code></td>
<td align="left">获取用户列表</td>
</tr>
<tr>
<td align="left"><code>/getUserById?id=1</code></td>
<td align="left"><code>GET /users/1</code></td>
<td align="left">获取特定用户</td>
</tr>
<tr>
<td align="left"><code>/createUser</code></td>
<td align="left"><code>POST /users</code></td>
<td align="left">创建用户</td>
</tr>
<tr>
<td align="left"><code>/updateUser</code></td>
<td align="left"><code>PUT /users/1</code></td>
<td align="left">更新用户</td>
</tr>
<tr>
<td align="left"><code>/deleteUser?id=1</code></td>
<td align="left"><code>DELETE /users/1</code></td>
<td align="left">删除用户</td>
</tr>
<tr>
<td align="left"><code>/users/1/orders</code></td>
<td align="left"><code>GET /users/1/orders</code></td>
<td align="left">获取某用户的订单</td>
</tr>
</tbody></table>
<hr>
<h4 id="1-2-2-HTTP-动词"><a href="#1-2-2-HTTP-动词" class="headerlink" title="1.2.2 HTTP 动词"></a>1.2.2 HTTP 动词</h4><p>正确使用 HTTP 方法来表达对资源的操作类型：</p>
<ul>
<li><strong>GET</strong>：查询资源（Read）。<strong>安全且幂等</strong>。</li>
<li><strong>POST</strong>：创建资源（Create）。<strong>不幂等</strong>（重复提交会创建多个资源）。</li>
<li><strong>PUT</strong>：更新资源（Update）。<strong>幂等</strong>。通常用于全量替换资源。</li>
<li><strong>PATCH</strong>：更新资源（Update）。<strong>幂等或不幂等</strong>。用于局部更新（只修改变动的字段）。</li>
<li><strong>DELETE</strong>：删除资源（Delete）。<strong>幂等</strong>。</li>
</ul>
<hr>
<h4 id="1-2-3-HTTP-状态码"><a href="#1-2-3-HTTP-状态码" class="headerlink" title="1.2.3 HTTP 状态码"></a>1.2.3 HTTP 状态码</h4><p>不要总是返回 <code>200 OK</code>，要利用 HTTP 状态码表达请求的结果。</p>
<ul>
<li><strong>2xx 成功</strong><ul>
<li><code>200 OK</code>：通用成功（GET, PUT, PATCH）。</li>
<li><code>201 Created</code>：资源创建成功（POST）。</li>
<li><code>204 No Content</code>：删除成功，无返回内容（DELETE）。</li>
</ul>
</li>
<li><strong>4xx 客户端错误</strong><ul>
<li><code>400 Bad Request</code>：参数错误或请求体格式不对。</li>
<li><code>401 Unauthorized</code>：未登录&#x2F;未认证。</li>
<li><code>403 Forbidden</code>：已登录但无权限。</li>
<li><code>404 Not Found</code>：资源不存在。</li>
</ul>
</li>
<li><strong>5xx 服务器错误</strong><ul>
<li><code>500 Internal Server Error</code>：服务器代码抛出异常。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-2-4-无状态"><a href="#1-2-4-无状态" class="headerlink" title="1.2.4 无状态"></a>1.2.4 无状态</h4><p>服务器不应保存客户端的会话状态（Session）。每次请求都必须包含服务器处理该请求所需的所有信息（如 Token）。这有利于水平扩展（Clustering）。</p>
<hr>
<h4 id="1-2-5-统一接口返回格式"><a href="#1-2-5-统一接口返回格式" class="headerlink" title="1.2.5 统一接口返回格式"></a>1.2.5 统一接口返回格式</h4><p>虽然 HTTP 状态码很重要，但业务层面通常需要一个统一的 JSON 结构。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span>          <span class="comment">// 业务状态码</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;success&quot;</span><span class="punctuation">,</span> <span class="comment">// 提示信息</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> ... <span class="punctuation">&#125;</span>       <span class="comment">// 实际数据</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-6-版本控制"><a href="#1-2-6-版本控制" class="headerlink" title="1.2.6 版本控制"></a>1.2.6 版本控制</h4><p>API 会随业务演进，版本控制必不可少。主流做法有三种：</p>
<ol>
<li><strong>URI 版本（最流行）</strong>：<code>/api/v1/users</code></li>
<li>Header 版本：<code>Accept-version: v1</code></li>
<li>Query 参数：<code>/users?version=1</code></li>
</ol>
<hr>
<h2 id="2-RequestMapping-映射详解"><a href="#2-RequestMapping-映射详解" class="headerlink" title="2. @RequestMapping 映射详解"></a>2. @RequestMapping 映射详解</h2><h3 id="2-1-注解概述"><a href="#2-1-注解概述" class="headerlink" title="2.1 注解概述"></a>2.1 注解概述</h3><ul>
<li><strong>核心作用</strong>：建立 <strong>HTTP 请求</strong>（URL, Method, Params）与 <strong>Java 方法</strong> 之间的映射关系。</li>
<li><strong>核心属性</strong>：<ul>
<li><code>value</code> &#x2F; <code>path</code>：映射路径（默认属性）。</li>
<li><code>method</code>：限定 HTTP 请求方式。</li>
<li><code>params</code>：限定请求参数。</li>
<li><code>headers</code>：限定请求头。</li>
<li><code>consumes</code>: 限定请求体的内容类型。</li>
<li><code>produces</code>: 限定响应体的内容类型.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-标注位置与路径继承"><a href="#2-2-标注位置与路径继承" class="headerlink" title="2.2 标注位置与路径继承"></a>2.2 标注位置与路径继承</h3><p><code>@RequestMapping</code> 可以标注在类上，也可以标注在方法上。</p>
<ul>
<li><strong>类上 (Class Level)</strong>：提供初步的请求映射信息（通常用于<strong>模块划分</strong>）。</li>
<li><strong>方法上 (Method Level)</strong>：提供具体的请求映射信息。</li>
<li><strong>最终访问路径</strong> &#x3D; <code>类上的 value</code> + <code>方法上的 value</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span> <span class="comment">// 基准路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问路径: http://localhost:8080/user/login</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问路径: http://localhost:8080/user/register</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-URL-路径匹配规则"><a href="#2-3-URL-路径匹配规则" class="headerlink" title="2.3 URL 路径匹配规则"></a>2.3 URL 路径匹配规则</h3><h4 id="2-3-1-精确匹配"><a href="#2-3-1-精确匹配" class="headerlink" title="2.3.1 精确匹配"></a>2.3.1 精确匹配</h4><p>最常用的方式。</p>
<ul>
<li><code>@RequestMapping(&quot;/test&quot;)</code> -&gt; 仅匹配 <code>/test</code>。</li>
</ul>
<hr>
<h4 id="2-3-2-Ant-风格通配符"><a href="#2-3-2-Ant-风格通配符" class="headerlink" title="2.3.2 Ant 风格通配符"></a>2.3.2 Ant 风格通配符</h4><p>SpringMVC 支持 Ant 风格的路径匹配符，非常灵活。</p>
<ul>
<li><code>?</code>：匹配文件名中的<strong>一个字符</strong>。<ul>
<li><code>/user/c?eate</code> -&gt; 匹配 <code>/user/create</code>, <code>/user/cxeate</code></li>
</ul>
</li>
<li><code>*</code>：匹配文件名中的<strong>任意字符</strong>（一层路径）。<ul>
<li><code>/user/*/login</code> -&gt; 匹配 <code>/user/aaa/login</code>, <code>/user/bbb/login</code></li>
</ul>
</li>
<li><code>**</code>：匹配<strong>多层路径</strong>。<ul>
<li><code>/user/**</code> -&gt; 匹配 <code>/user/login</code>, <code>/user/a/b/c/login</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-3-3-占位符匹配"><a href="#2-3-3-占位符匹配" class="headerlink" title="2.3.3 占位符匹配"></a>2.3.3 占位符匹配</h4><p>配合 <code>@PathVariable</code> 使用（后续 3.4 节详解）。</p>
<ul>
<li><code>@RequestMapping(&quot;/user/{id}&quot;)</code> -&gt; 匹配 <code>/user/1</code>, <code>/user/100</code>。</li>
</ul>
<hr>
<h3 id="2-4-HTTP-请求方式限定"><a href="#2-4-HTTP-请求方式限定" class="headerlink" title="2.4 HTTP 请求方式限定"></a>2.4 HTTP 请求方式限定</h3><p>默认情况下，<code>@RequestMapping(&quot;/test&quot;)</code> 会接收 GET、POST 等<strong>所有</strong>类型的请求。为了安全和规范（RESTful），通常需要限定。</p>
<ul>
<li><p><strong>常规写法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有 POST 请求能访问，GET 访问会报 405 错误</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/save&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>组合注解（推荐，Spring 4.3+）</strong>：<br>为了简化代码，Spring 提供了专属注解：</p>
<ul>
<li><code>@GetMapping(&quot;/save&quot;)</code> 等同于 <code>method = RequestMethod.GET</code></li>
<li><code>@PostMapping(&quot;/save&quot;)</code></li>
<li><code>@PutMapping(&quot;/update&quot;)</code></li>
<li><code>@DeleteMapping(&quot;/delete&quot;)</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-5-请求参数与请求头限定"><a href="#2-5-请求参数与请求头限定" class="headerlink" title="2.5 请求参数与请求头限定"></a>2.5 请求参数与请求头限定</h3><p>这是一种更<strong>严格</strong>的匹配方式。即使 URL 和 Method 都对，如果参数或头信息不符合规则，依然拒绝访问。</p>
<h4 id="2-5-1-params-属性（限定请求参数）"><a href="#2-5-1-params-属性（限定请求参数）" class="headerlink" title="2.5.1 params 属性（限定请求参数）"></a>2.5.1 <code>params</code> 属性（限定请求参数）</h4><p>支持简单的逻辑表达式。</p>
<table>
<thead>
<tr>
<th align="left">表达式格式</th>
<th align="left">含义</th>
<th align="left">示例</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&quot;param&quot;</code></td>
<td align="left"><strong>必须存在</strong></td>
<td align="left"><code>&quot;uid&quot;</code></td>
<td align="left">请求中必须包含 <code>uid</code></td>
</tr>
<tr>
<td align="left"><code>&quot;!param&quot;</code></td>
<td align="left"><strong>必须不存在</strong></td>
<td align="left"><code>&quot;!uid&quot;</code></td>
<td align="left">请求中<strong>不能</strong>包含 <code>uid</code></td>
</tr>
<tr>
<td align="left"><code>&quot;param=value&quot;</code></td>
<td align="left"><strong>必须等于</strong></td>
<td align="left"><code>&quot;age=18&quot;</code></td>
<td align="left">必须含 <code>age</code> 且值为 <code>18</code></td>
</tr>
<tr>
<td align="left"><code>&quot;param!=value&quot;</code></td>
<td align="left"><strong>不等于</strong></td>
<td align="left"><code>&quot;age!=18&quot;</code></td>
<td align="left"><code>age</code> 值不是 <code>18</code>，<strong>或者</strong>没传 <code>age</code></td>
</tr>
</tbody></table>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL必须包含 username，且 age 必须为 18</span></span><br><span class="line"><span class="comment">// /test?username=zs&amp;age=18</span></span><br><span class="line"><span class="comment">// /test?username=zs (报 400 错误)</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/test&quot;, params = &#123;&quot;username&quot;, &quot;age=18&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testParams</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-5-2-headers-属性（限定请求头）"><a href="#2-5-2-headers-属性（限定请求头）" class="headerlink" title="2.5.2 headers 属性（限定请求头）"></a>2.5.2 <code>headers</code> 属性（限定请求头）</h4><p>用法与 <code>params</code> 一致，校验 HTTP Header。常用于鉴权或限制内容类型。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求头必须包含 &quot;Token&quot;，且 Content-Type 必须为 json</span></span><br><span class="line"><span class="meta">@PostMapping(value = &quot;/api&quot;, headers = &#123;&quot;Token&quot;, &quot;content-type=application/json&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testHeader</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="四、请求数据绑定"><a href="#四、请求数据绑定" class="headerlink" title="四、请求数据绑定"></a>四、请求数据绑定</h1><blockquote>
<p><strong>核心目标</strong>：解决“数据如何从 HTTP 协议包（字符串&#x2F;字节流）转换为 Java 对象”的问题。</p>
<p><strong>核心原则</strong>：SpringMVC 通过 <strong><code>HandlerAdapter</code></strong> 调用一系列 <strong><code>ArgumentResolver</code></strong>（参数解析器），配合反射技术完成数据注入。</p>
</blockquote>
<h2 id="1-简单参数绑定"><a href="#1-简单参数绑定" class="headerlink" title="1. 简单参数绑定"></a>1. 简单参数绑定</h2><h3 id="1-1-普通参数：-RequestParam"><a href="#1-1-普通参数：-RequestParam" class="headerlink" title="1.1 普通参数：@RequestParam"></a>1.1 普通参数：<code>@RequestParam</code></h3><blockquote>
<p><strong>适用场景</strong>：</p>
<ol>
<li>GET 请求的 Query String：<code>/users?name=alice&amp;age=30</code></li>
<li>POST 请求的 Form 表单：<code>Content-Type: application/x-www-form-urlencoded</code></li>
</ol>
</blockquote>
<ul>
<li><p><strong>基本用法</strong>：<br>如果方法形参名与请求参数名<strong>完全一致</strong>，注解可以省略（SpringMVC 会默认按 <code>@RequestParam(required=false)</code> 处理）。</p>
</li>
<li><p><strong>核心属性</strong>：</p>
<ul>
<li><code>value</code> &#x2F; <code>name</code>：指定请求参数名（当前端参数名与后端形参名不一致时使用）。</li>
<li><code>required</code>：是否必填，默认为 <code>true</code>。若缺失则报 <strong>400 错误</strong>。</li>
<li><code>defaultValue</code>：默认值。<strong>注意：一旦设置了默认值，隐式意味着 <code>required=false</code></strong>。</li>
</ul>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findUser</span><span class="params">(</span></span><br><span class="line"><span class="params">    // <span class="number">1.</span> 省略注解 (前端传 name)</span></span><br><span class="line">    String name,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 指定参数名 &amp; 设为可选 (前端传 user_age)</span></span><br><span class="line">    <span class="meta">@RequestParam(name = &quot;user_age&quot;, required = false)</span> Integer age,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置默认值 (没传 page 则为 1)</span></span><br><span class="line">    <span class="meta">@RequestParam(defaultValue = &quot;1&quot;)</span> <span class="type">int</span> page,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 接收同名参数 (复选框 ?roles=admin&amp;roles=user)</span></span><br><span class="line">    <span class="meta">@RequestParam(&quot;roles&quot;)</span> List&lt;String&gt; roles </span><br><span class="line">) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="1-2-路径参数：-PathVariable"><a href="#1-2-路径参数：-PathVariable" class="headerlink" title="1.2 路径参数：@PathVariable"></a>1.2 路径参数：<code>@PathVariable</code></h3><blockquote>
<p><strong>适用场景</strong>：RESTful 风格的 API，参数直接嵌入在 URL 路径中。</p>
<p>例如：<code>GET /users/123</code> (获取 ID 为 123 的用户)</p>
</blockquote>
<ul>
<li><p><strong>URL 模板</strong>：在 <code>@RequestMapping</code> 中使用 <code>{}</code> 占位符。</p>
</li>
<li><p><strong>注意</strong>：<code>{name}</code> 必须与 <code>@PathVariable(&quot;name&quot;)</code> 保持一致。</p>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL: /users/123/orders/999</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/users/&#123;userId&#125;/orders/&#123;orderId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getOrder</span><span class="params">(</span></span><br><span class="line"><span class="params">    // 将路径中的 &#123;userId&#125; 绑定到变量 userId</span></span><br><span class="line"><span class="params">    <span class="meta">@PathVariable</span> Long userId,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">    // 假如形参名不想叫 orderId，需显式指定</span></span><br><span class="line"><span class="params">    <span class="meta">@PathVariable(&quot;orderId&quot;)</span> String orderIdentifier</span></span><br><span class="line"><span class="params">)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="1-3-请求头与-Cookie"><a href="#1-3-请求头与-Cookie" class="headerlink" title="1.3 请求头与 Cookie"></a>1.3 请求头与 Cookie</h3><ul>
<li><p><strong><code>@RequestHeader</code></strong>：获取 HTTP 请求头信息（如 Token、User-Agent）。</p>
</li>
<li><p><strong><code>@CookieValue</code></strong>：获取指定的 Cookie 值（如 SessionId）。</p>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">test</span><span class="params">(<span class="meta">@RequestHeader(&quot;Authorization&quot;)</span> String token, </span></span><br><span class="line"><span class="params">                   <span class="meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String sessionId)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="2-复杂参数绑定"><a href="#2-复杂参数绑定" class="headerlink" title="2. 复杂参数绑定"></a>2. 复杂参数绑定</h2><h3 id="2-1-POJO-自动封装"><a href="#2-1-POJO-自动封装" class="headerlink" title="2.1 POJO 自动封装"></a>2.1 POJO 自动封装</h3><blockquote>
<p><strong>适用场景</strong>：POST 请求的 Form 表单<code>Content-Type: application/x-www-form-urlencoded</code></p>
</blockquote>
<ul>
<li><p><strong>机制</strong>：SpringMVC 会根据<strong>参数名</strong>查找 POJO 类的 <strong>Setter 方法</strong>进行赋值。</p>
</li>
<li><p><strong>要求</strong>：POJO 类必须有<strong>无参构造器</strong>和 public 的 <strong>Setter</strong>。</p>
</li>
<li><p><strong>支持级联</strong>：支持 <code>address.city</code> 这种嵌套属性。</p>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提交数据：username=carol&amp;email=carol@gmail.com</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/users/create&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">createUser</span><span class="params">(UserCreateForm form)</span> &#123; <span class="comment">// 无需注解！</span></span><br><span class="line">    <span class="comment">// 自动 new UserCreateForm() -&gt; setUsername() -&gt; setEmail()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-2-JSON-请求体：-RequestBody"><a href="#2-2-JSON-请求体：-RequestBody" class="headerlink" title="2.2 JSON 请求体：@RequestBody"></a>2.2 JSON 请求体：<code>@RequestBody</code></h3><blockquote>
<p><strong>适用场景</strong>：POST&#x2F;PUT 请求，请求体是 JSON 或 XML 数据。</p>
<p><code>Content-Type: application/json</code></p>
</blockquote>
<ul>
<li><p><strong>核心机制</strong>：SpringMVC 使用 <code>HttpMessageConverter</code> (默认 Jackson) 将 JSON 字符串<strong>反序列化</strong>为 Java 对象。</p>
</li>
<li><p><strong>限制</strong>：一个 Controller 方法中<strong>最多只能有一个</strong> <code>@RequestBody</code>（因为请求体 InputStream 只能读一次）。</p>
</li>
<li><p><strong>接收 Map vs 接收 DTO (最佳实践)</strong>：</p>
<ul>
<li><strong>接收 Map</strong>：<code>public Result save(@RequestBody Map&lt;String, Object&gt; map)</code><ul>
<li><em>缺点</em>：不安全，不知道里面有什么字段，Swagger 无法生成文档，需要手动强转类型，<strong>维护噩梦</strong>。</li>
</ul>
</li>
<li><strong>接收 DTO</strong>：<code>public Result save(@RequestBody UserDTO userDto)</code><ul>
<li><em>优点</em>：类型安全，自动校验（JSR-303），文档清晰。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端发送：&#123;&quot;username&quot;: &quot;bob&quot;, &quot;age&quot;: 18&#125;</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/users/register&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestBody</span> UserDTO userDto</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    System.out.println(userDto.getUsername());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="3-特殊参数处理"><a href="#3-特殊参数处理" class="headerlink" title="3. 特殊参数处理"></a>3. 特殊参数处理</h2><h3 id="3-1-日期时间处理"><a href="#3-1-日期时间处理" class="headerlink" title="3.1 日期时间处理"></a>3.1 日期时间处理</h3><ul>
<li><p><strong>痛点</strong>：前端传 <code>&quot;2023-10-01&quot;</code>，后端字段是 <code>Date</code> 或 <code>LocalDate</code>。</p>
</li>
<li><p><strong>解决方案</strong>：使用 <strong><code>@DateTimeFormat</code></strong>。</p>
</li>
<li><p><strong>建议</strong>：废弃 <code>java.util.Date</code>，全面使用 Java 8 的 <strong><code>LocalDate</code> &#x2F; <code>LocalDateTime</code></strong>。</p>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适用于 @RequestParam 或 POJO 字段</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getDailyReport</span><span class="params">(<span class="meta">@RequestParam</span> <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate date)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果是 JSON Body (<code>@RequestBody</code>) 中的日期，需要用 <code>@JsonFormat</code> (Jackson 注解) 或全局配置，而非 <code>@DateTimeFormat</code> (Spring 注解)。</p>
</li>
</ul>
<hr>
<h3 id="3-2-集合绑定的“坑”"><a href="#3-2-集合绑定的“坑”" class="headerlink" title="3.2 集合绑定的“坑”"></a>3.2 集合绑定的“坑”</h3><h4 id="3-2-1-问题现象"><a href="#3-2-1-问题现象" class="headerlink" title="3.2.1 问题现象"></a>3.2.1 问题现象</h4><ul>
<li><strong>代码写法</strong>：<code>public void test(List&lt;String&gt; ids)</code></li>
<li><strong>错误信息</strong>：<code>No primary or default constructor found for interface java.util.List</code></li>
<li><strong>根本原因</strong>：<ul>
<li>在未添加任何注解的情况下，SpringMVC 默认将参数视为 <strong>ModelAttribute</strong>（待绑定的 JavaBean）。</li>
<li>框架尝试通过反射去<strong>实例化</strong>该参数类型。由于 <code>java.util.List</code> 是<strong>接口</strong>，无法实例化，因此抛出异常。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-2-使用-RequestParam-注解（用于简单参数）"><a href="#3-2-2-使用-RequestParam-注解（用于简单参数）" class="headerlink" title="3.2.2 使用 @RequestParam 注解（用于简单参数）"></a>3.2.2 使用 <code>@RequestParam</code> 注解（用于简单参数）</h4><ul>
<li><strong>写法</strong>：<code>public void test(@RequestParam(&quot;ids&quot;) List&lt;String&gt; ids)</code></li>
<li><strong>原理</strong>：<ul>
<li>注解显式告诉 SpringMVC 该参数来源于 HTTP 请求参数（Query Parameter 或 Form Data），而非一个需要实例化的 JavaBean。</li>
<li>此时触发 <code>RequestParamMethodArgumentResolver</code>，框架会自动调用内部的 <strong>ConversionService</strong>。</li>
<li>转换器会将请求中的字符串数组（或逗号分隔的字符串）自动转换为 <code>ArrayList</code> 并填充数据。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-3-使用-RequestBody-注解（用于复杂参数）"><a href="#3-2-3-使用-RequestBody-注解（用于复杂参数）" class="headerlink" title="3.2.3 使用 @RequestBody 注解（用于复杂参数）"></a>3.2.3 使用 <code>@RequestBody</code> 注解（用于复杂参数）</h4><ul>
<li><strong>写法</strong>：<code>public void test(@RequestBody List&lt;UserDTO&gt; users)</code></li>
<li><strong>原理</strong>：注解显式告诉 SpringMVC 该参数来源于 HTTP 请求体，而非一个需要实例化的 JavaBean。</li>
</ul>
<hr>
<h4 id="3-2-4-包装在-POJO-对象中（用于复杂表单）"><a href="#3-2-4-包装在-POJO-对象中（用于复杂表单）" class="headerlink" title="3.2.4 包装在 POJO 对象中（用于复杂表单）"></a>3.2.4 包装在 POJO 对象中（用于复杂表单）</h4><ul>
<li><p><strong>写法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义包装类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserForm</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; ids;</span><br><span class="line">    <span class="comment">// getter &amp; setter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(UserForm form)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原理</strong>：</p>
<ul>
<li>SpringMVC 首先实例化 <code>UserForm</code> 对象（这是一个具体的类，可以实例化）。</li>
<li>接着使用 <code>DataBinder</code> 机制处理属性填充。当遇到 <code>ids</code> 属性时，BeanWrapper 会根据 Java Bean 规范和内置编辑器自动创建默认的集合实现（通常是 <code>ArrayList</code>）来接收数据。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-3-获取原生-API"><a href="#3-3-获取原生-API" class="headerlink" title="3.3 获取原生 API"></a>3.3 获取原生 API</h3><h4 id="3-3-1-为什么需要原生-API？"><a href="#3-3-1-为什么需要原生-API？" class="headerlink" title="3.3.1 为什么需要原生 API？"></a>3.3.1 为什么需要原生 API？</h4><p>尽管 SpringMVC 封装了 <code>Model</code>、<code>@RequestParam</code> 等便捷工具，但以下场景必须用原生 API：</p>
<ol>
<li><strong>Session 管理</strong>：登录成功后 <code>session.setAttribute(&quot;user&quot;, user)</code>。</li>
<li><strong>Cookie 操作</strong>：虽然有 <code>@CookieValue</code> 读取，但<strong>设置</strong> Cookie 依然需要 <code>response.addCookie()</code>。</li>
<li><strong>文件下载</strong>：需要操作 <code>response.getOutputStream()</code> 写入文件流。</li>
<li><strong>IP 获取</strong>：<code>request.getRemoteAddr()</code>。</li>
<li><strong>ServletContext</strong>：获取 Web 应用的全局配置或真实路径。</li>
</ol>
<hr>
<h4 id="3-3-2-获取方式"><a href="#3-3-2-获取方式" class="headerlink" title="3.3.2 获取方式"></a>3.3.2 获取方式</h4><p><strong>想要什么，就在 Controller 方法的参数里写什么</strong>。DispatcherServlet 会自动检测并注入。</p>
<p><strong>支持的原生类型包括</strong>：</p>
<ul>
<li><code>HttpServletRequest</code></li>
<li><code>HttpServletResponse</code></li>
<li><code>HttpSession</code></li>
<li><code>java.security.Principal</code> (安全认证相关)</li>
<li><code>Locale</code> (国际化区域信息)</li>
<li><code>InputStream</code> &#x2F; <code>OutputStream</code> &#x2F; <code>Reader</code> &#x2F; <code>Writer</code></li>
</ul>
<hr>
<h4 id="3-3-3-代码示例"><a href="#3-3-3-代码示例" class="headerlink" title="3.3.3 代码示例"></a>3.3.3 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testNative</span><span class="params">(</span></span><br><span class="line"><span class="params">        HttpServletRequest request, </span></span><br><span class="line"><span class="params">        HttpServletResponse response,</span></span><br><span class="line"><span class="params">        HttpSession session</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取请求信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">clientIP</span> <span class="operator">=</span> request.getRemoteAddr();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端IP: &quot;</span> + clientIP);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 操作 Session (存取数据)</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果 session 还没创建，request.getSession() 会自动创建</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 操作 Response (如手动添加 Cookie)</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;token&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        cookie.setMaxAge(<span class="number">3600</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 获取 ServletContext (应用上下文)</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> application.getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;上传文件夹物理路径: &quot;</span> + realPath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-请求乱码"><a href="#4-请求乱码" class="headerlink" title="4. 请求乱码"></a>4. 请求乱码</h2><blockquote>
<p><strong>历史背景</strong>：在 JSP&#x2F;Servlet 时代，处理乱码需要修改 Tomcat <code>server.xml</code> 或在代码里写 <code>request.setCharacterEncoding(&quot;UTF-8&quot;)</code>。</p>
</blockquote>
<h3 id="4-1-乱码根源"><a href="#4-1-乱码根源" class="headerlink" title="4.1 乱码根源"></a>4.1 乱码根源</h3><p>HTTP 协议传输的是字节流，浏览器默认可能用 UTF-8 发送，而服务器默认（特别是旧版 Tomcat）可能按 ISO-8859-1 解码，导致出现乱码。</p>
<hr>
<h3 id="4-2-现代解决方案：CharacterEncodingFilter"><a href="#4-2-现代解决方案：CharacterEncodingFilter" class="headerlink" title="4.2 现代解决方案：CharacterEncodingFilter"></a>4.2 现代解决方案：<code>CharacterEncodingFilter</code></h3><p>SpringMVC 提供了一个现成的过滤器，我们需要做的仅仅是配置它。它做了两件事：</p>
<ol>
<li><code>request.setCharacterEncoding(&quot;UTF-8&quot;)</code></li>
<li><code>response.setCharacterEncoding(&quot;UTF-8&quot;)</code></li>
</ol>
<hr>
<h3 id="4-3-配置方式"><a href="#4-3-配置方式" class="headerlink" title="4.3 配置方式"></a>4.3 配置方式</h3><ul>
<li><p><strong>Spring Boot (当前主流)</strong>：</p>
<ul>
<li><p>默认已经配好了！(在 <code>HttpEncodingAutoConfiguration</code> 中)。</p>
</li>
<li><p>如果需要手动修改，在 <code>application.yml</code> 中：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">encoding:</span></span><br><span class="line">      <span class="attr">charset:</span> <span class="string">UTF-8</span></span><br><span class="line">      <span class="attr">force:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>web.xml (SSM 遗留项目)</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>总结</strong>：只要正确配置了 Filter，且前后端统一 UTF-8，<strong>不需要</strong>再手动去改 Tomcat 配置文件或在 Controller 里转码。</p>
<hr>
<h1 id="五、响应数据处理"><a href="#五、响应数据处理" class="headerlink" title="五、响应数据处理"></a>五、响应数据处理</h1><blockquote>
<p><strong>核心目标</strong>：解决“Java 对象如何序列化为 HTTP 响应体（通常是 JSON）发送给前端”。</p>
<p><strong>核心组件</strong>：<code>HttpMessageConverter</code> (尤其是 Jackson 实现) 和 <code>ReturnValueHandler</code>。</p>
</blockquote>
<h2 id="1-JSON-数据响应"><a href="#1-JSON-数据响应" class="headerlink" title="1. JSON 数据响应"></a>1. JSON 数据响应</h2><h3 id="1-1-ResponseBody-与-RestController"><a href="#1-1-ResponseBody-与-RestController" class="headerlink" title="1.1 @ResponseBody 与 @RestController"></a>1.1 <code>@ResponseBody</code> 与 <code>@RestController</code></h3><ul>
<li><strong><code>@ResponseBody</code></strong>：<ul>
<li><strong>作用</strong>：告诉 SpringMVC，不要去解析视图（View），而是直接将返回值放入 HTTP Response Body 中。</li>
<li><strong>原理</strong>：触发 <code>RequestResponseBodyMethodProcessor</code>，利用 <code>Jackson</code> 将对象转为 JSON 字符串。</li>
</ul>
</li>
<li><strong><code>@RestController</code></strong>：<ul>
<li><strong>定义</strong>：组合注解 &#x3D; <code>@Controller</code> + <code>@ResponseBody</code>。</li>
<li><strong>便利性</strong>：类上加了这个注解，里面所有方法都默认返回 JSON，不用每个方法都写一遍 <code>@ResponseBody</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-常见-JSON-格式化注解"><a href="#1-2-常见-JSON-格式化注解" class="headerlink" title="1.2 常见 JSON 格式化注解"></a>1.2 常见 JSON 格式化注解</h3><p>有时候我们需要对输出的 JSON 格式做微调（比如日期格式、忽略字段）。</p>
<ul>
<li><p><strong><code>@JsonFormat</code></strong>：格式化日期（最常用）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时输出: &quot;2023-12-31 12:00:00&quot; (默认是时间戳)</span></span><br><span class="line"><span class="comment">// timezone: 解决时区差问题 (少8小时)</span></span><br><span class="line"><span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date birthday;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@JsonIgnore</code></strong>：忽略该字段，不生成到 JSON 中（如密码字段）。</p>
</li>
<li><p><strong><code>@JsonProperty</code></strong>：给字段起别名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonProperty(&quot;username&quot;)</span> <span class="comment">// JSON 中叫 username，Java 中叫 name</span></span><br><span class="line"><span class="keyword">private</span> String name; </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@JsonInclude(JsonInclude.Include.NON_NULL)</code></strong>：如果字段值为 null，则不返回该字段。</p>
</li>
</ul>
<hr>
<h2 id="2-HTTP-协议控制：ResponseEntity"><a href="#2-HTTP-协议控制：ResponseEntity" class="headerlink" title="2. HTTP 协议控制：ResponseEntity"></a>2. HTTP 协议控制：ResponseEntity</h2><h3 id="2-1-什么是-ResponseEntity？"><a href="#2-1-什么是-ResponseEntity？" class="headerlink" title="2.1 什么是 ResponseEntity？"></a>2.1 什么是 <code>ResponseEntity</code>？</h3><ul>
<li><strong>定义</strong>：<code>ResponseEntity&lt;T&gt;</code> 是 Spring 提供的一个泛型类，它继承自 <code>HttpEntity</code>。</li>
<li><strong>地位</strong>：它代表了整个 <strong>HTTP 响应</strong> 报文。</li>
<li><strong>能力</strong>：通过它，我们可以自由配置：<ol>
<li><strong>HttpStatus</strong>：响应状态码 (如 200, 201, 404, 500)。</li>
<li><strong>HttpHeaders</strong>：响应头 (如 Content-Type, Token, Cache-Control)。</li>
<li><strong>Body</strong>：响应体 (实际的业务数据)。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-2-为什么需要它"><a href="#2-2-为什么需要它" class="headerlink" title="2.2 为什么需要它"></a>2.2 为什么需要它</h3><p>在标准的 RESTful 规范中，不同的操作结果应该对应不同的状态码，而不仅仅是永远返回 200。</p>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left"><code>@ResponseBody</code> 处理</th>
<th align="left"><strong><code>ResponseEntity</code> 处理 (推荐)</strong></th>
<th align="left">状态码</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>查询成功</strong></td>
<td align="left">返回 JSON</td>
<td align="left"><code>ResponseEntity.ok(data)</code></td>
<td align="left"><strong>200 OK</strong></td>
</tr>
<tr>
<td align="left"><strong>创建资源</strong></td>
<td align="left">返回 JSON (状态码200)</td>
<td align="left"><code>ResponseEntity.status(201).body(data)</code></td>
<td align="left"><strong>201 Created</strong></td>
</tr>
<tr>
<td align="left"><strong>资源不存在</strong></td>
<td align="left">返回 null 或 报错</td>
<td align="left"><code>ResponseEntity.notFound().build()</code></td>
<td align="left"><strong>404 Not Found</strong></td>
</tr>
<tr>
<td align="left"><strong>没有权限</strong></td>
<td align="left">抛异常</td>
<td align="left"><code>ResponseEntity.status(403).build()</code></td>
<td align="left"><strong>403 Forbidden</strong></td>
</tr>
<tr>
<td align="left"><strong>文件下载</strong></td>
<td align="left">无法处理 Header</td>
<td align="left">设置 <code>Content-Disposition</code> 头</td>
<td align="left"><strong>200 OK</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="2-3-基本用法详解"><a href="#2-3-基本用法详解" class="headerlink" title="2.3 基本用法详解"></a>2.3 基本用法详解</h3><h4 id="2-3-1-链式构建风格"><a href="#2-3-1-链式构建风格" class="headerlink" title="2.3.1 链式构建风格"></a>2.3.1 链式构建风格</h4><p>Spring 提供了非常优雅的流式 API 来构建响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findById(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 成功：返回 200 OK 和对象</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(user);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 失败：返回 404 Not Found (无 Body)</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.notFound().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-2-构造器风格"><a href="#2-3-2-构造器风格" class="headerlink" title="2.3.2 构造器风格"></a>2.3.2 构造器风格</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 201 Created</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(user, HttpStatus.CREATED);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 500 Error</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(HttpStatus.INTERNAL_SERVER_ERROR);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-3-自定义响应头"><a href="#2-3-3-自定义响应头" class="headerlink" title="2.3.3 自定义响应头"></a>2.3.3 自定义响应头</h4><p>有时我们需要在 Header 里放自定义的 Token 或缓存指令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">login</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 Headers 对象</span></span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    headers.add(<span class="string">&quot;X-Auth-Token&quot;</span>, <span class="string">&quot;abcdef123456&quot;</span>); <span class="comment">// 自定义头</span></span><br><span class="line">    headers.add(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);    <span class="comment">// 标准头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 组装返回</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity</span><br><span class="line">            .ok()                  <span class="comment">// 状态码 200</span></span><br><span class="line">            .headers(headers)      <span class="comment">// 设置头</span></span><br><span class="line">            .body(<span class="string">&quot;Login Success&quot;</span>); <span class="comment">// 设置体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-页面跳转（传统SSR模式）"><a href="#3-页面跳转（传统SSR模式）" class="headerlink" title="3. 页面跳转（传统SSR模式）"></a>3. 页面跳转（传统SSR模式）</h2><blockquote>
<p>仅用于后台管理系统（Thymeleaf）或老项目维护，现代 API 开发可跳过。</p>
</blockquote>
<h3 id="3-1-返回-String-视图名"><a href="#3-1-返回-String-视图名" class="headerlink" title="3.1 返回 String (视图名)"></a>3.1 返回 String (视图名)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑视图名 &quot;home&quot;，会被 ViewResolver 解析为 /WEB-INF/views/home.jsp</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-2-转发-forward-与-重定向-redirect"><a href="#3-2-转发-forward-与-重定向-redirect" class="headerlink" title="3.2 转发 (forward:) 与 重定向 (redirect:)"></a>3.2 转发 (forward:) 与 重定向 (redirect:)</h3><ul>
<li><strong>转发 (<code>forward:/login</code>)</strong>：<ul>
<li>服务器内部跳转，URL <strong>不变</strong>。</li>
<li>共享 Request 域数据。</li>
<li>效率高。</li>
</ul>
</li>
<li><strong>重定向 (<code>redirect:/login</code>)</strong>：<ul>
<li>客户端重新发起请求，URL <strong>会变</strong>。</li>
<li><strong>不共享</strong> Request 数据（可以使用 <code>FlashAttribute</code> 传递一次性数据）。</li>
<li>用于防止表单重复提交（Post&#x2F;Redirect&#x2F;Get 模式）。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="六、高级功能与实战"><a href="#六、高级功能与实战" class="headerlink" title="六、高级功能与实战"></a>六、高级功能与实战</h1><h2 id="1-全局异常处理"><a href="#1-全局异常处理" class="headerlink" title="1. 全局异常处理"></a>1. 全局异常处理</h2><blockquote>
<p><strong>痛点</strong>：不处理异常时，SpringMVC 会把包含 Java 堆栈信息的 500 错误页直接抛给用户，既不安全也不友好。</p>
<p><strong>目标</strong>：无论发生什么错误，永远返回格式统一的 JSON 数据（如 <code>code: 500, msg: &quot;系统繁忙&quot;</code><em>）。</em></p>
</blockquote>
<h3 id="1-1-核心注解：-RestControllerAdvice"><a href="#1-1-核心注解：-RestControllerAdvice" class="headerlink" title="1.1 核心注解：@RestControllerAdvice"></a>1.1 核心注解：<code>@RestControllerAdvice</code></h3><ul>
<li><strong>组合注解</strong>：等同于 <code>@ControllerAdvice</code> + <code>@ResponseBody</code>。</li>
<li><strong>作用</strong>：它是一个增强器，能拦截所有 <code>@RequestMapping</code> 方法抛出的异常。</li>
</ul>
<hr>
<h3 id="1-2-实战：构建统一错误响应体系"><a href="#1-2-实战：构建统一错误响应体系" class="headerlink" title="1.2 实战：构建统一错误响应体系"></a>1.2 实战：构建统一错误响应体系</h3><p><strong>第一步：定义自定义异常 (BusinessException)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">// 构造器...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步：编写全局异常处理器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 捕获自定义业务异常 (如：余额不足)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">handleBusinessException</span><span class="params">(BusinessException e)</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;业务异常: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> Result.error(e.getCode(), e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 捕获参数校验异常 (JSR-303)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">handleValidationException</span><span class="params">(MethodArgumentNotValidException e)</span> &#123;</span><br><span class="line">        <span class="comment">// 提取第一条错误提示信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> e.getBindingResult().getFieldError().getDefaultMessage();</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="number">400</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 捕获所有未知的系统异常 (兜底方案)</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">handleException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;系统异常&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="number">500</span>, <span class="string">&quot;系统繁忙，请联系管理员&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优势</strong>：Controller 层不需要写任何 <code>try-catch</code>，代码极其干净。</li>
</ul>
<hr>
<h3 id="1-3-底层原理"><a href="#1-3-底层原理" class="headerlink" title="1.3 底层原理"></a>1.3 底层原理</h3><ol>
<li><strong>DispatcherServlet</strong> 调用 <code>doDispatch</code> 方法。</li>
<li><code>doDispatch</code> 中通过 <code>ha.handle(...)</code> 执行 Controller 方法。</li>
<li>如果 Controller 抛出异常，<strong><code>catch</code> 块会捕获到该异常</strong>，并将其赋值给 <code>dispatchException</code> 变量。</li>
<li>在最后的 <code>processDispatchResult</code> 方法中，会判断 <code>dispatchException</code> 是否为空。</li>
<li>如果不为空，SpringMVC 会遍历所有注册的 <code>HandlerExceptionResolver</code>（如 <code>ExceptionHandlerExceptionResolver</code>），找到能处理该异常的方法（即 <code>@ExceptionHandler</code> 标记的方法），并执行它。</li>
</ol>
<hr>
<h2 id="2-拦截器"><a href="#2-拦截器" class="headerlink" title="2. 拦截器"></a>2. 拦截器</h2><h3 id="2-1-什么是拦截器？"><a href="#2-1-什么是拦截器？" class="headerlink" title="2.1 什么是拦截器？"></a>2.1 什么是拦截器？</h3><ul>
<li><strong>定义</strong>：SpringMVC 提供的一种机制，用于在 <strong>Controller 方法执行前后</strong> 对请求进行拦截和处理。</li>
<li><strong>核心接口</strong>：<code>org.springframework.web.servlet.HandlerInterceptor</code>。</li>
<li><strong>地位</strong>：它是 SpringMVC 框架内部的组件，<strong>只拦截 Controller 的请求</strong></li>
</ul>
<hr>
<h3 id="2-2-拦截器-vs-过滤器"><a href="#2-2-拦截器-vs-过滤器" class="headerlink" title="2.2 拦截器 vs 过滤器"></a>2.2 拦截器 vs 过滤器</h3><table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left"><strong>过滤器 (Filter)</strong></th>
<th align="left"><strong>拦截器 (Interceptor)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>归属</strong></td>
<td align="left">Servlet 规范 (Tomcat 容器)</td>
<td align="left"><strong>SpringMVC 框架</strong></td>
</tr>
<tr>
<td align="left"><strong>拦截范围</strong></td>
<td align="left"><strong>所有请求</strong></td>
<td align="left">仅拦截 <strong>Controller 请求</strong></td>
</tr>
<tr>
<td align="left"><strong>底层实现</strong></td>
<td align="left">函数回调</td>
<td align="left"><strong>Java 反射机制</strong></td>
</tr>
<tr>
<td align="left"><strong>上下文</strong></td>
<td align="left">只能获取 Request&#x2F;Response</td>
<td align="left">可以获取 <strong>Spring 容器 (Bean)</strong></td>
</tr>
<tr>
<td align="left"><strong>执行时机</strong></td>
<td align="left">请求刚进入 Tomcat 时</td>
<td align="left">请求进入 DispatcherServlet 后</td>
</tr>
</tbody></table>
<p><strong>总结</strong>：如果你需要依赖 Spring 的 Service 层（比如查数据库判断 token），必须用拦截器；如果只是简单的字符编码设置，用过滤器。</p>
<hr>
<h3 id="2-3-三大核心方法-生命周期"><a href="#2-3-三大核心方法-生命周期" class="headerlink" title="2.3 三大核心方法 (生命周期)"></a>2.3 三大核心方法 (生命周期)</h3><p>自定义拦截器需要实现 <code>HandlerInterceptor</code> 接口（或继承 <code>HandlerInterceptorAdapter</code> 类）。</p>
<ol>
<li><strong><code>preHandle</code> (前置拦截) —— 最常用</strong><ul>
<li><strong>执行时机</strong>：在 Controller 方法执行 <strong>之前</strong>。</li>
<li><strong>返回值</strong>：<code>boolean</code>。<ul>
<li><code>true</code>：<strong>放行</strong>。请求继续向下走（去找下一个拦截器或 Controller）。</li>
<li><code>false</code>：<strong>拦截</strong>。请求到此为止，不再执行后续代码（通常配合 <code>response</code> 输出错误信息或重定向）。</li>
</ul>
</li>
<li><strong>用途</strong>：登录检查、权限校验。</li>
</ul>
</li>
<li><strong><code>postHandle</code> (后置处理)</strong><ul>
<li><strong>执行时机</strong>：Controller 方法执行 <strong>之后</strong>，视图渲染 <strong>之前</strong>。</li>
<li><strong>用途</strong>：修改 <code>ModelAndView</code> 中的数据（比如统一添加菜单、版权信息）。</li>
</ul>
</li>
<li><strong><code>afterCompletion</code> (最终收尾)</strong><ul>
<li><strong>执行时机</strong>：整个请求完成（视图渲染完毕）<strong>之后</strong>。</li>
<li><strong>用途</strong>：资源清理、异常日志记录、性能监控（计算请求总耗时）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-4-实战：登录权限拦截器"><a href="#2-4-实战：登录权限拦截器" class="headerlink" title="2.4 实战：登录权限拦截器"></a>2.4 实战：登录权限拦截器</h3><h4 id="2-4-1-编写拦截器"><a href="#2-4-1-编写拦截器" class="headerlink" title="2.4.1 编写拦截器"></a>2.4.1 编写拦截器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt; 登录拦截器开始拦截...&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 获取 Session 中的用户</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;loginUser&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 判断是否登录</span></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 已登录，放行</span></span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-4-2-配置-注册拦截器（-Java-Config-）"><a href="#2-4-2-配置-注册拦截器（-Java-Config-）" class="headerlink" title="2.4.2 配置&#x2F;注册拦截器（ Java Config ）"></a>2.4.2 配置&#x2F;注册拦截器（ Java Config ）</h4><p><strong>注意</strong>：在 Spring 5.0 之前通常继承 <code>WebMvcConfigurerAdapter</code>（已废弃），现在直接实现接口即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 注册自定义拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)             <span class="comment">// 拦截所有路径</span></span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/static/**&quot;</span>); <span class="comment">// 排除登录接口和静态资源</span></span><br><span class="line">                <span class="comment">// .order(1); // 可选：设置执行顺序，数字越小越先执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特点</strong>：类型安全，重构方便，是 Spring Boot 的标准做法。</li>
<li><strong>关于 <code>@EnableWebMvc</code></strong>：在 Spring Boot 中，通常<strong>不需要</strong>加 <code>@EnableWebMvc</code>，否则会接管并导致 Spring Boot 的默认 MVC 配置（如 Jackson、静态资源映射）失效。在纯 Spring MVC 项目中则需要加上。</li>
</ul>
<hr>
<h2 id="3-跨域资源共享-CORS"><a href="#3-跨域资源共享-CORS" class="headerlink" title="3. 跨域资源共享 (CORS)"></a>3. 跨域资源共享 (CORS)</h2><blockquote>
<p><strong>现象</strong>：前端 (<code>localhost:8080</code>) 调用后端 (<code>localhost:9090</code>) 接口时，浏览器报错：<code>Access-Control-Allow-Origin</code>。这是浏览器的“同源策略”保护机制。</p>
</blockquote>
<h3 id="3-1-解决方案-1：局部注解-开发调试用"><a href="#3-1-解决方案-1：局部注解-开发调试用" class="headerlink" title="3.1 解决方案 1：局部注解 (开发调试用)"></a>3.1 解决方案 1：局部注解 (开发调试用)</h3><p>在 Controller 类或方法上添加：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &quot;*&quot;)</span> </span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-2-解决方案-2：全局配置-生产推荐"><a href="#3-2-解决方案-2：全局配置-生产推荐" class="headerlink" title="3.2 解决方案 2：全局配置 (生产推荐)"></a>3.2 解决方案 2：全局配置 (生产推荐)</h3><p>在 <code>WebMvcConfigurer</code> 中配置，一次性解决所有接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">    registry.addMapping(<span class="string">&quot;/**&quot;</span>)                  <span class="comment">// 针对所有接口</span></span><br><span class="line">            .allowedOriginPatterns(<span class="string">&quot;*&quot;</span>)         <span class="comment">// 允许来源 (SpringBoot 2.4+ 用这个)</span></span><br><span class="line">            .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">            .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">            .allowCredentials(<span class="literal">true</span>)             <span class="comment">// 允许携带 Cookie</span></span><br><span class="line">            .maxAge(<span class="number">3600</span>);                      <span class="comment">// 预检请求缓存时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>注意：如果有自定义 Filter，CORS 配置可能会失效，此时建议使用 <code>CorsFilter</code> 方式配置。</em></p>
<hr>
<h2 id="4-参数校验-Validation-JSR-303"><a href="#4-参数校验-Validation-JSR-303" class="headerlink" title="4. 参数校验 (Validation &#x2F; JSR-303)"></a>4. 参数校验 (Validation &#x2F; JSR-303)</h2><blockquote>
<p><strong>核心原则</strong>：永远不要相信前端传来的数据。</p>
<p><strong>痛点</strong>：如果在 Service 层写满 <code>if (user.getAge() &lt; 0)</code> 这种代码，业务逻辑会变得臃肿不堪。</p>
<p><strong>方案</strong>：使用 <strong>Bean Validation (JSR-303&#x2F;JSR-349)</strong> 标准。Hibernate Validator 是该标准的参考实现。</p>
</blockquote>
<h3 id="4-1-基础依赖与概念"><a href="#4-1-基础依赖与概念" class="headerlink" title="4.1 基础依赖与概念"></a>4.1 基础依赖与概念</h3><h4 id="4-1-1-依赖引入"><a href="#4-1-1-依赖引入" class="headerlink" title="4.1.1 依赖引入"></a>4.1.1 依赖引入</h4><p>如果是 Spring Boot 项目，直接引入 <code>spring-boot-starter-validation</code> 即可。如果是传统 SSM，需手动引入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Hibernate Validator 引擎 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.2.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 标准 API 接口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-1-2-常用校验注解-标注在-DTO-POJO-属性上"><a href="#4-1-2-常用校验注解-标注在-DTO-POJO-属性上" class="headerlink" title="4.1.2 常用校验注解 (标注在 DTO&#x2F;POJO 属性上)"></a>4.1.2 常用校验注解 (标注在 DTO&#x2F;POJO 属性上)</h4><table>
<thead>
<tr>
<th align="left">注解</th>
<th align="left">适用类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>@NotNull</code></strong></td>
<td align="left">任何</td>
<td align="left">不能为 null，但在字符串时可以是空串 “”</td>
</tr>
<tr>
<td align="left"><strong><code>@NotEmpty</code></strong></td>
<td align="left">String, Map, List</td>
<td align="left">不能为 null 且 size &gt; 0 (字符串不能是 “”)</td>
</tr>
<tr>
<td align="left"><strong><code>@NotBlank</code></strong></td>
<td align="left">String</td>
<td align="left"><strong>最严格</strong>。不能为 null 且去掉空格后长度 &gt; 0 (仅限 String)</td>
</tr>
<tr>
<td align="left"><strong><code>@Size(min, max)</code></strong></td>
<td align="left">String, Map, List</td>
<td align="left">长度&#x2F;大小范围限制</td>
</tr>
<tr>
<td align="left"><strong><code>@Min</code> &#x2F; <code>@Max</code></strong></td>
<td align="left">Number</td>
<td align="left">数值大小限制</td>
</tr>
<tr>
<td align="left"><strong><code>@Email</code></strong></td>
<td align="left">String</td>
<td align="left">必须是合法的邮箱格式</td>
</tr>
<tr>
<td align="left"><strong><code>@Pattern(regexp)</code></strong></td>
<td align="left">String</td>
<td align="left">正则校验 (如手机号 <code>^1[3-9]\d{9}$</code>)</td>
</tr>
<tr>
<td align="left"><strong><code>@Past</code> &#x2F; <code>@Future</code></strong></td>
<td align="left">Date&#x2F;LocalDate</td>
<td align="left">必须是过去&#x2F;未来的时间</td>
</tr>
</tbody></table>
<p><strong>DTO 示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDTO</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户名不能为空&quot;)</span> <span class="comment">// 自定义错误消息</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min(value = 18, message = &quot;未成年人禁止注册&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 150, message = &quot;请输入合法的年龄&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式错误&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 嵌套对象的校验需加 @Valid</span></span><br><span class="line">    <span class="meta">@Valid</span> </span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> AddressDTO address; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2-Controller-层开启校验-最佳实践"><a href="#4-2-Controller-层开启校验-最佳实践" class="headerlink" title="4.2 Controller 层开启校验 (最佳实践)"></a>4.2 Controller 层开启校验 (最佳实践)</h3><blockquote>
<p><strong>注意</strong>：这里有两种写法，<strong>强烈推荐第二种（配合全局异常处理）</strong>。</p>
</blockquote>
<h4 id="4-2-1-写法一：手动处理-传统-不推荐"><a href="#4-2-1-写法一：手动处理-传统-不推荐" class="headerlink" title="4.2.1 写法一：手动处理 (传统&#x2F;不推荐)"></a>4.2.1 写法一：手动处理 (传统&#x2F;不推荐)</h4><p>在参数后紧跟 <code>BindingResult</code>，手动判断是否有错。<strong>缺点是代码冗余</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">register</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserDTO user, BindingResult result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        <span class="comment">// 手动提取第一条错误信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> result.getAllErrors().get(<span class="number">0</span>).getDefaultMessage();</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="number">400</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userService.register(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-2-写法二：自动抛出异常-现代-推荐"><a href="#4-2-2-写法二：自动抛出异常-现代-推荐" class="headerlink" title="4.2.2 写法二：自动抛出异常 (现代&#x2F;推荐)"></a>4.2.2 写法二：自动抛出异常 (现代&#x2F;推荐)</h4><p><strong>不写</strong> <code>BindingResult</code> 参数。如果校验失败，SpringMVC 会自动抛出 <code>MethodArgumentNotValidException</code> 异常。我们只需在全局异常处理器中捕获它即可。</p>
<p><strong>Controller 代码（极其清爽）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">register</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> UserDTO user)</span> &#123;</span><br><span class="line">    <span class="comment">// 只要进来了，说明参数一定是对的</span></span><br><span class="line">    <span class="keyword">return</span> userService.register(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>全局异常处理器配合：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">handleValidationException</span><span class="params">(MethodArgumentNotValidException e)</span> &#123;</span><br><span class="line">        <span class="comment">// 自动提取错误信息，如 &quot;用户名不能为空&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> e.getBindingResult().getFieldError().getDefaultMessage();</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="number">400</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-分组校验-Group-Validation"><a href="#4-3-分组校验-Group-Validation" class="headerlink" title="4.3 分组校验 (Group Validation)"></a>4.3 分组校验 (Group Validation)</h3><p><strong>场景</strong>：</p>
<ul>
<li><strong>新增</strong>：ID 必须为空（数据库自增）。</li>
<li><strong>更新</strong>：ID 必须不为空（作为主键）。</li>
<li>同一个 <code>UserDTO</code> 对象，不同接口规则冲突。</li>
</ul>
<h4 id="4-3-1-定义分组接口-空接口"><a href="#4-3-1-定义分组接口-空接口" class="headerlink" title="4.3.1 定义分组接口 (空接口)"></a>4.3.1 定义分组接口 (空接口)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AddGroup</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UpdateGroup</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-2-在-DTO-上指定分组"><a href="#4-3-2-在-DTO-上指定分组" class="headerlink" title="4.3.2 在 DTO 上指定分组"></a>4.3.2 在 DTO 上指定分组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDTO</span> &#123;</span><br><span class="line">    <span class="comment">// 只有在 UpdateGroup 分组下，ID 才不能为空</span></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;ID不能为空&quot;, groups = &#123;UpdateGroup.class&#125;)</span></span><br><span class="line">    <span class="meta">@Null(message = &quot;新增时ID必须为空&quot;, groups = &#123;AddGroup.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有指定 groups 的注解，默认属于 Default.class 分组</span></span><br><span class="line">    <span class="comment">// 如果要让它在 Add 和 Update 都生效，需要显式指定，或者继承 Default</span></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;姓名不能为空&quot;, groups = &#123;AddGroup.class, UpdateGroup.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-3-在-Controller-中指定分组"><a href="#4-3-3-在-Controller-中指定分组" class="headerlink" title="4.3.3 在 Controller 中指定分组"></a>4.3.3 在 Controller 中指定分组</h4><p>必须使用 Spring 的 <strong><code>@Validated</code></strong> 注解（<code>@Valid</code> 不支持分组）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增：只校验 AddGroup 规则</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">add</span><span class="params">(<span class="meta">@Validated(AddGroup.class)</span> <span class="meta">@RequestBody</span> UserDTO user)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新：只校验 UpdateGroup 规则</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/update&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(<span class="meta">@Validated(UpdateGroup.class)</span> <span class="meta">@RequestBody</span> UserDTO user)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-4-自定义校验注解-进阶"><a href="#4-4-自定义校验注解-进阶" class="headerlink" title="4.4 自定义校验注解 (进阶)"></a>4.4 自定义校验注解 (进阶)</h3><p>如果标准注解不够用（比如校验“手机号必须已注册”），可以自定义注解。</p>
<ol>
<li><strong>定义注解</strong>：<code>@CheckStatus</code></li>
<li><strong>实现校验器</strong>：实现 <code>ConstraintValidator</code> 接口。</li>
<li><strong>关联</strong>：在注解上使用 <code>@Constraint(validatedBy = MyValidator.class)</code>。<br><em>(此部分在实战中较少用，通常在 Service 层处理复杂业务校验，了解即可)</em></li>
</ol>
<hr>
<h2 id="5-文件上传与下载"><a href="#5-文件上传与下载" class="headerlink" title="5. 文件上传与下载"></a>5. 文件上传与下载</h2><h3 id="5-1-文件上传"><a href="#5-1-文件上传" class="headerlink" title="5.1 文件上传"></a>5.1 文件上传</h3><p>SpringMVC 的文件上传虽然基于 Apache Commons FileUpload 或 Servlet 3.0 标准，但对外提供了统一的 API。</p>
<h4 id="5-1-1-前端表单三要素"><a href="#5-1-1-前端表单三要素" class="headerlink" title="5.1.1 前端表单三要素"></a>5.1.1 前端表单三要素</h4><p>如果要上传文件，HTML 表单必须满足三个硬性条件：</p>
<ol>
<li><code>method=&quot;post&quot;</code>：GET 请求有长度限制，且无法携带二进制流。</li>
<li><code>enctype=&quot;multipart/form-data&quot;</code>：告诉浏览器把请求体切分成多个部分（Part），并将文件转为二进制流发送，而不是 key&#x3D;value 字符串。</li>
<li><code>type=&quot;file&quot;</code>：文件选择控件。</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    头像：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;headerImg&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-1-2-依赖引入-pom-xml-SSM-场景"><a href="#5-1-2-依赖引入-pom-xml-SSM-场景" class="headerlink" title="5.1.2 依赖引入 (pom.xml - SSM 场景)"></a>5.1.2 依赖引入 (<code>pom.xml</code> - SSM 场景)</h4><p><em>注：如果是 Spring Boot 项目，无需手动引入，<code>spring-boot-starter-web</code> 已内置所有依赖。</em></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Commons FileUpload (仅在非 Servlet 3.0 环境或使用 Commons 解析器时需要) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-1-3-SpringMVC-配置-spring-mvc-xml-SSM-场景"><a href="#5-1-3-SpringMVC-配置-spring-mvc-xml-SSM-场景" class="headerlink" title="5.1.3 SpringMVC 配置 (spring-mvc.xml - SSM 场景)"></a>5.1.3 SpringMVC 配置 (<code>spring-mvc.xml</code> - SSM 场景)</h4><p>必须配置一个 <strong>MultipartResolver</strong>，且 <strong>id 必须叫 <code>multipartResolver</code></strong>（Spring 源码是写死按这个 id 查找 Bean 的）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置默认编码，防止中文文件名乱码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 单个文件最大值 (5MB = 5*1024*1024) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSizePerFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5242880&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 总上传最大值 (10MB) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10485760&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-1-4-Controller-代码实现"><a href="#5-1-4-Controller-代码实现" class="headerlink" title="5.1.4 Controller 代码实现"></a>5.1.4 Controller 代码实现</h4><p>使用 <strong><code>MultipartFile</code></strong> 接口接收文件，不要用原生 Servlet API。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestParam(&quot;headerImg&quot;)</span> MultipartFile file, </span></span><br><span class="line"><span class="params">                     HttpServletRequest request)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 基础校验</span></span><br><span class="line">    <span class="keyword">if</span> (file.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;上传失败，请选择文件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取原始文件名 (如: avatar.png)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 生成唯一文件名 (UUID + 后缀)，防止同名文件覆盖</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">newFileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + suffix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 确定上传路径</span></span><br><span class="line">    <span class="comment">// 注意：request.getServletContext().getRealPath 只是临时方案，重启会丢失！</span></span><br><span class="line">    <span class="comment">// 生产环境建议配置固定磁盘路径，如 &quot;/opt/data/uploads&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;/uploads&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(realPath);</span><br><span class="line">    <span class="keyword">if</span> (!dir.exists()) dir.mkdirs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 执行保存 (核心操作)</span></span><br><span class="line">    <span class="comment">// transferTo 底层会自动将输入流写入目标文件</span></span><br><span class="line">    file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(dir, newFileName));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.success(newFileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-2-文件下载"><a href="#5-2-文件下载" class="headerlink" title="5.2 文件下载"></a>5.2 文件下载</h3><p>文件下载的本质是：<strong>读取服务器文件 -&gt; 写入 Response 输出流 -&gt; 设置 <code>Content-Disposition</code> 响应头</strong>。</p>
<h4 id="5-2-1-下载辅助依赖"><a href="#5-2-1-下载辅助依赖" class="headerlink" title="5.2.1 下载辅助依赖"></a>5.2.1 下载辅助依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 简化文件 I/O 操作 (FileUtils.readFileToByteArray) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-2-2-核心实现-小文件下载"><a href="#5-2-2-核心实现-小文件下载" class="headerlink" title="5.2.2 核心实现 (小文件下载)"></a>5.2.2 核心实现 (小文件下载)</h4><p>使用 <code>ResponseEntity</code> 可以优雅地设置 HTTP 头和状态码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;<span class="type">byte</span>[]&gt; download(HttpServletRequest request, String filename) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 定位文件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;/uploads/&quot;</span> + filename);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.notFound().build(); <span class="comment">// 404</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置响应头</span></span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    <span class="comment">// attachment: 告诉浏览器以附件形式下载，而不是尝试打开它</span></span><br><span class="line">    <span class="comment">// filename: 指定下载时的默认文件名 (需处理中文乱码: UTF-8 -&gt; ISO-8859-1)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">downloadFileName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(filename.getBytes(<span class="string">&quot;UTF-8&quot;</span>), <span class="string">&quot;ISO-8859-1&quot;</span>);</span><br><span class="line">    headers.setContentDispositionFormData(<span class="string">&quot;attachment&quot;</span>, downloadFileName);</span><br><span class="line">    headers.setContentType(MediaType.APPLICATION_OCTET_STREAM); <span class="comment">// 二进制流</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 读取文件并返回 (仅适用于小文件)</span></span><br><span class="line">    <span class="comment">// 风险：FileUtils.readFileToByteArray 会把整个文件加载进内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(FileUtils.readFileToByteArray(file), headers, HttpStatus.OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-2-3-大文件下载优化-StreamingResponseBody"><a href="#5-2-3-大文件下载优化-StreamingResponseBody" class="headerlink" title="5.2.3 大文件下载优化 (StreamingResponseBody)"></a>5.2.3 大文件下载优化 (<code>StreamingResponseBody</code>)</h4><p><strong>痛点</strong>：<code>ResponseEntity&lt;byte[]&gt;</code> 会导致内存溢出 (OOM)。如果 100 个人同时下载 1GB 的视频，服务器内存瞬间撑爆。</p>
<p><strong>方案</strong>：使用 <strong><code>StreamingResponseBody</code></strong> 进行流式传输，一边读硬盘一边发网络，不占内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download/stream&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;StreamingResponseBody&gt; <span class="title function_">downloadStream</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/opt/data/large-movie.mp4&quot;</span>; <span class="comment">// 假设是本地固定路径</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    headers.setContentDispositionFormData(<span class="string">&quot;attachment&quot;</span>, <span class="string">&quot;movie.mp4&quot;</span>);</span><br><span class="line">    headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心：返回一个回调接口，SpringMVC 会在写入响应流时调用它</span></span><br><span class="line">    <span class="type">StreamingResponseBody</span> <span class="variable">stream</span> <span class="operator">=</span> outputStream -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123;</span><br><span class="line">            <span class="comment">// 每次只读 4KB，内存占用极低</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            <span class="type">int</span> bytesRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                outputStream.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(stream, headers, HttpStatus.OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-3-实战避坑：虚拟路径映射"><a href="#5-3-实战避坑：虚拟路径映射" class="headerlink" title="5.3 实战避坑：虚拟路径映射"></a>5.3 实战避坑：虚拟路径映射</h3><blockquote>
<p><strong>问题</strong>：<code>request.getServletContext().getRealPath(&quot;/uploads&quot;)</code> 指向的是 Tomcat 的临时部署目录 (<code>webapps</code>). <strong>一旦重新部署，该目录会被清空，用户上传的文件全没了！</strong></p>
</blockquote>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>存储</strong>：将文件保存到服务器的一个固定磁盘目录（如 <code>D:/uploads/</code> 或 Linux <code>/opt/data/</code>）。</li>
<li><strong>访问</strong>：配置<strong>虚拟路径映射</strong>，把 URL <code>/files/**</code> 映射到本地目录。</li>
</ol>
<p><strong>配置方式 (Java Config &#x2F; Spring Boot)</strong></p>
<p>在 <code>WebMvcConfigurer</code> 实现类中配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 当访问 http://localhost:8080/files/avatar.png 时</span></span><br><span class="line">    <span class="comment">// 实际上去 D:/uploads/avatar.png 找</span></span><br><span class="line">    registry.addResourceHandler(<span class="string">&quot;/files/**&quot;</span>)</span><br><span class="line">            .addResourceLocations(<span class="string">&quot;file:D:/uploads/&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-4-多文件上传"><a href="#5-4-多文件上传" class="headerlink" title="5.4 多文件上传"></a>5.4 多文件上传</h3><p>前端 <code>input</code> 添加 <code>multiple</code> 属性，后端使用数组或集合接收。</p>
<p><strong>后端代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/upload/batch&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">uploadBatch</span><span class="params">(<span class="meta">@RequestParam(&quot;files&quot;)</span> MultipartFile[] files)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (MultipartFile file : files) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!file.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 复用之前的保存逻辑...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.success(<span class="string">&quot;批量上传成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-5-核心接口剖析：MultipartFile-与-Part"><a href="#5-5-核心接口剖析：MultipartFile-与-Part" class="headerlink" title="5.5 核心接口剖析：MultipartFile 与 Part"></a>5.5 核心接口剖析：MultipartFile 与 Part</h3><h4 id="5-5-1-什么是-MultipartFile？"><a href="#5-5-1-什么是-MultipartFile？" class="headerlink" title="5.5.1 什么是 MultipartFile？"></a>5.5.1 什么是 MultipartFile？</h4><p><code>org.springframework.web.multipart.MultipartFile</code> 是 Spring 对上传文件的一层<strong>抽象封装</strong>。它的作用是<strong>屏蔽底层的具体实现细节</strong>，让开发者无论使用哪种底层技术，代码都不用变。</p>
<p><strong>常用方法速查：</strong></p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>getOriginalFilename()</code></td>
<td align="left">获取原始文件名 (如 “avatar.png”)</td>
</tr>
<tr>
<td align="left"><code>getSize()</code></td>
<td align="left">获取文件大小 (字节)</td>
</tr>
<tr>
<td align="left"><code>isEmpty()</code></td>
<td align="left">判断文件是否为空 (size &#x3D;&#x3D; 0)</td>
</tr>
<tr>
<td align="left"><code>getInputStream()</code></td>
<td align="left">获取输入流 (用于自定义读取)</td>
</tr>
<tr>
<td align="left"><strong><code>transferTo(File dest)</code></strong></td>
<td align="left"><strong>核心方法</strong>：将文件直接保存到目标路径</td>
</tr>
</tbody></table>
<hr>
<h4 id="5-5-2-MultipartFile-与-Part-的关系-适配器模式"><a href="#5-5-2-MultipartFile-与-Part-的关系-适配器模式" class="headerlink" title="5.5.2 MultipartFile 与 Part 的关系 (适配器模式)"></a>5.5.2 MultipartFile 与 Part 的关系 (适配器模式)</h4><p>Spring MVC 通过配置不同的 <strong>MultipartResolver</strong> 来决定底层用谁：</p>
<ol>
<li><strong>StandardServletMultipartResolver (Spring Boot 默认)</strong><ul>
<li>底层：基于 <strong>Servlet 3.0+ 标准 (<code>javax.servlet.http.Part</code>)</strong>。</li>
<li>无需第三方 jar 包，性能更好。</li>
<li>Spring 将 <code>Part</code> 包装为 <code>StandardMultipartFile</code>。</li>
</ul>
</li>
<li><strong>CommonsMultipartResolver (SSM 旧项目)</strong><ul>
<li>底层：基于 <strong>Apache Commons FileUpload</strong>。</li>
<li>Spring 将 <code>FileItem</code> 包装为 <code>CommonsMultipartFile</code>。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-5-3-为什么推荐用-MultipartFile-而不是-Part？"><a href="#5-5-3-为什么推荐用-MultipartFile-而不是-Part？" class="headerlink" title="5.5.3 为什么推荐用 MultipartFile 而不是 Part？"></a>5.5.3 为什么推荐用 MultipartFile 而不是 Part？</h4><ol>
<li><strong>解耦</strong>：如果有一天你想把底层从 Tomcat 换成 Jetty，或者升级上传组件，业务代码一行都不用改。</li>
<li><strong>便利性</strong>：<code>MultipartFile.transferTo(dest)</code> 自动处理了绝对路径问题，而 <code>Part.write(name)</code> 在不同容器中的路径处理行为不一致（有些是相对临时目录，有些是绝对路径），极其容易踩坑。</li>
</ol>
<hr>
<h1 id="七、SpringMVC-配置进化论（从-SSM-到-Boot）"><a href="#七、SpringMVC-配置进化论（从-SSM-到-Boot）" class="headerlink" title="七、SpringMVC 配置进化论（从 SSM 到 Boot）"></a>七、SpringMVC 配置进化论（从 SSM 到 Boot）</h1><h2 id="1-配置方式的演变"><a href="#1-配置方式的演变" class="headerlink" title="1. 配置方式的演变"></a>1. 配置方式的演变</h2><p>SpringMVC 的发展史，本质上就是一部 <strong>“去 XML 化”</strong> 的历史。</p>
<h3 id="1-1-Web-xml-SpringXML-考古级-1-0-时代"><a href="#1-1-Web-xml-SpringXML-考古级-1-0-时代" class="headerlink" title="1.1 Web.xml + SpringXML (考古级 - 1.0 时代)"></a>1.1 Web.xml + SpringXML (考古级 - 1.0 时代)</h3><blockquote>
<p><strong>状态</strong>：SSM 老项目标配，现代开发已淘汰。仅需了解，为了看懂 10 年前的代码。</p>
</blockquote>
<ul>
<li><strong>核心动作 1 (Web.xml)</strong>：在 <code>web.xml</code> 中手动注册 <code>DispatcherServlet</code>，并指定配置文件的路径（如 <code>classpath:spring-mvc.xml</code>）。</li>
<li><strong>核心动作 2 (SpringXML)</strong>：编写 XML 文件，使用 <code>&lt;context:component-scan&gt;</code> 扫描包，使用 <code>&lt;mvc:annotation-driven&gt;</code> 开启注解驱动，使用 <code>&lt;mvc:interceptors&gt;</code> 配置拦截器。</li>
<li><strong>痛点</strong>：配置繁琐，没有类型安全检查，XML 写错标签查错困难。</li>
</ul>
<hr>
<h3 id="1-2-Java-Config-全注解方式-原理级-2-0-时代"><a href="#1-2-Java-Config-全注解方式-原理级-2-0-时代" class="headerlink" title="1.2 Java Config 全注解方式 (原理级 - 2.0 时代)"></a>1.2 Java Config 全注解方式 (原理级 - 2.0 时代)</h3><blockquote>
<p><strong>状态</strong>：Spring 3.x+ &#x2F; Servlet 3.0+ 引入。<strong>这是理解 Spring Boot 自动配置原理的必经之路。</strong></p>
</blockquote>
<p>Spring 官方开始推荐用 Java 类（<code>@Configuration</code>）替代 XML。</p>
<h4 id="1-2-1-替代-web-xml-的原理"><a href="#1-2-1-替代-web-xml-的原理" class="headerlink" title="1.2.1 替代 web.xml 的原理"></a>1.2.1 替代 web.xml 的原理</h4><p>Tomcat 启动时会通过 SPI 机制加载 <code>ServletContainerInitializer</code>，Spring 利用这个机制，允许我们通过继承 <strong><code>AbstractAnnotationConfigDispatcherServletInitializer</code></strong> 来动态注册 DispatcherServlet。</p>
<p><strong>代码示例 (看看就好，不用背)：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 指定 Root 配置类 (替代 applicationContext.xml)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; SpringConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 指定 Web 配置类 (替代 spring-mvc.xml)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; WebConfig.class &#125;; <span class="comment">// 下面会讲 WebConfig 怎么写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 指定 DispatcherServlet 的映射路径 (url-pattern)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;/&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-2-替代-spring-mvc-xml-的方式"><a href="#1-2-2-替代-spring-mvc-xml-的方式" class="headerlink" title="1.2.2 替代 spring-mvc.xml 的方式"></a>1.2.2 替代 spring-mvc.xml 的方式</h4><p>通过继承或实现 <strong><code>WebMvcConfigurer</code></strong> 接口的 Java 类来配置 MVC 组件。这正是 Spring Boot 现在的做法。</p>
<hr>
<h2 id="2-WebMvcConfigurer-接口详解-核心重点"><a href="#2-WebMvcConfigurer-接口详解-核心重点" class="headerlink" title="2. WebMvcConfigurer 接口详解 (核心重点)"></a>2. WebMvcConfigurer 接口详解 (核心重点)</h2><blockquote>
<p><strong>地位</strong>：在 Spring Boot 时代，如果你想定制 SpringMVC（加拦截器、改跨域、配资源映射），<strong>99% 的工作都是实现这个接口</strong>。</p>
</blockquote>
<h3 id="2-1-什么是-WebMvcConfigurer？"><a href="#2-1-什么是-WebMvcConfigurer？" class="headerlink" title="2.1 什么是 WebMvcConfigurer？"></a>2.1 什么是 WebMvcConfigurer？</h3><p>在 Spring 5.0 之前，我们通常继承 <code>WebMvcConfigurerAdapter</code>（抽象类）。但在 Java 8 接口支持默认方法后，这个适配器类已过时。</p>
<p>现在，我们直接实现 <strong><code>WebMvcConfigurer</code></strong> 接口，并重写我们需要的方法即可。</p>
<hr>
<h3 id="2-2-常用配置方法实战"><a href="#2-2-常用配置方法实战" class="headerlink" title="2.2 常用配置方法实战"></a>2.2 常用配置方法实战</h3><p>创建一个配置类，加上 <code>@Configuration</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginInterceptor loginInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 添加拦截器 (最常用)</span></span><br><span class="line"><span class="comment">     * 对应 XML: &lt;mvc:interceptors&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(loginInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)             <span class="comment">// 拦截所有</span></span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/public/**&quot;</span>); <span class="comment">// 放行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 跨域配置 (CORS)</span></span><br><span class="line"><span class="comment">     * 对应 XML: &lt;mvc:cors&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 静态资源映射</span></span><br><span class="line"><span class="comment">     * 场景：将 URL /files/** 映射到本地磁盘 D:/uploads/</span></span><br><span class="line"><span class="comment">     * 对应 XML: &lt;mvc:resources&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/files/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;file:D:/uploads/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4. 消息转换器配置 (进阶)</span></span><br><span class="line"><span class="comment">     * 场景：全局解决 Long 类型转 JSON 精度丢失问题，或修改日期格式</span></span><br><span class="line"><span class="comment">     * 注意：推荐使用 extendMessageConverters 而不是 configureMessageConverters，</span></span><br><span class="line"><span class="comment">     * 因为 configure 会覆盖掉 Spring Boot 默认的一堆转换器。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">        <span class="comment">// 在列表最前面添加一个自定义的 Jackson 转换器</span></span><br><span class="line">        <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">myConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">        <span class="comment">// ... 配置 myConverter ...</span></span><br><span class="line">        converters.add(<span class="number">0</span>, myConverter);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 5. 视图控制器 (简单页面跳转)</span></span><br><span class="line"><span class="comment">     * 场景：访问 / 直接跳转到 login 页面，不想特意写个 Controller</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;login&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-总结：从-SSM-到-Boot-的映射关系"><a href="#2-3-总结：从-SSM-到-Boot-的映射关系" class="headerlink" title="2.3 总结：从 SSM 到 Boot 的映射关系"></a>2.3 总结：从 SSM 到 Boot 的映射关系</h3><table>
<thead>
<tr>
<th align="left">功能需求</th>
<th align="left">SSM (XML)</th>
<th align="left">Spring Boot (Java Config)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>开启 MVC</strong></td>
<td align="left"><code>&lt;mvc:annotation-driven/&gt;</code></td>
<td align="left"><code>@EnableWebMvc</code> (<strong>慎用</strong>)</td>
</tr>
<tr>
<td align="left"><strong>拦截器</strong></td>
<td align="left"><code>&lt;mvc:interceptors&gt;</code></td>
<td align="left"><code>addInterceptors()</code></td>
</tr>
<tr>
<td align="left"><strong>跨域</strong></td>
<td align="left"><code>&lt;mvc:cors&gt;</code></td>
<td align="left"><code>addCorsMappings()</code></td>
</tr>
<tr>
<td align="left"><strong>静态资源</strong></td>
<td align="left"><code>&lt;mvc:resources&gt;</code></td>
<td align="left"><code>addResourceHandlers()</code></td>
</tr>
<tr>
<td align="left"><strong>JSON 配置</strong></td>
<td align="left"><code>&lt;mvc:message-converters&gt;</code></td>
<td align="left"><code>extendMessageConverters()</code></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>特别注意 <code>@EnableWebMvc</code></strong>：</p>
<p>在 Spring Boot 中，<strong>通常不需要</strong>在配置类上加 <code>@EnableWebMvc</code>。</p>
<ul>
<li>如果不加：Spring Boot 会应用自动配置（默认配好了 Jackson、静态资源映射等），并叠加你的 <code>WebMvcConfigurer</code> 配置。</li>
<li>如果加了：表示<strong>完全接管</strong> SpringMVC，Spring Boot 的自动配置（如静态资源访问）会<strong>全部失效</strong>，你必须自己把所有东西重配一遍。</li>
<li><strong>结论</strong>：除非要改变整个框架，否则<strong>别加</strong>这个注解。</li>
</ul>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringBoot/" rel="prev" title="Spring全家桶-SpringBoot">
                  <i class="fa fa-angle-left"></i> Spring全家桶-SpringBoot
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringData/" rel="next" title="Spring全家桶-SpringData">
                  Spring全家桶-SpringData <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
