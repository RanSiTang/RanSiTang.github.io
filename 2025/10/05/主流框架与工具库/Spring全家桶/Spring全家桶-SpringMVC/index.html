<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="一、初识 SpringMVC1. Web开发演进史Web 开发一直在解决一个核心矛盾：业务逻辑（Java 代码）与 页面展示（HTML 代码）的耦合问题。 第一阶段：纯 Servlet 时代（史前时代）在 Java Web 刚诞生时，没有 JSP，只有 Servlet。  工作模式：所有的请求处理、数据库操作、HTML 页面拼接，全部在 Java 类（Servlet）中完成。  代码示例（伪代码）">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring全家桶-SpringMVC">
<meta property="og:url" content="http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringMVC/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="一、初识 SpringMVC1. Web开发演进史Web 开发一直在解决一个核心矛盾：业务逻辑（Java 代码）与 页面展示（HTML 代码）的耦合问题。 第一阶段：纯 Servlet 时代（史前时代）在 Java Web 刚诞生时，没有 JSP，只有 Servlet。  工作模式：所有的请求处理、数据库操作、HTML 页面拼接，全部在 Java 类（Servlet）中完成。  代码示例（伪代码）">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-05T06:27:02.000Z">
<meta property="article:modified_time" content="2025-12-29T12:05:10.523Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringMVC/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringMVC/","path":"2025/10/05/主流框架与工具库/Spring全家桶/Spring全家桶-SpringMVC/","title":"Spring全家桶-SpringMVC"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Spring全家桶-SpringMVC | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%88%9D%E8%AF%86-SpringMVC"><span class="nav-text">一、初识 SpringMVC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Web%E5%BC%80%E5%8F%91%E6%BC%94%E8%BF%9B%E5%8F%B2"><span class="nav-text">1. Web开发演进史</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%9A%E7%BA%AF-Servlet-%E6%97%B6%E4%BB%A3%EF%BC%88%E5%8F%B2%E5%89%8D%E6%97%B6%E4%BB%A3%EF%BC%89"><span class="nav-text">第一阶段：纯 Servlet 时代（史前时代）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%9AModel-1-%E6%A8%A1%E5%BC%8F%EF%BC%88JSP-%E7%8B%AC%E5%A4%A7%EF%BC%89"><span class="nav-text">第二阶段：Model 1 模式（JSP 独大）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%EF%BC%9AModel-2-%E6%A8%A1%E5%BC%8F%EF%BC%88Servlet-JSP-JavaBean%EF%BC%89"><span class="nav-text">第三阶段：Model 2 模式（Servlet + JSP + JavaBean）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%EF%BC%9AMVC-%E6%A1%86%E6%9E%B6%E6%97%B6%E4%BB%A3%EF%BC%88SpringMVC-%E7%99%BB%E5%9C%BA%EF%BC%89"><span class="nav-text">第四阶段：MVC 框架时代（SpringMVC 登场）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-SpringMVC-%E7%AE%80%E4%BB%8B"><span class="nav-text">2. SpringMVC 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AFSpringMVC"><span class="nav-text">2.1 什么是SpringMVC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF"><span class="nav-text">2.2 核心优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-SpringMVC-vs-Struts2"><span class="nav-text">2.3 SpringMVC vs Struts2</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">二、核心架构与执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="nav-text">1. 核心组件详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-text">1.1 核心组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E5%89%8D%E7%AB%AF%E6%8E%A7%E5%88%B6%E5%99%A8-DispatcherServlet"><span class="nav-text">1.1.1 前端控制器 (DispatcherServlet)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E5%A4%84%E7%90%86%E5%99%A8%E6%98%A0%E5%B0%84%E5%99%A8-HandlerMapping"><span class="nav-text">1.1.2 处理器映射器 (HandlerMapping)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-%E5%A4%84%E7%90%86%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8-HandlerAdapter"><span class="nav-text">1.1.3 处理器适配器 (HandlerAdapter)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-4-%E5%A4%84%E7%90%86%E5%99%A8-Handler"><span class="nav-text">1.1.4 处理器 (Handler)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-5-%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8-ViewResolver"><span class="nav-text">1.1.5  视图解析器 (ViewResolver)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-6-%E8%A7%86%E5%9B%BE-View"><span class="nav-text">1.1.6 视图 (View)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%BE%85%E5%8A%A9%E7%BB%84%E4%BB%B6"><span class="nav-text">1.2 辅助组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-HandlerExceptionResolver-%E5%BC%82%E5%B8%B8%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-text">1.2.1 HandlerExceptionResolver (异常解析器)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-MultipartResolver-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-text">1.2.2 MultipartResolver (文件上传解析器)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-FlashMapManager"><span class="nav-text">1.2.3 FlashMapManager</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">2. 执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-text">2.1 流程图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%85%AB%E6%AD%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">2.2 八步执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%9A%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84"><span class="nav-text">第一阶段：请求映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%9A%E4%B8%9A%E5%8A%A1%E6%89%A7%E8%A1%8C"><span class="nav-text">第二阶段：业务执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%EF%BC%9A%E8%A7%86%E5%9B%BE%E6%B8%B2%E6%9F%93"><span class="nav-text">第三阶段：视图渲染</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%BA%90%E7%A0%81%E7%BA%A7%E7%90%86%E8%A7%A3"><span class="nav-text">2.3 源码级理解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="nav-text">三、请求处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-RequestMapping-%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3"><span class="nav-text">1. @RequestMapping 注解详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%B3%A8%E8%A7%A3%E6%A6%82%E8%BF%B0"><span class="nav-text">1.1 注解概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%A0%87%E6%B3%A8%E4%BD%8D%E7%BD%AE%E4%B8%8E%E8%B7%AF%E5%BE%84%E7%BB%A7%E6%89%BF"><span class="nav-text">1.2 标注位置与路径继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-URL-%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="nav-text">1.3 URL 路径匹配规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-%E7%B2%BE%E7%A1%AE%E5%8C%B9%E9%85%8D"><span class="nav-text">1.3.1 精确匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-Ant-%E9%A3%8E%E6%A0%BC%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-text">1.3.2 Ant 风格通配符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3-%E5%8D%A0%E4%BD%8D%E7%AC%A6%E5%8C%B9%E9%85%8D"><span class="nav-text">1.3.3 占位符匹配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-HTTP-%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E9%99%90%E5%AE%9A"><span class="nav-text">1.4 HTTP 请求方式限定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E4%B8%8E%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%99%90%E5%AE%9A"><span class="nav-text">1.5 请求参数与请求头限定</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-params-%E5%B1%9E%E6%80%A7%EF%BC%88%E9%99%90%E5%AE%9A%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%EF%BC%89"><span class="nav-text">1.5.1 params 属性（限定请求参数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-2-headers-%E5%B1%9E%E6%80%A7%EF%BC%88%E9%99%90%E5%AE%9A%E8%AF%B7%E6%B1%82%E5%A4%B4%EF%BC%89"><span class="nav-text">1.5.2 headers 属性（限定请求头）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="nav-text">2. 参数绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%A6%82%E8%BF%B0"><span class="nav-text">2.1 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%85%AD%E5%A4%A7%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3"><span class="nav-text">2.2 六大绑定方式详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-RequestParam%EF%BC%9A%E5%A4%84%E7%90%86%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0%E4%B8%8E%E8%A1%A8%E5%8D%95%E5%AD%97%E6%AE%B5"><span class="nav-text">2.2.1 @RequestParam：处理查询参数与表单字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-PathVariable%EF%BC%9A%E5%A4%84%E7%90%86-URL-%E8%B7%AF%E5%BE%84%E5%8F%98%E9%87%8F"><span class="nav-text">2.2.2 @PathVariable：处理 URL 路径变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-RequestBody%EF%BC%9A%E5%A4%84%E7%90%86-JSON-%E8%AF%B7%E6%B1%82%E4%BD%93"><span class="nav-text">2.2.3  @RequestBody：处理 JSON 请求体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-POJO-%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A%EF%BC%9AForm-%E8%A1%A8%E5%8D%95%E8%87%AA%E5%8A%A8%E5%B0%81%E8%A3%85"><span class="nav-text">2.2.4 POJO 对象绑定：Form 表单自动封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-5-RequestHeader%EF%BC%9A%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="nav-text">2.2.5 @RequestHeader：获取请求头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-6-CookieValue%EF%BC%9A%E8%8E%B7%E5%8F%96-Cookie"><span class="nav-text">2.2.6 @CookieValue：获取 Cookie</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E9%AB%98%E7%BA%A7%E7%BB%91%E5%AE%9A%E4%B8%8E%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97"><span class="nav-text">2.3 高级绑定与避坑指南</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-List-%E9%9B%86%E5%90%88%E7%BB%91%E5%AE%9A%E7%9A%84%E2%80%9C%E5%9D%91%E2%80%9D"><span class="nav-text">2.3.1 List 集合绑定的“坑”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-400-Bad-Request%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5"><span class="nav-text">2.3.2 400 Bad Request错误排查</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98"><span class="nav-text">3. 中文乱码问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E4%B9%B1%E7%A0%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%A0%B9%E6%BA%90"><span class="nav-text">3.1 乱码产生的根源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E8%AF%B7%E6%B1%82%E4%B9%B1%E7%A0%81"><span class="nav-text">3.2 请求乱码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-POST-%E8%AF%B7%E6%B1%82%E4%B9%B1%E7%A0%81-%E6%9C%80%E5%B8%B8%E8%A7%81"><span class="nav-text">3.2.1 POST 请求乱码 (最常见)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-GET-%E8%AF%B7%E6%B1%82%E4%B9%B1%E7%A0%81-%E5%8E%86%E5%8F%B2%E9%81%97%E7%95%99"><span class="nav-text">3.2.2 GET 请求乱码 (历史遗留)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%93%8D%E5%BA%94%E4%B9%B1%E7%A0%81"><span class="nav-text">3.3 响应乱码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E8%BF%94%E5%9B%9E-JSON-%E6%95%B0%E6%8D%AE%E4%B9%B1%E7%A0%81"><span class="nav-text">3.3.1 返回 JSON 数据乱码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E8%8E%B7%E5%8F%96%E5%8E%9F%E7%94%9F-Servlet-API"><span class="nav-text">4. 获取原生 Servlet API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8E%9F%E7%94%9F-API%EF%BC%9F"><span class="nav-text">4.1 为什么需要原生 API？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="nav-text">4.2 获取方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-text">4.3 代码示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86"><span class="nav-text">四、响应处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC"><span class="nav-text">1. 页面跳转</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E8%BD%AC%E5%8F%91-vs-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-text">1.1 转发 vs 重定向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-SpringMVC%E4%B8%AD%E7%9A%84%E8%B7%B3%E8%BD%AC%E6%96%B9%E5%BC%8F"><span class="nav-text">1.2 SpringMVC中的跳转方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E9%BB%98%E8%AE%A4%E8%B7%B3%E8%BD%AC%EF%BC%88%E8%BD%AC%E5%8F%91%EF%BC%89"><span class="nav-text">1.2.1 默认跳转（转发）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E6%98%BE%E5%BC%8F%E8%BD%AC%E5%8F%91-forward"><span class="nav-text">1.2.2 显式转发 (forward:)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E6%98%BE%E5%BC%8F%E9%87%8D%E5%AE%9A%E5%90%91-redirect"><span class="nav-text">1.2.3 显式重定向 (redirect:)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E8%B7%B3%E8%BD%AC%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92"><span class="nav-text">1.3 跳转时的数据传递</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-%E8%BD%AC%E5%8F%91%E5%B8%A6%E6%95%B0%E6%8D%AE-Forward"><span class="nav-text">1.3.1 转发带数据 (Forward)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-%E9%87%8D%E5%AE%9A%E5%90%91%E5%B8%A6%E6%95%B0%E6%8D%AE-Redirect-%E4%B8%89%E7%A7%8D%E6%96%B9%E6%A1%88"><span class="nav-text">1.3.2 重定向带数据 (Redirect) - 三种方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-void-%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-text">1.4 void 返回值的情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="nav-text">2. 数据共享</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E7%9A%84%E6%A0%B8%E5%BF%83%E8%BD%BD%E4%BD%93%EF%BC%9ARequest%E5%9F%9F"><span class="nav-text">2.1 数据共享的核心载体：Request域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E4%B8%89%E7%A7%8D%E4%B8%BB%E8%A6%81%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="nav-text">2.2 三种主要的共享方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E4%BD%BF%E7%94%A8-Model-%E6%8E%A5%E5%8F%A3"><span class="nav-text">2.2.1 使用 Model 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E4%BD%BF%E7%94%A8-Map-%E6%8E%A5%E5%8F%A3"><span class="nav-text">2.2.2 使用 Map 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E4%BD%BF%E7%94%A8-ModelMap-%E7%B1%BB"><span class="nav-text">2.2.3 使用 ModelMap 类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-%E4%BD%BF%E7%94%A8-ModelAndView"><span class="nav-text">2.2.4 使用 ModelAndView</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Session%E5%9F%9F%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="nav-text">2.3 Session域数据共享</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E5%8E%9F%E7%94%9F-HttpSession"><span class="nav-text">2.3.1 原生 HttpSession</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-SessionAttributes-%E6%B3%A8%E8%A7%A3"><span class="nav-text">2.3.2 @SessionAttributes 注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-Application-%E5%9F%9F%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="nav-text">2.4 Application 域数据共享</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-JSON-%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92"><span class="nav-text">3. JSON 数据交互</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%A0%B8%E5%BF%83%E4%BE%9D%E8%B5%96"><span class="nav-text">3.1 核心依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E8%BE%93%E5%87%BA-JSON-Java-JSON"><span class="nav-text">3.2 输出 JSON (Java -&gt; JSON)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-ResponseBody-%E6%B3%A8%E8%A7%A3"><span class="nav-text">3.2.1 @ResponseBody 注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-RestController-%E6%B3%A8%E8%A7%A3"><span class="nav-text">3.2.2 @RestController 注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E8%BE%93%E5%85%A5-JSON-JSON-Java"><span class="nav-text">3.3 输入 JSON (JSON -&gt; Java)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-RequestBody-%E6%B3%A8%E8%A7%A3"><span class="nav-text">3.3.1 @RequestBody 注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%B8%B8%E8%A7%81-JSON-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%B3%A8%E8%A7%A3"><span class="nav-text">3.4 常见 JSON 格式化注解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-ResponseEntity-%E6%B7%B1%E5%BA%A6%E5%AE%9A%E5%88%B6%E5%93%8D%E5%BA%94"><span class="nav-text">4. ResponseEntity 深度定制响应</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E4%BB%80%E4%B9%88%E6%98%AF-ResponseEntity%EF%BC%9F"><span class="nav-text">4.1 什么是 ResponseEntity？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AE%83"><span class="nav-text">4.2 为什么需要它</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-text">4.3 基本用法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E9%93%BE%E5%BC%8F%E6%9E%84%E5%BB%BA%E9%A3%8E%E6%A0%BC"><span class="nav-text">4.3.1 链式构建风格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%E6%9E%84%E9%80%A0%E5%99%A8%E9%A3%8E%E6%A0%BC"><span class="nav-text">4.3.2 构造器风格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="nav-text">4.3.3 自定义响应头</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%AE%9E%E6%88%98"><span class="nav-text">五、高级功能与实战</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="nav-text">1. 拦截器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%9F"><span class="nav-text">1.1 什么是拦截器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%8B%A6%E6%88%AA%E5%99%A8-vs-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-text">1.2 拦截器 vs 过滤器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">1.3 三大核心方法 (生命周期)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E5%AE%9E%E6%88%98%EF%BC%9A%E7%99%BB%E5%BD%95%E6%9D%83%E9%99%90%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="nav-text">1.4 实战：登录权限拦截器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-%E7%BC%96%E5%86%99%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="nav-text">1.4.1 编写拦截器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-2-%E9%85%8D%E7%BD%AE-%E6%B3%A8%E5%86%8C%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="nav-text">1.4.2 配置&#x2F;注册拦截器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%9F%BA%E4%BA%8EJava%E9%85%8D%E7%BD%AE"><span class="nav-text">1. 基于Java配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%9F%BA%E4%BA%8E-XML-%E9%85%8D%E7%BD%AE"><span class="nav-text">2. 基于 XML 配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E5%A4%9A%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-text">1.5 多拦截器的执行顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD"><span class="nav-text">2. 文件上传与下载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="nav-text">2.1 文件上传</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E5%89%8D%E7%AB%AF%E8%A1%A8%E5%8D%95%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-text">2.1.1 前端表单三要素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E4%BE%9D%E8%B5%96%E5%BC%95%E5%85%A5-pom-xml"><span class="nav-text">2.1.2 依赖引入 (pom.xml)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-SpringMVC-%E9%85%8D%E7%BD%AE-spring-mvc-xml"><span class="nav-text">2.1.3 SpringMVC 配置 (spring-mvc.xml)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-Controller-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.1.4 Controller 代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD"><span class="nav-text">2.2 文件下载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E4%B8%8B%E8%BD%BD%E8%BE%85%E5%8A%A9%E4%BE%9D%E8%B5%96"><span class="nav-text">2.2.1 下载辅助依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.2.2 核心实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E4%BC%98%E5%8C%96-StreamingResponseBody"><span class="nav-text">2.2.3 大文件下载优化 (StreamingResponseBody)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%AE%9E%E6%88%98%E9%81%BF%E5%9D%91%EF%BC%9A%E8%99%9A%E6%8B%9F%E8%B7%AF%E5%BE%84%E6%98%A0%E5%B0%84"><span class="nav-text">2.3 实战避坑：虚拟路径映射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E9%85%8D%E7%BD%AE-Tomcat-%E6%98%A0%E5%B0%84-%E9%92%88%E5%AF%B9-spring-mvc-xml-%E6%96%B9%E5%BC%8F"><span class="nav-text">2.3.1 配置 Tomcat 映射 (针对 spring-mvc.xml 方式)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-Spring-MVC-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%98%A0%E5%B0%84"><span class="nav-text">2.3.2 Spring MVC 静态资源映射</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%A4%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="nav-text">2.4 多文件上传</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3%E5%89%96%E6%9E%90%EF%BC%9AMultipartFile-%E4%B8%8E-Part"><span class="nav-text">2.5 核心接口剖析：MultipartFile 与 Part</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1-%E4%BB%80%E4%B9%88%E6%98%AF-MultipartFile%EF%BC%9F"><span class="nav-text">2.5.1 什么是 MultipartFile？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-MultipartFile-%E4%B8%8E-Part%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">2.5.2 MultipartFile 与 Part的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E7%94%A8-MultipartFile-%E8%80%8C%E4%B8%8D%E6%98%AF-Part%EF%BC%9F"><span class="nav-text">2.5.3 为什么推荐用 MultipartFile 而不是 Part？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">3. 全局异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%9F"><span class="nav-text">3.1 为什么需要全局异常处理器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-SpringMVC-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-text">3.2 SpringMVC 异常处理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-SimpleMappingExceptionResolver-XML-%E9%85%8D%E7%BD%AE"><span class="nav-text">3.2.1 SimpleMappingExceptionResolver (XML 配置)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-ControllerAdvice-ExceptionHandler-%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8"><span class="nav-text">3.2.2 @ControllerAdvice + @ExceptionHandler (注解驱动)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="nav-text">3.3 自定义异常体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="nav-text">3.4 原理解析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E6%A0%A1%E9%AA%8C"><span class="nav-text">4. 数据格式化与校验</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-text">4.1 数据格式化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-DateTimeFormat-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-text">4.1.1 @DateTimeFormat (日期格式化)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-NumberFormat-%E6%95%B0%E5%80%BC%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-text">4.1.2 @NumberFormat (数值格式化)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C-Validation-JSR-303"><span class="nav-text">4.2 数据校验 (Validation) - JSR-303</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E4%BE%9D%E8%B5%96%E5%BC%95%E5%85%A5"><span class="nav-text">4.2.1 依赖引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E5%B8%B8%E7%94%A8%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3"><span class="nav-text">4.2.2 常用校验注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-%E5%BC%80%E5%90%AF%E6%A0%A1%E9%AA%8C-Valid-Validated"><span class="nav-text">4.2.3 开启校验 (@Valid &#x2F; @Validated)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C"><span class="nav-text">4.3 分组校验</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E5%AE%9A%E4%B9%89%E5%88%86%E7%BB%84%E6%8E%A5%E5%8F%A3"><span class="nav-text">4.3.1 定义分组接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%E5%9C%A8POJO%E4%B8%8A%E6%8C%87%E5%AE%9A%E5%88%86%E7%BB%84"><span class="nav-text">4.3.2 在POJO上指定分组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-%E5%9C%A8Controller%E4%B8%AD%E6%8C%87%E5%AE%9A%E5%88%86%E7%BB%84"><span class="nav-text">4.3.3 在Controller中指定分组</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81SSM-%E6%95%B4%E5%90%88%E4%B8%8E%E9%85%8D%E7%BD%AE%E8%BF%9B%E5%8C%96"><span class="nav-text">六、SSM 整合与配置进化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-SSM-%E6%95%B4%E5%90%88-Spring-SpringMVC-MyBatis"><span class="nav-text">1. SSM 整合 (Spring + SpringMVC + MyBatis)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%95%B4%E5%90%88%E6%80%9D%E8%B7%AF%EF%BC%9A%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8F%8C%E5%AE%B9%E5%99%A8"><span class="nav-text">1.1 整合思路：三层架构与双容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="nav-text">1.2 引入依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%84%E5%88%92"><span class="nav-text">1.3 配置文件规划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4"><span class="nav-text">1.4 详细配置步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-web-xml-%E5%90%AF%E5%8A%A8%E5%8F%8C%E5%AE%B9%E5%99%A8"><span class="nav-text">1.4.1 web.xml (启动双容器)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-2-spring-mvc-xml-Web-%E5%B1%82%E9%85%8D%E7%BD%AE"><span class="nav-text">1.4.2 spring-mvc.xml (Web 层配置)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-3-applicationContext-xml-Service-Dao-%E5%B1%82%E9%85%8D%E7%BD%AE"><span class="nav-text">1.4.3 applicationContext.xml (Service + Dao 层配置)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BA%AF%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE"><span class="nav-text">2. 纯注解配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BA%AF%E6%B3%A8%E8%A7%A3"><span class="nav-text">2.1 为什么要纯注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%9B%BF%E4%BB%A3-web-xml%EF%BC%9AAbstractAnnotationConfigDispatcherServletInitializer"><span class="nav-text">2.2 替代 web.xml：AbstractAnnotationConfigDispatcherServletInitializer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%9B%BF%E4%BB%A3-spring-mvc-xml%EF%BC%9AWebMvcConfigurer"><span class="nav-text">2.3 替代 spring-mvc.xml：WebMvcConfigurer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E6%9B%BF%E4%BB%A3-applicationContext-xml%EF%BC%9ASpring-%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="nav-text">2.4 替代 applicationContext.xml：Spring 配置类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="nav-text">七、源码剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-DispatcherServlet-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="nav-text">1. DispatcherServlet 初始化过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE%E8%B0%B1"><span class="nav-text">1.1 继承关系图谱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B"><span class="nav-text">1.2 初始化核心流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-HttpServletBean-init"><span class="nav-text">1.2.1 HttpServletBean.init()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-FrameworkServlet-initServletBean"><span class="nav-text">1.2.2 FrameworkServlet.initServletBean()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-DispatcherServlet-onRefresh"><span class="nav-text">1.2.3 DispatcherServlet.onRefresh()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E7%BB%84%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E9%BB%98%E8%AE%A4%E7%AD%96%E7%95%A5"><span class="nav-text">1.3 组件初始化的默认策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-doDispatch-%E6%96%B9%E6%B3%95%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="nav-text">2. doDispatch 方法深度解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%96%B9%E6%B3%95%E5%85%A5%E5%8F%A3"><span class="nav-text">2.1 方法入口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%BA%90%E7%A0%81%E9%AA%A8%E6%9E%B6-%E4%BC%AA%E4%BB%A3%E7%A0%81%E7%B2%BE%E7%AE%80%E7%89%88"><span class="nav-text">2.2 源码骨架 (伪代码精简版)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90"><span class="nav-text">2.3 关键步骤深度剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-getHandler-%E5%AF%BB%E6%89%BE-Handler"><span class="nav-text">2.3.1 getHandler() - 寻找 Handler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-ha-handle-%E9%80%82%E9%85%8D%E5%99%A8%E6%89%A7%E8%A1%8C"><span class="nav-text">2.3.2 ha.handle() - 适配器执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-processDispatchResult-%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86"><span class="nav-text">2.3.3 processDispatchResult() - 结果处理</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringMVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Spring全家桶-SpringMVC | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring全家桶-SpringMVC
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-05 14:27:02" itemprop="dateCreated datePublished" datetime="2025-10-05T14:27:02+08:00">2025-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-12-29 20:05:10" itemprop="dateModified" datetime="2025-12-29T20:05:10+08:00">2025-12-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/" itemprop="url" rel="index"><span itemprop="name">开发框架与生态</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/" itemprop="url" rel="index"><span itemprop="name">Spring全家桶</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="一、初识-SpringMVC"><a href="#一、初识-SpringMVC" class="headerlink" title="一、初识 SpringMVC"></a>一、初识 SpringMVC</h1><h2 id="1-Web开发演进史"><a href="#1-Web开发演进史" class="headerlink" title="1. Web开发演进史"></a>1. Web开发演进史</h2><p>Web 开发一直在解决一个核心矛盾：<strong>业务逻辑（Java 代码）与 页面展示（HTML 代码）的耦合问题。</strong></p>
<h3 id="第一阶段：纯-Servlet-时代（史前时代）"><a href="#第一阶段：纯-Servlet-时代（史前时代）" class="headerlink" title="第一阶段：纯 Servlet 时代（史前时代）"></a>第一阶段：纯 Servlet 时代（史前时代）</h3><p>在 Java Web 刚诞生时，没有 JSP，只有 Servlet。</p>
<ul>
<li><p><strong>工作模式</strong>：<br>所有的请求处理、数据库操作、HTML 页面拼接，全部在 Java 类（Servlet）中完成。</p>
</li>
<li><p><strong>代码示例（伪代码）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> &#123;</span><br><span class="line">    resp.getWriter().write(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">    resp.getWriter().write(<span class="string">&quot;&lt;body&gt;&quot;</span>);</span><br><span class="line">    resp.getWriter().write(<span class="string">&quot;&lt;h1&gt;欢迎用户：&quot;</span> + username + <span class="string">&quot;&lt;/h1&gt;&quot;</span>); <span class="comment">// 逻辑与视图混杂</span></span><br><span class="line">    resp.getWriter().write(<span class="string">&quot;&lt;/body&gt;&quot;</span>);</span><br><span class="line">    resp.getWriter().write(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>痛点（缺点）</strong>：</p>
<ol>
<li><strong>开发效率极低</strong>：在 Java 字符串中拼接 HTML 是地狱般的体验，极易出错。</li>
<li><strong>维护困难</strong>：修改一个页面标点符号，都需要修改 Java 代码并重新编译。</li>
<li><strong>耦合度过高</strong>：后端开发人员必须精通前端 HTML。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="第二阶段：Model-1-模式（JSP-独大）"><a href="#第二阶段：Model-1-模式（JSP-独大）" class="headerlink" title="第二阶段：Model 1 模式（JSP 独大）"></a>第二阶段：Model 1 模式（JSP 独大）</h3><p>为了解决 Servlet 拼接 HTML 的痛苦，Sun 公司推出了 JSP（Java Server Pages）。</p>
<ul>
<li><p><strong>工作模式</strong>：<br>JSP 本质是 Servlet，但它允许在 HTML 中直接写 Java 代码。Model 1 模式下，<strong>JSP 既负责页面展示，又负责业务逻辑</strong>。</p>
</li>
<li><p><strong>架构流程</strong>：</p>
<ul>
<li>Client -&gt; JSP (接收请求 -&gt; 调 Java Bean 查数据库 -&gt; 渲染页面) -&gt; Client</li>
</ul>
</li>
<li><p><strong>代码示例（JSP）</strong>：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;% </span><br><span class="line">        <span class="comment">// 在页面里直接写逻辑，非常混乱</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findById(id); </span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;h1&gt;欢迎：&lt;%= user.getName() %&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>痛点（缺点）</strong>：</p>
<ol>
<li><strong>职责不清</strong>：JSP 变得极其臃肿，成千上万行代码，包含 HTML、CSS、Java 逻辑、SQL 查询。</li>
<li><strong>“意大利面条式”代码</strong>：逻辑流难以追踪，前端改页面怕动坏逻辑，后端改逻辑怕弄乱页面。</li>
<li><strong>难以复用</strong>：业务逻辑嵌在页面里，其他页面无法复用。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="第三阶段：Model-2-模式（Servlet-JSP-JavaBean）"><a href="#第三阶段：Model-2-模式（Servlet-JSP-JavaBean）" class="headerlink" title="第三阶段：Model 2 模式（Servlet + JSP + JavaBean）"></a>第三阶段：Model 2 模式（Servlet + JSP + JavaBean）</h3><p>这是 MVC 思想的雏形，也是 Web 开发的分水岭。</p>
<ul>
<li><strong>核心思想</strong>：<strong>关注点分离（Separation of Concerns）</strong>。</li>
<li><strong>架构流程</strong>：<ol>
<li><strong>Controller (Servlet)</strong>：负责接收请求，处理业务逻辑（调用 Service），将数据放入 Request 域，<strong>转发</strong>给 JSP。</li>
<li><strong>View (JSP)</strong>：不再处理逻辑，只负责从 Request 域取出数据并展示（使用 EL 表达式和 JSTL）。</li>
<li><strong>Model (JavaBean)</strong>：承载数据。</li>
</ol>
</li>
<li><strong>代码分工</strong>：<ul>
<li><code>UserServlet.java</code>: 处理 <code>/login</code> 请求，判断密码，成功则 <code>req.getRequestDispatcher(&quot;home.jsp&quot;).forward(req, resp);</code></li>
<li><code>home.jsp</code>: 只写 <code>${user.name}</code>。</li>
</ul>
</li>
<li><strong>痛点（缺点 - 为什么还需要 SpringMVC？）</strong>：<br>虽然结构清晰了，但<strong>原生 Servlet 开发依然繁琐</strong>：<ol>
<li><strong>Servlet 太多</strong>：每个业务功能可能都需要一个 Servlet（或者在一个 Servlet 里写大量的 <code>if/else</code> 判断方法）。</li>
<li><strong>参数提取繁琐</strong>：需要手动写 <code>req.getParameter(&quot;age&quot;)</code> 并手动进行类型转换（String 转 Int）。</li>
<li><strong>依赖 Servlet API</strong>：代码严重依赖 Web 容器（Tomcat），导致单元测试困难。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="第四阶段：MVC-框架时代（SpringMVC-登场）"><a href="#第四阶段：MVC-框架时代（SpringMVC-登场）" class="headerlink" title="第四阶段：MVC 框架时代（SpringMVC 登场）"></a>第四阶段：MVC 框架时代（SpringMVC 登场）</h3><p>为了解决 Model 2 中 Servlet 代码重复、繁琐的问题，出现了 Struts 和 SpringMVC 这样的框架。</p>
<ul>
<li><strong>核心思想</strong>：<strong>前端控制器模式（Front Controller Pattern）</strong>。</li>
<li><strong>SpringMVC 做了什么？</strong><ul>
<li>它提供了一个核心的 Servlet（<code>DispatcherServlet</code>），拦截所有请求。</li>
<li>它把“请求参数解析”、“类型转换”、“逻辑跳转”这些脏活累活都封装好了。</li>
<li>开发者只需要写一个简单的 Java 类（Controller），加几个注解（<code>@RequestMapping</code>），就能专注于业务。</li>
</ul>
</li>
<li><strong>演变总结</strong>：<br>从 <strong>“如何实现 Web 功能”</strong> 进化到了 <strong>“如何更优雅、更简便地实现 Web 功能”</strong>。</li>
</ul>
<hr>
<h2 id="2-SpringMVC-简介"><a href="#2-SpringMVC-简介" class="headerlink" title="2. SpringMVC 简介"></a>2. SpringMVC 简介</h2><h3 id="2-1-什么是SpringMVC"><a href="#2-1-什么是SpringMVC" class="headerlink" title="2.1 什么是SpringMVC"></a>2.1 什么是SpringMVC</h3><blockquote>
<p><em>官方定义：Spring Web MVC is the original web framework built on the Servlet API and has been included in the Spring Framework from the very beginning.</em></p>
</blockquote>
<ul>
<li><strong>通俗解释</strong>：<br>SpringMVC 是 Spring 框架中的一个<strong>模块</strong>（子项目），专门用于构建 Web 应用。它基于 <strong>Servlet API</strong> 构建，严格遵循 <strong>MVC 设计模式</strong>。</li>
<li><strong>核心地位</strong>：<br>它不是一个独立存在的框架，而是 Spring 生态系统的一部分。这意味着它<strong>天生就能无缝集成 Spring 的核心功能</strong>（IOC 控制反转 和 AOP 面向切面编程）。</li>
<li><strong>一句话概括</strong>：<br>SpringMVC 就是一个<strong>封装了高级功能的 Servlet</strong>，它帮我们把“请求参数解析”、“视图跳转”、“响应数据封装”等繁琐工作都做完了，让我们只关注业务逻辑。</li>
</ul>
<hr>
<h3 id="2-2-核心优势"><a href="#2-2-核心优势" class="headerlink" title="2.2 核心优势"></a>2.2 核心优势</h3><ol>
<li><strong>轻量级与非侵入性</strong>：<ul>
<li>SpringMVC 的 jar 包很小，且不强制要求你的类继承框架特定的类（Struts2 早期需要继承 ActionSupport）。你的 Controller 就是一个普通的 POJO（普通 Java 对象）。</li>
</ul>
</li>
<li><strong>天生集成 Spring（最大优势）</strong>：<ul>
<li>Controller 可以直接通过 <code>@Autowired</code> 注入 Service 层的 Bean。</li>
<li>统一的事务管理、统一的 AOP 配置，无需像 Struts2 那样编写大量的“胶水代码”来整合 Spring。</li>
</ul>
</li>
<li><strong>强大的参数绑定机制</strong>：<ul>
<li>前端传 <code>user.name</code>，后端直接用 <code>User user</code> 对象接收，框架自动封装，无需手动 <code>request.getParameter</code>。</li>
<li>自动处理复杂数据类型（日期、集合、Map）。</li>
</ul>
</li>
<li><strong>灵活的配置</strong>：<ul>
<li>支持 XML 配置，也支持纯注解配置（0 XML）。</li>
<li>组件化设计：视图解析器、拦截器、文件上传处理器等都可以随意替换或自定义。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-3-SpringMVC-vs-Struts2"><a href="#2-3-SpringMVC-vs-Struts2" class="headerlink" title="2.3 SpringMVC vs Struts2"></a>2.3 SpringMVC vs Struts2</h3><table>
<thead>
<tr>
<th align="left">比较维度</th>
<th align="left"><strong>SpringMVC</strong></th>
<th align="left"><strong>Struts2</strong></th>
<th align="left"><strong>深度解析</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>入口机制</strong></td>
<td align="left"><strong>Servlet</strong> (<code>DispatcherServlet</code>)</td>
<td align="left"><strong>Filter</strong> (<code>StrutsPrepareAndExecuteFilter</code>)</td>
<td align="left">SpringMVC 机制更接近原生 Servlet，效率略高。</td>
</tr>
<tr>
<td align="left"><strong>运行级别</strong></td>
<td align="left"><strong>方法级 (Method Level)</strong></td>
<td align="left"><strong>类级 (Class Level)</strong></td>
<td align="left"><strong>核心区别</strong>：SpringMVC 一个方法处理一个请求；Struts2 一个类处理一个请求。</td>
</tr>
<tr>
<td align="left"><strong>对象实例</strong></td>
<td align="left"><strong>单例 (Singleton)</strong></td>
<td align="left"><strong>多例 (Prototype)</strong></td>
<td align="left">SpringMVC 的 Controller 默认是单例，<strong>性能更高</strong>，但在类中定义成员变量是不安全的（有线程安全问题）。Struts2 每次请求都 new 一个 Action，线程安全但耗资源。</td>
</tr>
<tr>
<td align="left"><strong>参数传递</strong></td>
<td align="left">方法形参</td>
<td align="left">类成员变量</td>
<td align="left">SpringMVC 参数在方法里传递，干脆利落；Struts2 参数存放在类的字段里，混乱。</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left">较高</td>
<td align="left">较低</td>
<td align="left">Struts2 历史上爆出过多次重大安全漏洞（OGNL 表达式注入），导致企业大规模迁移至 SpringMVC。</td>
</tr>
</tbody></table>
<hr>
<hr>
<h1 id="二、核心架构与执行流程"><a href="#二、核心架构与执行流程" class="headerlink" title="二、核心架构与执行流程"></a>二、核心架构与执行流程</h1><h2 id="1-核心组件详解"><a href="#1-核心组件详解" class="headerlink" title="1. 核心组件详解"></a>1. 核心组件详解</h2><h3 id="1-1-核心组件"><a href="#1-1-核心组件" class="headerlink" title="1.1 核心组件"></a>1.1 核心组件</h3><h4 id="1-1-1-前端控制器-DispatcherServlet"><a href="#1-1-1-前端控制器-DispatcherServlet" class="headerlink" title="1.1.1 前端控制器 (DispatcherServlet)"></a>1.1.1 前端控制器 (DispatcherServlet)</h4><ul>
<li><strong>地位</strong>：<strong>核心中枢、总指挥</strong>。</li>
<li><strong>作用</strong>：接收客户端发来的 HTTP 请求，然后根据请求的类型，指挥其他组件协同工作。它是整个 SpringMVC 的入口。</li>
<li><strong>餐厅类比</strong>：<strong>【前台经理】</strong>。<ul>
<li>顾客（浏览器）进门，第一个接待的就是前台经理。经理不亲自做菜，他只负责分发任务：“那桌要点菜（找映射器）”、“那桌菜做好了上菜（找视图解析器）”。</li>
</ul>
</li>
<li><strong>源码位置</strong>：<code>org.springframework.web.servlet.DispatcherServlet</code></li>
</ul>
<hr>
<h4 id="1-1-2-处理器映射器-HandlerMapping"><a href="#1-1-2-处理器映射器-HandlerMapping" class="headerlink" title="1.1.2 处理器映射器 (HandlerMapping)"></a>1.1.2 处理器映射器 (HandlerMapping)</h4><ul>
<li><strong>地位</strong>：<strong>秘书 &#x2F; 导航仪</strong>。</li>
<li><strong>作用</strong>：负责根据用户请求的 URL（如 <code>/user/login</code>），找到对应的后端处理器（Controller 中的方法）。它返回一个 <strong>执行链 (HandlerExecutionChain)</strong>，里面包含处理器对象和拦截器。</li>
<li><strong>餐厅类比</strong>：<strong>【菜单与点餐系统】</strong>。<ul>
<li>经理问：“顾客要吃‘宫保鸡丁’（URL），是哪位厨师负责？”</li>
<li>点餐系统查表回答：“是王大厨（Controller A）的 3 号灶台（Method）负责。”</li>
</ul>
</li>
<li><strong>核心实现</strong>：<code>RequestMappingHandlerMapping</code> (处理 <code>@RequestMapping</code> 注解的核心类)。</li>
</ul>
<hr>
<h4 id="1-1-3-处理器适配器-HandlerAdapter"><a href="#1-1-3-处理器适配器-HandlerAdapter" class="headerlink" title="1.1.3 处理器适配器 (HandlerAdapter)"></a>1.1.3 处理器适配器 (HandlerAdapter)</h4><ul>
<li><strong>地位</strong>：<strong>万能转接头</strong>。</li>
<li><strong>作用</strong>：负责<strong>真正调用</strong> Controller 中的方法。<ul>
<li><em>为什么需要它？</em> 因为 Controller 的写法有很多种（早期可以实现 Controller 接口，现在用 <code>@RequestMapping</code> 注解）。<code>DispatcherServlet</code> 不想去判断每种 Controller 怎么调用，它只管调 <code>Adapter</code> 的 <code>handle()</code> 方法，由 Adapter 内部去匹配并执行具体的 Controller。</li>
</ul>
</li>
<li><strong>餐厅类比</strong>：<strong>【传菜员 &#x2F; 厨房调度】</strong>。<ul>
<li>经理（Dispatcher）不懂做菜，他只懂下命令。</li>
<li>王大厨（Controller）说中文，那是川菜；</li>
<li>Jack大厨（Servlet）说英文，那是西餐。</li>
<li>经理无法直接跟所有厨师沟通，所以需要一个<strong>调度员（Adapter）</strong>。经理对调度员说“执行任务”，调度员再用厨师能听懂的方式去命令厨师做菜。</li>
</ul>
</li>
<li><strong>核心实现</strong>：<code>RequestMappingHandlerAdapter</code>。</li>
</ul>
<hr>
<h4 id="1-1-4-处理器-Handler"><a href="#1-1-4-处理器-Handler" class="headerlink" title="1.1.4 处理器 (Handler)"></a>1.1.4 处理器 (Handler)</h4><ul>
<li><strong>地位</strong>：<strong>打工人</strong>。</li>
<li><strong>作用</strong>：即开发者编写的 <strong>Controller</strong>。这是真正处理业务逻辑的地方（调用 Service，查询 Database）。</li>
<li><strong>注意</strong>：Handler 不是 SpringMVC 的基础设施，而是我们自己写的代码。</li>
<li><strong>餐厅类比</strong>：<strong>【厨师】</strong>。<ul>
<li>真正切墩、炒菜、放盐的人。他把食材（参数）做成菜品（数据）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-1-5-视图解析器-ViewResolver"><a href="#1-1-5-视图解析器-ViewResolver" class="headerlink" title="1.1.5  视图解析器 (ViewResolver)"></a>1.1.5  视图解析器 (ViewResolver)</h4><ul>
<li><strong>地位</strong>：<strong>美工 &#x2F; 包装师</strong>。</li>
<li><strong>作用</strong>：Controller 执行完通常只返回一个逻辑视图名（比如字符串 <code>&quot;success&quot;</code>）。ViewResolver 负责把这个字符串解析成真正的物理视图对象（View）。</li>
<li><strong>餐厅类比</strong>：<strong>【摆盘设计师】</strong>。<ul>
<li>厨师做完菜喊了一声：“做好啦（success）！”</li>
<li>设计师接到指令，决定用什么盘子装，是“陶瓷盘（JSP）”还是“外卖盒（JSON）”，并确定盘子放在哪个柜子里（前缀后缀路径拼接）。</li>
</ul>
</li>
<li><strong>核心实现</strong>：<code>InternalResourceViewResolver</code> (JSP解析器)。</li>
</ul>
<hr>
<h4 id="1-1-6-视图-View"><a href="#1-1-6-视图-View" class="headerlink" title="1.1.6 视图 (View)"></a>1.1.6 视图 (View)</h4><ul>
<li><strong>地位</strong>：<strong>成品</strong>。</li>
<li><strong>作用</strong>：负责将模型数据渲染到页面上（将 Request 域的数据填入 JSP&#x2F;HTML）。</li>
<li><strong>餐厅类比</strong>：<strong>【端上桌的那盘菜】</strong>。<ul>
<li>最终呈现给顾客（浏览器）看到的 HTML 页面。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-辅助组件"><a href="#1-2-辅助组件" class="headerlink" title="1.2 辅助组件"></a>1.2 辅助组件</h3><h4 id="1-2-1-HandlerExceptionResolver-异常解析器"><a href="#1-2-1-HandlerExceptionResolver-异常解析器" class="headerlink" title="1.2.1 HandlerExceptionResolver (异常解析器)"></a>1.2.1 HandlerExceptionResolver (异常解析器)</h4><ul>
<li><strong>作用</strong>：当 Controller 报错时（空指针、除零异常），负责捕获异常并跳转到指定的错误页面。</li>
<li><em>类比</em>：<strong>【餐厅公关部】</strong>。吃到苍蝇了？公关部出面道歉并赔偿优惠券（错误页）。</li>
</ul>
<hr>
<h4 id="1-2-2-MultipartResolver-文件上传解析器"><a href="#1-2-2-MultipartResolver-文件上传解析器" class="headerlink" title="1.2.2 MultipartResolver (文件上传解析器)"></a>1.2.2 MultipartResolver (文件上传解析器)</h4><ul>
<li><strong>作用</strong>：处理 <code>multipart/form-data</code> 类型的数据，实现文件上传。</li>
<li><em>类比</em>：<strong>【大宗货物接收员】</strong>。普通信件前台收，大箱子货物（文件）由专人接收。</li>
</ul>
<hr>
<h4 id="1-2-3-FlashMapManager"><a href="#1-2-3-FlashMapManager" class="headerlink" title="1.2.3 FlashMapManager"></a>1.2.3 FlashMapManager</h4><ul>
<li><strong>作用</strong>：用于重定向（Redirect）时携带参数。重定向是两次请求，Request 域数据会丢失，FlashMap 可以把数据“闪存”一下带到下一次请求。</li>
</ul>
<hr>
<h2 id="2-执行流程"><a href="#2-执行流程" class="headerlink" title="2. 执行流程"></a>2. 执行流程</h2><h3 id="2-1-流程图"><a href="#2-1-流程图" class="headerlink" title="2.1 流程图"></a>2.1 流程图</h3><p>下面是当一个HTTP请求（例如 <code>GET /users/123</code>）到达时，Spring MVC内部发生的详细步骤：</p>
<pre><code class="highlight mermaid">sequenceDiagram
    actor Client

    title Spring MVC DispatcherServlet 工作流程
    Client-&gt;&gt;+DS: 1. HTTP Request
    
    DS-&gt;&gt;HM: 2. 查询能处理请求的Handler
    HM--&gt;&gt;DS: 3. 返回HandlerExecutionChain (含Controller方法和Interceptors)

    DS-&gt;&gt;+HA: 4. 请求HandlerAdapter执行Handler
    
    note right of HA: 执行拦截器的 preHandle 方法
    HA-&gt;&gt;I: 5a. Interceptor.preHandle()
    I--&gt;&gt;HA: (若返回false, 则中断流程)

    note right of HA: 参数解析、数据转换、数据校验等
    HA-&gt;&gt;+C: 5b. 通过反射调用Controller方法
    
    C--&gt;&gt;-HA: 6. Controller处理后返回ModelAndView
    
    note right of HA: 执行拦截器的 postHandle 方法
    HA-&gt;&gt;I: 7a. Interceptor.postHandle()
    I--&gt;&gt;HA: 
    
    HA--&gt;&gt;-DS: 7b. 返回ModelAndView给DispatcherServlet

    DS-&gt;&gt;+VR: 8. 请求ViewResolver解析视图
    VR--&gt;&gt;-DS: 返回具体的View对象

    DS-&gt;&gt;+V: 9a. 使用Model数据渲染View
    V--&gt;&gt;-DS: 返回渲染后的响应 (如HTML)

    note left of Client: 视图渲染完毕后
    DS-&gt;&gt;I: 9b. 执行Interceptor.afterCompletion()
    I--&gt;&gt;DS: 
    
    DS--&gt;&gt;-Client: 9c. 响应客户端</code></pre>

<hr>
<h3 id="2-2-八步执行流程"><a href="#2-2-八步执行流程" class="headerlink" title="2.2 八步执行流程"></a>2.2 八步执行流程</h3><h4 id="第一阶段：请求映射"><a href="#第一阶段：请求映射" class="headerlink" title="第一阶段：请求映射"></a>第一阶段：请求映射</h4><ol>
<li><strong>请求到达前端控制器 (<code>DispatcherServlet</code>)</strong><ul>
<li>用户的 HTTP 请求首先到达 Web 服务器（如 Tomcat），被 <code>DispatcherServlet</code> 拦截。</li>
<li>它是整个流程的<strong>中央调度器</strong>，负责统筹全局。</li>
</ul>
</li>
<li><strong>查找处理器 (<code>HandlerMapping</code>)</strong><ul>
<li><code>DispatcherServlet</code> 携带请求信息查询 <code>HandlerMapping</code>。</li>
<li><strong>核心动作</strong>：系统根据 URL（如 <code>/user/login</code>）匹配找到对应的 <code>HandlerMethod</code>（Controller 中的方法）。</li>
<li><strong>产出</strong>：返回一个 <strong>执行链 (<code>HandlerExecutionChain</code>)</strong>。<ul>
<li><em>注意</em>：这个链包含两部分：<strong>目标处理器 (Handler)</strong> + <strong>拦截器集合 (Interceptors)</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>请求适配器 (<code>HandlerAdapter</code>)</strong><ul>
<li><code>DispatcherServlet</code> 根据 Handler 的类型，寻找支持该 Handler 的适配器（通常是 <code>RequestMappingHandlerAdapter</code>）。</li>
<li><strong>作用</strong>：为了屏蔽不同 Handler 的调用差异，实现统一调用。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="第二阶段：业务执行"><a href="#第二阶段：业务执行" class="headerlink" title="第二阶段：业务执行"></a>第二阶段：业务执行</h4><ol>
<li><strong>前置拦截与参数准备</strong><ul>
<li><strong>前置拦截</strong>：在执行 Handler 之前，按顺序执行所有拦截器的 <code>preHandle()</code> 方法。如果拦截器返回 <code>false</code>，流程直接中断。</li>
<li><strong>参数绑定 (Data Binding)</strong>：适配器开始干活，将 HTTP 请求中的数据（String）解析并转换为 Controller 方法需要的形参（User对象、Int、List等）。<ul>
<li><em>包含</em>：参数解析 (<code>ArgumentResolvers</code>)、数据转换 (<code>Converters</code>)、数据校验 (<code>Validation</code>)。</li>
</ul>
</li>
</ul>
</li>
<li><strong>反射执行处理器 (<code>Handler</code>)</strong><ul>
<li>一切准备就绪后，适配器通过 <strong>反射机制 (Reflection)</strong> 真正执行我们编写的 Controller 业务方法。</li>
<li>Controller 调用 Service 层处理业务逻辑。</li>
</ul>
</li>
<li><strong>返回处理结果 (<code>ModelAndView</code> vs <code>@ResponseBody</code>)</strong><ul>
<li><strong>场景 A (传统页面)</strong>：Controller 方法执行完毕，封装并返回 <code>ModelAndView</code>（包含<strong>逻辑视图名</strong>和<strong>模型数据</strong>）给适配器。</li>
<li><strong>场景 B (前后端分离)</strong>：如果方法标记了 <code>@ResponseBody</code>，数据会通过 <code>HttpMessageConverter</code> 直接写入 HTTP 响应体（JSON）。此时方法通常返回 <code>null</code>，<strong>后续的视图解析步骤将被跳过</strong>。</li>
</ul>
</li>
<li><strong>后置拦截</strong><ul>
<li>适配器在返回前，按逆序执行拦截器的 <code>postHandle()</code> 方法（此时可以对 <code>ModelAndView</code> 再做最后修改）。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="第三阶段：视图渲染"><a href="#第三阶段：视图渲染" class="headerlink" title="第三阶段：视图渲染"></a>第三阶段：视图渲染</h4><ol>
<li><strong>视图解析 (<code>ViewResolver</code>)</strong><ul>
<li><code>DispatcherServlet</code> 拿到逻辑视图名（如 <code>&quot;success&quot;</code>），请求 <code>ViewResolver</code> 进行解析。</li>
<li><strong>产出</strong>：解析器根据前缀后缀配置，定位到物理文件，生成具体的 <strong><code>View</code> 对象</strong>（如 <code>JstlView</code>）。</li>
</ul>
</li>
<li><strong>视图渲染与最终响应</strong><ul>
<li><strong>渲染 (Render)</strong>：<code>View</code> 对象根据 Model 数据渲染 JSP&#x2F;HTML（本质是 <code>request.setAttribute</code>）。</li>
<li><strong>最终拦截</strong>：渲染完成后，执行拦截器的 <code>afterCompletion()</code> 方法（用于资源清理、异常日志）。</li>
<li><strong>响应</strong>：将最终的 HTML 或数据流返回给客户端浏览器。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-3-源码级理解"><a href="#2-3-源码级理解" class="headerlink" title="2.3 源码级理解"></a>2.3 源码级理解</h3><p>上述所有流程，都封装在 <code>DispatcherServlet</code> 类的 <code>doDispatch()</code> 方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 执行链（Handler + 拦截器）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;     <span class="comment">// 是否为文件上传请求</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 【预处理】检查是否是文件上传请求 (Multipart)</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ================== 第一阶段：请求映射 (Match) ==================</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 【核心】根据请求 URL 找到处理器执行链 (HandlerExecutionChain)</span></span><br><span class="line">            <span class="comment">// 对应组件：HandlerMapping</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 【核心】根据 Handler 找到对应的适配器</span></span><br><span class="line">            <span class="comment">// 对应组件：HandlerAdapter</span></span><br><span class="line">            <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ================== 第二阶段：业务执行 (Execute) ==================</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 【拦截器】执行 preHandle 方法 (正序)</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 如果返回 false，流程中断</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 【核心】适配器执行 Handler (Controller 方法)</span></span><br><span class="line">            <span class="comment">// 对应组件：Controller</span></span><br><span class="line">            <span class="comment">// 注意：如果是 @ResponseBody，mv 在这里可能为 null</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. 【默认视图】如果 Controller 返回 void 且没写 @ResponseBody，尝试生成默认视图名</span></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7. 【拦截器】执行 postHandle 方法 (逆序)</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex; <span class="comment">// 捕获业务执行期间的异常</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ================== 第三阶段：渲染与响应 (Render) ==================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8. 【核心】处理结果：渲染视图 or 处理异常</span></span><br><span class="line">        <span class="comment">// 对应组件：ViewResolver + View</span></span><br><span class="line">        <span class="comment">// 注意：拦截器的 afterCompletion 也会在这里面触发</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="comment">// 9. 【兜底】最终的异常触发 afterCompletion</span></span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 资源清理</span></span><br><span class="line">        <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">            cleanupMultipart(processedRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong><code>getHandler()</code> 其实干了两件事</strong>：<ul>
<li>它不仅找到了 <code>Handler</code>（Controller 方法），还把所有配置好的 <code>Interceptor</code> 找出来，打包成了 <code>HandlerExecutionChain</code> 对象。</li>
</ul>
</li>
<li><strong><code>ha.handle()</code> 的黑盒魔法</strong>：<ul>
<li>这行代码看似简单，内部却包含了<strong>参数绑定</strong>的复杂逻辑（反射获取参数名、类型转换、JSR303 校验）。</li>
<li><strong>重点</strong>：如果你的 Controller 方法加了 <code>@ResponseBody</code>，<code>ha.handle()</code> 内部会直接通过 <code>HttpMessageConverter</code> 把数据写回 Response，并返回 <code>null</code> 给 <code>mv</code>。</li>
</ul>
</li>
<li><strong><code>processDispatchResult()</code> 的双重职责</strong>：<ul>
<li><strong>正常情况</strong>：调用 <code>render()</code> 方法，通过 ViewResolver 解析视图并渲染。</li>
<li><strong>异常情况</strong>：如果 <code>dispatchException</code> 不为空，它会调用 <code>HandlerExceptionResolver</code> 全局异常处理器。</li>
<li><strong>收尾</strong>：无论成功失败，它最终都会触发拦截器的 <code>afterCompletion</code> 方法。</li>
</ul>
</li>
</ol>
<hr>
<hr>
<h1 id="三、请求处理"><a href="#三、请求处理" class="headerlink" title="三、请求处理"></a>三、请求处理</h1><h2 id="1-RequestMapping-注解详解"><a href="#1-RequestMapping-注解详解" class="headerlink" title="1. @RequestMapping 注解详解"></a>1. <code>@RequestMapping</code> 注解详解</h2><h3 id="1-1-注解概述"><a href="#1-1-注解概述" class="headerlink" title="1.1 注解概述"></a>1.1 注解概述</h3><ul>
<li><strong>核心作用</strong>：建立 <strong>HTTP 请求</strong>（URL, Method, Params）与 <strong>Java 方法</strong> 之间的映射关系。</li>
<li><strong>通俗理解</strong>：它就是 SpringMVC 的“交通指示牌”，告诉 DispatcherServlet：“如果有人去 <code>/login</code>，请把请求导向 <code>login()</code> 方法。”</li>
<li><strong>核心属性</strong>：<ul>
<li><code>value</code> &#x2F; <code>path</code>：映射路径（默认属性）。</li>
<li><code>method</code>：限定 HTTP 请求方式。</li>
<li><code>params</code>：限定请求参数。</li>
<li><code>headers</code>：限定请求头。</li>
<li><code>consumes</code>: 限定请求体的内容类型。</li>
<li><code>produces</code>: 限定响应体的内容类型.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-2-标注位置与路径继承"><a href="#1-2-标注位置与路径继承" class="headerlink" title="1.2 标注位置与路径继承"></a>1.2 标注位置与路径继承</h3><p><code>@RequestMapping</code> 可以标注在类上，也可以标注在方法上。</p>
<ul>
<li><strong>类上 (Class Level)</strong>：提供初步的请求映射信息（通常用于<strong>模块划分</strong>）。</li>
<li><strong>方法上 (Method Level)</strong>：提供具体的请求映射信息。</li>
<li><strong>最终访问路径</strong> &#x3D; <code>类上的 value</code> + <code>方法上的 value</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span> <span class="comment">// 基准路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问路径: http://localhost:8080/user/login</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问路径: http://localhost:8080/user/register</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-3-URL-路径匹配规则"><a href="#1-3-URL-路径匹配规则" class="headerlink" title="1.3 URL 路径匹配规则"></a>1.3 URL 路径匹配规则</h3><h4 id="1-3-1-精确匹配"><a href="#1-3-1-精确匹配" class="headerlink" title="1.3.1 精确匹配"></a>1.3.1 精确匹配</h4><p>最常用的方式。</p>
<ul>
<li><code>@RequestMapping(&quot;/test&quot;)</code> -&gt; 仅匹配 <code>/test</code>。</li>
</ul>
<hr>
<h4 id="1-3-2-Ant-风格通配符"><a href="#1-3-2-Ant-风格通配符" class="headerlink" title="1.3.2 Ant 风格通配符"></a>1.3.2 Ant 风格通配符</h4><p>SpringMVC 支持 Ant 风格的路径匹配符，非常灵活。</p>
<ul>
<li><code>?</code>：匹配文件名中的<strong>一个字符</strong>。<ul>
<li><code>/user/c?eate</code> -&gt; 匹配 <code>/user/create</code>, <code>/user/cxeate</code></li>
</ul>
</li>
<li><code>*</code>：匹配文件名中的<strong>任意字符</strong>（一层路径）。<ul>
<li><code>/user/*/login</code> -&gt; 匹配 <code>/user/aaa/login</code>, <code>/user/bbb/login</code></li>
</ul>
</li>
<li><code>**</code>：匹配<strong>多层路径</strong>。<ul>
<li><code>/user/**</code> -&gt; 匹配 <code>/user/login</code>, <code>/user/a/b/c/login</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="1-3-3-占位符匹配"><a href="#1-3-3-占位符匹配" class="headerlink" title="1.3.3 占位符匹配"></a>1.3.3 占位符匹配</h4><p>配合 <code>@PathVariable</code> 使用（后续 3.4 节详解）。</p>
<ul>
<li><code>@RequestMapping(&quot;/user/{id}&quot;)</code> -&gt; 匹配 <code>/user/1</code>, <code>/user/100</code>。</li>
</ul>
<hr>
<h3 id="1-4-HTTP-请求方式限定"><a href="#1-4-HTTP-请求方式限定" class="headerlink" title="1.4 HTTP 请求方式限定"></a>1.4 HTTP 请求方式限定</h3><p>默认情况下，<code>@RequestMapping(&quot;/test&quot;)</code> 会接收 GET、POST 等<strong>所有</strong>类型的请求。为了安全和规范（RESTful），通常需要限定。</p>
<ul>
<li><p><strong>常规写法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有 POST 请求能访问，GET 访问会报 405 错误</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/save&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>组合注解（推荐，Spring 4.3+）</strong>：<br>为了简化代码，Spring 提供了专属注解：</p>
<ul>
<li><code>@GetMapping(&quot;/save&quot;)</code> 等同于 <code>method = RequestMethod.GET</code></li>
<li><code>@PostMapping(&quot;/save&quot;)</code></li>
<li><code>@PutMapping(&quot;/update&quot;)</code></li>
<li><code>@DeleteMapping(&quot;/delete&quot;)</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="1-5-请求参数与请求头限定"><a href="#1-5-请求参数与请求头限定" class="headerlink" title="1.5 请求参数与请求头限定"></a>1.5 请求参数与请求头限定</h3><p>这是一种更<strong>严格</strong>的匹配方式。即使 URL 和 Method 都对，如果参数或头信息不符合规则，依然拒绝访问。</p>
<h4 id="1-5-1-params-属性（限定请求参数）"><a href="#1-5-1-params-属性（限定请求参数）" class="headerlink" title="1.5.1 params 属性（限定请求参数）"></a>1.5.1 <code>params</code> 属性（限定请求参数）</h4><p>支持简单的逻辑表达式。</p>
<table>
<thead>
<tr>
<th align="left">表达式格式</th>
<th align="left">含义</th>
<th align="left">示例</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&quot;param&quot;</code></td>
<td align="left"><strong>必须存在</strong></td>
<td align="left"><code>&quot;uid&quot;</code></td>
<td align="left">请求中必须包含 <code>uid</code></td>
</tr>
<tr>
<td align="left"><code>&quot;!param&quot;</code></td>
<td align="left"><strong>必须不存在</strong></td>
<td align="left"><code>&quot;!uid&quot;</code></td>
<td align="left">请求中<strong>不能</strong>包含 <code>uid</code></td>
</tr>
<tr>
<td align="left"><code>&quot;param=value&quot;</code></td>
<td align="left"><strong>必须等于</strong></td>
<td align="left"><code>&quot;age=18&quot;</code></td>
<td align="left">必须含 <code>age</code> 且值为 <code>18</code></td>
</tr>
<tr>
<td align="left"><code>&quot;param!=value&quot;</code></td>
<td align="left"><strong>不等于</strong></td>
<td align="left"><code>&quot;age!=18&quot;</code></td>
<td align="left"><code>age</code> 值不是 <code>18</code>，<strong>或者</strong>没传 <code>age</code></td>
</tr>
</tbody></table>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL必须包含 username，且 age 必须为 18</span></span><br><span class="line"><span class="comment">// /test?username=zs&amp;age=18</span></span><br><span class="line"><span class="comment">// /test?username=zs (报 400 错误)</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/test&quot;, params = &#123;&quot;username&quot;, &quot;age=18&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testParams</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-5-2-headers-属性（限定请求头）"><a href="#1-5-2-headers-属性（限定请求头）" class="headerlink" title="1.5.2 headers 属性（限定请求头）"></a>1.5.2 <code>headers</code> 属性（限定请求头）</h4><p>用法与 <code>params</code> 一致，校验 HTTP Header。常用于鉴权或限制内容类型。</p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求头必须包含 &quot;Token&quot;，且 Content-Type 必须为 json</span></span><br><span class="line"><span class="meta">@PostMapping(value = &quot;/api&quot;, headers = &#123;&quot;Token&quot;, &quot;content-type=application/json&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testHeader</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-参数绑定"><a href="#2-参数绑定" class="headerlink" title="2. 参数绑定"></a>2. 参数绑定</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>参数绑定（或称请求参数处理）是Spring MVC框架的一项强大功能。</p>
<p>它的核心任务是：<strong>将 HTTP 请求中的数据（URL 参数、请求体 JSON、请求头 Header、Cookie 等）自动提取、转换类型，并赋值给 Controller 方法的形参</strong>。</p>
<p>在原生 Servlet 时代，我们获取参数非常痛苦：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧时代：痛苦的手动解析</span></span><br><span class="line"><span class="type">String</span> <span class="variable">ageStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(ageStr); <span class="comment">// 还要处理 NumberFormatException</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setName(request.getParameter(<span class="string">&quot;name&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>在 SpringMVC 中，你只需要：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新时代：自动绑定</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(Integer age, User user)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>DispatcherServlet</strong> 配合 <strong>HandlerAdapter</strong> 会自动帮你把参数赋上值。</p>
<hr>
<h3 id="2-2-六大绑定方式详解"><a href="#2-2-六大绑定方式详解" class="headerlink" title="2.2 六大绑定方式详解"></a>2.2 六大绑定方式详解</h3><h4 id="2-2-1-RequestParam：处理查询参数与表单字段"><a href="#2-2-1-RequestParam：处理查询参数与表单字段" class="headerlink" title="2.2.1 @RequestParam：处理查询参数与表单字段"></a>2.2.1 <code>@RequestParam</code>：处理查询参数与表单字段</h4><blockquote>
<p><strong>适用场景</strong>：</p>
<ol>
<li>GET 请求的 Query String：<code>/users?name=alice&amp;age=30</code></li>
<li>POST 请求的 Form 表单：<code>Content-Type: application/x-www-form-urlencoded</code></li>
</ol>
</blockquote>
<ul>
<li><p><strong>基本用法</strong>：<br>如果方法形参名与请求参数名<strong>完全一致</strong>，注解可以省略（SpringMVC 会默认按 <code>@RequestParam(required=false)</code> 处理）。</p>
</li>
<li><p><strong>核心属性</strong>：</p>
<ul>
<li><code>value</code> &#x2F; <code>name</code>：指定请求参数名（当前端参数名与后端形参名不一致时使用）。</li>
<li><code>required</code>：是否必填，默认为 <code>true</code>。若缺失则报 <strong>400 错误</strong>。</li>
<li><code>defaultValue</code>：默认值。<strong>注意：一旦设置了默认值，隐式意味着 <code>required=false</code></strong>。</li>
</ul>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findUser</span><span class="params">(</span></span><br><span class="line"><span class="params">    // <span class="number">1.</span> 省略注解 (前端传 name)</span></span><br><span class="line">    String name,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 指定参数名 &amp; 设为可选 (前端传 user_age)</span></span><br><span class="line">    <span class="meta">@RequestParam(name = &quot;user_age&quot;, required = false)</span> Integer age,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置默认值 (没传 page 则为 1)</span></span><br><span class="line">    <span class="meta">@RequestParam(defaultValue = &quot;1&quot;)</span> <span class="type">int</span> page,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 接收同名参数 (复选框 ?roles=admin&amp;roles=user)</span></span><br><span class="line">    <span class="meta">@RequestParam(&quot;roles&quot;)</span> List&lt;String&gt; roles </span><br><span class="line">) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-2-PathVariable：处理-URL-路径变量"><a href="#2-2-2-PathVariable：处理-URL-路径变量" class="headerlink" title="2.2.2 @PathVariable：处理 URL 路径变量"></a>2.2.2 <code>@PathVariable</code>：处理 URL 路径变量</h4><blockquote>
<p><strong>适用场景</strong>：RESTful 风格的 API，参数直接嵌入在 URL 路径中。</p>
<p>例如：<code>GET /users/123</code> (获取 ID 为 123 的用户)</p>
</blockquote>
<ul>
<li><p><strong>URL 模板</strong>：在 <code>@RequestMapping</code> 中使用 <code>{}</code> 占位符。</p>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL: /users/123/orders/999</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/users/&#123;userId&#125;/orders/&#123;orderId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getOrder</span><span class="params">(</span></span><br><span class="line"><span class="params">    // 将路径中的 &#123;userId&#125; 绑定到变量 userId</span></span><br><span class="line"><span class="params">    <span class="meta">@PathVariable</span> Long userId,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">    // 假如形参名不想叫 orderId，需显式指定</span></span><br><span class="line"><span class="params">    <span class="meta">@PathVariable(&quot;orderId&quot;)</span> String orderIdentifier</span></span><br><span class="line"><span class="params">)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-3-RequestBody：处理-JSON-请求体"><a href="#2-2-3-RequestBody：处理-JSON-请求体" class="headerlink" title="2.2.3  @RequestBody：处理 JSON 请求体"></a>2.2.3  <code>@RequestBody</code>：处理 JSON 请求体</h4><blockquote>
<p><strong>适用场景</strong>：POST&#x2F;PUT 请求，请求体是 JSON 或 XML 数据。<br>	<code>Content-Type: application/json</code></p>
</blockquote>
<ul>
<li><p><strong>核心机制</strong>：SpringMVC 使用 <code>HttpMessageConverter</code> (默认 Jackson) 将 JSON 字符串<strong>反序列化</strong>为 Java 对象。</p>
</li>
<li><p><strong>限制</strong>：一个 Controller 方法中<strong>最多只能有一个</strong> <code>@RequestBody</code>（因为请求体 InputStream 只能读一次）。</p>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端发送：&#123;&quot;username&quot;: &quot;bob&quot;, &quot;age&quot;: 18&#125;</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/users/register&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestBody</span> UserDTO userDto</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    System.out.println(userDto.getUsername());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-4-POJO-对象绑定：Form-表单自动封装"><a href="#2-2-4-POJO-对象绑定：Form-表单自动封装" class="headerlink" title="2.2.4 POJO 对象绑定：Form 表单自动封装"></a>2.2.4 POJO 对象绑定：Form 表单自动封装</h4><blockquote>
<p><strong>适用场景</strong>：传统的表单提交（非 JSON），参数很多，不想写一堆 <code>@RequestParam</code>。</p>
</blockquote>
<ul>
<li><p><strong>机制</strong>：SpringMVC 会根据<strong>参数名</strong>查找 POJO 类的 <strong>Setter 方法</strong>进行赋值。</p>
</li>
<li><p><strong>要求</strong>：POJO 类必须有<strong>无参构造器</strong>和 public 的 <strong>Setter</strong>。</p>
</li>
<li><p><strong>支持级联</strong>：支持 <code>address.city</code> 这种嵌套属性。</p>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提交数据：username=carol&amp;email=carol@gmail.com</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/users/create&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">createUser</span><span class="params">(UserCreateForm form)</span> &#123; <span class="comment">// 无需注解！</span></span><br><span class="line">    <span class="comment">// 自动 new UserCreateForm() -&gt; setUsername() -&gt; setEmail()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-5-RequestHeader：获取请求头"><a href="#2-2-5-RequestHeader：获取请求头" class="headerlink" title="2.2.5 @RequestHeader：获取请求头"></a>2.2.5 <code>@RequestHeader</code>：获取请求头</h4><blockquote>
<p><strong>适用场景</strong>：需要读取 <code>User-Agent</code>、<code>Authorization</code> Token 或自定义 Header。</p>
</blockquote>
<ul>
<li><p><strong>属性</strong>: 与 <code>@RequestParam</code> 类似，也支持 <code>name</code>, <code>required</code>, <code>defaultValue</code>。</p>
</li>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/api/info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">(</span></span><br><span class="line"><span class="params">    // 获取标准头</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader(&quot;User-Agent&quot;)</span> String userAgent,</span></span><br><span class="line"><span class="params">    // 获取所有头信息到 Map 中</span></span><br><span class="line"><span class="params">    <span class="meta">@RequestHeader</span> Map&lt;String, String&gt; allHeaders</span></span><br><span class="line"><span class="params">)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-6-CookieValue：获取-Cookie"><a href="#2-2-6-CookieValue：获取-Cookie" class="headerlink" title="2.2.6 @CookieValue：获取 Cookie"></a>2.2.6 <code>@CookieValue</code>：获取 Cookie</h4><blockquote>
<p><strong>适用场景</strong>：读取 JSESSIONID 或其他 Cookie 数据。</p>
</blockquote>
<ul>
<li><p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/profile&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">profile</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String sessionId</span></span><br><span class="line"><span class="params">)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-3-高级绑定与避坑指南"><a href="#2-3-高级绑定与避坑指南" class="headerlink" title="2.3 高级绑定与避坑指南"></a>2.3 高级绑定与避坑指南</h3><h4 id="2-3-1-List-集合绑定的“坑”"><a href="#2-3-1-List-集合绑定的“坑”" class="headerlink" title="2.3.1 List 集合绑定的“坑”"></a>2.3.1 List 集合绑定的“坑”</h4><ul>
<li><strong>错误写法</strong>：<code>public void test(List&lt;String&gt; ids)</code><ul>
<li><em>报错</em>：SpringMVC 不知道该创建 ArrayList 还是 LinkedList，也无法确定泛型。</li>
</ul>
</li>
<li><strong>正确解法 1</strong>：加注解 <code>@RequestParam(&quot;ids&quot;) List&lt;String&gt; ids</code>。</li>
<li><strong>正确解法 2</strong>：包装在 POJO 中（<code>class Form { List&lt;String&gt; ids; }</code>）。</li>
</ul>
<hr>
<h4 id="2-3-2-400-Bad-Request错误排查"><a href="#2-3-2-400-Bad-Request错误排查" class="headerlink" title="2.3.2 400 Bad Request错误排查"></a>2.3.2 400 Bad Request错误排查</h4><p>如果你收到 HTTP 400 错误，通常是以下原因：</p>
<ol>
<li><strong>参数缺失</strong>：<code>@RequestParam(required=true)</code> 的参数没传。</li>
<li><strong>类型不匹配</strong>：前端传了 “abc” 给后端的 <code>Integer</code> 字段。</li>
<li><strong>JSON 格式错</strong>：<code>@RequestBody</code> 解析失败（例如 JSON 语法错误）。</li>
</ol>
<hr>
<h2 id="3-中文乱码问题"><a href="#3-中文乱码问题" class="headerlink" title="3. 中文乱码问题"></a>3. 中文乱码问题</h2><h3 id="3-1-乱码产生的根源"><a href="#3-1-乱码产生的根源" class="headerlink" title="3.1 乱码产生的根源"></a>3.1 乱码产生的根源</h3><p>Web 应用的数据流转链路很长：<code>浏览器 -&gt; Tomcat -&gt; SpringMVC -&gt; Controller</code>。<br>乱码的核心原因永远只有一个：<strong>编码和解码使用的字符集不一致</strong>。</p>
<ul>
<li><strong>浏览器端</strong>：通常使用 UTF-8 发送请求。</li>
<li><strong>服务器端 (Tomcat)</strong>：<ul>
<li><strong>Tomcat 8.0 之前</strong>：默认使用 <code>ISO-8859-1</code>（这个字符集不支持中文）。</li>
<li><strong>Tomcat 8.0 之后</strong>：默认使用了 <code>UTF-8</code>（这解决了很多问题，但依然有坑）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-2-请求乱码"><a href="#3-2-请求乱码" class="headerlink" title="3.2 请求乱码"></a>3.2 请求乱码</h3><h4 id="3-2-1-POST-请求乱码-最常见"><a href="#3-2-1-POST-请求乱码-最常见" class="headerlink" title="3.2.1 POST 请求乱码 (最常见)"></a>3.2.1 POST 请求乱码 (最常见)</h4><ul>
<li><strong>现象</strong>：表单提交中文，后端接收到的是乱码。</li>
<li><strong>原因</strong>：HTTP 协议规定，POST 请求的参数是在<strong>请求体 (Body)</strong> 中传输的。Request 对象在首次读取 Body 时，如果未指定编码，Servlet 容器（如 Tomcat）会默认使用 <code>ISO-8859-1</code> 去解析字节流，导致中文变乱码。</li>
<li><strong>解决方案</strong>：使用 Spring 提供的 <strong><code>CharacterEncodingFilter</code></strong>。</li>
</ul>
<p><strong>关键配置 (<code>web.xml</code>)</strong>：</p>
<p> <strong>注意</strong>：这段配置必须放在 <code>web.xml</code> 中<strong>所有 Filter 的最前面</strong>！如果在它之前有其他 Filter 读取了参数（调用了 <code>request.getParameter</code>），那么编码就会被锁死，再设置也没用了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 SpringMVC 的编码过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 1. 设置请求编码为 UTF-8 (解决 POST 请求乱码) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 2. 强制设置请求编码 (无论 Request 是否已指定编码，都强制覆盖) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceRequestEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3. 强制设置响应编码 (解决 Response 乱码，可选) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-2-GET-请求乱码-历史遗留"><a href="#3-2-2-GET-请求乱码-历史遗留" class="headerlink" title="3.2.2 GET 请求乱码 (历史遗留)"></a>3.2.2 GET 请求乱码 (历史遗留)</h4><ul>
<li><strong>现象</strong>：URL 参数带中文（如 <code>/user?name=张三</code>），后端接收乱码。</li>
<li><strong>原因</strong>：GET 请求的参数是在 <strong>URL 地址栏</strong> 中传输的。URL 的解析权在 Tomcat 的 Connector 连接器手中。</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>Tomcat 8.0+</strong>：默认已改为 UTF-8，<strong>无需任何配置</strong>，自动支持中文。</li>
<li><strong>Tomcat 7 及以下</strong>：<code>CharacterEncodingFilter</code> 对 GET 请求<strong>无效</strong>！必须修改 Tomcat 的配置文件。</li>
</ul>
</li>
</ul>
<p><strong>Tomcat 7 修改方案 (<code>conf/server.xml</code>)</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 增加 URIEncoding=&quot;UTF-8&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">URIEncoding</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-响应乱码"><a href="#3-3-响应乱码" class="headerlink" title="3.3 响应乱码"></a>3.3 响应乱码</h3><h4 id="3-3-1-返回-JSON-数据乱码"><a href="#3-3-1-返回-JSON-数据乱码" class="headerlink" title="3.3.1 返回 JSON 数据乱码"></a>3.3.1 返回 JSON 数据乱码</h4><p>如果使用 <code>@ResponseBody</code> 返回中文字符串，可能会乱码。</p>
<ul>
<li><p><strong>原因</strong>：SpringMVC 默认的 <code>StringHttpMessageConverter</code> 使用了 <code>ISO-8859-1</code>。</p>
</li>
<li><p><strong>解法 1 (注解法)</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/test&quot;, produces = &quot;application/json;charset=utf-8&quot;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解法 2 (全局配置法)</strong>：在 <code>spring-mvc.xml</code> 中配置 MessageConverter（推荐使用 Jackson，它默认就是 UTF-8，一般无需额外配置）。</p>
</li>
</ul>
<hr>
<h2 id="4-获取原生-Servlet-API"><a href="#4-获取原生-Servlet-API" class="headerlink" title="4. 获取原生 Servlet API"></a>4. 获取原生 Servlet API</h2><h3 id="4-1-为什么需要原生-API？"><a href="#4-1-为什么需要原生-API？" class="headerlink" title="4.1 为什么需要原生 API？"></a>4.1 为什么需要原生 API？</h3><p>尽管 SpringMVC 封装了 <code>Model</code>、<code>@RequestParam</code> 等便捷工具，但以下场景必须用原生 API：</p>
<ol>
<li><strong>Session 管理</strong>：登录成功后 <code>session.setAttribute(&quot;user&quot;, user)</code>。</li>
<li><strong>Cookie 操作</strong>：虽然有 <code>@CookieValue</code> 读取，但<strong>设置</strong> Cookie 依然需要 <code>response.addCookie()</code>。</li>
<li><strong>文件下载</strong>：需要操作 <code>response.getOutputStream()</code> 写入文件流。</li>
<li><strong>IP 获取</strong>：<code>request.getRemoteAddr()</code>。</li>
<li><strong>ServletContext</strong>：获取 Web 应用的全局配置或真实路径。</li>
</ol>
<hr>
<h3 id="4-2-获取方式"><a href="#4-2-获取方式" class="headerlink" title="4.2 获取方式"></a>4.2 获取方式</h3><p>SpringMVC 的设计非常人性化，你<strong>想要什么，就在 Controller 方法的参数里写什么</strong>。DispatcherServlet 会自动检测并注入。</p>
<p><strong>支持的原生类型包括</strong>：</p>
<ul>
<li><code>HttpServletRequest</code></li>
<li><code>HttpServletResponse</code></li>
<li><code>HttpSession</code></li>
<li><code>java.security.Principal</code> (安全认证相关)</li>
<li><code>Locale</code> (国际化区域信息)</li>
<li><code>InputStream</code> &#x2F; <code>OutputStream</code> &#x2F; <code>Reader</code> &#x2F; <code>Writer</code></li>
</ul>
<hr>
<h3 id="4-3-代码示例"><a href="#4-3-代码示例" class="headerlink" title="4.3 代码示例"></a>4.3 代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testNative</span><span class="params">(</span></span><br><span class="line"><span class="params">        HttpServletRequest request, </span></span><br><span class="line"><span class="params">        HttpServletResponse response,</span></span><br><span class="line"><span class="params">        HttpSession session</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取请求信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">clientIP</span> <span class="operator">=</span> request.getRemoteAddr();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端IP: &quot;</span> + clientIP);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 操作 Session (存取数据)</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果 session 还没创建，request.getSession() 会自动创建</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 操作 Response (如手动添加 Cookie)</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;token&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        cookie.setMaxAge(<span class="number">3600</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 获取 ServletContext (应用上下文)</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> application.getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;上传文件夹物理路径: &quot;</span> + realPath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="四、响应处理"><a href="#四、响应处理" class="headerlink" title="四、响应处理"></a>四、响应处理</h1><h2 id="1-页面跳转"><a href="#1-页面跳转" class="headerlink" title="1. 页面跳转"></a>1. 页面跳转</h2><h3 id="1-1-转发-vs-重定向"><a href="#1-1-转发-vs-重定向" class="headerlink" title="1.1 转发 vs 重定向"></a>1.1 转发 vs 重定向</h3><p>在学习 SpringMVC 的跳转语法前，必须先复习 Servlet 时代的这两个核心概念。</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><strong>转发 (Forward)</strong></th>
<th align="left"><strong>重定向 (Redirect)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>发生位置</strong></td>
<td align="left"><strong>服务器内部</strong> (Tomcat 自己处理)</td>
<td align="left"><strong>客户端浏览器</strong> (浏览器重新发起请求)</td>
</tr>
<tr>
<td align="left"><strong>请求次数</strong></td>
<td align="left"><strong>1 次</strong></td>
<td align="left"><strong>2 次</strong></td>
</tr>
<tr>
<td align="left"><strong>URL 地址栏</strong></td>
<td align="left"><strong>不变</strong> (显示 <code>/login</code>)</td>
<td align="left"><strong>变化</strong> (变成 <code>/home</code>)</td>
</tr>
<tr>
<td align="left"><strong>数据共享</strong></td>
<td align="left"><strong>可以</strong>共享 Request 域数据</td>
<td align="left"><strong>不可以</strong>共享 Request 域数据 (跨请求了)</td>
</tr>
<tr>
<td align="left"><strong>访问范围</strong></td>
<td align="left">只能访问内部资源 (<code>WEB-INF</code> 下)</td>
<td align="left">可以访问外部链接 (如 <code>www.baidu.com</code>)</td>
</tr>
<tr>
<td align="left"><strong>效率</strong></td>
<td align="left">高</td>
<td align="left">低</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-2-SpringMVC中的跳转方式"><a href="#1-2-SpringMVC中的跳转方式" class="headerlink" title="1.2 SpringMVC中的跳转方式"></a>1.2 SpringMVC中的跳转方式</h3><p>SpringMVC 通过方法返回的字符串（String）来控制跳转。</p>
<h4 id="1-2-1-默认跳转（转发）"><a href="#1-2-1-默认跳转（转发）" class="headerlink" title="1.2.1 默认跳转（转发）"></a>1.2.1 默认跳转（转发）</h4><p>如果不加特殊前缀，配合视图解析器 (<code>InternalResourceViewResolver</code>)，默认就是转发。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置前缀：/WEB-INF/pages/，后缀：.jsp</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 物理路径 = /WEB-INF/pages/success.jsp</span></span><br><span class="line">    <span class="comment">// 行为：转发</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-2-显式转发-forward"><a href="#1-2-2-显式转发-forward" class="headerlink" title="1.2.2 显式转发 (forward:)"></a>1.2.2 显式转发 (<code>forward:</code>)</h4><p>如果你想<strong>绕过视图解析器的前缀后缀拼接</strong>，或者想<strong>转发到另一个 Controller 方法</strong>，可以使用 <code>forward:</code> 前缀。</p>
<ul>
<li><strong>特点</strong>：<code>forward:</code> 后的路径是<strong>完整路径</strong>，视图解析器会忽略配置的前缀后缀。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/handle01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handle01</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;处理请求 01&quot;</span>);</span><br><span class="line">    <span class="comment">// 转发到另一个 Controller 方法 (/handle02)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/handle02&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/handle02&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handle02</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-3-显式重定向-redirect"><a href="#1-2-3-显式重定向-redirect" class="headerlink" title="1.2.3 显式重定向 (redirect:)"></a>1.2.3 显式重定向 (<code>redirect:</code>)</h4><p>当你做完像“删除”、“修改”这样的非幂等操作后，为了防止用户刷新页面导致<strong>重复提交</strong>，必须使用重定向。</p>
<ul>
<li><strong>特点</strong>：<ul>
<li><code>redirect:</code> 后的路径不需要加项目名（ContextPath），SpringMVC 会自动帮你加上。</li>
<li>重定向无法访问 <code>/WEB-INF</code> 下的受保护资源。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/delete&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;删除成功...&quot;</span>);</span><br><span class="line">    <span class="comment">// 重定向到列表页 (浏览器地址栏会变)</span></span><br><span class="line">    <span class="comment">// 实际访问路径：http://localhost:8080/project/user/list</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/user/list&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-3-跳转时的数据传递"><a href="#1-3-跳转时的数据传递" class="headerlink" title="1.3 跳转时的数据传递"></a>1.3 跳转时的数据传递</h3><p>这是一个常见痛点：<strong>重定向怎么带参数？</strong></p>
<h4 id="1-3-1-转发带数据-Forward"><a href="#1-3-1-转发带数据-Forward" class="headerlink" title="1.3.1 转发带数据 (Forward)"></a>1.3.1 转发带数据 (Forward)</h4><p>直接放在 <code>Model</code> 或 <code>Request</code> 域中即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/a&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toA</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;我是转发带的数据&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/b&quot;</span>; <span class="comment">// /b 可以取到 msg</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-3-2-重定向带数据-Redirect-三种方案"><a href="#1-3-2-重定向带数据-Redirect-三种方案" class="headerlink" title="1.3.2 重定向带数据 (Redirect) - 三种方案"></a>1.3.2 重定向带数据 (Redirect) - 三种方案</h4><p>由于重定向是两次请求，Request 域数据会丢失。</p>
<ol>
<li><p><strong>URL 拼接 (笨办法)</strong>：<br><code>return &quot;redirect:/list?msg=success&quot;;</code></p>
<ul>
<li><em>缺点</em>：暴露在地址栏，不安全，且有长度限制。</li>
</ul>
</li>
<li><p><strong>RedirectAttributes (推荐)</strong>：<br>SpringMVC 提供的专门用于重定向传参的工具。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(RedirectAttributes ra)</span> &#123;</span><br><span class="line">    <span class="comment">// addAttribute: 参数会拼接到 URL 后面 (?msg=ok)</span></span><br><span class="line">    ra.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;ok&quot;</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// addFlashAttribute: 参数会暂时存在 Session 中，用完即销毁 (地址栏看不见)</span></span><br><span class="line">    ra.addFlashAttribute(<span class="string">&quot;user&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/list&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>FlashMap (底层原理)</strong>：<br><code>addFlashAttribute</code> 的底层就是利用了 Session 短暂存储数据，到达目标页面后立即移除，就像 Flash (闪光) 一样。</p>
</li>
</ol>
<hr>
<h3 id="1-4-void-返回值的情况"><a href="#1-4-void-返回值的情况" class="headerlink" title="1.4 void 返回值的情况"></a>1.4 <code>void</code> 返回值的情况</h3><p>如果 Controller 方法返回 <code>void</code>，SpringMVC 会默认认为<strong>请求路径就是视图名</strong>。</p>
<ul>
<li>请求：<code>/user/login</code></li>
<li>方法：<code>public void login() {}</code></li>
<li>结果：尝试去找 <code>/WEB-INF/pages/user/login.jsp</code>。</li>
<li><em>避坑</em>：通常我们写 <code>void</code> 都是为了配合 <code>response.getWriter()</code> 手动输出 JSON，记得加上 <code>@ResponseBody</code> 避免它乱找视图。</li>
</ul>
<hr>
<h2 id="2-数据共享"><a href="#2-数据共享" class="headerlink" title="2. 数据共享"></a>2. 数据共享</h2><h3 id="2-1-数据共享的核心载体：Request域"><a href="#2-1-数据共享的核心载体：Request域" class="headerlink" title="2.1 数据共享的核心载体：Request域"></a>2.1 数据共享的核心载体：Request域</h3><p>在 JavaWeb 阶段，我们习惯写 <code>request.setAttribute(&quot;key&quot;, value)</code>。<br>在 SpringMVC 中，虽然我们可以继续用原生 Request，但框架提供了更优雅、解耦的替代方案：<strong>Model</strong>。</p>
<p><strong>底层原理</strong>：</p>
<p>无论你使用 <code>Model</code>、<code>Map</code> 还是 <code>ModelMap</code>，SpringMVC 最终都会在内部将这些数据封装到一个 <code>BindingAwareModelMap</code> 中，并在视图渲染之前，把这些数据全部 <strong>put 进原生的 HttpServletRequest 域</strong>中。</p>
<hr>
<h3 id="2-2-三种主要的共享方式"><a href="#2-2-三种主要的共享方式" class="headerlink" title="2.2 三种主要的共享方式"></a>2.2 三种主要的共享方式</h3><p>这三种方式在本质上是<strong>完全一样</strong>的，只是接口定义不同。开发者通常<strong>首选 <code>Model</code> 接口</strong>。</p>
<h4 id="2-2-1-使用-Model-接口"><a href="#2-2-1-使用-Model-接口" class="headerlink" title="2.2.1 使用 Model 接口"></a>2.2.1 使用 <code>Model</code> 接口</h4><ul>
<li><p><strong>特点</strong>：SpringMVC 提供的接口，语义清晰，专用于模型数据封装。</p>
</li>
<li><p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testModel</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">    <span class="comment">// 存储数据</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;Hello, SpringMVC!&quot;</span>);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">18</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-2-使用-Map-接口"><a href="#2-2-2-使用-Map-接口" class="headerlink" title="2.2.2 使用 Map 接口"></a>2.2.2 使用 <code>Map</code> 接口</h4><ul>
<li><p><strong>特点</strong>：使用 JDK 标准的 <code>java.util.Map</code>，解耦程度最高（完全不依赖 Spring API）。</p>
</li>
<li><p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testMap</span><span class="params">(Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">    map.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;Hello, Map!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-3-使用-ModelMap-类"><a href="#2-2-3-使用-ModelMap-类" class="headerlink" title="2.2.3 使用 ModelMap 类"></a>2.2.3 使用 <code>ModelMap</code> 类</h4><ul>
<li><p><strong>特点</strong>：<code>LinkedHashMap</code> 的子类，提供了链式调用等扩展功能。</p>
</li>
<li><p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testModelMap</span><span class="params">(ModelMap modelMap)</span> &#123;</span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">            .addAttribute(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>); <span class="comment">// 支持链式写法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-4-使用-ModelAndView"><a href="#2-2-4-使用-ModelAndView" class="headerlink" title="2.2.4 使用 ModelAndView"></a>2.2.4 使用 <code>ModelAndView</code></h4><ul>
<li><p><strong>特点</strong>：同时包含视图信息和模型数据。现在用的比较少，因为它需要方法返回 <code>ModelAndView</code> 类型，不够灵活。</p>
</li>
<li><p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testMV&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">testMV</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    mv.addObject(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;Hello MV&quot;</span>); <span class="comment">// 存数据</span></span><br><span class="line">    mv.setViewName(<span class="string">&quot;success&quot;</span>);       <span class="comment">// 定视图</span></span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-3-Session域数据共享"><a href="#2-3-Session域数据共享" class="headerlink" title="2.3 Session域数据共享"></a>2.3 Session域数据共享</h3><p>有时候我们需要把数据存在 Session 中（比如用户信息、购物车），而不是 Request 中。</p>
<h4 id="2-3-1-原生-HttpSession"><a href="#2-3-1-原生-HttpSession" class="headerlink" title="2.3.1 原生 HttpSession"></a>2.3.1 原生 HttpSession</h4><p>简单直接，容易理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;currentUser&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Admin&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-2-SessionAttributes-注解"><a href="#2-3-2-SessionAttributes-注解" class="headerlink" title="2.3.2 @SessionAttributes 注解"></a>2.3.2 <code>@SessionAttributes</code> 注解</h4><ul>
<li><strong>作用</strong>：将 <code>Model</code> 中属性名为指定名称的数据，同步存储到 Session 域中。</li>
<li><strong>位置</strong>：<strong>类上有注解</strong>。</li>
<li><strong>注意</strong>：这是一个容易踩坑的功能（比如清除 Session 时比较麻烦），现在的开发习惯倾向于直接用原生 HttpSession。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes(value = &#123;&quot;user&quot;, &quot;token&quot;&#125;)</span> <span class="comment">// 指定哪些 key 也要存 Session</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">        <span class="comment">// 这行代码不仅会把 user 存入 Request，还会同步存入 Session</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;user&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>清除</strong>：需要使用 <code>SessionStatus.setComplete()</code> 来清除通过该注解存储的数据。</li>
</ul>
<hr>
<h3 id="2-4-Application-域数据共享"><a href="#2-4-Application-域数据共享" class="headerlink" title="2.4 Application 域数据共享"></a>2.4 Application 域数据共享</h3><p>Application 域的数据是<strong>全局共享</strong>的（所有用户都能看到，且服务器不重启一直存在）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/init&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">init</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 ServletContext</span></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line">    application.setAttribute(<span class="string">&quot;siteName&quot;</span>, <span class="string">&quot;我的博客系统&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-JSON-数据交互"><a href="#3-JSON-数据交互" class="headerlink" title="3. JSON 数据交互"></a>3. JSON 数据交互</h2><h3 id="3-1-核心依赖"><a href="#3-1-核心依赖" class="headerlink" title="3.1 核心依赖"></a>3.1 核心依赖</h3><p>SpringMVC 本身不具备解析 JSON 的能力，它依赖于第三方的 JSON 处理库。业界标准通常是 <strong>Jackson</strong>（Spring Boot 默认也是它）。</p>
<p><strong>Maven 坐标 (<code>pom.xml</code>)</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Jackson 核心包 (只需引入这一个，Maven 会自动传递引入 core 和 annotations) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 建议使用较新版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>配置开启 (<code>spring-mvc.xml</code>)</strong>：</p>
<p>必须配置注解驱动！它会自动注册 <code>RequestMappingHandlerAdapter</code>，并装配好 <code>MappingJackson2HttpMessageConverter</code>（消息转换器）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-2-输出-JSON-Java-JSON"><a href="#3-2-输出-JSON-Java-JSON" class="headerlink" title="3.2 输出 JSON (Java -&gt; JSON)"></a>3.2 输出 JSON (Java -&gt; JSON)</h3><blockquote>
<p><strong>场景</strong>：后端查询数据库得到 <code>User</code> 对象，前端需要 <code>{ &quot;name&quot;: &quot;Jack&quot; }</code>。</p>
</blockquote>
<h4 id="3-2-1-ResponseBody-注解"><a href="#3-2-1-ResponseBody-注解" class="headerlink" title="3.2.1 @ResponseBody 注解"></a>3.2.1 <code>@ResponseBody</code> 注解</h4><ul>
<li><strong>作用</strong>：<ol>
<li>告诉 SpringMVC：<strong>不要走视图解析器</strong>（不要去找 JSP）。</li>
<li>告诉 SpringMVC：将方法的返回值（对象&#x2F;集合）通过 <strong>HttpMessageConverter</strong> 转换为 JSON 格式，并写入 HTTP 响应体。</li>
</ol>
</li>
<li><strong>位置</strong>：<ul>
<li><strong>方法上</strong>：只针对该方法生效。</li>
<li><strong>类上</strong>：该类所有方法都生效。</li>
</ul>
</li>
<li><strong>返回值支持</strong>：<ul>
<li>POJO 对象 -&gt; <code>{}</code></li>
<li>List&#x2F;Array -&gt; <code>[]</code></li>
<li>Map -&gt; <code>{}</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-2-RestController-注解"><a href="#3-2-2-RestController-注解" class="headerlink" title="3.2.2 @RestController 注解"></a>3.2.2 <code>@RestController</code> 注解</h4><ul>
<li><strong>定义</strong>：<code>@RestController = @Controller + @ResponseBody</code>。</li>
<li><strong>用法</strong>：直接标在类上，里面所有方法默认都返回 JSON。这是目前微服务开发的主流写法。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span> <span class="comment">// 复合注解</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApiController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Rose&quot;</span>, <span class="number">16</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 自动转为 JSON 数组: [&#123;&quot;name&quot;:&quot;Jack&quot;,&quot;age&quot;:18&#125;, &#123;...&#125;]</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-输入-JSON-JSON-Java"><a href="#3-3-输入-JSON-JSON-Java" class="headerlink" title="3.3 输入 JSON (JSON -&gt; Java)"></a>3.3 输入 JSON (JSON -&gt; Java)</h3><blockquote>
<p><strong>场景</strong>：前端发送 POST 请求，Body 里是 JSON 字符串，后端要自动封装成 <code>User</code> 对象。</p>
</blockquote>
<h4 id="3-3-1-RequestBody-注解"><a href="#3-3-1-RequestBody-注解" class="headerlink" title="3.3.1 @RequestBody 注解"></a>3.3.1 <code>@RequestBody</code> 注解</h4><ul>
<li><strong>作用</strong>：读取 HTTP 请求体（Body）中的 JSON 数据，使用 Jackson 反序列化为 Java 对象。</li>
<li><strong>注意</strong>：<ol>
<li>前端请求的 <code>Content-Type</code> 必须是 <strong><code>application/json</code></strong>。</li>
<li>一个方法中只能有一个 <code>@RequestBody</code>。</li>
<li>通常用于 POST 或 PUT 请求。</li>
</ol>
</li>
</ul>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前端发送：</span></span><br><span class="line"><span class="comment"> * POST /api/users/save</span></span><br><span class="line"><span class="comment"> * Content-Type: application/json</span></span><br><span class="line"><span class="comment"> * Body: &#123; &quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 20 &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">    System.out.println(user.getName()); <span class="comment">// 输出 Tom</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-4-常见-JSON-格式化注解"><a href="#3-4-常见-JSON-格式化注解" class="headerlink" title="3.4 常见 JSON 格式化注解"></a>3.4 常见 JSON 格式化注解</h3><p>有时候我们需要对输出的 JSON 格式做微调（比如日期格式、忽略字段）。</p>
<ul>
<li><p><strong><code>@JsonFormat</code></strong>：格式化日期（最常用）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时输出: &quot;2023-12-31 12:00:00&quot; (默认是时间戳)</span></span><br><span class="line"><span class="comment">// timezone: 解决时区差问题 (少8小时)</span></span><br><span class="line"><span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date birthday;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@JsonIgnore</code></strong>：忽略该字段，不生成到 JSON 中（如密码字段）。</p>
</li>
<li><p><strong><code>@JsonProperty</code></strong>：给字段起别名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonProperty(&quot;username&quot;)</span> <span class="comment">// JSON 中叫 username，Java 中叫 name</span></span><br><span class="line"><span class="keyword">private</span> String name; </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@JsonInclude(JsonInclude.Include.NON_NULL)</code></strong>：如果字段值为 null，则不返回该字段。</p>
</li>
</ul>
<hr>
<h2 id="4-ResponseEntity-深度定制响应"><a href="#4-ResponseEntity-深度定制响应" class="headerlink" title="4. ResponseEntity 深度定制响应"></a>4. ResponseEntity 深度定制响应</h2><h3 id="4-1-什么是-ResponseEntity？"><a href="#4-1-什么是-ResponseEntity？" class="headerlink" title="4.1 什么是 ResponseEntity？"></a>4.1 什么是 <code>ResponseEntity</code>？</h3><ul>
<li><strong>定义</strong>：<code>ResponseEntity&lt;T&gt;</code> 是 Spring 提供的一个泛型类，它继承自 <code>HttpEntity</code>。</li>
<li><strong>地位</strong>：它代表了整个 <strong>HTTP 响应</strong> 报文。</li>
<li><strong>能力</strong>：通过它，我们可以自由配置：<ol>
<li><strong>HttpStatus</strong>：响应状态码 (如 200, 201, 404, 500)。</li>
<li><strong>HttpHeaders</strong>：响应头 (如 Content-Type, Token, Cache-Control)。</li>
<li><strong>Body</strong>：响应体 (实际的业务数据)。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-2-为什么需要它"><a href="#4-2-为什么需要它" class="headerlink" title="4.2 为什么需要它"></a>4.2 为什么需要它</h3><p>在标准的 RESTful 规范中，不同的操作结果应该对应不同的状态码，而不仅仅是永远返回 200。</p>
<table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left"><code>@ResponseBody</code> 处理</th>
<th align="left"><strong><code>ResponseEntity</code> 处理 (推荐)</strong></th>
<th align="left">状态码</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>查询成功</strong></td>
<td align="left">返回 JSON</td>
<td align="left"><code>ResponseEntity.ok(data)</code></td>
<td align="left"><strong>200 OK</strong></td>
</tr>
<tr>
<td align="left"><strong>创建资源</strong></td>
<td align="left">返回 JSON (状态码200)</td>
<td align="left"><code>ResponseEntity.status(201).body(data)</code></td>
<td align="left"><strong>201 Created</strong></td>
</tr>
<tr>
<td align="left"><strong>资源不存在</strong></td>
<td align="left">返回 null 或 报错</td>
<td align="left"><code>ResponseEntity.notFound().build()</code></td>
<td align="left"><strong>404 Not Found</strong></td>
</tr>
<tr>
<td align="left"><strong>没有权限</strong></td>
<td align="left">抛异常</td>
<td align="left"><code>ResponseEntity.status(403).build()</code></td>
<td align="left"><strong>403 Forbidden</strong></td>
</tr>
<tr>
<td align="left"><strong>文件下载</strong></td>
<td align="left">无法处理 Header</td>
<td align="left">设置 <code>Content-Disposition</code> 头</td>
<td align="left"><strong>200 OK</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="4-3-基本用法详解"><a href="#4-3-基本用法详解" class="headerlink" title="4.3 基本用法详解"></a>4.3 基本用法详解</h3><h4 id="4-3-1-链式构建风格"><a href="#4-3-1-链式构建风格" class="headerlink" title="4.3.1 链式构建风格"></a>4.3.1 链式构建风格</h4><p>Spring 提供了非常优雅的流式 API 来构建响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findById(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 成功：返回 200 OK 和对象</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(user);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 失败：返回 404 Not Found (无 Body)</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.notFound().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-2-构造器风格"><a href="#4-3-2-构造器风格" class="headerlink" title="4.3.2 构造器风格"></a>4.3.2 构造器风格</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 201 Created</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(user, HttpStatus.CREATED);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 500 Error</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(HttpStatus.INTERNAL_SERVER_ERROR);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-3-自定义响应头"><a href="#4-3-3-自定义响应头" class="headerlink" title="4.3.3 自定义响应头"></a>4.3.3 自定义响应头</h4><p>有时我们需要在 Header 里放自定义的 Token 或缓存指令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">login</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 Headers 对象</span></span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    headers.add(<span class="string">&quot;X-Auth-Token&quot;</span>, <span class="string">&quot;abcdef123456&quot;</span>); <span class="comment">// 自定义头</span></span><br><span class="line">    headers.add(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);    <span class="comment">// 标准头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 组装返回</span></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity</span><br><span class="line">            .ok()                  <span class="comment">// 状态码 200</span></span><br><span class="line">            .headers(headers)      <span class="comment">// 设置头</span></span><br><span class="line">            .body(<span class="string">&quot;Login Success&quot;</span>); <span class="comment">// 设置体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="五、高级功能与实战"><a href="#五、高级功能与实战" class="headerlink" title="五、高级功能与实战"></a>五、高级功能与实战</h1><h2 id="1-拦截器"><a href="#1-拦截器" class="headerlink" title="1. 拦截器"></a>1. 拦截器</h2><h3 id="1-1-什么是拦截器？"><a href="#1-1-什么是拦截器？" class="headerlink" title="1.1 什么是拦截器？"></a>1.1 什么是拦截器？</h3><ul>
<li><strong>定义</strong>：SpringMVC 提供的一种机制，用于在 <strong>Controller 方法执行前后</strong> 对请求进行拦截和处理。</li>
<li><strong>核心接口</strong>：<code>org.springframework.web.servlet.HandlerInterceptor</code>。</li>
<li><strong>地位</strong>：它是 SpringMVC 框架内部的组件，<strong>只拦截 Controller 的请求</strong>，不拦截 JSP&#x2F;HTML&#x2F;CSS 等静态资源（除非配置错误）。</li>
</ul>
<hr>
<h3 id="1-2-拦截器-vs-过滤器"><a href="#1-2-拦截器-vs-过滤器" class="headerlink" title="1.2 拦截器 vs 过滤器"></a>1.2 拦截器 vs 过滤器</h3><table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left"><strong>过滤器 (Filter)</strong></th>
<th align="left"><strong>拦截器 (Interceptor)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>归属</strong></td>
<td align="left">Servlet 规范 (Tomcat 容器)</td>
<td align="left"><strong>SpringMVC 框架</strong></td>
</tr>
<tr>
<td align="left"><strong>拦截范围</strong></td>
<td align="left"><strong>所有请求</strong> (包括 .jsp, .css, .js)</td>
<td align="left">仅拦截 <strong>Controller 请求</strong></td>
</tr>
<tr>
<td align="left"><strong>底层实现</strong></td>
<td align="left">函数回调</td>
<td align="left"><strong>Java 反射机制</strong></td>
</tr>
<tr>
<td align="left"><strong>上下文</strong></td>
<td align="left">只能获取 Request&#x2F;Response</td>
<td align="left">可以获取 <strong>Spring 容器 (Bean)</strong></td>
</tr>
<tr>
<td align="left"><strong>执行时机</strong></td>
<td align="left">请求刚进入 Tomcat 时</td>
<td align="left">请求进入 DispatcherServlet 后</td>
</tr>
</tbody></table>
<p><strong>总结</strong>：如果你需要依赖 Spring 的 Service 层（比如查数据库判断 token），必须用拦截器；如果只是简单的字符编码设置，用过滤器。</p>
<hr>
<h3 id="1-3-三大核心方法-生命周期"><a href="#1-3-三大核心方法-生命周期" class="headerlink" title="1.3 三大核心方法 (生命周期)"></a>1.3 三大核心方法 (生命周期)</h3><p>自定义拦截器需要实现 <code>HandlerInterceptor</code> 接口（或继承 <code>HandlerInterceptorAdapter</code> 类）。</p>
<ol>
<li><strong><code>preHandle</code> (前置拦截) —— 最常用</strong><ul>
<li><strong>执行时机</strong>：在 Controller 方法执行 <strong>之前</strong>。</li>
<li><strong>返回值</strong>：<code>boolean</code>。<ul>
<li><code>true</code>：<strong>放行</strong>。请求继续向下走（去找下一个拦截器或 Controller）。</li>
<li><code>false</code>：<strong>拦截</strong>。请求到此为止，不再执行后续代码（通常配合 <code>response</code> 输出错误信息或重定向）。</li>
</ul>
</li>
<li><strong>用途</strong>：登录检查、权限校验。</li>
</ul>
</li>
<li><strong><code>postHandle</code> (后置处理)</strong><ul>
<li><strong>执行时机</strong>：Controller 方法执行 <strong>之后</strong>，视图渲染 <strong>之前</strong>。</li>
<li><strong>用途</strong>：修改 <code>ModelAndView</code> 中的数据（比如统一添加菜单、版权信息）。</li>
</ul>
</li>
<li><strong><code>afterCompletion</code> (最终收尾)</strong><ul>
<li><strong>执行时机</strong>：整个请求完成（视图渲染完毕）<strong>之后</strong>。</li>
<li><strong>用途</strong>：资源清理、异常日志记录、性能监控（计算请求总耗时）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-4-实战：登录权限拦截器"><a href="#1-4-实战：登录权限拦截器" class="headerlink" title="1.4 实战：登录权限拦截器"></a>1.4 实战：登录权限拦截器</h3><h4 id="1-4-1-编写拦截器"><a href="#1-4-1-编写拦截器" class="headerlink" title="1.4.1 编写拦截器"></a>1.4.1 编写拦截器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt; 登录拦截器开始拦截...&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 获取 Session 中的用户</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;loginUser&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 判断是否登录</span></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 已登录，放行</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 未登录，拦截并跳转到登录页</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;请先登录！&quot;</span>);</span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/WEB-INF/pages/login.jsp&quot;</span>).forward(request, response);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-4-2-配置-注册拦截器"><a href="#1-4-2-配置-注册拦截器" class="headerlink" title="1.4.2 配置&#x2F;注册拦截器"></a>1.4.2 配置&#x2F;注册拦截器</h4><h5 id="1-基于Java配置"><a href="#1-基于Java配置" class="headerlink" title="1. 基于Java配置"></a>1. 基于Java配置</h5><p>这是目前最主流的方式。通过实现 <code>WebMvcConfigurer</code> 接口来注册。</p>
<p><strong>注意</strong>：在 Spring 5.0 之前通常继承 <code>WebMvcConfigurerAdapter</code>（已废弃），现在直接实现接口即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 注册自定义拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)             <span class="comment">// 拦截所有路径</span></span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/static/**&quot;</span>); <span class="comment">// 排除登录接口和静态资源</span></span><br><span class="line">                <span class="comment">// .order(1); // 可选：设置执行顺序，数字越小越先执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>特点</strong>：类型安全，重构方便，是 Spring Boot 的标准做法。</li>
<li><strong>关于 <code>@EnableWebMvc</code></strong>：在 Spring Boot 中，通常<strong>不需要</strong>加 <code>@EnableWebMvc</code>，否则会接管并导致 Spring Boot 的默认 MVC 配置（如 Jackson、静态资源映射）失效。在纯 Spring MVC 项目中则需要加上。</li>
</ul>
<hr>
<h5 id="2-基于-XML-配置"><a href="#2-基于-XML-配置" class="headerlink" title="2. 基于 XML 配置"></a>2. 基于 XML 配置</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置拦截器集 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 方式 A: 直接定义 Bean，拦截所有请求 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.example.interceptor.GlobalInterceptor&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 方式 B: 针对特定路径配置 (更常用) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 拦截路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 排除路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/login&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/resources/**&quot;</span>/&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">&lt;!-- 拦截器 Bean --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.example.interceptor.LoginInterceptor&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-5-多拦截器的执行顺序"><a href="#1-5-多拦截器的执行顺序" class="headerlink" title="1.5 多拦截器的执行顺序"></a>1.5 多拦截器的执行顺序</h3><p>如果有多个拦截器（Interceptor A 和 Interceptor B），执行顺序遵循 <strong>“先进后出”</strong> 原则（类似洋葱模型）。</p>
<ul>
<li><p><strong>配置顺序</strong>：A 在前，B 在后。</p>
</li>
<li><p><strong>正常流程</strong>：</p>
<ol>
<li>A.preHandle</li>
<li>B.preHandle</li>
<li><strong>Controller 执行</strong></li>
<li>B.postHandle</li>
<li>A.postHandle</li>
<li><strong>视图渲染</strong></li>
<li>B.afterCompletion</li>
<li>A.afterCompletion</li>
</ol>
</li>
<li><p><strong>中断流程</strong>：如果 B.preHandle 返回 <code>false</code>：</p>
<ol>
<li>A.preHandle (true)</li>
<li>B.preHandle (false) -&gt; <strong>流程结束</strong></li>
</ol>
<ul>
<li><em>注意</em>：A.afterCompletion <strong>会执行</strong>（Spring 机制保证已放行的拦截器能清理资源），但 B.afterCompletion 不会执行。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-文件上传与下载"><a href="#2-文件上传与下载" class="headerlink" title="2. 文件上传与下载"></a>2. 文件上传与下载</h2><h3 id="2-1-文件上传"><a href="#2-1-文件上传" class="headerlink" title="2.1 文件上传"></a>2.1 文件上传</h3><p>SpringMVC 的文件上传基于 Apache Commons FileUpload 组件。</p>
<h4 id="2-1-1-前端表单三要素"><a href="#2-1-1-前端表单三要素" class="headerlink" title="2.1.1 前端表单三要素"></a>2.1.1 前端表单三要素</h4><p>如果要上传文件，HTML 表单必须满足三个条件：</p>
<ol>
<li><code>method=&quot;post&quot;</code>：文件通常很大，必须用 POST。</li>
<li><code>enctype=&quot;multipart/form-data&quot;</code>：告诉浏览器把文件转换成二进制流发送，而不是 key-value 字符串。</li>
<li><code>type=&quot;file&quot;</code>：文件选择框。</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    头像：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;headerImg&quot;</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-2-依赖引入-pom-xml"><a href="#2-1-2-依赖引入-pom-xml" class="headerlink" title="2.1.2 依赖引入 (pom.xml)"></a>2.1.2 依赖引入 (<code>pom.xml</code>)</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Commons FileUpload --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-3-SpringMVC-配置-spring-mvc-xml"><a href="#2-1-3-SpringMVC-配置-spring-mvc-xml" class="headerlink" title="2.1.3 SpringMVC 配置 (spring-mvc.xml)"></a>2.1.3 SpringMVC 配置 (<code>spring-mvc.xml</code>)</h4><p>必须配置一个 <strong>MultipartResolver</strong>，且 <strong>id 必须叫 <code>multipartResolver</code></strong>（Spring 源码是按 id 查找的，写错会报错）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置默认编码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置单个文件最大值 (5MB = 5*1024*1024) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSizePerFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5242880&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置总上传最大值 (10MB) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10485760&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-4-Controller-代码实现"><a href="#2-1-4-Controller-代码实现" class="headerlink" title="2.1.4 Controller 代码实现"></a>2.1.4 Controller 代码实现</h4><p>使用 <code>MultipartFile</code> 接口接收文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestParam(&quot;headerImg&quot;)</span> MultipartFile file, </span></span><br><span class="line"><span class="params">                     HttpServletRequest request,</span></span><br><span class="line"><span class="params">                     Model model)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 检查文件是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (file.isEmpty()) &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;上传失败，请选择文件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取原始文件名 (如: avatar.png)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 生成唯一文件名 (防止文件名冲突覆盖: uuid + 后缀)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">newFileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + suffix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 确定上传路径 (保存到服务器 webapp/uploads 目录下)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;/uploads&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(realPath);</span><br><span class="line">    <span class="keyword">if</span> (!dir.exists()) dir.mkdirs(); <span class="comment">// 目录不存在则创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 执行保存 (核心操作)</span></span><br><span class="line">    <span class="comment">// transferTo 自动将临时文件写入目标位置</span></span><br><span class="line">    file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(dir, newFileName));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-文件下载"><a href="#2-2-文件下载" class="headerlink" title="2.2 文件下载"></a>2.2 文件下载</h3><p>文件下载的本质是：<strong>读取服务器文件 -&gt; 写入 Response 输出流 -&gt; 设置特殊的响应头</strong>。</p>
<p>SpringMVC 提供了 <code>ResponseEntity</code> 来优雅地实现下载</p>
<h4 id="2-2-1-下载辅助依赖"><a href="#2-2-1-下载辅助依赖" class="headerlink" title="2.2.1 下载辅助依赖"></a>2.2.1 下载辅助依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 简化文件IO操作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-2-核心实现"><a href="#2-2-2-核心实现" class="headerlink" title="2.2.2 核心实现"></a>2.2.2 核心实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;<span class="type">byte</span>[]&gt; download(HttpServletRequest request, String filename) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 定位文件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;/uploads/&quot;</span> + filename);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.notFound().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置响应头 (告诉浏览器这是下载，不是直接打开)</span></span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    <span class="comment">// attachment: 附件形式下载</span></span><br><span class="line">    <span class="comment">// filename: 指定下载时的默认文件名 (记得解决中文乱码)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">downloadFileName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(filename.getBytes(<span class="string">&quot;UTF-8&quot;</span>), <span class="string">&quot;ISO-8859-1&quot;</span>);</span><br><span class="line">    headers.setContentDispositionFormData(<span class="string">&quot;attachment&quot;</span>, downloadFileName);</span><br><span class="line">    headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 读取文件并返回</span></span><br><span class="line">    <span class="comment">// 提示: 对于大文件，不要一次性读入 byte[]，应用 StreamingResponseBody</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(FileUtils.readFileToByteArray(file), headers, HttpStatus.OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-3-大文件下载优化-StreamingResponseBody"><a href="#2-2-3-大文件下载优化-StreamingResponseBody" class="headerlink" title="2.2.3 大文件下载优化 (StreamingResponseBody)"></a>2.2.3 大文件下载优化 (<code>StreamingResponseBody</code>)</h4><p><strong>痛点</strong>：<code>ResponseEntity&lt;byte[]&gt;</code> 会把文件内容一次性加载到内存中。如果下载 1GB 的文件，JVM 内存会瞬间飙升导致 OOM (Out Of Memory)。</p>
<p><strong>方案</strong>：使用 <code>StreamingResponseBody</code> 进行流式传输。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/download/stream&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;StreamingResponseBody&gt; <span class="title function_">downloadStream</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;/uploads/large-movie.mp4&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    headers.setContentDispositionFormData(<span class="string">&quot;attachment&quot;</span>, <span class="string">&quot;movie.mp4&quot;</span>);</span><br><span class="line">    headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心：返回一个回调接口，SpringMVC 会在写入响应流时调用它</span></span><br><span class="line">    <span class="type">StreamingResponseBody</span> <span class="variable">stream</span> <span class="operator">=</span> outputStream -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123;</span><br><span class="line">            <span class="comment">// 每次只读 1KB，不会占用大量内存</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> bytesRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                outputStream.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(stream, headers, HttpStatus.OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-实战避坑：虚拟路径映射"><a href="#2-3-实战避坑：虚拟路径映射" class="headerlink" title="2.3 实战避坑：虚拟路径映射"></a>2.3 实战避坑：虚拟路径映射</h3><p>在上述代码中，我们使用了 <code>request.getServletContext().getRealPath(&quot;/uploads&quot;)</code>。</p>
<ul>
<li><strong>问题</strong>：这个路径指向 Tomcat 的 <code>webapps</code> 目录下的临时部署文件夹。<strong>每次项目重新部署（Re-deploy）时，该文件夹会被清空，用户上传的文件会全部丢失！</strong></li>
<li><strong>解决方案</strong>：将文件保存到服务器的一个固定磁盘目录（如 <code>/opt/data/uploads</code> 或 <code>D:/uploads</code>），然后通过<strong>虚拟路径</strong>映射访问。</li>
</ul>
<h4 id="2-3-1-配置-Tomcat-映射-针对-spring-mvc-xml-方式"><a href="#2-3-1-配置-Tomcat-映射-针对-spring-mvc-xml-方式" class="headerlink" title="2.3.1 配置 Tomcat 映射 (针对 spring-mvc.xml 方式)"></a>2.3.1 配置 Tomcat 映射 (针对 <code>spring-mvc.xml</code> 方式)</h4><p>在 Tomcat 的 <code>server.xml</code> 或 IDEA 的 Tomcat 配置中设置：</p>
<ul>
<li><strong>物理路径</strong>：<code>D:/uploads/</code></li>
<li><strong>访问路径</strong>：<code>http://localhost:8080/files/avatar.png</code></li>
</ul>
<hr>
<h4 id="2-3-2-Spring-MVC-静态资源映射"><a href="#2-3-2-Spring-MVC-静态资源映射" class="headerlink" title="2.3.2 Spring MVC 静态资源映射"></a>2.3.2 Spring MVC 静态资源映射</h4><p>更推荐在 Spring MVC 配置文件中直接映射：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-mvc.xml --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当访问 /files/** 时，去本地磁盘 D:/uploads/ 找 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/files/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;file:D:/uploads/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时 Controller 中保存文件的路径应直接写死为 <code>D:/uploads/</code>，不再使用 <code>getRealPath</code>。</p>
<hr>
<h3 id="2-4-多文件上传"><a href="#2-4-多文件上传" class="headerlink" title="2.4 多文件上传"></a>2.4 多文件上传</h3><p>前端 <code>input</code> 添加 <code>multiple</code> 属性，后端使用数组或集合接收。</p>
<p><strong>前端：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;files&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>后端：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/upload/batch&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">uploadBatch</span><span class="params">(<span class="meta">@RequestParam(&quot;files&quot;)</span> MultipartFile[] files)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (MultipartFile file : files) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!file.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 循环复用之前的保存逻辑</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">            <span class="comment">// ... 保存操作 ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-5-核心接口剖析：MultipartFile-与-Part"><a href="#2-5-核心接口剖析：MultipartFile-与-Part" class="headerlink" title="2.5 核心接口剖析：MultipartFile 与 Part"></a>2.5 核心接口剖析：MultipartFile 与 Part</h3><h4 id="2-5-1-什么是-MultipartFile？"><a href="#2-5-1-什么是-MultipartFile？" class="headerlink" title="2.5.1 什么是 MultipartFile？"></a>2.5.1 什么是 MultipartFile？</h4><p><code>org.springframework.web.multipart.MultipartFile</code> 是 Spring 框架定义的一个接口，它是 Spring 对上传文件的一层<strong>封装</strong>（Abstraction）。</p>
<p>它的作用是<strong>屏蔽底层的具体实现细节</strong>，让开发者无论使用哪种底层上传技术（Apache Commons FileUpload 还是 Servlet 3.0+ 标准），都能使用统一的 API 来操作文件。</p>
<p><strong>常用方法速查：</strong></p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">描述</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>String getOriginalFilename()</code></td>
<td align="left">获取客户端文件系统的原始文件名</td>
<td align="left">如 “avatar.png”</td>
</tr>
<tr>
<td align="left"><code>String getContentType()</code></td>
<td align="left">获取文件的 MIME 类型</td>
<td align="left">如 “image&#x2F;png”</td>
</tr>
<tr>
<td align="left"><code>long getSize()</code></td>
<td align="left">获取文件大小（字节）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>boolean isEmpty()</code></td>
<td align="left">判断文件是否为空</td>
<td align="left">size &#x3D;&#x3D; 0</td>
</tr>
<tr>
<td align="left"><code>InputStream getInputStream()</code></td>
<td align="left">获取文件内容的输入流</td>
<td align="left">用于自定义读取</td>
</tr>
<tr>
<td align="left"><code>void transferTo(File dest)</code></td>
<td align="left"><strong>核心方法</strong>：将接收到的文件保存到目标路径</td>
<td align="left">底层会自动处理流的读写和关闭</td>
</tr>
</tbody></table>
<hr>
<h4 id="2-5-2-MultipartFile-与-Part的关系"><a href="#2-5-2-MultipartFile-与-Part的关系" class="headerlink" title="2.5.2 MultipartFile 与 Part的关系"></a>2.5.2 MultipartFile 与 Part的关系</h4><p><strong>一句话总结：<code>MultipartFile</code> 是对 <code>Part</code> 的包装（适配器模式）。</strong></p>
<p>Spring MVC 为了保持框架的兼容性，它并没有直接把 Servlet 的 <code>Part</code> 暴露给开发者（虽然你也可以在 Controller 参数里直接写 <code>Part</code>，但很少这么做），而是设计了 <code>MultipartFile</code>。</p>
<p>Spring MVC 通过配置不同的 <strong>MultipartResolver</strong>（解析器）来决定底层使用谁：</p>
<ol>
<li><strong>场景一：使用 CommonsMultipartResolver (旧版&#x2F;SSM)</strong><ul>
<li>依赖：需要引入 <code>commons-fileupload</code> jar 包。</li>
<li>流程：HTTP 请求 -&gt; Apache FileItem -&gt; <strong>Spring 包装为 CommonsMultipartFile</strong> -&gt; Controller。</li>
</ul>
</li>
<li><strong>场景二：使用 StandardServletMultipartResolver (Spring Boot 默认)</strong><ul>
<li>依赖：不需要额外 jar 包，基于 Servlet 3.0+ 容器（如 Tomcat 7+）。</li>
<li>流程：HTTP 请求 -&gt; Servlet Part -&gt; <strong>Spring 包装为 StandardMultipartFile</strong> -&gt; Controller。</li>
</ul>
</li>
</ol>
<p><strong>对比图解：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">              [ 开发者层 (Controller) ]</span><br><span class="line">                         |</span><br><span class="line">           使用统一接口: MultipartFile</span><br><span class="line">                         |</span><br><span class="line">          --------------------------------</span><br><span class="line">          |                              |</span><br><span class="line">[ 适配器实现: StandardMultipartFile ]  [ 适配器实现: CommonsMultipartFile ]</span><br><span class="line">          |                              |</span><br><span class="line">          | (包装)                        | (包装)</span><br><span class="line">          v                              v</span><br><span class="line"> [ 底层: Servlet 3.0 Part ]      [ 底层: Apache Commons FileItem ]</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-5-3-为什么推荐用-MultipartFile-而不是-Part？"><a href="#2-5-3-为什么推荐用-MultipartFile-而不是-Part？" class="headerlink" title="2.5.3 为什么推荐用 MultipartFile 而不是 Part？"></a>2.5.3 为什么推荐用 MultipartFile 而不是 Part？</h4><p>虽然在 Controller 中直接注入 <code>Part</code> 也是可以的，但推荐使用 <code>MultipartFile</code>，原因如下：</p>
<ol>
<li><strong>解耦</strong>：如果有一天你想从 Tomcat (支持 Part) 迁移到某种不支持 Servlet 规范的容器，或者降级使用旧版上传组件，使用 <code>MultipartFile</code> 的代码不需要改动一行。</li>
<li><strong>便利性</strong>：<code>MultipartFile.transferTo(File dest)</code> 非常方便，它自动处理了路径问题。而 <code>Part.write(String fileName)</code> 在某些容器实现中，路径是相对于临时目录的，处理绝对路径比较麻烦。</li>
<li><strong>Spring 生态</strong>：<code>MultipartFile</code> 能更好地与 Spring 的数据绑定（DataBinding）和验证机制集成。</li>
</ol>
<hr>
<h2 id="3-全局异常处理"><a href="#3-全局异常处理" class="headerlink" title="3. 全局异常处理"></a>3. 全局异常处理</h2><h3 id="3-1-为什么需要全局异常处理器？"><a href="#3-1-为什么需要全局异常处理器？" class="headerlink" title="3.1 为什么需要全局异常处理器？"></a>3.1 为什么需要全局异常处理器？</h3><ul>
<li><p><strong>痛点</strong>：在 Controller 中，如果每个方法都写 <code>try-catch</code>，代码会极其臃肿且难以维护。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反例：不要这么写！</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        userService.doSomething();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>目标</strong>：<strong>将异常处理逻辑从业务代码中剥离出来</strong>。Controller 只管抛异常，专门的组件负责接住异常并处理。</p>
</li>
</ul>
<hr>
<h3 id="3-2-SpringMVC-异常处理机制"><a href="#3-2-SpringMVC-异常处理机制" class="headerlink" title="3.2 SpringMVC 异常处理机制"></a>3.2 SpringMVC 异常处理机制</h3><p>SpringMVC 提供了 <code>HandlerExceptionResolver</code> 接口来处理异常。</p>
<h4 id="3-2-1-SimpleMappingExceptionResolver-XML-配置"><a href="#3-2-1-SimpleMappingExceptionResolver-XML-配置" class="headerlink" title="3.2.1 SimpleMappingExceptionResolver (XML 配置)"></a>3.2.1 <code>SimpleMappingExceptionResolver</code> (XML 配置)</h4><p>适用于简单的场景：出现什么异常 -&gt; 跳转什么页面。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-mvc.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 遇到空指针，跳到 error_null.jsp --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.NullPointerException&quot;</span>&gt;</span>error_null<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 遇到算术异常，跳到 error_math.jsp --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.ArithmeticException&quot;</span>&gt;</span>error_math<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认错误页面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultErrorView&quot;</span> <span class="attr">value</span>=<span class="string">&quot;error&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将异常对象存入 Request 域的 key (页面可用 $&#123;ex&#125; 获取) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ex&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-2-ControllerAdvice-ExceptionHandler-注解驱动"><a href="#3-2-2-ControllerAdvice-ExceptionHandler-注解驱动" class="headerlink" title="3.2.2 @ControllerAdvice + @ExceptionHandler (注解驱动)"></a>3.2.2 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code> (注解驱动)</h4><p>这是目前最主流、最灵活的方式，支持返回 JSON 数据（前后端分离标配）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span> <span class="comment">// 1. 标记这是个&quot;增强版&quot;的 Controller，专管异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理特定的异常 (如算术异常)</span></span><br><span class="line"><span class="comment">     * 返回错误页面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ArithmeticException.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleMathException</span><span class="params">(Exception e, Model model)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕获到算术异常：&quot;</span> + e.getMessage());</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;计算出错了！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>; <span class="comment">// 跳转到 error.jsp</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理自定义业务异常 (返回 JSON)</span></span><br><span class="line"><span class="comment">     * 场景：前后端分离，前端需要拿到 code 和 msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MyBusinessException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span> <span class="comment">// 2. 关键：将错误信息转为 JSON</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handleBusinessException</span><span class="params">(MyBusinessException e)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>, e.getCode());</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 兜底异常处理 (处理所有未知的 Exception)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handleAll</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Map.of(<span class="string">&quot;code&quot;</span>, <span class="number">500</span>, <span class="string">&quot;message&quot;</span>, <span class="string">&quot;系统繁忙，请稍后再试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-自定义异常体系"><a href="#3-3-自定义异常体系" class="headerlink" title="3.3 自定义异常体系"></a>3.3 自定义异常体系</h3><p>为了更好地配合全局异常处理，项目中通常会定义自己的异常类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础业务异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code; <span class="comment">// 错误码 (如 1001:余额不足, 1002:库存不足)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBusinessException</span><span class="params">(Integer code, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getter/setter...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Controller 中的使用</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/buy&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">buy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (money &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接抛出异常，不用 catch，坐等 @ControllerAdvice 接盘</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyBusinessException</span>(<span class="number">1001</span>, <span class="string">&quot;余额不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-4-原理解析"><a href="#3-4-原理解析" class="headerlink" title="3.4 原理解析"></a>3.4 原理解析</h3><ol>
<li><strong>DispatcherServlet</strong> 调用 <code>doDispatch</code> 方法。</li>
<li><code>doDispatch</code> 中通过 <code>ha.handle(...)</code> 执行 Controller 方法。</li>
<li>如果 Controller 抛出异常，<strong><code>catch</code> 块会捕获到该异常</strong>，并将其赋值给 <code>dispatchException</code> 变量。</li>
<li>在最后的 <code>processDispatchResult</code> 方法中，会判断 <code>dispatchException</code> 是否为空。</li>
<li>如果不为空，SpringMVC 会遍历所有注册的 <code>HandlerExceptionResolver</code>（如 <code>ExceptionHandlerExceptionResolver</code>），找到能处理该异常的方法（即 <code>@ExceptionHandler</code> 标记的方法），并执行它。</li>
</ol>
<hr>
<h2 id="4-数据格式化与校验"><a href="#4-数据格式化与校验" class="headerlink" title="4. 数据格式化与校验"></a>4. 数据格式化与校验</h2><h3 id="4-1-数据格式化"><a href="#4-1-数据格式化" class="headerlink" title="4.1 数据格式化"></a>4.1 数据格式化</h3><p><strong>痛点</strong>：HTTP 协议传参全是字符串。如果前端传 <code>birth=2023-10-01</code>，后端字段是 <code>Date</code> 类型，SpringMVC 默认会报错（400 Bad Request），因为它不知道怎么转换。</p>
<h4 id="4-1-1-DateTimeFormat-日期格式化"><a href="#4-1-1-DateTimeFormat-日期格式化" class="headerlink" title="4.1.1 @DateTimeFormat (日期格式化)"></a>4.1.1 <code>@DateTimeFormat</code> (日期格式化)</h4><p>用于将<strong>前端传来的字符串</strong>转换为 <strong>Java Date&#x2F;LocalDateTime</strong> 对象。</p>
<ul>
<li><strong>位置</strong>：POJO 类的属性上，或 Controller 方法的形参上。</li>
<li><strong>注意</strong>：它只管 <strong>入参（String -&gt; Date）</strong>，不管出参（转 JSON 时的格式）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前端必须传: 2023-10-01，传 2023/10/01 会报错</span></span><br><span class="line">    <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-1-2-NumberFormat-数值格式化"><a href="#4-1-2-NumberFormat-数值格式化" class="headerlink" title="4.1.2 @NumberFormat (数值格式化)"></a>4.1.2 <code>@NumberFormat</code> (数值格式化)</h4><p>用于处理带有货币符号或千分位的数字字符串。</p>
<ul>
<li><code>@NumberFormat(pattern = &quot;#,###,###.##&quot;)</code>：处理如 “1,234.56” 这样的字符串转 BigDecimal。</li>
</ul>
<hr>
<h3 id="4-2-数据校验-Validation-JSR-303"><a href="#4-2-数据校验-Validation-JSR-303" class="headerlink" title="4.2 数据校验 (Validation) - JSR-303"></a>4.2 数据校验 (Validation) - JSR-303</h3><p><strong>痛点</strong>：如果你在 Controller 里写 <code>if (user.getAge() &lt; 0) ...</code>，业务代码会充满垃圾判断逻辑。</p>
<p><strong>方案</strong>：使用 <strong>Bean Validation (JSR-303&#x2F;JSR-349)</strong> 标准。Hibernate Validator 是该标准的参考实现。</p>
<h4 id="4-2-1-依赖引入"><a href="#4-2-1-依赖引入" class="headerlink" title="4.2.1 依赖引入"></a>4.2.1 依赖引入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Hibernate Validator 引擎 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.2.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Servlet 容器并未内置校验 API，需引入标准接口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-2-常用校验注解"><a href="#4-2-2-常用校验注解" class="headerlink" title="4.2.2 常用校验注解"></a>4.2.2 常用校验注解</h4><p>标注在 POJO 类的属性上。</p>
<table>
<thead>
<tr>
<th align="left">注解</th>
<th align="left">适用类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>@NotNull</code></strong></td>
<td align="left">任何</td>
<td align="left">不能为 null，但在字符串时可以是空串 “”</td>
</tr>
<tr>
<td align="left"><strong><code>@NotEmpty</code></strong></td>
<td align="left">String, Map, List</td>
<td align="left">不能为 null 且 size &gt; 0 (字符串不能是 “”)</td>
</tr>
<tr>
<td align="left"><strong><code>@NotBlank</code></strong></td>
<td align="left">String</td>
<td align="left">最严格。不能为 null 且去掉空格后长度 &gt; 0</td>
</tr>
<tr>
<td align="left"><strong><code>@Size(min, max)</code></strong></td>
<td align="left">String, Map, List</td>
<td align="left">长度范围限制</td>
</tr>
<tr>
<td align="left"><strong><code>@Min(value)</code></strong></td>
<td align="left">Number</td>
<td align="left">最小值限制</td>
</tr>
<tr>
<td align="left"><strong><code>@Max(value)</code></strong></td>
<td align="left">Number</td>
<td align="left">最大值限制</td>
</tr>
<tr>
<td align="left"><strong><code>@Email</code></strong></td>
<td align="left">String</td>
<td align="left">必须是合法的邮箱格式</td>
</tr>
<tr>
<td align="left"><strong><code>@Pattern(regexp)</code></strong></td>
<td align="left">String</td>
<td align="left">必须符合正则表达式 (如手机号校验)</td>
</tr>
</tbody></table>
<p><strong>POJO 示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户名不能为空&quot;)</span> <span class="comment">// 自定义错误消息</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min(value = 18, message = &quot;未成年人禁止注册&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 150, message = &quot;请输入合法的年龄&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式错误&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-3-开启校验-Valid-Validated"><a href="#4-2-3-开启校验-Valid-Validated" class="headerlink" title="4.2.3 开启校验 (@Valid &#x2F; @Validated)"></a>4.2.3 开启校验 (<code>@Valid</code> &#x2F; <code>@Validated</code>)</h4><p>在 Controller 接收参数的地方，必须告诉 SpringMVC：“请帮我校验这个对象”。</p>
<ul>
<li><strong><code>@Valid</code></strong> (标准注解) 或 <strong><code>@Validated</code></strong> (Spring 增强注解，支持分组)。</li>
<li><strong><code>BindingResult</code></strong>：<strong>必须</strong>紧跟在被校验的对象后面，用于接收校验结果。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@Valid</span> <span class="meta">@RequestBody</span> User user, // <span class="number">1.</span> 开启校验</span></span><br><span class="line"><span class="params">    BindingResult result           // <span class="number">2.</span> 接收错误信息 (必须紧挨着 User 参数)</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// 3. 判断是否有错</span></span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        <span class="comment">// 获取所有错误</span></span><br><span class="line">        List&lt;ObjectError&gt; errors = result.getAllErrors();</span><br><span class="line">        <span class="keyword">for</span> (ObjectError error : errors) &#123;</span><br><span class="line">            System.out.println(error.getDefaultMessage()); <span class="comment">// 打印: 用户名不能为空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>; <span class="comment">// 返回错误页</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 校验通过，执行业务</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-分组校验"><a href="#4-3-分组校验" class="headerlink" title="4.3 分组校验"></a>4.3 分组校验</h3><p><strong>场景</strong>：</p>
<ul>
<li><strong>注册</strong>时：id 必须为空 (数据库自增)。</li>
<li><strong>修改</strong>时：id 必须不为空 (通过 id 找人)。<br>同一个 <code>User</code> 对象，不同场景规则冲突，怎么办？</li>
</ul>
<h4 id="4-3-1-定义分组接口"><a href="#4-3-1-定义分组接口" class="headerlink" title="4.3.1 定义分组接口"></a>4.3.1 定义分组接口</h4><p>不需要写方法，只是作为标识。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AddGroup</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UpdateGroup</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-2-在POJO上指定分组"><a href="#4-3-2-在POJO上指定分组" class="headerlink" title="4.3.2 在POJO上指定分组"></a>4.3.2 在POJO上指定分组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// 只有在 UpdateGroup 分组下，才校验 @NotNull</span></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;ID不能为空&quot;, groups = &#123;UpdateGroup.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 AddGroup 和 UpdateGroup 下都要校验</span></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;姓名不能为空&quot;, groups = &#123;AddGroup.class, UpdateGroup.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-3-在Controller中指定分组"><a href="#4-3-3-在Controller中指定分组" class="headerlink" title="4.3.3 在Controller中指定分组"></a>4.3.3 在Controller中指定分组</h4><p>必须使用 Spring 的 <strong><code>@Validated</code></strong> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">add</span><span class="params">(<span class="meta">@Validated(AddGroup.class)</span> User user, BindingResult result)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/update&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@Validated(UpdateGroup.class)</span> User user, BindingResult result)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="六、SSM-整合与配置进化"><a href="#六、SSM-整合与配置进化" class="headerlink" title="六、SSM 整合与配置进化"></a>六、SSM 整合与配置进化</h1><h2 id="1-SSM-整合-Spring-SpringMVC-MyBatis"><a href="#1-SSM-整合-Spring-SpringMVC-MyBatis" class="headerlink" title="1. SSM 整合 (Spring + SpringMVC + MyBatis)"></a>1. SSM 整合 (Spring + SpringMVC + MyBatis)</h2><h3 id="1-1-整合思路：三层架构与双容器"><a href="#1-1-整合思路：三层架构与双容器" class="headerlink" title="1.1 整合思路：三层架构与双容器"></a>1.1 整合思路：三层架构与双容器</h3><p>SSM 整合的本质，就是把三个框架像搭积木一样拼在一起，各司其职。</p>
<ul>
<li><strong>SpringMVC</strong>：管理 Web 层（Controller），负责接收请求。</li>
<li><strong>Spring</strong>：管理 Service 层（Service）和 DAO 层（MyBatis 的 Mapper 代理对象），负责业务逻辑和事务控制。</li>
<li><strong>MyBatis</strong>：负责数据持久化。</li>
</ul>
<p>Spring 在 Web 环境下启动时，会创建<strong>两个</strong> IOC 容器：</p>
<ol>
<li><strong>父容器 (Spring Root Context)</strong>：由 <code>ContextLoaderListener</code> 加载。<ul>
<li>管理：<code>Service</code>, <code>Dao</code>, <code>DataSource</code>, <code>TransactionManager</code>。</li>
<li><em>特点</em>：父容器不可见子容器的 Bean（Service 不能注入 Controller）。</li>
</ul>
</li>
<li><strong>子容器 (SpringMVC Web Context)</strong>：由 <code>DispatcherServlet</code> 加载。<ul>
<li>管理：<code>Controller</code>, <code>ViewResolver</code>, <code>HandlerMapping</code>。</li>
<li><em>特点</em>：子容器可见父容器的 Bean（Controller 可以注入 Service）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1-2-引入依赖"><a href="#1-2-引入依赖" class="headerlink" title="1.2 引入依赖"></a>1.2 引入依赖</h3><ol>
<li><strong>Spring 核心</strong>：<code>spring-context</code>, <code>spring-aspects</code>, <code>spring-jdbc</code>, <code>spring-test</code>, <code>spring-webmvc</code>。</li>
<li><strong>MyBatis</strong>：<code>mybatis</code>, <code>mybatis-spring</code> (整合包)。</li>
<li><strong>数据库</strong>：<code>mysql-connector-java</code>, <code>druid</code> (连接池)。</li>
<li><strong>Servlet</strong>：<code>javax.servlet-api</code>, <code>jsp-api</code>。</li>
<li><strong>工具</strong>：<code>jackson</code>, <code>lombok</code>, <code>junit</code>。</li>
</ol>
<hr>
<h3 id="1-3-配置文件规划"><a href="#1-3-配置文件规划" class="headerlink" title="1.3 配置文件规划"></a>1.3 配置文件规划</h3><ul>
<li><code>web.xml</code>：总入口。</li>
<li><code>spring-mvc.xml</code>：SpringMVC 专用配置。</li>
<li><code>applicationContext.xml</code>：Spring + MyBatis 配置（或者拆分为 <code>spring-dao.xml</code>, <code>spring-service.xml</code>）。</li>
</ul>
<hr>
<h3 id="1-4-详细配置步骤"><a href="#1-4-详细配置步骤" class="headerlink" title="1.4 详细配置步骤"></a>1.4 详细配置步骤</h3><h4 id="1-4-1-web-xml-启动双容器"><a href="#1-4-1-web-xml-启动双容器" class="headerlink" title="1.4.1 web.xml (启动双容器)"></a>1.4.1 web.xml (启动双容器)</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1. 启动 Spring 父容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 启动 SpringMVC 子容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3. 字符编码过滤器 (防止中文乱码) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span>...<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-4-2-spring-mvc-xml-Web-层配置"><a href="#1-4-2-spring-mvc-xml-Web-层配置" class="headerlink" title="1.4.2 spring-mvc.xml (Web 层配置)"></a>1.4.2 spring-mvc.xml (Web 层配置)</h4><p><strong>关键点</strong>：只扫描 Controller！避免扫描到 Service，否则事务可能会失效。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1. 只扫描 Controller --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.example&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 注解驱动 (JSON支持, JSR303校验等) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3. 静态资源放行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4. 视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-4-3-applicationContext-xml-Service-Dao-层配置"><a href="#1-4-3-applicationContext-xml-Service-Dao-层配置" class="headerlink" title="1.4.3 applicationContext.xml (Service + Dao 层配置)"></a>1.4.3 applicationContext.xml (Service + Dao 层配置)</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1. 扫描 Service, Repository (排除 Controller) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.example&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 引入 db.properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:db.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3. 配置数据源 (Druid) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4. 整合 MyBatis (SqlSessionFactory) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定 Mapper XML 文件位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 别名包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.example.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 5. 扫描 Mapper 接口 (生成代理对象注入容器) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.example.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 6. 事务管理器配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启声明式事务注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-纯注解配置"><a href="#2-纯注解配置" class="headerlink" title="2. 纯注解配置"></a>2. 纯注解配置</h2><h3 id="2-1-为什么要纯注解"><a href="#2-1-为什么要纯注解" class="headerlink" title="2.1 为什么要纯注解"></a>2.1 为什么要纯注解</h3><ul>
<li><strong>XML 的痛点</strong>：繁琐、类型不安全、解析慢。</li>
<li><strong>JavaConfig 的优势</strong>：<ul>
<li><strong>类型安全</strong>：重构代码（重命名类）时，IDE 能够感知并报错。</li>
<li><strong>编程能力</strong>：可以在配置类中写 <code>if/else</code> 逻辑（虽然不推荐太复杂）。</li>
<li><strong>SpringBoot 基础</strong>：是现代 Spring 开发的标准范式。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-替代-web-xml：AbstractAnnotationConfigDispatcherServletInitializer"><a href="#2-2-替代-web-xml：AbstractAnnotationConfigDispatcherServletInitializer" class="headerlink" title="2.2 替代 web.xml：AbstractAnnotationConfigDispatcherServletInitializer"></a>2.2 替代 web.xml：<code>AbstractAnnotationConfigDispatcherServletInitializer</code></h3><p>在 Servlet 3.0+ 环境下，我们可以创建一个类继承 <code>AbstractAnnotationConfigDispatcherServletInitializer</code>，Tomcat 启动时会自动加载它，从而替代 <code>web.xml</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebInit</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 指定 Spring 父容器的配置类 (替代 applicationContext.xml)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 指定 SpringMVC 子容器的配置类 (替代 spring-mvc.xml)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;WebMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 指定 DispatcherServlet 的映射路径 (url-pattern)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 配置过滤器 (如字符编码过滤器)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">encodingFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        encodingFilter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        encodingFilter.setForceEncoding(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 支持 HiddenHttpMethodFilter 处理 PUT/DELETE</span></span><br><span class="line">        <span class="type">HiddenHttpMethodFilter</span> <span class="variable">hiddenFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HiddenHttpMethodFilter</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;encodingFilter, hiddenFilter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-替代-spring-mvc-xml：WebMvcConfigurer"><a href="#2-3-替代-spring-mvc-xml：WebMvcConfigurer" class="headerlink" title="2.3 替代 spring-mvc.xml：WebMvcConfigurer"></a>2.3 替代 spring-mvc.xml：<code>WebMvcConfigurer</code></h3><p>我们需要编写一个配置类，加上 <code>@Configuration</code> 和 <code>@EnableWebMvc</code> 注解，并实现 <code>WebMvcConfigurer</code> 接口来定制组件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.example.controller&quot;)</span> <span class="comment">// 1. 组件扫描</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span> <span class="comment">// 2. 开启 MVC 注解驱动 (等同于 &lt;mvc:annotation-driven/&gt;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 配置视图解析器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置 JSP 视图解析器</span></span><br><span class="line">        registry.jsp(<span class="string">&quot;/WEB-INF/pages/&quot;</span>, <span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 开启静态资源处理 (DefaultServletHandler)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 配置拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/static/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-4-替代-applicationContext-xml：Spring-配置类"><a href="#2-4-替代-applicationContext-xml：Spring-配置类" class="headerlink" title="2.4 替代 applicationContext.xml：Spring 配置类"></a>2.4 替代 applicationContext.xml：Spring 配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;, </span></span><br><span class="line"><span class="meta">    excludeFilters = @Filter(type = FilterType.ANNOTATION, classes = Controller.class))</span> <span class="comment">// 排除 Controller</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:db.properties&quot;)</span> <span class="comment">// 加载配置文件</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">// 开启事务注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入配置文件中的值</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 配置数据源 Bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 配置 JdbcTemplate 或 MyBatis SqlSessionFactory</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        bean.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 配置事务管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="七、源码剖析"><a href="#七、源码剖析" class="headerlink" title="七、源码剖析"></a>七、源码剖析</h1><h2 id="1-DispatcherServlet-初始化过程"><a href="#1-DispatcherServlet-初始化过程" class="headerlink" title="1. DispatcherServlet 初始化过程"></a>1. DispatcherServlet 初始化过程</h2><h3 id="1-1-继承关系图谱"><a href="#1-1-继承关系图谱" class="headerlink" title="1.1 继承关系图谱"></a>1.1 继承关系图谱</h3><p>要理解初始化，首先要看透它的继承结构。<code>DispatcherServlet</code> 本质上就是一个标准的 <strong>Servlet</strong>。</p>
<pre><code class="highlight mermaid">graph BT
    DispatcherServlet --&gt; FrameworkServlet
    FrameworkServlet --&gt; HttpServletBean
    HttpServletBean --&gt; HttpServlet
    HttpServlet --&gt; GenericServlet
    GenericServlet --&gt; Servlet((Servlet接口))</code></pre>

<ul>
<li><strong><code>Servlet.init(ServletConfig)</code></strong>：Servlet 生命周期的起点。</li>
<li><strong><code>HttpServletBean</code></strong>：负责将 <code>web.xml</code> 中配置的 <code>&lt;init-param&gt;</code> 注入到 Servlet 类的属性中。</li>
<li><strong><code>FrameworkServlet</code></strong>：负责初始化 Spring 的 Web 容器 (<code>WebApplicationContext</code>)。</li>
<li><strong><code>DispatcherServlet</code></strong>：负责初始化 SpringMVC 的九大组件。</li>
</ul>
<hr>
<h3 id="1-2-初始化核心流程"><a href="#1-2-初始化核心流程" class="headerlink" title="1.2 初始化核心流程"></a>1.2 初始化核心流程</h3><p>当 Tomcat 启动（或第一次请求到达）时，会调用 <code>init()</code> 方法。</p>
<h4 id="1-2-1-HttpServletBean-init"><a href="#1-2-1-HttpServletBean-init" class="headerlink" title="1.2.1 HttpServletBean.init()"></a>1.2.1 <code>HttpServletBean.init()</code></h4><blockquote>
<p>目标：读取配置参数，变为属性。</p>
</blockquote>
<ol>
<li>调用父类的 <code>init()</code>。</li>
<li>解析 <code>web.xml</code> 或注解中的初始化参数（如 <code>contextConfigLocation</code>）。</li>
<li>将这些参数赋值给 Servlet 实例的 Bean 属性。</li>
</ol>
<hr>
<h4 id="1-2-2-FrameworkServlet-initServletBean"><a href="#1-2-2-FrameworkServlet-initServletBean" class="headerlink" title="1.2.2 FrameworkServlet.initServletBean()"></a>1.2.2 <code>FrameworkServlet.initServletBean()</code></h4><blockquote>
<p>目标：建立 Spring 容器。</p>
</blockquote>
<p>这是关键的一步。它会调用 <code>initWebApplicationContext()</code> 方法：</p>
<ol>
<li><strong>创建容器</strong>：创建 <code>XmlWebApplicationContext</code>（或注解版容器）。</li>
<li><strong>设置父容器</strong>：如果存在 Root Context（由 ContextLoaderListener 创建的 Service 层容器），将其设置为当前容器的<strong>父容器</strong>。</li>
<li><strong>加载 Bean</strong>：读取 <code>spring-mvc.xml</code>，加载 Controller、ViewResolver 等 Bean。</li>
<li><strong>刷新容器</strong>：调用 <code>wac.refresh()</code>，触发 IOC 容器的初始化流程。</li>
<li><strong>发布事件</strong>：容器创建完成后，调用 <code>onRefresh(wac)</code>。这是一个模板方法，由子类实现。</li>
</ol>
<hr>
<h4 id="1-2-3-DispatcherServlet-onRefresh"><a href="#1-2-3-DispatcherServlet-onRefresh" class="headerlink" title="1.2.3 DispatcherServlet.onRefresh()"></a>1.2.3 <code>DispatcherServlet.onRefresh()</code></h4><blockquote>
<p>目标：初始化九大组件。</p>
</blockquote>
<p><code>DispatcherServlet</code> 重写了 <code>onRefresh</code> 方法，这是 SpringMVC 的<strong>高光时刻</strong>。它调用了 <code>initStrategies(context)</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.web.servlet.DispatcherServlet</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 初始化多文件上传解析器</span></span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 初始化区域解析器 (国际化)</span></span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 初始化主题解析器</span></span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 【核心】初始化处理器映射器 (HandlerMapping)</span></span><br><span class="line">    <span class="comment">// 作用：URL -&gt; Controller</span></span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 【核心】初始化处理器适配器 (HandlerAdapter)</span></span><br><span class="line">    <span class="comment">// 作用：执行 Controller 方法</span></span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 初始化异常解析器</span></span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 7. 初始化视图名转换器</span></span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 8. 【核心】初始化视图解析器 (ViewResolver)</span></span><br><span class="line">    <span class="comment">// 作用：String -&gt; View</span></span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 9. 初始化 FlashMap 管理器 (重定向数据)</span></span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-3-组件初始化的默认策略"><a href="#1-3-组件初始化的默认策略" class="headerlink" title="1.3 组件初始化的默认策略"></a>1.3 组件初始化的默认策略</h3><blockquote>
<p><strong>面试题</strong>：如果在 <code>spring-mvc.xml</code> 中不配置 <code>InternalResourceViewResolver</code>，SpringMVC 会报错吗？</p>
</blockquote>
<p><strong>答</strong>：不会报错，但可能无法正常跳转 JSP。</p>
<p>SpringMVC 有一套<strong>默认配置策略</strong>。</p>
<ul>
<li>配置文件位置：<code>org/springframework/web/servlet/DispatcherServlet.properties</code>。</li>
<li>该文件定义了如果不显式配置 Bean，SpringMVC 默认使用哪些类。<ul>
<li>比如默认的 HandlerMapping 是 <code>BeanNameUrlHandlerMapping</code> 和 <code>RequestMappingHandlerMapping</code>。</li>
<li>默认的 ViewResolver 是 <code>InternalResourceViewResolver</code>。</li>
</ul>
</li>
</ul>
<p><strong>初始化逻辑 (<code>initHandlerMappings</code> 为例)</strong>：</p>
<ol>
<li>首先去 Spring 容器里找有没有类型为 <code>HandlerMapping</code> 的 Bean。<ul>
<li>如果有，就用容器里的（我们自己配的）。</li>
</ul>
</li>
<li>如果没有（<code>detectAllHandlerMappings</code> 没找到），就去读取 <code>DispatcherServlet.properties</code>，加载默认的组件。</li>
</ol>
<hr>
<h2 id="2-doDispatch-方法深度解析"><a href="#2-doDispatch-方法深度解析" class="headerlink" title="2. doDispatch 方法深度解析"></a>2. <code>doDispatch</code> 方法深度解析</h2><h3 id="2-1-方法入口"><a href="#2-1-方法入口" class="headerlink" title="2.1 方法入口"></a>2.1 方法入口</h3><ul>
<li><strong>类</strong>：<code>org.springframework.web.servlet.DispatcherServlet</code></li>
<li><strong>方法</strong>：<code>doDispatch(HttpServletRequest request, HttpServletResponse response)</code></li>
<li><strong>作用</strong>：接收每一个 HTTP 请求，调度组件处理，返回响应。</li>
</ul>
<hr>
<h3 id="2-2-源码骨架-伪代码精简版"><a href="#2-2-源码骨架-伪代码精简版" class="headerlink" title="2.2 源码骨架 (伪代码精简版)"></a>2.2 源码骨架 (伪代码精简版)</h3><p>请务必记住这个 try-catch 结构和核心步骤。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 执行链 (Handler + Interceptors)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;     <span class="comment">// 是否是文件上传</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 步骤 1: 检查是否是文件上传请求</span></span><br><span class="line">            <span class="comment">// 如果是 multipart/form-data，会将 request 包装成 MultipartHttpServletRequest</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 步骤 2: 获取处理器执行链 (HandlerMapping)</span></span><br><span class="line">            <span class="comment">// 结果：找到 Controller 方法，以及该请求对应的一堆拦截器</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果找不到 Handler (404)，抛异常或通过 response 报错</span></span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 步骤 3: 获取处理器适配器 (HandlerAdapter)</span></span><br><span class="line">            <span class="comment">// 结果：找到能执行这个 Handler 的适配器 (如 RequestMappingHandlerAdapter)</span></span><br><span class="line">            <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 步骤 4: 处理 Last-Modified 缓存头 (GET请求优化，非核心)</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 步骤 5: 执行拦截器的 preHandle 方法 (正序)</span></span><br><span class="line">            <span class="comment">// 如果任一拦截器返回 false，流程直接在这里 return，中断后续操作</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 步骤 6: 【核心】适配器执行 Handler (调用 Controller 方法)</span></span><br><span class="line">            <span class="comment">// 结果：返回 ModelAndView 对象 (包含数据和视图名)</span></span><br><span class="line">            <span class="comment">// 注意：如果是 @ResponseBody，这里 mv 可能是 null</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 步骤 7: 处理默认视图名</span></span><br><span class="line">            <span class="comment">// 如果 Controller 返回 void 且没写 @ResponseBody，Spring 会尝试根据 URL 生成视图名</span></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 步骤 8: 执行拦截器的 postHandle 方法 (逆序)</span></span><br><span class="line">            <span class="comment">// 此时可以修改 ModelAndView</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex; <span class="comment">// 捕获业务异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤 9: 处理调度结果 (渲染视图 / 处理异常)</span></span><br><span class="line">        <span class="comment">// 对应方法: processDispatchResult</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="comment">// 兜底异常处理</span></span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 步骤 10: 资源清理</span></span><br><span class="line">        <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">            cleanupMultipart(processedRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-关键步骤深度剖析"><a href="#2-3-关键步骤深度剖析" class="headerlink" title="2.3 关键步骤深度剖析"></a>2.3 关键步骤深度剖析</h3><h4 id="2-3-1-getHandler-寻找-Handler"><a href="#2-3-1-getHandler-寻找-Handler" class="headerlink" title="2.3.1 getHandler() - 寻找 Handler"></a>2.3.1 <code>getHandler()</code> - 寻找 Handler</h4><ul>
<li><strong>逻辑</strong>：遍历容器中所有的 <code>HandlerMapping</code> 列表（如 <code>RequestMappingHandlerMapping</code>）。</li>
<li><strong>匹配</strong>：每个 Mapping 尝试根据 URL 匹配。一旦匹配成功，不仅返回 Handler（Controller 方法），还会把配置好的所有 <code>Interceptor</code> 组装进去，返回一个 <code>HandlerExecutionChain</code> 对象。</li>
</ul>
<hr>
<h4 id="2-3-2-ha-handle-适配器执行"><a href="#2-3-2-ha-handle-适配器执行" class="headerlink" title="2.3.2 ha.handle() - 适配器执行"></a>2.3.2 <code>ha.handle()</code> - 适配器执行</h4><ul>
<li><strong>黑盒内部</strong>：这一步最复杂。它不是简单的反射调用。</li>
<li><strong>参数解析 (<code>ArgumentResolver</code>)</strong>：反射分析 Controller 方法的参数，去 Request 里找数据，进行类型转换、隐式参数注入（Request, Session）。</li>
<li><strong>返回值处理 (<code>ReturnValueHandler</code>)</strong>：<ul>
<li>如果是 <code>String</code>：封装成 <code>ModelAndView</code>。</li>
<li>如果是 <code>@ResponseBody</code>：调用 <code>MessageConverter</code> 写流，标记请求已处理，返回 null 的 <code>mv</code>。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-3-3-processDispatchResult-结果处理"><a href="#2-3-3-processDispatchResult-结果处理" class="headerlink" title="2.3.3 processDispatchResult() - 结果处理"></a>2.3.3 <code>processDispatchResult()</code> - 结果处理</h4><p>这是流程的收尾阶段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(..., ModelAndView mv, Exception exception)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 如果前面有异常 (exception != null)</span></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用全局异常解析器 (HandlerExceptionResolver)</span></span><br><span class="line">        <span class="comment">// 尝试解析异常，返回一个新的错误页面的 ModelAndView</span></span><br><span class="line">        processHandlerException(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 如果 mv 不为空 (说明是跳转页面，不是 @ResponseBody)</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">        <span class="comment">// 【渲染核心】调用 ViewResolver 解析视图并渲染</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 执行拦截器的 afterCompletion (无论成功失败都执行)</span></span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">        mappedHandler.triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringBoot/" rel="prev" title="Spring全家桶-SpringBoot">
                  <i class="fa fa-angle-left"></i> Spring全家桶-SpringBoot
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/10/05/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BA%93/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringData/" rel="next" title="Spring全家桶-SpringData">
                  Spring全家桶-SpringData <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
