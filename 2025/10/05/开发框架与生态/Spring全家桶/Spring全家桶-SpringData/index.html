<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="四、SpringData1. Spring JDBC1.1 JdbcTemplate 的使用 (CRUD操作)1.1.1 什么是 JdbcTemplate？JdbcTemplate 是 Spring Framework 核心包 (spring-jdbc)中提供的一个核心类。它极大地简化了传统JDBC的使用，旨在解决原生JDBC开发的几大痛”点：  资源管理的繁琐: 原生JDBC需要手动管理Conn">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring全家桶-SpringData">
<meta property="og:url" content="http://example.com/2025/10/05/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringData/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:description" content="四、SpringData1. Spring JDBC1.1 JdbcTemplate 的使用 (CRUD操作)1.1.1 什么是 JdbcTemplate？JdbcTemplate 是 Spring Framework 核心包 (spring-jdbc)中提供的一个核心类。它极大地简化了传统JDBC的使用，旨在解决原生JDBC开发的几大痛”点：  资源管理的繁琐: 原生JDBC需要手动管理Conn">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-05T11:55:10.000Z">
<meta property="article:modified_time" content="2025-10-16T08:04:24.266Z">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/10/05/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringData/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/10/05/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringData/","path":"2025/10/05/开发框架与生态/Spring全家桶/Spring全家桶-SpringData/","title":"Spring全家桶-SpringData"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Spring全家桶-SpringData | 冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">冉的技术宝典</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81SpringData"><span class="nav-number">1.</span> <span class="nav-text">四、SpringData</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Spring-JDBC"><span class="nav-number">1.1.</span> <span class="nav-text">1. Spring JDBC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-JdbcTemplate-%E7%9A%84%E4%BD%BF%E7%94%A8-CRUD%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 JdbcTemplate 的使用 (CRUD操作)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E4%BB%80%E4%B9%88%E6%98%AF-JdbcTemplate%EF%BC%9F"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">1.1.1 什么是 JdbcTemplate？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%87%86%E5%A4%87"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">1.1.2 配置与准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-%E6%A0%B8%E5%BF%83CRUD%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">1.1.3 核心CRUD操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C-INSERT-UPDATE-DELETE"><span class="nav-number">1.1.1.3.1.</span> <span class="nav-text">1. 更新操作 (INSERT, UPDATE, DELETE)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%9F%A5%E8%AF%A2%E5%8D%95%E4%B8%AA%E5%80%BC-Query-for-a-Single-Value"><span class="nav-number">1.1.1.3.2.</span> <span class="nav-text">2. 查询单个值 (Query for a Single Value)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%9F%A5%E8%AF%A2%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1-Query-for-a-Single-Object"><span class="nav-number">1.1.1.3.3.</span> <span class="nav-text">3. 查询单个对象 (Query for a Single Object)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%9F%A5%E8%AF%A2%E5%AF%B9%E8%B1%A1%E5%88%97%E8%A1%A8-Query-for-a-List-of-Objects"><span class="nav-number">1.1.1.3.4.</span> <span class="nav-text">4. 查询对象列表 (Query for a List of Objects)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C-Batch-Operations"><span class="nav-number">1.1.1.3.5.</span> <span class="nav-text">5. 批量操作 (Batch Operations)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Spring-Data-Commons"><span class="nav-number">1.2.</span> <span class="nav-text">2. Spring Data Commons</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E6%A0%B8%E5%BF%83%E7%90%86%E5%BF%B5"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 核心理念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%B1%82%E7%9A%84%E7%97%9B%E7%82%B9"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">2.1.1 问题背景：传统数据访问层的痛点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E6%A0%B8%E5%BF%83%E7%90%86%E5%BF%B5%EF%BC%9A%E7%BB%9F%E4%B8%80%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%8A%BD%E8%B1%A1-Unified-Data-Access-Abstraction"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">2.1.2 核心理念：统一的数据访问抽象 (Unified Data Access Abstraction)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Repository-%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%88%E6%9E%81%E6%8A%BD%E8%B1%A1"><span class="nav-number">1.2.1.2.1.</span> <span class="nav-text">1. Repository 模式的终极抽象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%BA%A6%E5%AE%9A%E4%BC%98%E4%BA%8E%E9%85%8D%E7%BD%AE-Convention-over-Configuration-%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.1.2.2.</span> <span class="nav-text">2. 约定优于配置 (Convention over Configuration) 的查询方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E9%80%9A%E7%94%A8%E5%8A%9F%E8%83%BD"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 通用功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E6%8E%92%E5%BA%8F-Sorting"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">2.2.1 排序 (Sorting)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Sort-%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.2.1.1.</span> <span class="nav-text">1. Sort 对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%9C%A8Repository%E4%B8%AD%E4%BD%BF%E7%94%A8-Sort"><span class="nav-number">1.2.2.1.2.</span> <span class="nav-text">2. 在Repository中使用 Sort</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E5%88%86%E9%A1%B5-Pagination"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">2.2.2 分页 (Pagination)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Pageable-%E6%8E%A5%E5%8F%A3-%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5"><span class="nav-number">1.2.2.2.1.</span> <span class="nav-text">1. Pageable 接口 (请求分页)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Page-%E6%8E%A5%E5%8F%A3-%E5%93%8D%E5%BA%94%E5%88%86%E9%A1%B5"><span class="nav-number">1.2.2.2.2.</span> <span class="nav-text">2. Page&lt;T&gt; 接口 (响应分页)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%9C%A8Repository%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%88%86%E9%A1%B5"><span class="nav-number">1.2.2.2.3.</span> <span class="nav-text">3. 在Repository中使用分页</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Spring-Data-JPA"><span class="nav-number">1.3.</span> <span class="nav-text">3. Spring Data JPA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%AE%9E%E4%BD%93%E6%98%A0%E5%B0%84"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 实体映射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-Entity-%E5%A3%B0%E6%98%8E%E5%AE%9E%E4%BD%93"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">3.1.1 @Entity - 声明实体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-Id-GeneratedValue-%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%94%AE"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">3.1.2 @Id &amp; @GeneratedValue - 定义主键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-Column-Basic-%E6%98%A0%E5%B0%84%E6%99%AE%E9%80%9A%E5%88%97"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">3.1.3 @Column &amp; @Basic - 映射普通列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4-%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">3.1.4 其他常用注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 关系映射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E9%80%9A%E7%94%A8%E6%A6%82%E5%BF%B5%EF%BC%9A%E5%85%B3%E7%B3%BB%E7%BB%B4%E6%8A%A4%E6%96%B9%E4%B8%8E%E8%A2%AB%E7%BB%B4%E6%8A%A4%E6%96%B9"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">3.2.1 通用概念：关系维护方与被维护方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E5%A4%9A%E5%AF%B9%E4%B8%80-ManyToOne-%E4%B8%80%E5%AF%B9%E5%A4%9A-OneToMany"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">3.2.2 多对一 (@ManyToOne) &amp; 一对多 (@OneToMany)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89%E5%85%B3%E7%B3%BB"><span class="nav-number">1.3.2.2.1.</span> <span class="nav-text">1. 定义关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">1.3.2.2.2.</span> <span class="nav-text">2. 示例代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%85%B3%E9%94%AE%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%B1%9E%E6%80%A7"><span class="nav-number">1.3.2.2.3.</span> <span class="nav-text">3. 关键注解与属性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E4%B8%80%E5%AF%B9%E4%B8%80-OneToOne"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">3.2.3 一对一 (@OneToOne)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-%E5%A4%9A%E5%AF%B9%E5%A4%9A-ManyToMany"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">3.2.4 多对多 (@ManyToMany)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">1.3.2.4.1.</span> <span class="nav-text">1. 示例代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%85%B3%E9%94%AE%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.3.2.4.2.</span> <span class="nav-text">2. 关键注解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3 查询方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E6%96%B9%E6%B3%95%E5%91%BD%E5%90%8D%E6%9F%A5%E8%AF%A2-Query-Methods"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">3.3.1 方法命名查询 (Query Methods)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E7%90%86%E5%BF%B5"><span class="nav-number">1.3.3.1.1.</span> <span class="nav-text">1. 核心理念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.3.1.2.</span> <span class="nav-text">2. 工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A%E8%AF%AD%E6%B3%95"><span class="nav-number">1.3.3.1.3.</span> <span class="nav-text">3. 命名约定语法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E6%9F%A5%E8%AF%A2%E5%89%8D%E7%BC%80-Prefix"><span class="nav-number">1.3.3.1.3.1.</span> <span class="nav-text">a. 查询前缀 (Prefix)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E5%B1%9E%E6%80%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%9D%A1%E4%BB%B6%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="nav-number">1.3.3.1.3.2.</span> <span class="nav-text">b. 属性表达式与条件关键词</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-%E6%8E%92%E5%BA%8F%E4%B8%8E%E9%99%90%E5%88%B6%E7%BB%93%E6%9E%9C"><span class="nav-number">1.3.3.1.3.3.</span> <span class="nav-text">c. 排序与限制结果</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.3.3.1.4.</span> <span class="nav-text">4. 综合示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-Query-%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">3.3.2 @Query 注解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Query%EF%BC%9F"><span class="nav-number">1.3.3.2.1.</span> <span class="nav-text">1. 为什么需要 @Query？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8JPQL-Java-Persistence-Query-Language"><span class="nav-number">1.3.3.2.2.</span> <span class="nav-text">2. 使用JPQL (Java Persistence Query Language)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">1.3.3.2.2.1.</span> <span class="nav-text">a. 基本用法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-%E6%8A%95%E5%BD%B1%E6%9F%A5%E8%AF%A2-%E5%8F%AA%E6%9F%A5%E8%AF%A2%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5"><span class="nav-number">1.3.3.2.2.2.</span> <span class="nav-text">b. 投影查询 (只查询部分字段)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-Modifying"><span class="nav-number">1.3.3.2.2.3.</span> <span class="nav-text">c. 更新和删除操作 (@Modifying)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9FSQL-Native-SQL"><span class="nav-number">1.3.3.2.3.</span> <span class="nav-text">3. 使用原生SQL (Native SQL)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.3.2.4.</span> <span class="nav-text">3. 总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-Specification-%E5%8A%A8%E6%80%81%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">3.3.3 Specification (动态查询)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Specification%EF%BC%9F"><span class="nav-number">1.3.3.3.1.</span> <span class="nav-text">1. 为什么需要 Specification？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%A0%B8%E5%BF%83%E7%90%86%E5%BF%B5%EF%BC%9A%E8%B0%93%E8%AF%8D-Predicate-%E7%9A%84%E7%BB%84%E5%90%88"><span class="nav-number">1.3.3.3.2.</span> <span class="nav-text">2. 核心理念：谓词 (Predicate) 的组合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Specification"><span class="nav-number">1.3.3.3.3.</span> <span class="nav-text">3. 如何使用 Specification</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF"><span class="nav-number">1.3.3.3.4.</span> <span class="nav-text">4. 优势与劣势</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Spring-Data-for-Redis"><span class="nav-number">1.4.</span> <span class="nav-text">4. Spring Data for Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9B%86%E6%88%90"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 客户端集成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">4.1.1 如何配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-Lettuce-%E7%8E%B0%E4%BB%A3%E5%8C%96%E7%9A%84%E3%80%81%E9%BB%98%E8%AE%A4%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">4.1.2 Lettuce - 现代化的、默认的选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3-Jedis-%E4%BC%A0%E7%BB%9F%E8%80%8C%E7%A8%B3%E5%AE%9A%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">4.1.3 Jedis - 传统而稳定的选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-4-%E5%A6%82%E4%BD%95%E4%BB%8ELettuce%E5%88%87%E6%8D%A2%E5%88%B0Jedis%EF%BC%9F"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">4.1.4 如何从Lettuce切换到Jedis？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-5-%E6%80%BB%E7%BB%93"><span class="nav-number">1.4.1.5.</span> <span class="nav-text">4.1.5 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-RedisTemplate-vs-StringRedisTemplate"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2 RedisTemplate vs StringRedisTemplate</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-RedisTemplate-%E9%80%9A%E7%94%A8%E7%9A%84%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">4.2.1 RedisTemplate&lt;K, V&gt; - 通用的、面向对象的模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-StringRedisTemplate-%E4%B8%93%E7%94%A8%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">4.2.2 StringRedisTemplate - 专用于字符串的模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-%E6%80%BB%E7%BB%93"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">4.2.3 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.3 常用数据结构操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-String-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">4.3.1 String (字符串)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-Hash-%E5%93%88%E5%B8%8C"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">4.3.2 Hash (哈希)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-List-%E5%88%97%E8%A1%A8"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">4.3.3 List (列表)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-4-Set-%E9%9B%86%E5%90%88"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">4.3.4 Set (集合)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-5-ZSet-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">4.3.5 ZSet (有序集合)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-SpringCache%E6%8A%BD%E8%B1%A1%E4%B8%8ERedis%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.4.</span> <span class="nav-text">4.4 SpringCache抽象与Redis实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-%E4%BB%80%E4%B9%88%E6%98%AF-Spring-Cache-%E6%8A%BD%E8%B1%A1%EF%BC%9F"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">4.4.1 什么是 Spring Cache 抽象？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">4.4.2 核心注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-%E4%BD%BF%E7%94%A8Redis%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">4.4.3 使用Redis作为缓存实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-4-%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">4.4.4 序列化问题与解决方案</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/10/05/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringData/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Spring全家桶-SpringData | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring全家桶-SpringData
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-05 19:55:10" itemprop="dateCreated datePublished" datetime="2025-10-05T19:55:10+08:00">2025-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-16 16:04:24" itemprop="dateModified" datetime="2025-10-16T16:04:24+08:00">2025-10-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="四、SpringData"><a href="#四、SpringData" class="headerlink" title="四、SpringData"></a>四、SpringData</h1><h2 id="1-Spring-JDBC"><a href="#1-Spring-JDBC" class="headerlink" title="1. Spring JDBC"></a>1. Spring JDBC</h2><h3 id="1-1-JdbcTemplate-的使用-CRUD操作"><a href="#1-1-JdbcTemplate-的使用-CRUD操作" class="headerlink" title="1.1 JdbcTemplate 的使用 (CRUD操作)"></a>1.1 <code>JdbcTemplate</code> 的使用 (CRUD操作)</h3><h4 id="1-1-1-什么是-JdbcTemplate？"><a href="#1-1-1-什么是-JdbcTemplate？" class="headerlink" title="1.1.1 什么是 JdbcTemplate？"></a>1.1.1 什么是 <code>JdbcTemplate</code>？</h4><p><code>JdbcTemplate</code> 是 Spring Framework 核心包 (<code>spring-jdbc</code>)中提供的一个核心类。它<strong>极大地简化了传统JDBC的使用</strong>，旨在解决原生JDBC开发的几大痛”点：</p>
<ol>
<li><strong>资源管理的繁琐</strong>: 原生JDBC需要手动管理<code>Connection</code>, <code>Statement</code>, <code>ResultSet</code>的创建和关闭，并且必须在<code>finally</code>块中进行以确保资源释放，代码冗长且容易出错。</li>
<li><strong>异常处理的复杂</strong>: 原生JDBC抛出的是受检异常 <code>SQLException</code>，开发者必须在代码中显式地<code>try-catch</code>。</li>
<li><strong>重复的样板代码</strong>: 每次查询都需要重复编写获取连接、创建<code>Statement</code>、执行SQL、遍历<code>ResultSet</code>、关闭资源等一系列步骤。</li>
</ol>
<p><strong><code>JdbcTemplate</code> 所做的就是将这些重复的、底层的、资源管理相关的“脏活累活”全部封装起来</strong>，让开发者可以只专注于两件核心的事情：</p>
<ol>
<li><strong>提供SQL语句</strong>。</li>
<li><strong>处理查询结果</strong>。</li>
</ol>
<hr>
<h4 id="1-1-2-配置与准备"><a href="#1-1-2-配置与准备" class="headerlink" title="1.1.2 配置与准备"></a>1.1.2 配置与准备</h4><p><strong>Step 1: 添加依赖</strong></p>
<p>只需要引入<code>spring-boot-starter-jdbc</code>依赖。通常，如果你使用了任何数据库相关的Starter（如<code>spring-boot-starter-data-jpa</code>或<code>spring-boot-starter-mybatis</code>），这个依赖已经被传递性地包含了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> <span class="comment">&lt;!-- 或者其他数据库驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Step 2: 配置数据源 (<code>application.yml</code>)</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/testdb?useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">password</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p><strong>Step 3: 注入 <code>JdbcTemplate</code></strong></p>
<p>Spring Boot的自动配置机制会检测到<code>DataSource</code>的存在，并<strong>自动为你创建一个 <code>JdbcTemplate</code> 的Bean</strong>。你只需要在需要使用它的地方（如Service或DAO层）通过 <code>@Autowired</code> 注入即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... CRUD方法将在这里实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-1-3-核心CRUD操作"><a href="#1-1-3-核心CRUD操作" class="headerlink" title="1.1.3 核心CRUD操作"></a>1.1.3 核心CRUD操作</h4><p>假设我们有一个<code>user</code>表，包含<code>id</code>, <code>username</code>, <code>password</code>, <code>email</code>字段。</p>
<h5 id="1-更新操作-INSERT-UPDATE-DELETE"><a href="#1-更新操作-INSERT-UPDATE-DELETE" class="headerlink" title="1. 更新操作 (INSERT, UPDATE, DELETE)"></a>1. 更新操作 (INSERT, UPDATE, DELETE)</h5><p>对于所有不返回结果集（只返回受影响行数）的写操作，都使用 <code>update()</code> 方法。</p>
<ul>
<li><strong><code>int update(String sql, Object... args)</code></strong>:<ul>
<li><code>sql</code>: 带有 <code>?</code> 占位符的SQL语句。</li>
<li><code>args</code>: 与 <code>?</code> 占位符按顺序对应的参数列表。</li>
<li><strong>返回值</strong>: <code>int</code> 类型，表示受影响的行数。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CREATE (INSERT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO user (username, password, email) VALUES (?, ?, ?)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.update(sql, user.getUsername(), user.getPassword(), user.getEmail());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UPDATE</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateUserEmail</span><span class="params">(Long id, String newEmail)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE user SET email = ? WHERE id = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.update(sql, newEmail, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DELETE</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;DELETE FROM user WHERE id = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.update(sql, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优势</strong>: <code>JdbcTemplate</code> 内部处理了 <code>PreparedStatement</code> 的创建和参数绑定，有效防止了<strong>SQL注入</strong>。</p>
<hr>
<h5 id="2-查询单个值-Query-for-a-Single-Value"><a href="#2-查询单个值-Query-for-a-Single-Value" class="headerlink" title="2. 查询单个值 (Query for a Single Value)"></a>2. 查询单个值 (Query for a Single Value)</h5><p>当你确定查询结果<strong>只有一行一列</strong>时（例如查询总数、获取某个用户的姓名），使用 <code>queryForObject()</code>。</p>
<ul>
<li><strong><code>T queryForObject(String sql, Class&lt;T&gt; requiredType, Object... args)</code></strong>:<ul>
<li><code>requiredType</code>: 期望返回值的类型（如 <code>Integer.class</code>, <code>String.class</code>）。</li>
<li><strong>注意</strong>: 如果查询没有返回任何行，或者返回了多行，此方法会抛出异常。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询用户总数</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">countUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT COUNT(*) FROM user&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据ID查询用户名</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUsernameById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT username FROM user WHERE id = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, String.class, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-查询单个对象-Query-for-a-Single-Object"><a href="#3-查询单个对象-Query-for-a-Single-Object" class="headerlink" title="3. 查询单个对象 (Query for a Single Object)"></a>3. 查询单个对象 (Query for a Single Object)</h5><p>当你需要将<strong>一行</strong>查询结果映射为一个完整的Java对象时，也使用 <code>queryForObject()</code>，但需要提供一个 <code>RowMapper</code>。</p>
<ul>
<li><strong><code>T queryForObject(String sql, RowMapper&lt;T&gt; rowMapper, Object... args)</code></strong>:<ul>
<li><code>RowMapper&lt;T&gt;</code>: 这是一个<strong>函数式接口</strong>，其核心方法是 <code>T mapRow(ResultSet rs, int rowNum)</code>。你需要在这个方法中实现如何将 <code>ResultSet</code> 的当前行数据，手动映射到你的Java对象的字段上。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据ID查询一个完整的User对象</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">findUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM user WHERE id = ?&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// RowMapper可以定义为匿名内部类，或Lambda表达式，或一个独立的类</span></span><br><span class="line">    RowMapper&lt;User&gt; rowMapper = (rs, rowNum) -&gt; &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(rs.getLong(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        user.setUsername(rs.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        user.setPassword(rs.getString(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">        user.setEmail(rs.getString(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, rowMapper, id);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (EmptyResultDataAccessException e) &#123;</span><br><span class="line">        <span class="comment">// queryForObject在找不到记录时会抛出此异常，可以捕获并返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Spring内置的 <code>BeanPropertyRowMapper</code></strong>:</p>
<p>如果你的Java Bean的<strong>字段名</strong>与数据库表的<strong>列名</strong>完全一致（或符合驼峰与下划线的转换规则），你可以使用 <code>BeanPropertyRowMapper</code> 来简化映射，无需手动编写<code>RowMapper</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">findUserByIdSimple</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM user WHERE id = ?&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class), id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-查询对象列表-Query-for-a-List-of-Objects"><a href="#4-查询对象列表-Query-for-a-List-of-Objects" class="headerlink" title="4. 查询对象列表 (Query for a List of Objects)"></a>4. 查询对象列表 (Query for a List of Objects)</h5><p>当你需要查询<strong>多行</strong>数据，并将每一行都映射为一个Java对象时，使用 <code>query()</code> 方法。</p>
<ul>
<li><strong><code>List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper, Object... args)</code></strong>:<ul>
<li>这个方法会遍历 <code>ResultSet</code> 的所有行，对每一行都调用你提供的 <code>RowMapper</code>，并将所有映射出的对象收集到一个 <code>List</code> 中返回。</li>
<li>如果查询结果为空，它会返回一个<strong>空的List</strong>，而不是<code>null</code>。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有用户</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM user&quot;</span>;</span><br><span class="line">    <span class="comment">// 可以复用上面定义的rowMapper，或者使用BeanPropertyRowMapper</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据email后缀查询用户</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findUsersByEmailDomain</span><span class="params">(String domain)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM user WHERE email LIKE ?&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class), <span class="string">&quot;%&quot;</span> + domain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-批量操作-Batch-Operations"><a href="#5-批量操作-Batch-Operations" class="headerlink" title="5. 批量操作 (Batch Operations)"></a>5. 批量操作 (Batch Operations)</h5><p>当需要执行大量相同的写操作时（如一次性插入1000条记录），使用 <code>batchUpdate()</code> 可以获得极高的性能，因为它会减少网络往返次数。</p>
<ul>
<li><strong><code>int[] batchUpdate(String sql, List&lt;Object[]&gt; batchArgs)</code></strong>:</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批量添加用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] batchAddUsers(List&lt;User&gt; users) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO user (username, password, email) VALUES (?, ?, ?)&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">        Object[] args = &#123;user.getUsername(), user.getPassword(), user.getEmail()&#125;;</span><br><span class="line">        batchArgs.add(args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-Spring-Data-Commons"><a href="#2-Spring-Data-Commons" class="headerlink" title="2. Spring Data Commons"></a>2. Spring Data Commons</h2><h3 id="2-1-核心理念"><a href="#2-1-核心理念" class="headerlink" title="2.1 核心理念"></a>2.1 核心理念</h3><h4 id="2-1-1-问题背景：传统数据访问层的痛点"><a href="#2-1-1-问题背景：传统数据访问层的痛点" class="headerlink" title="2.1.1 问题背景：传统数据访问层的痛点"></a>2.1.1 问题背景：传统数据访问层的痛点</h4><p>在 Spring Data 出现之前，即使使用了像 JPA&#x2F;Hibernate 这样的ORM框架，数据访问层（DAO&#x2F;Repository层）的开发依然存在大量重复的、机械化的<strong>样板代码 (Boilerplate Code)</strong>。</p>
<p>对于每一个实体（Entity），比如 <code>User</code>, <code>Order</code>, <code>Product</code>，我们通常都需要手动编写一个实现类，并在其中一遍又一遍地实现最基础的CRUD（创建、读取、更新、删除）操作：</p>
<p><strong>传统的JPA Repository实现示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span> <span class="comment">// 声明为数据访问Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JpaUserRepository</span> <span class="keyword">implements</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PersistenceContext</span> <span class="comment">// 注入JPA的EntityManager</span></span><br><span class="line">    <span class="keyword">private</span> EntityManager em;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> em.find(User.class, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> em.createQuery(<span class="string">&quot;SELECT u FROM User u&quot;</span>, User.class).getResultList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (user.getId() == <span class="literal">null</span>) &#123;</span><br><span class="line">            em.persist(user); <span class="comment">// 新增</span></span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> em.merge(user); <span class="comment">// 更新</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        em.remove(em.contains(user) ? user : em.merge(user));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果需要按名字查找，还需要再写一个方法...</span></span><br><span class="line">    <span class="comment">// public User findByUsername(String username) &#123; ... &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>痛点分析</strong>：</p>
<ol>
<li><strong>高度重复</strong>: <code>findById</code>, <code>findAll</code>, <code>save</code>, <code>delete</code> 的实现逻辑在99%的情况下都是完全一样的，但我们却要为每个实体都写一遍。</li>
<li><strong>容易出错</strong>: 手动编写JPQL或SQL语句容易出现拼写错误。</li>
<li><strong>工作量大</strong>: 应用中有几十个实体，就意味着要写几十个这样的实现类。</li>
</ol>
<hr>
<h4 id="2-1-2-核心理念：统一的数据访问抽象-Unified-Data-Access-Abstraction"><a href="#2-1-2-核心理念：统一的数据访问抽象-Unified-Data-Access-Abstraction" class="headerlink" title="2.1.2 核心理念：统一的数据访问抽象 (Unified Data Access Abstraction)"></a>2.1.2 核心理念：统一的数据访问抽象 (Unified Data Access Abstraction)</h4><p><strong>Spring Data Commons 的核心理念</strong>就是为了解决上述痛点，它旨在提供一个<strong>统一的、基于Repository模式的数据访问层抽象</strong>，使得开发者无论使用何种持久化技术（关系型数据库、NoSQL数据库等），都能享有一致的、极简的编程模型。</p>
<p><strong>Spring Data Commons 本身不提供任何具体的数据访问实现</strong>。它就像一个**“规范”<strong>或</strong>“蓝图”<strong>，定义了一系列通用的接口和注解。而 Spring Data JPA, Spring Data MongoDB 等具体的模块，则是对这个“规范”的</strong>具体实现**。</p>
<p>这个理念主要通过以下两大支柱来实现：</p>
<h5 id="1-Repository-模式的终极抽象"><a href="#1-Repository-模式的终极抽象" class="headerlink" title="1. Repository 模式的终极抽象"></a>1. Repository 模式的终极抽象</h5><p>Spring Data Commons 将<strong>仓储模式 (Repository Pattern)</strong> 提升到了一个新的高度。它提供了一系列核心接口，开发者只需要继承这些接口，<strong>无需编写任何实现代码</strong>，就能在运行时自动获得强大的数据访问能力。</p>
<ul>
<li><strong><code>Repository&lt;T, ID&gt;</code></strong>:<ul>
<li>最顶层的<strong>标记接口 (Marker Interface)</strong>。它本身不包含任何方法。</li>
<li>它的作用是告诉Spring Data：“这个接口是一个用于数据访问的Repository”。</li>
<li><code>T</code> 代表实体类型（如 <code>User</code>），<code>ID</code> 代表主键类型（如 <code>Long</code>）。</li>
</ul>
</li>
<li><strong><code>CrudRepository&lt;T, ID&gt;</code></strong>:<ul>
<li>继承自 <code>Repository</code>，提供了最基础、最通用的<strong>CRUD</strong>方法。</li>
<li>例如：<code>save()</code>, <code>findById()</code>, <code>findAll()</code>, <code>count()</code>, <code>deleteById()</code>, <code>existsById()</code> 等。</li>
<li><strong>在 90% 的场景下，继承这个接口就足够了</strong>。</li>
</ul>
</li>
<li><strong><code>PagingAndSortingRepository&lt;T, ID&gt;</code></strong>:<ul>
<li>继承自 <code>CrudRepository</code>，额外增加了对<strong>分页 (Pagination)</strong> 和<strong>排序 (Sorting)</strong> 的支持。</li>
<li>例如：<code>findAll(Sort sort)</code>, <code>findAll(Pageable pageable)</code>。</li>
</ul>
</li>
</ul>
<p><strong>核心魔法</strong>：</p>
<p>当你定义一个接口 <code>interface UserRepository extends CrudRepository&lt;User, Long&gt; {}</code> 时，Spring Data在应用启动时，会通过<strong>动态代理 (Dynamic Proxy)</strong> 技术，在内存中<strong>自动为你生成这个接口的实现类</strong>。这个实现类包含了所有<code>CrudRepository</code>中定义方法的高效实现。你只需要定义接口，实现由框架搞定！</p>
<hr>
<h5 id="2-约定优于配置-Convention-over-Configuration-的查询方法"><a href="#2-约定优于配置-Convention-over-Configuration-的查询方法" class="headerlink" title="2. 约定优于配置 (Convention over Configuration) 的查询方法"></a>2. 约定优于配置 (Convention over Configuration) 的查询方法</h5><p>这是 Spring Data 另一个“杀手锏”功能，被称为 <strong>Query Methods</strong> 或 <strong>方法命名查询</strong>。</p>
<ul>
<li><strong>理念</strong>: 你不再需要手写JPQL或SQL查询语句。你只需要按照<strong>预定义的命名约定</strong>来<strong>声明一个方法</strong>，Spring Data 就会在运行时<strong>解析这个方法名</strong>，并<strong>自动为你生成并执行对应的查询</strong>。</li>
<li><strong>命名约定</strong>: <code>find...By...</code>, <code>read...By...</code>, <code>query...By...</code>, <code>count...By...</code>, <code>get...By...</code><ul>
<li><code>findByUsername(String username)</code> -&gt; <code>WHERE username = ?</code></li>
<li><code>findByUsernameAndPassword(String username, String password)</code> -&gt; <code>WHERE username = ? AND password = ?</code></li>
<li><code>findByAgeGreaterThan(int age)</code> -&gt; <code>WHERE age &gt; ?</code></li>
<li><code>findFirst10ByOrderByUsernameDesc()</code> -&gt; <code>WHERE ... ORDER BY username DESC LIMIT 10</code></li>
</ul>
</li>
</ul>
<p><strong>一个形象的比喻</strong>:</p>
<p>可以把 Spring Data Commons 与 Java 的 <code>Collection</code> 框架类比：</p>
<table>
<thead>
<tr>
<th align="left">Java Collection 框架</th>
<th align="left">Spring Data Commons 体系</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>Collection&lt;T&gt;</code></strong> (顶层接口)</td>
<td align="left"><strong><code>Repository&lt;T, ID&gt;</code></strong> (顶层标记接口)</td>
</tr>
<tr>
<td align="left"><strong><code>List&lt;T&gt;</code></strong> (具体接口)</td>
<td align="left"><strong><code>CrudRepository&lt;T, ID&gt;</code></strong> (具体接口)</td>
</tr>
<tr>
<td align="left"><code>new ArrayList&lt;T&gt;()</code> (具体实现)</td>
<td align="left"><code>spring-boot-starter-data-jpa</code> (具体实现模块)</td>
</tr>
</tbody></table>
<p>你编程时面向的是 <code>List</code> 接口，而不需要关心底层是 <code>ArrayList</code>还是 <code>LinkedList</code>。同样，你编程时面向的是 <code>CrudRepository</code>，Spring Data Commons 确保了无论你将来把底层的数据源从JPA换成MongoDB，你的Repository接口和业务代码几乎<strong>无需改动</strong>。</p>
<hr>
<h3 id="2-2-通用功能"><a href="#2-2-通用功能" class="headerlink" title="2.2 通用功能"></a>2.2 通用功能</h3><p>除了提供基础的Repository抽象，Spring Data Commons 还内置了对分页和排序的通用支持。这意味着，无论你使用 Spring Data JPA、Spring Data MongoDB 还是其他模块，进行分页和排序的<strong>编程方式是完全一致的</strong>。</p>
<h4 id="2-2-1-排序-Sorting"><a href="#2-2-1-排序-Sorting" class="headerlink" title="2.2.1 排序 (Sorting)"></a>2.2.1 排序 (Sorting)</h4><h5 id="1-Sort-对象"><a href="#1-Sort-对象" class="headerlink" title="1. Sort 对象"></a>1. <code>Sort</code> 对象</h5><p><code>org.springframework.data.domain.Sort</code> 是一个用于封装排序信息的类。</p>
<ul>
<li><p><strong>创建 <code>Sort</code> 对象</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 按单个字段升序 (默认)</span></span><br><span class="line"><span class="type">Sort</span> <span class="variable">sortByUsernameAsc</span> <span class="operator">=</span> Sort.by(<span class="string">&quot;username&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 按单个字段降序</span></span><br><span class="line"><span class="type">Sort</span> <span class="variable">sortByCreateTimeDesc</span> <span class="operator">=</span> Sort.by(Sort.Direction.DESC, <span class="string">&quot;createTime&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 组合多个排序条件 (按年龄降序，如果年龄相同，再按用户名升序)</span></span><br><span class="line"><span class="type">Sort</span> <span class="variable">sortByAgeDescAndUsernameAsc</span> <span class="operator">=</span> Sort.by(<span class="string">&quot;age&quot;</span>).descending()</span><br><span class="line">                                       .and(Sort.by(<span class="string">&quot;username&quot;</span>).ascending());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种链式写法</span></span><br><span class="line"><span class="type">Sort</span> <span class="variable">complexSort</span> <span class="operator">=</span> Sort.by(</span><br><span class="line">    Sort.Order.desc(<span class="string">&quot;priority&quot;</span>),</span><br><span class="line">    Sort.Order.asc(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-在Repository中使用-Sort"><a href="#2-在Repository中使用-Sort" class="headerlink" title="2. 在Repository中使用 Sort"></a>2. 在Repository中使用 <code>Sort</code></h5><ol>
<li><p><strong>对于 <code>CrudRepository</code></strong>: 它自身没有直接支持排序的方法，但你可以在<strong>方法命名查询</strong>中嵌入排序规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// 方法名中直接包含排序规则</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByStatusOrderByCreateTimeDesc</span><span class="params">(String status)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对于 <code>PagingAndSortingRepository</code></strong>: 这个接口继承自 <code>CrudRepository</code>，并额外提供了一个接收 <code>Sort</code> 参数的 <code>findAll</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PagingAndSortingRepository 继承了 CrudRepository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductRepository</span> <span class="keyword">extends</span> <span class="title class_">PagingAndSortingRepository</span>&lt;Product, Long&gt; &#123;</span><br><span class="line"><span class="comment">// 该接口自带 findAll(Sort sort) 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Service层中使用</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductService</span> &#123;    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductRepository productRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;Product&gt; <span class="title function_">getProductsSortedByPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Sort</span> <span class="variable">sortByPriceAsc</span> <span class="operator">=</span> Sort.by(<span class="string">&quot;price&quot;</span>).ascending();</span><br><span class="line">        <span class="keyword">return</span> (List&lt;Product&gt;) productRepository.findAll(sortByPriceAsc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在自定义查询方法中使用 <code>Sort</code></strong>: 你也可以在自定义的查询方法中添加一个 <code>Sort</code> 类型的参数，Spring Data会自动应用这个排序规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// Spring Data会解析方法名生成查询条件 (WHERE status = ?)，</span></span><br><span class="line">    <span class="comment">// 然后将传入的Sort对象动态地应用到查询的 ORDER BY 子句上。</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByStatus</span><span class="params">(String status, Sort sort)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Service层中使用</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getActiveUsersSorted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> Sort.by(<span class="string">&quot;lastName&quot;</span>).ascending();</span><br><span class="line">    <span class="keyword">return</span> userRepository.findByStatus(<span class="string">&quot;ACTIVE&quot;</span>, sort);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="2-2-2-分页-Pagination"><a href="#2-2-2-分页-Pagination" class="headerlink" title="2.2.2 分页 (Pagination)"></a>2.2.2 分页 (Pagination)</h4><p>当查询结果集非常大时，一次性加载所有数据是不现实的，这会导致内存溢出和性能问题。分页查询是必须的。Spring Data Commons 提供了 <code>Pageable</code> 和 <code>Page</code> 两个核心接口来优雅地处理分页。</p>
<h5 id="1-Pageable-接口-请求分页"><a href="#1-Pageable-接口-请求分页" class="headerlink" title="1. Pageable 接口 (请求分页)"></a>1. <code>Pageable</code> 接口 (请求分页)</h5><p><code>org.springframework.data.domain.Pageable</code> 是一个接口，用于<strong>封装分页请求信息</strong>，通常由客户端（或Service层）传入。</p>
<ul>
<li><p><strong>核心信息</strong>:</p>
<ul>
<li><strong>页码 (Page Number)</strong>: 请求的是第几页（<strong>从0开始</strong>）。</li>
<li><strong>每页大小 (Page Size)</strong>: 每页希望返回多少条记录。</li>
<li><strong>排序信息 (Sort)</strong>: 一个可选的 <code>Sort</code> 对象，用于对当前页的数据进行排序。</li>
</ul>
</li>
<li><p><strong>创建 <code>Pageable</code> 对象</strong>:<br>通常使用其实现类 <code>PageRequest</code> 来创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个简单的分页请求：请求第 0 页，每页 10 条数据</span></span><br><span class="line"><span class="type">Pageable</span> <span class="variable">firstPageWithTenElements</span> <span class="operator">=</span> PageRequest.of(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个带排序的分页请求：请求第 2 页，每页 5 条，按用户名降序</span></span><br><span class="line"><span class="type">Pageable</span> <span class="variable">thirdPageWithFiveElementsSorted</span> <span class="operator">=</span> PageRequest.of(<span class="number">2</span>, <span class="number">5</span>, Sort.by(<span class="string">&quot;username&quot;</span>).descending());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以先创建Sort对象</span></span><br><span class="line"><span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> Sort.by(<span class="string">&quot;createTime&quot;</span>).descending();</span><br><span class="line"><span class="type">Pageable</span> <span class="variable">pageableWithSort</span> <span class="operator">=</span> PageRequest.of(<span class="number">0</span>, <span class="number">20</span>, sort);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-Page-接口-响应分页"><a href="#2-Page-接口-响应分页" class="headerlink" title="2. Page&lt;T&gt; 接口 (响应分页)"></a>2. <code>Page&lt;T&gt;</code> 接口 (响应分页)</h5><p><code>org.springframework.data.domain.Page&lt;T&gt;</code> 是一个接口，用于<strong>封装分页查询的结果</strong>。它不仅仅包含了当前页的数据列表，还包含了丰富的<strong>分页元数据 (metadata)</strong>，非常便于前端展示分页控件。</p>
<ul>
<li><strong>核心信息</strong>:<ul>
<li><code>List&lt;T&gt; getContent()</code>: 获取当前页的数据列表。</li>
<li><code>int getTotalPages()</code>: 获取总页数。</li>
<li><code>long getTotalElements()</code>: 获取总记录数。</li>
<li><code>int getNumber()</code>: 获取当前页码（从0开始）。</li>
<li><code>int getSize()</code>: 获取当前页的实际大小。</li>
<li><code>int getNumberOfElements()</code>: 获取当前页的记录数。</li>
<li><code>boolean hasContent()</code>: 判断当前页是否有数据。</li>
<li><code>boolean isFirst()</code>: 是否是第一页。</li>
<li><code>boolean isLast()</code>: 是否是最后一页。</li>
<li><code>boolean hasNext()</code>: 是否有下一页。</li>
<li><code>boolean hasPrevious()</code>: 是否有上一页。</li>
<li><code>Pageable nextPageable()</code>: 获取请求下一页的 <code>Pageable</code> 对象。</li>
<li><code>Pageable previousPageable()</code>: 获取请求上一页的 <code>Pageable</code> 对象。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-在Repository中使用分页"><a href="#3-在Repository中使用分页" class="headerlink" title="3. 在Repository中使用分页"></a>3. 在Repository中使用分页</h5><ol>
<li><p><strong>继承 <code>PagingAndSortingRepository</code></strong>: 这个接口直接提供了 <code>findAll(Pageable pageable)</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductRepository</span> <span class="keyword">extends</span> <span class="title class_">PagingAndSortingRepository</span>&lt;Product, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// 自带 Page&lt;Product&gt; findAll(Pageable pageable);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在自定义查询方法中使用 <code>Pageable</code></strong>:</p>
<ul>
<li>在任何自定义的查询方法中，只要将<strong>最后一个参数</strong>设置为 <code>Pageable</code> 类型，并且<strong>返回类型</strong>是 <code>Page&lt;T&gt;</code>，Spring Data就会自动执行分页查询。</li>
<li>它会执行<strong>两次</strong>查询：一次是获取总记录数的 <code>COUNT</code> 查询，一次是获取当前页数据的分页查询。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">PagingAndSortingRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">    <span class="comment">// 根据状态查询用户，并进行分页</span></span><br><span class="line">    Page&lt;User&gt; <span class="title function_">findByStatus</span><span class="params">(String status, Pageable pageable)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Service层中使用</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Page&lt;User&gt; <span class="title function_">findActiveUsers</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建分页请求对象，按创建时间降序</span></span><br><span class="line">        <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> PageRequest.of(page, size, Sort.by(<span class="string">&quot;createTime&quot;</span>).descending());</span><br><span class="line">        <span class="keyword">return</span> userRepository.findByStatus(<span class="string">&quot;ACTIVE&quot;</span>, pageable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在Controller中与Spring MVC集成</strong>:<br>Spring MVC可以自动将HTTP请求中的 <code>page</code>, <code>size</code>, <code>sort</code> 参数解析并组装成一个 <code>Pageable</code> 对象，直接注入到Controller方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端可以这样请求: /users?page=0&amp;size=10&amp;sort=username,desc</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Page&lt;User&gt; <span class="title function_">getActiveUsers</span><span class="params">(Pageable pageable)</span> &#123;</span><br><span class="line">        <span class="comment">// Spring MVC 已经自动根据请求参数创建好了 pageable 对象</span></span><br><span class="line">        <span class="keyword">return</span> userService.findActiveUsers(pageable); <span class="comment">// Service层也需要一个接收Pageable的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个自动化集成极大地简化了分页API的开发。</p>
</li>
</ol>
<hr>
<h2 id="3-Spring-Data-JPA"><a href="#3-Spring-Data-JPA" class="headerlink" title="3. Spring Data JPA"></a>3. Spring Data JPA</h2><p><strong>核心接口</strong></p>
<p>Spring Data JPA 的核心是围绕一系列<strong>层层递进、功能不断增强</strong>的Repository接口构建的。开发者通过继承这些接口，可以“免费”获得大量预先实现好的数据访问方法。这个接口的继承体系主要源自 Spring Data Commons，在第上一章已经介绍过了。</p>
<h3 id="3-1-实体映射"><a href="#3-1-实体映射" class="headerlink" title="3.1 实体映射"></a>3.1 实体映射</h3><p>实体映射是通过一系列的 <strong>JPA (Java Persistence API)</strong> 注解来完成的。这些注解告诉JPA提供者（如Hibernate）如何将一个普通的Java类（POJO）转换为可以被数据库持久化的<strong>实体 (Entity)</strong>。</p>
<hr>
<h4 id="3-1-1-Entity-声明实体"><a href="#3-1-1-Entity-声明实体" class="headerlink" title="3.1.1 @Entity - 声明实体"></a>3.1.1 <code>@Entity</code> - 声明实体</h4><ul>
<li><strong>作用</strong>: <strong>这是最重要的注解</strong>。它标记在一个类上，向JPA声明这个类是一个实体类，它将<strong>映射到数据库中的一张表</strong>。</li>
<li><strong>要求</strong>:<ol>
<li>该类必须有一个<strong>无参的构造函数</strong>（可以是<code>public</code>或<code>protected</code>），JPA需要用它来创建实体实例。</li>
<li>该类不能是 <code>final</code> 的，因为JPA提供者可能需要创建代理子类来实现懒加载等特性。</li>
<li>必须包含一个<strong>主键</strong>，通过<code>@Id</code>注解标记。</li>
</ol>
</li>
<li><strong><code>@Table</code> - 指定表名</strong><ul>
<li><strong>作用</strong>: 与 <code>@Entity</code> 配合使用，用于<strong>显式指定</strong>该实体映射到的数据库表的<strong>名称</strong>。</li>
<li><strong>常用属性</strong>:<ul>
<li><code>name</code>: 指定表名。</li>
<li><code>schema</code>: 指定数据库的模式（Schema）。</li>
<li><code>uniqueConstraints</code>: 定义唯一约束。</li>
</ul>
</li>
<li><strong>约定</strong>: 如果<strong>不使用</strong><code>@Table</code>注解，JPA默认会使用<strong>类名</strong>作为表名（命名策略可能因配置而异，如驼峰转下划线<code>UserInfo</code> -&gt; <code>user_info</code>）。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Table;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span> <span class="comment">// 声明这是一个实体类</span></span><br><span class="line"><span class="meta">@Table(name = &quot;tbl_user&quot;)</span> <span class="comment">// 映射到数据库中的 &#x27;tbl_user&#x27; 表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// ... 字段和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-2-Id-GeneratedValue-定义主键"><a href="#3-1-2-Id-GeneratedValue-定义主键" class="headerlink" title="3.1.2 @Id &amp; @GeneratedValue - 定义主键"></a>3.1.2 <code>@Id</code> &amp; <code>@GeneratedValue</code> - 定义主键</h4><ul>
<li><strong><code>@Id</code></strong>:<ul>
<li><strong>作用</strong>: 标记在实体的某个字段上，声明该字段是实体类的<strong>主键 (Primary Key)</strong>，对应数据库表的主键列。<strong>每个实体必须有且只有一个<code>@Id</code></strong>。</li>
</ul>
</li>
<li><strong><code>@GeneratedValue</code></strong>:<ul>
<li><strong>作用</strong>: 与 <code>@Id</code> 配合使用，用于指定<strong>主键的生成策略</strong>。如果主键是由数据库自动生成的（如自增ID），则必须使用此注解。</li>
<li><strong>核心属性 <code>strategy</code></strong>:<ul>
<li><strong><code>GenerationType.AUTO</code> (默认值)</strong>:<ul>
<li>JPA提供者（Hibernate）会自动选择一个最适合当前数据库的策略。对于MySQL，它会选择<code>IDENTITY</code>；对于Oracle，会选择<code>SEQUENCE</code>。<strong>通常使用默认值即可</strong>。</li>
</ul>
</li>
<li><strong><code>GenerationType.IDENTITY</code></strong>:<ul>
<li>表示主键由数据库的<strong>自增列</strong>生成。适用于支持自增的数据库，如MySQL, SQL Server。</li>
<li>这是最常用的一种策略。</li>
</ul>
</li>
<li><strong><code>GenerationType.SEQUENCE</code></strong>:<ul>
<li>使用数据库的<strong>序列 (Sequence)</strong> 来生成主键。适用于Oracle, PostgreSQL等支持序列的数据库。</li>
<li>需要配合 <code>@SequenceGenerator</code> 注解来指定序列的名称。</li>
</ul>
</li>
<li><strong><code>GenerationType.TABLE</code></strong>:<ul>
<li>使用一张特定的数据库表来模拟序列的功能。这种方式性能较差，已很少使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GenerationType;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span> <span class="comment">// 使用数据库自增策略</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-3-Column-Basic-映射普通列"><a href="#3-1-3-Column-Basic-映射普通列" class="headerlink" title="3.1.3 @Column &amp; @Basic - 映射普通列"></a>3.1.3 <code>@Column</code> &amp; <code>@Basic</code> - 映射普通列</h4><ul>
<li><strong><code>@Column</code></strong>:<ul>
<li><strong>作用</strong>: 标记在实体的字段上，用于<strong>精细化控制</strong>该字段如何映射到数据库表的<strong>列 (Column)</strong>。</li>
<li><strong>常用属性</strong>:<ul>
<li><code>name</code>: 指定数据库列的名称。如果不指定，默认使用字段名。</li>
<li><code>length</code>: 指定列的长度（主要用于<code>VARCHAR</code>类型），默认255。</li>
<li><code>nullable</code>: 是否允许为<code>null</code>，默认<code>true</code>。设置为<code>false</code>会生成<code>NOT NULL</code>约束。</li>
<li><code>unique</code>: 是否是唯一约束，默认<code>false</code>。</li>
<li><code>columnDefinition</code>: 允许你直接定义该列的DDL片段，如<code>columnDefinition = &quot;TEXT&quot;</code>或<code>columnDefinition = &quot;DECIMAL(10, 2) DEFAULT 0.00&quot;</code>。</li>
<li><code>updatable</code>: 该列是否会包含在<code>UPDATE</code>语句中，默认<code>true</code>。</li>
<li><code>insertable</code>: 该列是否会包含在<code>INSERT</code>语句中，默认<code>true</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>@Basic</code></strong>:<ul>
<li>JPA默认会将所有未被注解的、非<code>static</code>、非<code>transient</code>的字段都当作持久化字段处理，这背后其实是隐式地使用了 <code>@Basic</code> 注解。</li>
<li>你<strong>几乎不需要显式使用</strong><code>@Basic</code>。它的主要作用是控制字段的<strong>加载策略</strong> (<code>fetch</code>属性，<code>FetchType.EAGER</code>或<code>FetchType.LAZY</code>），但这对于基本类型字段的懒加载通常意义不大。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">// ... id ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_name&quot;, nullable = false, length = 50, unique = true)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(length = 100)</span> <span class="comment">// 只指定长度</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果字段名和列名一致，且没有其他特殊约束，可以不加@Column注解</span></span><br><span class="line">    <span class="keyword">private</span> String email; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-4-其他常用注解"><a href="#3-1-4-其他常用注解" class="headerlink" title="3.1.4 其他常用注解"></a>3.1.4 其他常用注解</h4><ul>
<li><p><strong><code>@Transient</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 标记在字段上，告诉JPA<strong>忽略这个字段</strong>，不要将它持久化到数据库中。</li>
<li><strong>场景</strong>: 用于存放一些临时的、计算得出的，或者不属于数据模型的字段。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transient</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 假设age是根据生日计算得出的，不需要存入数据库</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@Temporal</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 用于修饰 <code>java.util.Date</code> 或 <code>java.util.Calendar</code> 类型的字段，指定它们在数据库中映射的类型。</li>
<li><strong>属性</strong>:<ul>
<li><code>TemporalType.DATE</code>: 只保留日期部分（映射到<code>DATE</code>类型）。</li>
<li><code>TemporalType.TIME</code>: 只保留时间部分（映射到<code>TIME</code>类型）。</li>
<li><code>TemporalType.TIMESTAMP</code>: 保留日期和时间（映射到<code>TIMESTAMP</code>类型）。</li>
</ul>
</li>
<li><strong>现代实践</strong>: <strong>强烈推荐使用 Java 8 的 <code>java.time</code> 包下的日期时间类型（<code>LocalDate</code>, <code>LocalTime</code>, <code>LocalDateTime</code>）</strong>。这些类型在JPA 2.2及以上版本中是原生支持的，<strong>不再需要</strong> <code>@Temporal</code> 注解，并且能更精确地映射到数据库类型。</li>
</ul>
</li>
<li><p><strong><code>@Enumerated</code></strong>:</p>
<ul>
<li><strong>作用</strong>: 用于映射<strong>枚举 (Enum)</strong> 类型字段。</li>
<li><strong>属性</strong>:<ul>
<li><strong><code>EnumType.ORDINAL</code> (默认值)</strong>: 将枚举的<strong>序数</strong>（从0开始的整数）存入数据库。<strong>这是一个危险的默认值！</strong> 因为如果你在枚举中间插入一个新的值，所有后续枚举的序数都会改变，导致数据错乱。</li>
<li><strong><code>EnumType.STRING</code> (推荐)</strong>: 将枚举的<strong>名称</strong>（字符串）存入数据库。这更具可读性，也更健壮。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UserStatus</span> &#123; ACTIVE, INACTIVE, BANNED; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Enumerated(EnumType.STRING)</span> <span class="comment">// 强烈推荐使用STRING</span></span><br><span class="line"><span class="meta">@Column(length = 20)</span></span><br><span class="line"><span class="keyword">private</span> UserStatus status;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-2-关系映射"><a href="#3-2-关系映射" class="headerlink" title="3.2 关系映射"></a>3.2 关系映射</h3><p>在关系型数据库中，表与表之间的关系通常通过<strong>外键 (Foreign Key)</strong> 来维护。JPA通过一系列的关系映射注解，将这种数据库层面的关系，优雅地转换为了Java对象之间的<strong>引用 (Reference)</strong> 关系。</p>
<p>关系映射主要分为四种类型，根据实体间数量上的对应关系（“基数”）来定义：</p>
<ol>
<li><strong>一对一 (<code>@OneToOne</code>)</strong></li>
<li><strong>一对多 (<code>@OneToMany</code>)</strong></li>
<li><strong>多对一 (<code>@ManyToOne</code>)</strong></li>
<li><strong>多对多 (<code>@ManyToMany</code>)</strong></li>
</ol>
<hr>
<h4 id="3-2-1-通用概念：关系维护方与被维护方"><a href="#3-2-1-通用概念：关系维护方与被维护方" class="headerlink" title="3.2.1 通用概念：关系维护方与被维护方"></a>3.2.1 通用概念：关系维护方与被维护方</h4><p>在双向关系中（即两个实体都持有对方的引用），必须指定一个<strong>关系维护方 (Owning Side)</strong>。</p>
<ul>
<li><strong>关系维护方</strong>:<ul>
<li>通常是“多”的一方（在<code>@ManyToOne</code>中）或逻辑上的从属方。</li>
<li>这个实体对应的表中，会包含<strong>外键列</strong>。</li>
<li>在代码中，它使用 <code>@JoinColumn</code> 注解来定义外键。</li>
</ul>
</li>
<li><strong>关系被维护方 (Inverse Side)</strong>:<ul>
<li>它不拥有外键。</li>
<li>在代码中，它使用关系注解的 <code>mappedBy</code> 属性来声明：“这段关系由对方的那个字段来维护”。</li>
</ul>
</li>
</ul>
<p><strong>规则</strong>: <code>mappedBy</code> 属性总是出现在<strong>不包含外键</strong>的那一方。</p>
<hr>
<h4 id="3-2-2-多对一-ManyToOne-一对多-OneToMany"><a href="#3-2-2-多对一-ManyToOne-一对多-OneToMany" class="headerlink" title="3.2.2 多对一 (@ManyToOne) &amp; 一对多 (@OneToMany)"></a>3.2.2 多对一 (<code>@ManyToOne</code>) &amp; 一对多 (<code>@OneToMany</code>)</h4><p>这是最常见的一种关系，例如 <strong>用户(User)</strong> 和 <strong>订单(Order)</strong>。一个用户可以有多个订单，但一个订单只属于一个用户。</p>
<h5 id="1-定义关系"><a href="#1-定义关系" class="headerlink" title="1. 定义关系"></a>1. 定义关系</h5><ul>
<li><strong><code>Order</code> (多方 - Owning Side)</strong>:<ul>
<li>持有 <code>User</code> 的单个引用。</li>
<li>使用 <code>@ManyToOne</code> 注解。</li>
<li>使用 <code>@JoinColumn</code> 来定义外键列。</li>
</ul>
</li>
<li><strong><code>User</code> (一方 - Inverse Side)</strong>:<ul>
<li>持有 <code>Order</code> 的一个集合 (<code>Set</code> 或 <code>List</code>)。</li>
<li>使用 <code>@OneToMany</code> 注解。</li>
<li>使用 <code>mappedBy</code> 属性指向 <code>Order</code> 类中维护关系的字段名。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="2-示例代码"><a href="#2-示例代码" class="headerlink" title="2. 示例代码"></a>2. 示例代码</h5><p><strong><code>Order.java</code> (多方，关系维护方)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;orders&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String orderNumber;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span> <span class="comment">// 多对一关系，默认是EAGER加载</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;user_id&quot;)</span> <span class="comment">// 定义外键列，名为 user_id</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>User.java</code> (一方，关系被维护方)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一对多关系，默认是LAZY加载</span></span><br><span class="line">    <span class="comment">// mappedBy 的值是 Order 类中 &quot;user&quot; 字段的名称</span></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = &quot;user&quot;, cascade = CascadeType.ALL, orphanRemoval = true)</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-关键注解与属性"><a href="#3-关键注解与属性" class="headerlink" title="3. 关键注解与属性"></a>3. 关键注解与属性</h5><ul>
<li><strong><code>@JoinColumn(name = &quot;...&quot;)</code></strong>:<ul>
<li>定义了在当前实体对应的表中，外键列的名称。</li>
</ul>
</li>
<li><strong><code>fetch</code> (加载策略)</strong>:<ul>
<li><code>FetchType.EAGER</code> (急切加载): 当查询主实体时，<strong>立即</strong>加载其关联的实体。</li>
<li><code>FetchType.LAZY</code> (懒加载): 当查询主实体时，<strong>不加载</strong>其关联的实体。只有当你<strong>第一次访问</strong>这个关联实体时，JPA才会发送额外的SQL去查询它。</li>
<li><strong>默认值</strong>:<ul>
<li><code>@ManyToOne</code> 和 <code>@OneToOne</code> 默认是 <strong><code>EAGER</code></strong>。</li>
<li><code>@OneToMany</code> 和 <code>@ManyToMany</code> 默认是 <strong><code>LAZY</code></strong>。</li>
</ul>
</li>
<li><strong>最佳实践</strong>: <strong>强烈建议将所有 <code>to-one</code> 关系（<code>@ManyToOne</code>, <code>@OneToOne</code>）手动设置为 <code>LAZY</code></strong>，以避免不必要的查询和N+1问题。只在确定每次都需要关联数据时才使用 <code>EAGER</code>。</li>
</ul>
</li>
<li><strong><code>cascade</code> (级联操作)</strong>:<ul>
<li>定义了对主实体的操作如何<strong>传播</strong>到关联实体。</li>
<li><code>CascadeType.ALL</code>: 所有操作（<code>PERSIST</code>, <code>MERGE</code>, <code>REMOVE</code>, <code>REFRESH</code>, <code>DETACH</code>）都级联。</li>
<li><code>CascadeType.PERSIST</code>: 级联保存（当你保存<code>User</code>时，会自动保存其<code>orders</code>集合中的新订单）。</li>
<li><code>CascadeType.REMOVE</code>: 级联删除（当你删除<code>User</code>时，会自动删除其所有订单）。</li>
<li><strong>使用场景</strong>: 通常在父子关系（如<code>User</code>与<code>Order</code>）中，在“一”的一方使用 <code>cascade = CascadeType.ALL</code>，可以简化代码。</li>
</ul>
</li>
<li><strong><code>orphanRemoval = true</code> (孤儿移除)</strong>:<ul>
<li>与 <code>cascade</code> 配合使用，通常在 <code>@OneToMany</code> 中。</li>
<li>当一个子实体（<code>Order</code>）从父实体（<code>User</code>）的集合中被<strong>移除</strong>时（例如 <code>user.getOrders().remove(someOrder)</code>），这个子实体会被自动从数据库中<strong>删除</strong>。它就像一个“孤儿”，失去了与父级的关联，所以被清理掉。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-2-3-一对一-OneToOne"><a href="#3-2-3-一对一-OneToOne" class="headerlink" title="3.2.3 一对一 (@OneToOne)"></a>3.2.3 一对一 (<code>@OneToOne</code>)</h4><p>例如，<strong>用户(User)</strong> 和 <strong>用户资料(UserProfile)</strong>。一个用户只有一个资料，一个资料也只属于一个用户。</p>
<p>实现方式有两种：共享主键（不推荐）和<strong>唯一外键</strong>。</p>
<p><strong>示例：使用唯一外键</strong></p>
<p><strong><code>UserProfile.java</code> (关系维护方)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProfile</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id; <span class="comment">// 主键</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String bio;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@MapsId</span> <span class="comment">// 关键：将外键 user_id 同时作为本实体的主键</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;user_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>User.java</code> (关系被维护方)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// orphanRemoval=true 确保删除User时，UserProfile也被删除</span></span><br><span class="line">    <span class="meta">@OneToOne(mappedBy = &quot;user&quot;, cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true)</span></span><br><span class="line">    <span class="keyword">private</span> UserProfile userProfile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@MapsId</code>: 这是一个非常巧妙的注解。它告诉JPA，<code>UserProfile</code> 的主键(<code>id</code>)的值，直接来源于关联的<code>User</code>对象的主键。这保证了<code>user_id</code>既是外键，又是主键，从而在数据库层面实现了严格的一对一关系。</li>
</ul>
<hr>
<h4 id="3-2-4-多对多-ManyToMany"><a href="#3-2-4-多对多-ManyToMany" class="headerlink" title="3.2.4 多对多 (@ManyToMany)"></a>3.2.4 多对多 (<code>@ManyToMany</code>)</h4><p>例如，<strong>文章(Post)</strong> 和 <strong>标签(Tag)</strong>。一篇文章可以有多个标签，一个标签也可以用于多篇文章。</p>
<p>在数据库中，多对多关系必须通过一个<strong>中间表 (Join Table &#x2F; Link Table)</strong> 来实现。</p>
<h5 id="1-示例代码"><a href="#1-示例代码" class="headerlink" title="1. 示例代码"></a>1. 示例代码</h5><p><strong><code>Post.java</code> (关系的一方)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany(cascade = &#123; CascadeType.PERSIST, CascadeType.MERGE &#125;)</span></span><br><span class="line">    <span class="meta">@JoinTable(</span></span><br><span class="line"><span class="meta">        name = &quot;post_tag&quot;, // 中间表的名字</span></span><br><span class="line"><span class="meta">        joinColumns = @JoinColumn(name = &quot;post_id&quot;), // 中间表中，指向本实体(Post)的外键列</span></span><br><span class="line"><span class="meta">        inverseJoinColumns = @JoinColumn(name = &quot;tag_id&quot;) // 中间表中，指向另一方实体(Tag)的外键列</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Tag&gt; tags = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>Tag.java</code> (关系的另一方)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tag</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany(mappedBy = &quot;tags&quot;)</span> <span class="comment">// 由Post方的&quot;tags&quot;字段维护关系</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Post&gt; posts = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-关键注解"><a href="#2-关键注解" class="headerlink" title="2. 关键注解"></a>2. 关键注解</h5><ul>
<li><strong><code>@JoinTable</code></strong>:<ul>
<li>用于在<strong>关系维护方</strong>定义中间表的细节。</li>
<li><code>name</code>: 中间表的名称。</li>
<li><code>joinColumns</code>: 定义了中间表中与<strong>当前实体</strong>相关联的外键。</li>
<li><code>inverseJoinColumns</code>: 定义了中间表中与<strong>另一方实体</strong>相关联的外键。</li>
</ul>
</li>
</ul>
<p><strong>多对多关系的警告</strong>:<br>虽然JPA的<code>@ManyToMany</code>用起来很方便，但在实际项目中，中间表往往不只是包含两个外键，可能还需要包含额外的属性（如<code>创建时间</code>、<code>排序字段</code>等）。在这种情况下，<strong>最佳实践</strong>是<strong>将多对多关系拆分为两个一对多关系</strong>，即创建一个代表中间表的<strong>新实体</strong>（如<code>PostTag</code>），然后建立 <code>Post -&gt; PostTag</code> 和 <code>Tag -&gt; PostTag</code> 的两个一对多关系。</p>
<hr>
<h3 id="3-3-查询方式"><a href="#3-3-查询方式" class="headerlink" title="3.3 查询方式"></a>3.3 查询方式</h3><h4 id="3-3-1-方法命名查询-Query-Methods"><a href="#3-3-1-方法命名查询-Query-Methods" class="headerlink" title="3.3.1 方法命名查询 (Query Methods)"></a>3.3.1 方法命名查询 (Query Methods)</h4><h5 id="1-核心理念"><a href="#1-核心理念" class="headerlink" title="1. 核心理念"></a>1. 核心理念</h5><p>方法命名查询的核心理念是：<strong>你不再需要编写JPQL或SQL语句，只需要在你的Repository接口中，按照Spring Data预先定义好的一套命名约定来声明一个方法，Spring Data框架就会在运行时自动为你解析这个方法名，并生成对应的查询语句来执行。</strong></p>
<p>这就像你和Spring Data之间有了一个“暗号”。你说出暗号（方法名），它就能理解你的查询意图。</p>
<hr>
<h5 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h5><ol>
<li><strong>接口定义</strong>: 你在继承了<code>JpaRepository</code>的接口中定义一个新方法，例如 <code>findByUsername(String username)</code>。</li>
<li><strong>应用启动</strong>: Spring Boot在启动并扫描到你的Repository接口时，Spring Data框架会介入。</li>
<li><strong>方法名解析</strong>: 它会获取到你定义的所有方法，并尝试解析那些没有具体实现的方法名。</li>
<li><strong>查询生成</strong>: 它会根据一套严格的语法规则来“拆解”方法名，例如：<ul>
<li><code>find</code>…<code>By</code>…: 识别出查询的前缀和分隔符。</li>
<li><code>Username</code>: 将其解析为实体类<code>User</code>的一个属性<code>username</code>。</li>
<li><code>String username</code>: 识别出方法的参数，并将其与属性<code>username</code>对应。</li>
</ul>
</li>
<li><strong>代理实现</strong>: 最后，它会为这个方法动态地生成一个实现，该实现内部包含了执行 <code>SELECT u FROM User u WHERE u.username = ?1</code> 这样的JPQL查询的逻辑。</li>
</ol>
<p>当你的Service层调用<code>userRepository.findByUsername(&quot;alice&quot;)</code>时，实际上是调用了这个动态生成的代理实现。</p>
<hr>
<h5 id="3-命名约定语法"><a href="#3-命名约定语法" class="headerlink" title="3. 命名约定语法"></a>3. 命名约定语法</h5><p>方法名的结构通常如下：<code>[前缀][关键词][(属性名 + 条件)]...[排序子句]</code></p>
<h6 id="a-查询前缀-Prefix"><a href="#a-查询前缀-Prefix" class="headerlink" title="a. 查询前缀 (Prefix)"></a>a. 查询前缀 (Prefix)</h6><table>
<thead>
<tr>
<th align="left">前缀</th>
<th align="left">描述</th>
<th align="left">返回类型示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>find...By...</code></td>
<td align="left">最常用的查询前缀。</td>
<td align="left"><code>User</code>, <code>List&lt;User&gt;</code></td>
</tr>
<tr>
<td align="left"><code>read...By...</code></td>
<td align="left">功能与<code>find</code>完全相同，语义上表示读取。</td>
<td align="left"><code>User</code>, <code>List&lt;User&gt;</code></td>
</tr>
<tr>
<td align="left"><code>query...By...</code></td>
<td align="left">功能与<code>find</code>完全相同。</td>
<td align="left"><code>User</code>, <code>List&lt;User&gt;</code></td>
</tr>
<tr>
<td align="left"><code>get...By...</code></td>
<td align="left">功能与<code>find</code>完全相同。</td>
<td align="left"><code>User</code>, <code>List&lt;User&gt;</code></td>
</tr>
<tr>
<td align="left"><code>count...By...</code></td>
<td align="left">查询符合条件的记录<strong>总数</strong>。</td>
<td align="left"><code>long</code>, <code>int</code></td>
</tr>
<tr>
<td align="left"><code>exists...By...</code></td>
<td align="left">判断是否存在符合条件的记录。</td>
<td align="left"><code>boolean</code></td>
</tr>
<tr>
<td align="left"><code>delete...By...</code> *</td>
<td align="left">删除符合条件的记录。需要事务支持 (<code>@Transactional</code>)。</td>
<td align="left"><code>long</code> (删除的行数)</td>
</tr>
<tr>
<td align="left"><code>remove...By...</code> *</td>
<td align="left">功能与<code>delete</code>相同。</td>
<td align="left"><code>long</code> (删除的行数)</td>
</tr>
</tbody></table>
<p><em>注意: <code>delete</code>和<code>remove</code>前缀返回的是被删除的记录数或记录列表，具体取决于返回类型定义。</em></p>
<hr>
<h6 id="b-属性表达式与条件关键词"><a href="#b-属性表达式与条件关键词" class="headerlink" title="b. 属性表达式与条件关键词"></a>b. 属性表达式与条件关键词</h6><p><code>By</code>之后的部分是查询的<strong>条件</strong>，由<strong>实体属性名</strong>和<strong>条件关键词</strong>组成。</p>
<ul>
<li><strong>属性名</strong>: 必须与你的实体类中的<strong>字段名完全匹配</strong>（首字母大写）。支持<strong>嵌套属性</strong>，通过 <code>_</code> 或直接驼峰连接，例如 <code>findByAddressCity(String city)</code> 对应 <code>address.city</code>。</li>
<li><strong>条件关键词 (Keywords)</strong>:</li>
</ul>
<table>
<thead>
<tr>
<th align="left">关键词</th>
<th align="left">JPQL&#x2F;SQL 等价物</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>And</code></td>
<td align="left"><code>AND</code></td>
<td align="left"><code>findByUsernameAndEmail(String name, String email)</code></td>
</tr>
<tr>
<td align="left"><code>Or</code></td>
<td align="left"><code>OR</code></td>
<td align="left"><code>findByUsernameOrEmail(String name, String email)</code></td>
</tr>
<tr>
<td align="left"><code>Is</code>, <code>Equals</code></td>
<td align="left"><code>=</code></td>
<td align="left"><code>findByUsername(&quot;alice&quot;)</code>, <code>findByUsernameIs(&quot;alice&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>IsNot</code>, <code>Not</code></td>
<td align="left"><code>!=</code> or <code>&lt;&gt;</code></td>
<td align="left"><code>findByUsernameIsNot(&quot;admin&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>IsNull</code>, <code>IsNotNull</code></td>
<td align="left"><code>IS NULL</code>, <code>IS NOT NULL</code></td>
<td align="left"><code>findByAddressIsNull()</code></td>
</tr>
<tr>
<td align="left"><code>IsTrue</code>, <code>IsFalse</code></td>
<td align="left"><code>= true</code>, <code>= false</code></td>
<td align="left"><code>findByActiveIsTrue()</code></td>
</tr>
<tr>
<td align="left"><code>Like</code>, <code>NotLike</code></td>
<td align="left"><code>LIKE</code>, <code>NOT LIKE</code></td>
<td align="left"><code>findByNameLike(&quot;%a%&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>StartingWith</code></td>
<td align="left"><code>LIKE &#39;prefix%&#39;</code></td>
<td align="left"><code>findByNameStartingWith(&quot;A&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>EndingWith</code></td>
<td align="left"><code>LIKE &#39;%suffix&#39;</code></td>
<td align="left"><code>findByNameEndingWith(&quot;ce&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>Containing</code></td>
<td align="left"><code>LIKE &#39;%infix%&#39;</code></td>
<td align="left"><code>findByNameContaining(&quot;li&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>GreaterThan</code></td>
<td align="left"><code>&gt;</code></td>
<td align="left"><code>findByAgeGreaterThan(18)</code></td>
</tr>
<tr>
<td align="left"><code>GreaterThanEqual</code></td>
<td align="left"><code>&gt;=</code></td>
<td align="left"><code>findByAgeGreaterThanEqual(18)</code></td>
</tr>
<tr>
<td align="left"><code>LessThan</code></td>
<td align="left"><code>&lt;</code></td>
<td align="left"><code>findByAgeLessThan(60)</code></td>
</tr>
<tr>
<td align="left"><code>LessThanEqual</code></td>
<td align="left"><code>&lt;=</code></td>
<td align="left"><code>findByAgeLessThanEqual(60)</code></td>
</tr>
<tr>
<td align="left"><code>Between</code></td>
<td align="left"><code>BETWEEN</code></td>
<td align="left"><code>findByAgeBetween(18, 30)</code> (接收两个参数)</td>
</tr>
<tr>
<td align="left"><code>In</code>, <code>NotIn</code></td>
<td align="left"><code>IN</code>, <code>NOT IN</code></td>
<td align="left"><code>findByStatusIn(List&lt;Status&gt; statuses)</code> (接收集合参数)</td>
</tr>
<tr>
<td align="left"><code>IgnoreCase</code></td>
<td align="left">(会转换值为小写&#x2F;大写进行比较)</td>
<td align="left"><code>findByUsernameIgnoreCase(&quot;ALICE&quot;)</code></td>
</tr>
</tbody></table>
<hr>
<h6 id="c-排序与限制结果"><a href="#c-排序与限制结果" class="headerlink" title="c. 排序与限制结果"></a>c. 排序与限制结果</h6><ul>
<li><strong>排序 (<code>OrderBy</code>)</strong>:<ul>
<li>在方法名末尾使用 <code>OrderBy</code> 子句，后跟属性名和排序方向 (<code>Asc</code> 或 <code>Desc</code>)。</li>
<li><code>findByStatusOrderByUsernameAsc(String status)</code></li>
<li><code>findByStatusOrderByCreateTimeDesc(String status)</code></li>
</ul>
</li>
<li><strong>限制结果数量 (<code>Top</code>, <code>First</code>)</strong>:<ul>
<li>在查询前缀后，<code>By</code>之前，可以加上 <code>Top&lt;N&gt;</code> 或 <code>First&lt;N&gt;</code> 来限制返回结果的数量。</li>
<li><code>findTop10ByOrderByCreateTimeDesc()</code>: 查询最新的10条记录。</li>
<li><code>findFirstByStatus(String status)</code>: 只返回符合条件的第一条记录。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-综合示例"><a href="#4-综合示例" class="headerlink" title="4. 综合示例"></a>4. 综合示例</h5><p>假设有一个 <code>User</code> 实体，包含 <code>username</code>, <code>email</code>, <code>status</code> (Enum), <code>age</code>, <code>createTime</code> 字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 根据用户名精确查找用户 (返回单个对象)</span></span><br><span class="line">    Optional&lt;User&gt; <span class="title function_">findByUsername</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 根据用户名和状态查找用户列表</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByUsernameAndStatus</span><span class="params">(String username, UserStatus status)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 根据年龄大于某个值，并按创建时间降序排序</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByAgeGreaterThanOrderByCreateTimeDesc</span><span class="params">(<span class="type">int</span> age)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 根据用户名模糊查询（忽略大小写）</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findByUsernameContainingIgnoreCase</span><span class="params">(String keyword)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 查询某个日期之后创建的用户数量</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">countByCreateTimeAfter</span><span class="params">(LocalDateTime dateTime)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 查找状态为ACTIVE的前5个用户</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findTop5ByStatus</span><span class="params">(UserStatus status)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 判断是否存在某个邮箱的用户</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">existsByEmail</span><span class="params">(String email)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 根据ID列表批量删除用户</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">deleteByIdIn</span><span class="params">(List&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优势</strong>:</p>
<ul>
<li><strong>零SQL</strong>: 无需编写任何JPQL或SQL，完全避免了拼写错误。</li>
<li><strong>类型安全</strong>: 方法参数是强类型的，IDE和编译器可以进行检查。</li>
<li><strong>代码即文档</strong>: 方法名本身就清晰地描述了查询的目的，可读性极高。</li>
<li><strong>易于重构</strong>: 如果实体字段名发生变化，IDE的重构工具可以自动更新方法名。</li>
</ul>
<p><strong>局限性</strong>:</p>
<ul>
<li>对于<strong>非常复杂</strong>的查询（如多表连接、子查询、复杂的聚合函数），方法名会变得<strong>异常冗长且难以理解</strong>。</li>
<li>无法实现动态查询（即查询条件根据输入动态增减）。</li>
</ul>
<hr>
<h4 id="3-3-2-Query-注解"><a href="#3-3-2-Query-注解" class="headerlink" title="3.3.2 @Query 注解"></a>3.3.2 <code>@Query</code> 注解</h4><h5 id="1-为什么需要-Query？"><a href="#1-为什么需要-Query？" class="headerlink" title="1. 为什么需要 @Query？"></a>1. 为什么需要 <code>@Query</code>？</h5><p>虽然方法命名查询非常便捷，但它有其局限性：</p>
<ol>
<li><strong>复杂查询的表达能力不足</strong>: 对于涉及多表<code>JOIN</code>、子查询、<code>GROUP BY</code>、<code>HAVING</code>或复杂聚合函数的查询，如果硬要用方法名来表示，方法名会变得极其冗长、难以阅读和维护。</li>
<li><strong>查询逻辑固定</strong>: 方法名一旦定义，其查询逻辑就是固定的。它无法处理动态的、根据输入参数有选择性地添加查询条件的需求。</li>
<li><strong>非实体字段查询</strong>: 方法命名查询默认只能查询实体的所有字段。如果你只想查询部分字段（投影查询），或者进行一些计算，方法命名查询就无能为力了。</li>
</ol>
<p><code>@Query</code> 注解就是为了解决这些问题而生的。它允许你<strong>直接在Repository接口的方法上，编写自定义的JPQL（Java Persistence Query Language）或原生SQL语句</strong>，从而获得对查询逻辑的完全控制权。</p>
<hr>
<h5 id="2-使用JPQL-Java-Persistence-Query-Language"><a href="#2-使用JPQL-Java-Persistence-Query-Language" class="headerlink" title="2. 使用JPQL (Java Persistence Query Language)"></a>2. 使用JPQL (Java Persistence Query Language)</h5><p>JPQL是一种<strong>面向对象</strong>的查询语言，语法与SQL非常相似，但它是<strong>针对实体（Entity）和实体的属性</strong>进行查询的，而不是直接操作数据库的表和列。这是使用<code>@Query</code>的首选和最常用的方式。</p>
<h6 id="a-基本用法"><a href="#a-基本用法" class="headerlink" title="a. 基本用法"></a>a. 基本用法</h6><ul>
<li>在Repository接口的方法上添加 <code>@Query</code> 注解。</li>
<li>将JPQL语句作为注解的 <code>value</code> 属性值。</li>
<li>使用<strong>位置参数</strong> (<code>?</code> + 索引，从1开始) 或 <strong>命名参数</strong> (<code>:</code> + 参数名) 来引用方法参数。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 使用位置参数 (?1, ?2, ...)</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT u FROM User u WHERE u.username = ?1 AND u.status = ?2&quot;)</span></span><br><span class="line">    Optional&lt;User&gt; <span class="title function_">findUserByUsernameAndStatus</span><span class="params">(String username, UserStatus status)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 使用命名参数 (:paramName) - 更推荐，可读性更好</span></span><br><span class="line">    <span class="comment">//    需要配合 @Param 注解来绑定方法参数</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT u FROM User u WHERE u.email LIKE :emailPattern&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">findUsersWithEmailLike</span><span class="params">(<span class="meta">@Param(&quot;emailPattern&quot;)</span> String emailPattern)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意：</span></span><br><span class="line">    <span class="comment">// - &quot;User&quot; 是实体类的名字，不是表名 &quot;users&quot;。</span></span><br><span class="line">    <span class="comment">// - &quot;u.username&quot; 是实体类的字段名，不是列名 &quot;user_name&quot;。</span></span><br><span class="line">    <span class="comment">// - JPQL是大小写敏感的 (对于实体名和属性名)。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>@Param(&quot;...&quot;)</code></strong>: 用于将方法的参数与JPQL中的命名参数进行绑定。如果方法参数名与命名参数名一致，在较新版本的Spring Data JPA中可以省略<code>@Param</code>，但显式指定是最佳实践。</li>
</ul>
<hr>
<h6 id="b-投影查询-只查询部分字段"><a href="#b-投影查询-只查询部分字段" class="headerlink" title="b. 投影查询 (只查询部分字段)"></a>b. 投影查询 (只查询部分字段)</h6><p>你可以直接在 <code>SELECT</code> 子句中指定要查询的字段。如果返回的是多个字段，通常需要将它们封装到一个DTO（Data Transfer Object）或接口中。</p>
<p><strong>返回DTO (构造函数表达式)</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserSummaryDTO.java (必须有一个与JPQL中NEW后面的构造函数参数匹配的构造器)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSummaryDTO</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">// Constructor, Getters...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserRepository.java</span></span><br><span class="line"><span class="meta">@Query(&quot;SELECT new com.example.dto.UserSummaryDTO(u.username, u.email) FROM User u WHERE u.id = :id&quot;)</span></span><br><span class="line">UserSummaryDTO <span class="title function_">findUserSummaryById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>返回接口 (Interface-based Projections)</strong>:</p>
<p>这是一种更简洁的方式，你只需要定义一个接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个只包含需要字段的getter方法的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserProjection</span> &#123;</span><br><span class="line">    String <span class="title function_">getUsername</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getEmail</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserRepository.java</span></span><br><span class="line"><span class="meta">@Query(&quot;SELECT u FROM User u WHERE u.id = :id&quot;)</span></span><br><span class="line">UserProjection <span class="title function_">findUserProjectionById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br></pre></td></tr></table></figure>

<p>Spring Data JPA会自动创建一个代理实现来填充这个接口。</p>
<hr>
<h6 id="c-更新和删除操作-Modifying"><a href="#c-更新和删除操作-Modifying" class="headerlink" title="c. 更新和删除操作 (@Modifying)"></a>c. 更新和删除操作 (<code>@Modifying</code>)</h6><p>如果你想通过 <code>@Query</code> 执行 <code>UPDATE</code> 或 <code>DELETE</code> 操作，必须满足两个条件：</p>
<ol>
<li>在 <code>@Query</code> 注解旁边，额外添加 <strong><code>@Modifying</code></strong> 注解。</li>
<li>该方法必须在一个<strong>事务</strong>中执行（通常在Service层的方法上添加 <code>@Transactional</code>）。</li>
</ol>
<p><code>@Modifying</code> 注解告诉Spring Data，这个查询将要<strong>修改数据库状态</strong>。</p>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.Modifying;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Query(&quot;UPDATE User u SET u.status = :newStatus WHERE u.lastLoginTime &lt; :cutoffDate&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateStatusForInactiveUsers</span><span class="params">(<span class="meta">@Param(&quot;newStatus&quot;)</span> UserStatus newStatus, </span></span><br><span class="line"><span class="params">                                     <span class="meta">@Param(&quot;cutoffDate&quot;)</span> LocalDateTime cutoffDate)</span>;</span><br><span class="line">                                     </span><br><span class="line">    <span class="comment">// 返回值 int 表示受影响的行数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 执行 <code>@Modifying</code> 查询后，<strong>持久化上下文（Persistence Context）中的实体可能与数据库中的状态不一致</strong>。如果你需要在同一个事务中继续使用这些被修改的实体，可以设置 <code>@Modifying(clearAutomatically = true)</code> 来自动清空持久化上下文。</p>
<hr>
<h5 id="3-使用原生SQL-Native-SQL"><a href="#3-使用原生SQL-Native-SQL" class="headerlink" title="3. 使用原生SQL (Native SQL)"></a>3. 使用原生SQL (Native SQL)</h5><p>在某些特殊情况下，JPQL可能无法满足需求（例如，使用数据库特有的函数、复杂的查询提示或操作非实体映射的表）。此时，你可以通过<code>@Query</code>执行<strong>原生SQL</strong>。</p>
<ul>
<li><strong>开启原生查询</strong>: 在 <code>@Query</code> 注解中，将 <code>nativeQuery</code> 属性设置为 <code>true</code>。</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用数据库特有的函数 (例如 MySQL的 DATE_FORMAT)</span></span><br><span class="line">    <span class="comment">// 注意：表名和列名都是数据库中的实际名称</span></span><br><span class="line">    <span class="meta">@Query(value = &quot;SELECT * FROM users u WHERE u.user_name = ?1&quot;, nativeQuery = true)</span></span><br><span class="line">    User <span class="title function_">findByUsernameNative</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 投影查询也可以用原生SQL</span></span><br><span class="line">    <span class="meta">@Query(value = &quot;SELECT user_name, email FROM users WHERE id = ?1&quot;, nativeQuery = true)</span></span><br><span class="line">    Map&lt;String, Object&gt; <span class="title function_">findUsernameAndEmailNative</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原生SQL的缺点</strong>:</p>
<ul>
<li><strong>失去了数据库无关性</strong>: 你的代码将与特定的数据库方言（如MySQL, Oracle）绑定。</li>
<li><strong>类型不安全</strong>: 查询中的表名、列名都是字符串，IDE和编译器无法校验其正确性。</li>
<li><strong>分页和排序的复杂性</strong>: 对于复杂的原生SQL，Spring Data可能无法正确地自动生成<code>COUNT</code>查询，你需要手动提供<code>countQuery</code>或<code>countProjection</code>。</li>
</ul>
<hr>
<h5 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h5><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">方法命名查询</th>
<th align="left"><code>@Query</code> 注解</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>易用性</strong></td>
<td align="left"><strong>极高</strong>，无需编写任何查询语句。</td>
<td align="left"><strong>较高</strong>，需要编写JPQL或SQL，但比原生JDBC简单得多。</td>
</tr>
<tr>
<td align="left"><strong>表达能力</strong></td>
<td align="left"><strong>有限</strong>，适用于中等复杂度的CRUD和条件查询。</td>
<td align="left"><strong>极强</strong>，可以实现任何复杂的查询、更新、删除操作。</td>
</tr>
<tr>
<td align="left"><strong>代码可读性</strong></td>
<td align="left">方法名即文档，<strong>非常清晰</strong>（只要不过于复杂）。</td>
<td align="left">JPQL语句也很清晰，但查询逻辑与方法名分离。</td>
</tr>
<tr>
<td align="left"><strong>维护性</strong></td>
<td align="left"><strong>高</strong>，易于重构。</td>
<td align="left"><strong>中等</strong>，修改查询需要直接编辑字符串，容易出错。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left"><strong>80%的日常查询</strong>，特别是简单的条件过滤和排序。</td>
<td align="left"><strong>20%的复杂场景</strong>，如<code>JOIN</code>、投影、批量更新、使用原生SQL等。</td>
</tr>
</tbody></table>
<p><strong>最佳实践</strong>:</p>
<ol>
<li><strong>首选方法命名查询</strong>：对于简单和中等复杂度的查询，优先使用方法命名查询，因为它最简洁、最安全。</li>
<li><strong>次选 <code>@Query</code> + JPQL</strong>：当方法命名查询无法满足需求时，使用 <code>@Query</code> 结合JPQL。这在保持面向对象和一定数据库无关性的同时，提供了强大的查询能力。</li>
<li><strong>最后才考虑 <code>@Query</code> + 原生SQL</strong>：仅在JPQL无法实现特定功能时，才退回到使用原生SQL。</li>
</ol>
<hr>
<h4 id="3-3-3-Specification-动态查询"><a href="#3-3-3-Specification-动态查询" class="headerlink" title="3.3.3 Specification (动态查询)"></a>3.3.3 Specification (动态查询)</h4><h5 id="1-为什么需要-Specification？"><a href="#1-为什么需要-Specification？" class="headerlink" title="1. 为什么需要 Specification？"></a>1. 为什么需要 <code>Specification</code>？</h5><p>在很多业务场景中，我们的查询条件并不是固定的，而是根据用户的输入<strong>动态组合</strong>的。</p>
<p><strong>典型场景：一个复杂的用户搜索功能</strong><br>用户可以在搜索页面上提供以下任意组合的筛选条件：</p>
<ul>
<li>用户名 (模糊匹配)</li>
<li>邮箱 (精确匹配)</li>
<li>状态 (下拉选择)</li>
<li>年龄范围 (大于等于 <code>minAge</code>，小于等于 <code>maxAge</code>)</li>
<li>创建时间的范围</li>
</ul>
<p>如果使用<strong>方法命名查询</strong>，你需要为所有可能的条件组合都创建一个方法，这会导致方法数量爆炸式增长，完全不可行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// findByUsername(String username);</span></span><br><span class="line"><span class="comment">// findByUsernameAndStatus(String username, Status status);</span></span><br><span class="line"><span class="comment">// findByUsernameAndAgeBetween(String username, int minAge, int maxAge);</span></span><br><span class="line"><span class="comment">// ... 组合会非常多</span></span><br></pre></td></tr></table></figure>

<p>如果使用 <strong><code>@Query</code></strong> 注解，你可以在JPQL中用<code>if</code>语句拼接字符串，但这非常繁琐、容易出错，且有SQL注入的风险（尽管JPA参数绑定能缓解部分问题）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Service层拼接JPQL字符串，非常不推荐</span></span><br><span class="line"><span class="type">String</span> <span class="variable">jpql</span> <span class="operator">=</span> <span class="string">&quot;SELECT u FROM User u WHERE 1=1 &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (username != <span class="literal">null</span>) &#123;</span><br><span class="line">    jpql += <span class="string">&quot; AND u.username LIKE :username&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (status != <span class="literal">null</span>) &#123;</span><br><span class="line">    jpql += <span class="string">&quot; AND u.status = :status&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p><strong><code>Specification</code> 就是Spring Data JPA提供的、用于以一种类型安全、面向对象的方式来构建动态查询条件的解决方案。</strong></p>
<hr>
<h5 id="2-核心理念：谓词-Predicate-的组合"><a href="#2-核心理念：谓词-Predicate-的组合" class="headerlink" title="2. 核心理念：谓词 (Predicate) 的组合"></a>2. 核心理念：谓词 (Predicate) 的组合</h5><p><code>Specification</code> 的设计基于 <strong>JPA Criteria API</strong>，它的核心思想是：<strong>将每一个查询条件都看作是一个独立的“谓词 (Predicate)”，然后通过逻辑运算（AND, OR）将这些谓词动态地组合起来，形成一个完整的查询。</strong></p>
<p>一个 <code>Specification&lt;T&gt;</code> 本质上是一个<strong>函数式接口</strong>，它只有一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Specification</span>&lt;T&gt; &#123;</span><br><span class="line">    Predicate <span class="title function_">toPredicate</span><span class="params">(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>: 实体类型。</li>
<li><code>toPredicate(...)</code>: 这个方法就是你需要实现的核心。它的职责是根据输入的 <code>root</code>, <code>query</code>, <code>cb</code>，返回一个JPA的 <code>Predicate</code> 对象，这个对象就代表了一个查询条件（如 <code>username = &#39;alice&#39;</code>）。<ul>
<li><strong><code>Root&lt;T&gt; root</code></strong>: 代表了查询的<strong>根对象</strong>（通常是你要查询的实体）。你可以通过 <code>root.get(&quot;fieldName&quot;)</code> 来获取实体的属性。</li>
<li><strong><code>CriteriaQuery&lt;?&gt; query</code></strong>: 代表了整个查询语句。你可以用它来定义<code>ORDER BY</code>, <code>GROUP BY</code>等。</li>
<li><strong><code>CriteriaBuilder cb</code></strong>: 一个<strong>条件构造器工厂</strong>。它是最重要的部分，提供了大量的方法来创建各种类型的谓词，例如：<ul>
<li><code>cb.equal(expression, value)</code>: 等于 (<code>=</code>)</li>
<li><code>cb.like(expression, pattern)</code>: 模糊匹配 (<code>LIKE</code>)</li>
<li><code>cb.greaterThan(expression, value)</code>: 大于 (<code>&gt;</code>)</li>
<li><code>cb.and(predicate1, predicate2)</code>: 逻辑与 (<code>AND</code>)</li>
<li><code>cb.or(predicate1, predicate2)</code>: 逻辑或 (<code>OR</code>)</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5 id="3-如何使用-Specification"><a href="#3-如何使用-Specification" class="headerlink" title="3. 如何使用 Specification"></a>3. 如何使用 <code>Specification</code></h5><p><strong>Step 1: 让你的Repository接口继承 <code>JpaSpecificationExecutor</code></strong></p>
<p>这个接口提供了执行 <code>Specification</code> 查询所需要的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaSpecificationExecutor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JpaSpecificationExecutor&lt;User&gt; 提供了额外的、接收Specification参数的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt;, JpaSpecificationExecutor&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JpaSpecificationExecutor</code> 提供了如下关键方法：</p>
<ul>
<li><code>Optional&lt;T&gt; findOne(@Nullable Specification&lt;T&gt; spec)</code></li>
<li><code>List&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec)</code></li>
<li><code>Page&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec, Pageable pageable)</code></li>
<li><code>List&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec, Sort sort)</code></li>
<li><code>long count(@Nullable Specification&lt;T&gt; spec)</code></li>
</ul>
<p><strong>Step 2: 在Service层构建 <code>Specification</code></strong></p>
<p>这是最核心的部分。我们通常会在Service层根据传入的参数，动态地构建一个<code>Specification</code>对象。</p>
<p><strong>示例：实现前面提到的用户动态搜索</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">searchUsers</span><span class="params">(UserSearchCriteria criteria)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Specification&lt;User&gt; spec = (root, query, cb) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 创建一个 Predicate 列表，用于存放所有动态生成的查询条件</span></span><br><span class="line">            List&lt;Predicate&gt; predicates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 如果用户名不为空，添加 username LIKE &#x27;%...%&#x27; 条件</span></span><br><span class="line">            <span class="keyword">if</span> (criteria.getUsername() != <span class="literal">null</span> &amp;&amp; !criteria.getUsername().isEmpty()) &#123;</span><br><span class="line">                predicates.add(cb.like(root.get(<span class="string">&quot;username&quot;</span>), <span class="string">&quot;%&quot;</span> + criteria.getUsername() + <span class="string">&quot;%&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 如果状态不为空，添加 status = &#x27;...&#x27; 条件</span></span><br><span class="line">            <span class="keyword">if</span> (criteria.getStatus() != <span class="literal">null</span>) &#123;</span><br><span class="line">                predicates.add(cb.equal(root.get(<span class="string">&quot;status&quot;</span>), criteria.getStatus()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 如果最小年龄不为空，添加 age &gt;= ... 条件</span></span><br><span class="line">            <span class="keyword">if</span> (criteria.getMinAge() != <span class="literal">null</span>) &#123;</span><br><span class="line">                predicates.add(cb.greaterThanOrEqualTo(root.get(<span class="string">&quot;age&quot;</span>), criteria.getMinAge()));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 如果最大年龄不为空，添加 age &lt;= ... 条件</span></span><br><span class="line">            <span class="keyword">if</span> (criteria.getMaxAge() != <span class="literal">null</span>) &#123;</span><br><span class="line">                predicates.add(cb.lessThanOrEqualTo(root.get(<span class="string">&quot;age&quot;</span>), criteria.getMaxAge()));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ... 可以添加更多条件</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将所有条件用 AND 连接起来</span></span><br><span class="line">            <span class="comment">// cb.and() 接收一个 Predicate 数组</span></span><br><span class="line">            <span class="keyword">return</span> cb.and(predicates.toArray(<span class="keyword">new</span> <span class="title class_">Predicate</span>[<span class="number">0</span>]));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用构建好的 Specification 和排序/分页信息进行查询</span></span><br><span class="line">        <span class="keyword">return</span> userRepository.findAll(spec, Sort.by(<span class="string">&quot;createTime&quot;</span>).descending());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UserSearchCriteria</code> 是一个简单的DTO，用于封装搜索参数。</p>
<p><strong>Step 3 (可选): 将<code>Specification</code>逻辑封装成可复用的单元</strong></p>
<p>为了提高代码的可读性和复用性，我们可以为每个查询条件创建一个独立的<code>Specification</code>，然后在需要时将它们组合起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 UserSpecifications 工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSpecifications</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Specification&lt;User&gt; <span class="title function_">usernameContains</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (root, query, cb) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (username == <span class="literal">null</span> || username.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> cb.conjunction(); <span class="comment">// 返回一个恒为 true 的 Predicate</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cb.like(root.get(<span class="string">&quot;username&quot;</span>), <span class="string">&quot;%&quot;</span> + username + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Specification&lt;User&gt; <span class="title function_">hasStatus</span><span class="params">(UserStatus status)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (root, query, cb) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (status == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cb.conjunction();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cb.equal(root.get(<span class="string">&quot;status&quot;</span>), status);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Service层中可以这样使用，代码更清晰</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">searchUsersV2</span><span class="params">(UserSearchCriteria criteria)</span> &#123;</span><br><span class="line">    Specification&lt;User&gt; spec = Specification</span><br><span class="line">            .where(UserSpecifications.usernameContains(criteria.getUsername()))</span><br><span class="line">            .and(UserSpecifications.hasStatus(criteria.getStatus()));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> userRepository.findAll(spec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Specification.where(spec1).and(spec2).or(spec3)</code>: 提供了流式API来组合<code>Specification</code>。</li>
<li><code>cb.conjunction()</code>: 返回一个 <code>true</code> 条件 (<code>1=1</code>)，在动态构建<code>AND</code>条件时非常有用，可以作为初始条件。</li>
<li><code>cb.disjunction()</code>: 返回一个 <code>false</code> 条件 (<code>1=0</code>)，用于构建<code>OR</code>条件。</li>
</ul>
<hr>
<h5 id="4-优势与劣势"><a href="#4-优势与劣势" class="headerlink" title="4. 优势与劣势"></a>4. 优势与劣势</h5><p><strong>优势</strong>:</p>
<ol>
<li><strong>极高的灵活性</strong>: 可以构建出任意复杂的动态查询逻辑。</li>
<li><strong>类型安全</strong>: 所有属性名都是通过 <code>root.get(&quot;fieldName&quot;)</code> 获取的，如果字段名写错，在<strong>编译时</strong>可能会被一些静态分析工具发现（运行时肯定会报错），比拼接字符串更安全。</li>
<li><strong>代码可读性与复用性</strong>: 将查询逻辑封装成独立的<code>Specification</code>方法，使得代码更清晰、易于测试和复用。</li>
</ol>
<p><strong>劣势</strong>:</p>
<ol>
<li><strong>学习曲线陡峭</strong>: <code>Criteria API</code> 的语法相对繁琐和抽象，初学者需要一定时间来适应。</li>
<li><strong>代码量较大</strong>: 相比方法命名查询，实现一个简单的动态查询也需要编写更多的代码。</li>
<li><strong>关联查询（JOIN）相对复杂</strong>: 虽然<code>Criteria API</code>支持JOIN，但语法会变得更加复杂，例如 <code>root.join(&quot;address&quot;).get(&quot;city&quot;)</code>。</li>
</ol>
<hr>
<h2 id="4-Spring-Data-for-Redis"><a href="#4-Spring-Data-for-Redis" class="headerlink" title="4. Spring Data for Redis"></a>4. Spring Data for Redis</h2><h3 id="4-1-客户端集成"><a href="#4-1-客户端集成" class="headerlink" title="4.1 客户端集成"></a>4.1 客户端集成</h3><p>要在Java应用中与Redis服务器进行通信，我们需要一个<strong>Redis客户端库</strong>。这个库负责处理网络连接、执行Redis命令、以及对返回结果进行编码和解码。</p>
<p>在Spring Boot 2.x及以后的版本中，Spring Data Redis 支持两个主流的、高性能的Java Redis客户端：<strong>Lettuce</strong> 和 <strong>Jedis</strong>。</p>
<p><strong>Spring Boot的默认选择</strong>：从 Spring Boot 2.0 开始，<strong>Lettuce</strong> 成为了<strong>默认</strong>的Redis客户端。</p>
<hr>
<h4 id="4-1-1-如何配置"><a href="#4-1-1-如何配置" class="headerlink" title="4.1.1 如何配置"></a>4.1.1 如何配置</h4><p>Spring Boot的自动配置机制使得客户端的集成变得异常简单。</p>
<p><strong>Step 1: 添加 <code>spring-boot-starter-data-redis</code> 依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当你只添加这个Starter时，它会<strong>传递性地依赖 <code>lettuce-core</code></strong>，所以你默认使用的就是Lettuce。</li>
</ul>
<p><strong>Step 2: 配置Redis连接 (<code>application.yml</code>)</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">your-password</span> <span class="comment"># 如果有密码的话</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment"># 使用的数据库索引，默认为0</span></span><br><span class="line">    <span class="attr">lettuce:</span> <span class="comment"># Lettuce特有的连接池配置</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment"># 最大连接数</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span>   <span class="comment"># 最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span>   <span class="comment"># 最小空闲连接</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">-1ms</span> <span class="comment"># 连接等待时间，-1表示不限制</span></span><br></pre></td></tr></table></figure>

<p>完成这两步，Spring Boot就会自动为你配置好一个<code>LettuceConnectionFactory</code>以及后续会讲到的<code>RedisTemplate</code>等Bean，你就可以直接开始使用了。</p>
<hr>
<h4 id="4-1-2-Lettuce-现代化的、默认的选择"><a href="#4-1-2-Lettuce-现代化的、默认的选择" class="headerlink" title="4.1.2 Lettuce - 现代化的、默认的选择"></a>4.1.2 Lettuce - 现代化的、默认的选择</h4><ul>
<li><strong>官方网站</strong>: <a target="_blank" rel="noopener" href="https://lettuce.io/">https://lettuce.io/</a></li>
<li><strong>底层技术</strong>: 基于 <strong>Netty</strong>，一个高性能的、异步的、事件驱动的网络应用框架。</li>
<li><strong>核心特点</strong>:<ol>
<li><strong>异步非阻塞 (Asynchronous &amp; Non-blocking)</strong>: 这是Lettuce<strong>最核心的优势</strong>。它允许你在一个线程上发送多个Redis命令而无需等待响应，当响应返回时，会通过回调来处理。这与响应式编程（Project Reactor）的思想完美契合。</li>
<li><strong>响应式支持 (Reactive)</strong>: Lettuce提供了原生的响应式API，可以返回<code>Mono</code>和<code>Flux</code>。这使得它成为<strong>Spring WebFlux</strong>项目中与Redis交互的<strong>唯一选择</strong>。</li>
<li><strong>可伸缩性和高性能</strong>: 由于其非阻塞的特性，Lettuce可以用更少的线程处理更高的并发量，从而获得更好的性能和资源利用率。</li>
<li><strong>线程安全</strong>: 一个Lettuce连接（<code>StatefulRedisConnection</code>）<strong>是线程安全的</strong>，这意味着多个线程可以<strong>共享同一个连接</strong>来执行命令，而不会产生线程安全问题。这简化了连接管理，并且通过连接池可以进一步提高性能。</li>
</ol>
</li>
<li><strong>缺点</strong>:<ul>
<li>API相对Jedis来说稍显复杂，特别是直接使用其原生异步API时。但在Spring Data Redis的封装下，这个缺点被很大程度上隐藏了。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-1-3-Jedis-传统而稳定的选择"><a href="#4-1-3-Jedis-传统而稳定的选择" class="headerlink" title="4.1.3 Jedis - 传统而稳定的选择"></a>4.1.3 Jedis - 传统而稳定的选择</h4><ul>
<li><strong>官方网站</strong>: <a target="_blank" rel="noopener" href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></li>
<li><strong>底层技术</strong>: 基于传统的<strong>阻塞式I&#x2F;O (BIO)</strong>，使用Java的<code>Socket</code>进行通信。</li>
<li><strong>核心特点</strong>:<ol>
<li><strong>同步阻塞 (Synchronous &amp; Blocking)</strong>: 这是Jedis最显著的特点。当你发送一个命令时，当前线程会<strong>阻塞</strong>，直到Redis服务器返回响应。这使得它的编程模型非常简单直观，易于理解。</li>
<li><strong>简单易用</strong>: API非常直接，几乎与Redis的原生命令一一对应。</li>
<li><strong>线程不安全</strong>: 一个Jedis连接实例<strong>不是线程安全的</strong>。因此，在多线程环境中，你<strong>必须</strong>使用连接池（如<code>JedisPool</code>），每个线程从池中获取自己的连接，使用完毕后归还。如果多个线程共享一个Jedis实例，会导致不可预知的数据错乱。</li>
</ol>
</li>
<li><strong>缺点</strong>:<ul>
<li><strong>性能瓶颈</strong>: 在高并发场景下，同步阻塞模型会导致大量线程被创建和阻塞，成为系统的性能瓶颈。</li>
<li><strong>不支持响应式</strong>: 由于其阻塞的特性，Jedis<strong>无法</strong>与Spring WebFlux等响应式框架协同工作。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-1-4-如何从Lettuce切换到Jedis？"><a href="#4-1-4-如何从Lettuce切换到Jedis？" class="headerlink" title="4.1.4 如何从Lettuce切换到Jedis？"></a>4.1.4 如何从Lettuce切换到Jedis？</h4><p>如果你因为特定原因（例如，需要兼容一些只支持Jedis的老代码或库）需要使用Jedis，切换过程也非常简单：</p>
<p><strong>Step 1: 修改<code>pom.xml</code></strong></p>
<ol>
<li>在 <code>spring-boot-starter-data-redis</code> 中<strong>排除</strong>默认的 <code>lettuce-core</code> 依赖。</li>
<li><strong>添加</strong> <code>jedis</code> 依赖。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Step 2: 修改<code>application.yml</code> (可选)</strong></p>
<p>将连接池的配置从<code>lettuce.pool</code>改为<code>jedis.pool</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment"># ... host, port等通用配置 ...</span></span><br><span class="line">    <span class="attr">jedis:</span> <span class="comment"># Jedis特有的连接池配置</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>Spring Boot的自动配置会检测到类路径下存在<code>Jedis</code>而没有<code>Lettuce</code>，于是会自动为你配置<code>JedisConnectionFactory</code>。你的上层业务代码（如使用<code>RedisTemplate</code>）<strong>无需做任何改动</strong>，这是Spring抽象的强大之处。</p>
<hr>
<h4 id="4-1-5-总结"><a href="#4-1-5-总结" class="headerlink" title="4.1.5 总结"></a>4.1.5 总结</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Lettuce (默认推荐)</th>
<th align="left">Jedis (传统选择)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>I&#x2F;O模型</strong></td>
<td align="left"><strong>异步非阻塞</strong> (基于Netty)</td>
<td align="left"><strong>同步阻塞</strong> (基于BIO Socket)</td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td align="left">连接是<strong>线程安全</strong>的，可多线程共享</td>
<td align="left">连接是<strong>非线程安全</strong>的，多线程必须使用连接池</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left"><strong>高</strong>。在高并发和响应式场景下表现优异。</td>
<td align="left"><strong>中等</strong>。在低并发下简单直接，高并发下会成为瓶颈。</td>
</tr>
<tr>
<td align="left"><strong>响应式支持</strong></td>
<td align="left"><strong>原生支持</strong>。是WebFlux的标配。</td>
<td align="left"><strong>不支持</strong>。无法用于响应式编程。</td>
</tr>
<tr>
<td align="left"><strong>资源消耗</strong></td>
<td align="left"><strong>低</strong>。可以用更少的线程处理更多请求。</td>
<td align="left"><strong>高</strong>。每个阻塞的请求都需要一个线程。</td>
</tr>
<tr>
<td align="left"><strong>编程模型</strong></td>
<td align="left">略复杂，但被Spring封装后变得简单。</td>
<td align="left">非常简单直观。</td>
</tr>
</tbody></table>
<p><strong>最终建议</strong>:</p>
<ul>
<li>对于<strong>所有新的Spring Boot项目</strong>，都应该<strong>坚持使用默认的Lettuce</strong>。它的性能优势、线程安全以及对未来响应式编程的支持，使其成为一个毫无疑问的更优选择。</li>
<li>只有在维护<strong>老的、已经在使用Jedis的项目</strong>，或者有<strong>强烈的理由</strong>（如需要与某些仅支持Jedis的第三方工具集成）时，才考虑切换到Jedis。</li>
</ul>
<hr>
<h3 id="4-2-RedisTemplate-vs-StringRedisTemplate"><a href="#4-2-RedisTemplate-vs-StringRedisTemplate" class="headerlink" title="4.2 RedisTemplate vs StringRedisTemplate"></a>4.2 <code>RedisTemplate</code> vs <code>StringRedisTemplate</code></h3><p>当你在Spring Boot项目中配置好Redis后，自动配置会为你创建并注册两个核心的模板类Bean：<code>RedisTemplate&lt;Object, Object&gt;</code> 和 <code>StringRedisTemplate</code>。它们都是对Redis命令的高度封装，提供了便捷的API来操作Redis中的各种数据结构。</p>
<p>它们最核心、最根本的区别在于<strong>序列化方式 (Serialization)</strong> 的不同。</p>
<hr>
<h4 id="4-2-1-RedisTemplate-通用的、面向对象的模板"><a href="#4-2-1-RedisTemplate-通用的、面向对象的模板" class="headerlink" title="4.2.1 RedisTemplate&lt;K, V&gt; - 通用的、面向对象的模板"></a>4.2.1 <code>RedisTemplate&lt;K, V&gt;</code> - 通用的、面向对象的模板</h4><ul>
<li><strong>泛型定义</strong>: <code>RedisTemplate&lt;K, V&gt;</code> 是一个泛型类，允许你指定键（Key）和值（Value）的类型。在Spring Boot自动配置中，默认创建的是 <code>RedisTemplate&lt;Object, Object&gt;</code>。</li>
<li><strong>核心特点：可定制的序列化</strong><ul>
<li><code>RedisTemplate</code> 为了能够处理<strong>任何类型的Java对象</strong>（如 <code>User</code>, <code>Product</code>, <code>List&lt;String&gt;</code> 等），必须对存入Redis的键和值进行<strong>序列化</strong>，将Java对象转换成二进制数据。</li>
<li><strong>默认序列化器</strong>: <code>JdkSerializationRedisSerializer</code>。<ul>
<li><strong>工作方式</strong>: 使用Java<strong>自带的序列化机制</strong> (<code>ObjectOutputStream</code>)。</li>
<li><strong>缺点</strong>:<ol>
<li><strong>可读性极差</strong>: 序列化后的结果是一串二进制数据，包含了类的信息、版本号等，在Redis客户端（如<code>redis-cli</code>）中查看时，会显示为乱码（如 <code>\xac\xed\x00\x05t\x00\x04user</code>）。</li>
<li><strong>跨语言不友好</strong>: 只有Java程序能够反序列化这些数据，其他语言（Python, Go, Node.js）的程序无法识别。</li>
<li><strong>占用空间较大</strong>: 存储了额外的元数据，比JSON等格式更占空间。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>适用场景</strong>:<ul>
<li>当你需要存储<strong>复杂的Java对象</strong>，并且<strong>只有Java应用</strong>会访问这些数据时。</li>
<li>在现代微服务架构中，由于其可读性和跨语言的弊端，<strong>默认的<code>JdkSerializationRedisSerializer</code>已不被推荐使用</strong>。</li>
</ul>
</li>
<li><strong>如何改进（最佳实践）</strong>:<br>为了解决上述缺点，我们通常会<strong>手动配置<code>RedisTemplate</code></strong>，将其默认的序列化器替换为<strong>更通用的格式</strong>，如 <strong>JSON</strong>。</li>
</ul>
<p><strong>自定义 <code>RedisTemplate</code> Bean配置示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建JSON序列化器</span></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建String序列化器</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 设置Key的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 设置Value的序列化方式</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置后的效果</strong>:</p>
<ul>
<li>当你使用这个自定义的 <code>redisTemplate</code> 存入一个 <code>User</code> 对象时，Redis中存储的将是<strong>可读的JSON字符串</strong>，如 <code>{&quot;id&quot;:1, &quot;name&quot;:&quot;Alice&quot;}</code>。</li>
<li>这样既保证了可读性，也实现了跨语言的兼容性。</li>
</ul>
<hr>
<h4 id="4-2-2-StringRedisTemplate-专用于字符串的模板"><a href="#4-2-2-StringRedisTemplate-专用于字符串的模板" class="headerlink" title="4.2.2 StringRedisTemplate - 专用于字符串的模板"></a>4.2.2 <code>StringRedisTemplate</code> - 专用于字符串的模板</h4><ul>
<li><p><strong>继承关系</strong>: <code>StringRedisTemplate extends RedisTemplate&lt;String, String&gt;</code>。</p>
</li>
<li><p><strong>核心特点：固定的字符串序列化</strong></p>
<ul>
<li>从它的继承关系就可以看出，<code>StringRedisTemplate</code> 是一个<strong>特化</strong>的<code>RedisTemplate</code>，它<strong>强制要求键（Key）和值（Value）都是 <code>String</code> 类型</strong>。</li>
<li>它内部<strong>固定使用 <code>StringRedisSerializer</code></strong> 来进行序列化。</li>
<li><code>StringRedisSerializer</code> 会将字符串按照指定的字符集（默认为UTF-8）转换为字节数组。</li>
</ul>
</li>
<li><p><strong>优点</strong>:</p>
<ol>
<li><strong>可读性最好</strong>: 存入Redis的数据就是你传入的原始字符串，在任何客户端中查看都非常直观。</li>
<li><strong>通用性最强</strong>: 字符串是所有编程语言都支持的最基本数据类型，跨语言交互毫无障碍。</li>
<li><strong>性能高</strong>: 字符串序列化比复杂的对象序列化更快。</li>
<li><strong>完美匹配Redis原生操作</strong>: 非常适合用来操作Redis中的字符串类型数据，以及对数字进行<code>incr</code>（自增）、<code>decr</code>（自减）等操作。</li>
</ol>
</li>
<li><p><strong>适用场景</strong>:</p>
<ul>
<li><p>当你的应用中，Redis主要用于存储<strong>简单的字符串键值对</strong>时，例如：</p>
<ul>
<li>缓存简单的文本信息、配置项。</li>
<li>存储Session ID。</li>
<li>实现分布式锁（锁的value通常是字符串）。</li>
<li>用作计数器（存储数字字符串）。</li>
</ul>
</li>
<li><p>当需要缓存<strong>JSON字符串</strong>时。你可以手动将Java对象序列化为JSON字符串，然后使用<code>StringRedisTemplate</code>存入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动序列化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">userJson</span> <span class="operator">=</span> objectMapper.writeValueAsString(user);</span><br><span class="line">stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:1&quot;</span>, userJson);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动反序列化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">storedJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> objectMapper.readValue(storedJson, User.class);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-2-3-总结"><a href="#4-2-3-总结" class="headerlink" title="4.2.3 总结"></a>4.2.3 总结</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>RedisTemplate&lt;Object, Object&gt;</code> (默认)</th>
<th align="left"><code>RedisTemplate&lt;String, Object&gt;</code> (自定义JSON序列化)</th>
<th align="left"><code>StringRedisTemplate</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>键(Key)类型</strong></td>
<td align="left"><code>Object</code></td>
<td align="left"><code>String</code></td>
<td align="left"><code>String</code></td>
</tr>
<tr>
<td align="left"><strong>值(Value)类型</strong></td>
<td align="left"><code>Object</code></td>
<td align="left"><code>Object</code></td>
<td align="left"><code>String</code></td>
</tr>
<tr>
<td align="left"><strong>序列化器</strong></td>
<td align="left"><code>JdkSerializationRedisSerializer</code></td>
<td align="left">Key: <code>StringRedisSerializer</code><br>Value: <code>Jackson2JsonRedisSerializer</code></td>
<td align="left">Key&#x2F;Value: <code>StringRedisSerializer</code></td>
</tr>
<tr>
<td align="left"><strong>Redis中存储格式</strong></td>
<td align="left"><strong>二进制乱码</strong></td>
<td align="left"><strong>可读的JSON字符串</strong></td>
<td align="left"><strong>原始字符串</strong></td>
</tr>
<tr>
<td align="left"><strong>跨语言兼容性</strong></td>
<td align="left"><strong>差</strong> (仅Java)</td>
<td align="left"><strong>好</strong></td>
<td align="left"><strong>极好</strong></td>
</tr>
<tr>
<td align="left"><strong>可读性</strong></td>
<td align="left"><strong>差</strong></td>
<td align="left"><strong>好</strong></td>
<td align="left"><strong>极好</strong></td>
</tr>
<tr>
<td align="left"><strong>使用便利性</strong></td>
<td align="left">直接存取Java对象，无需手动转换。</td>
<td align="left">直接存取Java对象，无需手动转换。</td>
<td align="left">只能存取字符串，存取对象需<strong>手动进行JSON转换</strong>。</td>
</tr>
<tr>
<td align="left"><strong>核心用途</strong></td>
<td align="left">存储任意Java对象（不推荐默认配置）</td>
<td align="left"><strong>推荐用于存储复杂Java对象作为缓存</strong></td>
<td align="left"><strong>推荐用于存储简单字符串、计数器、JSON字符串</strong></td>
</tr>
</tbody></table>
<p><strong>最终选择建议</strong>:</p>
<ol>
<li><strong>首选自定义的<code>RedisTemplate&lt;String, Object&gt;</code></strong>: 在大多数需要将<strong>Java对象</strong>作为整体进行缓存的场景中，配置一个使用JSON序列化器的<code>RedisTemplate</code>是<strong>最佳实践</strong>。它兼顾了使用的便利性（直接操作对象）和数据在Redis中的可读性&#x2F;通用性。</li>
<li><strong>使用<code>StringRedisTemplate</code>处理简单数据</strong>: 当你明确知道要处理的就是<strong>字符串</strong>、<strong>数字</strong>（作为字符串存储）或者需要<strong>手动控制JSON转换</strong>时，<code>StringRedisTemplate</code> 是最直接、最高效的选择。</li>
<li><strong>避免使用默认的<code>RedisTemplate&lt;Object, Object&gt;</code></strong>: 除非你的应用是一个与外界完全隔离的、纯Java的单体应用，并且你不在乎Redis中数据的可读性，否则应<strong>尽量避免</strong>使用其默认的JDK序列化方式。</li>
</ol>
<hr>
<h3 id="4-3-常用数据结构操作"><a href="#4-3-常用数据结构操作" class="headerlink" title="4.3 常用数据结构操作"></a>4.3 常用数据结构操作</h3><p>Redis之所以强大，不仅仅因为它是一个键值存储，更在于它为值（Value）提供了丰富的数据结构。Spring Data Redis 通过 <code>RedisTemplate</code> 提供了一系列的操作接口（Operations），使得我们可以用面向对象的方式来与这些数据结构交互，而无需记忆繁杂的Redis命令。</p>
<p><strong>获取操作接口</strong>:</p>
<p><code>RedisTemplate</code> 提供了一系列的 <code>opsFor...()</code> 方法来获取针对特定数据结构的操作接口：</p>
<ul>
<li><code>opsForValue()</code>: 操作 <strong>String (字符串)</strong></li>
<li><code>opsForHash()</code>: 操作 <strong>Hash (哈希&#x2F;散列)</strong></li>
<li><code>opsForList()</code>: 操作 <strong>List (列表)</strong></li>
<li><code>opsForSet()</code>: 操作 <strong>Set (集合)</strong></li>
<li><code>opsForZSet()</code>: 操作 <strong>ZSet (有序集合)</strong></li>
</ul>
<p>在下面的示例中，我们假设已经注入了<code>StringRedisTemplate</code>，因为它操作的结果在<code>redis-cli</code>中查看最直观。使用自定义JSON序列化的<code>RedisTemplate</code>在API调用上是完全一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisOperationService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 操作方法将在这里实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-1-String-字符串"><a href="#4-3-1-String-字符串" class="headerlink" title="4.3.1 String (字符串)"></a>4.3.1 String (字符串)</h4><p>这是最简单的数据结构，一个key对应一个string value。</p>
<ul>
<li><strong>用途</strong>: 缓存用户信息JSON、存储配置、计数器、分布式锁等。</li>
<li><strong>操作接口</strong>: <code>ValueOperations&lt;String, String&gt;</code> (通过 <code>stringRedisTemplate.opsForValue()</code>)</li>
</ul>
<p><strong>常用方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">    ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 设置键值 (SET key value)</span></span><br><span class="line">    ops.set(<span class="string">&quot;user:1:name&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置键值并带过期时间 (SETEX key seconds value)</span></span><br><span class="line">    ops.set(<span class="string">&quot;sms:code:138xxxx&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取键值 (GET key)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ops.get(<span class="string">&quot;user:1:name&quot;</span>); <span class="comment">// &quot;Alice&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 获取多个键值 (MGET key1 key2 ...)</span></span><br><span class="line">    List&lt;String&gt; values = ops.multiGet(Arrays.asList(<span class="string">&quot;user:1:name&quot;</span>, <span class="string">&quot;another_key&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 原子性自增 (INCR key) - 值必须是数字字符串</span></span><br><span class="line">    ops.set(<span class="string">&quot;page:view:1001&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    ops.increment(<span class="string">&quot;page:view:1001&quot;</span>); <span class="comment">// 返回 1</span></span><br><span class="line">    ops.increment(<span class="string">&quot;page:view:1001&quot;</span>, <span class="number">10</span>); <span class="comment">// 增加10，返回 11</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 原子性自减 (DECR key)</span></span><br><span class="line">    ops.decrement(<span class="string">&quot;page:view:1001&quot;</span>); <span class="comment">// 返回 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-2-Hash-哈希"><a href="#4-3-2-Hash-哈希" class="headerlink" title="4.3.2 Hash (哈希)"></a>4.3.2 Hash (哈希)</h4><p>一个key对应一个<code>Map&lt;String, String&gt;</code>，非常适合用来存储一个<strong>对象</strong>的多个字段。</p>
<ul>
<li><strong>用途</strong>: 存储一个用户的多个属性（姓名、年龄、邮箱），避免为每个属性都创建一个顶层key。</li>
<li><strong>操作接口</strong>: <code>HashOperations&lt;String, HK, HV&gt;</code> (通过 <code>stringRedisTemplate.opsForHash()</code>)</li>
</ul>
<p><strong>常用方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    HashOperations&lt;String, String, String&gt; ops = stringRedisTemplate.opsForHash();</span><br><span class="line">    <span class="type">String</span> <span class="variable">userKey</span> <span class="operator">=</span> <span class="string">&quot;user:profile:1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 设置单个字段值 (HSET key field value)</span></span><br><span class="line">    ops.put(userKey, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    ops.put(userKey, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;30&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 一次性设置多个字段值 (HMSET key field1 value1 ...)</span></span><br><span class="line">    Map&lt;String, String&gt; userFields = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    userFields.put(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;bob@example.com&quot;</span>);</span><br><span class="line">    userFields.put(<span class="string">&quot;city&quot;</span>, <span class="string">&quot;New York&quot;</span>);</span><br><span class="line">    ops.putAll(userKey, userFields);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取单个字段值 (HGET key field)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ops.get(userKey, <span class="string">&quot;name&quot;</span>); <span class="comment">// &quot;Bob&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 获取多个字段值 (HMGET key field1 field2 ...)</span></span><br><span class="line">    List&lt;String&gt; fields = ops.multiGet(userKey, Arrays.asList(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;city&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 获取所有字段和值 (HGETALL key)</span></span><br><span class="line">    Map&lt;String, String&gt; allFields = ops.entries(userKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 删除一个或多个字段 (HDEL key field1 ...)</span></span><br><span class="line">    ops.delete(userKey, <span class="string">&quot;city&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 判断字段是否存在 (HEXISTS key field)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> ops.hasKey(userKey, <span class="string">&quot;email&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-3-List-列表"><a href="#4-3-3-List-列表" class="headerlink" title="4.3.3 List (列表)"></a>4.3.3 List (列表)</h4><p>一个key对应一个<strong>有序的、可重复的</strong>字符串列表。它是一个双向链表，所以在两端添加和删除元素非常快。</p>
<ul>
<li><strong>用途</strong>: 实现消息队列（生产者LPUSH，消费者BRPOP）、存储文章的评论列表、最新动态列表。</li>
<li><strong>操作接口</strong>: <code>ListOperations&lt;String, String&gt;</code> (通过 <code>stringRedisTemplate.opsForList()</code>)</li>
</ul>
<p><strong>常用方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span> &#123;</span><br><span class="line">    ListOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForList();</span><br><span class="line">    <span class="type">String</span> <span class="variable">tasksKey</span> <span class="operator">=</span> <span class="string">&quot;tasks:queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 从左侧推入元素 (LPUSH key value1 [value2 ...])</span></span><br><span class="line">    ops.leftPush(tasksKey, <span class="string">&quot;Task A&quot;</span>);</span><br><span class="line">    ops.leftPushAll(tasksKey, <span class="string">&quot;Task B&quot;</span>, <span class="string">&quot;Task C&quot;</span>); <span class="comment">// 现在的顺序: C, B, A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从右侧推入元素 (RPUSH key value1 [value2 ...])</span></span><br><span class="line">    ops.rightPush(tasksKey, <span class="string">&quot;Task D&quot;</span>); <span class="comment">// 现在的顺序: C, B, A, D</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 从左侧弹出元素 (LPOP key)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">task</span> <span class="operator">=</span> ops.leftPop(tasksKey); <span class="comment">// &quot;C&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 从右侧弹出元素 (RPOP key)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lastTask</span> <span class="operator">=</span> ops.rightPop(tasksKey); <span class="comment">// &quot;D&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 阻塞式地从左侧弹出元素 (BLPOP key timeout) - 消息队列核心</span></span><br><span class="line">    <span class="comment">// 如果列表为空，会阻塞等待最多10秒，直到有新元素或超时</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">blockingTask</span> <span class="operator">=</span> ops.leftPop(tasksKey, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 获取列表长度 (LLEN key)</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> ops.size(tasksKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 获取指定范围的元素 (LRANGE key start stop) - 0是第一个，-1是最后一个</span></span><br><span class="line">    List&lt;String&gt; allTasks = ops.range(tasksKey, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-4-Set-集合"><a href="#4-3-4-Set-集合" class="headerlink" title="4.3.4 Set (集合)"></a>4.3.4 Set (集合)</h4><p>一个key对应一个<strong>无序的、唯一的</strong>字符串集合。</p>
<ul>
<li><strong>用途</strong>: 存储一篇文章的点赞用户ID、一个用户的标签、共同好友计算。</li>
<li><strong>操作接口</strong>: <code>SetOperations&lt;String, String&gt;</code> (通过 <code>stringRedisTemplate.opsForSet()</code>)</li>
</ul>
<p><strong>常用方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> &#123;</span><br><span class="line">    SetOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForSet();</span><br><span class="line">    <span class="type">String</span> <span class="variable">post1Likes</span> <span class="operator">=</span> <span class="string">&quot;post:1:likes&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">post2Likes</span> <span class="operator">=</span> <span class="string">&quot;post:2:likes&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 添加一个或多个成员 (SADD key member1 [member2 ...])</span></span><br><span class="line">    ops.add(post1Likes, <span class="string">&quot;user:101&quot;</span>, <span class="string">&quot;user:102&quot;</span>, <span class="string">&quot;user:103&quot;</span>);</span><br><span class="line">    ops.add(post2Likes, <span class="string">&quot;user:102&quot;</span>, <span class="string">&quot;user:104&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取所有成员 (SMEMBERS key)</span></span><br><span class="line">    Set&lt;String&gt; members = ops.members(post1Likes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 判断成员是否存在 (SISMEMBER key member)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> ops.isMember(post1Likes, <span class="string">&quot;user:101&quot;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 获取集合大小 (SCARD key)</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> ops.size(post1Likes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 移除一个或多个成员 (SREM key member1 ...)</span></span><br><span class="line">    ops.remove(post1Likes, <span class="string">&quot;user:103&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 集合运算</span></span><br><span class="line">    <span class="comment">// 交集 (SINTER key1 key2): 同时点赞了文章1和文章2的用户</span></span><br><span class="line">    Set&lt;String&gt; intersection = ops.intersect(post1Likes, post2Likes); <span class="comment">// &#123;&quot;user:102&quot;&#125;</span></span><br><span class="line">    <span class="comment">// 并集 (SUNION key1 key2): 至少点赞了一篇文章的用户</span></span><br><span class="line">    Set&lt;String&gt; union = ops.union(post1Likes, post2Likes);</span><br><span class="line">    <span class="comment">// 差集 (SDIFF key1 key2): 点赞了文章1但没点赞文章2的用户</span></span><br><span class="line">    Set&lt;String&gt; difference = ops.difference(post1Likes, post2Likes); <span class="comment">// &#123;&quot;user:101&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-5-ZSet-有序集合"><a href="#4-3-5-ZSet-有序集合" class="headerlink" title="4.3.5 ZSet (有序集合)"></a>4.3.5 ZSet (有序集合)</h4><p>ZSet (Sorted Set) 是Set的升级版，它在每个成员上关联了一个<strong>分数 (score)</strong>，并根据这个分数对成员进行<strong>排序</strong>。成员是唯一的，但分数可以重复。</p>
<ul>
<li><strong>用途</strong>: 排行榜（按分数排序）、带有权重的任务队列、范围查找（如查找分数在某个区间的成员）。</li>
<li><strong>操作接口</strong>: <code>ZSetOperations&lt;String, String&gt;</code> (通过 <code>stringRedisTemplate.opsForZSet()</code>)</li>
</ul>
<p><strong>常用方法</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZSet</span><span class="params">()</span> &#123;</span><br><span class="line">    ZSetOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForZSet();</span><br><span class="line">    <span class="type">String</span> <span class="variable">leaderboardKey</span> <span class="operator">=</span> <span class="string">&quot;game:leaderboard&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 添加成员并指定分数 (ZADD key score1 member1 [score2 member2 ...])</span></span><br><span class="line">    ops.add(leaderboardKey, <span class="string">&quot;player:alice&quot;</span>, <span class="number">1500.0</span>);</span><br><span class="line">    ops.add(leaderboardKey, <span class="string">&quot;player:bob&quot;</span>, <span class="number">1800.0</span>);</span><br><span class="line">    ops.add(leaderboardKey, <span class="string">&quot;player:charlie&quot;</span>, <span class="number">1200.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 为成员增加分数 (ZINCRBY key increment member)</span></span><br><span class="line">    ops.incrementScore(leaderboardKey, <span class="string">&quot;player:alice&quot;</span>, <span class="number">50.0</span>); <span class="comment">// Alice的分数变为1550</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取指定成员的分数 (ZSCORE key member)</span></span><br><span class="line">    <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> ops.score(leaderboardKey, <span class="string">&quot;player:bob&quot;</span>); <span class="comment">// 1800.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 按分数范围获取成员 (ZRANGEBYSCORE key min max)</span></span><br><span class="line">    Set&lt;String&gt; players = ops.rangeByScore(leaderboardKey, <span class="number">1500</span>, <span class="number">2000</span>); <span class="comment">// &#123;&quot;player:alice&quot;, &quot;player:bob&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 按排名范围获取成员 (ZRANGE key start stop) - 分数从低到高</span></span><br><span class="line">    Set&lt;String&gt; top3Asc = ops.range(leaderboardKey, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// Charlie, Alice, Bob</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 按排名范围获取成员 (ZREVRANGE key start stop) - 分数从高到低</span></span><br><span class="line">    Set&lt;String&gt; top3Desc = ops.reverseRange(leaderboardKey, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// Bob, Alice, Charlie</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 获取成员的排名 (ZRANK / ZREVRANK)</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">rank</span> <span class="operator">=</span> ops.rank(leaderboardKey, <span class="string">&quot;player:alice&quot;</span>); <span class="comment">// 1 (从0开始，升序排名)</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">reverseRank</span> <span class="operator">=</span> ops.reverseRank(leaderboardKey, <span class="string">&quot;player:alice&quot;</span>); <span class="comment">// 1 (从0开始，降序排名)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 8. 获取集合大小 (ZCARD key)</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">size</span> <span class="operator">=</span> ops.size(leaderboardKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-4-SpringCache抽象与Redis实现"><a href="#4-4-SpringCache抽象与Redis实现" class="headerlink" title="4.4 SpringCache抽象与Redis实现"></a>4.4 SpringCache抽象与Redis实现</h3><h4 id="4-4-1-什么是-Spring-Cache-抽象？"><a href="#4-4-1-什么是-Spring-Cache-抽象？" class="headerlink" title="4.4.1 什么是 Spring Cache 抽象？"></a>4.4.1 什么是 Spring Cache 抽象？</h4><p><strong>问题背景</strong>：<br>在应用中，对于那些<strong>读多写少</strong>、<strong>计算成本高</strong>且<strong>数据不经常变化</strong>的操作（例如，从数据库查询商品详情、计算复杂的报表），我们通常会引入<strong>缓存</strong>来提升性能和降低后端负载。</p>
<p><strong>传统的缓存实现方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Service层手动编写缓存逻辑</span></span><br><span class="line"><span class="keyword">public</span> Product <span class="title function_">getProductById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 先从缓存中查找</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> cacheManager.get(<span class="string">&quot;productCache&quot;</span>, id);</span><br><span class="line">    <span class="keyword">if</span> (product != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> product; <span class="comment">// 缓存命中，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 缓存未命中，从数据库查询</span></span><br><span class="line">    product = productRepository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将查询结果放入缓存</span></span><br><span class="line">    <span class="keyword">if</span> (product != <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheManager.put(<span class="string">&quot;productCache&quot;</span>, id, product);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这种方式的痛点</strong>:</p>
<ol>
<li><strong>代码侵入性强</strong>: 缓存逻辑（<code>get</code>, <code>put</code>, <code>evict</code>）与业务逻辑<strong>高度耦合</strong>，混杂在一起，使得业务代码变得复杂和不纯粹。</li>
<li><strong>重复劳动</strong>: 每个需要缓存的方法都得写一遍类似的逻辑。</li>
<li><strong>缓存技术更换困难</strong>: 如果想从 Guava Cache 换成 Redis Cache，你需要修改所有相关的业务代码。</li>
</ol>
<p><strong>Spring Cache 抽象的解决方案</strong>:<br>Spring Cache 提供了一套<strong>基于注解</strong>的、<strong>与具体缓存技术无关</strong>的抽象层。它的核心思想是：</p>
<ul>
<li><strong>将缓存操作声明化</strong>: 开发者不再需要手动编写缓存的读写逻辑，而是通过在方法上添加简单的注解（如 <code>@Cacheable</code>），来**“声明”**这个方法的缓存行为。</li>
<li><strong>AOP实现</strong>: Spring 在底层通过**AOP（面向切面编程）**来拦截这些被注解标记的方法调用。<ul>
<li>在方法<strong>执行前</strong>，AOP切面会先检查缓存。如果命中，则直接返回缓存结果，<strong>不再执行</strong>方法体。</li>
<li>如果缓存未命中，AOP切面会<strong>执行</strong>方法体，获取返回值，然后在方法<strong>返回后</strong>，自动将结果放入缓存。</li>
</ul>
</li>
<li><strong>技术无关性</strong>: 你的业务代码只依赖于Spring Cache的注解，而<strong>不关心底层到底是用Redis、Caffeine、EhCache还是ConcurrentHashMap</strong>。底层的缓存实现是可插拔的，通过配置文件即可轻松切换。</li>
</ul>
<p><strong>最终效果</strong>: 业务代码回归纯粹，缓存逻辑被优雅地分离出去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务代码变得极其简洁</span></span><br><span class="line"><span class="meta">@Cacheable(cacheNames = &quot;productCache&quot;, key = &quot;#id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Product <span class="title function_">getProductById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 只需要保留核心的业务逻辑</span></span><br><span class="line">    <span class="keyword">return</span> productRepository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-4-2-核心注解"><a href="#4-4-2-核心注解" class="headerlink" title="4.4.2 核心注解"></a>4.4.2 核心注解</h4><p>Spring Cache 主要通过以下三个注解来工作：</p>
<ul>
<li><p><strong><code>@Cacheable</code></strong>: <strong>触发缓存入口</strong></p>
<ul>
<li><strong>作用</strong>: 主要用于<strong>查询</strong>操作。标记在一个方法上，表示该方法的执行结果是可以被缓存的。</li>
<li><strong>执行流程</strong>:<ol>
<li>方法调用前，根据 <code>cacheNames</code> 和 <code>key</code> 生成一个缓存键。</li>
<li>用这个键去缓存中查找。</li>
<li><strong>如果找到</strong>，直接返回缓存的值，<strong>方法体不会被执行</strong>。</li>
<li><strong>如果没找到</strong>，执行方法体，将方法的返回值存入缓存，然后再返回结果。</li>
</ol>
</li>
<li><strong>常用属性</strong>:<ul>
<li><code>cacheNames</code> &#x2F; <code>value</code>: 指定要使用的缓存区域的名称（可以有多个）。</li>
<li><code>key</code>: <strong>缓存的键</strong>。支持 <strong>SpEL (Spring Expression Language)</strong> 来动态生成。<ul>
<li><code>#id</code>: 引用方法参数 <code>id</code>。</li>
<li><code>#p0</code>, <code>#a0</code>: 引用第一个方法参数。</li>
<li><code>#result</code>: 引用方法的返回值（通常用于<code>@CachePut</code>）。</li>
<li><code>#root.methodName</code>: 引用当前方法名。</li>
<li>如果<strong>不指定</strong>，Spring会使用所有方法参数的 <code>hashCode</code> 生成一个默认的key。</li>
</ul>
</li>
<li><code>condition</code>: SpEL表达式，满足条件时才进行缓存。例如 <code>condition = &quot;#result != null&quot;</code>。</li>
<li><code>unless</code>: SpEL表达式，满足条件时<strong>不</strong>进行缓存。例如 <code>unless = &quot;#result.price &lt; 100&quot;</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>@CachePut</code></strong>: <strong>强制更新缓存</strong></p>
<ul>
<li><strong>作用</strong>: 主要用于<strong>更新</strong>操作。</li>
<li><strong>执行流程</strong>: 与 <code>@Cacheable</code> 不同，<code>@CachePut</code> <strong>总是会执行方法体</strong>。在方法执行成功后，它会<strong>强制</strong>将方法的返回值更新到缓存中。</li>
<li><strong>场景</strong>: 当你更新了数据库中的某个对象，并希望<strong>同步更新</strong>缓存中的数据时使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CachePut(cacheNames = &quot;productCache&quot;, key = &quot;#product.id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Product <span class="title function_">updateProduct</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> productRepository.save(product); <span class="comment">// save方法会返回更新后的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@CacheEvict</code></strong>: <strong>清空缓存</strong></p>
<ul>
<li><strong>作用</strong>: 主要用于<strong>删除</strong>操作。</li>
<li><strong>执行流程</strong>: 方法执行后，会从缓存中<strong>移除</strong>指定的数据。</li>
<li><strong>常用属性</strong>:<ul>
<li><code>cacheNames</code>, <code>key</code>: 指定要移除的缓存项。</li>
<li><code>allEntries = true</code>: 如果设置为 <code>true</code>，则会清空整个 <code>cacheNames</code> 区域的所有缓存，而不是只移除单个key。</li>
<li><code>beforeInvocation = true</code>: 默认是 <code>false</code> (方法执行后清除)。如果设为 <code>true</code>，则在方法执行前就清除缓存，这在方法可能抛出异常的情况下可以保证缓存一定被清除。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheEvict(cacheNames = &quot;productCache&quot;, key = &quot;#id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteProduct</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    productRepository.deleteById(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空所有productCache</span></span><br><span class="line"><span class="meta">@CacheEvict(cacheNames = &quot;productCache&quot;, allEntries = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reloadAllProducts</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... 重新加载数据的逻辑 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-4-3-使用Redis作为缓存实现"><a href="#4-4-3-使用Redis作为缓存实现" class="headerlink" title="4.4.3 使用Redis作为缓存实现"></a>4.4.3 使用Redis作为缓存实现</h4><p>将Spring Cache的后端从默认的 <code>ConcurrentHashMap</code> 切换为 Redis 非常简单。</p>
<p><strong>Step 1: 添加 <code>spring-boot-starter-data-redis</code> 依赖</strong></p>
<p>(这在之前的章节已经做过)</p>
<p><strong>Step 2: 在启动类上开启缓存功能</strong></p>
<p>在你的Spring Boot主启动类上添加 <code>@EnableCaching</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span> <span class="comment">// 开启Spring Cache的注解功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Step 3: 配置 <code>application.yml</code></strong></p>
<p>告诉Spring Boot我们希望使用Redis作为缓存类型。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># ... redis 连接配置 ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span> <span class="comment"># 指定缓存类型为Redis</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="string">600s</span> <span class="comment"># 全局设置缓存的默认过期时间为10分钟</span></span><br><span class="line">      <span class="comment"># key-prefix: myapp:cache: # （可选）为所有缓存键添加一个公共前缀</span></span><br><span class="line">      <span class="comment"># use-key-prefix: true</span></span><br><span class="line">      <span class="comment"># cache-null-values: false # （可选）是否缓存null值，默认为true</span></span><br></pre></td></tr></table></figure>

<p><strong>完成！</strong> Spring Boot的自动配置会检测到 <code>spring.cache.type=redis</code>，然后自动为你配置好一个 <code>RedisCacheManager</code> Bean。现在，你所有的 <code>@Cacheable</code> 等注解就会自动地将数据存入Redis，而不是内存。</p>
<hr>
<h4 id="4-4-4-序列化问题与解决方案"><a href="#4-4-4-序列化问题与解决方案" class="headerlink" title="4.4.4 序列化问题与解决方案"></a>4.4.4 序列化问题与解决方案</h4><p>默认情况下，Spring Cache使用Redis时，会使用 <code>RedisTemplate&lt;Object, Object&gt;</code> 的默认JDK序列化方式。这会导致你在Redis中看到的是<strong>乱码</strong>。</p>
<p>为了解决这个问题，我们需要像之前一样，自定义一个 <code>RedisCacheManager</code> Bean，并为其配置<strong>JSON序列化</strong>。</p>
<p><strong>自定义 <code>RedisCacheManager</code> 配置示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个默认的缓存配置</span></span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">defaultCacheConfig</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                <span class="comment">// 2. 设置key的序列化方式为String</span></span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>()))</span><br><span class="line">                <span class="comment">// 3. 设置value的序列化方式为JSON</span></span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>()))</span><br><span class="line">                <span class="comment">// 4. 设置默认的过期时间</span></span><br><span class="line">                .entryTtl(Duration.ofMinutes(<span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. （可选）为特定的cacheName设置不同的过期时间</span></span><br><span class="line">        <span class="comment">// Map&lt;String, RedisCacheConfiguration&gt; cacheConfigurations = new HashMap&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// cacheConfigurations.put(&quot;userCache&quot;, defaultCacheConfig.entryTtl(Duration.ofHours(1)));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 创建RedisCacheManager</span></span><br><span class="line">        <span class="keyword">return</span> RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(defaultCacheConfig)</span><br><span class="line">                <span class="comment">// .withInitialCacheConfigurations(cacheConfigurations)</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这个配置后，所有通过Spring Cache存入Redis的数据，其值都会是<strong>可读的JSON格式</strong>，大大提升了可维护性和调试便利性。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/10/05/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringWeb/" rel="prev" title="Spring全家桶-SpringWeb">
                  <i class="fa fa-angle-left"></i> Spring全家桶-SpringWeb
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/10/06/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%94%9F%E6%80%81/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6-SpringSecurity/" rel="next" title="Spring全家桶-SpringSecurity">
                  Spring全家桶-SpringSecurity <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
