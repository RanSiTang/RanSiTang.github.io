<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="冉的技术宝典">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="冉的技术宝典">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="冉丝堂">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>冉的技术宝典</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.10.1/mermaid.min.js","integrity":"sha256-BmQmdWDS8X2OTbrwELWK366LV6escyWhHHe0XCTU/Hk="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">冉的技术宝典</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">冉丝堂</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%B8%89%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%B8%89%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">三、面向对象编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-06 18:10:00" itemprop="dateCreated datePublished" datetime="2025-09-06T18:10:00+08:00">2025-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 11:08:15" itemprop="dateModified" datetime="2025-10-17T11:08:15+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/" itemprop="url" rel="index"><span itemprop="name">基础核心层</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="三、面向对象编程"><a href="#三、面向对象编程" class="headerlink" title="三、面向对象编程"></a>三、面向对象编程</h1><h2 id="1-核心思想与基础概念"><a href="#1-核心思想与基础概念" class="headerlink" title="1. 核心思想与基础概念"></a>1. 核心思想与基础概念</h2><h3 id="1-1-面向过程和面向对象"><a href="#1-1-面向过程和面向对象" class="headerlink" title="1.1 面向过程和面向对象"></a>1.1 面向过程和面向对象</h3><ul>
<li><strong>面向过程 (POP - Procedure-Oriented Programming)</strong>：<strong>关注的是“怎么做”</strong>。就像一份<strong>菜谱</strong>，它详细记录了做一道菜的每一个步骤：第一步洗菜，第二步切菜，第三步热油，第四步下锅翻炒… 你按照线性的步骤一步一步执行，最终得到结果。<ul>
<li><strong>焦点</strong>：<strong>步骤（过程&#x2F;函数）</strong></li>
<li><strong>思维</strong>：“我先做什么，再做什么，然后做什么？”</li>
</ul>
</li>
<li><strong>面向对象 (OOP - Object-Oriented Programming)</strong>：<strong>关注的是“谁来做”</strong>。就像<strong>开一家餐厅</strong>。你不需要关心一道菜具体怎么炒（过程），你关心的是餐厅里有哪些角色：厨师、服务员、收银员、厨师长。你给每个角色分配任务：厨师负责做菜，服务员负责点菜和上菜，收银员负责收款。这些角色各司其职，通过互相协作来完成整个业务流程。<ul>
<li><strong>焦点</strong>：<strong>对象（类和对象）</strong></li>
<li><strong>思维</strong>：“我需要哪些对象？这些对象有什么属性和能力？对象之间如何交互？”</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">面向过程 (POP)</th>
<th align="left">面向对象 (OOP)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心思想</strong></td>
<td align="left">以<strong>函数</strong>为中心，强调步骤和过程。</td>
<td align="left">以<strong>对象</strong>为中心，强调具备属性和行为的实体。</td>
</tr>
<tr>
<td align="left"><strong>程序组成</strong></td>
<td align="left">一系列的函数&#x2F;方法。数据与函数是分离的。</td>
<td align="left">一系列相互作用的对象。数据与操作数据的方法被捆绑在一起。</td>
</tr>
<tr>
<td align="left"><strong>数据与函数</strong></td>
<td align="left"><strong>数据</strong>和<strong>处理数据的函数</strong>是分离的。</td>
<td align="left"><strong>数据</strong>和<strong>处理数据的函数（方法）</strong> 被封装在对象中。</td>
</tr>
<tr>
<td align="left"><strong>三大特性</strong></td>
<td align="left">不支持继承、多态，封装性也较差。</td>
<td align="left">支持<strong>封装、继承、多态</strong>，大大提升了代码的灵活性。</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left">数据是全局的或传递的，任何函数都可以修改，安全性低。</td>
<td align="left">数据被封装在对象内部，通过接口访问，安全性高。</td>
</tr>
<tr>
<td align="left"><strong>代码复用</strong></td>
<td align="left">主要通过<strong>函数</strong>来复用代码。</td>
<td align="left">主要通过<strong>类（Class）</strong> 和<strong>继承（Inheritance）</strong> 来复用代码。</td>
</tr>
<tr>
<td align="left"><strong>设计思维</strong></td>
<td align="left"><strong>自顶向下</strong>、逐步求精。先设计主流程，再分解为小函数。</td>
<td align="left"><strong>自底向上</strong>。先抽象出各种类和对象，再让它们协作完成功能。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">性能要求极高的场景（如单片机、内核）、简单的脚本或工具。</td>
<td align="left">大型复杂系统、需要频繁迭代和维护的业务系统、GUI应用等。</td>
</tr>
<tr>
<td align="left"><strong>优点</strong></td>
<td align="left">性能通常更高，流程直接清晰，适合简单问题。</td>
<td align="left">易维护、易扩展、易复用，更接近现实世界，适合复杂问题。</td>
</tr>
<tr>
<td align="left"><strong>缺点</strong></td>
<td align="left">难以应对复杂需求，代码维护和扩展困难，耦合度高。</td>
<td align="left">性能相对较低（但现代硬件差距已很小），学习曲线稍陡。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-2-类和对象"><a href="#1-2-类和对象" class="headerlink" title="1.2 类和对象"></a>1.2 类和对象</h3><p><strong>类</strong>：是对一类具有相同属性和行为的对象的抽象描述。它是一种<strong>自定义的数据类型</strong>。</p>
<ul>
<li><strong>属性 (成员变量 Field)</strong>：对象具有的各种特征。例如：一个人的年龄、姓名；一部手机的品牌、颜色。</li>
<li><strong>行为 (成员方法 Method)</strong>：对象能够执行的操作。例如：人可以吃饭、睡觉；手机可以打电话、玩游戏。</li>
</ul>
<p><strong>对象</strong>：是根据类这个模板创建出来的一个<strong>具体的、唯一的实例</strong>。创建对象的过程也叫<strong>实例化</strong>。</p>
<ul>
<li>每个对象都拥有其所属类中定义的属性和行为，但每个对象的属性值（<strong>状态</strong>）是独立的。</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义一个「类」，作为蓝图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123; <span class="comment">// 类名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性/成员变量 (描述状态)</span></span><br><span class="line">    String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="type">int</span> age;     <span class="comment">// 年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 行为/成员方法 (描述能做什么)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, my name is &quot;</span> + name + <span class="string">&quot;. I&#x27;m &quot;</span> + age + <span class="string">&quot; years old.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建并使用「对象」</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 &#x27;new&#x27; 关键字实例化对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// person1 是一个对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// person2 是另一个独立的对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为对象的属性赋值</span></span><br><span class="line">        person1.name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">        person1.age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">        person2.name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">        person2.age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用对象的方法</span></span><br><span class="line">        person1.sayHello(); <span class="comment">// 输出: Hello, my name is Alice. I&#x27;m 25 years old.</span></span><br><span class="line">        person2.sayHello(); <span class="comment">// 输出: Hello, my name is Bob. I&#x27;m 30 years old.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h2 id="2-核心特性"><a href="#2-核心特性" class="headerlink" title="2. 核心特性"></a>2. 核心特性</h2><h3 id="2-1-封装"><a href="#2-1-封装" class="headerlink" title="2.1 封装"></a>2.1 封装</h3><p><strong>隐藏对象的内部实现细节，仅对外提供公开的访问接口。</strong></p>
<h4 id="2-2-1-目的"><a href="#2-2-1-目的" class="headerlink" title="2.2.1 目的"></a>2.2.1 目的</h4><ol>
<li><strong>保证数据安全</strong>：防止对象的数据被意外或恶意地错误修改和访问。</li>
<li><strong>隐藏实现细节</strong>：类的内部实现可以自由改变，而不会影响使用该类的其他代码。只要公共接口保持不变，一切外部调用都能正常工作。</li>
<li><strong>提高代码可维护性</strong>：将数据和操作数据的方法绑定在一起，使得代码模块化程度更高，更容易理解和调试。</li>
</ol>
<hr>
<h4 id="2-2-2-实现方式（标准的JavaBean）"><a href="#2-2-2-实现方式（标准的JavaBean）" class="headerlink" title="2.2.2. 实现方式（标准的JavaBean）"></a>2.2.2. 实现方式（标准的JavaBean）</h4><ul>
<li>类名见名知意</li>
<li>成员变量使用<strong>private</strong>修饰</li>
<li>提供至少两个构造方法<ul>
<li>无参构造</li>
<li>带全部参数的有参构造</li>
</ul>
</li>
<li>成员方法：提供每个成员变量对应的setXxx()&#x2F;getXxx()</li>
</ul>
<hr>
<h3 id="2-2-继承"><a href="#2-2-继承" class="headerlink" title="2.2 继承"></a>2.2 继承</h3><h4 id="2-2-1-核心思想"><a href="#2-2-1-核心思想" class="headerlink" title="2.2.1 核心思想"></a>2.2.1 核心思想</h4><p><strong>基于已存在的类创建新类的过程。新类（子类）继承父类的属性和方法，并可以扩展新的属性和方法。</strong></p>
<p>继承描述的是“is-a”（是一个）的关系。例如，<code>Dog</code> (子类) <code>is an</code> <code>Animal</code> (父类)。</p>
<hr>
<h4 id="2-2-2-目的"><a href="#2-2-2-目的" class="headerlink" title="2.2.2 目的"></a>2.2.2 目的</h4><ol>
<li><strong>代码复用</strong>：子类可以直接使用父类非私有的属性和方法，无需重复编写。</li>
<li><strong>扩展功能</strong>：子类可以添加新的属性和方法，也可以<strong>重写</strong>父类的方法来改变其行为。</li>
<li><strong>为多态提供前提</strong>：多态的实现依赖于继承。</li>
</ol>
<hr>
<h4 id="2-2-3-实现方式"><a href="#2-2-3-实现方式" class="headerlink" title="2.2.3 实现方式"></a>2.2.3 实现方式</h4><ul>
<li>通过 <code>extends</code> 关键字实现单继承（Java 不支持多继承，但支持多重继承和接口实现）。</li>
<li>子类对象可以访问父类的 <code>public</code> 和 <code>protected</code> 成员。</li>
<li>子类<strong>不能继承</strong>父类的 <code>private</code> 成员和构造方法，但可以通过公共的 <code>getter/setter</code> 间接访问 <code>private</code> 属性。</li>
<li>可以使用 <code>super</code> 关键字来引用父类的成员（属性、方法、构造器）。</li>
</ul>
<hr>
<h4 id="2-2-4-代码示例"><a href="#2-2-4-代码示例" class="headerlink" title="2.2.4 代码示例"></a>2.2.4 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类（基类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name; <span class="comment">// protected，子类可以访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is sleeping.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类（派生类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123; <span class="comment">// 使用 extends 继承</span></span><br><span class="line">    <span class="keyword">private</span> String breed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, String breed)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 使用 super 调用父类构造器</span></span><br><span class="line">        <span class="built_in">this</span>.breed = breed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展的新方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; (a &quot;</span> + breed + <span class="string">&quot;) says: Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写（Override）父类方法：改变行为</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; the dog is gobbling down its food.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Buddy&quot;</span>, <span class="string">&quot;Golden Retriever&quot;</span>);</span><br><span class="line">        myDog.eat();    <span class="comment">// 调用的是子类重写后的方法</span></span><br><span class="line">        myDog.sleep();  <span class="comment">// 调用从父类继承来的方法</span></span><br><span class="line">        myDog.bark();   <span class="comment">// 调用子类自己的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-多态"><a href="#2-3-多态" class="headerlink" title="2.3 多态"></a>2.3 多态</h3><h4 id="2-3-1-核心思想"><a href="#2-3-1-核心思想" class="headerlink" title="2.3.1 核心思想"></a>2.3.1 核心思想</h4><p><strong>同一操作作用于不同的对象，可以产生不同的执行结果。</strong></p>
<p>更通俗地说：<strong>父类引用可以指向子类对象，且该引用在调用方法时，实际执行的是子类重写后的方法。</strong></p>
<hr>
<h4 id="2-3-2-目的"><a href="#2-3-2-目的" class="headerlink" title="2.3.2 目的"></a>2.3.2 目的</h4><ol>
<li><strong>提高代码的灵活性和可扩展性</strong>：程序可以在运行时才决定调用哪个对象的方法，这使得程序更容易进行扩展和维护。例如，添加一个新的子类，无需修改基于父类的现有代码。</li>
<li><strong>接口统一</strong>：可以用父类类型来统一处理各种子类对象。</li>
</ol>
<hr>
<h4 id="2-3-3-实现条件"><a href="#2-3-3-实现条件" class="headerlink" title="2.3.3 实现条件"></a>2.3.3 实现条件</h4><ol>
<li><strong>继承</strong>：必须存在继承关系。</li>
<li><strong>重写</strong>：子类必须重写父类的方法。</li>
<li><strong>向上转型</strong>：父类引用指向子类对象：<code>Parent p = new Child();</code></li>
</ol>
<hr>
<h4 id="2-3-4-实现机制：动态绑定"><a href="#2-3-4-实现机制：动态绑定" class="headerlink" title="2.3.4 实现机制：动态绑定"></a>2.3.4 实现机制：动态绑定</h4><p>Java 的方法调用是在运行时才确定其具体类型的，而不是在编译时。编译器检查的是父类中是否有该方法，而运行时 JVM 会找到实际对象所属的类的方法来执行。</p>
<hr>
<h4 id="2-3-5-代码示例"><a href="#2-3-5-代码示例" class="headerlink" title="2.3.5 代码示例"></a>2.3.5 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a shape.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123; <span class="comment">// 重写draw方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a circle.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123; <span class="comment">// 重写draw方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Drawing a square.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试多态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolymorphismTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 多态的经典体现：父类引用指向子类对象</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(); <span class="comment">// 向上转型</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>(); <span class="comment">// 向上转型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译时，shape1和shape2都是Shape类型</span></span><br><span class="line">        <span class="comment">// 运行时，JVM会根据它们实际指向的对象类型来调用相应的draw方法</span></span><br><span class="line">        shape1.draw(); <span class="comment">// 输出: Drawing a circle.</span></span><br><span class="line">        shape2.draw(); <span class="comment">// 输出: Drawing a square.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个更强大的例子：使用统一的方法处理不同的对象</span></span><br><span class="line">        Shape[] shapes = &#123;<span class="keyword">new</span> <span class="title class_">Circle</span>(), <span class="keyword">new</span> <span class="title class_">Square</span>(), <span class="keyword">new</span> <span class="title class_">Circle</span>()&#125;;</span><br><span class="line">        <span class="keyword">for</span> (Shape shape : shapes) &#123;</span><br><span class="line">            shape.draw(); <span class="comment">// 同一个调用，产生多种不同的行为</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">           Drawing a circle.</span></span><br><span class="line"><span class="comment">           Drawing a square.</span></span><br><span class="line"><span class="comment">           Drawing a circle.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-4-抽象类"><a href="#2-4-抽象类" class="headerlink" title="2.4 抽象类"></a>2.4 抽象类</h3><p>抽象类（Abstract Class）在 Java 中是一种特殊的类，它<strong>不能被实例化</strong>（即你不能使用 <code>new</code> 关键字来创建一个抽象类的对象）。它存在的意义是<strong>作为其他类的基类（父类）</strong>，用于被继承。</p>
<h4 id="2-4-1-作用"><a href="#2-4-1-作用" class="headerlink" title="2.4.1. 作用"></a>2.4.1. 作用</h4><p>想象一个场景：我们要设计一个图形（<code>Shape</code>）类体系，包括圆形（<code>Circle</code>）、矩形（<code>Rectangle</code>）等。</p>
<ul>
<li>所有图形都有一个共同的行为：计算面积（<code>calculateArea()</code>）。</li>
<li>但是，<strong>计算面积的具体公式因图形而异</strong>。<code>Shape</code> 类本身无法提供一个通用的、有实际意义的面积计算公式。</li>
</ul>
<p>如果没有抽象类，我们可能会在 <code>Shape</code> 类中这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>; <span class="comment">// 或者抛出一个异常，但这并不优雅</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会导致两个问题：</p>
<ol>
<li>用户可能会错误地实例化 <code>Shape</code> 类，而一个“形状”本身是没有实际意义的。</li>
<li><code>return 0.0</code> 是一个无意义的、妥协的实现，容易引发错误。</li>
</ol>
<p><strong>抽象类解决了这个问题</strong>：它允许我们声明一个方法但不提供实现（即抽象方法），强制其子类<strong>必须</strong>提供这个方法的具体实现。这样就定义了一个清晰的契约（Contract）。</p>
<hr>
<h4 id="2-4-2-定义"><a href="#2-4-2-定义" class="headerlink" title="2.4.2 定义"></a>2.4.2 定义</h4><p>使用 <code>abstract</code> 关键字来修饰一个类。</p>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 abstract 关键字声明一个抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> class 类名 &#123;</span><br><span class="line">    <span class="comment">// 类的成员：字段、具体方法、抽象方法等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键特性：抽象方法</strong></p>
<ul>
<li>抽象方法是一种<strong>只有声明，没有方法体（没有 <code>{}</code> ）</strong> 的方法。</li>
<li>抽象方法也<strong>必须</strong>使用 <code>abstract</code> 关键字来修饰。</li>
<li>包含抽象方法的类<strong>必须是</strong>抽象类。但反过来，抽象类不一定包含抽象方法（虽然这种情况不常见）。</li>
</ul>
<p><strong>语法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象方法没有方法体，以分号结束</span></span><br><span class="line">访问修饰符 <span class="keyword">abstract</span> 返回值类型 方法名(参数列表);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">abstract</span> 访问修饰符 返回值类型 方法名(参数列表); <span class="comment">// 两种写法均可，通常前者更常见</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-4-3-特点与规则"><a href="#2-4-3-特点与规则" class="headerlink" title="2.4.3 特点与规则"></a>2.4.3 特点与规则</h4><ol>
<li><strong>不能被实例化</strong>：这是最基本的原则。<code>new AbstractClass()</code> 会导致编译错误。</li>
<li><strong>可以包含抽象方法和具体方法</strong>：抽象类提供了很好的灵活性，既可以定义契约（抽象方法），也可以提供公共的实现（具体方法）供子类复用。</li>
<li><strong>子类必须实现所有抽象方法</strong>：如果一个非抽象类（具体类）继承了一个抽象类，它<strong>必须</strong>实现（Override）父类中所有的抽象方法。否则，这个子类自己也必须声明为 <code>abstract</code>。</li>
<li><strong>可以有构造方法</strong>：虽然不能直接实例化，但抽象类的构造方法可以被子类的构造方法通过 <code>super()</code> 调用，用于初始化从抽象类继承的字段。</li>
<li><strong>可以有 main 方法</strong>：抽象类可以有 <code>static main</code> 方法，甚至可以运行它，但这通常只用于测试类本身的一些静态功能。</li>
<li><strong>可以包含所有普通类的成员</strong>：字段（成员变量）、具体方法、构造方法、静态方法、final 方法等。</li>
</ol>
<hr>
<h3 id="2-5-接口"><a href="#2-5-接口" class="headerlink" title="2.5 接口"></a>2.5 接口</h3><p>接口在 Java 中是一种<strong>完全抽象</strong>的引用类型。它是一组<strong>方法声明</strong>的集合，形成了一种行为契约（Contract）或协议（Protocol）。</p>
<p>核心思想是：<strong>“做什么”与“怎么做”分离</strong>。</p>
<ul>
<li><strong>接口</strong>：只定义“<strong>做什么</strong>”（即有哪些方法）。</li>
<li><strong>实现类</strong>：负责“<strong>怎么做</strong>”（即具体实现这些方法）。</li>
</ul>
<p>一个类通过<strong>实现（implements）</strong> 一个接口，来承诺它将提供接口中所有声明的具体实现。</p>
<hr>
<h4 id="2-5-1-核心目的与设计理念"><a href="#2-5-1-核心目的与设计理念" class="headerlink" title="2.5.1 核心目的与设计理念"></a>2.5.1 核心目的与设计理念</h4><p>接口的核心设计理念是定义 <strong>“can-do”关系</strong>（能够做什么），而不是 <strong>“is-a”关系</strong>（是什么）。</p>
<ul>
<li><strong>抽象类</strong>（如 <code>Shape</code>）：表示“它是一个图形”，这是一种本质上的分类。</li>
<li><strong>接口</strong>（如 <code>Drawable</code>）：表示“它可以被绘制”，这是一种能力或行为，任何不相关的对象（如图形、按钮、游戏角色）都可以拥有这个能力。</li>
</ul>
<p>接口的主要目的有：</p>
<ol>
<li><strong>实现多重继承的效果</strong>：Java 类是单继承的，但一个类可以实现多个接口。这使得类可以具备多种不同的能力。</li>
<li><strong>实现完全抽象</strong>：在早期 Java 版本中，接口是实现完全抽象的唯一方式。</li>
<li><strong>降低耦合，提高扩展性</strong>：程序依赖于接口（抽象）而非具体实现，使得代码更灵活，更容易扩展和维护。这是许多设计模式（如策略模式、工厂模式）的基础。</li>
</ol>
<hr>
<h4 id="2-5-2-接口的演变"><a href="#2-5-2-接口的演变" class="headerlink" title="2.5.2 接口的演变"></a>2.5.2 接口的演变</h4><table>
<thead>
<tr>
<th align="left">版本</th>
<th align="left">允许包含的内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Java 7 及以前</strong></td>
<td align="left">1. <strong>常量</strong> (<code>public static final</code>) 2. <strong>抽象方法</strong> (<code>public abstract</code>)</td>
</tr>
<tr>
<td align="left"><strong>Java 8</strong></td>
<td align="left">3. <strong>默认方法</strong> (<code>default</code>) 4. <strong>静态方法</strong> (<code>static</code>)</td>
</tr>
<tr>
<td align="left"><strong>Java 9</strong></td>
<td align="left">5. <strong>私有方法</strong> (<code>private</code>)</td>
</tr>
</tbody></table>
<hr>
<h4 id="2-5-3-接口的成员解析"><a href="#2-5-3-接口的成员解析" class="headerlink" title="2.5.3 接口的成员解析"></a>2.5.3 接口的成员解析</h4><h5 id="1-抽象方法-Abstract-Methods"><a href="#1-抽象方法-Abstract-Methods" class="headerlink" title="1. 抽象方法 (Abstract Methods)"></a>1. 抽象方法 (Abstract Methods)</h5><p>这是接口最核心的成员。所有方法默认都是 <code>public abstract</code> 的，这些关键字可以省略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 完整写法：public abstract void eat();</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;   <span class="comment">// 省略写法，依然是公共的抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>; <span class="comment">// 省略写法，依然是公共的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>规则</strong>：任何实现该接口的<strong>非抽象类</strong>，必须提供所有这些抽象方法的具体实现。</p>
<hr>
<h5 id="2-常量-Constants"><a href="#2-常量-Constants" class="headerlink" title="2. 常量 (Constants)"></a>2. 常量 (Constants)</h5><p>接口中声明的字段默认都是 <code>public static final</code> 的（即常量），这些关键字也可以省略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Constants</span> &#123;</span><br><span class="line">    <span class="comment">// 完整写法：public static final double PI = 3.14159;</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159</span>; <span class="comment">// 省略写法，依然是公共静态常量</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">APPLICATION_NAME</span> <span class="operator">=</span> <span class="string">&quot;MyApp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-默认方法-Default-Methods-Java-8"><a href="#3-默认方法-Default-Methods-Java-8" class="headerlink" title="3. 默认方法 (Default Methods) - Java 8+"></a>3. 默认方法 (Default Methods) - Java 8+</h5><p>使用 <code>default</code> 关键字修饰的方法。它<strong>有方法体</strong>，其主要目的是<strong>接口演化</strong>：允许向现有接口添加新方法，而不会破坏已有的实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认方法 - 提供默认实现</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">honk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vehicle is honking!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Car starts with key.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可以选择不重写 honk() 方法，直接使用默认实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">myCar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        myCar.start(); <span class="comment">// 输出: Car starts with key.</span></span><br><span class="line">        myCar.honk();  <span class="comment">// 输出: Vehicle is honking! (使用了默认实现)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-静态方法-Static-Methods-Java-8"><a href="#4-静态方法-Static-Methods-Java-8" class="headerlink" title="4. 静态方法 (Static Methods) - Java 8+"></a>4. 静态方法 (Static Methods) - Java 8+</h5><p>使用 <code>static</code> 关键字修饰的方法。它<strong>有方法体</strong>，属于接口本身，只能通过接口名直接调用，不能被实现类继承或重写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MathOperations</span> &#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> MathOperations.add(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 通过接口名调用</span></span><br><span class="line">        System.out.println(sum); <span class="comment">// 输出: 8</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Car myCar = new Car();</span></span><br><span class="line">        <span class="comment">// myCar.add(5, 3); // 错误！静态方法不能通过实现类的实例调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-私有方法-Private-Methods-Java-9"><a href="#5-私有方法-Private-Methods-Java-9" class="headerlink" title="5. 私有方法 (Private Methods) - Java 9+"></a>5. 私有方法 (Private Methods) - Java 9+</h5><p>使用 <code>private</code> 关键字修饰的方法。它<strong>有方法体</strong>，主要用于接口内部，作为默认方法或静态方法的辅助工具，用来抽取公共代码，减少重复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">logInfo</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;INFO&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">logError</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;ERROR&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有方法，为默认方法提供共享代码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String level, String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span> + level + <span class="string">&quot;] &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-5-4-定义与实现"><a href="#2-5-4-定义与实现" class="headerlink" title="2.5.4 定义与实现"></a>2.5.4 定义与实现</h4><h5 id="1-定义接口"><a href="#1-定义接口" class="headerlink" title="1. 定义接口"></a>1. 定义接口</h5><p>使用 <code>interface</code> 关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名 &#123;</span><br><span class="line">    <span class="comment">// 抽象方法、常量、默认方法、静态方法、私有方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-实现接口"><a href="#2-实现接口" class="headerlink" title="2. 实现接口"></a>2. 实现接口</h5><p>使用 <code>implements</code> 关键字。一个类可以实现多个接口（用逗号分隔）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口<span class="number">1</span>, 接口<span class="number">2</span>, ... &#123;</span><br><span class="line">    <span class="comment">// 必须实现所有接口的所有抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-类的构成与高级特性"><a href="#3-类的构成与高级特性" class="headerlink" title="3. 类的构成与高级特性"></a>3. 类的构成与高级特性</h2><h3 id="3-1-类的成员"><a href="#3-1-类的成员" class="headerlink" title="3.1 类的成员"></a>3.1 类的成员</h3><h4 id="3-1-1-变量"><a href="#3-1-1-变量" class="headerlink" title="3.1.1 变量"></a>3.1.1 变量</h4><h5 id="1-局部变量"><a href="#1-局部变量" class="headerlink" title="1. 局部变量"></a>1. 局部变量</h5><ul>
<li><strong>定义</strong>：在方法、构造函数或代码块内部声明的变量</li>
<li><strong>作用域</strong>：仅限于声明它的方法、构造函数或代码块内部</li>
<li><strong>生命周期</strong>：从声明处开始，到所在代码块执行结束时销毁</li>
<li><strong>特点</strong>：<ul>
<li>必须初始化后才能使用</li>
<li>不能使用访问修饰符（如public&#x2F;private）</li>
<li>存储在栈内存中</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exampleMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">localVar</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    System.out.println(localVar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-成员变量-实例变量"><a href="#2-成员变量-实例变量" class="headerlink" title="2. 成员变量&#x2F;实例变量"></a>2. 成员变量&#x2F;实例变量</h5><ul>
<li><strong>定义</strong>：在类内部但在方法外部声明的变量，没有static修饰</li>
<li><strong>作用域</strong>：整个类内部都可访问</li>
<li><strong>生命周期</strong>：与对象实例相同，对象创建时产生，对象被垃圾回收时销毁</li>
<li><strong>特点</strong>：<ul>
<li>有默认值（数值型为0，布尔型为false，引用型为null）</li>
<li>可以使用访问修饰符</li>
<li>存储在堆内存中</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> instanceVar; <span class="comment">// 成员变量/实例变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInstanceVar</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.instanceVar = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-静态变量-类变量"><a href="#3-静态变量-类变量" class="headerlink" title="3. 静态变量&#x2F;类变量"></a>3. 静态变量&#x2F;类变量</h5><ul>
<li><strong>定义</strong>：使用static关键字声明的变量</li>
<li><strong>作用域</strong>：整个类以及可以通过类名访问</li>
<li><strong>生命周期</strong>：程序开始时创建，程序结束时销毁</li>
<li><strong>特点</strong>：<ul>
<li>所有类实例共享同一个静态变量</li>
<li>可以通过类名直接访问</li>
<li>有默认值</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVar</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 静态变量/类变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyClass.staticVar = <span class="number">10</span>; <span class="comment">// 直接通过类名访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-常量"><a href="#4-常量" class="headerlink" title="4. 常量"></a>4. 常量</h5><ul>
<li><strong>定义</strong>：使用final关键字声明的变量，值一旦设定不能更改</li>
<li><strong>特点</strong>：<ul>
<li>如果是基本数据类型，值不能改变</li>
<li>如果是对象引用，引用不能改变，但对象内容可以改变</li>
<li>通常与static一起使用，表示类常量</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159</span>; <span class="comment">// 常量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxValue;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxValue = max; <span class="comment">// 可以在构造函数中初始化final变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-2-方法"><a href="#3-1-2-方法" class="headerlink" title="3.1.2 方法"></a>3.1.2 方法</h4><h5 id="1-方法声明"><a href="#1-方法声明" class="headerlink" title="1. 方法声明"></a>1. 方法声明</h5><p>Java方法的基本结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[访问修饰符] [其他修饰符] 返回类型 方法名(参数列表) [异常列表] &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">addNumbers</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Numbers must be positive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-实例方法"><a href="#2-实例方法" class="headerlink" title="2. 实例方法"></a>2. 实例方法</h5><ul>
<li><strong>定义</strong>：不使用static关键字声明的方法</li>
<li><strong>特点</strong>：<ul>
<li>必须通过类的实例调用</li>
<li>可以访问类的所有成员变量和方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        result += value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">Calculator</span> <span class="variable">calc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">calc.add(<span class="number">5</span>); <span class="comment">// 通过实例调用实例方法</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="3. 静态方法"></a>3. 静态方法</h5><ul>
<li><strong>定义</strong>：使用static关键字声明的方法</li>
<li><strong>特点</strong>：<ul>
<li>可以通过类名直接调用</li>
<li>只能直接访问静态变量和静态方法</li>
<li>不能使用this关键字</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathUtils</span> &#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> MathUtils.multiply(<span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 直接通过类名调用</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-抽象方法"><a href="#4-抽象方法" class="headerlink" title="4. 抽象方法"></a>4. 抽象方法</h5><ul>
<li><strong>定义</strong>：使用abstract关键字声明且没有方法体的方法</li>
<li><strong>特点</strong>：<ul>
<li>只能在抽象类或接口中声明</li>
<li>必须在子类中实现（除非子类也是抽象类）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-final方法"><a href="#5-final方法" class="headerlink" title="5. final方法"></a>5. final方法</h5><ul>
<li><strong>定义</strong>：使用final关键字声明的方法</li>
<li><strong>特点</strong>：不能被子类重写</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">cannotOverride</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 此方法不能被子类重写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="6-同步方法"><a href="#6-同步方法" class="headerlink" title="6. 同步方法"></a>6. 同步方法</h5><ul>
<li><strong>定义</strong>：使用synchronized关键字声明的方法</li>
<li><strong>特点</strong>：用于多线程编程，确保同一时间只有一个线程执行该方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++; <span class="comment">// 线程安全操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="7-本地方法"><a href="#7-本地方法" class="headerlink" title="7. 本地方法"></a>7. 本地方法</h5><ul>
<li><strong>定义</strong>：使用native关键字声明的方法</li>
<li><strong>特点</strong>：方法实现由本地代码（如C&#x2F;C++）提供</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>; <span class="comment">// 本地方法，实现在外部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="8-可变参数"><a href="#8-可变参数" class="headerlink" title="8. 可变参数"></a>8. 可变参数</h5><p>可变参数（Variable Arguments，简称Varargs）是Java 5中引入的一个重要特性，它允许方法接受数量可变的同类型参数。这个特性大大简化了需要处理不定数量参数的方法编写。</p>
<ul>
<li><strong>语法</strong>：参数类型后添加三个点（…）</li>
<li>**原理：**可变参数在底层是基于数组实现的。编译器会自动将传递的参数转换为数组，因此在方法体内可以像处理数组一样处理可变参数。</li>
<li><strong>使用规则：</strong><ul>
<li><strong>一个方法只能有一个可变参数</strong></li>
<li><strong>可变参数必须是方法的最后一个参数</strong></li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-1-3-构造器"><a href="#3-1-3-构造器" class="headerlink" title="3.1.3 构造器"></a>3.1.3 构造器</h4><p>构造方法是一个特殊的成员方法，它的名字<strong>必须与它所在的类名完全相同</strong>，并且<strong>没有返回类型</strong>（连 <code>void</code> 也没有）。它的主要作用是在创建对象时<strong>初始化该对象</strong>，即为对象的成员变量赋初始值。</p>
<h5 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h5><ol>
<li><strong>名称与类名完全相同</strong>。</li>
<li><strong>没有返回类型</strong>：这是它和普通方法最明显的区别。</li>
<li><strong>主要作用是初始化对象</strong>，而不是执行常规操作。</li>
<li><strong>在创建对象时自动调用</strong>：当使用 <code>new</code> 关键字实例化一个对象时，JVM 会自动调用相应的构造方法。</li>
<li><strong>不能被 <code>static</code>, <code>final</code>, <code>abstract</code>, <code>synchronized</code> 等修饰符修饰</strong>：但可以使用访问控制符（<code>public</code>, <code>protected</code>, <code>private</code>）。</li>
</ol>
<hr>
<h5 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h5><p><strong>(1)默认构造函数</strong></p>
<p>如果一个类没有<strong>显式地</strong>定义任何构造方法，Java 编译器会在编译时<strong>自动为你提供一个无参的、方法体为空的默认构造方法</strong>。</p>
<p><strong>格式：</strong><code>[public] ClassName() {}</code> （访问权限与类相同）</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 没有显式定义任何构造方法</span></span><br><span class="line">    <span class="comment">// 编译器会自动提供：public Person() &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以使用默认构造方法创建对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br></pre></td></tr></table></figure>

<p><strong>重要提示</strong>：一旦你显式地定义了一个或多个构造方法，编译器就<strong>不再提供</strong>默认的无参构造方法。这时如果你还想用 <code>new ClassName()</code> 的方式创建对象，就必须自己手动定义一个无参构造方法。</p>
<p><strong>(2)带参数的构造方法</strong></p>
<p>为了在创建对象时就赋予成员变量特定的值，我们可以定义带参数的构造方法。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// 使用 this 关键字来区分同名的成员变量和参数</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以同时定义一个无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>); <span class="comment">// 调用带参构造</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 调用无参构造</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-重载"><a href="#3-重载" class="headerlink" title="3. 重载"></a>3. 重载</h5><p>和普通方法一样，构造方法也可以重载。这意味着一个类中可以有多个同名的构造方法，但它们的<strong>参数列表（参数的类型、顺序或数量）必须不同</strong>。重载提供了多种初始化对象的方式，增加了类的灵活性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法1：初始化所有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String title, String author, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法2：只初始化 title 和 author，price 给默认值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String title, String author)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(title, author, <span class="number">0.0</span>); <span class="comment">// 使用 this() 调用另一个构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法3：无参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;Untitled&quot;</span>, <span class="string">&quot;Unknown&quot;</span>, <span class="number">0.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-使用-this-调用其他构造方法"><a href="#4-使用-this-调用其他构造方法" class="headerlink" title="4. 使用 this() 调用其他构造方法"></a>4. 使用 <code>this()</code> 调用其他构造方法</h5><p>在一个构造方法中，可以使用 <code>this(参数列表)</code> 的形式来调用本类的其他构造方法。这有助于减少代码重复。</p>
<p><strong>规则：</strong></p>
<ul>
<li><code>this()</code> 必须是构造方法体内的<strong>第一条语句</strong>。</li>
<li>只能在一个构造方法中调用一次其他的构造方法。</li>
</ul>
<p><strong>示例（见上例中的 <code>Book</code> 类）</strong></p>
<hr>
<h5 id="5-继承中的构造方法"><a href="#5-继承中的构造方法" class="headerlink" title="5. 继承中的构造方法"></a>5. 继承中的构造方法</h5><p>在存在继承关系的父子类中，构造方法的调用遵循以下规则：</p>
<ol>
<li><strong>子类构造方法必须调用父类构造方法</strong>：如果子类的构造方法没有显式地使用 <code>super(参数列表)</code> 来调用父类的某个构造方法，那么编译器会自动在子类构造方法的第一句加上 <code>super()</code>，即调用父类的无参构造方法。</li>
<li><code>super()</code> 和 <code>this()</code> 不能同时出现：因为它们都要求是第一条语句。</li>
<li><strong>如果父类没有无参构造方法，子类必须显式调用</strong>：如果父类只定义了带参构造方法（意味着编译器不会提供默认无参构造），那么子类的构造方法<strong>必须</strong>使用 <code>super(参数列表)</code> 显式地调用父类的某个带参构造方法，否则会编译错误。</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类定义了带参构造，没有无参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类必须显式调用父类的带参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String type, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(type); <span class="comment">// 必须放在第一行</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误示例：编译器会尝试自动添加 super()，但父类没有，所以会报错</span></span><br><span class="line">    <span class="comment">// public Dog(String name) &#123;</span></span><br><span class="line">    <span class="comment">//     this.name = name;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="6-最佳实践"><a href="#6-最佳实践" class="headerlink" title="6. 最佳实践"></a>6. 最佳实践</h5><ol>
<li><strong>养成好习惯</strong>：即使暂时不需要，也<strong>最好显式地写出无参构造方法</strong>。这可以避免因为后续添加了带参构造方法而导致的意外错误（比如很多框架如 Spring Hibernate 都默认使用无参构造来创建对象）。</li>
<li><strong>保持构造方法简单</strong>：构造方法的主要目的是初始化状态。避免在构造方法中编写复杂的逻辑或调用可能被重写的方法，这可能导致意想不到的行为。</li>
<li><strong>使用重载提供灵活性</strong>：提供多种构造方法，让类的使用者可以用最方便的方式初始化对象。</li>
</ol>
<hr>
<h4 id="3-1-4-代码块"><a href="#3-1-4-代码块" class="headerlink" title="3.1.4 代码块"></a>3.1.4 代码块</h4><h5 id="1-局部代码块"><a href="#1-局部代码块" class="headerlink" title="1. 局部代码块"></a>1. 局部代码块</h5><p>局部代码块定义在方法或语句中，用于限制变量的作用范围 ，提前结束变量的生命周期。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalBlockExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 方法级别的代码</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;x = &quot;</span> + x);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 局部代码块</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// y 只在此代码块内可见</span></span><br><span class="line">            System.out.println(<span class="string">&quot;y = &quot;</span> + y);</span><br><span class="line">            System.out.println(<span class="string">&quot;x inside block = &quot;</span> + x); <span class="comment">// 可以访问外部变量</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// System.out.println(y); // 编译错误: y 无法解析为变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;x outside block = &quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>限定变量生命周期，提高内存利用率</li>
<li>变量只在代码块内部可见</li>
<li>可以访问外部代码块的变量</li>
</ul>
<hr>
<h5 id="2-构造代码块"><a href="#2-构造代码块" class="headerlink" title="2. 构造代码块"></a>2. 构造代码块</h5><p>构造代码块用于初始化实例变量，在每次创建对象时执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorBlockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        value = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块执行，value = &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConstructorBlockExample</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造函数执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConstructorBlockExample</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        System.out.println(<span class="string">&quot;带参构造函数执行，value = &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConstructorBlockExample</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstructorBlockExample</span>();</span><br><span class="line">        <span class="type">ConstructorBlockExample</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstructorBlockExample</span>(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构造代码块执行，value = 10</span><br><span class="line">构造函数执行</span><br><span class="line">构造代码块执行，value = 10</span><br><span class="line">带参构造函数执行，value = 20</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>每次创建对象时都会执行</li>
<li>在构造函数之前执行</li>
<li>多个构造代码块按顺序执行</li>
<li>常用于多个构造函数共享的初始化代码</li>
</ul>
<hr>
<h5 id="3-静态代码块"><a href="#3-静态代码块" class="headerlink" title="3. 静态代码块"></a>3. 静态代码块</h5><p>静态代码块用于初始化静态变量，在类加载时执行且只执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticBlockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> staticValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> instanceValue;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        staticValue = <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行，staticValue = &quot;</span> + staticValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        instanceValue = <span class="number">50</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块执行，instanceValue = &quot;</span> + instanceValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StaticBlockExample</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造函数执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主方法开始&quot;</span>);</span><br><span class="line">        <span class="type">StaticBlockExample</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticBlockExample</span>();</span><br><span class="line">        <span class="type">StaticBlockExample</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticBlockExample</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">静态代码块执行，staticValue = 100</span><br><span class="line">主方法开始</span><br><span class="line">构造代码块执行，instanceValue = 50</span><br><span class="line">构造函数执行</span><br><span class="line">构造代码块执行，instanceValue = 50</span><br><span class="line">构造函数执行</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>类加载时执行且只执行一次</li>
<li>在main方法之前执行</li>
<li>只能访问静态成员</li>
<li>常用于加载外部资源或执行一次性初始化操作</li>
</ul>
<hr>
<h5 id="4-同步代码块"><a href="#4-同步代码块" class="headerlink" title="4. 同步代码块"></a>4. 同步代码块</h5><p>同步代码块用于控制多线程对共享资源的访问，防止数据不一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedBlockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 同步代码块，使用lock对象作为锁</span></span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 非同步代码</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行非同步操作&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 同步代码块，使用this作为锁</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 进入同步块&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedBlockExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedBlockExample</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建多个线程测试同步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                example.increment();</span><br><span class="line">                example.performTask();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>确保同一时间只有一个线程执行代码块</li>
<li>需要指定监视器对象（锁）</li>
<li>比同步方法更细粒度地控制同步</li>
<li>可以减少线程等待时间，提高效率</li>
</ul>
<hr>
<h3 id="3-2-关键字"><a href="#3-2-关键字" class="headerlink" title="3.2 关键字"></a>3.2 关键字</h3><h4 id="3-2-1-this、super"><a href="#3-2-1-this、super" class="headerlink" title="3.2.1 this、super"></a>3.2.1 this、super</h4><h5 id="1-this"><a href="#1-this" class="headerlink" title="1. this"></a>1. this</h5><p><code>this</code> 关键字是一个引用变量，它<strong>指向当前正在执行方法的对象实例</strong>。</p>
<p><strong>（1） 解决实例变量与局部变量的命名冲突（最常见用途）</strong></p>
<p>当方法的参数名或局部变量名与类的实例变量名相同时，使用 <code>this</code> 可以明确指定要访问的是实例变量，从而避免歧义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 实例变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法参数名与实例变量名相同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// this.name 指的是实例变量，等号右边的 name 指的是参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// 同上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>如果没有 <code>this</code>，<code>name = name</code> 这条语句实际上只是将参数 <code>name</code> 的值赋给它自己，实例变量 <code>name</code> 的值并未改变。</em></p>
<p><strong>（2） 在类的内部调用当前对象的其他方法（通常可省略）</strong></p>
<p>虽然通常可以省略（因为编译器会默认加上），但显式地使用 <code>this.methodName()</code> 可以更清晰地表明调用的是当前对象的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Printing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPrint</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.printStatus(); <span class="comment">// 显式使用this调用，等同于直接写 printStatus();</span></span><br><span class="line">        <span class="comment">// ... 其他打印逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）在构造方法中调用同一个类的其他构造方法（<code>this()</code>）</strong></p>
<p>使用 <code>this()</code> 可以在一个构造方法中调用本类的另一个重载的构造方法。<strong>这必须作为构造方法的第一条语句出现</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造，调用有参构造并提供默认值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// 调用下面的有参构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>这样做的好处是避免了在多个构造方法中重复相同的初始化代码。</em></p>
<p><strong>（4）作为参数传递</strong></p>
<p>可以将当前对象作为参数传递给其他方法或构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassA</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ClassB b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前 ClassA 的对象传递给 ClassB 的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.b = <span class="keyword">new</span> <span class="title class_">ClassB</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassB</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ClassA a;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassB</span><span class="params">(ClassA a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-super"><a href="#2-super" class="headerlink" title="2. super"></a>2. super</h5><p><code>super</code> 关键字是一个引用变量，用于<strong>引用直接父类对象</strong>。它主要用于在子类中访问被隐藏或重写的父类成员。</p>
<p><strong>（1）调用父类的构造方法（<code>super()</code>）</strong></p>
<p>在子类的构造方法中，<strong>必须</strong>调用父类的某个构造方法。如果子类构造方法没有显式地使用 <code>super(...)</code> 来调用特定的父类构造方法，编译器会自动插入一个无参的 <code>super()</code>。</p>
<ul>
<li><code>super()</code> 调用也必须放在子类构造方法的<strong>第一行</strong>。</li>
<li><code>this()</code> 和 <code>super()</code> 不能同时存在于同一个构造方法中，因为它们都要求是第一行语句。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String breed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, String breed)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 必须放在第一行，调用父类有参构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.breed = breed; <span class="comment">// 然后初始化子类自己的属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）访问父类被隐藏的成员变量</strong></p>
<p>如果子类声明了与父类同名的成员变量（不推荐这样做），则父类的变量被“隐藏”。可以使用 <code>super.variableName</code> 来访问父类的版本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello from Parent&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello from Child&quot;</span>; <span class="comment">// 隐藏了父类的 message</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessages</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">super</span>.message); <span class="comment">// 输出: Hello from Parent</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.message);  <span class="comment">// 输出: Hello from Child</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）调用父类被重写的方法</strong></p>
<p>当子类重写了父类的方法后，如果还想在子类内部调用父类该方法的原始实现，就需要使用 <code>super.methodName()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vehicle is starting...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.start(); <span class="comment">// 先调用父类的start方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Car is starting its engine...&quot;</span>); <span class="comment">// 再添加子类特有的行为</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>这是一种非常常见的模式，用于扩展而非完全替代父类的功能。</em></p>
<hr>
<h4 id="3-2-2-static"><a href="#3-2-2-static" class="headerlink" title="3.2.2 static"></a>3.2.2 static</h4><p><code>static</code> 关键字的核心含义是 <strong>“静态的”</strong> 或 <strong>“与类相关的，而非与实例相关的”</strong>。</p>
<h5 id="1-核心思想"><a href="#1-核心思想" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h5><ul>
<li>被 <code>static</code> 修饰的成员（变量、方法、代码块、内部类）属于<strong>类本身</strong>，而不是属于类的某个实例对象。</li>
<li>它是在<strong>类加载过程</strong>（JVM 将类的字节码加载到内存时）中被创建和初始化的。它在内存中只有一份副本，被所有该类的实例所共享。</li>
<li>正因为不依赖于实例，所以<strong>静态成员不能直接访问非静态成员</strong>（因为非静态成员属于实例，此时实例可能还未创建）。反之，非静态成员可以直接访问静态成员。</li>
</ul>
<hr>
<h5 id="2-主要用途"><a href="#2-主要用途" class="headerlink" title="2. 主要用途"></a>2. 主要用途</h5><p><strong>（1）静态变量（类变量）</strong></p>
<ul>
<li><p><strong>定义</strong>：使用 <code>static</code> 修饰的变量。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>内存中只有一个副本，无论创建多少个对象。</li>
<li>当且仅当类初次加载时被初始化一次。</li>
<li>可以通过 <code>ClassName.variableName</code> 直接访问（推荐），也可以通过对象实例访问（不推荐）。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：用于需要被所有实例共享的数据，例如计数器、配置参数、常量池等。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">nextId</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 静态变量，用于分配唯一ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">        id = nextId;</span><br><span class="line">        nextId++; <span class="comment">// 所有Employee对象共享并修改同一个nextId</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>（2）静态方法（类方法）</strong></p>
<ul>
<li><p><strong>定义</strong>：使用 <code>static</code> 修饰的方法。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>不能使用 <code>this</code> 和 <code>super</code> 关键字（因为它们与实例相关）。</li>
<li><strong>不能直接访问类的非静态变量和非静态方法</strong>（因为非静态成员需要先有实例才能存在）。</li>
<li>可以通过 <code>ClassName.methodName()</code> 直接调用。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>工具类方法（如 <code>Math.sqrt()</code>, <code>Arrays.sort()</code>），这些方法的执行不依赖于任何对象状态。</li>
<li>工厂方法，用于创建对象实例。</li>
<li><code>main</code> 方法是程序入口，必须是静态的。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">calculateCircleArea</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius; <span class="comment">// 不依赖任何实例状态，只依赖于输入参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用：double area = MathUtils.calculateCircleArea(5.0);</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>（2）静态代码块</strong></p>
<ul>
<li><p><strong>定义</strong>：使用 <code>static</code> 修饰的代码块。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>在<strong>类被加载时</strong>执行，且<strong>只执行一次</strong>。</li>
<li>执行顺序优先于实例代码块和构造方法。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：用于初始化静态变量，或者执行只需要进行一次的复杂操作（例如加载本地库）。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123; <span class="comment">// 静态代码块，类加载时执行</span></span><br><span class="line">        props = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Files.newInputStream(Paths.get(<span class="string">&quot;db.config&quot;</span>))) &#123;</span><br><span class="line">            props.load(is); <span class="comment">// 初始化静态变量props</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to load config&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>（4）静态内部类</strong></p>
<ul>
<li><p><strong>定义</strong>：使用 <code>static</code> 修饰的内部类（嵌套类）。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>它不持有外部类的引用（与普通内部类最大的区别），因此它<strong>不能直接访问外部类的非静态成员</strong>。</li>
<li>创建静态内部类对象不需要先创建外部类对象：<code>new OuterClass.StaticNestedClass()</code>。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：当内部类不需要访问外部类实例时，应该优先使用静态内部类，因为它更节省内存（没有隐含的对外部类实例的引用）。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticField</span> <span class="operator">=</span> <span class="string">&quot;Static Field&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">instanceField</span> <span class="operator">=</span> <span class="string">&quot;Instance Field&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticNestedClass</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">accessFields</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(staticField); <span class="comment">// 可以访问外部类的静态成员</span></span><br><span class="line">            <span class="comment">// System.out.println(instanceField); // 编译错误！不能访问外部类的非静态成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建对象：Outer.StaticNestedClass nested = new Outer.StaticNestedClass();</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-2-3-final"><a href="#3-2-3-final" class="headerlink" title="3.2.3 final"></a>3.2.3 final</h4><p><code>final</code> 关键字的核心含义是 <strong>“不可改变的”</strong>。</p>
<h5 id="1-核心思想-1"><a href="#1-核心思想-1" class="headerlink" title="1. 核心思想"></a>1. 核心思想</h5><p>它可以修饰类、方法、变量，含义略有不同，但核心都是表示“最终形态”，无法被继承、重写或修改。</p>
<h5 id="2-主要用途-1"><a href="#2-主要用途-1" class="headerlink" title="2. 主要用途"></a>2. 主要用途</h5><p><strong>（1）final 变量（常量）</strong></p>
<ul>
<li><p><strong>定义</strong>：一旦被赋值，其值就不能再被修改。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li>如果是基本类型，值不能变。</li>
<li>如果是<strong>对象引用</strong>，<strong>引用不能变</strong>（即不能再指向另一个对象），但<strong>对象内部的状态是可以改变的</strong>（除非对象本身也是不可变对象，如 <code>String</code>）。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：用于定义常量。</p>
</li>
<li><p><strong>规范</strong>：常量名通常全部大写，单词间用下划线分隔。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constants</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159</span>; <span class="comment">// 基本类型，值不可变</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; NAMES = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 引用类型，引用不可变</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// NAMES = new ArrayList&lt;&gt;(); // 编译错误！不能修改final引用</span></span><br><span class="line">        NAMES.add(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// 可以！修改的是对象内部的状态，引用本身没变</span></span><br><span class="line">        NAMES.add(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>（2）final 方法</strong></p>
<ul>
<li><p><strong>定义</strong>：被 <code>final</code> 修饰的方法。</p>
</li>
<li><p><strong>特点</strong>：<strong>不能被子类重写 (Override)</strong>。</p>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li>防止子类改变方法的实现，确保方法的行为在继承体系中保持不变。</li>
<li>早期Java版本中，用于内联优化（现代JVM已经很智能，此作用已减弱）。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">secureMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这个方法很重要，不允许子类修改其实现</span></span><br><span class="line">        System.out.println(<span class="string">&quot;This is a critical operation.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// @Override // 编译错误！不能重写final方法</span></span><br><span class="line">    <span class="comment">// public void secureMethod() &#123; ... &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>（3）final 类</strong></p>
<ul>
<li><p><strong>定义</strong>：被 <code>final</code> 修饰的类。</p>
</li>
<li><p><strong>特点</strong>：<strong>不能被继承</strong>，即不能有子类。</p>
</li>
<li><p><strong>使用场景</strong>：保证类的安全性和不变性，防止他人通过继承来修改其行为。Java 标准库中的 <code>String</code>, <code>Integer</code> 等包装类都是 <code>final</code> 的。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ImmutableClass</span> &#123; <span class="comment">// 这个类是最终的，不能被继承</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImmutableClass</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class SubClass extends ImmutableClass &#123; &#125; // 编译错误！</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-2-4-static与final组合使用"><a href="#3-2-4-static与final组合使用" class="headerlink" title="3.2.4 static与final组合使用"></a>3.2.4 static与final组合使用</h4><p><code>static</code> 和 <code>final</code> 经常一起使用，用来定义<strong>全局常量</strong>。</p>
<ul>
<li><code>static</code>：强调这个变量属于类，只有一份，不需要创建对象就能访问。</li>
<li><code>final</code>：强调这个变量的值不可改变。</li>
</ul>
<p>它们的组合完美地定义了程序中的常量。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConstants</span> &#123;</span><br><span class="line">    <span class="comment">// 类常量，全局唯一且不可修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">APPLICATION_NAME</span> <span class="operator">=</span> <span class="string">&quot;My Awesome App&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">VERSION</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> MAX_CONNECTIONS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 也可以通过静态代码块为复杂的静态final常量赋值</span></span><br><span class="line">        MAX_CONNECTIONS = initializeMaxConnectionsFromConfig();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">initializeMaxConnectionsFromConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ... 从配置文件读取</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时直接通过类名访问：<code>String appName = AppConstants.APPLICATION_NAME;</code></p>
<hr>
<h3 id="3-3-包"><a href="#3-3-包" class="headerlink" title="3.3 包"></a>3.3 包</h3><h4 id="3-3-1-核心概念与作用"><a href="#3-3-1-核心概念与作用" class="headerlink" title="3.3.1 核心概念与作用"></a>3.3.1 核心概念与作用</h4><h5 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h5><p>包本质上就是<strong>文件系统中的文件夹</strong>。它是一种用于<strong>组织和管理 Java 类与接口</strong>的命名空间机制。它将功能相似或相关的类集合在一起，形成一个逻辑单元。</p>
<hr>
<h5 id="2-核心作用"><a href="#2-核心作用" class="headerlink" title="2. 核心作用"></a>2. 核心作用</h5><p>包的出现主要为了解决以下几个问题：</p>
<ol>
<li><strong>避免命名冲突（Namespace Management）</strong>：这是最核心的作用。全世界那么多开发者，难免会写出同名的类。包提供了唯一的命名空间，只要包名不同，即使类名相同，也被视为不同的类。<ul>
<li>例如：<code>java.util.Date</code> 和 <code>java.sql.Date</code> 是两个完全不同的类。</li>
</ul>
</li>
<li><strong>提高可维护性和可读性</strong>：将成千上万个类分门别类地放在不同的包中，结构清晰，便于查找和管理。就像你不会把所有的文件都放在桌面上，而是会建立不同的文件夹来分类存放。</li>
<li><strong>提供访问控制</strong>：包与访问权限修饰符相结合，可以定义类、接口、变量和方法的可见性，从而实现封装。我们熟知的<code>protected</code>和<strong>默认（包级私有）</strong> 权限都直接与包相关。</li>
</ol>
<hr>
<h4 id="3-3-2-包的定义与命名规则"><a href="#3-3-2-包的定义与命名规则" class="headerlink" title="3.3.2 包的定义与命名规则"></a>3.3.2 包的定义与命名规则</h4><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h5><p>在 Java 源文件（.java）的<strong>第一行（必须是第一行，注释除外）</strong> 使用 <code>package</code> 关键字来声明该文件中所有类所属的包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件路径: com/companyname/utils/StringUtil.java</span></span><br><span class="line"><span class="keyword">package</span> com.companyname.utils; <span class="comment">// 包声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringUtil</span> &#123;</span><br><span class="line">    <span class="comment">// 类的代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编译后，<code>StringUtil.class</code> 文件必须位于 <code>com/companyname/utils/</code> 目录下。</li>
<li>一个文件中最多只能有一个 <code>package</code> 语句。</li>
<li>如果没有指定 <code>package</code>，则该文件中的类属于<strong>无名包（unnamed package）</strong> 或默认包。这在小型测试程序中很常见，但在正式项目中<strong>强烈不推荐</strong>使用。</li>
</ul>
<hr>
<h5 id="2-规则与约定"><a href="#2-规则与约定" class="headerlink" title="2. 规则与约定"></a>2. 规则与约定</h5><p>包名是类全限定名（Fully Qualified Name）的重要组成部分。其命名遵循以下规范：</p>
<ul>
<li><strong>全部使用小写字母</strong>。</li>
<li><strong>采用反转的互联网域名（Reverse Domain Name）作为前缀</strong>：这是行业通用标准，能极大程度地保证全球唯一性。<ul>
<li>例如，如果你的公司域名是 <code>google.com</code>，那么你的包前缀就应该是 <code>com.google</code>。</li>
</ul>
</li>
<li><strong>后续部分根据项目、模块、功能进行划分</strong>：在域名后缀之后，根据项目的具体结构来定义。<ul>
<li>例如：<code>com.google.gson</code> (Gson 库), <code>org.springframework.boot</code> (Spring Boot 模块)。</li>
</ul>
</li>
<li><strong>使用点号 <code>.</code> 分隔</strong>，点号对应文件系统的目录层级。</li>
<li>不能使用 Java 保留字（如 <code>int</code>, <code>class</code>等）。</li>
</ul>
<hr>
<h4 id="3-3-3-包与作用域"><a href="#3-3-3-包与作用域" class="headerlink" title="3.3.3 包与作用域"></a>3.3.3 包与作用域</h4><p>Java 的四个访问权限修饰符中，有两个与包密切相关：</p>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="center">同类</th>
<th align="center">同包</th>
<th align="center">子类</th>
<th align="center">不同包</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>private</code></td>
<td align="center">可以访问</td>
<td align="center">不可</td>
<td align="center">不可</td>
<td align="center">不可</td>
<td>仅本类可见</td>
</tr>
<tr>
<td align="left"><strong>默认（无修饰符）</strong></td>
<td align="center">可以访问</td>
<td align="center">可以访问</td>
<td align="center">不可</td>
<td align="center">不可</td>
<td><strong>包级私有（Package-Private）</strong>，同包下的类可以访问</td>
</tr>
<tr>
<td align="left"><code>protected</code></td>
<td align="center">可以访问</td>
<td align="center">可以访问</td>
<td align="center">可以访问</td>
<td align="center">不可</td>
<td>同包和不同包的子类可以访问</td>
</tr>
<tr>
<td align="left"><code>public</code></td>
<td align="center">可以访问</td>
<td align="center">可以访问</td>
<td align="center">可以访问</td>
<td align="center">可以访问</td>
<td>完全公开</td>
</tr>
</tbody></table>
<p><strong>重点理解“默认”权限（包级私有）：</strong></p>
<ul>
<li>如果一个类、方法或变量没有指定任何访问修饰符，它就拥有“默认”权限。</li>
<li>这意味着，<strong>只有在同一个包下的其他类才能访问它</strong>。不同包下的类，即使是其子类，也无法访问。</li>
<li><strong>这是实现包内封装的关键机制</strong>。你可以将只希望在包内部使用的工具类、共享逻辑设置为包级私有，从而对外部隐藏实现细节。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件: com/utils/Logger.java</span></span><br><span class="line"><span class="keyword">package</span> com.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123; <span class="comment">// 注意：没有 public 修饰符，是包级私有的</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[LOG] &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件: com/utils/StringUtil.java</span></span><br><span class="line"><span class="keyword">package</span> com.utils; <span class="comment">// 同一个包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        Logger.log(<span class="string">&quot;Something happened!&quot;</span>); <span class="comment">// 可以访问，因为它们在同一个包下</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件: com/app/Main.java</span></span><br><span class="line"><span class="keyword">package</span> com.app; <span class="comment">// 不同的包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.utils.StringUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StringUtil</span>().doSomething();</span><br><span class="line">        <span class="comment">// Logger.log(&quot;Hello&quot;); // 编译错误！Logger 在 com.utils 包中是包级私有的，Main 在 com.app 包中无法访问。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-3-4-导入"><a href="#3-3-4-导入" class="headerlink" title="3.3.4 导入"></a>3.3.4 导入</h4><p>为了不在代码中每次都写类的全限定名（如 <code>java.util.List</code>），我们可以使用 <code>import</code> 语句。</p>
<h5 id="1-导入单个类"><a href="#1-导入单个类" class="headerlink" title="1. 导入单个类"></a>1. 导入单个类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">// 导入 ArrayList 类</span></span><br><span class="line"><span class="keyword">import</span> java.io.File;        <span class="comment">// 导入 File 类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 现在可以直接使用类名</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-导入整个包"><a href="#2-导入整个包" class="headerlink" title="2. 导入整个包"></a>2. 导入整个包</h5><p>使用通配符 <code>*</code> 可以导入一个包下的所有<strong>公共类</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">// 导入 java.util 包下的所有公共类（如 ArrayList, HashMap, Scanner等）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：不会导入子包中的类！例如 ‘java.util.concurrent’ 下的类不会被导入。</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-静态导入"><a href="#3-静态导入" class="headerlink" title="3. 静态导入"></a>3. 静态导入</h5><p>用于导入类的<strong>静态成员（静态变量和静态方法）</strong>，之后可以直接使用静态成员名，而不用加类名前缀。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.PI;    <span class="comment">// 导入静态变量 PI</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.pow;   <span class="comment">// 导入静态方法 pow</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out; <span class="comment">// 导入静态变量 out</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PI * pow(radius, <span class="number">2</span>); <span class="comment">// 直接使用 PI 和 pow，无需 Math.PI 和 Math.pow</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        out.println(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 直接使用 out，无需 System.out</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>谨慎使用</strong>：过度使用静态导入会使代码难以阅读，因为读者无法一眼看出静态成员来自哪个类。</p>
<hr>
<h5 id="4-导入规则与注意点"><a href="#4-导入规则与注意点" class="headerlink" title="4.导入规则与注意点"></a>4.导入规则与注意点</h5><ul>
<li><p><code>import</code> 语句位于 <code>package</code> 语句之后，类声明之前。</p>
</li>
<li><p><strong>不需要显式导入的类</strong>：</p>
<ul>
<li>同一个包下的其他类。</li>
<li><code>java.lang</code> 包下的所有类（如 <code>String</code>, <code>System</code>, <code>Object</code> 等），这是由编译器自动导入的。</li>
</ul>
</li>
<li><p>如果使用了两个 不同包中同名的类（例如 <code>java.sql.Date</code> 和 <code>java.util.Date</code>），就不能使用通配符导入，必须使用<strong>单类型导入</strong>，或者在代码中<strong>直接使用全限定名</strong>来避免冲突。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">// import java.sql.Date; // 不能再导入另一个Date</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">utilDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// 指向 java.util.Date</span></span><br><span class="line">        java.sql.<span class="type">Date</span> <span class="variable">sqlDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(...); <span class="comment">// 必须使用全限定名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-3-5-最佳实践"><a href="#3-3-5-最佳实践" class="headerlink" title="3.3.5 最佳实践"></a>3.3.5 最佳实践</h4><ol>
<li><strong>始终使用包，杜绝默认包</strong>：即使是再小的项目或 demo，也应建立一个有意义的包名（如 <code>com.example.demo</code>）。使用默认包会导致类无法被其他包导入，且容易引发命名冲突。</li>
<li><strong>遵循反转域名约定</strong>：这是 Java 世界的通用语言，能有效避免冲突，并让其他开发者一眼看出代码的来源或所属组织。</li>
<li><strong>包名要有意义，按模块&#x2F;功能划分</strong>：<ul>
<li><code>com.companyname.projectname.model</code> （数据模型）</li>
<li><code>com.companyname.projectname.dao</code> 或 <code>repository</code> （数据访问层）</li>
<li><code>com.companyname.projectname.service</code> （业务逻辑层）</li>
<li><code>com.companyname.projectname.controller</code> （Web控制层）</li>
<li><code>com.companyname.projectname.utils</code> （工具类）</li>
</ul>
</li>
<li><strong>合理使用访问控制符，强化封装</strong>：<ul>
<li>思考“这个类&#x2F;方法真的需要是 <code>public</code> 的吗？”</li>
<li>优先使用<strong>包级私有（无修饰符）</strong> 来隐藏那些只在包内部使用的实现细节。这是设计良好 API 的关键。</li>
</ul>
</li>
<li><strong>明智地选择导入方式</strong>：<ul>
<li>优先使用<strong>单类型导入</strong>（<code>import java.util.ArrayList;</code>），而不是通配符导入（<code>import java.util.*;</code>）。这让代码的依赖关系非常清晰，读者能确切知道使用了哪些类。现代的 IDE 可以自动管理这些导入。</li>
<li><strong>静态导入</strong>应仅用于非常常用且不会引起混淆的静态成员（如 <code>JUnit</code> 的 <code>Assert</code> 方法，<code>Math</code> 的 <code>PI</code>）。</li>
</ul>
</li>
<li><strong>包与物理目录结构严格匹配</strong>：这是 Java 语言的强制要求。包名 <code>com.example.utils</code> 必须对应文件系统中的 <code>com/example/utils</code> 目录。构建工具（Maven&#x2F;Gradle）和 IDE 都遵循并强制这一约定。</li>
</ol>
<hr>
<hr>
<h2 id="4-高级特性和设计模式初探"><a href="#4-高级特性和设计模式初探" class="headerlink" title="4. 高级特性和设计模式初探"></a>4. 高级特性和设计模式初探</h2><h3 id="4-1-Object类"><a href="#4-1-Object类" class="headerlink" title="4.1 Object类"></a>4.1 Object类</h3><h4 id="4-1-1-概述"><a href="#4-1-1-概述" class="headerlink" title="4.1.1 概述"></a>4.1.1 概述</h4><p><code>java.lang.Object</code>类是Java中所有类的<strong>根类</strong>，即所有类都直接或间接地继承自<code>Object</code>类。如果一个类没有使用<code>extends</code>关键字明确指定父类，那么它会<strong>默认继承</strong><code>Object</code>类。</p>
<p>这意味着，你定义的任何一个类，无论是简单的POJO、数组，还是复杂的业务类，都拥有<code>Object</code>类中定义的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这两种写法是等价的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">extends</span> <span class="title class_">Object</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-1-2-主要方法"><a href="#4-1-2-主要方法" class="headerlink" title="4.1.2 主要方法"></a>4.1.2 主要方法</h4><h5 id="1-toString-方法"><a href="#1-toString-方法" class="headerlink" title="1. toString()方法"></a>1. <code>toString()</code>方法</h5><ul>
<li><strong>作用</strong>：返回该对象的字符串表示。这是一个非常重要的方法，主要用于<strong>日志打印</strong>和<strong>调试</strong>，以便于阅读对象的信息。</li>
<li><strong>默认实现</strong>：<code>Object</code>类的默认实现返回的字符串由三部分组成：<code>类名 + @ + 对象的哈希码的无符号十六进制表示</code>。<ul>
<li>例如：<code>com.example.MyClass@1b6d3586</code></li>
</ul>
</li>
<li><strong>重写建议</strong>：<strong>强烈建议为你自己的类重写此方法</strong>，返回一个包含对象有意义信息的、简洁且易于阅读的字符串。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-equals-Object-obj-方法"><a href="#2-equals-Object-obj-方法" class="headerlink" title="2. equals(Object obj)方法"></a>2. <code>equals(Object obj)</code>方法</h5><ul>
<li><strong>作用</strong>：指示<strong>其他某个对象是否与此对象“相等”</strong>。用于判断两个对象在逻辑上是否等价。</li>
<li><strong>默认实现</strong>：默认使用<code>==</code>操作符进行比较，即只判断两个<strong>引用是否指向堆内存中的同一个对象</strong>（判断的是对象地址是否相同）。</li>
<li><strong>重写建议</strong>：当你需要根据对象的<strong>内容</strong>（即字段的值）而不是内存地址来判断相等性时，必须重写此方法。</li>
<li><strong>重写<code>equals()</code>必须遵守的通用约定</strong>：<ol>
<li><strong>自反性</strong>：<code>x.equals(x)</code>必须返回<code>true</code>。</li>
<li><strong>对称性</strong>：如果<code>x.equals(y)</code>为<code>true</code>，那么<code>y.equals(x)</code>也必须为<code>true</code>。</li>
<li><strong>传递性</strong>：如果<code>x.equals(y)</code>为<code>true</code>，且<code>y.equals(z)</code>为<code>true</code>，那么<code>x.equals(z)</code>也必须为<code>true</code>。</li>
<li><strong>一致性</strong>：只要对象没有被修改，多次调用<code>x.equals(y)</code>应该一直返回相同的结果。</li>
<li><strong>非空性</strong>：<code>x.equals(null)</code>必须返回<code>false</code>。</li>
</ol>
</li>
</ul>
<hr>
<h5 id="3-hashCode-方法"><a href="#3-hashCode-方法" class="headerlink" title="3. hashCode()方法"></a>3. <code>hashCode()</code>方法</h5><ul>
<li><strong>作用</strong>：返回对象的<strong>哈希码值</strong>（一个<code>int</code>类型的整数）。这个方法主要用于支持基于哈希表的集合，如<code>HashMap</code>, <code>HashSet</code>, <code>Hashtable</code>等。</li>
<li><strong>与<code>equals()</code>方法的重写关系</strong>：这是一个<strong>极其重要</strong>的规则！<ul>
<li><strong>规则1</strong>：如果两个对象根据<code>equals(Object)</code>方法是相等的，那么对这两个对象中的每个对象调用<code>hashCode</code>方法都必须生成<strong>相同的</strong>整数结果。</li>
<li><strong>规则2</strong>：如果两个对象根据<code>equals(Object)</code>方法是不相等的，并不要求它们调用<code>hashCode</code>必须产生不同的结果。但是，<strong>为不相等的对象生成不同的哈希码可以提高哈希表的性能</strong>。</li>
</ul>
</li>
<li><strong>为什么有这个规则？</strong> 哈希表（如<code>HashMap</code>）通过哈希码来快速定位对象存储的“桶”（bucket）。如果两个相等的对象有不同的哈希码，它们可能会被放到不同的桶里，导致<code>HashMap</code>无法正常工作（例如，用<code>equals</code>认为相同的key却找不到对应的value）。</li>
</ul>
<p><strong>结论：只要你重写了<code>equals()</code>方法，就必须同时重写<code>hashCode()</code>方法</strong>，以确保上述规则得以遵守。</p>
<hr>
<h5 id="4-getClass-方法"><a href="#4-getClass-方法" class="headerlink" title="4. getClass()方法"></a>4. <code>getClass()</code>方法</h5><ul>
<li><strong>作用</strong>：返回此对象的<strong>运行时类</strong>（Runtime Class）。这是一个<code>final</code>方法，不能被重写。</li>
<li><strong>用途</strong>：通过返回的<code>Class</code>对象，你可以获取类的元信息，如类名、方法、字段等。它通常用于<strong>反射</strong>机制。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">Class&lt;?&gt; clazz = obj.getClass(); <span class="comment">// 返回的是java.lang.String类对象</span></span><br><span class="line">System.out.println(clazz.getName()); <span class="comment">// 输出 &quot;java.lang.String&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="5-clone-方法"><a href="#5-clone-方法" class="headerlink" title="5. clone()方法"></a>5. <code>clone()</code>方法</h5><ul>
<li><strong>作用</strong>：创建并返回此对象的一个<strong>副本</strong>。“副本”的准确含义取决于该对象的类本身，通常的意图是：对于任何对象<code>x</code>，表达式<code>x.clone() != x</code>为真，且<code>x.clone().getClass() == x.getClass()</code>也为真（但这些不是绝对要求）。</li>
<li><strong>使用限制</strong>：要使用<code>clone()</code>方法，对象的类必须<strong>实现<code>Cloneable</code>接口</strong>。这是一个标记接口（没有任何方法），仅仅表示该类允许被克隆。如果没有实现该接口就调用<code>clone()</code>，会抛出<code>CloneNotSupportedException</code>异常。</li>
<li><strong>深浅拷贝问题</strong>：<code>Object</code>类的<code>clone()</code>方法默认实现的是<strong>浅拷贝</strong>（shallow copy）。它复制对象的所有字段（基本类型拷贝值，引用类型拷贝引用地址）。如果对象包含可变对象的引用，浅拷贝可能会导致问题。如果需要<strong>深拷贝</strong>（deep copy），必须在重写的<code>clone()</code>方法中手动实现。</li>
</ul>
<hr>
<h5 id="6-finalize-方法"><a href="#6-finalize-方法" class="headerlink" title="6. finalize()方法"></a>6. <code>finalize()</code>方法</h5><ul>
<li><strong>作用</strong>：当垃圾回收器（Garbage Collector, GC）确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。它原本的设计目的是用于在对象被回收前执行一些资源释放操作（如关闭文件描述符）。</li>
<li><strong>重要说明</strong>：<strong>此方法已被弃用（deprecated），从Java 9开始标记为<code>@Deprecated</code>，不推荐使用</strong>。它的执行时机是不确定的，甚至不保证一定会被执行（如果程序终止，GC可能永远不会触发）。依赖<code>finalize()</code>来释放关键资源会导致严重的性能问题和资源泄漏。正确的做法是使用<code>try-with-resources</code>语句或显式调用<code>close()</code>方法来管理资源。</li>
</ul>
<hr>
<h5 id="7-多线程相关的方法：wait-notify-notifyAll"><a href="#7-多线程相关的方法：wait-notify-notifyAll" class="headerlink" title="7. 多线程相关的方法：wait(), notify(), notifyAll()"></a>7. 多线程相关的方法：<code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code></h5><ul>
<li><strong>作用</strong>：这三个方法用于实现线程间的<strong>等待&#x2F;通知机制</strong>，是Java内置的、最基本的线程间通信方式。它们都是<code>final</code>方法，不能被重写。</li>
<li><strong>重要前提</strong>：这些方法的调用<strong>必须发生在该对象的同步代码块或同步方法中</strong>（即线程必须持有该对象的监视器锁，也称为 intrinsic lock），否则会抛出<code>IllegalMonitorStateException</code>异常。</li>
<li><code>wait()</code>：导致当前线程等待，直到其他线程调用该对象的<code>notify()</code>或<code>notifyAll()</code>方法，或者指定的时间超时。调用后，当前线程会<strong>释放持有的该对象锁</strong>。</li>
<li><code>notify()</code>：唤醒在此对象监视器上等待的<strong>单个</strong>线程。选择是任意性的。</li>
<li><code>notifyAll()</code>：唤醒在此对象监视器上等待的<strong>所有</strong>线程。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：在现代Java并发编程中，更推荐使用<code>java.util.concurrent</code>包（JUC）提供的更高级的同步工具（如<code>Lock</code>, <code>Condition</code>, <code>CountDownLatch</code>, <code>Semaphore</code>等），而不是使用这些底层的<code>wait()</code>&#x2F;<code>notify()</code>方法。</p>
</blockquote>
<hr>
<h4 id="4-1-3-最佳实践"><a href="#4-1-3-最佳实践" class="headerlink" title="4.1.3 最佳实践"></a>4.1.3 最佳实践</h4><ol>
<li><strong>总是重写<code>toString()</code></strong>：让你的对象在打印时更具可读性。</li>
<li><strong>谨慎重写<code>equals()</code>和<code>hashCode()</code></strong>：只有当需要基于内容进行相等性比较时才重写它们，并且一定要同时重写，遵守约定。IDE（如IntelliJ IDEA或Eclipse）通常可以自动生成高质量的实现。</li>
<li><strong>避免使用<code>finalize()</code>和<code>clone()</code></strong>：对于资源管理，使用<code>try-with-resources</code>；对于对象复制，考虑使用<strong>拷贝构造函数</strong>或<strong>静态工厂方法</strong>，它们比<code>clone()</code>更简单安全。</li>
</ol>
<hr>
<h3 id="4-2-内部类"><a href="#4-2-内部类" class="headerlink" title="4.2 内部类"></a>4.2 内部类</h3><p><strong>内部类是定义在另一个类内部的类</strong>。与之相对，普通的类可以称为“顶级类（Top-level Class）”。</p>
<p><strong>为什么需要内部类？</strong></p>
<ol>
<li><strong>增强封装性</strong>：可以将一个类深度隐藏在另一个类中，只为其外部类提供服务，而不被其他任何类访问。</li>
<li><strong>提高可读性和可维护性</strong>：将逻辑上属于同一组的类组织在一起，使得代码更紧凑。</li>
<li><strong>间接实现多重继承</strong>：每个内部类都可以独立地继承一个类或实现一个接口，这使得外部类实际上具备了多种能力，而避免了Java单继承的限制。</li>
<li><strong>轻松访问外部类的所有成员</strong>（包括私有成员）：这是内部类一个非常强大和方便的特性。</li>
</ol>
<hr>
<h4 id="4-2-1-成员内部类（Member-Inner-Class）"><a href="#4-2-1-成员内部类（Member-Inner-Class）" class="headerlink" title="4.2.1 成员内部类（Member Inner Class）"></a>4.2.1 成员内部类（Member Inner Class）</h4><p>这是最普通、最常见的内部类形式，类似于类的成员变量或方法。</p>
<h5 id="1-定义语法："><a href="#1-定义语法：" class="headerlink" title="1. 定义语法："></a>1. 定义语法：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;      <span class="comment">// 外部类</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;  <span class="comment">// 成员内部类</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-特点："><a href="#2-特点：" class="headerlink" title="2. 特点："></a>2. 特点：</h5><ul>
<li><strong>与实例绑定</strong>：成员内部类的实例<strong>必须</strong>依赖于一个外部类的实例才能存在。你不能先创建一个内部类对象而不先创建其外部类对象。</li>
<li><strong>访问权限</strong>：内部类可以自由访问外部类的<strong>所有成员（字段和方法），包括 <code>private</code> 私有成员</strong>。这是因为内部类被看作外部类的一个特殊成员。</li>
<li><strong>外部类访问内部类</strong>：外部类要想访问内部类的成员，则<strong>必须创建内部类的对象</strong>，然后通过这个对象来访问。</li>
</ul>
<hr>
<h5 id="3-如何实例化？"><a href="#3-如何实例化？" class="headerlink" title="3. 如何实例化？"></a>3. 如何实例化？</h5><p>在外部类<strong>外部</strong>实例化成员内部类，语法有点特殊：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OuterClass</span> <span class="variable">outerObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">OuterClass.<span class="type">InnerClass</span> <span class="variable">innerObject</span> <span class="operator">=</span> outerObject.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="4-代码示例："><a href="#4-代码示例：" class="headerlink" title="4. 代码示例："></a>4. 代码示例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">outerPrivateField</span> <span class="operator">=</span> <span class="string">&quot;Outer Private&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer Method&quot;</span>);</span><br><span class="line">        <span class="comment">// 外部类内部创建内部类对象</span></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 内部类可以直接访问外部类的私有成员</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Accessing from Inner: &quot;</span> + outerPrivateField);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 先创建外部类对象</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 通过外部类对象来创建内部类对象</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line"></span><br><span class="line">        inner.innerMethod(); <span class="comment">// 输出: Accessing from Inner: Outer Private</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 也可以在外部类的方法内部创建，如 outerMethod() 中所示</span></span><br><span class="line">        outer.outerMethod();</span><br><span class="line">        <span class="comment">// 输出:</span></span><br><span class="line">        <span class="comment">// Outer Method</span></span><br><span class="line">        <span class="comment">// Accessing from Inner: Outer Private</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-2-静态嵌套类（Static-Nested-Class）"><a href="#4-2-2-静态嵌套类（Static-Nested-Class）" class="headerlink" title="4.2.2 静态嵌套类（Static Nested Class）"></a>4.2.2 静态嵌套类（Static Nested Class）</h4><p>使用 <code>static</code> 修饰的内部类，它的行为更像一个独立的顶级类，只是被嵌套在了另一个类里面。</p>
<h5 id="1-定义语法：-1"><a href="#1-定义语法：-1" class="headerlink" title="1. 定义语法："></a>1. 定义语法：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticNestedClass</span> &#123; <span class="comment">// 静态嵌套类</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-特点：-1"><a href="#2-特点：-1" class="headerlink" title="2. 特点："></a>2. 特点：</h5><ul>
<li><strong>与类绑定</strong>：静态嵌套类<strong>不依赖于外部类的实例</strong>。你可以把它看作一个放在另一个类命名空间下的普通类。</li>
<li><strong>访问权限</strong>：静态嵌套类<strong>不能直接访问</strong>外部类的非静态成员（实例变量和方法），因为它没有对外部类实例的隐式引用。它只能访问外部类的静态成员。</li>
<li><strong>实例化方式</strong>：不需要外部类实例，直接 <code>new OuterClass.StaticNestedClass()</code>。</li>
</ul>
<hr>
<h5 id="3-代码示例："><a href="#3-代码示例：" class="headerlink" title="3. 代码示例："></a>3. 代码示例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">instanceField</span> <span class="operator">=</span> <span class="string">&quot;Instance Field&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticField</span> <span class="operator">=</span> <span class="string">&quot;Static Field&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticNested</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// System.out.println(instanceField); // 错误！不能访问非静态成员</span></span><br><span class="line">            System.out.println(staticField);      <span class="comment">// 正确！可以访问静态成员</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Static Nested Class Method&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 无需外部类实例，直接创建</span></span><br><span class="line">        Outer.<span class="type">StaticNested</span> <span class="variable">nestedObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticNested();</span><br><span class="line">        nestedObj.method(); <span class="comment">// 输出: Static Field</span></span><br><span class="line">                            <span class="comment">//       Static Nested Class Method</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-3-局部内部类（Local-Inner-Class）"><a href="#4-2-3-局部内部类（Local-Inner-Class）" class="headerlink" title="4.2.3 局部内部类（Local Inner Class）"></a>4.2.3 局部内部类（Local Inner Class）</h4><p>定义在<strong>方法</strong>或<strong>作用域块</strong>（如 <code>if</code> 块、<code>for</code> 循环内）内部的类。</p>
<h5 id="1-特点："><a href="#1-特点：" class="headerlink" title="1. 特点："></a>1. 特点：</h5><ul>
<li><strong>作用域受限</strong>：局部内部类只在定义它的方法或作用域块内可见，外界完全无法访问。</li>
<li><strong>访问外部变量</strong>：它可以访问外部类的成员。此外，从 <strong>Java 8 开始</strong>，它可以访问方法中的 <code>final</code> 或 <strong>有效最终（effectively final）</strong> 的局部变量（即变量初始化后值再未改变）。</li>
</ul>
<hr>
<h5 id="2-代码示例："><a href="#2-代码示例：" class="headerlink" title="2. 代码示例："></a>2. 代码示例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">outerField</span> <span class="operator">=</span> <span class="string">&quot;Outer field&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">localFinalVar</span> <span class="operator">=</span> <span class="string">&quot;Local Final&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">effectivelyFinalVar</span> <span class="operator">=</span> <span class="string">&quot;Effectively Final&quot;</span>; <span class="comment">// 值从未改变，也是有效的final</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalInner</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(outerField);          <span class="comment">// 可以访问外部类字段</span></span><br><span class="line">                System.out.println(localFinalVar);       <span class="comment">// 可以访问final局部变量</span></span><br><span class="line">                System.out.println(effectivelyFinalVar); <span class="comment">// 可以访问有效最终变量</span></span><br><span class="line">                <span class="comment">// effectivelyFinalVar = &quot;changed&quot;;      // 错误！如果在内部类中修改，就不再是有效最终了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只能在方法内部实例化和使用</span></span><br><span class="line">        <span class="type">LocalInner</span> <span class="variable">local</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalInner</span>();</span><br><span class="line">        local.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.someMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-4-匿名内部类（Anonymous-Inner-Class）"><a href="#4-2-4-匿名内部类（Anonymous-Inner-Class）" class="headerlink" title="4.2.4 匿名内部类（Anonymous Inner Class）"></a>4.2.4 匿名内部类（Anonymous Inner Class）</h4><p>没有名字的局部内部类。它同时完成了<strong>类的定义</strong>和<strong>对象的实例化</strong>。常用于需要快速实现一个接口或继承一个类，但不想专门写一个类文件的场景。</p>
<h5 id="1-语法："><a href="#1-语法：" class="headerlink" title="1. 语法："></a>1. 语法：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类构造器() &#123; 或 接口名() &#123; </span><br><span class="line">    <span class="comment">// 类体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-特点：-2"><a href="#2-特点：-2" class="headerlink" title="2. 特点："></a>2. 特点：</h5><ul>
<li><strong>没有名字</strong>：所以只能使用一次，用于创建一个对象。</li>
<li><strong>常用场景</strong>：<strong>事件监听</strong>、<strong>线程创建</strong>（<code>Runnable</code>）等。</li>
</ul>
<hr>
<h5 id="3-代码示例：-1"><a href="#3-代码示例：-1" class="headerlink" title="3. 代码示例："></a>3. 代码示例：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Greeting</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 实现一个接口的匿名内部类</span></span><br><span class="line">        <span class="type">Greeting</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Greeting</span>() &#123; <span class="comment">// 这里的 new 是创建接口的实现类对象</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello from Anonymous Class!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        greeting.greet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 继承一个类的匿名内部类</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123; <span class="comment">// 这里的 new 是创建Thread的子类对象</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread is running from Anonymous Class.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 更常见的写法：直接在方法参数中创建（例如创建Runnable）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Runnable from Anonymous Class.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：在Java 8+中，上述Runnable的用法通常被Lambda表达式取代：</span></span><br><span class="line">        <span class="comment">// new Thread(() -&gt; System.out.println(&quot;Runnable from Lambda.&quot;)).start();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-枚举类"><a href="#4-3-枚举类" class="headerlink" title="4.3 枚举类"></a>4.3 枚举类</h3><h4 id="4-3-1-传统的弊端"><a href="#4-3-1-传统的弊端" class="headerlink" title="4.3.1 传统的弊端"></a>4.3.1 传统的弊端</h4><p>在枚举出现之前，我们通常使用一系列 <code>static final</code> 常量来表示一组有限的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 古老的方式，存在诸多问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OldStyle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STATUS_OPEN</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STATUS_CLOSE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STATUS_PENDING</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时</span></span><br><span class="line"><span class="type">OldStyle</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OldStyle</span>();</span><br><span class="line">obj.setStatus(OldStyle.STATUS_OPEN); <span class="comment">// 这样OK</span></span><br><span class="line">obj.setStatus(<span class="number">4</span>); <span class="comment">// 编译器不会报错，但逻辑上是错误的！这就是“类型不安全”</span></span><br><span class="line">obj.setStatus(<span class="number">99</span>); <span class="comment">// 甚至是一个毫无意义的数字，运行时可能才出错</span></span><br></pre></td></tr></table></figure>

<p><strong>传统方式的缺点：</strong></p>
<ol>
<li><strong>类型不安全</strong>：<code>setStatus</code> 方法接受任何 <code>int</code> 值，即使传入一个无效的值（如 99），编译器也无法检查。</li>
<li><strong>无命名空间</strong>：常量属于类，使用时需要带上类名前缀，略显冗长。</li>
<li><strong>脆弱性</strong>：如果常量值是整数，在调试时看到的只是一个数字，可读性差。</li>
<li><strong>功能单一</strong>：常量本身只是一个值，无法附加行为（方法）。</li>
</ol>
<hr>
<h4 id="4-3-2-枚举的基本语法和本质"><a href="#4-3-2-枚举的基本语法和本质" class="headerlink" title="4.3.2 枚举的基本语法和本质"></a>4.3.2 枚举的基本语法和本质</h4><h5 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1. 基本定义"></a>1. 基本定义</h5><p>使用关键字 <code>enum</code> 来定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    OPEN,      <span class="comment">// 每个标识符都是一个枚举实例</span></span><br><span class="line">    CLOSE,     <span class="comment">// 注意：使用逗号分隔</span></span><br><span class="line">    PENDING    <span class="comment">// 最后一个可以带分号，也可以不带（如果后面没有其他代码）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-本质"><a href="#2-本质" class="headerlink" title="2. 本质"></a>2. 本质</h5><p><strong>枚举的本质是一个继承自 <code>java.lang.Enum</code> 的类</strong>。上面的 <code>Status</code> 枚举编译后，大致相当于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是JVM和编译器帮我们完成的，我们不能手动这样写</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Status</span> <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;Status&gt; &#123;</span><br><span class="line">    <span class="comment">// 在类内部预先创建好的几个公共静态常量实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Status</span> <span class="variable">OPEN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Status</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Status</span> <span class="variable">CLOSE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Status</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Status</span> <span class="variable">PENDING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Status</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造器，防止外部new操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Status</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他由Enum类继承来的方法，如values(), valueOf()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个角度看，枚举的每个常量（<code>OPEN</code>, <code>CLOSE</code>）都是该枚举类型的一个<strong>单例对象</strong>。</p>
<hr>
<h4 id="4-3-3-枚举的常用方法"><a href="#4-3-3-枚举的常用方法" class="headerlink" title="4.3.3 枚举的常用方法"></a>4.3.3 枚举的常用方法</h4><p>由于所有枚举都隐式继承自 <code>Enum</code> 类，所以它们自动拥有以下方法：</p>
<ol>
<li><code>name()</code>: 返回枚举常量的名称（String），与声明时完全一致。<strong>通常是首字母大写的单词</strong>。它是 <code>final</code> 的，不能被重写。</li>
<li><code>ordinal()</code>: 返回枚举常量的序数（int），即它在枚举声明中的位置（从 0 开始）。<strong>不建议在业务代码中依赖此值</strong>，因为它的值会随着枚举声明的顺序改变而改变。</li>
<li><code>values()</code>: 是一个静态方法，由编译器生成，返回包含该枚举所有常量的数组（<code>Status[]</code>）。</li>
<li><code>valueOf(String name)</code>: 也是一个静态方法，根据给定的名称字符串返回对应的枚举常量。如果名称不存在，会抛出 <code>IllegalArgumentException</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Status</span> <span class="variable">currentStatus</span> <span class="operator">=</span> Status.OPEN;</span><br><span class="line"></span><br><span class="line">System.out.println(currentStatus.name());      <span class="comment">// 输出: &quot;OPEN&quot;</span></span><br><span class="line">System.out.println(currentStatus.ordinal());   <span class="comment">// 输出: 0</span></span><br><span class="line"></span><br><span class="line">Status[] allStatuses = Status.values();        <span class="comment">// 返回 [OPEN, CLOSE, PENDING]</span></span><br><span class="line"><span class="type">Status</span> <span class="variable">s</span> <span class="operator">=</span> Status.valueOf(<span class="string">&quot;CLOSE&quot;</span>);            <span class="comment">// 返回 Status.CLOSE 对象</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-4-枚举的高级用法"><a href="#4-3-4-枚举的高级用法" class="headerlink" title="4.3.4 枚举的高级用法"></a>4.3.4 枚举的高级用法</h4><p>枚举远不止是常量列表，它可以像普通类一样拥有字段、构造器、方法，甚至实现接口。</p>
<h5 id="1-添加字段和自定义构造器"><a href="#1-添加字段和自定义构造器" class="headerlink" title="1. 添加字段和自定义构造器"></a>1. 添加字段和自定义构造器</h5><p>你可以为每个枚举常量附加额外的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Planet</span> &#123;</span><br><span class="line">    <span class="comment">// 调用带参数的构造器</span></span><br><span class="line">    MERCURY(<span class="number">3.303e+23</span>, <span class="number">2.4397e6</span>),</span><br><span class="line">    VENUS(<span class="number">4.869e+24</span>, <span class="number">6.0518e6</span>),</span><br><span class="line">    EARTH(<span class="number">5.976e+24</span>, <span class="number">6.37814e6</span>),</span><br><span class="line">    MARS(<span class="number">6.421e+23</span>, <span class="number">3.3972e6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字段 (final, 因为枚举常量是 immutable 的更安全)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> mass;   <span class="comment">// in kilograms</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> radius; <span class="comment">// in meters</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造器（枚举的构造器只能是 private，可省略不写）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Planet</span><span class="params">(<span class="type">double</span> mass, <span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mass = mass;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMass</span><span class="params">()</span> &#123; <span class="keyword">return</span> mass; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getRadius</span><span class="params">()</span> &#123; <span class="keyword">return</span> radius; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 甚至可以计算星球表面的重力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSurfaceGravity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">double</span> <span class="variable">G</span> <span class="operator">=</span> <span class="number">6.67300E-11</span>; <span class="comment">// 万有引力常数</span></span><br><span class="line">        <span class="keyword">return</span> G * mass / (radius * radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据体重计算在不同星球上的重量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSurfaceWeight</span><span class="params">(<span class="type">double</span> otherMass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> otherMass * getSurfaceGravity();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">Planet</span> <span class="variable">earth</span> <span class="operator">=</span> Planet.EARTH;</span><br><span class="line"><span class="type">double</span> <span class="variable">myWeightOnEarth</span> <span class="operator">=</span> earth.getSurfaceWeight(<span class="number">80</span>); <span class="comment">// 计算80kg在地球上的重量</span></span><br><span class="line">System.out.println(myWeightOnEarth);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-为每个常量添加特定行为（抽象方法）"><a href="#2-为每个常量添加特定行为（抽象方法）" class="headerlink" title="2. 为每个常量添加特定行为（抽象方法）"></a>2. 为每个常量添加特定行为（抽象方法）</h5><p>你可以定义一个抽象方法，然后让每个枚举常量都实现它。这是枚举最强大的特性之一，常用于实现<strong>状态模式</strong>或<strong>策略模式</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="comment">// 每个常量都实现了apply方法</span></span><br><span class="line">    PLUS &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123; <span class="keyword">return</span> x / y; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个抽象方法，强制每个常量都实现它</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">apply</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">Operation</span> <span class="variable">op</span> <span class="operator">=</span> Operation.PLUS;</span><br><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> op.apply(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// result = 8.0</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-实现接口"><a href="#3-实现接口" class="headerlink" title="3. 实现接口"></a>3. 实现接口</h5><p>枚举可以实现一个或多个接口，为所有常量提供统一的能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">FileCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    OPEN &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Opening file...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SAVE &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Saving file...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 实现了Command接口的execute方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-5-经典应用场景"><a href="#4-3-5-经典应用场景" class="headerlink" title="4.3.5 经典应用场景"></a>4.3.5 经典应用场景</h4><ol>
<li><p><strong>替代常量</strong>：最基础的用法，如状态、类型、模式等。</p>
</li>
<li><p><strong>单例模式（Singleton）</strong>：这是实现单例的最佳方式，绝对防止多实例化，且提供序列化机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE; <span class="comment">// 唯一的实例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加你自己的方法和字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>状态机</strong>：如订单状态（<code>NEW</code>, <code>PAID</code>, <code>SHIPPED</code>, <code>COMPLETED</code>），每个状态可以有不同的行为。</p>
</li>
<li><p><strong>策略模式</strong>：如上文的 <code>Operation</code> 例子，每个枚举常量代表一种策略。</p>
</li>
</ol>
<hr>
<h3 id="4-4-注解"><a href="#4-4-注解" class="headerlink" title="4.4 注解"></a>4.4 注解</h3><h4 id="4-4-1-概念"><a href="#4-4-1-概念" class="headerlink" title="4.4.1 概念"></a>4.4.1 概念</h4><p><strong>注解</strong>是一种形式化的元数据，它可以被添加到 Java 源代码中。它提供了一种向代码添加信息（数据）的方式，这些信息本身不是程序的一部分，但可以被其他程序（如编译器、开发工具或运行时框架）读取并用于不同的目的。</p>
<p><strong>核心思想：</strong> 注解本身没有逻辑，它的行为由处理它的代码决定。</p>
<hr>
<h4 id="4-4-2-注解的作用与用途"><a href="#4-4-2-注解的作用与用途" class="headerlink" title="4.4.2 注解的作用与用途"></a>4.4.2 注解的作用与用途</h4><p>注解的主要用途有：</p>
<ol>
<li><strong>编译检查</strong>：告诉编译器一些信息，让编译器进行基本的验证（如 <code>@Override</code>， <code>@Deprecated</code>）。</li>
<li><strong>编译时和部署时处理</strong>：在编译时，工具可以根据注解信息生成代码、配置文件或其他文件（如 Lombok, Google Auto）。APT 技术。</li>
<li><strong>运行时处理</strong>：在程序运行时，通过反射机制读取注解信息，从而执行相应的逻辑（这是最常用的一种方式，如 Spring, Hibernate, JUnit 等框架）。</li>
</ol>
<hr>
<h4 id="4-4-3-Java-内置的标准注解"><a href="#4-4-3-Java-内置的标准注解" class="headerlink" title="4.4.3 Java 内置的标准注解"></a>4.4.3 Java 内置的标准注解</h4><p>Java 本身提供了一些内置的注解。</p>
<h5 id="1-用于代码的注解"><a href="#1-用于代码的注解" class="headerlink" title="1. 用于代码的注解"></a>1. 用于代码的注解</h5><ul>
<li><p><strong><code>@Override</code></strong>： 检查该方法是否是重写父类的方法。如果不是，编译器会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@Deprecated</code></strong>： 标记该方法或类已过时，不推荐使用。编译器会生成警告。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oldMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@SuppressWarnings</code></strong>： 告诉编译器忽略特定的警告信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 可能产生未检查转换警告的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>@FunctionalInterface</code></strong> (Java 8+)： 声明一个接口是函数式接口（只能有一个抽象方法）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFunctionalInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 只能有一个抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-用于其他注解的注解（元注解）"><a href="#2-用于其他注解的注解（元注解）" class="headerlink" title="2. 用于其他注解的注解（元注解）"></a>2. 用于其他注解的注解（元注解）</h5><p>这些注解用于修饰<em>自定义注解</em>，定义了自定义注解的行为。</p>
<ul>
<li><strong><code>@Target</code></strong>： 指定注解可以应用在哪些Java元素上。<ul>
<li><code>ElementType.TYPE</code>： 类、接口、枚举</li>
<li><code>ElementType.FIELD</code>： 字段</li>
<li><code>ElementType.METHOD</code>： 方法</li>
<li><code>ElementType.PARAMETER</code>： 参数</li>
<li><code>ElementType.CONSTRUCTOR</code>： 构造器</li>
<li><code>ElementType.LOCAL_VARIABLE</code>： 局部变量</li>
<li><code>ElementType.ANNOTATION_TYPE</code>： 注解类型</li>
<li><code>ElementType.PACKAGE</code>： 包</li>
<li><code>ElementType.TYPE_PARAMETER</code> (Java 8+)： 类型参数</li>
<li><code>ElementType.TYPE_USE</code> (Java 8+)： 类型使用</li>
</ul>
</li>
<li><strong><code>@Retention</code></strong>： 指定注解的保留策略，即注解的生命周期。<ul>
<li><code>RetentionPolicy.SOURCE</code>： 仅在源代码中保留，编译器会丢弃（如 <code>@Override</code>, <code>@SuppressWarnings</code>）。</li>
<li><code>RetentionPolicy.CLASS</code>： 在 class 文件中保留，但不会被 JVM 在运行时加载（默认行为）。</li>
<li><code>RetentionPolicy.RUNTIME</code>： 在运行时可用，可以通过反射读取。这是最常用的策略，用于运行时处理。</li>
</ul>
</li>
<li><strong><code>@Documented</code></strong>： 表示该注解应该被 javadoc 工具记录，生成到 API 文档中。</li>
<li><strong><code>@Inherited</code></strong>： 表示该注解可以被继承。如果一个类用了被 <code>@Inherited</code> 修饰的注解，其子类将自动具有该注解。</li>
<li><strong><code>@Repeatable</code></strong> (Java 8+)： 表示注解可以在同一个声明上多次使用。</li>
</ul>
<hr>
<h4 id="4-4-4-如何自定义注解"><a href="#4-4-4-如何自定义注解" class="headerlink" title="4.4.4 如何自定义注解"></a>4.4.4 如何自定义注解</h4><p>使用 <code>@interface</code> 关键字来定义注解。注解的成员以无参数方法的形式声明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用元注解定义我们的自定义注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">// 只能用在方法上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 运行时保留，可通过反射读取</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyCustomAnnotation &#123;</span><br><span class="line">    <span class="comment">// 注解的成员。方法名就是参数名。</span></span><br><span class="line">    <span class="comment">// 可以使用 default 提供默认值</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;default value&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">priority</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String[] tags() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>成员的类型只能是基本类型、<code>String</code>、<code>Class</code>、<code>enum</code>、注解类型，以及这些类型的数组。</li>
<li>如果注解只有一个成员，通常命名为 <code>value()</code>。这样在使用时可以省略参数名。</li>
<li>没有默认值的成员，在使用注解时必须显式提供值。</li>
</ul>
<p><strong>使用自定义注解：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="meta">@MyCustomAnnotation(</span></span><br><span class="line"><span class="meta">        value = &quot;test method&quot;,</span></span><br><span class="line"><span class="meta">        priority = 10,</span></span><br><span class="line"><span class="meta">        tags = &#123;&quot;important&quot;, &quot;unit-test&quot;&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果只有一个 value 成员，可以简写</span></span><br><span class="line">    <span class="meta">@MyCustomAnnotation(&quot;another method&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">anotherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-4-5-如何处理注解（读取注解信息）"><a href="#4-4-5-如何处理注解（读取注解信息）" class="headerlink" title="4.4.5 如何处理注解（读取注解信息）"></a>4.4.5 如何处理注解（读取注解信息）</h4><p>定义注解本身没用，关键是如何处理它。处理方式取决于其 <code>@Retention</code> 策略。</p>
<h5 id="1-运行时处理（通过反射）"><a href="#1-运行时处理（通过反射）" class="headerlink" title="1. 运行时处理（通过反射）"></a>1. 运行时处理（通过反射）</h5><p>这是最常见的方式，主要用于框架。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 获取类的 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; clazz = MyClass.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取目标方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;testMethod&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 检查方法上是否存在指定的注解</span></span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(MyCustomAnnotation.class)) &#123;</span><br><span class="line">            <span class="comment">// 4. 获取注解实例</span></span><br><span class="line">            <span class="type">MyCustomAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> method.getAnnotation(MyCustomAnnotation.class);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 从注解实例中读取成员值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> annotation.value();</span><br><span class="line">            <span class="type">int</span> <span class="variable">priority</span> <span class="operator">=</span> annotation.priority();</span><br><span class="line">            String[] tags = annotation.tags();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Value: &quot;</span> + value);</span><br><span class="line">            System.out.println(<span class="string">&quot;Priority: &quot;</span> + priority);</span><br><span class="line">            System.out.println(<span class="string">&quot;Tags: &quot;</span> + String.join(<span class="string">&quot;, &quot;</span>, tags));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里就可以根据读取到的注解信息，执行相应的业务逻辑</span></span><br><span class="line">            <span class="comment">// 例如，根据 priority 决定执行顺序，根据 tags 进行分组测试等</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-编译时处理（APT-Annotation-Processing-Tool）"><a href="#2-编译时处理（APT-Annotation-Processing-Tool）" class="headerlink" title="2. 编译时处理（APT - Annotation Processing Tool）"></a>2. 编译时处理（APT - Annotation Processing Tool）</h5><p>更高级的用法，用于在编译期生成代码。你需要继承 <code>AbstractProcessor</code> 类并实现 <code>process</code> 方法。Lombok 库就是利用这个机制在编译时生成 getter&#x2F;setter 等方法字节码的。</p>
<hr>
<h3 id="4-5-异常处理"><a href="#4-5-异常处理" class="headerlink" title="4.5 异常处理"></a>4.5 异常处理</h3><h4 id="4-5-1-概念"><a href="#4-5-1-概念" class="headerlink" title="4.5.1 概念"></a>4.5.1 概念</h4><p>异常（Exception）是指在程序运行过程中发生的非正常事件，它中断了正常的指令流。例如：文件找不到、网络连接失败、除零错误、数组下标越界等。</p>
<p>Java 的异常处理机制通过面向对象的方式来解决这些问题，其核心思想是：<strong>将业务逻辑代码和错误处理代码分离</strong>，从而使程序更健壮、更易于维护。</p>
<hr>
<h4 id="4-5-2-分类"><a href="#4-5-2-分类" class="headerlink" title="4.5.2 分类"></a>4.5.2 分类</h4><p>Java 中所有的异常都继承自 <code>java.lang.Throwable</code> 类。其下有两个主要的子类：<code>Error</code> 和 <code>Exception</code>。</p>
<pre><code class="highlight mermaid">graph TD
    A[Throwable] --&gt; B[Error]
    A --&gt; C[Exception]

    subgraph Error
        B --&gt; D[LinkageError]
        B --&gt; E[&quot;VirtualMachineError&lt;br/&gt;如: OutOfMemoryError&quot;]
        E --&gt; F[StackOverflowError]
    end

    subgraph Exception
        C --&gt; G[IOException]
        C --&gt; H[RuntimeException]
        C --&gt; I[&quot;其他Checked Exception&lt;br/&gt;如: InterruptedException&quot;]
    end

    subgraph IOException
        G --&gt; J[FileNotFoundException]
        G --&gt; K[EOFException]
    end

    subgraph RuntimeException
        H --&gt; L[NullPointerException]
        H --&gt; M[ArrayIndexOutOfBoundsException]
        H --&gt; N[ClassCastException]
        H --&gt; O[IllegalArgumentException]
    end</code></pre>

<h5 id="1-Error-错误"><a href="#1-Error-错误" class="headerlink" title="1. Error (错误)"></a>1. Error (错误)</h5><ul>
<li><strong>定义</strong>：<code>Error</code> 及其子类表示的是<strong>严重的、程序无法处理</strong>的系统级错误。</li>
<li><strong>特点</strong>：通常是虚拟机本身的问题，如系统崩溃、虚拟机错误、内存不足等。应用程序通常无法处理或恢复这些错误，因此我们不需要捕获它们（捕获了也通常无能为力）。</li>
<li><strong>例子</strong>：<code>OutOfMemoryError</code>（内存溢出），<code>StackOverflowError</code>（栈溢出）。</li>
</ul>
<hr>
<h5 id="2-Exception-异常"><a href="#2-Exception-异常" class="headerlink" title="2. Exception (异常)"></a>2. Exception (异常)</h5><ul>
<li><strong>定义</strong>：<code>Exception</code> 及其子类表示的是<strong>程序本身可以处理</strong>的非正常情况。这是我们异常处理机制的核心。</li>
<li><strong>分类</strong>：<ul>
<li><strong>Checked Exception (受检异常)</strong>：<ul>
<li>指除了 <code>RuntimeException</code> 以外的 <code>Exception</code> 子类。</li>
<li><strong>特点</strong>：<strong>编译器会检查</strong>这类异常。意味着在编写代码时，你必须要么用 <code>try-catch</code> 语句捕获它，要么用 <code>throws</code> 子句声明抛出它，否则编译无法通过。</li>
<li><strong>例子</strong>：<code>IOException</code>, <code>SQLException</code>, <code>ClassNotFoundException</code>。这些通常是由外部因素（如文件、数据库、网络）引起的，程序应该有能力去处理（如提示用户重试）。</li>
</ul>
</li>
<li><strong>Unchecked Exception (非受检异常)</strong>：<ul>
<li>指 <code>RuntimeException</code> 及其子类。</li>
<li><strong>特点</strong>：<strong>编译器不会检查</strong>这类异常。你不需要在代码中显式地捕获或声明它们。它们通常是由程序的逻辑错误导致的，应该在开发阶段通过代码审查和测试来避免。</li>
<li><strong>例子</strong>：<code>NullPointerException</code>（空指针），<code>ArrayIndexOutOfBoundsException</code>（数组越界），<code>ClassCastException</code>（类型转换错误），<code>IllegalArgumentException</code>（非法参数）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-5-3-异常处理的关键字和机制"><a href="#4-5-3-异常处理的关键字和机制" class="headerlink" title="4.5.3 异常处理的关键字和机制"></a>4.5.3 异常处理的关键字和机制</h4><p>Java 提供了五个关键字来处理异常：<code>try</code>, <code>catch</code>, <code>finally</code>, <code>throw</code>, <code>throws</code>。</p>
<h5 id="1-try-catch-finally-块：捕获和处理异常"><a href="#1-try-catch-finally-块：捕获和处理异常" class="headerlink" title="1. try-catch-finally 块：捕获和处理异常"></a>1. try-catch-finally 块：捕获和处理异常</h5><p>这是处理异常最核心的结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能会发生异常的代码块</span></span><br><span class="line">    <span class="comment">// 如果这里的代码抛出了异常，JVM会立即跳出try块，寻找匹配的catch块</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;nonexistent.txt&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// 捕获并处理特定的异常（这里是文件未找到异常）</span></span><br><span class="line">    <span class="comment">// 可以有一个或多个catch块，用于捕获不同类型的异常</span></span><br><span class="line">    System.err.println(<span class="string">&quot;文件未找到: &quot;</span> + e.getMessage());</span><br><span class="line">    <span class="comment">// 可以在这里进行恢复操作，如提示用户、使用默认文件等</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// 捕获更一般的IOException</span></span><br><span class="line">    System.err.println(<span class="string">&quot;发生IO错误: &quot;</span> + e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 捕获所有其他异常（通常放在最后）</span></span><br><span class="line">    System.err.println(<span class="string">&quot;发生未知错误: &quot;</span> + e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，finally块中的代码都会被执行</span></span><br><span class="line">    <span class="comment">// 通常用于释放资源，如关闭文件、数据库连接、网络连接等</span></span><br><span class="line">    <span class="comment">// 这是一个可选块，但强烈推荐用于资源清理</span></span><br><span class="line">    <span class="keyword">if</span> (file != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;关闭文件时出错: &quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行流程</strong>：</p>
<ol>
<li>执行 <code>try</code> 块中的代码。</li>
<li>如果发生异常，跳转到第一个能匹配该异常类型的 <code>catch</code> 块执行。</li>
<li>无论是否发生异常或是否被捕获，最终都会执行 <code>finally</code> 块（如果存在）。</li>
</ol>
<hr>
<h5 id="2-throw：主动抛出异常"><a href="#2-throw：主动抛出异常" class="headerlink" title="2. throw：主动抛出异常"></a>2. throw：主动抛出异常</h5><p>使用 <code>throw</code> 关键字可以在代码中<strong>主动地、显式地</strong>抛出一个异常对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个异常对象并用throw抛出</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;年龄必须在0到150之间&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-throws：声明方法可能抛出的异常"><a href="#3-throws：声明方法可能抛出的异常" class="headerlink" title="3. throws：声明方法可能抛出的异常"></a>3. throws：声明方法可能抛出的异常</h5><p>当一个方法内部可能会产生<strong>受检异常（Checked Exception）</strong>，但又不打算在当前方法中处理时，可以使用 <code>throws</code> 关键字在方法签名上<strong>声明</strong>该方法可能抛出的异常类型，将异常传递给调用者去处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法声明了它可能会抛出FileNotFoundException和IOException</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, IOException &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;important.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// ... 读取文件操作</span></span><br><span class="line">    file.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>规则</strong>：</p>
<ul>
<li>对于受检异常，必须要么 <code>try-catch</code>，要么 <code>throws</code>。</li>
<li>对于非受检异常（运行时异常），使用 <code>throws</code> 声明是可选的。</li>
<li>子类重写父类方法时，其 <code>throws</code> 声明的异常不能是父类方法声明异常的父类（即子类方法抛出的异常应该更具体）。</li>
</ul>
<hr>
<h4 id="4-5-4-try-with-resources-语句（Java-7-）"><a href="#4-5-4-try-with-resources-语句（Java-7-）" class="headerlink" title="4.5.4 try-with-resources 语句（Java 7+）"></a>4.5.4 try-with-resources 语句（Java 7+）</h4><p>这是一种简化资源管理的语法糖，用于自动关闭实现了 <code>AutoCloseable</code> 或 <code>Closeable</code> 接口的资源（如 <code>InputStream</code>, <code>OutputStream</code>, <code>Connection</code> 等）。</p>
<p><strong>传统方式（繁琐）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file.txt&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            br.close(); <span class="comment">// 需要显式关闭，并且还要套一个try-catch</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 try-with-resources（简洁安全）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 资源在try后的括号中声明和创建</span></span><br><span class="line"><span class="comment">// 无论是否发生异常，资源都会在最后被自动正确关闭</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以声明多个资源，用分号隔开，它们会以<strong>相反的顺序</strong>被自动关闭。</p>
<hr>
<h4 id="4-5-5-自定义异常"><a href="#4-5-5-自定义异常" class="headerlink" title="4.5.5 自定义异常"></a>4.5.5 自定义异常</h4><p>虽然 Java 提供了丰富的异常类，但有时你需要创建特定于自己业务的异常。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li>继承 <code>Exception</code>（创建受检异常）或 <code>RuntimeException</code>（创建非受检异常）。</li>
<li>通常提供两个构造方法：一个无参构造，一个带有详细错误信息的构造方法。</li>
</ol>
<p><strong>例子</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义一个受检异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsufficientBalanceException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InsufficientBalanceException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InsufficientBalanceException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义一个非受检异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvalidInputException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvalidInputException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvalidInputException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> amount)</span> <span class="keyword">throws</span> InsufficientBalanceException &#123;</span><br><span class="line">    <span class="keyword">if</span> (amount &gt; balance) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientBalanceException</span>(<span class="string">&quot;余额不足。当前余额: &quot;</span> + balance);</span><br><span class="line">    &#125;</span><br><span class="line">    balance -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-5-6-最佳实践"><a href="#4-5-6-最佳实践" class="headerlink" title="4.5.6 最佳实践"></a>4.5.6 最佳实践</h4><ol>
<li><p><strong>只捕获你知道如何处理的异常</strong>：不要用一个空的 <code>catch</code> 块或简单地 <code>printStackTrace()</code> 来忽略异常。</p>
</li>
<li><p><strong>具体异常优先</strong>：在 <code>catch</code> 块中，先捕获最具体的异常，再捕获更一般的异常。</p>
</li>
<li><p><strong>使用非受检异常表示编程错误</strong>：如前置条件检查失败、无效参数等。</p>
</li>
<li><p><strong>使用受检异常表示可恢复的条件</strong>：如用户输入错误、外部服务暂时不可用等。</p>
</li>
<li><p><strong>尽早抛出，延迟捕获</strong>：在检测到错误的地方就抛出异常，在有能力处理这个异常的最高层才捕获它。</p>
</li>
<li><p><strong>在 finally 块或 try-with-resources 中清理资源</strong>：确保资源（文件、连接等）总能被正确释放。</p>
</li>
<li><p><strong>记录异常信息</strong>：使用日志框架（如 Log4j, SLF4J）记录异常的详细信息，而不仅仅是打印到控制台。</p>
</li>
<li><p><strong>异常转译</strong>：有时在捕获一个异常后，可以抛出一个更符合当前抽象层的自定义异常，并将原始异常作为 <code>cause</code>（通过构造方法传入）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ... 可能抛出SQLException的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyBusinessException</span>(<span class="string">&quot;保存用户信息失败&quot;</span>, e); <span class="comment">// e作为cause</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>避免在异常中暴露敏感信息</strong>：如密码、密钥等。</p>
</li>
</ol>
<hr>
<h3 id="4-6-设计模式"><a href="#4-6-设计模式" class="headerlink" title="4.6 设计模式"></a>4.6 设计模式</h3><h4 id="4-6-1-概念"><a href="#4-6-1-概念" class="headerlink" title="4.6.1 概念"></a>4.6.1 概念</h4><p>设计模式（Design Pattern）代表了<strong>最佳的实践</strong>，是众多软件开发人员在长期实践中总结和提炼出来的。它们提供了：</p>
<ol>
<li><strong>可重用性</strong>：解决特定场景下的常见设计问题。</li>
<li><strong>可维护性</strong>：使代码更易于理解和修改。</li>
<li><strong>可扩展性</strong>：使系统更容易应对未来的变化。</li>
<li><strong>共享词汇</strong>：为开发者提供了一种通用的交流语言。例如，你说“这里用个工厂模式”，大家立刻就明白了你的意图。</li>
</ol>
<hr>
<h4 id="4-6-2-分类（GoF-23种经典模式）"><a href="#4-6-2-分类（GoF-23种经典模式）" class="headerlink" title="4.6.2 分类（GoF 23种经典模式）"></a>4.6.2 分类（GoF 23种经典模式）</h4><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">目的</th>
<th align="left">包含的模式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>创建型模式</strong></td>
<td align="left"><strong>关注对象的创建过程</strong>，将对象的创建与使用分离，使系统更灵活。</td>
<td align="left">单例、工厂方法、抽象工厂、建造者、原型</td>
</tr>
<tr>
<td align="left"><strong>结构型模式</strong></td>
<td align="left"><strong>关注类和对象的组合</strong>，形成更大的结构。</td>
<td align="left">适配器、桥接、组合、装饰器、外观、享元、代理</td>
</tr>
<tr>
<td align="left"><strong>行为型模式</strong></td>
<td align="left"><strong>关注对象之间的职责分配和通信</strong>。</td>
<td align="left">责任链、命令、解释器、迭代器、中介者、备忘录、观察者、状态、策略、模板方法、访问者</td>
</tr>
</tbody></table>
<hr>
<h4 id="4-6-3-常用设计模式详解"><a href="#4-6-3-常用设计模式详解" class="headerlink" title="4.6.3  常用设计模式详解"></a>4.6.3  常用设计模式详解</h4><p>由于23种模式全部介绍篇幅过长，这里重点讲解最常用和核心的几个模式。</p>
<h5 id="1-单例模式-Singleton-Pattern"><a href="#1-单例模式-Singleton-Pattern" class="headerlink" title="1. 单例模式 (Singleton Pattern)"></a>1. 单例模式 (Singleton Pattern)</h5><p><strong>意图</strong>：保证一个类仅有一个实例，并提供一个全局访问点。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li>私有化构造方法。</li>
<li>类内部创建唯一实例。</li>
<li>提供静态方法获取该实例。</li>
</ul>
<p><strong>实现方式（线程安全的懒汉式，使用双重检查锁）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用volatile关键字确保多线程环境下的可见性和有序性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单例实例的方法</span></span><br><span class="line"><span class="comment">     * 使用双重检查锁定（Double-Checked Locking）模式确保线程安全和高性能</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Singleton实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 第一次检查：避免不必要的同步，提高性能</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 同步代码块，确保线程安全</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="comment">// 第二次检查：确保只创建一个实例</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么这么设计</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最基础的懒汉式 (线程不安全)</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 假设线程A和线程B同时调用 getInstance()</span></span><br><span class="line"><span class="comment"> * 线程A执行到 if (instance == null)，判断为 true。</span></span><br><span class="line"><span class="comment"> * 在线程A创建实例之前，CPU切换到线程B。</span></span><br><span class="line"><span class="comment"> * 线程B也执行到 if (instance == null)，由于线程A还没创建实例，所以判断也为 true。</span></span><br><span class="line"><span class="comment"> * 线程B创建了一个实例。</span></span><br><span class="line"><span class="comment"> * CPU切换回线程A，线程A继续执行，也创建了一个实例。</span></span><br><span class="line"><span class="comment"> * 都会创建新的实例，导致 instance 不是一个单例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// &lt;-- 问题点：非线程安全的检查</span></span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加锁的懒汉式 (线程安全，但性能差)</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * synchronized 锁住了整个方法。</span></span><br><span class="line"><span class="comment"> * 实际上，我们只需要在第一次创建实例时进行同步。</span></span><br><span class="line"><span class="comment"> * 一旦实例创建完毕，后续所有对 getInstance() 的调用都只是读操作，是不需要同步的。</span></span><br><span class="line"><span class="comment"> * 但这个版本中，每一次调用 getInstance() 都会进行加锁和解锁，即使 instance 已经不为 null 了。</span></span><br><span class="line"><span class="comment"> * 这在高并发场景下会造成严重的性能瓶颈。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="comment">// &lt;-- 加锁</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong>：配置管理器、线程池、数据库连接池、日志对象等。</p>
<hr>
<h5 id="2-工厂方法模式-Factory-Method-Pattern"><a href="#2-工厂方法模式-Factory-Method-Pattern" class="headerlink" title="2. 工厂方法模式 (Factory Method Pattern)"></a>2. 工厂方法模式 (Factory Method Pattern)</h5><p><strong>意图</strong>：定义一个用于创建对象的接口，但让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p>
<p><strong>关键点</strong>：将 <code>new</code> 操作封装起来，客户端不关心具体的创建细节。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 产品接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 具体产品A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using Product A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 具体产品B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using Product B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建者（工厂）抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Creator</span> &#123;</span><br><span class="line">    <span class="comment">// 工厂方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title function_">createProduct</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> createProduct();</span><br><span class="line">        product.use();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 具体创建者A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCreatorA</span> <span class="keyword">extends</span> <span class="title class_">Creator</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 具体创建者B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCreatorB</span> <span class="keyword">extends</span> <span class="title class_">Creator</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Creator</span> <span class="variable">creator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteCreatorA</span>();</span><br><span class="line">        creator.someOperation(); <span class="comment">// 输出: Using Product A</span></span><br><span class="line"></span><br><span class="line">        creator = <span class="keyword">new</span> <span class="title class_">ConcreteCreatorB</span>();</span><br><span class="line">        creator.someOperation(); <span class="comment">// 输出: Using Product B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong>：JDK 中的 <code>Calendar.getInstance()</code>, <code>NumberFormat.getInstance()</code>。框架中需要动态决定创建哪种对象时。</p>
<hr>
<h5 id="3-抽象工厂模式-Abstract-Factory-Pattern"><a href="#3-抽象工厂模式-Abstract-Factory-Pattern" class="headerlink" title="3. 抽象工厂模式 (Abstract Factory Pattern)"></a>3. 抽象工厂模式 (Abstract Factory Pattern)</h5><p><strong>意图</strong>：提供一个接口，用于创建<strong>相关或依赖对象</strong>的<strong>家族</strong>，而不需要明确指定具体类。</p>
<p><strong>关键点</strong>：是工厂的工厂，一个工厂能生产一整套产品（例如，生产一套不同风格的UI控件：按钮、文本框等）。</p>
<p><strong>简单示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产品族1：按钮</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品族2：复选框</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Checkbox</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinCheckbox</span> <span class="keyword">implements</span> <span class="title class_">Checkbox</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacCheckbox</span> <span class="keyword">implements</span> <span class="title class_">Checkbox</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line">    Button <span class="title function_">createButton</span><span class="params">()</span>;</span><br><span class="line">    Checkbox <span class="title function_">createCheckbox</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂：生产Windows风格的产品族</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WinFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> &#123; ... &#125;</span><br><span class="line"><span class="comment">// 具体工厂：生产Mac风格的产品族</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Button button;</span><br><span class="line">    <span class="keyword">private</span> Checkbox checkbox;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Application</span><span class="params">(GUIFactory factory)</span> &#123;</span><br><span class="line">        button = factory.createButton();</span><br><span class="line">        checkbox = factory.createCheckbox();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">()</span> &#123;</span><br><span class="line">        button.paint();765S</span><br><span class="line">        checkbox.paint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong>：跨平台UI开发、更换数据库驱动、更换主题等。</p>
<hr>
<h5 id="4-观察者模式-Observer-Pattern"><a href="#4-观察者模式-Observer-Pattern" class="headerlink" title="4. 观察者模式 (Observer Pattern)"></a>4. 观察者模式 (Observer Pattern)</h5><p><strong>意图</strong>：定义对象间的一种<strong>一对多</strong>的依赖关系，当一个对象（主题）的状态发生改变时，所有依赖于它的对象（观察者）都得到通知并被自动更新。</p>
<p><strong>关键点</strong>：解耦主题和观察者，使它们可以独立变化。</p>
<p><strong>示例（Java自身提供了<code>java.util.Observable</code>和<code>java.util.Observer</code>，但已过时，推荐自己实现）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主题（被观察者）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体主题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String newState)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = newState;</span><br><span class="line">        notifyObservers(); <span class="comment">// 状态改变，通知所有观察者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        observers.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteObserver</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; received: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Observer</span> <span class="variable">obs1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>(<span class="string">&quot;Observer 1&quot;</span>);</span><br><span class="line">        <span class="type">Observer</span> <span class="variable">obs2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>(<span class="string">&quot;Observer 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        subject.registerObserver(obs1);</span><br><span class="line">        subject.registerObserver(obs2);</span><br><span class="line"></span><br><span class="line">        subject.setState(<span class="string">&quot;New State!&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出:</span></span><br><span class="line">        <span class="comment">// Observer 1 received: New State!</span></span><br><span class="line">        <span class="comment">// Observer 2 received: New State!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong>：事件驱动系统、MVC架构（模型变更通知视图）、消息订阅、React&#x2F;Vue等前端框架的响应式原理。</p>
<hr>
<h5 id="5-装饰器模式-Decorator-Pattern"><a href="#5-装饰器模式-Decorator-Pattern" class="headerlink" title="5. 装饰器模式 (Decorator Pattern)"></a>5. 装饰器模式 (Decorator Pattern)</h5><p><strong>意图</strong>：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>
<p><strong>关键点</strong>：通过<strong>组合</strong>而非继承来扩展功能。装饰器和被装饰对象实现同一个接口。</p>
<p><strong>示例（Java I&#x2F;O 是装饰器模式的经典应用）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleCoffee</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">2.0</span>; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Simple Coffee&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器抽象类（实现接口并持有接口的引用）</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoffeeDecorator</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Coffee decoratedCoffee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CoffeeDecorator</span><span class="params">(Coffee coffee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.decoratedCoffee = coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> decoratedCoffee.getCost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> decoratedCoffee.getDescription();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰器：加牛奶</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithMilk</span> <span class="keyword">extends</span> <span class="title class_">CoffeeDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WithMilk</span><span class="params">(Coffee coffee)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getCost() + <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDescription() + <span class="string">&quot;, Milk&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰器：加糖</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WithSugar</span> <span class="keyword">extends</span> <span class="title class_">CoffeeDecorator</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">myCoffee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleCoffee</span>();</span><br><span class="line">        System.out.println(myCoffee.getDescription() + <span class="string">&quot; $&quot;</span> + myCoffee.getCost());</span><br><span class="line"></span><br><span class="line">        myCoffee = <span class="keyword">new</span> <span class="title class_">WithMilk</span>(myCoffee); <span class="comment">// 装饰牛奶</span></span><br><span class="line">        System.out.println(myCoffee.getDescription() + <span class="string">&quot; $&quot;</span> + myCoffee.getCost());</span><br><span class="line"></span><br><span class="line">        myCoffee = <span class="keyword">new</span> <span class="title class_">WithSugar</span>(myCoffee); <span class="comment">// 再装饰糖</span></span><br><span class="line">        System.out.println(myCoffee.getDescription() + <span class="string">&quot; $&quot;</span> + myCoffee.getCost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong>：Java I&#x2F;O 流（<code>BufferedReader</code>, <code>InputStreamReader</code> 等）、Servlet API 中的 <code>HttpServletRequestWrapper</code>。</p>
<h4 id="4-6-4-注意"><a href="#4-6-4-注意" class="headerlink" title="4.6.4 注意"></a>4.6.4 注意</h4><ol>
<li><strong>思考适用场景</strong>：不要为了用模式而用模式。在真正  需要解决特定设计问题时再考虑使用。</li>
<li><strong>避免过度设计</strong>：简单的<code>if-else</code>或<code>new</code>就能解决的问题，没必要引入复杂的模式。</li>
</ol>
<hr>
<h3 id="4-7-反射"><a href="#4-7-反射" class="headerlink" title="4.7 反射"></a>4.7 反射</h3><h4 id="4-7-1-核心思想"><a href="#4-7-1-核心思想" class="headerlink" title="4.7.1 核心思想"></a>4.7.1 核心思想</h4><p>Java反射机制允许一个正在运行的Java程序<strong>在运行时</strong>检查（introspect）和操作（manipulate）自身的内部属性。你可以把它想象成一面镜子，程序可以通过这面镜子看到自己的结构（类、方法、字段等），并且可以动态地改变这些结构。</p>
<p><strong>技术定义：</strong></p>
<p>在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种<strong>动态获取信息</strong>以及<strong>动态调用对象方法</strong>的功能被称为Java语言的反射机制。</p>
<p>正常的Java代码是在<strong>编译时</strong>就确定了要调用的类和方法。而反射则是在<strong>运行时</strong>才确定，这赋予了Java极大的灵活性和动态性。</p>
<hr>
<h4 id="4-7-2-核心组成部分"><a href="#4-7-2-核心组成部分" class="headerlink" title="4.7.2 核心组成部分"></a>4.7.2 核心组成部分</h4><p>Java的反射功能主要由<code>java.lang.Class</code>类和<code>java.lang.reflect</code>包下的一系列类来支持。</p>
<h5 id="1-java-lang-Class-类-反射的入口"><a href="#1-java-lang-Class-类-反射的入口" class="headerlink" title="1. java.lang.Class 类 (反射的入口)"></a>1. <code>java.lang.Class</code> 类 (反射的入口)</h5><p><code>Class</code>类的实例代表了Java应用程序中的类和接口。JVM中每加载一个类，都会为其创建一个对应的<code>Class</code>对象。这个对象包含了该类的完整信息，如类名、父类、接口、构造器、方法、字段等。</p>
<p><strong>获取<code>Class</code>对象</strong> 主要有三种方式：</p>
<ol>
<li><p><strong>通过对象实例获取：</strong> <code>person.getClass()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">Class&lt;?&gt; personClass1 = person.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过类名获取：</strong> <code>Person.class</code> (最安全、性能最好)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass2 = Person.class;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过类的全限定名获取：</strong> <code>Class.forName(&quot;com.example.Person&quot;)</code> (最常用，尤其是在框架中)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; personClass3 = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="2-java-lang-reflect-包"><a href="#2-java-lang-reflect-包" class="headerlink" title="2. java.lang.reflect 包"></a>2. <code>java.lang.reflect</code> 包</h5><p>这个包提供了实现反射功能的关键类：</p>
<ul>
<li><strong><code>Constructor</code></strong>: 代表类的构造方法。</li>
<li><strong><code>Method</code></strong>: 代表类的方法。</li>
<li><strong><code>Field</code></strong>: 代表类的成员变量（字段）。</li>
<li><strong><code>Modifier</code></strong>: 提供静态方法来解码由<code>getModifiers()</code>返回的访问修饰符（如 <code>public</code>, <code>private</code>, <code>static</code>）。</li>
</ul>
<hr>
<h4 id="4-7-3-主要用途"><a href="#4-7-3-主要用途" class="headerlink" title="4.7.3 主要用途"></a>4.7.3 主要用途</h4><ol>
<li><strong>动态创建对象</strong>：在运行时根据类名创建类的实例。</li>
<li><strong>动态调用方法</strong>：在运行时调用任意对象的任意方法，即使是私有方法。</li>
<li><strong>动态访问和修改字段</strong>：在运行时获取和设置任意对象的任意字段值，即使是私有字段。</li>
<li><strong>获取类的完整结构信息</strong>：获取类的父类、接口、构造器、方法、字段、注解等所有信息。</li>
</ol>
<hr>
<h4 id="4-7-4-代码示例"><a href="#4-7-4-代码示例" class="headerlink" title="4.7.4 代码示例"></a>4.7.4 代码示例</h4><p>定义一个简单的<code>Person</code>类作为示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/com/example/Person.java</span></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单的Person类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/9/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;Default&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造（私有）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I am &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有方法</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getDetails</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prefix + <span class="string">&quot;: &quot;</span> + name + <span class="string">&quot;, &quot;</span> + age + <span class="string">&quot; years old.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-获取Class对象并创建实例"><a href="#1-获取Class对象并创建实例" class="headerlink" title="1. 获取Class对象并创建实例"></a>1. 获取Class对象并创建实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 使用无参构造器创建实例 (推荐方式)</span></span><br><span class="line">Constructor&lt;?&gt; constructor = personClass.getConstructor();</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> (Person) constructor.newInstance();</span><br><span class="line">System.out.println(person1); <span class="comment">// Person&#123;name=&#x27;Default&#x27;, age=0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用私有构造器创建实例</span></span><br><span class="line">Constructor&lt;?&gt; privateConstructor = personClass.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">privateConstructor.setAccessible(<span class="literal">true</span>); <span class="comment">// **关键：解除私有访问限制**</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> (Person) privateConstructor.newInstance(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line">System.out.println(person2); <span class="comment">// Person&#123;name=&#x27;Alice&#x27;, age=25&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: <code>Class.newInstance()</code> 方法在Java 9中已被废弃，因为它只能调用无参构造器且异常处理不明确。推荐使用<code>getConstructor().newInstance()</code>。</p>
<hr>
<h5 id="2-访问和修改字段"><a href="#2-访问和修改字段" class="headerlink" title="2. 访问和修改字段"></a>2. 访问和修改字段</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) personClass.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 访问公有字段 &#x27;age&#x27;</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">ageField</span> <span class="operator">=</span> personClass.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">ageField.set(person, <span class="number">30</span>); <span class="comment">// person.age = 30;</span></span><br><span class="line">System.out.println(<span class="string">&quot;Public age: &quot;</span> + person.age); <span class="comment">// Public age: 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 访问私有字段 &#x27;name&#x27;</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> personClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">nameField.setAccessible(<span class="literal">true</span>); <span class="comment">// **关键：解除私有访问限制**</span></span><br><span class="line">nameField.set(person, <span class="string">&quot;Bob&quot;</span>); <span class="comment">// person.name = &quot;Bob&quot;;</span></span><br><span class="line">System.out.println(<span class="string">&quot;Private name: &quot;</span> + nameField.get(person)); <span class="comment">// Private name: Bob</span></span><br></pre></td></tr></table></figure>

<p><strong><code>getField()</code> vs <code>getDeclaredField()</code></strong>:</p>
<ul>
<li><code>getField()</code>: 获取<strong>公有</strong>字段（包括从父类继承的）。</li>
<li><code>getDeclaredField()</code>: 获取<strong>任意</strong>访问修饰符的字段，但<strong>仅限当前类</strong>声明的。</li>
</ul>
<hr>
<h5 id="3-调用方法"><a href="#3-调用方法" class="headerlink" title="3. 调用方法"></a>3. 调用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personClass = Class.forName(<span class="string">&quot;com.example.Person&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) personClass.getConstructor().newInstance();</span><br><span class="line">person.age = <span class="number">40</span>; <span class="comment">// 为了演示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 调用公有方法 &#x27;sayHello&#x27;</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">sayHelloMethod</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;sayHello&quot;</span>);</span><br><span class="line">sayHelloMethod.invoke(person); <span class="comment">// Hello, I am Default</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 调用私有方法 &#x27;getDetails&#x27;</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">getDetailsMethod</span> <span class="operator">=</span> personClass.getDeclaredMethod(<span class="string">&quot;getDetails&quot;</span>, String.class);</span><br><span class="line">getDetailsMethod.setAccessible(<span class="literal">true</span>); <span class="comment">// **关键：解除私有访问限制**</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> getDetailsMethod.invoke(person, <span class="string">&quot;Details&quot;</span>);</span><br><span class="line">System.out.println(result); <span class="comment">// Details: Default, 40 years old.</span></span><br></pre></td></tr></table></figure>

<p><strong><code>getMethod()</code> vs <code>getDeclaredMethod()</code></strong>:</p>
<ul>
<li><code>getMethod(name, paramTypes)</code>: 获取<strong>公有</strong>方法（包括从父类继承的）。</li>
<li><code>getDeclaredMethod(name, paramTypes)</code>: 获取<strong>任意</strong>访问修饰符的方法，但<strong>仅限当前类</strong>声明的。</li>
</ul>
<p><code>invoke(Object obj, Object... args)</code> 方法：</p>
<ul>
<li><code>obj</code>: 要调用该方法的对象实例。如果方法是静态的，则此参数为 <code>null</code>。</li>
<li><code>args</code>: 传递给方法的参数。</li>
</ul>
<hr>
<h4 id="4-7-5-优缺点"><a href="#4-7-5-优缺点" class="headerlink" title="4.7.5 优缺点"></a>4.7.5 优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li><strong>灵活性和动态性</strong>：这是反射最大的优点。它允许程序在运行时创建对象、调用方法，大大提高了程序的灵活性，特别适合用于编写通用性强的框架和库。</li>
<li><strong>解耦</strong>：反射可以降低代码的耦合度。例如，通过配置文件指定要加载的类，程序就可以在不修改源码的情况下更换具体实现。</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li><strong>性能开销</strong>：反射操作涉及到动态解析类信息，方法调用绕过了常规的JVM优化（如JIT编译），因此其性能远低于直接调用。频繁使用反射会严重影响程序性能。</li>
<li><strong>破坏封装性</strong>：反射可以访问和修改类的私有成员（通过<code>setAccessible(true)</code>），这违背了面向对象的封装原则，可能导致代码逻辑混乱和安全问题。</li>
<li><strong>类型不安全</strong>：反射操作在编译时无法进行类型检查，所有类型错误都只能在运行时才能发现，这增加了运行时错误的风险。</li>
<li><strong>代码可读性差</strong>：大量使用反射的代码通常比常规代码更复杂、更难阅读和维护。</li>
</ol>
<hr>
<h4 id="4-7-6-真实应用场景"><a href="#4-7-6-真实应用场景" class="headerlink" title="4.7.6 真实应用场景"></a>4.7.6 真实应用场景</h4><p>尽管有缺点，反射在许多场景下是不可或缺的。</p>
<ol>
<li><strong>框架开发</strong>：<ul>
<li><strong>Spring&#x2F;Spring Boot</strong>：其核心功能如**依赖注入（DI）<strong>和</strong>面向切面编程（AOP）**都大量使用了反射。Spring容器通过读取配置（XML或注解）来动态创建对象（Bean）并注入其依赖。</li>
<li><strong>ORM框架（Hibernate, MyBatis）</strong>：通过反射读取实体类的注解和字段，自动将数据库记录映射为Java对象。</li>
</ul>
</li>
<li><strong>动态代理</strong>：Java的<code>java.lang.reflect.Proxy</code>类就是基于反射来创建动态代理对象的。</li>
<li><strong>注解处理器</strong>：在运行时，可以通过反射获取类、方法或字段上的注解信息，并根据注解执行相应的逻辑。例如，JUnit就是通过反射查找带有<code>@Test</code>注解的方法来执行测试。</li>
<li><strong>JDBC驱动加载</strong>：在早期的JDBC中，<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>就是通过反射来加载和注册数据库驱动的。</li>
</ol>
<p><strong>使用原则</strong>：应避免在业务逻辑的性能敏感路径上滥用反射。它更适合用在框架、库和需要高度动态性的底层代码中。在能用常规方式解决问题时，尽量不要使用反射。</p>
<hr>
<h3 id="4-8-动态代理"><a href="#4-8-动态代理" class="headerlink" title="4.8 动态代理"></a>4.8 动态代理</h3><h4 id="4-8-1-代理模式"><a href="#4-8-1-代理模式" class="headerlink" title="4.8.1 代理模式"></a>4.8.1 代理模式</h4><p>代理模式的核心思想是：<strong>为其他对象提供一种代理以控制对这个对象的访问</strong>。</p>
<p>你可以把代理想象成一个“中介”或“经纪人”。你不想直接和某个对象（目标对象）打交道，而是通过这个中介。这个中介可以在你和目标对象交互的<strong>前后</strong>做一些额外的事情。</p>
<p>***注：*<em>动态代理在实际业务开发中使用不多，但很重要要体会他的思想</em></p>
<hr>
<h4 id="4-8-2-静态代理与动态代理"><a href="#4-8-2-静态代理与动态代理" class="headerlink" title="4.8.2 静态代理与动态代理"></a>4.8.2 静态代理与动态代理</h4><h5 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1. 静态代理"></a>1. 静态代理</h5><p><strong>特点</strong>：代理类是在<strong>编译时</strong>就创建好的。程序员需要手动为每一个需要被代理的接口或类编写一个代理类。</p>
<p><strong>实现步骤</strong>：</p>
<ol>
<li>定义一个接口（例如 <code>UserService</code>）。</li>
<li>创建一个实现该接口的目标类（<code>UserServiceImpl</code>）。</li>
<li>创建一个实现该接口的代理类（<code>UserServiceProxy</code>），代理类内部持有目标类的实例。</li>
<li>在代理类的方法中，调用目标类的同名方法，并在调用前后添加附加逻辑。</li>
</ol>
<p><strong>示例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 目标类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据库：添加用户 &quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 静态代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService target; <span class="comment">// 持有目标对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceProxy</span><span class="params">(UserService target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--- 事务开始 ---&quot;</span>); <span class="comment">// 增强逻辑</span></span><br><span class="line">        target.addUser(username); <span class="comment">// 调用目标方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--- 事务提交 ---&quot;</span>); <span class="comment">// 增强逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceProxy</span>(target);</span><br><span class="line">        proxy.addUser(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态代理的缺点</strong>：</p>
<ul>
<li><strong>类爆炸</strong>：如果需要代理的接口很多，就需要为每个接口编写一个代理类，导致类数量急剧增加。</li>
<li><strong>代码重复</strong>：所有代理类的逻辑（如事务、日志）都是相似的，导致大量重复代码。</li>
<li><strong>不易维护</strong>：如果接口增加一个方法，目标类和代理类都需要修改。</li>
</ul>
<hr>
<h5 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2. 动态代理"></a>2. 动态代理</h5><p><strong>特点</strong>：代理类是在<strong>运行时</strong>动态生成的，而不是在编译时。我们不需要手动编写代理类，而是通过Java提供的API来动态创建一个代理对象。</p>
<p><strong>核心思想</strong>：我们不再关心代理类的具体形态，而是只关心在代理过程中需要执行的<strong>附加逻辑（Advice）</strong>。这个逻辑被封装在一个统一的处理器中。</p>
<p>动态代理解决了静态代理的所有缺点，实现了对任意接口的通用代理。</p>
<hr>
<h4 id="4-8-3-Java中的动态代理实现"><a href="#4-8-3-Java中的动态代理实现" class="headerlink" title="4.8.3 Java中的动态代理实现"></a>4.8.3 Java中的动态代理实现</h4><p>Java生态中主要有两种实现动态代理的方式：<strong>JDK动态代理</strong> 和 <strong>CGLIB动态代理</strong>。</p>
<h5 id="1-JDK动态代理"><a href="#1-JDK动态代理" class="headerlink" title="1. JDK动态代理"></a>1. JDK动态代理</h5><p>这是Java官方提供的实现方式，位于 <code>java.lang.reflect</code> 包下。</p>
<p><strong>核心组件</strong>：</p>
<ol>
<li><strong><code>java.lang.reflect.Proxy</code></strong>: 这是创建代理对象的工厂类。最重要的方法是 <code>newProxyInstance()</code>。</li>
<li><strong><code>java.lang.reflect.InvocationHandler</code></strong>: 这是一个接口。我们需要编写一个实现该接口的类，这个类就是我们之前提到的“附加逻辑”的封装。所有对代理对象的方法调用，都会被转发到这个 <code>InvocationHandler</code> 的 <code>invoke</code> 方法中。</li>
</ol>
<p><strong>实现要求</strong>：</p>
<ul>
<li><strong>目标类必须实现一个或多个接口</strong>。JDK动态代理是基于接口的。</li>
</ul>
<p><strong>实现步骤</strong>：</p>
<ol>
<li><strong>定义一个接口和目标类</strong>（同静态代理）。</li>
<li><strong>创建一个 <code>InvocationHandler</code> 实现类</strong>。在这个类的 <code>invoke</code> 方法中编写统一的代理逻辑。</li>
<li><strong>使用 <code>Proxy.newProxyInstance()</code> 方法创建代理对象</strong>。</li>
<li>通过代理对象调用方法。</li>
</ol>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 接口和目标类（与静态代理相同）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String username)</span>;</span><br><span class="line">    String <span class="title function_">findUser</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据库：添加用户 &quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findUser</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据库：查找用户ID &quot;</span> + id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建 InvocationHandler</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target; <span class="comment">// 目标对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  动态生成的代理对象本身（很少使用）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被调用的方法对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   调用方法时传入的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 方法的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--- 日志：方法 &quot;</span> + method.getName() + <span class="string">&quot; 开始执行 ---&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标对象的原始方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--- 日志：方法 &quot;</span> + method.getName() + <span class="string">&quot; 执行完毕 ---&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkDynamicProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建目标对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建 InvocationHandler</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 使用 Proxy.newProxyInstance() 创建代理对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (UserService) Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载器</span></span><br><span class="line">            target.getClass().getInterfaces(),   <span class="comment">// 目标类实现的接口数组</span></span><br><span class="line">            handler                              <span class="comment">// InvocationHandler 实例</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 通过代理对象调用方法</span></span><br><span class="line">        proxyInstance.addUser(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> proxyInstance.findUser(<span class="number">101</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;找到的用户是: &quot;</span> + user);</span><br><span class="line">        </span><br><span class="line">        System.out.println(proxyInstance.getClass()); <span class="comment">// class com.sun.proxy.$Proxy0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-CGLIB动态代理"><a href="#2-CGLIB动态代理" class="headerlink" title="2. CGLIB动态代理"></a>2. CGLIB动态代理</h5><p>CGLIB (Code Generation Library) 是一个强大的、高性能的代码生成库。它被广泛应用于许多框架中（如Spring、Hibernate），用于在运行时扩展Java类和实现AOP。</p>
<p><strong>核心思想</strong>：</p>
<p>CGLIB通过<strong>继承</strong>的方式来实现代理。它在运行时动态地生成一个目标类的<strong>子类</strong>，并重写父类（目标类）中的非final方法，在重写的方法中织入增强逻辑。</p>
<p><strong>核心组件</strong>：</p>
<ol>
<li><strong><code>net.sf.cglib.proxy.Enhancer</code></strong>: 类似于JDK的<code>Proxy</code>类，是创建代理对象的入口。</li>
<li><strong><code>net.sf.cglib.proxy.MethodInterceptor</code></strong>: 类似于JDK的<code>InvocationHandler</code>，用于定义拦截逻辑。</li>
</ol>
<p><strong>实现要求</strong>：</p>
<ul>
<li><strong>目标类不能是 <code>final</code> 的</strong>。因为CGLIB需要继承这个类。</li>
<li>被代理的方法不能是 <code>final</code> 或 <code>static</code> 的。</li>
</ul>
<p><strong>代码示例</strong> (需要添加CGLIB依赖)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Maven 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标类（没有实现任何接口）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据库：创建订单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123; <span class="comment">// final 方法无法被代理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;数据库：获取订单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MethodInterceptor 实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj    代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被拦截的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  用于调用父类（目标类）的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt; 权限检查开始 &gt;&gt;&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用父类（目标类）的原始方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;&lt;&lt; 权限检查结束 &lt;&lt;&lt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建 Enhancer 对象</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 2. 设置父类（目标类）</span></span><br><span class="line">        enhancer.setSuperclass(OrderService.class);</span><br><span class="line">        <span class="comment">// 3. 设置回调（MethodInterceptor）</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MyMethodInterceptor</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 创建代理对象</span></span><br><span class="line">        <span class="type">OrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (OrderService) enhancer.create();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 调用方法</span></span><br><span class="line">        proxy.createOrder();</span><br><span class="line">        proxy.getOrder(); <span class="comment">// final 方法不会被拦截，直接调用原始方法</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(proxy.getClass()); <span class="comment">// class com.example.OrderService$$EnhancerByCGLIB$$...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-8-4-总结"><a href="#4-8-4-总结" class="headerlink" title="4.8.4 总结"></a>4.8.4 总结</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">JDK 动态代理</th>
<th align="left">CGLIB 动态代理</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>实现原理</strong></td>
<td align="left">基于<strong>接口</strong>，运行时动态生成接口的实现类。</td>
<td align="left">基于<strong>继承</strong>，运行时动态生成目标类的子类。</td>
</tr>
<tr>
<td align="left"><strong>代理对象要求</strong></td>
<td align="left">目标类必须实现至少一个接口。</td>
<td align="left">目标类不能是<code>final</code>类，被代理的方法不能是<code>final</code>或<code>static</code>。</td>
</tr>
<tr>
<td align="left"><strong>依赖</strong></td>
<td align="left">Java JDK 自带，无需额外依赖。</td>
<td align="left">需要引入第三方CGLIB库。</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">在早期版本中，性能略低于CGLIB。但在现代JDK版本中，通过不断优化，两者性能差距已经非常小，有时JDK代理甚至更快。</td>
<td align="left">传统上认为性能更高，因为它通过方法索引直接调用，而非反射。</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">适用于目标对象有接口的情况。</td>
<td align="left">适用于没有接口，但需要代理的普通类。</td>
</tr>
</tbody></table>
<p><strong>Spring AOP中的选择</strong>：</p>
<p>Spring AOP会智能地在这两者之间进行选择：</p>
<ul>
<li>如果目标对象<strong>实现了接口</strong>，Spring默认使用<strong>JDK动态代理</strong>。</li>
<li>如果目标对象<strong>没有实现接口</strong>，Spring会使用<strong>CGLIB动态代理</strong>。</li>
<li>你也可以强制Spring全部使用CGLIB代理（通过配置<code>proxy-target-class=&quot;true&quot;</code>）。</li>
</ul>
<hr>
<h4 id="4-8-5-真实应用场景"><a href="#4-8-5-真实应用场景" class="headerlink" title="4.8.5 真实应用场景"></a>4.8.5 真实应用场景</h4><p>动态代理是实现许多高级功能的核心技术，尤其是在**面向切面编程（AOP）**中。</p>
<ol>
<li><strong>Spring AOP</strong>：实现事务管理（<code>@Transactional</code>）、日志记录、权限控制、性能监控等横切关注点。</li>
<li><strong>RPC 框架</strong>：如Dubbo、gRPC的客户端，你调用的远程服务接口实际上是一个本地的代理对象，该代理对象负责网络通信、序列化等底层细节。</li>
<li><strong>ORM 框架</strong>：如MyBatis，你编写的Mapper接口并没有实现类，MyBatis通过动态代理为你生成一个实现类，该类负责执行SQL语句。</li>
<li><strong>数据库连接池</strong>：当调用<code>connection.close()</code>时，连接池并不会真正关闭物理连接，而是通过代理将连接归还给连接池。</li>
</ol>
<hr>
<h2 id="5-综合与对比"><a href="#5-综合与对比" class="headerlink" title="5. 综合与对比"></a>5. 综合与对比</h2><h3 id="5-1-抽象类-Abstract-Class-vs-接口-Interface"><a href="#5-1-抽象类-Abstract-Class-vs-接口-Interface" class="headerlink" title="5.1 抽象类 (Abstract Class) vs 接口 (Interface)"></a>5.1 抽象类 (Abstract Class) vs 接口 (Interface)</h3><p>自从 Java 8 引入默认方法和静态方法，以及 Java 9 引入私有方法后，接口的能力大大增强。以下是它们在现代 Java 中的对比。</p>
<table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left">抽象类 (Abstract Class)</th>
<th align="left">接口 (Interface)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>设计目的</strong></td>
<td align="left">表示 <strong>“是一个 (IS-A)”</strong> 关系。代码复用，为相关类提供模板。</td>
<td align="left">表示 <strong>“具有某种能力 (CAN-DO)”</strong> 关系。定义行为契约，实现多继承。</td>
</tr>
<tr>
<td align="left"><strong>方法</strong></td>
<td align="left">可以包含<strong>抽象方法</strong>和<strong>具体实现的方法</strong>。</td>
<td align="left">Java 8以前：只能是<strong>抽象方法</strong>。 Java 8+：可包含 <strong><code>abstract</code></strong>, <strong><code>default</code></strong>, <strong><code>static</code></strong> 方法。 Java 9+：可包含 <strong><code>private</code></strong> 方法。</td>
</tr>
<tr>
<td align="left"><strong>成员变量</strong></td>
<td align="left">可以是<strong>常量</strong>、<strong>普通成员变量</strong>（各种访问权限）。</td>
<td align="left">默认且只能是 <code>public static final</code> 的<strong>常量</strong>（即静态常量）。</td>
</tr>
<tr>
<td align="left"><strong>构造器</strong></td>
<td align="left"><strong>有构造器</strong>（但不能直接实例化，用于子类初始化）。</td>
<td align="left"><strong>没有构造器</strong>。</td>
</tr>
<tr>
<td align="left"><strong>继承</strong></td>
<td align="left"><strong>单继承</strong>：一个子类只能继承<strong>一个</strong>抽象类。</td>
<td align="left"><strong>多实现</strong>：一个类可以实现<strong>多个</strong>接口。</td>
</tr>
<tr>
<td align="left"><strong>访问修饰符</strong></td>
<td align="left">方法可以使用任意访问修饰符（<code>public</code>, <code>protected</code>, <code>private</code>）。</td>
<td align="left">在 Java 9 之前，方法默认且只能是 <code>public</code>。Java 9 后 <code>private</code> 方法可用。</td>
</tr>
</tbody></table>
<p><strong>如何选择？</strong></p>
<ul>
<li>如果你要定义一些类的模板，强调代码复用和“是一个”的关系，使用<strong>抽象类</strong>。</li>
<li>如果你要定义一种行为契约，让毫不相干的类都能拥有某种能力，或者需要实现多继承，使用<strong>接口</strong>。</li>
</ul>
<hr>
<h3 id="5-2-重载-Overload-vs-重写-Override"><a href="#5-2-重载-Overload-vs-重写-Override" class="headerlink" title="5.2 重载 (Overload) vs 重写 (Override)"></a>5.2 重载 (Overload) vs 重写 (Override)</h3><table>
<thead>
<tr>
<th align="left">特性维度</th>
<th align="left">重载 (Overload)</th>
<th align="left">重写 (Override)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>定义</strong></td>
<td align="left">同一个类中，方法名相同，但<strong>参数列表不同</strong>。</td>
<td align="left">子类中定义一个与父类<strong>方法签名完全相同</strong>的方法。</td>
</tr>
<tr>
<td align="left"><strong>范围</strong></td>
<td align="left">发生在<strong>同一个类</strong>内部。</td>
<td align="left">发生在<strong>继承体系</strong>的子类与父类之间。</td>
</tr>
<tr>
<td align="left"><strong>参数列表</strong></td>
<td align="left"><strong>必须不同</strong>（类型、个数、顺序至少有一个不同）。</td>
<td align="left"><strong>必须完全相同</strong>。</td>
</tr>
<tr>
<td align="left"><strong>返回类型</strong></td>
<td align="left">可以相同也可以<strong>不同</strong>。</td>
<td align="left">返回类型必须<strong>相同</strong>或是父类方法返回类型的<strong>子类</strong>（协变返回类型）。</td>
</tr>
<tr>
<td align="left"><strong>异常</strong></td>
<td align="left">对抛出异常<strong>没有要求</strong>。</td>
<td align="left">子类方法抛出的异常必须和父类方法抛出的异常<strong>相同</strong>，或者是其<strong>子类</strong>，或者<strong>更少</strong>（更不通用）。</td>
</tr>
<tr>
<td align="left"><strong>访问权限</strong></td>
<td align="left">访问修饰符可以<strong>不同</strong>。</td>
<td align="left">子类方法的访问权限不能比父类方法<strong>更严格</strong>（例如，父类是<code>protected</code>，子类可以是<code>public</code>，但不能是<code>private</code>）。</td>
</tr>
<tr>
<td align="left"><strong>调用</strong></td>
<td align="left">编译器在<strong>编译期</strong>根据方法的<strong>签名（方法名+参数）</strong> 来确定调用哪个方法。</td>
<td align="left">JVM 在<strong>运行期</strong>根据对象的<strong>实际类型</strong>（而不是引用类型）来确定调用哪个方法（多态的核心）。</td>
</tr>
</tbody></table>
<p><strong>简单记忆：</strong></p>
<ul>
<li><strong>重载 (Overload)</strong>：<strong>横向</strong>的，同类之间的“多个版本”。</li>
<li><strong>重写 (Override)</strong>：<strong>纵向</strong>的，父子类之间的“覆盖更新”。</li>
</ul>
<hr>
<h3 id="5-3-和-equals-的区别"><a href="#5-3-和-equals-的区别" class="headerlink" title="5.3 == 和 equals() 的区别"></a>5.3 <code>==</code> 和 <code>equals()</code> 的区别</h3><table>
<thead>
<tr>
<th align="left">操作符&#x2F;方法</th>
<th align="left"><code>==</code></th>
<th align="left"><code>equals()</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>本质</strong></td>
<td align="left">是一个<strong>操作符</strong>。</td>
<td align="left">是一个<strong>方法</strong>，定义在 <code>Object</code> 类中。</td>
</tr>
<tr>
<td align="left"><strong>比较对象</strong></td>
<td align="left">比较两个变量保存的<strong>值</strong>。</td>
<td align="left">默认行为（未重写时）与 <code>==</code> 完全相同，比较两个对象的<strong>内存地址</strong>。</td>
</tr>
<tr>
<td align="left"><strong>作用</strong></td>
<td align="left">1. 比较<strong>基本数据类型</strong>：比较它们的<strong>数值</strong>是否相等。 2. 比较<strong>引用类型</strong>：比较两个引用是否指向<strong>同一个对象</strong>（即内存地址是否相同）。</td>
<td align="left">用于比较两个<strong>对象</strong>在<strong>逻辑上</strong>是否“相等”（例如，两个String对象的内容是否相同）。</td>
</tr>
<tr>
<td align="left"><strong>可定制性</strong></td>
<td align="left"><strong>不可定制</strong>，行为由语言本身定义。</td>
<td align="left"><strong>可重写</strong>，类可以根据自己的业务逻辑来定义怎样的两个对象才算“相等”（如<code>String</code>, <code>Integer</code>等类都已重写）。</td>
</tr>
</tbody></table>
<p><strong>核心总结：</strong></p>
<ul>
<li><code>==</code> 永远比较的是<strong>值</strong>。对于引用，这个值就是<strong>内存地址</strong>。</li>
<li><code>equals()</code> 的默认行为是比较<strong>内存地址</strong>，但可以被重写为比较<strong>对象内容</strong>。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);      <span class="comment">// false，比较地址，两个不同的对象</span></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true，比较内容，内容都是&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-4-值传递和引用传递：Java中只有值传递！"><a href="#5-4-值传递和引用传递：Java中只有值传递！" class="headerlink" title="5.4 值传递和引用传递：Java中只有值传递！"></a>5.4 值传递和引用传递：Java中只有值传递！</h3><p>这是一个非常重要的概念，也是常见的误解。</p>
<h4 id="5-4-1-核心结论："><a href="#5-4-1-核心结论：" class="headerlink" title="5.4.1 核心结论："></a>5.4.1 核心结论：</h4><p><strong>Java中只有值传递（Pass by Value），没有引用传递（Pass by Reference）。</strong></p>
<hr>
<h4 id="5-4-2-如何理解："><a href="#5-4-2-如何理解：" class="headerlink" title="5.4.2 如何理解："></a>5.4.2 如何理解：</h4><ol>
<li><p><strong>基本数据类型作为参数</strong>：<br>传递的是该变量的<strong>值的拷贝</strong>。在方法内部修改参数值，<strong>不会影响</strong>原始变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">changeValue</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    x = <span class="number">10</span>; <span class="comment">// 修改的是拷贝的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">changeValue(num);</span><br><span class="line">System.out.println(num); <span class="comment">// 输出 5，原始值未改变</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用数据类型（对象）作为参数</strong>：<br>传递的是该<strong>引用的值的拷贝</strong>（即对象内存地址的拷贝）。</p>
<ul>
<li>因为两个引用（原始引用和拷贝后的引用）指向的是<strong>同一个对象</strong>，所以通过这个拷贝的引用<strong>修改对象的状态</strong>（例如修改对象的成员变量），会影响到原始引用所指向的对象。</li>
<li>但是，如果试图在方法内部<strong>改变拷贝引用的指向</strong>（让它指向一个新对象），这个改变<strong>不会影响</strong>到原始的引用，原始引用依然指向原来的对象。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5-4-3-示例与图解："><a href="#5-4-3-示例与图解：" class="headerlink" title="5.4.3 示例与图解："></a>5.4.3 示例与图解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// 方法参数是一个MyClass类型的引用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modifyObject</span><span class="params">(MyClass ref)</span> &#123;</span><br><span class="line">        ref.value = <span class="number">100</span>; <span class="comment">// 动作1：通过拷贝的引用修改对象状态（有效）</span></span><br><span class="line">        ref = <span class="keyword">new</span> <span class="title class_">MyClass</span>(); <span class="comment">// 动作2：让拷贝的引用指向一个新对象（无效！）</span></span><br><span class="line">        ref.value = <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        obj.value = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before: &quot;</span> + obj.value); <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line">        modifyObject(obj);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;After: &quot;</span> + obj.value); <span class="comment">// 输出 100，而不是50或1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内存图解：</strong></p>
<ol>
<li><code>main</code>方法中<code>obj</code>创建，指向对象A（<code>value=1</code>）。</li>
<li>调用<code>modifyObject(obj)</code>，将<code>obj</code>的值（对象A的地址）<strong>拷贝</strong>给形参<code>ref</code>。现在<code>obj</code>和<code>ref</code>都指向对象A。</li>
<li><strong>动作1</strong>：<code>ref.value = 100;</code> 通过<code>ref</code>找到对象A，将其<code>value</code>改为100。此时对象A的<code>value</code>变为100。</li>
<li><strong>动作2</strong>：<code>ref = new MyClass();</code> 让<code>ref</code>这个<strong>拷贝的引用</strong>指向了一个全新的对象B。<code>ref</code>和<code>obj</code>不再指向同一个对象。后续对<code>ref.value</code>的修改只影响对象B。</li>
<li>方法调用结束，形参<code>ref</code>生命周期结束被销毁。<code>obj</code>依然指向已经被修改过的对象A（<code>value=100</code>）。对象B因失去引用将被GC回收。</li>
</ol>
<p><strong>最终结论：</strong> Java中对象作为参数传递时，传递的是引用的副本（值），而不是引用本身。因此，可以修改原对象的内容，但无法让原引用指向新的对象。这完美地证明了Java是<strong>值传递</strong>。</p>
<hr>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%BA%8C%E3%80%81%E6%95%B0%E7%BB%84&%E5%AD%97%E7%AC%A6%E4%B8%B2&%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%BA%8C%E3%80%81%E6%95%B0%E7%BB%84&%E5%AD%97%E7%AC%A6%E4%B8%B2&%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" class="post-title-link" itemprop="url">二、数组&字符串&内存分配</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-06 18:05:00" itemprop="dateCreated datePublished" datetime="2025-09-06T18:05:00+08:00">2025-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 11:08:12" itemprop="dateModified" datetime="2025-10-17T11:08:12+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/" itemprop="url" rel="index"><span itemprop="name">基础核心层</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="二、数组-字符串-内存分配"><a href="#二、数组-字符串-内存分配" class="headerlink" title="二、数组&amp;字符串&amp;内存分配"></a>二、数组&amp;字符串&amp;内存分配</h1><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h2><h3 id="1-1-数组的核心特性"><a href="#1-1-数组的核心特性" class="headerlink" title="1.1 数组的核心特性"></a>1.1 数组的核心特性</h3><p><strong>定义</strong>：数组是一种用于存储<strong>固定大小的</strong>、<strong>相同类型元素</strong>的线性数据结构。</p>
<p><strong>核心特点</strong>：</p>
<ol>
<li><strong>固定长度</strong>：一旦数组被创建，其长度就不可改变。</li>
<li><strong>相同类型</strong>：数组中的所有元素必须是相同的数据类型（无论是基本类型还是引用类型）。</li>
<li><strong>内存连续</strong>：数组在内存中占据一块连续的空间，这使得通过索引访问元素非常高效（时间复杂度为 O(1)）。</li>
<li><strong>索引访问</strong>：每个元素都有一个从 0 开始的数字索引，通过索引可以快速访问或修改对应的元素。</li>
<li><strong>是对象</strong>：在 Java 中，数组是<strong>对象</strong>（即使它存储的是基本数据类型）。它继承自 <code>Object</code> 类，具有 <code>length</code> 等属性和方法。</li>
</ol>
<hr>
<h3 id="1-2-数组的声明与初始化"><a href="#1-2-数组的声明与初始化" class="headerlink" title="1.2 数组的声明与初始化"></a>1.2 数组的声明与初始化</h3><h4 id="1-2-1-声明数组"><a href="#1-2-1-声明数组" class="headerlink" title="1.2.1 声明数组"></a>1.2.1 声明数组</h4><p>声明数组时，并不分配内存，只是告诉编译器数组的类型和名称。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐写法： 类型[] 数组名;</span></span><br><span class="line"><span class="type">int</span>[] myArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以（C风格，不推荐）： 类型 数组名[];</span></span><br><span class="line"><span class="type">int</span> myArray[];</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-2-初始化数组"><a href="#1-2-2-初始化数组" class="headerlink" title="1.2.2 初始化数组"></a>1.2.2 初始化数组</h4><p>初始化是为数组分配内存并可能赋予初始值的过程。</p>
<p><strong>方式一：静态初始化（声明的同时直接赋值）</strong></p>
<p>在声明数组的同时，直接给出所有元素的值。由编译器决定数组长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整格式</span></span><br><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化格式（最常用）</span></span><br><span class="line"><span class="type">int</span>[] arr2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">String[] names = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>方式二：动态初始化（先声明，再使用 <code>new</code> 分配空间）</strong></p>
<p>只指定数组的长度，系统会自动为每个元素分配默认值。</p>
<ul>
<li>整数类型（<code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>）：默认值 <code>0</code></li>
<li>浮点类型（<code>float</code>, <code>double</code>）：默认值 <code>0.0</code></li>
<li>字符类型（<code>char</code>）：默认值 <code>&#39;\u0000&#39;</code> (空字符)</li>
<li>布尔类型（<code>boolean</code>）：默认值 <code>false</code></li>
<li>引用类型（<code>String</code>, 自定义类等）：默认值 <code>null</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法： 数组名 = new 类型[数组长度];</span></span><br><span class="line"><span class="type">int</span>[] arr;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">// 创建一个长度为5的int数组，所有元素初始为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明和分配空间合二为一</span></span><br><span class="line"><span class="type">int</span>[] arr3 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">// &#123;0, 0, 0, 0, 0&#125;</span></span><br><span class="line">String[] strArr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>]; <span class="comment">// &#123;null, null, null&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-3-数组的访问与遍历"><a href="#1-3-数组的访问与遍历" class="headerlink" title="1.3 数组的访问与遍历"></a>1.3 数组的访问与遍历</h3><h4 id="1-3-1-访问元素"><a href="#1-3-1-访问元素" class="headerlink" title="1.3.1 访问元素"></a>1.3.1 访问元素</h4><p>通过<strong>索引</strong>（下标）访问，索引范围从 <code>0</code> 到 <code>数组长度 - 1</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] scores = &#123;<span class="number">90</span>, <span class="number">85</span>, <span class="number">78</span>, <span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">firstScore</span> <span class="operator">=</span> scores[<span class="number">0</span>]; <span class="comment">// 获取第一个元素：90</span></span><br><span class="line">scores[<span class="number">1</span>] = <span class="number">95</span>; <span class="comment">// 修改第二个元素为95</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// System.out.println(scores[4]); // 错误！ArrayIndexOutOfBoundsException</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-3-2-遍历数组"><a href="#1-3-2-遍历数组" class="headerlink" title="1.3.2 遍历数组"></a>1.3.2 遍历数组</h4><p><strong>1.for 循环（最常用，可控索引）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; scores.length; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Index &quot;</span> + i + <span class="string">&quot;: &quot;</span> + scores[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.增强 for 循环（for-each，只读遍历）</strong><br>	语法更简洁，但无法获取当前元素的索引，也无法修改数组元素（对于基本数据类型）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> score : scores) &#123;</span><br><span class="line">    System.out.println(score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.使用 <code>Arrays.toString()</code>（快速打印）</strong><br>	<code>java.util.Arrays</code> 工具类提供了方便的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(scores)); </span><br><span class="line"><span class="comment">// 输出：[90, 95, 78, 100]</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-4-多维数组"><a href="#1-4-多维数组" class="headerlink" title="1.4 多维数组"></a>1.4 多维数组</h3><p>多维数组本质上是“数组的数组”，最常见的是二维数组。</p>
<h4 id="1-4-1-声明和初始化"><a href="#1-4-1-声明和初始化" class="headerlink" title="1.4.1 声明和初始化"></a>1.4.1 声明和初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line"><span class="type">int</span>[][] matrix = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态初始化（不规则数组）</span></span><br><span class="line"><span class="type">int</span>[][] arr2D = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][]; <span class="comment">// 先确定第一维（行）的长度</span></span><br><span class="line">arr2D[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>]; <span class="comment">// 第一行有2列</span></span><br><span class="line">arr2D[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">// 第二行有3列</span></span><br><span class="line">arr2D[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>]; <span class="comment">// 第三行有1列</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-4-2-访问与遍历"><a href="#1-4-2-访问与遍历" class="headerlink" title="1.4.2 访问与遍历"></a>1.4.2 访问与遍历</h4><p>需要使用嵌套循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123; <span class="comment">// 遍历行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123; <span class="comment">// 遍历当前行的每一列</span></span><br><span class="line">        System.out.print(matrix[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 1 2 3 </span></span><br><span class="line"><span class="comment">// 4 5 6 </span></span><br><span class="line"><span class="comment">// 7 8 9 </span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-4-3-注意事项"><a href="#1-4-3-注意事项" class="headerlink" title="1.4.3 注意事项"></a>1.4.3 注意事项</h4><p>在处理多维数组时，尽量<strong>将内存访问模式与数据存储顺序对齐</strong></p>
<p>例如：二维数组将每个元素+1；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10000</span>][<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先行后列访问</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">            array[i][j]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;先行后列访问时间：&quot;</span> + (endTime - startTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先列后行访问</span></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            array[i][j]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;先列后行访问时间：&quot;</span> + (endTime - startTime) + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先行后列访问时间：54毫秒</span></span><br><span class="line"><span class="comment">// 先列后行访问时间：1075毫秒</span></span><br></pre></td></tr></table></figure>

<p>可以发现速度差的不是一点，原因在于：</p>
<ol>
<li>二维数组 <code>int[10000][10000]</code> 在内存中被分配为<strong>连续块</strong>，但实际是由多个一维数组（每个行是一个一维数组）组成的。</li>
<li><strong>CPU缓存会预加载连续内存地址的数据</strong>（缓存行通常为64字节）。当按行访问时（<code>array[i][j]</code> 中 <code>i</code> 固定，<code>j</code> 连续变化），每次访问的元素在内存中是相邻的，缓存命中率高。</li>
<li><strong>按列访问时（<code>j</code> 固定，<code>i</code> 变化）</strong>，每次访问的元素间隔很大（间隔 <code>10000 * sizeof(int)</code> 字节），导致缓存无法有效预加载，频繁发生<strong>缓存未命中</strong>，需要从主内存读取数据，速度大幅下降。</li>
</ol>
<hr>
<h3 id="1-5-数组的常用操作与工具类-Arrays"><a href="#1-5-数组的常用操作与工具类-Arrays" class="headerlink" title="1.5 数组的常用操作与工具类 Arrays"></a>1.5 数组的常用操作与工具类 <code>Arrays</code></h3><p>Java 提供了 <code>java.util.Arrays</code> 工具类，包含大量操作数组的静态方法，非常实用。</p>
<ol>
<li><p><strong>排序：<code>Arrays.sort()</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>&#125;;</span><br><span class="line">Arrays.sort(numbers); <span class="comment">// 数组变为 [1, 3, 5, 8]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查找：<code>Arrays.binarySearch()</code></strong><br><strong>注意：使用前必须先对数组进行排序！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(numbers, <span class="number">5</span>); <span class="comment">// 返回元素5的索引：2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">notFound</span> <span class="operator">=</span> Arrays.binarySearch(numbers, <span class="number">10</span>); <span class="comment">// 返回负数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>填充：<code>Arrays.fill()</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">Arrays.fill(arr, <span class="number">100</span>); <span class="comment">// 将数组所有元素填充为100 -&gt; [100,100,100,100,100]</span></span><br><span class="line">Arrays.fill(arr, <span class="number">1</span>, <span class="number">3</span>, <span class="number">50</span>); <span class="comment">// 将索引[1,3)的元素填充为50 -&gt; [100,50,50,100,100]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>比较：<code>Arrays.equals()</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual</span> <span class="operator">=</span> Arrays.equals(a, b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>复制：<code>Arrays.copyOf()</code> &#x2F; <code>Arrays.copyOfRange()</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] original = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] copyAll = Arrays.copyOf(original, original.length); <span class="comment">// 复制整个数组</span></span><br><span class="line"><span class="type">int</span>[] copyPart = Arrays.copyOfRange(original, <span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 复制索引[1,3) -&gt; [2,3]</span></span><br><span class="line"><span class="type">int</span>[] biggerCopy = Arrays.copyOf(original, <span class="number">10</span>); <span class="comment">// 新数组长度为10，多出的元素为默认值0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层是 System.arraycopy() 平时经常使用Arrays提供的更抽象的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      src      源数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      srcPos   源数组中的起始复制位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      dest     目标数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      destPos  目标数据中的起始粘贴位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      length   要复制的数组元素的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     如果复制操作会导致访问数组边界之外的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     如果因为类型不匹配，src 数组中的某个元素无法存储到 dest 数组中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     如果 src 或 dest 为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// @IntrinsicCandidate 表明此方法是一个“内在候选者”，意味着JVM可能会使用高度优化的机器代码来替代原本的Java实现，以极大地提升其性能</span></span><br><span class="line"><span class="meta">@IntrinsicCandidate</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src,  <span class="type">int</span>  srcPos,</span></span><br><span class="line"><span class="params">                                    Object dest, <span class="type">int</span> destPos,</span></span><br><span class="line"><span class="params">                                    <span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>转换为字符串：<code>Arrays.toString()</code> &#x2F; <code>Arrays.deepToString()</code></strong><br><code>deepToString()</code> 用于打印多维数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] deepArray = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">System.out.println(Arrays.toString(deepArray)); <span class="comment">// 输出[[I@1db9742, [I@106d69c]</span></span><br><span class="line">System.out.println(Arrays.deepToString(deepArray)); <span class="comment">// 输出[[1, 2], [3, 4]]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="1-6-数组的注意事项与常见错误"><a href="#1-6-数组的注意事项与常见错误" class="headerlink" title="1.6 数组的注意事项与常见错误"></a>1.6 数组的注意事项与常见错误</h3><ol>
<li><p><strong><code>ArrayIndexOutOfBoundsException</code>（数组越界异常）</strong><br>这是最常见的运行时错误。访问了不存在的索引（如 <code>index &lt; 0</code> 或 <code>index &gt;= array.length</code>）。</p>
</li>
<li><p><strong><code>NullPointerException</code>（空指针异常）</strong><br>数组是引用类型，如果只是声明了数组引用但未初始化（<code>int[] arr = null;</code>），此时访问 <code>arr[0]</code> 或 <code>arr.length</code> 就会抛出此异常。</p>
</li>
<li><p><strong>长度不可变</strong><br>数组一旦创建，大小就固定了。如果需要动态扩容，需要手动创建新数组并拷贝数据（<code>Arrays.copyOf()</code> 内部就是这么做的），或者使用更高级的集合类（如 <code>ArrayList</code>）。</p>
</li>
<li><p><strong>数组作为参数传递</strong><br>数组是对象，所以作为参数传递给方法时，传递的是<strong>引用（地址）的副本</strong>。这意味着在方法内部修改数组的元素内容，会影响到原始的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modifyArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">100</span>; <span class="comment">// 这会改变原始数组的第一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2. 字符串"></a>2. 字符串</h2><h3 id="2-1-使用"><a href="#2-1-使用" class="headerlink" title="2.1 使用"></a>2.1 使用</h3><h4 id="2-1-1-创建-String-对象"><a href="#2-1-1-创建-String-对象" class="headerlink" title="2.1.1 创建 String 对象"></a>2.1.1 创建 String 对象</h4><p>主要有两种方式：</p>
<ul>
<li><p><strong>通过字面量直接创建（最常用）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这种方式会优先检查字符串常量池（String Constant Pool），如果池中已有相同内容的字符串，则直接返回其引用；如果没有，则在池中创建一个新的字符串对象再返回引用。<strong>这种方式能利用常量池，避免重复创建对象，节省内存。</strong></p>
</li>
<li><p><strong>通过 <code>new</code> 关键字创建</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这种方式会<strong>强制</strong>在堆内存（Heap）中创建一个新的、独立的 <code>String</code> 对象，无论常量池中是否已存在相同内容的字符串。通常不推荐这样使用，除非有特殊需求。</p>
</li>
</ul>
<hr>
<h4 id="2-1-2-字符串的基本操作"><a href="#2-1-2-字符串的基本操作" class="headerlink" title="2.1.2 字符串的基本操作"></a>2.1.2 字符串的基本操作</h4><p><code>String</code> 类提供了极其丰富的方法来操作字符串：</p>
<ul>
<li><p><strong>获取信息</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length(); <span class="comment">// 获取长度</span></span><br><span class="line"><span class="type">char</span> <span class="variable">firstChar</span> <span class="operator">=</span> s.charAt(<span class="number">0</span>); <span class="comment">// &#x27;J&#x27;，获取指定位置的字符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串比较</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual1</span> <span class="operator">=</span> (a == b); <span class="comment">// false，比较的是对象内存地址</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual2</span> <span class="operator">=</span> a.equals(b); <span class="comment">// true，比较的是字符串内容（重要！）</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual3</span> <span class="operator">=</span> a.equalsIgnoreCase(<span class="string">&quot;JAVA&quot;</span>); <span class="comment">// true，忽略大小写比较内容</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串查找</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;I love Java!&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> text.contains(<span class="string">&quot;love&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> text.indexOf(<span class="string">&quot;Java&quot;</span>); <span class="comment">// 返回首次出现的索引</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> text.lastIndexOf(<span class="string">&quot;a&quot;</span>); <span class="comment">// 返回最后一次出现的索引</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">starts</span> <span class="operator">=</span> text.startsWith(<span class="string">&quot;I&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">ends</span> <span class="operator">=</span> text.endsWith(<span class="string">&quot;!&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串截取与分割</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;usr/local/bin&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">sub1</span> <span class="operator">=</span> path.substring(<span class="number">4</span>); <span class="comment">// &quot;local/bin&quot;，从索引4开始到末尾</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sub2</span> <span class="operator">=</span> path.substring(<span class="number">4</span>, <span class="number">9</span>); <span class="comment">// &quot;local&quot;，从索引4到索引9（不含）</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;apple,orange,banana&quot;</span>;</span><br><span class="line">String[] fruits = data.split(<span class="string">&quot;,&quot;</span>); <span class="comment">// [&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;]，按逗号分割</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串替换</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">oldStr</span> <span class="operator">=</span> <span class="string">&quot;I like C.&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> oldStr.replace(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;Java&quot;</span>); <span class="comment">// &quot;I like Java.&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>大小写转换</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">mixed</span> <span class="operator">=</span> <span class="string">&quot;HeLLo&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">lower</span> <span class="operator">=</span> mixed.toLowerCase(); <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">upper</span> <span class="operator">=</span> mixed.toUpperCase(); <span class="comment">// &quot;HELLO&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>去除首尾空白字符</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">withSpaces</span> <span class="operator">=</span> <span class="string">&quot;  Hello World  &quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">trimmed</span> <span class="operator">=</span> withSpaces.trim(); <span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line"><span class="comment">// JDK 11+ 提供了 strip()，功能更强，能去除所有Unicode空白字符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串拼接</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用 + 运算符（最方便，但大量循环拼接时性能差）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot; &quot;</span> + <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用 concat() 方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Alice&quot;</span>.concat(<span class="string">&quot; Smith&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 高性能场景使用 StringBuilder 或 StringBuffer</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb.append(<span class="string">&quot;Hello&quot;</span>).append(<span class="string">&quot; &quot;</span>).append(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-2-底层机制详解"><a href="#2-2-底层机制详解" class="headerlink" title="2.2 底层机制详解"></a>2.2 底层机制详解</h3><h4 id="2-2-1-字符串的创建与内存分配（深入常量池）"><a href="#2-2-1-字符串的创建与内存分配（深入常量池）" class="headerlink" title="2.2.1 字符串的创建与内存分配（深入常量池）"></a>2.2.1 字符串的创建与内存分配（深入常量池）</h4><p>创建 <code>String</code> 对象主要有两种方式，它们在内存分配上有根本区别，核心在于<strong>字符串常量池 (String Constant Pool)</strong>。</p>
<ul>
<li><p><strong>字面量方式 (String Literal)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>机制</strong>：JVM 会首先检查字符串常量池中是否存在内容为 <code>&quot;hello&quot;</code> 的字符串对象的<strong>引用</strong>。<ul>
<li><strong>如果存在</strong>：则 <code>s1</code> 直接指向池中的那个引用，<strong>不会创建新对象</strong>。</li>
<li><strong>如果不存在</strong>：则在 <strong>堆 (Heap)</strong> 上创建一个新的 <code>String</code> 对象，然后将其<strong>引用</strong>保存在字符串常量池中，最后让 <code>s1</code> 指向这个引用。</li>
</ul>
</li>
<li><strong>结论</strong>：<code>s1 == s2</code> 为 <code>true</code>，因为它们指向<strong>同一个内存地址</strong>（常量池中的同一个引用）。这是实现字符串复用的关键。</li>
</ul>
</li>
<li><p><strong><code>new</code> 关键字方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>机制</strong>：<ol>
<li><code>&quot;hello&quot;</code> 这个字面量会首先按照上述规则在常量池中查找或创建。</li>
<li><code>new</code> 关键字会<strong>强制</strong>在 Java <strong>堆</strong>上创建一个全新的、独立的 <code>String</code> 对象。这个新对象的内部字符数组（<code>value</code>）可能会指向池中对象的字符数组，也可能拷贝一份（取决于JDK版本和实现优化）。</li>
</ol>
</li>
<li><strong>结论</strong>：<code>s3 == s4</code> 为 <code>false</code>，因为它们是堆上两个不同的对象。但 <code>s3.equals(s4)</code> 为 <code>true</code>，因为内容相同。</li>
</ul>
</li>
<li><p><strong>拼接字符串的特殊情况</strong><br><strong>针对没有使用双引号声明的字符串对象来说</strong>，即通过 <code>new</code> 和拼接操作在运行时动态创建的字符串，<strong>不会自动放入字符串常量池</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该操作会在堆上创建多个对象，但&quot;hello&quot;和&quot;world&quot;会进入常量池，而最终结果&quot;helloworld&quot;不会自动入池。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="comment">// 此时，字符串常量池中有&quot;hello&quot;和&quot;world&quot;，但没有&quot;helloworld&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>如果想把 s1 的内容也放入字符串常量池的话，可以调用 <code>intern()</code> 方法来完成。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 = s1.intern(); <span class="comment">// 将&quot;helloworld&quot;的引用存入常量池并返回</span></span><br><span class="line"><span class="comment">// 之后，任何直接使用字面量 &quot;helloworld&quot; 的声明都将指向这个池中的引用。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-2-2-intern-方法：手动入池"><a href="#2-2-2-intern-方法：手动入池" class="headerlink" title="2.2.2 intern() 方法：手动入池"></a>2.2.2 <code>intern()</code> 方法：手动入池</h4><p>这是一个 <code>native</code> 方法，用于手动将运行时动态创建的字符串添加到常量池。</p>
<ul>
<li><strong>作用</strong>：调用 <code>s.intern()</code> 时，JVM 会：<ol>
<li>检查常量池中是否有与 <code>s</code> 内容相同的字符串的引用。</li>
<li><strong>如果存在</strong>，则直接返回池中的那个引用。</li>
<li><strong>如果不存在（对于动态创建的字符串，这是常见情况）</strong>：在 JDK 1.7+ 之后，会将 <strong><code>s</code> 自身在堆中的引用</strong>添加到常量池中，然后返回这个引用。（在 JDK 1.6 及之前，是拷贝一份字符串对象到永久代）。</li>
</ol>
</li>
<li><strong>目的</strong>：可以将运行时动态生成（如通过 <code>new</code>、<code>StringBuilder</code> 拼接等）的字符串也纳入池化管理，后续就可以通过字面量或 <code>intern()</code> 来复用这个对象，节省内存。<strong>这是将拼接字符串加入常量池的标准方法。</strong></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;world&quot;</span>); <span class="comment">// s1 指向堆中的 &quot;helloworld&quot; 对象，池中无此引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>; <span class="comment">// 池中没有，因此在堆上创建新对象，引用放入池中，s2指向它</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1.intern();  <span class="comment">// JDK7+: 尝试将s1的引用放入常量池。发现池中已有s2的引用(内容相同)，因此返回s2的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>; <span class="comment">// s4 直接指向池中已有的引用（即s2的引用）</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// false, 两个不同的堆对象</span></span><br><span class="line">System.out.println(s2 == s3); <span class="comment">// true, s3得到的是池中s2的引用</span></span><br><span class="line">System.out.println(s2 == s4); <span class="comment">// true, 都指向池中的同一个引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;java&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;script&quot;</span>); <span class="comment">// 堆中创建&quot;javascript&quot;，池中无</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s5.intern(); <span class="comment">// JDK7+: 池中无此字符串，将s5的引用放入池中，并返回s5的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="string">&quot;javascript&quot;</span>; <span class="comment">// 池中已有(s5的引用)，直接返回该引用</span></span><br><span class="line"></span><br><span class="line">System.out.println(s5 == s6); <span class="comment">// true! 因为s6得到的就是s5自身的引用</span></span><br><span class="line">System.out.println(s5 == s7); <span class="comment">// true! 因为s7从池中拿到的是s5的引用</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-3-字符串常量池的位置演变"><a href="#2-2-3-字符串常量池的位置演变" class="headerlink" title="2.2.3 字符串常量池的位置演变"></a>2.2.3 字符串常量池的位置演变</h4><ul>
<li><strong>JDK 1.6 及以前</strong>：位于<strong>方法区 (Method Area)</strong>，具体实现是<strong>永久代 (PermGen)</strong>。<ul>
<li><strong>问题</strong>：永久代大小有限且难以调整，容易发生 <code>OutOfMemoryError: PermGen space</code>。且该区域的垃圾回收效率不高。</li>
</ul>
</li>
<li><strong>JDK 1.7</strong>：<strong>字符串常量池被移到了堆 (Heap) 中</strong>。<ul>
<li><strong>好处</strong>：堆内存更大，且由垃圾回收器统一管理。即使字符串不再被引用，也可以从池中回收，避免了内存泄漏问题。</li>
</ul>
</li>
<li><strong>JDK 1.8 及以后</strong>：<strong>永久代 (PermGen) 被彻底移除</strong>，取而代之的是<strong>元空间 (Metaspace)</strong>。<strong>字符串常量池仍在堆中</strong>。类元信息、方法信息等移到了元空间。<ul>
<li><strong>好处</strong>：元空间使用本地内存，默认情况下只受本机可用内存限制，极大减少了 <code>OutOfMemoryError</code> 的风险。</li>
</ul>
</li>
</ul>
<p><strong>总结关系</strong>：</p>
<ul>
<li><strong>方法区</strong>是 JVM 规范定义的一个逻辑概念&#x2F;内存区域。</li>
<li><strong>永久代</strong>是 HotSpot 虚拟机对方法区的一种实现（JDK 8之前）。</li>
<li><strong>元空间</strong>是 HotSpot 虚拟机对方法区的另一种实现（JDK 8+），位于本地内存。</li>
<li><strong>字符串常量池</strong>在物理上，从 JDK 7 开始就存在于<strong>堆内存</strong>中。</li>
</ul>
<hr>
<h4 id="2-2-4-String-的不可变性-Immutability"><a href="#2-2-4-String-的不可变性-Immutability" class="headerlink" title="2.2.4 String 的不可变性 (Immutability)"></a>2.2.4 String 的不可变性 (Immutability)</h4><p>这是 <code>String</code> 类设计的基石。</p>
<ul>
<li><strong>如何实现？</strong><ol>
<li><strong><code>final</code> 类</strong>：防止被继承，从而被子类重写方法破坏不可变性。</li>
<li><strong><code>private final byte[] value</code> (JDK9+) &#x2F; <code>char[] value</code> (JDK8-)</strong>：<code>private</code> 阻止了外部直接访问，<code>final</code> 确保了数组引用不可变（但不能阻止数组元素被改，所以需要第3点）。</li>
<li><strong>无修改内部状态的方法</strong>：所有看似修改的方法（如 <code>concat</code>, <code>replace</code>）内部都返回一个<strong>新创建的 <code>String</code> 对象</strong>。</li>
</ol>
</li>
<li><strong>为何如此设计？</strong><ol>
<li><strong>安全</strong>：广泛用于类加载、网络连接、文件路径等。若可变，可能被恶意修改，造成安全漏洞。也保证了 <code>HashSet&lt;String&gt;</code>、<code>HashMap&lt;String, ...&gt;</code> 等集合键值的稳定性。</li>
<li><strong>线程安全</strong>：不可变对象天生线程安全，可在多线程间无忧共享。</li>
<li><strong>支持常量池</strong>：只有不变，才能让多个引用放心地指向同一个对象。</li>
<li><strong>性能</strong>：缓存哈希码（<code>hashCode</code>），作为 <code>HashMap</code> 的键时效率极高。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="2-2-5-JDK-9-的底层优化：byte-coder"><a href="#2-2-5-JDK-9-的底层优化：byte-coder" class="headerlink" title="2.2.5 JDK 9 的底层优化：byte[] + coder"></a>2.2.5 JDK 9 的底层优化：<code>byte[]</code> + <code>coder</code></h4><ul>
<li><p><strong>背景</strong>：在 JDK 8 及以前，<code>String</code> 使用 <code>char[]</code>（每个 <code>char</code> 2字节）存储数据。但大量实际应用（如JSON、XML、HTTP头）中的字符串仅包含 <strong>Latin-1</strong> 字符（如英文、数字），这些字符只需 <strong>1 字节</strong>即可表示。使用 <code>char[]</code> 存储造成了近 <strong>50%</strong> 的空间浪费。</p>
</li>
<li><p><strong>优化</strong>：JDK 9 将内部存储改为 <code>byte[]</code>，并引入了一个编码标志字段 <code>coder</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value; <span class="comment">// 存储字节</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder;   <span class="comment">// 0 代表 Latin-1，1 代表 UTF-16</span></span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当字符串全部是 Latin-1 字符时，<code>coder = 0</code>，<code>value</code> 数组紧凑地存储每个字符的1字节编码。</li>
<li>当字符串包含任何非 Latin-1 字符（如中文）时，<code>coder = 1</code>，<code>value</code> 数组改用 UTF-16 编码（每个字符通常占2或4字节）。</li>
</ul>
</li>
<li><p><strong>好处</strong>：</p>
<ul>
<li><strong>显著减少内存占用</strong>：对大量西方语言文本，内存占用大幅降低。</li>
<li><strong>减少 GC 压力</strong>：对象体积变小，内存分配和回收的效率更高。</li>
</ul>
</li>
<li><p><strong>对开发者的影响</strong>：<strong>完全透明</strong>。这是一项底层实现优化，所有 <code>String</code> 的公共API和行为没有任何变化，现有代码无需任何修改即可获益。</p>
</li>
</ul>
<hr>
<h3 id="2-3-StringBuilder、StringBuffer和StringJoiner"><a href="#2-3-StringBuilder、StringBuffer和StringJoiner" class="headerlink" title="2.3 StringBuilder、StringBuffer和StringJoiner"></a>2.3 StringBuilder、StringBuffer和StringJoiner</h3><h4 id="2-3-1-StringBuilder"><a href="#2-3-1-StringBuilder" class="headerlink" title="2.3.1 StringBuilder"></a>2.3.1 StringBuilder</h4><p><code>StringBuilder</code> 是一个可变的字符序列，用于高效地进行字符串的拼接、插入、删除等操作。它是对 <code>String</code> 不可变性的重要补充，解决了频繁修改字符串时产生的性能问题。</p>
<h5 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h5><ol>
<li><strong>可变性 (Mutability)</strong>：内部维护一个可变的字符数组（JDK9 后同为 <code>byte[]</code>），修改操作（如 <code>append</code>, <code>insert</code>）都是在原有对象上进行的，不会创建大量新的临时对象。</li>
<li><strong>非线程安全 (Not Thread-Safe)</strong>：它的方法<strong>没有</strong>使用 <code>synchronized</code> 关键字修饰。因此，它在单线程环境下性能最高，但在多线程环境下同时修改可能会导致数据不一致。</li>
<li><strong>高性能</strong>：由于避免了同步开销和大量对象的创建，它在单线程下的字符串操作性能是最优的。</li>
</ol>
<h5 id="主要构造方法"><a href="#主要构造方法" class="headerlink" title="主要构造方法"></a>主要构造方法</h5><ul>
<li><code>StringBuilder()</code>：构造一个空容器，初始容量为 <strong>16</strong> 个字符。</li>
<li><code>StringBuilder(int capacity)</code>：构造一个指定初始容量的空容器。</li>
<li><code>StringBuilder(String str)</code>：构造一个初始化为指定字符串内容的容器。</li>
</ul>
<h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><ul>
<li><code>append(xxx)</code>：最核心的方法，支持重载多种数据类型（<code>String</code>, <code>int</code>, <code>char</code>, <code>Object</code>…），将其追加到序列末尾。</li>
<li><code>insert(int offset, xxx)</code>：在指定位置插入数据。</li>
<li><code>delete(int start, int end)</code>：删除子序列。</li>
<li><code>replace(int start, int end, String str)</code>：替换子序列。</li>
<li><code>reverse()</code>：将此字符序列反转。</li>
<li><code>toString()</code>：将当前容器中的字符序列转换为一个 <code>String</code> 对象。</li>
<li><code>length()</code>：返回长度（字符数）。</li>
<li><code>capacity()</code>：返回当前容器的总容量。</li>
</ul>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p><strong>几乎所有需要进行字符串拼接、修改的场景，尤其是在循环体内。</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在循环中拼接字符串，必须使用StringBuilder</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    sb.append(i).append(<span class="string">&quot;, &quot;</span>); <span class="comment">// 链式调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">System.out.println(result); <span class="comment">// 输出: 0, 1, 2, ..., 99,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他操作</span></span><br><span class="line">sb.insert(<span class="number">0</span>, <span class="string">&quot;Start: &quot;</span>); <span class="comment">// 在开头插入</span></span><br><span class="line">sb.replace(sb.length()-<span class="number">2</span>, sb.length(), <span class="string">&quot;. End&quot;</span>); <span class="comment">// 替换最后的逗号和空格</span></span><br><span class="line">System.out.println(sb.toString()); <span class="comment">// 输出: Start: 0, 1, 2, ..., 99. End</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-2-StringBuffer"><a href="#2-3-2-StringBuffer" class="headerlink" title="2.3.2 StringBuffer"></a>2.3.2 StringBuffer</h4><p><code>StringBuffer</code> 可以看作是 <code>StringBuilder</code> 的线程安全版本。它们在 API 和功能上几乎是完全一致的。</p>
<h5 id="核心特性-1"><a href="#核心特性-1" class="headerlink" title="核心特性"></a>核心特性</h5><ol>
<li><strong>可变性 (Mutability)</strong>：与 <code>StringBuilder</code> 相同。</li>
<li><strong>线程安全 (Thread-Safe)</strong>：它的关键方法（如 <code>append</code>）都使用了 <strong><code>synchronized</code></strong> 关键字修饰，保证了多个线程无法同时修改它。因此，它是线程安全的。</li>
<li><strong>性能较低</strong>：由于同步锁的获取和释放会带来额外的开销，它的性能在单线程环境下通常低于 <code>StringBuilder</code>。</li>
</ol>
<h5 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h5><p><strong>需要在多线程环境下对同一个字符串序列进行修改的场景。</strong> 但由于现代开发中，多个线程竞争同一资源的情况相对较少，或者可以通过其他同步机制（如 <code>ThreadLocal</code>）来避免，<code>StringBuffer</code> 的使用频率已远低于 <code>StringBuilder</code>。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;ThreadSafe&quot;</span>);</span><br><span class="line"><span class="comment">// 用法与StringBuilder完全一样</span></span><br><span class="line">sBuffer.append(<span class="string">&quot; String&quot;</span>).append(<span class="string">&quot; Buffer&quot;</span>);</span><br><span class="line">System.out.println(sBuffer.toString()); <span class="comment">// 输出: ThreadSafe String Buffer</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-3-StringJoiner"><a href="#2-3-3-StringJoiner" class="headerlink" title="2.3.3 StringJoiner"></a>2.3.3 StringJoiner</h4><p><code>StringJoiner</code> 是 Java 8 引入的一个专门用于<strong>构造由分隔符分隔的字符序列</strong>的实用工具类。它极大地简化了拼接带有固定分隔符（如逗号、冒号）的字符串序列的操作。</p>
<h5 id="核心特性-2"><a href="#核心特性-2" class="headerlink" title="核心特性"></a>核心特性</h5><ol>
<li><strong>目的明确</strong>：专为拼接带有<strong>分隔符 (Delimiter)</strong>、<strong>前缀 (Prefix)</strong> 和<strong>后缀 (Suffix)</strong> 的序列而设计。</li>
<li><strong>底层实现</strong>：其内部通常使用 <code>StringBuilder</code> 来高效完成拼接。</li>
<li><strong>与 Stream API 无缝集成</strong>：<code>Collectors.joining()</code> 方法内部就使用了 <code>StringJoiner</code>，使其在流操作中极为方便。</li>
</ol>
<h5 id="主要构造方法-1"><a href="#主要构造方法-1" class="headerlink" title="主要构造方法"></a>主要构造方法</h5><ul>
<li><code>StringJoiner(CharSequence delimiter)</code>：使用指定的分隔符，无前缀后缀。</li>
<li><code>StringJoiner(CharSequence delimiter, CharSequence prefix, CharSequence suffix)</code>：使用指定的分隔符、前缀和后缀。</li>
</ul>
<h5 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h5><ul>
<li><code>add(CharSequence newElement)</code>：添加一个新元素，它会自动在后面加上分隔符（除了最后一个元素）。</li>
<li><code>merge(StringJoiner other)</code>：合并另一个 <code>StringJoiner</code> 的内容。</li>
<li><code>toString()</code>：返回拼接好的字符串，包含前缀和后缀。</li>
</ul>
<h5 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h5><p><strong>拼接集合元素、生成 CSV 行、SQL 语句的 IN 条件、输出格式化列表等。</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 简单拼接列表</span></span><br><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line"><span class="type">StringJoiner</span> <span class="variable">sj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">    sj1.add(name);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sj1.toString()); <span class="comment">// 输出: Alice, Bob, Charlie</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 带前缀和后缀（非常实用！）</span></span><br><span class="line"><span class="type">StringJoiner</span> <span class="variable">sj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;&#x27;, &#x27;&quot;</span>, <span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"><span class="comment">// 分隔符是 &quot;&#x27;, &#x27;&quot;, 前缀是 &quot;&#x27;&quot;, 后缀是 &quot;&#x27;&quot;</span></span><br><span class="line">sj2.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">sj2.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">sj2.add(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">System.out.println(sj2.toString()); <span class="comment">// 输出: &#x27;Apple&#x27;, &#x27;Banana&#x27;, &#x27;Orange&#x27;</span></span><br><span class="line"><span class="comment">// 这非常适合拼接SQL语句：SELECT * FROM fruits WHERE name IN (&#x27;Apple&#x27;, &#x27;Banana&#x27;, &#x27;Orange&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 与Stream API结合（最优雅的方式）</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">                       .map(String::valueOf)</span><br><span class="line">                       .collect(Collectors.joining(<span class="string">&quot; - &quot;</span>, <span class="string">&quot;[ &quot;</span>, <span class="string">&quot; ]&quot;</span>));</span><br><span class="line">System.out.println(result); <span class="comment">// 输出: [ 1 - 2 - 3 - 4 ]</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-4-对比总结与选择指南"><a href="#2-3-4-对比总结与选择指南" class="headerlink" title="2.3.4 对比总结与选择指南"></a>2.3.4 对比总结与选择指南</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">StringBuilder</th>
<th align="left">StringBuffer</th>
<th align="left">StringJoiner</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>可变性</strong></td>
<td align="left">是</td>
<td align="left">是</td>
<td align="left">是（内部基于StringBuilder）</td>
</tr>
<tr>
<td align="left"><strong>线程安全</strong></td>
<td align="left"><strong>否</strong></td>
<td align="left"><strong>是</strong>（ synchronized ）</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left"><strong>高</strong>（单线程）</td>
<td align="left">较低（因同步开销）</td>
<td align="left">高（专用场景）</td>
</tr>
<tr>
<td align="left"><strong>主要用途</strong></td>
<td align="left"><strong>通用字符串拼接与修改</strong></td>
<td align="left"><strong>多线程下的字符串拼接与修改</strong></td>
<td align="left"><strong>拼接带分隔符、前缀后缀的序列</strong></td>
</tr>
<tr>
<td align="left"><strong>引入版本</strong></td>
<td align="left">Java 5</td>
<td align="left">Java 1.0</td>
<td align="left">Java 8</td>
</tr>
</tbody></table>
<h5 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a><strong>如何选择？</strong></h5><ol>
<li><strong><code>StringBuilder</code></strong>：<strong>默认选择</strong>。适用于 99% 的字符串拼接和修改场景，尤其是在循环、方法内部等单线程环境下。</li>
<li><strong><code>StringBuffer</code></strong>：<strong>非常罕见</strong>。仅在需要在线程间共享并修改<strong>同一个</strong> <code>StringBuffer</code> 对象时使用。通常可以被 <code>StringBuilder</code> 配合其他同步机制替代。</li>
<li><strong><code>StringJoiner</code></strong>：<strong>目的驱动</strong>。当你需要拼接一个带有<strong>固定分隔符</strong>的列表，特别是还需要<strong>前缀和后缀</strong>时，它就是最清晰、最优雅的选择。与 Java 8 Stream API 是天作之合。</li>
</ol>
<p><strong>一句话总结：单线程拼接用 <code>StringBuilder</code>，要格式化成串用 <code>StringJoiner</code>，<code>StringBuffer</code> 基本被遗忘。</strong></p>
<hr>
<h2 id="3-Java-对象内存布局"><a href="#3-Java-对象内存布局" class="headerlink" title="3. Java 对象内存布局"></a>3. Java 对象内存布局</h2><p>Java 对象在堆内存中的存储布局可以分为三个部分：<strong>对象头 (Header)</strong>、<strong>实例数据 (Instance Data)</strong> 和<strong>对齐填充 (Padding)</strong>。</p>
<h3 id="3-1-对象结构概览"><a href="#3-1-对象结构概览" class="headerlink" title="3.1 对象结构概览"></a>3.1 对象结构概览</h3><table>
<thead>
<tr>
<th align="left">部分</th>
<th align="left">描述</th>
<th align="left">必选</th>
<th align="left">大小 (64位 JVM, 开启压缩指针)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>对象头 (Header)</strong></td>
<td align="left">包含对象的元数据</td>
<td align="left">是</td>
<td align="left">12 字节 (8B Mark Word + 4B Klass Word)</td>
</tr>
<tr>
<td align="left"><strong>实例数据 (Instance Data)</strong></td>
<td align="left">对象所有字段的内容</td>
<td align="left">否 (无字段则无)</td>
<td align="left">取决于具体字段类型和数量</td>
</tr>
<tr>
<td align="left"><strong>对齐填充 (Padding)</strong></td>
<td align="left">使对象总大小为 8 字节的整数倍</td>
<td align="left">否 (大小刚好则无)</td>
<td align="left">0 - 7 字节</td>
</tr>
</tbody></table>
<p><strong>总大小公式</strong>：<code>对象头 + 实例数据 + 对齐填充</code>，且总大小必须是 <strong>8 字节的整数倍</strong>。</p>
<hr>
<h3 id="3-2-各部分详解"><a href="#3-2-各部分详解" class="headerlink" title="3.2 各部分详解"></a>3.2 各部分详解</h3><h4 id="3-2-1-对象头-Object-Header"><a href="#3-2-1-对象头-Object-Header" class="headerlink" title="3.2.1 对象头 (Object Header)"></a>3.2.1 对象头 (Object Header)</h4><ol>
<li><strong>Mark Word</strong>: 存储对象自身的运行时数据。</li>
</ol>
<ul>
<li>包括：哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。</li>
<li><strong>大小</strong>：在 64 位 JVM 上占 <strong>8 字节</strong>。</li>
</ul>
<ol>
<li><strong>Klass Pointer (类型指针)</strong>: 指向对象的类元数据（<code>Class</code> 对象），JVM 通过它来确定对象是哪个类的实例。</li>
</ol>
<ul>
<li><strong>大小</strong>：在 64 位 JVM 且开启指针压缩 (<code>-XX:+UseCompressedOops</code>，<strong>默认开启</strong>) 时，占 <strong>4 字节</strong>；关闭时占 8 字节。</li>
</ul>
<blockquote>
<p><strong>指针压缩</strong>: 为了减少 64 位平台下的内存消耗，JVM 将原本 64 位（8字节）的 Klass Pointer 压缩为 32 位（4字节）。这使得对象头从 16 字节 (8+8) 减少到 12 字节 (8+4)，显著节约了内存。</p>
</blockquote>
<hr>
<h4 id="3-2-2-实例数据-Instance-Data"><a href="#3-2-2-实例数据-Instance-Data" class="headerlink" title="3.2.2 实例数据 (Instance Data)"></a>3.2.2 实例数据 (Instance Data)</h4><p>这是对象<strong>真正存储有效信息</strong>的部分，包含了代码中定义的所有类型的字段内容（包括从父类继承来的）。</p>
<ul>
<li><p><strong>内容</strong>：对象中所有定义字段的内容（包括从其父类继承的）。</p>
</li>
<li><p><strong>大小</strong>：完全由字段的类型和数量决定。</p>
</li>
<li><p><strong>基本类型占用空间</strong>：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>boolean</code>, <code>byte</code></td>
<td align="left">1 字节</td>
</tr>
<tr>
<td align="left"><code>short</code>, <code>char</code></td>
<td align="left">2 字节</td>
</tr>
<tr>
<td align="left"><code>int</code>, <code>float</code></td>
<td align="left">4 字节</td>
</tr>
<tr>
<td align="left"><code>long</code>, <code>double</code></td>
<td align="left">8 字节</td>
</tr>
<tr>
<td align="left"><strong>引用类型</strong></td>
<td align="left"><strong>4字节</strong> (64位JVM开启压缩指针时)</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意</strong>：虽然 <code>boolean</code> 理论上只需 1 位，但 JVM 将其最小单位定义为 <strong>1 字节</strong>。</p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="3-2-3-对齐填充-Padding"><a href="#3-2-3-对齐填充-Padding" class="headerlink" title="3.2.3 对齐填充 (Padding)"></a>3.2.3 对齐填充 (Padding)</h4><ul>
<li><strong>作用</strong>: HotSpot JVM 的内存管理系统要求<strong>对象的起始地址必须是 8 字节的整数倍</strong>（即 8 字节对齐）。因此，对象的总大小也必须是 8 字节的整数倍。</li>
<li><strong>原因</strong>: 对齐后，CPU 的内存访问速度会大大提升。这是一种典型的“以空间换时间”的策略。</li>
<li>如果 <code>对象头 + 实例数据</code> 的总大小不是 8 的倍数，JVM 会自动添加若干字节的无效数据（Padding）来补全。</li>
</ul>
<hr>
<h3 id="3-3-案例分析"><a href="#3-3-案例分析" class="headerlink" title="3.3 案例分析"></a>3.3 案例分析</h3><h4 id="案例-1-java-lang-Object-空对象"><a href="#案例-1-java-lang-Object-空对象" class="headerlink" title="案例 1: java.lang.Object 空对象"></a>案例 1: <code>java.lang.Object</code> 空对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// JOL 输出</span></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  <span class="number">0</span>   <span class="number">8</span>        (object header: mark)     <span class="number">0x0000000000000001</span> (non-biasable; age: <span class="number">0</span>)</span><br><span class="line">  <span class="number">8</span>   <span class="number">4</span>        (object header: class)    <span class="number">0x000000f8</span> <span class="comment">// Klass Pointer</span></span><br><span class="line"> <span class="number">12</span>   <span class="number">4</span>        (object alignment gap)    <span class="comment">// 对齐填充</span></span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>分析</strong>：对象头占 12B (8B Mark Word + 4B Klass Pointer)。12B 不是 8 的倍数，需要填充 4B 达到 16B。</li>
<li><strong>结论</strong>：一个空 <code>Object</code> 对象占用 <strong>16 字节</strong>。</li>
</ul>
<hr>
<h4 id="案例-2-包含一个-int-字段的对象"><a href="#案例-2-包含一个-int-字段的对象" class="headerlink" title="案例 2: 包含一个 int 字段的对象"></a>案例 2: 包含一个 <code>int</code> 字段的对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleInt</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SimpleInt</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleInt</span>();</span><br><span class="line"><span class="comment">// JOL 输出 (简化)</span></span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  <span class="number">0</span>   <span class="number">8</span>        (object header: mark)     ...</span><br><span class="line">  <span class="number">8</span>   <span class="number">4</span>        (object header: class)    ...</span><br><span class="line"> <span class="number">12</span>   <span class="number">4</span>    <span class="type">int</span> SimpleInt.value           <span class="number">0</span></span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>分析</strong>：对象头 (12B) + 实例数据 <code>int value</code> (4B) &#x3D; 16B。16 是 8 的倍数，无需填充。</li>
<li><strong>结论</strong>：该对象占用 <strong>16 字节</strong>。</li>
</ul>
<hr>
<h4 id="案例-3-java-lang-Boolean-对象"><a href="#案例-3-java-lang-Boolean-对象" class="headerlink" title="案例 3: java.lang.Boolean 对象"></a>案例 3: <code>java.lang.Boolean</code> 对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">obj</span> <span class="operator">=</span> Boolean.TRUE;</span><br><span class="line"><span class="comment">// JOL 输出 (简化)</span></span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  <span class="number">0</span>   <span class="number">8</span>        (object header: mark)     ...</span><br><span class="line">  <span class="number">8</span>   <span class="number">4</span>        (object header: class)    ...</span><br><span class="line"> <span class="number">12</span>   <span class="number">1</span>   <span class="type">byte</span> Boolean.value             <span class="number">1</span> <span class="comment">// Java 内部用 byte 表示 boolean</span></span><br><span class="line"> <span class="number">13</span>   <span class="number">3</span>        (object alignment gap)    <span class="comment">// 对齐填充</span></span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>分析</strong>：对象头 (12B) + 实例数据 <code>byte value</code> (1B) &#x3D; 13B。13B 不是 8 的倍数，需要填充 3B 达到 16B。</li>
<li><strong>结论</strong>：一个 <code>Boolean</code> 对象实际占用 <strong>16 字节</strong>。</li>
</ul>
<hr>
<h4 id="案例-4-java-lang-String-对象-JDK-8"><a href="#案例-4-java-lang-String-对象-JDK-8" class="headerlink" title="案例 4: java.lang.String 对象 (JDK 8+)"></a>案例 4: <code>java.lang.String</code> 对象 (JDK 8+)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">// JOL 输出 (简化)</span></span><br><span class="line">OFF  SZ     TYPE DESCRIPTION               VALUE</span><br><span class="line">  <span class="number">0</span>   <span class="number">8</span>          (object header: mark)     ...</span><br><span class="line">  <span class="number">8</span>   <span class="number">4</span>          (object header: class)    ...</span><br><span class="line"> <span class="number">12</span>   <span class="number">4</span>   <span class="type">byte</span>[] String.value              [] <span class="comment">// 引用，指向实际字节数组</span></span><br><span class="line"> <span class="number">16</span>   <span class="number">4</span>      <span class="type">int</span> String.hash               <span class="number">0</span></span><br><span class="line"> <span class="number">20</span>   <span class="number">1</span>     <span class="type">byte</span> String.coder              <span class="number">0</span> <span class="comment">// UTF-16 编码标识</span></span><br><span class="line"> <span class="number">21</span>   <span class="number">3</span>          (object alignment gap)    <span class="comment">// 对齐填充！注意这里</span></span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>分析</strong>：<ul>
<li>对象头: 12B</li>
<li>实例数据: <code>byte[] value</code> (4B) + <code>int hash</code> (4B) + <code>byte coder</code> (1B) &#x3D; 9B</li>
<li><strong>小计</strong>: 12B + 9B &#x3D; 21B</li>
<li><strong>填充</strong>: 21B 不是 8 的倍数，需要填充 3B 达到 24B。</li>
</ul>
</li>
<li><strong>结论</strong>：一个看似空的 <code>String</code> 对象本身也占用 <strong>24 字节</strong>。这还不包括它内部 <code>byte[] value</code> 数组所占用的内存。</li>
</ul>
<hr>
<h3 id="3-4-数组对象的内存布局"><a href="#3-4-数组对象的内存布局" class="headerlink" title="3.4 数组对象的内存布局"></a>3.4 数组对象的内存布局</h3><p>数组也是对象，其布局与普通对象类似，但对象头中包含一个额外的 <strong>4 字节</strong> 的<strong>数组长度</strong>字段。</p>
<h4 id="案例-5-int-4-数组对象"><a href="#案例-5-int-4-数组对象" class="headerlink" title="案例 5: int[4] 数组对象"></a>案例 5: <code>int[4]</code> 数组对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码</span></span><br><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="comment">// JOL 输出 (简化)</span></span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  <span class="number">0</span>   <span class="number">8</span>        (object header: mark)     ...</span><br><span class="line">  <span class="number">8</span>   <span class="number">4</span>        (object header: class)    ... <span class="comment">// 指向 int[] 类元数据</span></span><br><span class="line"> <span class="number">12</span>   <span class="number">4</span>        (array length)            <span class="number">4</span>   <span class="comment">// 额外字段！</span></span><br><span class="line"> <span class="number">16</span>   <span class="number">4</span>    <span class="type">int</span> [<span class="number">0</span>]                       <span class="number">0</span></span><br><span class="line"> <span class="number">20</span>   <span class="number">4</span>    <span class="type">int</span> [<span class="number">1</span>]                       <span class="number">0</span></span><br><span class="line"> <span class="number">24</span>   <span class="number">4</span>    <span class="type">int</span> [<span class="number">2</span>]                       <span class="number">0</span></span><br><span class="line"> <span class="number">28</span>   <span class="number">4</span>    <span class="type">int</span> [<span class="number">3</span>]                       <span class="number">0</span></span><br><span class="line">Instance size: <span class="number">32</span> bytes</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>分析</strong>：<ul>
<li><strong>对象头</strong>: 8B (Mark Word) + 4B (Klass Pointer) + 4B (数组长度) &#x3D; <strong>16B</strong></li>
<li><strong>实例数据</strong>: 4 个 <code>int</code> * 4B &#x3D; <strong>16B</strong></li>
<li><strong>总计</strong>: 16B + 16B &#x3D; 32B，刚好是 8 的倍数，无需填充。</li>
</ul>
</li>
<li><strong>结论</strong>：一个 <code>int[4]</code> 数组占用 <strong>32 字节</strong>。</li>
</ul>
<hr>
<h4 id="案例-6-String-3-引用类型数组-对象"><a href="#案例-6-String-3-引用类型数组-对象" class="headerlink" title="案例 6: String[3] (引用类型数组) 对象"></a>案例 6: <code>String[3]</code> (引用类型数组) 对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码</span></span><br><span class="line">String[] strArray = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// JOL 输出 (简化)</span></span><br><span class="line">OFF  SZ     TYPE DESCRIPTION               VALUE</span><br><span class="line">  <span class="number">0</span>   <span class="number">8</span>          (object header: mark)     ...</span><br><span class="line">  <span class="number">8</span>   <span class="number">4</span>          (object header: class)    ... <span class="comment">// 指向 String[] 类元数据</span></span><br><span class="line"> <span class="number">12</span>   <span class="number">4</span>          (array length)            <span class="number">3</span>   <span class="comment">// 额外字段！</span></span><br><span class="line"> <span class="number">16</span>   <span class="number">4</span>   String [<span class="number">0</span>]                       <span class="literal">null</span> <span class="comment">// 引用</span></span><br><span class="line"> <span class="number">20</span>   <span class="number">4</span>   String [<span class="number">1</span>]                       <span class="literal">null</span> <span class="comment">// 引用</span></span><br><span class="line"> <span class="number">24</span>   <span class="number">4</span>   String [<span class="number">2</span>]                       <span class="literal">null</span> <span class="comment">// 引用</span></span><br><span class="line"> <span class="number">28</span>   <span class="number">4</span>          (object alignment gap)        <span class="comment">// 对齐填充</span></span><br><span class="line">Instance size: <span class="number">32</span> bytes</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>分析</strong>：<ul>
<li><strong>对象头</strong>: 8B + 4B + 4B &#x3D; <strong>16B</strong></li>
<li><strong>实例数据</strong>: 3 个引用 * 4B &#x3D; <strong>12B</strong></li>
<li><strong>小计</strong>: 16B + 12B &#x3D; 28B</li>
<li><strong>填充</strong>: 28B 不是 8 的倍数，需要填充 4B 达到 32B。</li>
</ul>
</li>
<li><strong>结论</strong>：一个 <code>String[3]</code> 数组<strong>容器本身</strong>占用 <strong>32 字节</strong>。注意，这<strong>不包含</strong><code>String</code>元素对象本身的大小。</li>
</ul>
<hr>
<h3 id="3-5-总结与要点"><a href="#3-5-总结与要点" class="headerlink" title="3.5 总结与要点"></a>3.5 总结与要点</h3><ol>
<li><strong>固定开销</strong>：每个对象都有对象头的固定开销（普通对象12B，数组对象16B）。</li>
<li><strong>空间换时间</strong>：对齐填充机制用空间换取了CPU访问内存的速度。</li>
<li><strong>包装类型成本高</strong>：推荐在大量使用时使用基本类型而非包装类型（如 <code>int</code> vs <code>Integer</code>）。</li>
<li><strong>工具的重要性</strong>：使用 <strong>JOL (Java Object Layout)</strong> 工具可以直观地查看对象内存布局，避免理论计算的误差。</li>
<li><strong>数组的特殊性</strong>：数组对象头多一个 4B 的 length 字段。引用类型数组存储的是引用，而非对象本身。</li>
<li><strong>完整内存分析</strong>：分析复杂对象（如<code>String</code>、集合类）的内存占用时，需考虑其内部所有引用的对象。</li>
</ol>
<p><strong>如何使用 JOL</strong>:</p>
<ol>
<li><p>在 Maven 项目中添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 使用最新版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在代码中解析实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="4-Java内存分配"><a href="#4-Java内存分配" class="headerlink" title="4. Java内存分配"></a>4. Java内存分配</h2><p>Java 内存分配主要可以分为两大块：<strong>内存区域</strong> 和<strong>内存模型</strong>。</p>
<ol>
<li><strong>内存区域</strong> 指的是 JVM 在运行时将其管理的内存划分为几个不同用途的区域，这是《Java 虚拟机规范》中定义的概念。</li>
<li><strong>内存模型</strong> (JMM) 则是一个抽象概念，定义了线程如何与内存交互，主要是为了解决多线程环境下的可见性、有序性问题。</li>
</ol>
<h3 id="4-1-Java-运行时数据区"><a href="#4-1-Java-运行时数据区" class="headerlink" title="4.1 Java 运行时数据区"></a>4.1 Java 运行时数据区</h3><p>当 Java 程序运行时，JVM 会把它管理的内存划分为以下几个不同的数据区域。这些区域有些是线程私有的，随着线程的创建和销毁而存在；有些则是线程共享的，随着虚拟机的启动而创建，关闭而销毁。</p>
<p>下图清晰地展示了这些区域及其线程共享状态：</p>
<pre><code class="highlight mermaid">graph TD
    A[&quot;Java 运行时数据区&quot;] --&gt; B[&quot;线程私有&quot;]
    A --&gt; C[&quot;线程共享&quot;]

    subgraph 线程私有
        B --&gt; D[&quot;程序计数器&lt;br/&gt;Program Counter Register&quot;]
        B --&gt; E[&quot;Java 虚拟机栈&lt;br/&gt;JVM Stack&quot;]
        B --&gt; F[&quot;本地方法栈&lt;br/&gt;Native Method Stack&quot;]
    end

    subgraph 线程共享
        C --&gt; G[&quot;Java 堆&lt;br/&gt;Java Heap&quot;]
        C --&gt; H[&quot;方法区&lt;br/&gt;Method Area&quot;]
    end

    H --&gt; I[&quot;运行时常量池&lt;br/&gt;Runtime Constant Pool&quot;]</code></pre>

<hr>
<h4 id="4-1-1-程序计数器-Program-Counter-Register"><a href="#4-1-1-程序计数器-Program-Counter-Register" class="headerlink" title="4.1.1 程序计数器 (Program Counter Register)"></a>4.1.1 程序计数器 (Program Counter Register)</h4><ul>
<li><strong>作用</strong>： 它可以看作是当前线程所执行的<strong>字节码的行号指示器</strong>。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li>
<li><strong>特点</strong>：<ul>
<li><strong>线程私有</strong>：每条线程都有一个独立的程序计数器，各条线程之间互不影响，独立存储。</li>
<li>如果线程正在执行的是一个 <strong>Java 方法</strong>，这个计数器记录的是正在执行的虚拟机字节码指令的地址。</li>
<li>如果正在执行的是 <strong>Native 方法</strong>（本地方法，如用 C&#x2F;C++ 实现的方法），这个计数器的值则为<strong>空 (Undefined)</strong>。</li>
<li>此区域是唯一一个在《Java 虚拟机规范》中<strong>没有规定任何 <code>OutOfMemoryError</code> 情况</strong>的区域。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-1-2-Java-虚拟机栈-Java-Virtual-Machine-Stacks"><a href="#4-1-2-Java-虚拟机栈-Java-Virtual-Machine-Stacks" class="headerlink" title="4.1.2 Java 虚拟机栈 (Java Virtual Machine Stacks)"></a>4.1.2 Java 虚拟机栈 (Java Virtual Machine Stacks)</h4><ul>
<li><strong>作用</strong>： 描述的是 <strong>Java 方法执行的内存模型</strong>。每个方法在执行的同时都会创建一个 <strong>栈帧 (Stack Frame)</strong>，用于存储<strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
<li><strong>栈帧 (Stack Frame)</strong> 详解：<ul>
<li><strong>局部变量表 (Local Variable Table)</strong>： 存放了编译期可知的各种<strong>基本数据类型</strong> (<code>boolean</code>, <code>byte</code>, <code>char</code>, <code>short</code>, <code>int</code>, <code>float</code>, <code>long</code>, <code>double</code>)、<strong>对象引用</strong> (<code>reference</code> 类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置&#96;) 和 <strong>returnAddress 类型</strong>（指向了一条字节码指令的地址）。</li>
<li><strong>操作数栈 (Operand Stack)</strong>： 方法执行过程中，各种字节码指令往操作数栈中写入和提取内容，即入栈和出栈。</li>
<li><strong>动态链接 (Dynamic Linking)</strong>： 指向运行时常量池中该栈帧所属方法的引用。</li>
<li><strong>方法返回地址 (Return Address)</strong>： 方法退出后，需要返回到方法被调用的位置，程序计数器中的值就是通过这个来恢复的。</li>
</ul>
</li>
<li><strong>异常状况</strong>：<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 <strong><code>StackOverflowError</code></strong> 异常（例如无限递归）。</li>
<li>如果虚拟机栈可以动态扩展（当前大部分 Java 虚拟机都可动态扩展，只不过规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出 <strong><code>OutOfMemoryError</code></strong> 异常。</li>
</ul>
</li>
<li><strong>特点</strong>： <strong>线程私有</strong>，生命周期与线程相同。</li>
</ul>
<hr>
<h4 id="4-1-3-本地方法栈-Native-Method-Stack"><a href="#4-1-3-本地方法栈-Native-Method-Stack" class="headerlink" title="4.1.3 本地方法栈 (Native Method Stack)"></a>4.1.3 本地方法栈 (Native Method Stack)</h4><ul>
<li><strong>作用</strong>： 与虚拟机栈非常相似。其区别在于：<strong>虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong></li>
<li><strong>特点</strong>： 与虚拟机栈一样，本地方法栈区域也会抛出 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 异常。</li>
<li><strong>注意</strong>： HotSpot 虚拟机直接就把本地方法栈和虚拟机栈合二为一了。</li>
</ul>
<hr>
<h4 id="4-1-4-Java-堆-Java-Heap"><a href="#4-1-4-Java-堆-Java-Heap" class="headerlink" title="4.1.4 Java 堆 (Java Heap)"></a>4.1.4 Java 堆 (Java Heap)</h4><ul>
<li><strong>作用</strong>： 这是 <strong>最核心</strong> 的内存区域，<strong>此内存区域的唯一目的就是存放对象实例</strong>。几乎所有的对象实例以及数组都在这里分配内存。“几乎所有”是因为随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术会导致一些微妙的变化发生，所有对象都分配在堆上也渐渐变得不是那么“绝对”了。</li>
<li><strong>特点</strong>：<ul>
<li><strong>线程共享</strong>：Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</li>
<li><strong>GC 的主要管理区域</strong>：由于现代垃圾收集器基本都采用分代收集算法，所以 Java 堆中还可以细分为：<strong>新生代 (Young Generation)</strong> 和 <strong>老年代 (Old Generation&#x2F;Tenured Generation)</strong>。新生代又可以细分为 Eden 空间、From Survivor 空间、To Survivor 空间等。这样划分是为了更好地进行内存回收和分配。</li>
<li><strong>异常状况</strong>： 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 <strong><code>OutOfMemoryError</code></strong> 异常（俗称 <code>java.lang.OutOfMemoryError: Java heap space</code>）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-1-5-方法区-Method-Area"><a href="#4-1-5-方法区-Method-Area" class="headerlink" title="4.1.5. 方法区 (Method Area)"></a>4.1.5. 方法区 (Method Area)</h4><ul>
<li><strong>作用</strong>： 用于存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等数据。</li>
<li><strong>运行时常量池 (Runtime Constant Pool)</strong>： 它是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<strong>常量池表 (Constant Pool Table)</strong>，用于存放编译期生成的各种<strong>字面量</strong>和<strong>符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</li>
<li><strong>演进历史</strong>：<ul>
<li>在 JDK 1.7 之前，方法区的实现通常被称为 <strong>“永久代” (PermGen)</strong>。</li>
<li>在 JDK 1.8 及之后，HotSpot 虚拟机彻底移除了永久代，改用 <strong>元空间 (Metaspace)</strong> 来实现方法区。元空间不再使用虚拟机的内存，而是使用<strong>本地内存 (Native Memory)</strong>。</li>
</ul>
</li>
<li><strong>异常状况</strong>：<ul>
<li>当方法区（或元空间）无法满足内存分配需求时，将抛出 <strong><code>OutOfMemoryError</code></strong> 异常（在 JDK 1.8 之前是 <code>java.lang.OutOfMemoryError: PermGen space</code>，之后是 <code>java.lang.OutOfMemoryError: Metaspace</code>）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-2-示例"><a href="#4-2-示例" class="headerlink" title="4.2 示例"></a>4.2 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 实例变量，随对象存放在堆中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;     <span class="comment">// 实例变量，随对象存放在堆中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123; <span class="comment">// 方法信息存放在方法区</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="string">&quot;Hello!&quot;</span>; <span class="comment">// 局部变量，存放在sayHello方法的栈帧的局部变量表中</span></span><br><span class="line">        System.out.println(greeting + <span class="string">&quot; I&#x27;m &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">123</span>; <span class="comment">// 局部变量，存放在main方法的栈帧的局部变量表中</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>); <span class="comment">// s是对象引用，在栈中；new Student(...)是对象本身，在堆中。</span></span><br><span class="line">        s.sayHello(); <span class="comment">// 调用方法，为sayHello创建新的栈帧</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>编译</strong>：<code>javac</code> 命令将 <code>.java</code> 文件编译为 <code>.class</code> 文件，其中的常量等信息会存入常量池表。</li>
<li><strong>类加载</strong>：JVM 启动 <code>Main</code> 类，将 <code>Main</code> 和 <code>Student</code> 的类信息、常量、静态变量等加载到<strong>方法区</strong>。</li>
<li><strong>执行 <code>main</code> 方法</strong>：<ul>
<li>为 <code>main</code> 方法创建一个<strong>栈帧</strong>，压入<strong>虚拟机栈</strong>。</li>
<li>局部变量 <code>id</code>（基本类型）和 <code>s</code>（引用类型）存储在 <code>main</code> 栈帧的<strong>局部变量表</strong>中。</li>
</ul>
</li>
<li><strong>创建 <code>Student</code> 对象</strong>：<ul>
<li><code>new Student(&quot;Alice&quot;, 20)</code> 会在 <strong>Java 堆</strong> 中分配内存，创建 <code>Student</code> 对象实例，并初始化其字段 <code>name</code> 和 <code>age</code>。</li>
<li>对象中包含了指向方法区中 <code>Student</code> 类类型信息的指针。</li>
</ul>
</li>
<li><strong>赋值</strong>：将堆中对象的地址赋值给栈帧局部变量表中的引用变量 <code>s</code>。</li>
<li><strong>调用方法</strong>：<ul>
<li>执行 <code>s.sayHello()</code> 时，JVM 会为 <code>sayHello</code> 方法创建一个新的<strong>栈帧</strong>并压入栈。</li>
<li>方法中的局部变量 <code>greeting</code> 存放在 <code>sayHello</code> 栈帧的<strong>局部变量表</strong>中。</li>
<li>方法执行完毕后，其对应的栈帧出栈，局部变量 <code>greeting</code> 随之销毁。</li>
</ul>
</li>
<li><strong>程序结束</strong>：<code>main</code> 方法执行完毕，其栈帧出栈，JVM 退出。</li>
</ol>
<hr>
<h3 id="4-3-总结与对比"><a href="#4-3-总结与对比" class="headerlink" title="4.3 总结与对比"></a>4.3 总结与对比</h3><table>
<thead>
<tr>
<th align="left">内存区域</th>
<th align="left">线程共享？</th>
<th align="left">作用</th>
<th align="left">异常</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>程序计数器</strong></td>
<td align="left">私有</td>
<td align="left">当前线程执行的字节码行号指示器</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><strong>虚拟机栈</strong></td>
<td align="left">私有</td>
<td align="left">存储 Java 方法调用的栈帧</td>
<td align="left"><code>StackOverflowError</code> <code>OutOfMemoryError</code></td>
</tr>
<tr>
<td align="left"><strong>本地方法栈</strong></td>
<td align="left">私有</td>
<td align="left">存储 Native 方法调用的栈帧</td>
<td align="left"><code>StackOverflowError</code> <code>OutOfMemoryError</code></td>
</tr>
<tr>
<td align="left"><strong>Java 堆</strong></td>
<td align="left"><strong>共享</strong></td>
<td align="left"><strong>存储对象实例和数组</strong></td>
<td align="left"><strong><code>OutOfMemoryError</code></strong></td>
</tr>
<tr>
<td align="left"><strong>方法区</strong></td>
<td align="left"><strong>共享</strong></td>
<td align="left">存储类信息、常量、静态变量等</td>
<td align="left"><strong><code>OutOfMemoryError</code></strong></td>
</tr>
</tbody></table>
<p><strong>核心要点</strong>：</p>
<ul>
<li><strong>栈</strong>：解决的是程序运行的问题，即方法如何执行、数据如何处理。生命周期与线程相同，存取速度<strong>快</strong>。</li>
<li><strong>堆</strong>：解决的是数据存储的问题，即对象和数组怎么放、放在哪。是 GC 的主战场，生命周期与虚拟机相同，存取速度<strong>相对慢</strong>。</li>
<li>理解 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 的区别：一个是因为<strong>栈深度</strong>太大（通常是代码bug），另一个是因为<strong>内存空间</strong>不足（可能是代码bug，也可能是正常需要调大内存配置）。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%B8%80%E3%80%81Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="冉丝堂">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冉的技术宝典">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | 冉的技术宝典">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/06/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/%E4%B8%80%E3%80%81Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">一、Java语法基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-06 18:00:00" itemprop="dateCreated datePublished" datetime="2025-09-06T18:00:00+08:00">2025-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 11:08:05" itemprop="dateModified" datetime="2025-10-17T11:08:05+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/" itemprop="url" rel="index"><span itemprop="name">基础核心层</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%B1%82/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、Java语法基础"><a href="#一、Java语法基础" class="headerlink" title="一、Java语法基础"></a>一、Java语法基础</h1><h2 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h2><h3 id="1-1-单行注释"><a href="#1-1-单行注释" class="headerlink" title="1.1 单行注释"></a>1.1 单行注释</h3><p>使用 <code>//</code> 进行标记，通常用于对单行代码进行简短说明</p>
<p><strong>规范：</strong></p>
<ul>
<li><strong>位置</strong>：通常放在要注释代码的上一行</li>
<li><strong>内容</strong>：简洁明了，说明“为什么”这么做，而不是“做什么”（代码本身能说明做什么）</li>
<li><strong>空格</strong>：<code>//</code> 后应有一个空格</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算两项之和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a + b; </span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-2-多行注释"><a href="#1-2-多行注释" class="headerlink" title="1.2 多行注释"></a>1.2 多行注释</h3><p>使用 <code>/* ... */</code> 进行标记，用于对一段代码进行较详细的说明</p>
<p><strong>规范：</strong></p>
<ul>
<li><strong>格式</strong>：每行以 <code>*</code> 开头，并且 <code>*</code> 纵向对齐。</li>
<li><strong>首行和尾行</strong>：首行为 <code>/*</code>，中间行以 <code>*</code> 开头，尾行为 <code>*/</code>。</li>
<li><strong>缩进</strong>：与描述的代码保持相同的缩进级别。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这是一个多行注释的示例。</span></span><br><span class="line"><span class="comment"> * 它通常用于解释一段复杂的算法或者暂时屏蔽一大块代码。</span></span><br><span class="line"><span class="comment"> * 第二行和后续行的星号应该对齐。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complexMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="1-3-文档注释"><a href="#1-3-文档注释" class="headerlink" title="1.3 文档注释"></a>1.3 文档注释</h3><p>这是 <strong>最重要</strong> 的一种注释，使用 <code>/** ... */</code> 进行标记。用于生成正式的 API 文档（通过 <code>javadoc</code> 命令）</p>
<p><strong>规范：</strong></p>
<ul>
<li><strong>位置</strong>：用于声明 <strong>类、接口、方法、构造函数、字段</strong> 之前</li>
<li><strong>内容</strong>：首先是一段描述，然后使用特定的 <strong>标签</strong> 来提供特定信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示一个简单的银行账户类。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这个类提供了基本的存款、取款和查询余额的功能。</span></span><br><span class="line"><span class="comment"> * 它不是线程安全的，在多线程环境下使用需要外部同步。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  HuangJinCheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.util.Random</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   2025-09-04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个新的银行账户，初始余额为0。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BankAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从账户中存款。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> amount 要存入的金额。必须为正数，否则操作无效。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException 如果参数 amount 是负数或NaN。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> amount)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt;= <span class="number">0</span> || Double.isNaN(amount)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;存款金额必须为正数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        balance += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从账户中取款。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  amount 要取出的金额。必须为正数且不能超过当前余额。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>        取款是否成功。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InsufficientFundsException 如果余额不足。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> amount)</span> <span class="keyword">throws</span> InsufficientFundsException &#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; balance) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientFundsException</span>(<span class="string">&quot;余额不足。当前余额: &quot;</span> + balance);</span><br><span class="line">        &#125;</span><br><span class="line">        balance -= amount;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取账户当前余额。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前的账户余额。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文档注释常用的javadoc标签"><a href="#文档注释常用的javadoc标签" class="headerlink" title="文档注释常用的javadoc标签"></a>文档注释常用的javadoc标签</h4><table>
<thead>
<tr>
<th align="left">标签</th>
<th align="left">语法示例</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>@param</code></td>
<td align="left"><code>@param paramName description</code></td>
<td align="left">描述方法的参数。每个参数一个标签。</td>
</tr>
<tr>
<td align="left"><code>@return</code></td>
<td align="left"><code>@return description</code></td>
<td align="left">描述方法的返回值。对于返回 <code>void</code> 的方法，可省略。</td>
</tr>
<tr>
<td align="left"><code>@throws</code> &#x2F; <code>@exception</code></td>
<td align="left"><code>@throws ExceptionClass reason</code></td>
<td align="left">描述方法可能抛出的异常。</td>
</tr>
<tr>
<td align="left"><code>@see</code></td>
<td align="left"><code>@see reference</code></td>
<td align="left">添加一个“参见”的链接，可以是类、方法或URL。</td>
</tr>
<tr>
<td align="left"><code>@since</code></td>
<td align="left"><code>@since version</code></td>
<td align="left">指明引入该功能或类的版本号。</td>
</tr>
<tr>
<td align="left"><code>@deprecated</code></td>
<td align="left"><code>@deprecated explanation</code></td>
<td align="left">标记该方法或类已过时，并说明替代方案。</td>
</tr>
<tr>
<td align="left"><code>{@code text}</code></td>
<td align="left"><code>{@code code snippet}</code></td>
<td align="left">将文本以代码字体显示，但不进行HTML解析。</td>
</tr>
<tr>
<td align="left"><code>{@link package.Class#member label}</code></td>
<td align="left"><code>{@link String}</code></td>
<td align="left">创建一个内联链接，指向其他类或成员的文档。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-4-最佳实践与原则"><a href="#1-4-最佳实践与原则" class="headerlink" title="1.4 最佳实践与原则"></a>1.4 最佳实践与原则</h3><ul>
<li><p><strong>注释是给“人”看的</strong>：不要注释“代码在做什么”（<code>i++ // i增加1</code>），而要注释“代码为什么这么做”、“背后的业务逻辑或算法”、“有何限制或前提条件”</p>
</li>
<li><p><strong>保持更新</strong>：代码修改时，一定要同步更新相关的注释。<strong>过时的注释比没有注释更糟糕</strong></p>
</li>
<li><p><strong>公共API必须加文档注释</strong>：所有对外开放的类、接口、公共方法和字段都应该使用 <code>/** ... */</code> 进行完整描述。这是团队协作和生成API文档的基础</p>
</li>
<li><p><strong>避免冗余</strong>：代码清晰明了是最好的注释</p>
<ul>
<li><strong>坏注释</strong>：<code>int size; // 列表的大小</code></li>
<li><strong>好代码（无需注释）</strong>：<code>int itemCount;</code></li>
</ul>
</li>
<li><p><strong>使用 TODO 和 FIXME</strong>：这是一种特殊的单行注释，用于标记待办事项和需要修复的问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 未来需要优化这个算法的时间复杂度</span></span><br><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> 这里的边界条件处理存在潜在风险，需要重构</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除注释掉的代码</strong>：版本控制工具（如Git）会帮你记住旧代码，不要将大段被注释掉的代码提交到仓库，它们会严重干扰阅读</p>
</li>
</ul>
<hr>
<hr>
<h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><p>Java 的数据类型可分为两大类：<strong>基本数据类型</strong> 和 <strong>引用数据类型</strong></p>
<pre><code class="highlight mermaid">graph TD
    A[&quot;Java数据类型&quot;] --&gt; B[&quot;基本数据类型&quot;]
    A --&gt; C[&quot;引用数据类型&quot;]

    subgraph 基本数据类型
        B --&gt; D[&quot;数值型&quot;]
        B --&gt; E[&quot;非数值型&quot;]
    end

    subgraph 数值型
        D --&gt; F[&quot;整数类型&quot;]
        D --&gt; G[&quot;浮点类型&quot;]
    end

    subgraph 整数类型
        F --&gt; H[&quot;byte&lt;br/&gt;8位&quot;]
        F --&gt; I[&quot;short&lt;br/&gt;16位&quot;]
        F --&gt; J[&quot;int&lt;br/&gt;32位&quot;]
        F --&gt; K[&quot;long&lt;br/&gt;64位&quot;]
    end

    subgraph 浮点类型
        G --&gt; L[&quot;float&lt;br/&gt;32位&quot;]
        G --&gt; M[&quot;double&lt;br/&gt;64位&quot;]
    end

    subgraph 非数值型
        E --&gt; N[&quot;char&lt;br/&gt;16位 Unicode&quot;]
        E --&gt; O[&quot;boolean&lt;br/&gt;true / false&quot;]
    end

    subgraph 引用数据类型
        C --&gt; P[&quot;类Class&quot;]
        C --&gt; Q[&quot;接口Interface&quot;]
        C --&gt; R[&quot;数组Array&quot;]
        C --&gt; S[&quot;枚举Enum&quot;]
        C --&gt; T[&quot;注解Annotation&quot;]
    end

    P --&gt; U[&quot;String&lt;br/&gt;(最常用的类)&quot;]</code></pre>

<h3 id="2-1-基本数据类型"><a href="#2-1-基本数据类型" class="headerlink" title="2.1 基本数据类型"></a>2.1 基本数据类型</h3><p>基本数据类型是 Java 内置的、不可再分的最基础数据类型。它们直接存储在<strong>栈内存</strong>中，存储的是变量的<strong>实际值</strong>。共有 8 种基本数据类型，可分为 4 类：</p>
<h4 id="2-1-1-整数类型"><a href="#2-1-1-整数类型" class="headerlink" title="2.1.1 整数类型"></a>2.1.1 整数类型</h4><p>用于存储整数，根据表示范围的不同分为 4 种：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">取值范围</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>byte</code></td>
<td align="left">8 位 (1字节)</td>
<td align="left">-128 ~ 127</td>
<td align="left">0</td>
<td align="left">常用于处理二进制数据（如文件读写）</td>
</tr>
<tr>
<td align="left"><code>short</code></td>
<td align="left">16 位 (2字节)</td>
<td align="left">-32,768 ~ 32,767</td>
<td align="left">0</td>
<td align="left">较少使用</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left"><strong>32 位 (4字节)</strong></td>
<td align="left">-2³¹ ~ 2³¹-1 (约 -21亿 ~ 21亿)</td>
<td align="left">0</td>
<td align="left"><strong>最常用</strong>的整数类型。</td>
</tr>
<tr>
<td align="left"><code>long</code></td>
<td align="left">64 位 (8字节)</td>
<td align="left">-2⁶³ ~ 2⁶³-1</td>
<td align="left">0L</td>
<td align="left">表示很大整数时使用，定义时加 <code>L</code> 后缀</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">population</span> <span class="operator">=</span> <span class="number">7_900_000_000L</span>; <span class="comment">// 使用下划线分隔提高可读性</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-2-浮点类型"><a href="#2-1-2-浮点类型" class="headerlink" title="2.1.2 浮点类型"></a>2.1.2 浮点类型</h4><p>用于存储带小数点的数字（实数）</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">取值范围</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>float</code></td>
<td align="left">32 位 (4字节)</td>
<td align="left">大约 ±3.4E+38</td>
<td align="left">0.0f</td>
<td align="left">单精度，精度较低。定义时需加 <code>F</code> 后缀。</td>
</tr>
<tr>
<td align="left"><code>double</code></td>
<td align="left"><strong>64 位 (8字节)</strong></td>
<td align="left">大约 ±1.7E+308</td>
<td align="left">0.0d</td>
<td align="left"><strong>最常用</strong>的浮点类型，双精度，精度是 float 的两倍。</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">19.99</span>; <span class="comment">// 默认的浮点字面量是 double 类型</span></span><br><span class="line"><span class="type">float</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">1.75f</span>; <span class="comment">// 必须加 &#x27;f&#x27; 或 &#x27;F&#x27; 后缀</span></span><br><span class="line"><span class="type">double</span> <span class="variable">scientific</span> <span class="operator">=</span> <span class="number">2.5e-5</span>; <span class="comment">// 科学计数法表示 0.000025</span></span><br></pre></td></tr></table></figure>

<h5 id="单精度与双精度"><a href="#单精度与双精度" class="headerlink" title="单精度与双精度"></a>单精度与双精度</h5><ol>
<li><strong>符号位 (Sign bit)</strong>： 1 位，表示正负。</li>
<li><strong>指数位 (Exponent bits)</strong>：<ul>
<li><code>float</code> 用 <strong>8 位</strong>表示指数，决定了数的<strong>范围</strong>。</li>
<li><code>double</code> 用 <strong>11 位</strong>表示指数，因此范围更大。</li>
</ul>
</li>
<li><strong>尾数位&#x2F;小数位 (Mantissa&#x2F;Significand bits)</strong>：<ul>
<li><code>float</code> 用 <strong>23 位</strong>表示小数部分，决定了数的<strong>精度</strong>。</li>
<li><code>double</code> 用 <strong>52 位</strong>表示小数部分，因此精度更高。</li>
</ul>
</li>
</ol>
<p><strong>精度损失示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrecisionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 单精度</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">floatSum</span> <span class="operator">=</span> <span class="number">0.1f</span> + <span class="number">0.2f</span>;</span><br><span class="line">        <span class="comment">// 双精度</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">doubleSum</span> <span class="operator">=</span> <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Float: 0.1 + 0.2 = &quot;</span> + floatSum); <span class="comment">// 输出：0.3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Double: 0.1 + 0.2 = &quot;</span> + doubleSum); <span class="comment">// 输出：0.30000000000000004</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更明显的比较</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">123456789f</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">123456789d</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Float: &quot;</span> + f1);  <span class="comment">// 输出：1.23456792E8 (123456792)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Double: &quot;</span> + d1); <span class="comment">// 输出：1.23456789E8 (123456789)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：<code>0.1</code> 和 <code>0.2</code> 在二进制浮点数中无法被精确表示（就像 <code>1/3</code> 在十进制中无法精确表示一样），会有微小的误差。由于 <code>double</code> 的精度更高，它累积的误差比 <code>float</code> 更小，但依然存在。这就是为什么<strong>永远不要用 <code>float</code> 或 <code>double</code> 来进行精确的货币计算</strong>（应使用 <code>BigDecimal</code>）</p>
<p><strong>声明与后缀的重要性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuffixDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 错误：类型不匹配，默认的 3.14 是 double 类型，不能直接赋给 float 变量</span></span><br><span class="line">        <span class="comment">// float errorFloat = 3.14;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正确：使用 &#x27;f&#x27; 后缀明确指定为 float 字面量</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">correctFloat</span> <span class="operator">=</span> <span class="number">3.14f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正确：直接使用 double</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">correctDouble</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正确但不好：强制类型转换（可能丢失精度）</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">castFloat</span> <span class="operator">=</span> (<span class="type">float</span>) <span class="number">3.14</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-3-字符类型"><a href="#2-1-3-字符类型" class="headerlink" title="2.1.3 字符类型"></a>2.1.3 字符类型</h4><p>用于存储单个字符</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">取值范围</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>char</code></td>
<td align="left">16 位 (2字节)</td>
<td align="left">‘\u0000’ ~ ‘\uffff’</td>
<td align="left">‘\u0000’</td>
<td align="left">采用 <strong>Unicode</strong> 编码，可以表示中文字符等。</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">grade</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">chineseChar</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">unicodeChar</span> <span class="operator">=</span> <span class="string">&#x27;\u0041&#x27;</span>; <span class="comment">// 表示字符 &#x27;A&#x27;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-1-4-布尔类型"><a href="#2-1-4-布尔类型" class="headerlink" title="2.1.4 布尔类型"></a>2.1.4 布尔类型</h4><p>用于表示逻辑真或假</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小（官方未明确定义）</th>
<th align="left">取值范围</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>boolean</code></td>
<td align="left">通常按 1 位考虑</td>
<td align="left"><code>true</code> &#x2F; <code>false</code></td>
<td align="left">false</td>
<td align="left">用于条件判断和循环控制。**注意：**在JVM中可能会用int或byte实现，但行为上只有true和false。</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isJavaFun</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFinished</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-引用数据类型"><a href="#2-2-引用数据类型" class="headerlink" title="2.2 引用数据类型"></a>2.2 引用数据类型</h3><p>引用类型变量存储的是对象在<strong>堆内存</strong>中的<strong>地址</strong>（即引用），而不是对象本身的值。所有不属于基本数据类型的都是引用类型</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类</strong></td>
<td align="left">最常见的引用类型，例如自定义的类或 Java API 中的类（如 <code>String</code>）。</td>
<td align="left"><code>String name = &quot;Alice&quot;;</code> <code>Scanner input = new Scanner(System.in);</code></td>
</tr>
<tr>
<td align="left"><strong>接口</strong></td>
<td align="left">接口不能直接实例化，但可以声明其引用变量来指向实现了该接口的类的对象。</td>
<td align="left"><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code></td>
</tr>
<tr>
<td align="left"><strong>数组</strong></td>
<td align="left">数组是对象，无论是基本类型数组还是对象数组，都是引用类型。</td>
<td align="left"><code>int[] numbers = new int[5];</code> <code>String[] words = {&quot;hello&quot;, &quot;world&quot;};</code></td>
</tr>
<tr>
<td align="left"><strong>枚举</strong></td>
<td align="left">一种特殊的类，用于表示一组固定的常量。</td>
<td align="left"><code>enum Day { SUNDAY, MONDAY... }</code> <code>Day today = Day.MONDAY;</code></td>
</tr>
<tr>
<td align="left"><strong>注解</strong></td>
<td align="left">用于为代码提供元数据。</td>
<td align="left"><code>@Override</code></td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 是最常用的引用类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组是引用类型</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arrRef = arr; <span class="comment">// arrRef 和 arr 指向同一个数组对象</span></span><br><span class="line">arrRef[<span class="number">0</span>] = <span class="number">100</span>;    <span class="comment">// 修改 arrRef 也会影响 arr</span></span><br><span class="line">System.out.println(arr[<span class="number">0</span>]); <span class="comment">// 输出 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-包装器类型"><a href="#2-3-包装器类型" class="headerlink" title="2.3 包装器类型"></a>2.3 包装器类型</h3><h4 id="2-3-1-简介"><a href="#2-3-1-简介" class="headerlink" title="2.3.1 简介"></a>2.3.1 简介</h4><p>用于将基本数据类型转换为对应的对象类型</p>
<table>
<thead>
<tr>
<th align="left">基本数据类型</th>
<th align="left">包装器类名</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>byte</code></td>
<td align="left"><strong>Byte</strong></td>
</tr>
<tr>
<td align="left"><code>short</code></td>
<td align="left"><strong>Short</strong></td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left"><strong>Integer</strong></td>
</tr>
<tr>
<td align="left"><code>long</code></td>
<td align="left"><strong>Long</strong></td>
</tr>
<tr>
<td align="left"><code>float</code></td>
<td align="left"><strong>Float</strong></td>
</tr>
<tr>
<td align="left"><code>double</code></td>
<td align="left"><strong>Double</strong></td>
</tr>
<tr>
<td align="left"><code>char</code></td>
<td align="left"><strong>Character</strong></td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left"><strong>Boolean</strong></td>
</tr>
</tbody></table>
<h5 id="代码示例：证明它是引用类型"><a href="#代码示例：证明它是引用类型" class="headerlink" title="代码示例：证明它是引用类型"></a>代码示例：证明它是引用类型</h5><ol>
<li><p><strong>默认值为 <code>null</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本数据类型</span></span><br><span class="line"><span class="type">int</span> primitiveInt; <span class="comment">// 如果不初始化，在类成员变量时默认为0</span></span><br><span class="line"><span class="comment">// 包装器类型</span></span><br><span class="line">Integer wrapperInt; <span class="comment">// 如果不初始化，在类成员变量时默认为null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>new</code> 关键字创建（经典的对象创建方式）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆内存中创建一个Integer对象，将其引用赋给变量a</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>==</code> 比较的是地址（引用类型的特点）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">System.out.println(i1 == i2); <span class="comment">// 输出 true (由于缓存，见后文说明)</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(i3 == i4); <span class="comment">// 输出 false！因为128超出了缓存范围，是两个不同的对象，地址不同。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的比较方式：使用.equals()方法比较值</span></span><br><span class="line">System.out.println(i3.equals(i4)); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可以作为泛型参数（泛型需要引用类型）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：不能使用基本数据类型作为泛型参数</span></span><br><span class="line"><span class="comment">// ArrayList&lt;int&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：必须使用包装器类型</span></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">5</span>); <span class="comment">// 自动装箱：int -&gt; Integer</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h5><ul>
<li><p><strong>自动装箱</strong>：将基本数据类型自动转换为对应的包装器对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 编译器自动转换为：Integer i = Integer.valueOf(10);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自动拆箱</strong>：将包装器对象自动转换为对应的基本数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i; <span class="comment">// 编译器自动转换为：int num = i.intValue();</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h5><p>为了提升性能和节省内存，部分包装类（如 <code>Integer</code>、<code>Byte</code>、<code>Short</code>、<code>Long</code>、<code>Character</code>、<code>Boolean</code>）在内部实现了<strong>缓存池</strong>。</p>
<p>最典型的是 <code>Integer</code>，默认缓存了 <strong>-128 到 127</strong> 之间的值。通过 <code>valueOf()</code> 方法（自动装箱就是调用这个方法）获取这个范围内的整数时，返回的是缓存池中同一个对象的引用（但如果是自己调用new来创建，则不会使用缓存池）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true，因为指向缓存池的同一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(c == d); <span class="comment">// false，因为128不在缓存范围内，会new新的对象</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-2-核心静态方法（用于转换和创建）"><a href="#2-3-2-核心静态方法（用于转换和创建）" class="headerlink" title="2.3.2 核心静态方法（用于转换和创建）"></a>2.3.2 核心静态方法（用于转换和创建）</h4><p>这些方法通常通过类名直接调用（如 <code>Integer.parseInt()</code>）。</p>
<h5 id="1-解析方法：将-String-转换为包装器对象或基本类型"><a href="#1-解析方法：将-String-转换为包装器对象或基本类型" class="headerlink" title="1. 解析方法：将 String 转换为包装器对象或基本类型"></a>1. 解析方法：将 <code>String</code> 转换为包装器对象或基本类型</h5><p>这是<strong>最常用</strong>的方法之一，常用于处理用户输入、文件读取或网络传输的字符串数据。</p>
<ul>
<li><code>parseXxx(String s)</code>：将字   符串解析为对应的<strong>基本数据类型</strong>。<ul>
<li><code>Integer.parseInt(&quot;123&quot;)</code> -&gt; 返回 <code>int</code> 类型的 <code>123</code></li>
<li><code>Double.parseDouble(&quot;3.14&quot;)</code> -&gt; 返回 <code>double</code> 类型的 <code>3.14</code></li>
<li><code>Boolean.parseBoolean(&quot;true&quot;)</code> -&gt; 返回 <code>boolean</code> 类型的 <code>true</code></li>
<li><strong>注意</strong>：如果字符串格式不正确，会抛出 <code>NumberFormatException</code>。</li>
</ul>
</li>
<li><code>valueOf(String s)</code>：将字符串解析为对应的<strong>包装器对象</strong>。<ul>
<li><code>Integer.valueOf(&quot;123&quot;)</code> -&gt; 返回 <code>Integer</code> 对象</li>
<li><code>Double.valueOf(&quot;3.14&quot;)</code> -&gt; 返回 <code>Double</code> 对象</li>
<li>它也利用了缓存机制（对于 Integer，-128~127 会返回缓存对象）。</li>
</ul>
</li>
<li><code>valueOf(String s, int radix)</code>：按指定进制解析字符串。<ul>
<li><code>Integer.valueOf(&quot;FF&quot;, 16)</code> -&gt; 将16进制的 “FF” 解析为 <code>Integer</code> 对象，值为 255。</li>
<li><code>Integer.parseInt(&quot;1010&quot;, 2)</code> -&gt; 将2进制的 “1010” 解析为 <code>int</code>，值为 10。</li>
</ul>
</li>
</ul>
<h5 id="2-创建方法"><a href="#2-创建方法" class="headerlink" title="2. 创建方法"></a>2. 创建方法</h5><ul>
<li><code>valueOf(primitive value)</code>：将基本类型值转换为包装器对象（<strong>自动装箱的本质</strong>）。<ul>
<li><code>Integer.valueOf(10)</code> -&gt; 返回表示 10 的 <code>Integer</code> 对象。</li>
<li><code>Character.valueOf(&#39;A&#39;)</code> -&gt; 返回表示 ‘A’ 的 <code>Character</code> 对象。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-3-3-实例方法（需要对象调用）"><a href="#2-3-3-实例方法（需要对象调用）" class="headerlink" title="2.3.3 实例方法（需要对象调用）"></a>2.3.3 实例方法（需要对象调用）</h4><p>这些方法需要一个包装器类的实例来调用。</p>
<h5 id="1-转换方法：将包装器对象转换为基本类型"><a href="#1-转换方法：将包装器对象转换为基本类型" class="headerlink" title="1. 转换方法：将包装器对象转换为基本类型"></a>1. 转换方法：将包装器对象转换为基本类型</h5><ul>
<li><code>xxxValue()</code>：返回该对象对应的<strong>基本数据类型</strong>值（<strong>自动拆箱的本质</strong>）。<ul>
<li><code>Integer obj = 100; int num = obj.intValue();</code></li>
<li><code>Double obj = 3.14; double d = obj.doubleValue();</code></li>
<li><code>Boolean obj = true; boolean b = obj.booleanValue();</code></li>
</ul>
</li>
</ul>
<h5 id="2-比较方法"><a href="#2-比较方法" class="headerlink" title="2. 比较方法"></a>2. 比较方法</h5><ul>
<li><code>compareTo(AnotherWrapperObj)</code>：比较两个同类型包装器对象的大小。<ul>
<li>返回 <code>int</code> 值：如果当前对象小，返回负数；相等返回0；当前对象大返回正数。</li>
<li><code>Integer a = 10; Integer b = 20; int result = a.compareTo(b); // result &lt; 0</code></li>
</ul>
</li>
</ul>
<h5 id="3-转换为字符串"><a href="#3-转换为字符串" class="headerlink" title="3. 转换为字符串"></a>3. 转换为字符串</h5><ul>
<li><code>toString()</code>：将包装器对象的值转换为 <code>String</code> 对象。<ul>
<li><code>Integer obj = 100; String str = obj.toString(); // &quot;100&quot;</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-3-4-有用的静态常量和工具方法"><a href="#2-3-4-有用的静态常量和工具方法" class="headerlink" title="2.3.4 有用的静态常量和工具方法"></a>2.3.4 有用的静态常量和工具方法</h4><h5 id="1-常用常量"><a href="#1-常用常量" class="headerlink" title="1. 常用常量"></a>1. 常用常量</h5><ul>
<li><code>MIN_VALUE</code>：返回该类型的最小值。<ul>
<li><code>Integer.MIN_VALUE</code> -&gt; <code>-2147483648</code></li>
<li><code>Double.MIN_VALUE</code> -&gt; <strong>最小的正正值</strong> (约 4.9e-324)，注意不是负数。</li>
</ul>
</li>
<li><code>MAX_VALUE</code>：返回该类型的最大值。<ul>
<li><code>Integer.MAX_VALUE</code> -&gt; <code>2147483647</code></li>
<li><code>Double.MAX_VALUE</code> -&gt; 最大值 (约 1.7e+308)</li>
</ul>
</li>
<li><code>SIZE</code>：以位为单位返回该类型的大小。<ul>
<li><code>Integer.SIZE</code> -&gt; <code>32</code></li>
<li><code>Double.SIZE</code> -&gt; <code>64</code></li>
</ul>
</li>
<li><code>TYPE</code>：返回对应的基本类型的 <code>Class</code> 对象（用于反射）。<ul>
<li><code>Integer.TYPE</code> -&gt; <code>int.class</code></li>
<li><code>Double.TYPE</code> -&gt; <code>double.class</code></li>
</ul>
</li>
</ul>
<h5 id="2-工具方法（判断字符属性-Character-类特有）"><a href="#2-工具方法（判断字符属性-Character-类特有）" class="headerlink" title="2. 工具方法（判断字符属性 - Character 类特有）"></a>2. 工具方法（判断字符属性 - <code>Character</code> 类特有）</h5><p><code>Character</code> 类提供了大量静态方法来判断字符的属性，非常实用。</p>
<ul>
<li><code>isDigit(char ch)</code>：判断是否是数字。</li>
<li><code>isLetter(char ch)</code>：判断是否是字母。</li>
<li><code>isLetterOrDigit(char ch)</code>：判断是否是字母或数字。</li>
<li><code>isLowerCase(char ch)</code> &#x2F; <code>isUpperCase(char ch)</code>：判断是否是小写&#x2F;大写。</li>
<li><code>toLowerCase(char ch)</code> &#x2F; <code>toUpperCase(char ch)</code>：转换为小写&#x2F;大写。</li>
<li><code>isWhitespace(char ch)</code>：判断是否是空白字符（空格、换行、制表符等）。</li>
</ul>
<hr>
<h3 id="2-4-数据类型转换"><a href="#2-4-数据类型转换" class="headerlink" title="2.4 数据类型转换"></a>2.4 数据类型转换</h3><h4 id="2-4-1-基本数据类型之间的转换"><a href="#2-4-1-基本数据类型之间的转换" class="headerlink" title="2.4.1 基本数据类型之间的转换"></a>2.4.1 基本数据类型之间的转换</h4><h5 id="1-自动类型转换（隐式转换）"><a href="#1-自动类型转换（隐式转换）" class="headerlink" title="1. 自动类型转换（隐式转换）"></a>1. 自动类型转换（隐式转换）</h5><p>当满足<strong>目标类型范围大于源类型</strong>时，编译器会自动完成转换，无需任何特殊语法。</p>
<p><strong>转换规则（由低到高）：</strong><code>byte</code> -&gt; <code>short</code> -&gt; <code>char</code> -&gt; <code>int</code> -&gt; <code>long</code> -&gt; <code>float</code> -&gt; <code>double</code></p>
<p><strong>注意：</strong></p>
<ul>
<li><code>byte</code>、<code>short</code>、<code>char</code> 三者是平级的，在计算时会<strong>首先自动转换为 <code>int</code></strong> 类型。</li>
<li><code>long</code> 是 64 位，<code>float</code> 是 32 位，但 <code>long</code> 可以自动转为 <code>float</code>，因为浮点数的表示范围更大。</li>
<li><code>整数类型</code> 可以自动转换为 <code>浮点类型</code>，但可能会损失精度（例如，将很大的 <code>long</code> 转换为 <code>float</code>）。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> i;        <span class="comment">// 自动将 int 转换为 long</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> l;       <span class="comment">// 自动将 long 转换为 float</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> f;      <span class="comment">// 自动将 float 转换为 double</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">intFromChar</span> <span class="operator">=</span> c; <span class="comment">// 自动将 char 转换为 int (输出 65, &#x27;A&#x27; 的 ASCII 码)</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-强制类型转换（显式转换）"><a href="#2-强制类型转换（显式转换）" class="headerlink" title="2. 强制类型转换（显式转换）"></a>2. 强制类型转换（显式转换）</h5><p>当需要将<strong>范围大的类型转换为范围小的类型</strong>时，必须进行强制转换。这可能会<strong>导致精度损失或数据溢出</strong>。</p>
<p><strong>语法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(目标类型) 值或变量</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100.04</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> (<span class="type">long</span>) d;   <span class="comment">// 强制将 double 转换为 long, 丢失小数部分 (l = 100)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) l;     <span class="comment">// 强制将 long 转换为 int (i = 100)</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>) i;   <span class="comment">// 强制将 int 转换为 byte (b = 100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据溢出示例</span></span><br><span class="line"><span class="type">int</span> <span class="variable">largeNum</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">smallByte</span> <span class="operator">=</span> (<span class="type">byte</span>) largeNum; <span class="comment">// 300 远超 byte 范围(-128~127), 结果会溢出 (smallByte ≠ 300)</span></span><br><span class="line">System.out.println(smallByte); <span class="comment">// 输出 44 (300 - 256)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数截断示例</span></span><br><span class="line"><span class="type">float</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.14159f</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">intPi</span> <span class="operator">=</span> (<span class="type">int</span>) pi; <span class="comment">// 直接截断小数部分 (intPi = 3)</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-4-2-基本数据类型与包装类之间的转换"><a href="#2-4-2-基本数据类型与包装类之间的转换" class="headerlink" title="2.4.2 基本数据类型与包装类之间的转换"></a>2.4.2 基本数据类型与包装类之间的转换</h4><p>从 Java 5 开始，引入了<strong>自动装箱</strong>和<strong>自动拆箱</strong>机制，使得基本类型和其对应的包装类可以自动转换。</p>
<h5 id="1-自动装箱"><a href="#1-自动装箱" class="headerlink" title="1. 自动装箱"></a>1. 自动装箱</h5><p>基本数据类型自动转换为包装类对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动装箱 (Java 5 之前)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">obj1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 自动装箱 (Java 5 之后)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 编译器自动改为：Integer.valueOf(10)</span></span><br><span class="line"></span><br><span class="line"><span class="type">Double</span> <span class="variable">dObj</span> <span class="operator">=</span> <span class="number">3.14</span>; <span class="comment">// double -&gt; Double</span></span><br><span class="line"><span class="type">Character</span> <span class="variable">cObj</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; <span class="comment">// char -&gt; Character</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-自动拆箱"><a href="#2-自动拆箱" class="headerlink" title="2. 自动拆箱"></a>2. 自动拆箱</h5><p>包装类对象自动转换为基本数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动拆箱 (Java 5 之前)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> obj1.intValue();</span><br><span class="line"><span class="comment">// 自动拆箱 (Java 5 之后)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> obj2; <span class="comment">// 编译器自动改为：obj2.intValue()</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> dObj; <span class="comment">// Double -&gt; double</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> cObj; <span class="comment">// Character -&gt; char</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 自动拆箱时，如果包装类对象为 <code>null</code>，会抛出 <code>NullPointerException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">nullInt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">risk</span> <span class="operator">=</span> nullInt; <span class="comment">// 运行时抛出 NullPointerException</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-4-3-引用数据类型之间的转换（面向对象特性）"><a href="#2-4-3-引用数据类型之间的转换（面向对象特性）" class="headerlink" title="2.4.3 引用数据类型之间的转换（面向对象特性）"></a>2.4.3 引用数据类型之间的转换（面向对象特性）</h4><h5 id="1-向上转型"><a href="#1-向上转型" class="headerlink" title="1. 向上转型"></a>1. 向上转型</h5><p>将子类对象赋值给父类引用。这是安全的，编译器自动完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 Dog 类继承自 Animal 类</span></span><br><span class="line"><span class="type">Dog</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="type">Animal</span> <span class="variable">myAnimal</span> <span class="operator">=</span> myDog; <span class="comment">// 向上转型：Dog -&gt; Animal (自动)</span></span><br></pre></td></tr></table></figure>

<h5 id="2-向下转型"><a href="#2-向下转型" class="headerlink" title="2. 向下转型"></a>2. 向下转型</h5><p>将父类引用赋值给子类引用。这<strong>不安全</strong>，必须进行<strong>显式强制转换</strong>，并且可能在运行时抛出 <code>ClassCastException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">someAnimal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="comment">// 我们需要显式地告诉编译器：“我知道它实际上是只Dog”</span></span><br><span class="line"><span class="type">Dog</span> <span class="variable">myDogAgain</span> <span class="operator">=</span> (Dog) someAnimal; <span class="comment">// 向下转型：Animal -&gt; Dog (强制)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例：运行时异常</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">catAnimal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); <span class="comment">// 假设Cat也继承自Animal</span></span><br><span class="line"><span class="type">Dog</span> <span class="variable">wrongDog</span> <span class="operator">=</span> (Dog) catAnimal; <span class="comment">// 编译通过，但运行时会抛出 ClassCastException</span></span><br></pre></td></tr></table></figure>

<p><strong>安全的向下转型：</strong> 在转型前使用 <code>instanceof</code> 运算符进行检查。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someAnimal <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">safeDog</span> <span class="operator">=</span> (Dog) someAnimal; <span class="comment">// 安全的转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-4-4-与-String-类型的转换"><a href="#2-4-4-与-String-类型的转换" class="headerlink" title="2.4.4 与 String 类型的转换"></a>2.4.4 与 String 类型的转换</h4><h5 id="1-其他类型-String"><a href="#1-其他类型-String" class="headerlink" title="1. 其他类型 -&gt; String"></a>1. 其他类型 -&gt; String</h5><ul>
<li><p><strong>字符串连接</strong>：最简单的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + num; <span class="comment">// &quot;100&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>String.valueOf()</code> 方法</strong>：推荐方式，清晰高效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.valueOf(<span class="number">100</span>); <span class="comment">// &quot;100&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> String.valueOf(<span class="number">3.14</span>); <span class="comment">// &quot;3.14&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> String.valueOf(<span class="literal">true</span>); <span class="comment">// &quot;true&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用包装类的 <code>toString()</code> 方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> obj.toString(); <span class="comment">// &quot;200&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-String-其他类型"><a href="#2-String-其他类型" class="headerlink" title="2. String -&gt; 其他类型"></a>2. String -&gt; 其他类型</h5><ul>
<li><p><strong>使用包装类的 <code>parseXxx()</code> 方法</strong>：将字符串转换为<strong>基本数据类型</strong>（最常用）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(str); <span class="comment">// String -&gt; int</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Double.parseDouble(<span class="string">&quot;3.14&quot;</span>); <span class="comment">// String -&gt; double</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>); <span class="comment">// String -&gt; boolean</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用包装类的 <code>valueOf()</code> 方法</strong>：将字符串转换为<strong>包装类对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">obj</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;123&quot;</span>); <span class="comment">// String -&gt; Integer</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意：</strong> 如果字符串格式不正确，会抛出 <code>NumberFormatException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">error</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 抛出 NumberFormatException</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="2-4-5-总结与建议"><a href="#2-4-5-总结与建议" class="headerlink" title="2.4.5 总结与建议"></a>2.4.5 总结与建议</h4><table>
<thead>
<tr>
<th align="left">转换类型</th>
<th align="left">方式</th>
<th align="left">关键点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>基本类型间</strong></td>
<td align="left">自动转换 &#x2F; 强制转换</td>
<td align="left">注意范围和数据精度，大转小要强转，可能丢失数据。</td>
</tr>
<tr>
<td align="left"><strong>与包装类</strong></td>
<td align="left">自动装箱 &#x2F; 自动拆箱</td>
<td align="left">注意 <code>null</code> 值拆箱会引发 <code>NullPointerException</code>。</td>
</tr>
<tr>
<td align="left"><strong>引用类型间</strong></td>
<td align="left">向上转型 &#x2F; 向下转型</td>
<td align="left">向下转型不安全，必须用 <code>instanceof</code> 提前检查。</td>
</tr>
<tr>
<td align="left"><strong>与 String</strong></td>
<td align="left"><code>String.valueOf()</code> &#x2F; <code>parseXxx()</code></td>
<td align="left"><strong>最常用</strong>。转换失败会抛出 <code>NumberFormatException</code>。</td>
</tr>
</tbody></table>
<p><strong>最佳实践：</strong></p>
<ul>
<li>进行强制转换前，先确认数据范围是否在目标类型内。</li>
<li>拆箱前，先判断包装类对象是否为 <code>null</code>。</li>
<li>向下转型前，务必使用 <code>instanceof</code> 进行类型检查。</li>
<li>字符串转数字时，做好异常处理（<code>try-catch</code>）。</li>
</ul>
<hr>
<hr>
<h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h2><h3 id="3-1-算数运算符"><a href="#3-1-算数运算符" class="headerlink" title="3.1 算数运算符"></a>3.1 算数运算符</h3><p>用于执行基本的数学运算。</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">示例 (假设 <code>int a = 10, b = 3</code>)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>+</code></td>
<td align="left">加法</td>
<td align="left"><code>a + b = 13</code></td>
</tr>
<tr>
<td align="left"><code>-</code></td>
<td align="left">减法</td>
<td align="left"><code>a - b = 7</code></td>
</tr>
<tr>
<td align="left"><code>*</code></td>
<td align="left">乘法</td>
<td align="left"><code>a * b = 30</code></td>
</tr>
<tr>
<td align="left"><code>/</code></td>
<td align="left">除法</td>
<td align="left"><code>a / b = 3</code> (整数除法会截断小数部分)</td>
</tr>
<tr>
<td align="left"><code>%</code></td>
<td align="left">取模（求余数）</td>
<td align="left"><code>a % b = 1</code></td>
</tr>
<tr>
<td align="left"><code>++</code></td>
<td align="left"><strong>自增</strong>：操作数的值增加 1</td>
<td align="left"><code>a++</code> (后自增，先取值后加1) 或 <code>++a</code> (先自增，先加1后取值)</td>
</tr>
<tr>
<td align="left"><code>--</code></td>
<td align="left"><strong>自减</strong>：操作数的值减少 1</td>
<td align="left"><code>a--</code> (后自减) 或 <code>--a</code> (先自减)</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> </p>
<p><code>+</code> 运算符在操作字符串时，用作<strong>字符串连接符</strong>（如 <code>&quot;Hello&quot; + &quot;World&quot;</code>）。</p>
<p>整型和整型的运算结果就是整型，只要出现浮点型结果就是浮点型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当浮点数除以 0 的时候，结果为 Infinity 或者 NaN。</span></span><br><span class="line">System.out.println(<span class="number">10.0</span> / <span class="number">0.0</span>); <span class="comment">// Infinity 无穷大</span></span><br><span class="line">System.out.println(<span class="number">0.0</span> / <span class="number">0.0</span>); <span class="comment">// NaN 这不是一个数字（Not a Number）\</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当整数除以 0 的时候（10 / 0），会抛出异常</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ArithmeticException: / by zero</span><br><span class="line">	at com.itwanger.eleven.ArithmeticOperator.main(ArithmeticOperator.java:<span class="number">32</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-2-关系运算符"><a href="#3-2-关系运算符" class="headerlink" title="3.2 关系运算符"></a>3.2 关系运算符</h3><p>用于比较两个值之间的关系，返回一个布尔值 (<code>true</code> 或 <code>false</code>)。</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">示例 (<code>int a = 10, b = 20</code>)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>==</code></td>
<td align="left">检查两个操作数的值是否<strong>相等</strong></td>
<td align="left"><code>(a == b) → false</code></td>
</tr>
<tr>
<td align="left"><code>!=</code></td>
<td align="left">检查两个操作数的值是否<strong>不相等</strong></td>
<td align="left"><code>(a != b) → true</code></td>
</tr>
<tr>
<td align="left"><code>&gt;</code></td>
<td align="left">检查左操作数是否<strong>大于</strong>右操作数</td>
<td align="left"><code>(a &gt; b) → false</code></td>
</tr>
<tr>
<td align="left"><code>&lt;</code></td>
<td align="left">检查左操作数是否<strong>小于</strong>右操作数</td>
<td align="left"><code>(a &lt; b) → true</code></td>
</tr>
<tr>
<td align="left"><code>&gt;=</code></td>
<td align="left">检查左操作数是否<strong>大于或等于</strong>右操作数</td>
<td align="left"><code>(a &gt;= b) → false</code></td>
</tr>
<tr>
<td align="left"><code>&lt;=</code></td>
<td align="left">检查左操作数是否<strong>小于或等于</strong>右操作数</td>
<td align="left"><code>(a &lt;= b) → true</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="3-3-位运算符"><a href="#3-3-位运算符" class="headerlink" title="3.3 位运算符"></a>3.3 位运算符</h3><p>用于操作整数类型 (<code>int</code>, <code>long</code>, <code>short</code>, <code>char</code>, <code>byte</code>) 的二进制位。</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">示例 (<code>int a = 60; // 二进制: 0011 1100</code>)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&amp;</code></td>
<td align="left"><strong>按位与</strong>：如果相对应位都是 1，则结果为 1，否则为 0。</td>
<td align="left"><code>a &amp; 13</code> (二进制 0000 1101) &#x3D; <code>12</code> (0000 1100)</td>
</tr>
<tr>
<td align="left">&#96;</td>
<td align="left">&#96;</td>
<td align="left"><strong>按位或</strong>：如果相对应位都是 0，则结果为 0，否则为 1。</td>
</tr>
<tr>
<td align="left"><code>^</code></td>
<td align="left"><strong>按位异或</strong>：如果相对应位值相同，则结果为 0，否则为 1。</td>
<td align="left"><code>a ^ 13</code> &#x3D; <code>49</code> (0011 0001)</td>
</tr>
<tr>
<td align="left"><code>~</code></td>
<td align="left"><strong>按位取反</strong>：翻转操作数的每一位，即 0 变 1，1 变 0。</td>
<td align="left"><code>~a</code> &#x3D; <code>-61</code> (1100 0011)</td>
</tr>
<tr>
<td align="left"><code>&lt;&lt;</code></td>
<td align="left"><strong>左移</strong>：将位向左移动指定的位数，低位补 0。</td>
<td align="left"><code>a &lt;&lt; 2</code> &#x3D; <code>240</code> (1111 0000)</td>
</tr>
<tr>
<td align="left"><code>&gt;&gt;</code></td>
<td align="left"><strong>带符号右移</strong>：将位向右移动指定的位数，高位用符号位填充。</td>
<td align="left"><code>a &gt;&gt; 2</code> &#x3D; <code>15</code> (0000 1111)</td>
</tr>
<tr>
<td align="left"><code>&gt;&gt;&gt;</code></td>
<td align="left"><strong>无符号右移</strong>：将位向右移动指定的位数，高位补 0。</td>
<td align="left"><code>a &gt;&gt;&gt; 2</code> &#x3D; <code>15</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h3><p>用于操作布尔表达式，通常用于构建复杂的条件判断。</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">示例 (<code>boolean x = true, y = false</code>)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&amp;&amp;</code></td>
<td align="left"><strong>逻辑与</strong> (短路与)。当且仅当两个操作数都为 true，结果才为 true。如果第一个为 false，则不再计算第二个。</td>
<td align="left"><code>(x &amp;&amp; y) → false</code></td>
</tr>
<tr>
<td align="left">&#96;</td>
<td align="left"></td>
<td align="left">&#96;</td>
</tr>
<tr>
<td align="left"><code>!</code></td>
<td align="left"><strong>逻辑非</strong>。用来反转操作数的逻辑状态。</td>
<td align="left"><code>!x → false</code></td>
</tr>
</tbody></table>
<p><strong>注意：</strong> <code>&amp;</code> (按位与) 和 <code>|</code> (按位或) 也可以用于布尔运算，但它们<strong>不会短路</strong>，即两边表达式都会被执行。</p>
<hr>
<h3 id="3-5-赋值运算符"><a href="#3-5-赋值运算符" class="headerlink" title="3.5 赋值运算符"></a>3.5 赋值运算符</h3><p>用于为变量赋值。</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">示例</th>
<th align="left">等价于</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>=</code></td>
<td align="left"><code>c = a + b</code></td>
<td align="left">将 <code>a + b</code> 的值赋给 <code>c</code></td>
</tr>
<tr>
<td align="left"><code>+=</code></td>
<td align="left"><code>a += b</code></td>
<td align="left"><code>a = a + b</code></td>
</tr>
<tr>
<td align="left"><code>-=</code></td>
<td align="left"><code>a -= b</code></td>
<td align="left"><code>a = a - b</code></td>
</tr>
<tr>
<td align="left"><code>*=</code></td>
<td align="left"><code>a *= b</code></td>
<td align="left"><code>a = a * b</code></td>
</tr>
<tr>
<td align="left"><code>/=</code></td>
<td align="left"><code>a /= b</code></td>
<td align="left"><code>a = a / b</code></td>
</tr>
<tr>
<td align="left"><code>%=</code></td>
<td align="left"><code>a %= b</code></td>
<td align="left"><code>a = a % b</code></td>
</tr>
<tr>
<td align="left"><code>&amp;=</code></td>
<td align="left"><code>a &amp;= b</code></td>
<td align="left"><code>a = a &amp; b</code></td>
</tr>
<tr>
<td align="left">&#96;</td>
<td align="left">&#x3D;&#96;</td>
<td align="left">&#96;a</td>
</tr>
<tr>
<td align="left"><code>^=</code></td>
<td align="left"><code>a ^= b</code></td>
<td align="left"><code>a = a ^ b</code></td>
</tr>
<tr>
<td align="left"><code>&lt;&lt;=</code></td>
<td align="left"><code>a &lt;&lt;= 2</code></td>
<td align="left"><code>a = a &lt;&lt; 2</code></td>
</tr>
<tr>
<td align="left"><code>&gt;&gt;=</code></td>
<td align="left"><code>a &gt;&gt;= 2</code></td>
<td align="left"><code>a = a &gt;&gt; 2</code></td>
</tr>
<tr>
<td align="left"><code>&gt;&gt;&gt;=</code></td>
<td align="left"><code>a &gt;&gt;&gt;= 2</code></td>
<td align="left"><code>a = a &gt;&gt;&gt; 2</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="3-6-三元运算符"><a href="#3-6-三元运算符" class="headerlink" title="3.6 三元运算符"></a>3.6 三元运算符</h3><p><code>variable = (condition) ? expression1 : expression2</code></p>
<p>这是唯一一个需要三个操作数的运算符。如果 condition 为 true，则将 expression1 的值赋给变量；否则将 expression2 的值赋给变量。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">75</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (score &gt; <span class="number">60</span>) ? <span class="string">&quot;及格&quot;</span> : <span class="string">&quot;不及格&quot;</span>; <span class="comment">// result 的值为 &quot;及格&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-7-instanceof-运算符"><a href="#3-7-instanceof-运算符" class="headerlink" title="3.7 instanceof 运算符"></a>3.7 instanceof 运算符</h3><p>用于检查对象是否是一个特定类（或接口）的实例。返回布尔值。</p>
<p><strong>语法：</strong> <code>(objectReference) instanceof (Class/Interface)</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isString</span> <span class="operator">=</span> name <span class="keyword">instanceof</span> String; <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-8-运算符优先级"><a href="#3-8-运算符优先级" class="headerlink" title="3.8 运算符优先级"></a>3.8 运算符优先级</h3><p>当多个运算符出现在一个表达式中时，谁先谁后呢？这就由运算符的优先级决定。优先级高的先运算。不确定时，使用小括号 <code>()</code> 来明确指定计算顺序是最佳实践，也能增加代码的可读性。</p>
<p>从高到低的大致顺序（最上面最高）：</p>
<ol>
<li><strong>后缀</strong>：<code>expr++</code>, <code>expr--</code></li>
<li><strong>一元</strong>：<code>++expr</code>, <code>--expr</code>, <code>+expr</code>, <code>-expr</code>, <code>~</code>, <code>!</code></li>
<li><strong>乘性</strong>：<code>*</code>, <code>/</code>, <code>%</code></li>
<li><strong>加性</strong>：<code>+</code>, <code>-</code></li>
<li><strong>移位</strong>：<code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code></li>
<li><strong>关系</strong>：<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>instanceof</code></li>
<li><strong>相等</strong>：<code>==</code>, <code>!=</code></li>
<li><strong>按位与</strong>：<code>&amp;</code></li>
<li><strong>按位异或</strong>：<code>^</code></li>
<li><strong>按位或</strong>：<code>|</code></li>
<li><strong>逻辑与</strong>：<code>&amp;&amp;</code></li>
<li><strong>逻辑或</strong>：<code>||</code></li>
<li><strong>三元</strong>：<code>? :</code></li>
<li><strong>赋值</strong>：<code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&amp;=</code>, <code>^=</code>, <code>|=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&gt;&gt;&gt;=</code></li>
</ol>
<hr>
<hr>
<h2 id="4-流程控制语句"><a href="#4-流程控制语句" class="headerlink" title="4. 流程控制语句"></a>4. 流程控制语句</h2><h3 id="4-1-条件分支语句-Conditional-Branching-Statements"><a href="#4-1-条件分支语句-Conditional-Branching-Statements" class="headerlink" title="4.1 条件分支语句 (Conditional Branching Statements)"></a>4.1 条件分支语句 (Conditional Branching Statements)</h3><p>这类语句根据条件的真假（布尔表达式）来决定执行哪一部分代码。</p>
<h4 id="4-1-1-if-语句"><a href="#4-1-1-if-语句" class="headerlink" title="4.1.1 if 语句"></a>4.1.1 <code>if</code> 语句</h4><p>最基本的条件判断，如果条件为 <code>true</code>，则执行代码块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 当 condition 为 true 时执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-1-2-if-else-语句"><a href="#4-1-2-if-else-语句" class="headerlink" title="4.1.2 if...else 语句"></a>4.1.2 <code>if...else</code> 语句</h4><p>在 <code>if</code> 的基础上增加了一个分支，当条件为 <code>false</code> 时执行 <code>else</code> 后的代码块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 当 condition 为 true 时执行的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当 condition 为 false 时执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-1-3-if-else-if-else-语句"><a href="#4-1-3-if-else-if-else-语句" class="headerlink" title="4.1.3 if...else if...else 语句"></a>4.1.3 <code>if...else if...else</code> 语句</h4><p>用于处理多个条件分支，按顺序检查条件，一旦某个条件为 <code>true</code>，就执行对应的代码块，并跳过其余分支。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">    <span class="comment">// 当 condition1 为 true 时执行的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">    <span class="comment">// 当 condition2 为 true 时执行的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当所有 above conditions 都为 false 时执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-1-4-switch-语句"><a href="#4-1-4-switch-语句" class="headerlink" title="4.1.4 switch 语句"></a>4.1.4 <code>switch</code> 语句</h4><p>基于一个变量或表达式的值来选择要执行的代码块。它比一长串的 <code>if...else if</code> 语句更清晰，尤其适用于多路分支。</p>
<p><strong>传统语法 (Java 12 之前):</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">        <span class="comment">// 代码块 1</span></span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// break 关键字用于跳出 switch，防止“穿透”</span></span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">        <span class="comment">// 代码块 2</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// 可选的，当所有 case 都不匹配时执行</span></span><br><span class="line">        <span class="comment">// 默认代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>注意：传统语法中如果缺少 <code>break</code>，会发生“case 穿透”，即会继续执行下一个 <code>case</code> 的代码，直到遇到 <code>break</code> 或结束。</em></p>
<p><strong>增强语法 (Java 12+ 的 <code>switch</code> 表达式):</strong></p>
<p>Java 12 引入了更简洁、更安全的 <code>switch</code> 表达式，使用箭头 <code>-&gt;</code> 语法，避免了穿透问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为表达式使用（返回一个值）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">dayNumber</span> <span class="operator">=</span> <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;MON&quot;</span>, <span class="string">&quot;TUE&quot;</span>, <span class="string">&quot;WED&quot;</span>, <span class="string">&quot;THU&quot;</span>, <span class="string">&quot;FRI&quot;</span> -&gt; <span class="number">1</span>; <span class="comment">// 多值匹配，直接返回值</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;SAT&quot;</span>, <span class="string">&quot;SUN&quot;</span> -&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Invalid day&quot;</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">0</span>; <span class="comment">// 对于代码块，使用 yield 来返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为语句使用</span></span><br><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;MON&quot;</span> -&gt; System.out.println(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;TUE&quot;</span> -&gt; System.out.println(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;其他天&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2-循环语句-Loop-Statements"><a href="#4-2-循环语句-Loop-Statements" class="headerlink" title="4.2 循环语句 (Loop Statements)"></a>4.2 循环语句 (Loop Statements)</h3><p>用于重复执行一段代码，直到满足终止条件。</p>
<h4 id="4-2-1-for-循环"><a href="#4-2-1-for-循环" class="headerlink" title="4.2.1 for 循环"></a>4.2.1 <code>for</code> 循环</h4><p>已知循环次数的首选。它将初始化、循环条件和迭代操作都写在一行，结构非常清晰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; update) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：打印 0 到 4</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>增强 <code>for</code> 循环 (for-each loop):</strong></p>
<p>用于遍历数组或集合（如 <code>List</code>, <code>Set</code>）中的所有元素，无需使用索引，更简洁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (elementType element : collection) &#123;</span><br><span class="line">    <span class="comment">// 使用 element</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：遍历数组</span></span><br><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-2-while-循环"><a href="#4-2-2-while-循环" class="headerlink" title="4.2.2 while 循环"></a>4.2.2 <code>while</code> 循环</h4><p>只要条件为 <code>true</code>，就继续执行循环。<strong>先判断条件，后执行循环体</strong>。适用于循环次数不确定的场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    System.out.println(count);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-3-do-while-循环"><a href="#4-2-3-do-while-循环" class="headerlink" title="4.2.3 do...while 循环"></a>4.2.3 <code>do...while</code> 循环</h4><p>与 <code>while</code> 类似，但<strong>先执行一次循环体，再判断条件</strong>。因此，循环体<strong>至少会执行一次</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(count);</span><br><span class="line">    count++;</span><br><span class="line">&#125; <span class="keyword">while</span> (count &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-跳转语句-Branching-Statements-Control-Transfer-Statements"><a href="#4-3-跳转语句-Branching-Statements-Control-Transfer-Statements" class="headerlink" title="4.3 跳转语句 (Branching Statements &#x2F; Control Transfer Statements)"></a>4.3 跳转语句 (Branching Statements &#x2F; Control Transfer Statements)</h3><p>用于改变程序正常的执行流程。</p>
<h4 id="4-3-1-break-语句"><a href="#4-3-1-break-语句" class="headerlink" title="4.3.1 break 语句"></a>4.3.1 <code>break</code> 语句</h4><ul>
<li><strong>在循环中</strong>：立即终止整个循环，跳出循环体，执行循环后面的语句。</li>
<li><strong>在 <code>switch</code> 中</strong>：终止一个 <code>case</code>，防止“穿透”。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 for 循环中使用 break</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 当 i 等于 5 时，终止循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i); <span class="comment">// 只会打印 0 到 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>带标签的 <code>break</code> (Labeled Break):</strong></p>
<p>可以跳出到指定的标签处，用于跳出多层嵌套循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">outerLoop: <span class="comment">// 这是一个标签</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i * j &gt; <span class="number">6</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Breaking outerLoop&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span> outerLoop; <span class="comment">// 直接跳出外层循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-2-continue-语句"><a href="#4-3-2-continue-语句" class="headerlink" title="4.3.2 continue 语句"></a>4.3.2 <code>continue</code> 语句</h4><p>立即<strong>跳过当前循环的剩余语句</strong>，直接进行下一次循环的迭代（<code>for</code> 循环会先执行 <code>update</code> 部分）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印 0 到 9 中的所有奇数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 如果是偶数</span></span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 跳过本次循环的后续代码，直接 i++</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>带标签的 <code>continue</code> (Labeled Continue):</strong></p>
<p>跳过标签所指定循环的当前迭代，直接开始下一次迭代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">outerLoop:</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span> outerLoop; <span class="comment">// 当 j==1 时，直接跳到外层循环的 i++ 处</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot;, j=&quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// i=0, j=0</span></span><br><span class="line"><span class="comment">// i=1, j=0</span></span><br><span class="line"><span class="comment">// i=2, j=0</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-3-return-语句"><a href="#4-3-3-return-语句" class="headerlink" title="4.3.3 return 语句"></a>4.3.3 <code>return</code> 语句</h4><p><strong>用于方法中</strong>。它有两个作用：</p>
<ol>
<li>退出当前方法，并将控制权返回给方法的调用者。</li>
<li>optionally 返回一个值给调用者（如果方法声明了返回类型而非 <code>void</code>）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b; <span class="comment">// 返回 a+b 的值，并结束本方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printIfPositive</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 提前结束方法，不返回任何值（void）</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-4-实际应用"><a href="#4-4-实际应用" class="headerlink" title="4.4 实际应用"></a>4.4 实际应用</h3><h4 id="4-4-1-if与Switch"><a href="#4-4-1-if与Switch" class="headerlink" title="4.4.1 if与Switch"></a>4.4.1 if与Switch</h4><h5 id="1-何时选择-if-else？"><a href="#1-何时选择-if-else？" class="headerlink" title="1. 何时选择 if-else？"></a>1. 何时选择 <code>if-else</code>？</h5><ul>
<li><strong>进行非等值判断时</strong>：例如范围判断（<code>if (score &gt;= 90)</code>）、布尔条件判断（<code>if (value == null)</code>）、逻辑组合（<code>if (age &gt; 18 &amp;&amp; isCitizen)</code>）。</li>
<li><strong>分支数量很少时</strong>：通常只有一两个分支时，<code>if (condition) {...} else {...}</code> 是最简单、最直接的选择，代码量比 <code>switch</code> 更少。</li>
<li><strong>条件非常灵活或复杂时</strong>：当你的判断无法用一个单一的变量值来表示时，<code>if-else</code> 是唯一的选择。</li>
</ul>
<p><strong>示例：适合 if-else 的场景</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 范围判断 - 必须用 if</span></span><br><span class="line"><span class="keyword">if</span> (temperature &gt; <span class="number">35</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;高温警告&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temperature &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;低温警告&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;温度正常&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 复杂布尔逻辑 - 必须用 if</span></span><br><span class="line"><span class="keyword">if</span> (file != <span class="literal">null</span> &amp;&amp; file.exists() &amp;&amp; file.isReadable()) &#123;</span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 分支数少（只有2个） - 用 if 更简洁</span></span><br><span class="line"><span class="keyword">if</span> (isAdmin) &#123;</span><br><span class="line">    showAdminPanel();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    showUserPanel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-何时选择-switch？"><a href="#2-何时选择-switch？" class="headerlink" title="2. 何时选择 switch？"></a>2. 何时选择 <code>switch</code>？</h5><ul>
<li><strong>基于单个变量进行等值判断，且分支较多时</strong>：这是 <code>switch</code> 的绝对优势领域。一旦分支数超过 3 个，<code>switch</code> 在<strong>可读性</strong>和<strong>性能</strong>上的优势就会显现出来。</li>
<li><strong>枚举（Enum）类型判断时</strong>：<code>switch</code> 与 <code>enum</code> 是天生绝配，代码清晰易懂。</li>
<li><strong>追求更清晰的代码结构时</strong>：一长串的 <code>if-else if</code> 语句难以阅读和维护，而 <code>switch</code> 将所有可能的值一目了然地列出来。</li>
</ul>
<p><strong>示例：适合 switch 的场景</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 多路分支（基于枚举） - 用 switch 更清晰</span></span><br><span class="line"><span class="type">DayOfWeek</span> <span class="variable">day</span> <span class="operator">=</span> DayOfWeek.MONDAY;</span><br><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">    <span class="keyword">case</span> THURSDAY:</span><br><span class="line">    <span class="keyword">case</span> FRIDAY:</span><br><span class="line">        System.out.println(<span class="string">&quot;工作日&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SATURDAY:</span><br><span class="line">    <span class="keyword">case</span> SUNDAY:</span><br><span class="line">        System.out.println(<span class="string">&quot;休息日&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 现代 switch 表达式 (JDK 12+) - 推荐！更安全简洁</span></span><br><span class="line"><span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;A&quot;</span> -&gt; <span class="string">&quot;类型是 A&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;B&quot;</span> -&gt; <span class="string">&quot;类型是 B&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;C&quot;</span> -&gt; <span class="string">&quot;类型是 C&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="string">&quot;未知类型&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="3-相结合"><a href="#3-相结合" class="headerlink" title="3.  相结合"></a>3.  相结合</h5><p>有时会看到一些奇奇怪怪的写法，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设90%的情况下 color == Color.RED</span></span><br><span class="line"><span class="keyword">if</span> (color == Color.RED) &#123; <span class="comment">// &lt;--- 热点路径 (Hot Path)</span></span><br><span class="line">    System.out.println(<span class="string">&quot;RED&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// &lt;--- 冷点路径 (Cold Path)</span></span><br><span class="line">    <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">        <span class="comment">// ... 其他情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在分支预测下，用 <code>if</code> 处理热点路径（Hot Path），剩下的交给 <code>switch</code>，这样能兼顾性能和可读性。</strong></p>
<p><strong>这个写法在理论上是完全正确的，并且是一种经典的性能优化模式，称为“快慢路径分离”（Fast Path &#x2F; Slow Path Separation）。但在现代Java环境下，我们需要更深入地探讨它的实际效果。</strong></p>
<p><strong>分支预测（Branch Prediction）</strong></p>
<p>CPU为了提高效率，使用了指令流水线技术。它会提前加载并处理多条指令。当遇到一个分支（如 <code>if</code>）时，CPU不知道该走哪条路，它会进行“猜测”。</p>
<ul>
<li><strong>猜测正确</strong>：流水线继续顺畅执行，速度极快。</li>
<li><strong>猜测错误（Branch Misprediction）</strong>：CPU必须丢弃已经加载的错误分支的指令，清空流水线，然后重新加载正确分支的指令。这个过程会带来几十个时钟周期的惩罚（Penalty），在性能敏感的场景下是很大的开销。</li>
</ul>
<p>从纯粹的硬件和算法角度看，这种写法是无可挑剔的。</p>
<p>然而，在Java世界里，我们写的代码和最终在CPU上执行的机器码之间还隔着一个非常智能的 <strong>JIT（Just-In-Time）编译器</strong>。</p>
<p>JIT编译器会在运行时分析你的代码，找出热点代码，并进行深度优化。它有几种武器可能会让你的手动优化变得“多此一举”。</p>
<p><strong>(1) JIT的性能分析优化（Profile-Guided Optimization）</strong></p>
<p>JIT会监控你的代码运行情况。对于下面这个更“自然”的<code>switch</code>写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更常见的写法</span></span><br><span class="line"><span class="keyword">switch</span> (color) &#123;</span><br><span class="line">    <span class="keyword">case</span> RED -&gt; System.out.println(<span class="string">&quot;RED&quot;</span>);     <span class="comment">// JIT发现这个case是热点</span></span><br><span class="line">    <span class="keyword">case</span> GREEN -&gt; System.out.println(<span class="string">&quot;GREEN&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> BLUE -&gt; System.out.println(<span class="string">&quot;BLUE&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;UNKNOWN&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JIT在运行中会发现 <code>case RED</code> 的执行频率远高于其他分支。在编译成机器码时，<strong>它可能会自动地将这个 <code>switch</code> 结构重排成类似你写的 <code>if-else</code> 的形式！</strong> 也就是说，JIT可能会生成类似这样的机器码逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (color == RED) &#123; ... &#125; <span class="keyword">else</span> &#123; check <span class="keyword">for</span> GREEN, BLUE... &#125;</span><br></pre></td></tr></table></figure>

<p>JIT非常擅长做这种基于实际运行情况的优化。</p>
<p><strong>(2) <code>switch</code> 本身的优化</strong></p>
<ul>
<li><strong>tableswitch</strong>：如果你的 <code>case</code> 值是连续的（或接近连续的），编译器会生成一个“跳转表”。这是一种O(1)复杂度的操作，直接根据值在表里找到地址跳转过去，速度极快，几乎没有分支。</li>
<li><strong>lookupswitch</strong>：如果 <code>case</code> 值比较稀疏，编译器会生成一个类似二分查找的结构，复杂度是O(log n)，也比一长串 <code>if-else if</code> 要快。</li>
</ul>
<p>在你这个 <code>enum</code> 的例子中，<code>enum</code> 的 <code>ordinal()</code> 值是连续的整数，JIT极大概率会将其优化为 <code>tableswitch</code>，其本身性能就非常好。</p>
<hr>
<h5 id="总结与最佳实践"><a href="#总结与最佳实践" class="headerlink" title="总结与最佳实践"></a>总结与最佳实践</h5><ol>
<li><strong>首要考虑条件类型</strong>：<strong>等值判断</strong>考虑 <code>switch</code>，<strong>非等值或复杂判断</strong>只能用 <code>if-else</code>。</li>
<li><strong>分支数量是关键</strong>：<strong>1-2 个分支</strong>用 <code>if-else</code> 通常更直接；<strong>3 个及以上分支</strong>的等值判断，强烈推荐使用 <code>switch</code>，尤其是现代 <code>switch</code> 表达式。</li>
<li><strong>优先使用现代 <code>switch</code> 表达式</strong>：如果你使用的是 Java 12 及以上版本，在处理多路分支时，应优先选择 <code>switch</code> 表达式。它更安全（无穿透问题）、更简洁（箭头语法）、更强大（可以直接返回值）。</li>
<li><strong>可读性是终极目标</strong>：写代码不仅要让机器能执行，更要让人能轻松读懂。<code>switch</code> 在处理多路分支时，结构化的列表远比一长串 <code>if-else if</code> 更具可读性。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">冉丝堂</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
